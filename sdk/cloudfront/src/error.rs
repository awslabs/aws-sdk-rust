// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type UpdateStreamingDistributionErrorKind = UpdateStreamingDistributionError;
/// Error type for the `UpdateStreamingDistributionError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateStreamingDistributionError {
    /// <p>Access denied.</p>
    AccessDenied(crate::error::AccessDenied),
    /// <p>The CNAME specified is already defined for CloudFront.</p>
    CnameAlreadyExists(crate::error::CnameAlreadyExists),
    /// <p>The update contains modifications that are not allowed.</p>
    IllegalUpdate(crate::error::IllegalUpdate),
    /// <p>The value of <code>Quantity</code> and the size of <code>Items</code> don't match.</p>
    InconsistentQuantities(crate::error::InconsistentQuantities),
    /// <p>An argument is invalid.</p>
    InvalidArgument(crate::error::InvalidArgument),
    /// <p>The <code>If-Match</code> version is missing or not valid.</p>
    InvalidIfMatchVersion(crate::error::InvalidIfMatchVersion),
    /// <p>The origin access control is not valid.</p>
    InvalidOriginAccessControl(crate::error::InvalidOriginAccessControl),
    /// <p>The origin access identity is not valid or doesn't exist.</p>
    InvalidOriginAccessIdentity(crate::error::InvalidOriginAccessIdentity),
    /// <p>This operation requires a body. Ensure that the body is present and the <code>Content-Type</code> header is set.</p>
    MissingBody(crate::error::MissingBody),
    /// <p>The specified streaming distribution does not exist.</p>
    NoSuchStreamingDistribution(crate::error::NoSuchStreamingDistribution),
    /// <p>The precondition in one or more of the request fields evaluated to <code>false</code>.</p>
    PreconditionFailed(crate::error::PreconditionFailed),
    /// <p>Your request contains more CNAMEs than are allowed per distribution.</p>
    TooManyStreamingDistributionCnamEs(crate::error::TooManyStreamingDistributionCnamEs),
    /// <p>Your request contains more trusted signers than are allowed per distribution.</p>
    TooManyTrustedSigners(crate::error::TooManyTrustedSigners),
    /// <p>One or more of your trusted signers don't exist.</p>
    TrustedSignerDoesNotExist(crate::error::TrustedSignerDoesNotExist),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for UpdateStreamingDistributionError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for UpdateStreamingDistributionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AccessDenied(_inner) => _inner.fmt(f),
            Self::CnameAlreadyExists(_inner) => _inner.fmt(f),
            Self::IllegalUpdate(_inner) => _inner.fmt(f),
            Self::InconsistentQuantities(_inner) => _inner.fmt(f),
            Self::InvalidArgument(_inner) => _inner.fmt(f),
            Self::InvalidIfMatchVersion(_inner) => _inner.fmt(f),
            Self::InvalidOriginAccessControl(_inner) => _inner.fmt(f),
            Self::InvalidOriginAccessIdentity(_inner) => _inner.fmt(f),
            Self::MissingBody(_inner) => _inner.fmt(f),
            Self::NoSuchStreamingDistribution(_inner) => _inner.fmt(f),
            Self::PreconditionFailed(_inner) => _inner.fmt(f),
            Self::TooManyStreamingDistributionCnamEs(_inner) => _inner.fmt(f),
            Self::TooManyTrustedSigners(_inner) => _inner.fmt(f),
            Self::TrustedSignerDoesNotExist(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for UpdateStreamingDistributionError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AccessDenied(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::CnameAlreadyExists(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::IllegalUpdate(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InconsistentQuantities(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidArgument(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidIfMatchVersion(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidOriginAccessControl(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidOriginAccessIdentity(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::MissingBody(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NoSuchStreamingDistribution(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::PreconditionFailed(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyStreamingDistributionCnamEs(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyTrustedSigners(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TrustedSignerDoesNotExist(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::UpdateStreamingDistributionError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateStreamingDistributionError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateStreamingDistributionError {
    /// Creates the `UpdateStreamingDistributionError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `UpdateStreamingDistributionError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AccessDenied(e) => e.meta(),
            Self::CnameAlreadyExists(e) => e.meta(),
            Self::IllegalUpdate(e) => e.meta(),
            Self::InconsistentQuantities(e) => e.meta(),
            Self::InvalidArgument(e) => e.meta(),
            Self::InvalidIfMatchVersion(e) => e.meta(),
            Self::InvalidOriginAccessControl(e) => e.meta(),
            Self::InvalidOriginAccessIdentity(e) => e.meta(),
            Self::MissingBody(e) => e.meta(),
            Self::NoSuchStreamingDistribution(e) => e.meta(),
            Self::PreconditionFailed(e) => e.meta(),
            Self::TooManyStreamingDistributionCnamEs(e) => e.meta(),
            Self::TooManyTrustedSigners(e) => e.meta(),
            Self::TrustedSignerDoesNotExist(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `UpdateStreamingDistributionError::AccessDenied`.
    pub fn is_access_denied(&self) -> bool {
        matches!(self, Self::AccessDenied(_))
    }
    /// Returns `true` if the error kind is `UpdateStreamingDistributionError::CnameAlreadyExists`.
    pub fn is_cname_already_exists(&self) -> bool {
        matches!(self, Self::CnameAlreadyExists(_))
    }
    /// Returns `true` if the error kind is `UpdateStreamingDistributionError::IllegalUpdate`.
    pub fn is_illegal_update(&self) -> bool {
        matches!(self, Self::IllegalUpdate(_))
    }
    /// Returns `true` if the error kind is `UpdateStreamingDistributionError::InconsistentQuantities`.
    pub fn is_inconsistent_quantities(&self) -> bool {
        matches!(self, Self::InconsistentQuantities(_))
    }
    /// Returns `true` if the error kind is `UpdateStreamingDistributionError::InvalidArgument`.
    pub fn is_invalid_argument(&self) -> bool {
        matches!(self, Self::InvalidArgument(_))
    }
    /// Returns `true` if the error kind is `UpdateStreamingDistributionError::InvalidIfMatchVersion`.
    pub fn is_invalid_if_match_version(&self) -> bool {
        matches!(self, Self::InvalidIfMatchVersion(_))
    }
    /// Returns `true` if the error kind is `UpdateStreamingDistributionError::InvalidOriginAccessControl`.
    pub fn is_invalid_origin_access_control(&self) -> bool {
        matches!(self, Self::InvalidOriginAccessControl(_))
    }
    /// Returns `true` if the error kind is `UpdateStreamingDistributionError::InvalidOriginAccessIdentity`.
    pub fn is_invalid_origin_access_identity(&self) -> bool {
        matches!(self, Self::InvalidOriginAccessIdentity(_))
    }
    /// Returns `true` if the error kind is `UpdateStreamingDistributionError::MissingBody`.
    pub fn is_missing_body(&self) -> bool {
        matches!(self, Self::MissingBody(_))
    }
    /// Returns `true` if the error kind is `UpdateStreamingDistributionError::NoSuchStreamingDistribution`.
    pub fn is_no_such_streaming_distribution(&self) -> bool {
        matches!(self, Self::NoSuchStreamingDistribution(_))
    }
    /// Returns `true` if the error kind is `UpdateStreamingDistributionError::PreconditionFailed`.
    pub fn is_precondition_failed(&self) -> bool {
        matches!(self, Self::PreconditionFailed(_))
    }
    /// Returns `true` if the error kind is `UpdateStreamingDistributionError::TooManyStreamingDistributionCnamEs`.
    pub fn is_too_many_streaming_distribution_cnam_es(&self) -> bool {
        matches!(self, Self::TooManyStreamingDistributionCnamEs(_))
    }
    /// Returns `true` if the error kind is `UpdateStreamingDistributionError::TooManyTrustedSigners`.
    pub fn is_too_many_trusted_signers(&self) -> bool {
        matches!(self, Self::TooManyTrustedSigners(_))
    }
    /// Returns `true` if the error kind is `UpdateStreamingDistributionError::TrustedSignerDoesNotExist`.
    pub fn is_trusted_signer_does_not_exist(&self) -> bool {
        matches!(self, Self::TrustedSignerDoesNotExist(_))
    }
}
impl std::error::Error for UpdateStreamingDistributionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AccessDenied(_inner) => Some(_inner),
            Self::CnameAlreadyExists(_inner) => Some(_inner),
            Self::IllegalUpdate(_inner) => Some(_inner),
            Self::InconsistentQuantities(_inner) => Some(_inner),
            Self::InvalidArgument(_inner) => Some(_inner),
            Self::InvalidIfMatchVersion(_inner) => Some(_inner),
            Self::InvalidOriginAccessControl(_inner) => Some(_inner),
            Self::InvalidOriginAccessIdentity(_inner) => Some(_inner),
            Self::MissingBody(_inner) => Some(_inner),
            Self::NoSuchStreamingDistribution(_inner) => Some(_inner),
            Self::PreconditionFailed(_inner) => Some(_inner),
            Self::TooManyStreamingDistributionCnamEs(_inner) => Some(_inner),
            Self::TooManyTrustedSigners(_inner) => Some(_inner),
            Self::TrustedSignerDoesNotExist(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>One or more of your trusted signers don't exist.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TrustedSignerDoesNotExist {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl TrustedSignerDoesNotExist {
    /// Creates a new builder-style object to manufacture [`TrustedSignerDoesNotExist`](crate::error::TrustedSignerDoesNotExist).
    pub fn builder() -> crate::error::trusted_signer_does_not_exist::Builder {
        crate::error::trusted_signer_does_not_exist::Builder::default()
    }
}
/// See [`TrustedSignerDoesNotExist`](crate::error::TrustedSignerDoesNotExist).
pub mod trusted_signer_does_not_exist {

    /// A builder for [`TrustedSignerDoesNotExist`](crate::error::TrustedSignerDoesNotExist).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`TrustedSignerDoesNotExist`](crate::error::TrustedSignerDoesNotExist).
        pub fn build(self) -> crate::error::TrustedSignerDoesNotExist {
            crate::error::TrustedSignerDoesNotExist {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl TrustedSignerDoesNotExist {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TrustedSignerDoesNotExist {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TrustedSignerDoesNotExist")?;
        if let Some(inner_1) = &self.message {
            {
                write!(f, ": {}", inner_1)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for TrustedSignerDoesNotExist {}
impl aws_http::request_id::RequestId for crate::error::TrustedSignerDoesNotExist {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for TrustedSignerDoesNotExist {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>Your request contains more trusted signers than are allowed per distribution.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TooManyTrustedSigners {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl TooManyTrustedSigners {
    /// Creates a new builder-style object to manufacture [`TooManyTrustedSigners`](crate::error::TooManyTrustedSigners).
    pub fn builder() -> crate::error::too_many_trusted_signers::Builder {
        crate::error::too_many_trusted_signers::Builder::default()
    }
}
/// See [`TooManyTrustedSigners`](crate::error::TooManyTrustedSigners).
pub mod too_many_trusted_signers {

    /// A builder for [`TooManyTrustedSigners`](crate::error::TooManyTrustedSigners).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`TooManyTrustedSigners`](crate::error::TooManyTrustedSigners).
        pub fn build(self) -> crate::error::TooManyTrustedSigners {
            crate::error::TooManyTrustedSigners {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl TooManyTrustedSigners {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TooManyTrustedSigners {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TooManyTrustedSigners")?;
        if let Some(inner_2) = &self.message {
            {
                write!(f, ": {}", inner_2)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for TooManyTrustedSigners {}
impl aws_http::request_id::RequestId for crate::error::TooManyTrustedSigners {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for TooManyTrustedSigners {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>Your request contains more CNAMEs than are allowed per distribution.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TooManyStreamingDistributionCnamEs {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl TooManyStreamingDistributionCnamEs {
    /// Creates a new builder-style object to manufacture [`TooManyStreamingDistributionCnamEs`](crate::error::TooManyStreamingDistributionCnamEs).
    pub fn builder() -> crate::error::too_many_streaming_distribution_cnam_es::Builder {
        crate::error::too_many_streaming_distribution_cnam_es::Builder::default()
    }
}
/// See [`TooManyStreamingDistributionCnamEs`](crate::error::TooManyStreamingDistributionCnamEs).
pub mod too_many_streaming_distribution_cnam_es {

    /// A builder for [`TooManyStreamingDistributionCnamEs`](crate::error::TooManyStreamingDistributionCnamEs).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`TooManyStreamingDistributionCnamEs`](crate::error::TooManyStreamingDistributionCnamEs).
        pub fn build(self) -> crate::error::TooManyStreamingDistributionCnamEs {
            crate::error::TooManyStreamingDistributionCnamEs {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl TooManyStreamingDistributionCnamEs {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TooManyStreamingDistributionCnamEs {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "TooManyStreamingDistributionCnamEs [TooManyStreamingDistributionCNAMEs]"
        )?;
        if let Some(inner_3) = &self.message {
            {
                write!(f, ": {}", inner_3)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for TooManyStreamingDistributionCnamEs {}
impl aws_http::request_id::RequestId for crate::error::TooManyStreamingDistributionCnamEs {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for TooManyStreamingDistributionCnamEs
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The precondition in one or more of the request fields evaluated to <code>false</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PreconditionFailed {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl PreconditionFailed {
    /// Creates a new builder-style object to manufacture [`PreconditionFailed`](crate::error::PreconditionFailed).
    pub fn builder() -> crate::error::precondition_failed::Builder {
        crate::error::precondition_failed::Builder::default()
    }
}
/// See [`PreconditionFailed`](crate::error::PreconditionFailed).
pub mod precondition_failed {

    /// A builder for [`PreconditionFailed`](crate::error::PreconditionFailed).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`PreconditionFailed`](crate::error::PreconditionFailed).
        pub fn build(self) -> crate::error::PreconditionFailed {
            crate::error::PreconditionFailed {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl PreconditionFailed {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for PreconditionFailed {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "PreconditionFailed")?;
        if let Some(inner_4) = &self.message {
            {
                write!(f, ": {}", inner_4)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for PreconditionFailed {}
impl aws_http::request_id::RequestId for crate::error::PreconditionFailed {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for PreconditionFailed {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The specified streaming distribution does not exist.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct NoSuchStreamingDistribution {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl NoSuchStreamingDistribution {
    /// Creates a new builder-style object to manufacture [`NoSuchStreamingDistribution`](crate::error::NoSuchStreamingDistribution).
    pub fn builder() -> crate::error::no_such_streaming_distribution::Builder {
        crate::error::no_such_streaming_distribution::Builder::default()
    }
}
/// See [`NoSuchStreamingDistribution`](crate::error::NoSuchStreamingDistribution).
pub mod no_such_streaming_distribution {

    /// A builder for [`NoSuchStreamingDistribution`](crate::error::NoSuchStreamingDistribution).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`NoSuchStreamingDistribution`](crate::error::NoSuchStreamingDistribution).
        pub fn build(self) -> crate::error::NoSuchStreamingDistribution {
            crate::error::NoSuchStreamingDistribution {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl NoSuchStreamingDistribution {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for NoSuchStreamingDistribution {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "NoSuchStreamingDistribution")?;
        if let Some(inner_5) = &self.message {
            {
                write!(f, ": {}", inner_5)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for NoSuchStreamingDistribution {}
impl aws_http::request_id::RequestId for crate::error::NoSuchStreamingDistribution {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for NoSuchStreamingDistribution {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>This operation requires a body. Ensure that the body is present and the <code>Content-Type</code> header is set.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct MissingBody {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl MissingBody {
    /// Creates a new builder-style object to manufacture [`MissingBody`](crate::error::MissingBody).
    pub fn builder() -> crate::error::missing_body::Builder {
        crate::error::missing_body::Builder::default()
    }
}
/// See [`MissingBody`](crate::error::MissingBody).
pub mod missing_body {

    /// A builder for [`MissingBody`](crate::error::MissingBody).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`MissingBody`](crate::error::MissingBody).
        pub fn build(self) -> crate::error::MissingBody {
            crate::error::MissingBody {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl MissingBody {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for MissingBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "MissingBody")?;
        if let Some(inner_6) = &self.message {
            {
                write!(f, ": {}", inner_6)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for MissingBody {}
impl aws_http::request_id::RequestId for crate::error::MissingBody {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for MissingBody {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The origin access identity is not valid or doesn't exist.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidOriginAccessIdentity {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidOriginAccessIdentity {
    /// Creates a new builder-style object to manufacture [`InvalidOriginAccessIdentity`](crate::error::InvalidOriginAccessIdentity).
    pub fn builder() -> crate::error::invalid_origin_access_identity::Builder {
        crate::error::invalid_origin_access_identity::Builder::default()
    }
}
/// See [`InvalidOriginAccessIdentity`](crate::error::InvalidOriginAccessIdentity).
pub mod invalid_origin_access_identity {

    /// A builder for [`InvalidOriginAccessIdentity`](crate::error::InvalidOriginAccessIdentity).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidOriginAccessIdentity`](crate::error::InvalidOriginAccessIdentity).
        pub fn build(self) -> crate::error::InvalidOriginAccessIdentity {
            crate::error::InvalidOriginAccessIdentity {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl InvalidOriginAccessIdentity {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidOriginAccessIdentity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidOriginAccessIdentity")?;
        if let Some(inner_7) = &self.message {
            {
                write!(f, ": {}", inner_7)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidOriginAccessIdentity {}
impl aws_http::request_id::RequestId for crate::error::InvalidOriginAccessIdentity {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidOriginAccessIdentity {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The origin access control is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidOriginAccessControl {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidOriginAccessControl {
    /// Creates a new builder-style object to manufacture [`InvalidOriginAccessControl`](crate::error::InvalidOriginAccessControl).
    pub fn builder() -> crate::error::invalid_origin_access_control::Builder {
        crate::error::invalid_origin_access_control::Builder::default()
    }
}
/// See [`InvalidOriginAccessControl`](crate::error::InvalidOriginAccessControl).
pub mod invalid_origin_access_control {

    /// A builder for [`InvalidOriginAccessControl`](crate::error::InvalidOriginAccessControl).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidOriginAccessControl`](crate::error::InvalidOriginAccessControl).
        pub fn build(self) -> crate::error::InvalidOriginAccessControl {
            crate::error::InvalidOriginAccessControl {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl InvalidOriginAccessControl {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidOriginAccessControl {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidOriginAccessControl")?;
        if let Some(inner_8) = &self.message {
            {
                write!(f, ": {}", inner_8)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidOriginAccessControl {}
impl aws_http::request_id::RequestId for crate::error::InvalidOriginAccessControl {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidOriginAccessControl {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The <code>If-Match</code> version is missing or not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidIfMatchVersion {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidIfMatchVersion {
    /// Creates a new builder-style object to manufacture [`InvalidIfMatchVersion`](crate::error::InvalidIfMatchVersion).
    pub fn builder() -> crate::error::invalid_if_match_version::Builder {
        crate::error::invalid_if_match_version::Builder::default()
    }
}
/// See [`InvalidIfMatchVersion`](crate::error::InvalidIfMatchVersion).
pub mod invalid_if_match_version {

    /// A builder for [`InvalidIfMatchVersion`](crate::error::InvalidIfMatchVersion).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidIfMatchVersion`](crate::error::InvalidIfMatchVersion).
        pub fn build(self) -> crate::error::InvalidIfMatchVersion {
            crate::error::InvalidIfMatchVersion {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl InvalidIfMatchVersion {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidIfMatchVersion {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidIfMatchVersion")?;
        if let Some(inner_9) = &self.message {
            {
                write!(f, ": {}", inner_9)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidIfMatchVersion {}
impl aws_http::request_id::RequestId for crate::error::InvalidIfMatchVersion {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidIfMatchVersion {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>An argument is invalid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidArgument {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidArgument {
    /// Creates a new builder-style object to manufacture [`InvalidArgument`](crate::error::InvalidArgument).
    pub fn builder() -> crate::error::invalid_argument::Builder {
        crate::error::invalid_argument::Builder::default()
    }
}
/// See [`InvalidArgument`](crate::error::InvalidArgument).
pub mod invalid_argument {

    /// A builder for [`InvalidArgument`](crate::error::InvalidArgument).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidArgument`](crate::error::InvalidArgument).
        pub fn build(self) -> crate::error::InvalidArgument {
            crate::error::InvalidArgument {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl InvalidArgument {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidArgument {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidArgument")?;
        if let Some(inner_10) = &self.message {
            {
                write!(f, ": {}", inner_10)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidArgument {}
impl aws_http::request_id::RequestId for crate::error::InvalidArgument {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidArgument {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The value of <code>Quantity</code> and the size of <code>Items</code> don't match.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InconsistentQuantities {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InconsistentQuantities {
    /// Creates a new builder-style object to manufacture [`InconsistentQuantities`](crate::error::InconsistentQuantities).
    pub fn builder() -> crate::error::inconsistent_quantities::Builder {
        crate::error::inconsistent_quantities::Builder::default()
    }
}
/// See [`InconsistentQuantities`](crate::error::InconsistentQuantities).
pub mod inconsistent_quantities {

    /// A builder for [`InconsistentQuantities`](crate::error::InconsistentQuantities).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InconsistentQuantities`](crate::error::InconsistentQuantities).
        pub fn build(self) -> crate::error::InconsistentQuantities {
            crate::error::InconsistentQuantities {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl InconsistentQuantities {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InconsistentQuantities {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InconsistentQuantities")?;
        if let Some(inner_11) = &self.message {
            {
                write!(f, ": {}", inner_11)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InconsistentQuantities {}
impl aws_http::request_id::RequestId for crate::error::InconsistentQuantities {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InconsistentQuantities {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The update contains modifications that are not allowed.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct IllegalUpdate {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl IllegalUpdate {
    /// Creates a new builder-style object to manufacture [`IllegalUpdate`](crate::error::IllegalUpdate).
    pub fn builder() -> crate::error::illegal_update::Builder {
        crate::error::illegal_update::Builder::default()
    }
}
/// See [`IllegalUpdate`](crate::error::IllegalUpdate).
pub mod illegal_update {

    /// A builder for [`IllegalUpdate`](crate::error::IllegalUpdate).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`IllegalUpdate`](crate::error::IllegalUpdate).
        pub fn build(self) -> crate::error::IllegalUpdate {
            crate::error::IllegalUpdate {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl IllegalUpdate {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for IllegalUpdate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "IllegalUpdate")?;
        if let Some(inner_12) = &self.message {
            {
                write!(f, ": {}", inner_12)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for IllegalUpdate {}
impl aws_http::request_id::RequestId for crate::error::IllegalUpdate {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for IllegalUpdate {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The CNAME specified is already defined for CloudFront.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CnameAlreadyExists {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl CnameAlreadyExists {
    /// Creates a new builder-style object to manufacture [`CnameAlreadyExists`](crate::error::CnameAlreadyExists).
    pub fn builder() -> crate::error::cname_already_exists::Builder {
        crate::error::cname_already_exists::Builder::default()
    }
}
/// See [`CnameAlreadyExists`](crate::error::CnameAlreadyExists).
pub mod cname_already_exists {

    /// A builder for [`CnameAlreadyExists`](crate::error::CnameAlreadyExists).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`CnameAlreadyExists`](crate::error::CnameAlreadyExists).
        pub fn build(self) -> crate::error::CnameAlreadyExists {
            crate::error::CnameAlreadyExists {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl CnameAlreadyExists {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CnameAlreadyExists {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CnameAlreadyExists [CNAMEAlreadyExists]")?;
        if let Some(inner_13) = &self.message {
            {
                write!(f, ": {}", inner_13)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for CnameAlreadyExists {}
impl aws_http::request_id::RequestId for crate::error::CnameAlreadyExists {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CnameAlreadyExists {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>Access denied.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AccessDenied {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl AccessDenied {
    /// Creates a new builder-style object to manufacture [`AccessDenied`](crate::error::AccessDenied).
    pub fn builder() -> crate::error::access_denied::Builder {
        crate::error::access_denied::Builder::default()
    }
}
/// See [`AccessDenied`](crate::error::AccessDenied).
pub mod access_denied {

    /// A builder for [`AccessDenied`](crate::error::AccessDenied).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`AccessDenied`](crate::error::AccessDenied).
        pub fn build(self) -> crate::error::AccessDenied {
            crate::error::AccessDenied {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl AccessDenied {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for AccessDenied {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "AccessDenied")?;
        if let Some(inner_14) = &self.message {
            {
                write!(f, ": {}", inner_14)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for AccessDenied {}
impl aws_http::request_id::RequestId for crate::error::AccessDenied {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for AccessDenied {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type UpdateResponseHeadersPolicyErrorKind = UpdateResponseHeadersPolicyError;
/// Error type for the `UpdateResponseHeadersPolicyError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateResponseHeadersPolicyError {
    /// <p>Access denied.</p>
    AccessDenied(crate::error::AccessDenied),
    /// <p>The update contains modifications that are not allowed.</p>
    IllegalUpdate(crate::error::IllegalUpdate),
    /// <p>The value of <code>Quantity</code> and the size of <code>Items</code> don't match.</p>
    InconsistentQuantities(crate::error::InconsistentQuantities),
    /// <p>An argument is invalid.</p>
    InvalidArgument(crate::error::InvalidArgument),
    /// <p>The <code>If-Match</code> version is missing or not valid.</p>
    InvalidIfMatchVersion(crate::error::InvalidIfMatchVersion),
    /// <p>The response headers policy does not exist.</p>
    NoSuchResponseHeadersPolicy(crate::error::NoSuchResponseHeadersPolicy),
    /// <p>The precondition in one or more of the request fields evaluated to <code>false</code>.</p>
    PreconditionFailed(crate::error::PreconditionFailed),
    /// <p>A response headers policy with this name already exists. You must provide a unique name. To modify an existing response headers policy, use <code>UpdateResponseHeadersPolicy</code>.</p>
    ResponseHeadersPolicyAlreadyExists(crate::error::ResponseHeadersPolicyAlreadyExists),
    /// <p>The length of the <code>Content-Security-Policy</code> header value in the response headers policy exceeds the maximum.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
    TooLongCspInResponseHeadersPolicy(crate::error::TooLongCspInResponseHeadersPolicy),
    /// <p>The number of custom headers in the response headers policy exceeds the maximum.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
    TooManyCustomHeadersInResponseHeadersPolicy(
        crate::error::TooManyCustomHeadersInResponseHeadersPolicy,
    ),
    /// <p>The number of headers in <code>RemoveHeadersConfig</code> in the response headers policy exceeds the maximum.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
    TooManyRemoveHeadersInResponseHeadersPolicy(
        crate::error::TooManyRemoveHeadersInResponseHeadersPolicy,
    ),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for UpdateResponseHeadersPolicyError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for UpdateResponseHeadersPolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AccessDenied(_inner) => _inner.fmt(f),
            Self::IllegalUpdate(_inner) => _inner.fmt(f),
            Self::InconsistentQuantities(_inner) => _inner.fmt(f),
            Self::InvalidArgument(_inner) => _inner.fmt(f),
            Self::InvalidIfMatchVersion(_inner) => _inner.fmt(f),
            Self::NoSuchResponseHeadersPolicy(_inner) => _inner.fmt(f),
            Self::PreconditionFailed(_inner) => _inner.fmt(f),
            Self::ResponseHeadersPolicyAlreadyExists(_inner) => _inner.fmt(f),
            Self::TooLongCspInResponseHeadersPolicy(_inner) => _inner.fmt(f),
            Self::TooManyCustomHeadersInResponseHeadersPolicy(_inner) => _inner.fmt(f),
            Self::TooManyRemoveHeadersInResponseHeadersPolicy(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for UpdateResponseHeadersPolicyError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AccessDenied(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::IllegalUpdate(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InconsistentQuantities(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidArgument(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidIfMatchVersion(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NoSuchResponseHeadersPolicy(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::PreconditionFailed(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ResponseHeadersPolicyAlreadyExists(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooLongCspInResponseHeadersPolicy(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyCustomHeadersInResponseHeadersPolicy(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyRemoveHeadersInResponseHeadersPolicy(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::UpdateResponseHeadersPolicyError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateResponseHeadersPolicyError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateResponseHeadersPolicyError {
    /// Creates the `UpdateResponseHeadersPolicyError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `UpdateResponseHeadersPolicyError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AccessDenied(e) => e.meta(),
            Self::IllegalUpdate(e) => e.meta(),
            Self::InconsistentQuantities(e) => e.meta(),
            Self::InvalidArgument(e) => e.meta(),
            Self::InvalidIfMatchVersion(e) => e.meta(),
            Self::NoSuchResponseHeadersPolicy(e) => e.meta(),
            Self::PreconditionFailed(e) => e.meta(),
            Self::ResponseHeadersPolicyAlreadyExists(e) => e.meta(),
            Self::TooLongCspInResponseHeadersPolicy(e) => e.meta(),
            Self::TooManyCustomHeadersInResponseHeadersPolicy(e) => e.meta(),
            Self::TooManyRemoveHeadersInResponseHeadersPolicy(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `UpdateResponseHeadersPolicyError::AccessDenied`.
    pub fn is_access_denied(&self) -> bool {
        matches!(self, Self::AccessDenied(_))
    }
    /// Returns `true` if the error kind is `UpdateResponseHeadersPolicyError::IllegalUpdate`.
    pub fn is_illegal_update(&self) -> bool {
        matches!(self, Self::IllegalUpdate(_))
    }
    /// Returns `true` if the error kind is `UpdateResponseHeadersPolicyError::InconsistentQuantities`.
    pub fn is_inconsistent_quantities(&self) -> bool {
        matches!(self, Self::InconsistentQuantities(_))
    }
    /// Returns `true` if the error kind is `UpdateResponseHeadersPolicyError::InvalidArgument`.
    pub fn is_invalid_argument(&self) -> bool {
        matches!(self, Self::InvalidArgument(_))
    }
    /// Returns `true` if the error kind is `UpdateResponseHeadersPolicyError::InvalidIfMatchVersion`.
    pub fn is_invalid_if_match_version(&self) -> bool {
        matches!(self, Self::InvalidIfMatchVersion(_))
    }
    /// Returns `true` if the error kind is `UpdateResponseHeadersPolicyError::NoSuchResponseHeadersPolicy`.
    pub fn is_no_such_response_headers_policy(&self) -> bool {
        matches!(self, Self::NoSuchResponseHeadersPolicy(_))
    }
    /// Returns `true` if the error kind is `UpdateResponseHeadersPolicyError::PreconditionFailed`.
    pub fn is_precondition_failed(&self) -> bool {
        matches!(self, Self::PreconditionFailed(_))
    }
    /// Returns `true` if the error kind is `UpdateResponseHeadersPolicyError::ResponseHeadersPolicyAlreadyExists`.
    pub fn is_response_headers_policy_already_exists(&self) -> bool {
        matches!(self, Self::ResponseHeadersPolicyAlreadyExists(_))
    }
    /// Returns `true` if the error kind is `UpdateResponseHeadersPolicyError::TooLongCspInResponseHeadersPolicy`.
    pub fn is_too_long_csp_in_response_headers_policy(&self) -> bool {
        matches!(self, Self::TooLongCspInResponseHeadersPolicy(_))
    }
    /// Returns `true` if the error kind is `UpdateResponseHeadersPolicyError::TooManyCustomHeadersInResponseHeadersPolicy`.
    pub fn is_too_many_custom_headers_in_response_headers_policy(&self) -> bool {
        matches!(self, Self::TooManyCustomHeadersInResponseHeadersPolicy(_))
    }
    /// Returns `true` if the error kind is `UpdateResponseHeadersPolicyError::TooManyRemoveHeadersInResponseHeadersPolicy`.
    pub fn is_too_many_remove_headers_in_response_headers_policy(&self) -> bool {
        matches!(self, Self::TooManyRemoveHeadersInResponseHeadersPolicy(_))
    }
}
impl std::error::Error for UpdateResponseHeadersPolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AccessDenied(_inner) => Some(_inner),
            Self::IllegalUpdate(_inner) => Some(_inner),
            Self::InconsistentQuantities(_inner) => Some(_inner),
            Self::InvalidArgument(_inner) => Some(_inner),
            Self::InvalidIfMatchVersion(_inner) => Some(_inner),
            Self::NoSuchResponseHeadersPolicy(_inner) => Some(_inner),
            Self::PreconditionFailed(_inner) => Some(_inner),
            Self::ResponseHeadersPolicyAlreadyExists(_inner) => Some(_inner),
            Self::TooLongCspInResponseHeadersPolicy(_inner) => Some(_inner),
            Self::TooManyCustomHeadersInResponseHeadersPolicy(_inner) => Some(_inner),
            Self::TooManyRemoveHeadersInResponseHeadersPolicy(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The number of headers in <code>RemoveHeadersConfig</code> in the response headers policy exceeds the maximum.</p>
/// <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TooManyRemoveHeadersInResponseHeadersPolicy {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl TooManyRemoveHeadersInResponseHeadersPolicy {
    /// Creates a new builder-style object to manufacture [`TooManyRemoveHeadersInResponseHeadersPolicy`](crate::error::TooManyRemoveHeadersInResponseHeadersPolicy).
    pub fn builder() -> crate::error::too_many_remove_headers_in_response_headers_policy::Builder {
        crate::error::too_many_remove_headers_in_response_headers_policy::Builder::default()
    }
}
/// See [`TooManyRemoveHeadersInResponseHeadersPolicy`](crate::error::TooManyRemoveHeadersInResponseHeadersPolicy).
pub mod too_many_remove_headers_in_response_headers_policy {

    /// A builder for [`TooManyRemoveHeadersInResponseHeadersPolicy`](crate::error::TooManyRemoveHeadersInResponseHeadersPolicy).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`TooManyRemoveHeadersInResponseHeadersPolicy`](crate::error::TooManyRemoveHeadersInResponseHeadersPolicy).
        pub fn build(self) -> crate::error::TooManyRemoveHeadersInResponseHeadersPolicy {
            crate::error::TooManyRemoveHeadersInResponseHeadersPolicy {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl TooManyRemoveHeadersInResponseHeadersPolicy {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TooManyRemoveHeadersInResponseHeadersPolicy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TooManyRemoveHeadersInResponseHeadersPolicy")?;
        if let Some(inner_15) = &self.message {
            {
                write!(f, ": {}", inner_15)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for TooManyRemoveHeadersInResponseHeadersPolicy {}
impl aws_http::request_id::RequestId for crate::error::TooManyRemoveHeadersInResponseHeadersPolicy {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for TooManyRemoveHeadersInResponseHeadersPolicy
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The number of custom headers in the response headers policy exceeds the maximum.</p>
/// <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TooManyCustomHeadersInResponseHeadersPolicy {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl TooManyCustomHeadersInResponseHeadersPolicy {
    /// Creates a new builder-style object to manufacture [`TooManyCustomHeadersInResponseHeadersPolicy`](crate::error::TooManyCustomHeadersInResponseHeadersPolicy).
    pub fn builder() -> crate::error::too_many_custom_headers_in_response_headers_policy::Builder {
        crate::error::too_many_custom_headers_in_response_headers_policy::Builder::default()
    }
}
/// See [`TooManyCustomHeadersInResponseHeadersPolicy`](crate::error::TooManyCustomHeadersInResponseHeadersPolicy).
pub mod too_many_custom_headers_in_response_headers_policy {

    /// A builder for [`TooManyCustomHeadersInResponseHeadersPolicy`](crate::error::TooManyCustomHeadersInResponseHeadersPolicy).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`TooManyCustomHeadersInResponseHeadersPolicy`](crate::error::TooManyCustomHeadersInResponseHeadersPolicy).
        pub fn build(self) -> crate::error::TooManyCustomHeadersInResponseHeadersPolicy {
            crate::error::TooManyCustomHeadersInResponseHeadersPolicy {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl TooManyCustomHeadersInResponseHeadersPolicy {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TooManyCustomHeadersInResponseHeadersPolicy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TooManyCustomHeadersInResponseHeadersPolicy")?;
        if let Some(inner_16) = &self.message {
            {
                write!(f, ": {}", inner_16)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for TooManyCustomHeadersInResponseHeadersPolicy {}
impl aws_http::request_id::RequestId for crate::error::TooManyCustomHeadersInResponseHeadersPolicy {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for TooManyCustomHeadersInResponseHeadersPolicy
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The length of the <code>Content-Security-Policy</code> header value in the response headers policy exceeds the maximum.</p>
/// <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TooLongCspInResponseHeadersPolicy {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl TooLongCspInResponseHeadersPolicy {
    /// Creates a new builder-style object to manufacture [`TooLongCspInResponseHeadersPolicy`](crate::error::TooLongCspInResponseHeadersPolicy).
    pub fn builder() -> crate::error::too_long_csp_in_response_headers_policy::Builder {
        crate::error::too_long_csp_in_response_headers_policy::Builder::default()
    }
}
/// See [`TooLongCspInResponseHeadersPolicy`](crate::error::TooLongCspInResponseHeadersPolicy).
pub mod too_long_csp_in_response_headers_policy {

    /// A builder for [`TooLongCspInResponseHeadersPolicy`](crate::error::TooLongCspInResponseHeadersPolicy).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`TooLongCspInResponseHeadersPolicy`](crate::error::TooLongCspInResponseHeadersPolicy).
        pub fn build(self) -> crate::error::TooLongCspInResponseHeadersPolicy {
            crate::error::TooLongCspInResponseHeadersPolicy {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl TooLongCspInResponseHeadersPolicy {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TooLongCspInResponseHeadersPolicy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "TooLongCspInResponseHeadersPolicy [TooLongCSPInResponseHeadersPolicy]"
        )?;
        if let Some(inner_17) = &self.message {
            {
                write!(f, ": {}", inner_17)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for TooLongCspInResponseHeadersPolicy {}
impl aws_http::request_id::RequestId for crate::error::TooLongCspInResponseHeadersPolicy {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for TooLongCspInResponseHeadersPolicy {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>A response headers policy with this name already exists. You must provide a unique name. To modify an existing response headers policy, use <code>UpdateResponseHeadersPolicy</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ResponseHeadersPolicyAlreadyExists {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl ResponseHeadersPolicyAlreadyExists {
    /// Creates a new builder-style object to manufacture [`ResponseHeadersPolicyAlreadyExists`](crate::error::ResponseHeadersPolicyAlreadyExists).
    pub fn builder() -> crate::error::response_headers_policy_already_exists::Builder {
        crate::error::response_headers_policy_already_exists::Builder::default()
    }
}
/// See [`ResponseHeadersPolicyAlreadyExists`](crate::error::ResponseHeadersPolicyAlreadyExists).
pub mod response_headers_policy_already_exists {

    /// A builder for [`ResponseHeadersPolicyAlreadyExists`](crate::error::ResponseHeadersPolicyAlreadyExists).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`ResponseHeadersPolicyAlreadyExists`](crate::error::ResponseHeadersPolicyAlreadyExists).
        pub fn build(self) -> crate::error::ResponseHeadersPolicyAlreadyExists {
            crate::error::ResponseHeadersPolicyAlreadyExists {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl ResponseHeadersPolicyAlreadyExists {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ResponseHeadersPolicyAlreadyExists {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResponseHeadersPolicyAlreadyExists")?;
        if let Some(inner_18) = &self.message {
            {
                write!(f, ": {}", inner_18)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ResponseHeadersPolicyAlreadyExists {}
impl aws_http::request_id::RequestId for crate::error::ResponseHeadersPolicyAlreadyExists {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for ResponseHeadersPolicyAlreadyExists
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The response headers policy does not exist.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct NoSuchResponseHeadersPolicy {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl NoSuchResponseHeadersPolicy {
    /// Creates a new builder-style object to manufacture [`NoSuchResponseHeadersPolicy`](crate::error::NoSuchResponseHeadersPolicy).
    pub fn builder() -> crate::error::no_such_response_headers_policy::Builder {
        crate::error::no_such_response_headers_policy::Builder::default()
    }
}
/// See [`NoSuchResponseHeadersPolicy`](crate::error::NoSuchResponseHeadersPolicy).
pub mod no_such_response_headers_policy {

    /// A builder for [`NoSuchResponseHeadersPolicy`](crate::error::NoSuchResponseHeadersPolicy).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`NoSuchResponseHeadersPolicy`](crate::error::NoSuchResponseHeadersPolicy).
        pub fn build(self) -> crate::error::NoSuchResponseHeadersPolicy {
            crate::error::NoSuchResponseHeadersPolicy {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl NoSuchResponseHeadersPolicy {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for NoSuchResponseHeadersPolicy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "NoSuchResponseHeadersPolicy")?;
        if let Some(inner_19) = &self.message {
            {
                write!(f, ": {}", inner_19)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for NoSuchResponseHeadersPolicy {}
impl aws_http::request_id::RequestId for crate::error::NoSuchResponseHeadersPolicy {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for NoSuchResponseHeadersPolicy {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type UpdateRealtimeLogConfigErrorKind = UpdateRealtimeLogConfigError;
/// Error type for the `UpdateRealtimeLogConfigError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateRealtimeLogConfigError {
    /// <p>Access denied.</p>
    AccessDenied(crate::error::AccessDenied),
    /// <p>An argument is invalid.</p>
    InvalidArgument(crate::error::InvalidArgument),
    /// <p>The real-time log configuration does not exist.</p>
    NoSuchRealtimeLogConfig(crate::error::NoSuchRealtimeLogConfig),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for UpdateRealtimeLogConfigError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for UpdateRealtimeLogConfigError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AccessDenied(_inner) => _inner.fmt(f),
            Self::InvalidArgument(_inner) => _inner.fmt(f),
            Self::NoSuchRealtimeLogConfig(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for UpdateRealtimeLogConfigError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AccessDenied(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidArgument(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NoSuchRealtimeLogConfig(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::UpdateRealtimeLogConfigError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateRealtimeLogConfigError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateRealtimeLogConfigError {
    /// Creates the `UpdateRealtimeLogConfigError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `UpdateRealtimeLogConfigError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AccessDenied(e) => e.meta(),
            Self::InvalidArgument(e) => e.meta(),
            Self::NoSuchRealtimeLogConfig(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `UpdateRealtimeLogConfigError::AccessDenied`.
    pub fn is_access_denied(&self) -> bool {
        matches!(self, Self::AccessDenied(_))
    }
    /// Returns `true` if the error kind is `UpdateRealtimeLogConfigError::InvalidArgument`.
    pub fn is_invalid_argument(&self) -> bool {
        matches!(self, Self::InvalidArgument(_))
    }
    /// Returns `true` if the error kind is `UpdateRealtimeLogConfigError::NoSuchRealtimeLogConfig`.
    pub fn is_no_such_realtime_log_config(&self) -> bool {
        matches!(self, Self::NoSuchRealtimeLogConfig(_))
    }
}
impl std::error::Error for UpdateRealtimeLogConfigError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AccessDenied(_inner) => Some(_inner),
            Self::InvalidArgument(_inner) => Some(_inner),
            Self::NoSuchRealtimeLogConfig(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The real-time log configuration does not exist.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct NoSuchRealtimeLogConfig {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl NoSuchRealtimeLogConfig {
    /// Creates a new builder-style object to manufacture [`NoSuchRealtimeLogConfig`](crate::error::NoSuchRealtimeLogConfig).
    pub fn builder() -> crate::error::no_such_realtime_log_config::Builder {
        crate::error::no_such_realtime_log_config::Builder::default()
    }
}
/// See [`NoSuchRealtimeLogConfig`](crate::error::NoSuchRealtimeLogConfig).
pub mod no_such_realtime_log_config {

    /// A builder for [`NoSuchRealtimeLogConfig`](crate::error::NoSuchRealtimeLogConfig).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`NoSuchRealtimeLogConfig`](crate::error::NoSuchRealtimeLogConfig).
        pub fn build(self) -> crate::error::NoSuchRealtimeLogConfig {
            crate::error::NoSuchRealtimeLogConfig {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl NoSuchRealtimeLogConfig {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for NoSuchRealtimeLogConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "NoSuchRealtimeLogConfig")?;
        if let Some(inner_20) = &self.message {
            {
                write!(f, ": {}", inner_20)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for NoSuchRealtimeLogConfig {}
impl aws_http::request_id::RequestId for crate::error::NoSuchRealtimeLogConfig {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for NoSuchRealtimeLogConfig {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type UpdatePublicKeyErrorKind = UpdatePublicKeyError;
/// Error type for the `UpdatePublicKeyError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdatePublicKeyError {
    /// <p>Access denied.</p>
    AccessDenied(crate::error::AccessDenied),
    /// <p>You can't change the value of a public key.</p>
    CannotChangeImmutablePublicKeyFields(crate::error::CannotChangeImmutablePublicKeyFields),
    /// <p>The update contains modifications that are not allowed.</p>
    IllegalUpdate(crate::error::IllegalUpdate),
    /// <p>An argument is invalid.</p>
    InvalidArgument(crate::error::InvalidArgument),
    /// <p>The <code>If-Match</code> version is missing or not valid.</p>
    InvalidIfMatchVersion(crate::error::InvalidIfMatchVersion),
    /// <p>The specified public key doesn't exist.</p>
    NoSuchPublicKey(crate::error::NoSuchPublicKey),
    /// <p>The precondition in one or more of the request fields evaluated to <code>false</code>.</p>
    PreconditionFailed(crate::error::PreconditionFailed),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for UpdatePublicKeyError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for UpdatePublicKeyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AccessDenied(_inner) => _inner.fmt(f),
            Self::CannotChangeImmutablePublicKeyFields(_inner) => _inner.fmt(f),
            Self::IllegalUpdate(_inner) => _inner.fmt(f),
            Self::InvalidArgument(_inner) => _inner.fmt(f),
            Self::InvalidIfMatchVersion(_inner) => _inner.fmt(f),
            Self::NoSuchPublicKey(_inner) => _inner.fmt(f),
            Self::PreconditionFailed(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for UpdatePublicKeyError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AccessDenied(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::CannotChangeImmutablePublicKeyFields(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::IllegalUpdate(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidArgument(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidIfMatchVersion(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NoSuchPublicKey(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::PreconditionFailed(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::UpdatePublicKeyError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdatePublicKeyError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdatePublicKeyError {
    /// Creates the `UpdatePublicKeyError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `UpdatePublicKeyError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AccessDenied(e) => e.meta(),
            Self::CannotChangeImmutablePublicKeyFields(e) => e.meta(),
            Self::IllegalUpdate(e) => e.meta(),
            Self::InvalidArgument(e) => e.meta(),
            Self::InvalidIfMatchVersion(e) => e.meta(),
            Self::NoSuchPublicKey(e) => e.meta(),
            Self::PreconditionFailed(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `UpdatePublicKeyError::AccessDenied`.
    pub fn is_access_denied(&self) -> bool {
        matches!(self, Self::AccessDenied(_))
    }
    /// Returns `true` if the error kind is `UpdatePublicKeyError::CannotChangeImmutablePublicKeyFields`.
    pub fn is_cannot_change_immutable_public_key_fields(&self) -> bool {
        matches!(self, Self::CannotChangeImmutablePublicKeyFields(_))
    }
    /// Returns `true` if the error kind is `UpdatePublicKeyError::IllegalUpdate`.
    pub fn is_illegal_update(&self) -> bool {
        matches!(self, Self::IllegalUpdate(_))
    }
    /// Returns `true` if the error kind is `UpdatePublicKeyError::InvalidArgument`.
    pub fn is_invalid_argument(&self) -> bool {
        matches!(self, Self::InvalidArgument(_))
    }
    /// Returns `true` if the error kind is `UpdatePublicKeyError::InvalidIfMatchVersion`.
    pub fn is_invalid_if_match_version(&self) -> bool {
        matches!(self, Self::InvalidIfMatchVersion(_))
    }
    /// Returns `true` if the error kind is `UpdatePublicKeyError::NoSuchPublicKey`.
    pub fn is_no_such_public_key(&self) -> bool {
        matches!(self, Self::NoSuchPublicKey(_))
    }
    /// Returns `true` if the error kind is `UpdatePublicKeyError::PreconditionFailed`.
    pub fn is_precondition_failed(&self) -> bool {
        matches!(self, Self::PreconditionFailed(_))
    }
}
impl std::error::Error for UpdatePublicKeyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AccessDenied(_inner) => Some(_inner),
            Self::CannotChangeImmutablePublicKeyFields(_inner) => Some(_inner),
            Self::IllegalUpdate(_inner) => Some(_inner),
            Self::InvalidArgument(_inner) => Some(_inner),
            Self::InvalidIfMatchVersion(_inner) => Some(_inner),
            Self::NoSuchPublicKey(_inner) => Some(_inner),
            Self::PreconditionFailed(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The specified public key doesn't exist.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct NoSuchPublicKey {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl NoSuchPublicKey {
    /// Creates a new builder-style object to manufacture [`NoSuchPublicKey`](crate::error::NoSuchPublicKey).
    pub fn builder() -> crate::error::no_such_public_key::Builder {
        crate::error::no_such_public_key::Builder::default()
    }
}
/// See [`NoSuchPublicKey`](crate::error::NoSuchPublicKey).
pub mod no_such_public_key {

    /// A builder for [`NoSuchPublicKey`](crate::error::NoSuchPublicKey).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`NoSuchPublicKey`](crate::error::NoSuchPublicKey).
        pub fn build(self) -> crate::error::NoSuchPublicKey {
            crate::error::NoSuchPublicKey {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl NoSuchPublicKey {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for NoSuchPublicKey {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "NoSuchPublicKey")?;
        if let Some(inner_21) = &self.message {
            {
                write!(f, ": {}", inner_21)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for NoSuchPublicKey {}
impl aws_http::request_id::RequestId for crate::error::NoSuchPublicKey {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for NoSuchPublicKey {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>You can't change the value of a public key.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CannotChangeImmutablePublicKeyFields {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl CannotChangeImmutablePublicKeyFields {
    /// Creates a new builder-style object to manufacture [`CannotChangeImmutablePublicKeyFields`](crate::error::CannotChangeImmutablePublicKeyFields).
    pub fn builder() -> crate::error::cannot_change_immutable_public_key_fields::Builder {
        crate::error::cannot_change_immutable_public_key_fields::Builder::default()
    }
}
/// See [`CannotChangeImmutablePublicKeyFields`](crate::error::CannotChangeImmutablePublicKeyFields).
pub mod cannot_change_immutable_public_key_fields {

    /// A builder for [`CannotChangeImmutablePublicKeyFields`](crate::error::CannotChangeImmutablePublicKeyFields).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`CannotChangeImmutablePublicKeyFields`](crate::error::CannotChangeImmutablePublicKeyFields).
        pub fn build(self) -> crate::error::CannotChangeImmutablePublicKeyFields {
            crate::error::CannotChangeImmutablePublicKeyFields {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl CannotChangeImmutablePublicKeyFields {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CannotChangeImmutablePublicKeyFields {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CannotChangeImmutablePublicKeyFields")?;
        if let Some(inner_22) = &self.message {
            {
                write!(f, ": {}", inner_22)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for CannotChangeImmutablePublicKeyFields {}
impl aws_http::request_id::RequestId for crate::error::CannotChangeImmutablePublicKeyFields {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for CannotChangeImmutablePublicKeyFields
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type UpdateOriginRequestPolicyErrorKind = UpdateOriginRequestPolicyError;
/// Error type for the `UpdateOriginRequestPolicyError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateOriginRequestPolicyError {
    /// <p>Access denied.</p>
    AccessDenied(crate::error::AccessDenied),
    /// <p>The update contains modifications that are not allowed.</p>
    IllegalUpdate(crate::error::IllegalUpdate),
    /// <p>The value of <code>Quantity</code> and the size of <code>Items</code> don't match.</p>
    InconsistentQuantities(crate::error::InconsistentQuantities),
    /// <p>An argument is invalid.</p>
    InvalidArgument(crate::error::InvalidArgument),
    /// <p>The <code>If-Match</code> version is missing or not valid.</p>
    InvalidIfMatchVersion(crate::error::InvalidIfMatchVersion),
    /// <p>The origin request policy does not exist.</p>
    NoSuchOriginRequestPolicy(crate::error::NoSuchOriginRequestPolicy),
    /// <p>An origin request policy with this name already exists. You must provide a unique name. To modify an existing origin request policy, use <code>UpdateOriginRequestPolicy</code>.</p>
    OriginRequestPolicyAlreadyExists(crate::error::OriginRequestPolicyAlreadyExists),
    /// <p>The precondition in one or more of the request fields evaluated to <code>false</code>.</p>
    PreconditionFailed(crate::error::PreconditionFailed),
    /// <p>The number of cookies in the origin request policy exceeds the maximum. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
    TooManyCookiesInOriginRequestPolicy(crate::error::TooManyCookiesInOriginRequestPolicy),
    /// <p>The number of headers in the origin request policy exceeds the maximum. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
    TooManyHeadersInOriginRequestPolicy(crate::error::TooManyHeadersInOriginRequestPolicy),
    /// <p>The number of query strings in the origin request policy exceeds the maximum. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
    TooManyQueryStringsInOriginRequestPolicy(
        crate::error::TooManyQueryStringsInOriginRequestPolicy,
    ),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for UpdateOriginRequestPolicyError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for UpdateOriginRequestPolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AccessDenied(_inner) => _inner.fmt(f),
            Self::IllegalUpdate(_inner) => _inner.fmt(f),
            Self::InconsistentQuantities(_inner) => _inner.fmt(f),
            Self::InvalidArgument(_inner) => _inner.fmt(f),
            Self::InvalidIfMatchVersion(_inner) => _inner.fmt(f),
            Self::NoSuchOriginRequestPolicy(_inner) => _inner.fmt(f),
            Self::OriginRequestPolicyAlreadyExists(_inner) => _inner.fmt(f),
            Self::PreconditionFailed(_inner) => _inner.fmt(f),
            Self::TooManyCookiesInOriginRequestPolicy(_inner) => _inner.fmt(f),
            Self::TooManyHeadersInOriginRequestPolicy(_inner) => _inner.fmt(f),
            Self::TooManyQueryStringsInOriginRequestPolicy(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for UpdateOriginRequestPolicyError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AccessDenied(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::IllegalUpdate(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InconsistentQuantities(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidArgument(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidIfMatchVersion(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NoSuchOriginRequestPolicy(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::OriginRequestPolicyAlreadyExists(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::PreconditionFailed(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyCookiesInOriginRequestPolicy(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyHeadersInOriginRequestPolicy(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyQueryStringsInOriginRequestPolicy(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::UpdateOriginRequestPolicyError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateOriginRequestPolicyError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateOriginRequestPolicyError {
    /// Creates the `UpdateOriginRequestPolicyError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `UpdateOriginRequestPolicyError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AccessDenied(e) => e.meta(),
            Self::IllegalUpdate(e) => e.meta(),
            Self::InconsistentQuantities(e) => e.meta(),
            Self::InvalidArgument(e) => e.meta(),
            Self::InvalidIfMatchVersion(e) => e.meta(),
            Self::NoSuchOriginRequestPolicy(e) => e.meta(),
            Self::OriginRequestPolicyAlreadyExists(e) => e.meta(),
            Self::PreconditionFailed(e) => e.meta(),
            Self::TooManyCookiesInOriginRequestPolicy(e) => e.meta(),
            Self::TooManyHeadersInOriginRequestPolicy(e) => e.meta(),
            Self::TooManyQueryStringsInOriginRequestPolicy(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `UpdateOriginRequestPolicyError::AccessDenied`.
    pub fn is_access_denied(&self) -> bool {
        matches!(self, Self::AccessDenied(_))
    }
    /// Returns `true` if the error kind is `UpdateOriginRequestPolicyError::IllegalUpdate`.
    pub fn is_illegal_update(&self) -> bool {
        matches!(self, Self::IllegalUpdate(_))
    }
    /// Returns `true` if the error kind is `UpdateOriginRequestPolicyError::InconsistentQuantities`.
    pub fn is_inconsistent_quantities(&self) -> bool {
        matches!(self, Self::InconsistentQuantities(_))
    }
    /// Returns `true` if the error kind is `UpdateOriginRequestPolicyError::InvalidArgument`.
    pub fn is_invalid_argument(&self) -> bool {
        matches!(self, Self::InvalidArgument(_))
    }
    /// Returns `true` if the error kind is `UpdateOriginRequestPolicyError::InvalidIfMatchVersion`.
    pub fn is_invalid_if_match_version(&self) -> bool {
        matches!(self, Self::InvalidIfMatchVersion(_))
    }
    /// Returns `true` if the error kind is `UpdateOriginRequestPolicyError::NoSuchOriginRequestPolicy`.
    pub fn is_no_such_origin_request_policy(&self) -> bool {
        matches!(self, Self::NoSuchOriginRequestPolicy(_))
    }
    /// Returns `true` if the error kind is `UpdateOriginRequestPolicyError::OriginRequestPolicyAlreadyExists`.
    pub fn is_origin_request_policy_already_exists(&self) -> bool {
        matches!(self, Self::OriginRequestPolicyAlreadyExists(_))
    }
    /// Returns `true` if the error kind is `UpdateOriginRequestPolicyError::PreconditionFailed`.
    pub fn is_precondition_failed(&self) -> bool {
        matches!(self, Self::PreconditionFailed(_))
    }
    /// Returns `true` if the error kind is `UpdateOriginRequestPolicyError::TooManyCookiesInOriginRequestPolicy`.
    pub fn is_too_many_cookies_in_origin_request_policy(&self) -> bool {
        matches!(self, Self::TooManyCookiesInOriginRequestPolicy(_))
    }
    /// Returns `true` if the error kind is `UpdateOriginRequestPolicyError::TooManyHeadersInOriginRequestPolicy`.
    pub fn is_too_many_headers_in_origin_request_policy(&self) -> bool {
        matches!(self, Self::TooManyHeadersInOriginRequestPolicy(_))
    }
    /// Returns `true` if the error kind is `UpdateOriginRequestPolicyError::TooManyQueryStringsInOriginRequestPolicy`.
    pub fn is_too_many_query_strings_in_origin_request_policy(&self) -> bool {
        matches!(self, Self::TooManyQueryStringsInOriginRequestPolicy(_))
    }
}
impl std::error::Error for UpdateOriginRequestPolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AccessDenied(_inner) => Some(_inner),
            Self::IllegalUpdate(_inner) => Some(_inner),
            Self::InconsistentQuantities(_inner) => Some(_inner),
            Self::InvalidArgument(_inner) => Some(_inner),
            Self::InvalidIfMatchVersion(_inner) => Some(_inner),
            Self::NoSuchOriginRequestPolicy(_inner) => Some(_inner),
            Self::OriginRequestPolicyAlreadyExists(_inner) => Some(_inner),
            Self::PreconditionFailed(_inner) => Some(_inner),
            Self::TooManyCookiesInOriginRequestPolicy(_inner) => Some(_inner),
            Self::TooManyHeadersInOriginRequestPolicy(_inner) => Some(_inner),
            Self::TooManyQueryStringsInOriginRequestPolicy(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The number of query strings in the origin request policy exceeds the maximum. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TooManyQueryStringsInOriginRequestPolicy {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl TooManyQueryStringsInOriginRequestPolicy {
    /// Creates a new builder-style object to manufacture [`TooManyQueryStringsInOriginRequestPolicy`](crate::error::TooManyQueryStringsInOriginRequestPolicy).
    pub fn builder() -> crate::error::too_many_query_strings_in_origin_request_policy::Builder {
        crate::error::too_many_query_strings_in_origin_request_policy::Builder::default()
    }
}
/// See [`TooManyQueryStringsInOriginRequestPolicy`](crate::error::TooManyQueryStringsInOriginRequestPolicy).
pub mod too_many_query_strings_in_origin_request_policy {

    /// A builder for [`TooManyQueryStringsInOriginRequestPolicy`](crate::error::TooManyQueryStringsInOriginRequestPolicy).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`TooManyQueryStringsInOriginRequestPolicy`](crate::error::TooManyQueryStringsInOriginRequestPolicy).
        pub fn build(self) -> crate::error::TooManyQueryStringsInOriginRequestPolicy {
            crate::error::TooManyQueryStringsInOriginRequestPolicy {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl TooManyQueryStringsInOriginRequestPolicy {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TooManyQueryStringsInOriginRequestPolicy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TooManyQueryStringsInOriginRequestPolicy")?;
        if let Some(inner_23) = &self.message {
            {
                write!(f, ": {}", inner_23)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for TooManyQueryStringsInOriginRequestPolicy {}
impl aws_http::request_id::RequestId for crate::error::TooManyQueryStringsInOriginRequestPolicy {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for TooManyQueryStringsInOriginRequestPolicy
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The number of headers in the origin request policy exceeds the maximum. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TooManyHeadersInOriginRequestPolicy {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl TooManyHeadersInOriginRequestPolicy {
    /// Creates a new builder-style object to manufacture [`TooManyHeadersInOriginRequestPolicy`](crate::error::TooManyHeadersInOriginRequestPolicy).
    pub fn builder() -> crate::error::too_many_headers_in_origin_request_policy::Builder {
        crate::error::too_many_headers_in_origin_request_policy::Builder::default()
    }
}
/// See [`TooManyHeadersInOriginRequestPolicy`](crate::error::TooManyHeadersInOriginRequestPolicy).
pub mod too_many_headers_in_origin_request_policy {

    /// A builder for [`TooManyHeadersInOriginRequestPolicy`](crate::error::TooManyHeadersInOriginRequestPolicy).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`TooManyHeadersInOriginRequestPolicy`](crate::error::TooManyHeadersInOriginRequestPolicy).
        pub fn build(self) -> crate::error::TooManyHeadersInOriginRequestPolicy {
            crate::error::TooManyHeadersInOriginRequestPolicy {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl TooManyHeadersInOriginRequestPolicy {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TooManyHeadersInOriginRequestPolicy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TooManyHeadersInOriginRequestPolicy")?;
        if let Some(inner_24) = &self.message {
            {
                write!(f, ": {}", inner_24)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for TooManyHeadersInOriginRequestPolicy {}
impl aws_http::request_id::RequestId for crate::error::TooManyHeadersInOriginRequestPolicy {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for TooManyHeadersInOriginRequestPolicy
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The number of cookies in the origin request policy exceeds the maximum. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TooManyCookiesInOriginRequestPolicy {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl TooManyCookiesInOriginRequestPolicy {
    /// Creates a new builder-style object to manufacture [`TooManyCookiesInOriginRequestPolicy`](crate::error::TooManyCookiesInOriginRequestPolicy).
    pub fn builder() -> crate::error::too_many_cookies_in_origin_request_policy::Builder {
        crate::error::too_many_cookies_in_origin_request_policy::Builder::default()
    }
}
/// See [`TooManyCookiesInOriginRequestPolicy`](crate::error::TooManyCookiesInOriginRequestPolicy).
pub mod too_many_cookies_in_origin_request_policy {

    /// A builder for [`TooManyCookiesInOriginRequestPolicy`](crate::error::TooManyCookiesInOriginRequestPolicy).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`TooManyCookiesInOriginRequestPolicy`](crate::error::TooManyCookiesInOriginRequestPolicy).
        pub fn build(self) -> crate::error::TooManyCookiesInOriginRequestPolicy {
            crate::error::TooManyCookiesInOriginRequestPolicy {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl TooManyCookiesInOriginRequestPolicy {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TooManyCookiesInOriginRequestPolicy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TooManyCookiesInOriginRequestPolicy")?;
        if let Some(inner_25) = &self.message {
            {
                write!(f, ": {}", inner_25)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for TooManyCookiesInOriginRequestPolicy {}
impl aws_http::request_id::RequestId for crate::error::TooManyCookiesInOriginRequestPolicy {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for TooManyCookiesInOriginRequestPolicy
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>An origin request policy with this name already exists. You must provide a unique name. To modify an existing origin request policy, use <code>UpdateOriginRequestPolicy</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct OriginRequestPolicyAlreadyExists {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl OriginRequestPolicyAlreadyExists {
    /// Creates a new builder-style object to manufacture [`OriginRequestPolicyAlreadyExists`](crate::error::OriginRequestPolicyAlreadyExists).
    pub fn builder() -> crate::error::origin_request_policy_already_exists::Builder {
        crate::error::origin_request_policy_already_exists::Builder::default()
    }
}
/// See [`OriginRequestPolicyAlreadyExists`](crate::error::OriginRequestPolicyAlreadyExists).
pub mod origin_request_policy_already_exists {

    /// A builder for [`OriginRequestPolicyAlreadyExists`](crate::error::OriginRequestPolicyAlreadyExists).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`OriginRequestPolicyAlreadyExists`](crate::error::OriginRequestPolicyAlreadyExists).
        pub fn build(self) -> crate::error::OriginRequestPolicyAlreadyExists {
            crate::error::OriginRequestPolicyAlreadyExists {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl OriginRequestPolicyAlreadyExists {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for OriginRequestPolicyAlreadyExists {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "OriginRequestPolicyAlreadyExists")?;
        if let Some(inner_26) = &self.message {
            {
                write!(f, ": {}", inner_26)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for OriginRequestPolicyAlreadyExists {}
impl aws_http::request_id::RequestId for crate::error::OriginRequestPolicyAlreadyExists {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for OriginRequestPolicyAlreadyExists {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The origin request policy does not exist.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct NoSuchOriginRequestPolicy {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl NoSuchOriginRequestPolicy {
    /// Creates a new builder-style object to manufacture [`NoSuchOriginRequestPolicy`](crate::error::NoSuchOriginRequestPolicy).
    pub fn builder() -> crate::error::no_such_origin_request_policy::Builder {
        crate::error::no_such_origin_request_policy::Builder::default()
    }
}
/// See [`NoSuchOriginRequestPolicy`](crate::error::NoSuchOriginRequestPolicy).
pub mod no_such_origin_request_policy {

    /// A builder for [`NoSuchOriginRequestPolicy`](crate::error::NoSuchOriginRequestPolicy).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`NoSuchOriginRequestPolicy`](crate::error::NoSuchOriginRequestPolicy).
        pub fn build(self) -> crate::error::NoSuchOriginRequestPolicy {
            crate::error::NoSuchOriginRequestPolicy {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl NoSuchOriginRequestPolicy {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for NoSuchOriginRequestPolicy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "NoSuchOriginRequestPolicy")?;
        if let Some(inner_27) = &self.message {
            {
                write!(f, ": {}", inner_27)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for NoSuchOriginRequestPolicy {}
impl aws_http::request_id::RequestId for crate::error::NoSuchOriginRequestPolicy {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for NoSuchOriginRequestPolicy {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type UpdateOriginAccessControlErrorKind = UpdateOriginAccessControlError;
/// Error type for the `UpdateOriginAccessControlError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateOriginAccessControlError {
    /// <p>Access denied.</p>
    AccessDenied(crate::error::AccessDenied),
    /// <p>The update contains modifications that are not allowed.</p>
    IllegalUpdate(crate::error::IllegalUpdate),
    /// <p>An argument is invalid.</p>
    InvalidArgument(crate::error::InvalidArgument),
    /// <p>The <code>If-Match</code> version is missing or not valid.</p>
    InvalidIfMatchVersion(crate::error::InvalidIfMatchVersion),
    /// <p>The origin access control does not exist.</p>
    NoSuchOriginAccessControl(crate::error::NoSuchOriginAccessControl),
    /// <p>An origin access control with the specified parameters already exists.</p>
    OriginAccessControlAlreadyExists(crate::error::OriginAccessControlAlreadyExists),
    /// <p>The precondition in one or more of the request fields evaluated to <code>false</code>.</p>
    PreconditionFailed(crate::error::PreconditionFailed),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for UpdateOriginAccessControlError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for UpdateOriginAccessControlError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AccessDenied(_inner) => _inner.fmt(f),
            Self::IllegalUpdate(_inner) => _inner.fmt(f),
            Self::InvalidArgument(_inner) => _inner.fmt(f),
            Self::InvalidIfMatchVersion(_inner) => _inner.fmt(f),
            Self::NoSuchOriginAccessControl(_inner) => _inner.fmt(f),
            Self::OriginAccessControlAlreadyExists(_inner) => _inner.fmt(f),
            Self::PreconditionFailed(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for UpdateOriginAccessControlError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AccessDenied(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::IllegalUpdate(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidArgument(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidIfMatchVersion(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NoSuchOriginAccessControl(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::OriginAccessControlAlreadyExists(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::PreconditionFailed(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::UpdateOriginAccessControlError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateOriginAccessControlError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateOriginAccessControlError {
    /// Creates the `UpdateOriginAccessControlError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `UpdateOriginAccessControlError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AccessDenied(e) => e.meta(),
            Self::IllegalUpdate(e) => e.meta(),
            Self::InvalidArgument(e) => e.meta(),
            Self::InvalidIfMatchVersion(e) => e.meta(),
            Self::NoSuchOriginAccessControl(e) => e.meta(),
            Self::OriginAccessControlAlreadyExists(e) => e.meta(),
            Self::PreconditionFailed(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `UpdateOriginAccessControlError::AccessDenied`.
    pub fn is_access_denied(&self) -> bool {
        matches!(self, Self::AccessDenied(_))
    }
    /// Returns `true` if the error kind is `UpdateOriginAccessControlError::IllegalUpdate`.
    pub fn is_illegal_update(&self) -> bool {
        matches!(self, Self::IllegalUpdate(_))
    }
    /// Returns `true` if the error kind is `UpdateOriginAccessControlError::InvalidArgument`.
    pub fn is_invalid_argument(&self) -> bool {
        matches!(self, Self::InvalidArgument(_))
    }
    /// Returns `true` if the error kind is `UpdateOriginAccessControlError::InvalidIfMatchVersion`.
    pub fn is_invalid_if_match_version(&self) -> bool {
        matches!(self, Self::InvalidIfMatchVersion(_))
    }
    /// Returns `true` if the error kind is `UpdateOriginAccessControlError::NoSuchOriginAccessControl`.
    pub fn is_no_such_origin_access_control(&self) -> bool {
        matches!(self, Self::NoSuchOriginAccessControl(_))
    }
    /// Returns `true` if the error kind is `UpdateOriginAccessControlError::OriginAccessControlAlreadyExists`.
    pub fn is_origin_access_control_already_exists(&self) -> bool {
        matches!(self, Self::OriginAccessControlAlreadyExists(_))
    }
    /// Returns `true` if the error kind is `UpdateOriginAccessControlError::PreconditionFailed`.
    pub fn is_precondition_failed(&self) -> bool {
        matches!(self, Self::PreconditionFailed(_))
    }
}
impl std::error::Error for UpdateOriginAccessControlError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AccessDenied(_inner) => Some(_inner),
            Self::IllegalUpdate(_inner) => Some(_inner),
            Self::InvalidArgument(_inner) => Some(_inner),
            Self::InvalidIfMatchVersion(_inner) => Some(_inner),
            Self::NoSuchOriginAccessControl(_inner) => Some(_inner),
            Self::OriginAccessControlAlreadyExists(_inner) => Some(_inner),
            Self::PreconditionFailed(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>An origin access control with the specified parameters already exists.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct OriginAccessControlAlreadyExists {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl OriginAccessControlAlreadyExists {
    /// Creates a new builder-style object to manufacture [`OriginAccessControlAlreadyExists`](crate::error::OriginAccessControlAlreadyExists).
    pub fn builder() -> crate::error::origin_access_control_already_exists::Builder {
        crate::error::origin_access_control_already_exists::Builder::default()
    }
}
/// See [`OriginAccessControlAlreadyExists`](crate::error::OriginAccessControlAlreadyExists).
pub mod origin_access_control_already_exists {

    /// A builder for [`OriginAccessControlAlreadyExists`](crate::error::OriginAccessControlAlreadyExists).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`OriginAccessControlAlreadyExists`](crate::error::OriginAccessControlAlreadyExists).
        pub fn build(self) -> crate::error::OriginAccessControlAlreadyExists {
            crate::error::OriginAccessControlAlreadyExists {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl OriginAccessControlAlreadyExists {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for OriginAccessControlAlreadyExists {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "OriginAccessControlAlreadyExists")?;
        if let Some(inner_28) = &self.message {
            {
                write!(f, ": {}", inner_28)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for OriginAccessControlAlreadyExists {}
impl aws_http::request_id::RequestId for crate::error::OriginAccessControlAlreadyExists {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for OriginAccessControlAlreadyExists {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The origin access control does not exist.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct NoSuchOriginAccessControl {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl NoSuchOriginAccessControl {
    /// Creates a new builder-style object to manufacture [`NoSuchOriginAccessControl`](crate::error::NoSuchOriginAccessControl).
    pub fn builder() -> crate::error::no_such_origin_access_control::Builder {
        crate::error::no_such_origin_access_control::Builder::default()
    }
}
/// See [`NoSuchOriginAccessControl`](crate::error::NoSuchOriginAccessControl).
pub mod no_such_origin_access_control {

    /// A builder for [`NoSuchOriginAccessControl`](crate::error::NoSuchOriginAccessControl).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`NoSuchOriginAccessControl`](crate::error::NoSuchOriginAccessControl).
        pub fn build(self) -> crate::error::NoSuchOriginAccessControl {
            crate::error::NoSuchOriginAccessControl {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl NoSuchOriginAccessControl {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for NoSuchOriginAccessControl {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "NoSuchOriginAccessControl")?;
        if let Some(inner_29) = &self.message {
            {
                write!(f, ": {}", inner_29)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for NoSuchOriginAccessControl {}
impl aws_http::request_id::RequestId for crate::error::NoSuchOriginAccessControl {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for NoSuchOriginAccessControl {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type UpdateKeyGroupErrorKind = UpdateKeyGroupError;
/// Error type for the `UpdateKeyGroupError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateKeyGroupError {
    /// <p>An argument is invalid.</p>
    InvalidArgument(crate::error::InvalidArgument),
    /// <p>The <code>If-Match</code> version is missing or not valid.</p>
    InvalidIfMatchVersion(crate::error::InvalidIfMatchVersion),
    /// <p>A key group with this name already exists. You must provide a unique name. To modify an existing key group, use <code>UpdateKeyGroup</code>.</p>
    KeyGroupAlreadyExists(crate::error::KeyGroupAlreadyExists),
    /// <p>A resource that was specified is not valid.</p>
    NoSuchResource(crate::error::NoSuchResource),
    /// <p>The precondition in one or more of the request fields evaluated to <code>false</code>.</p>
    PreconditionFailed(crate::error::PreconditionFailed),
    /// <p>The number of public keys in this key group is more than the maximum allowed. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
    TooManyPublicKeysInKeyGroup(crate::error::TooManyPublicKeysInKeyGroup),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for UpdateKeyGroupError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for UpdateKeyGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::InvalidArgument(_inner) => _inner.fmt(f),
            Self::InvalidIfMatchVersion(_inner) => _inner.fmt(f),
            Self::KeyGroupAlreadyExists(_inner) => _inner.fmt(f),
            Self::NoSuchResource(_inner) => _inner.fmt(f),
            Self::PreconditionFailed(_inner) => _inner.fmt(f),
            Self::TooManyPublicKeysInKeyGroup(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for UpdateKeyGroupError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::InvalidArgument(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidIfMatchVersion(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::KeyGroupAlreadyExists(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NoSuchResource(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::PreconditionFailed(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyPublicKeysInKeyGroup(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::UpdateKeyGroupError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateKeyGroupError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateKeyGroupError {
    /// Creates the `UpdateKeyGroupError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `UpdateKeyGroupError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::InvalidArgument(e) => e.meta(),
            Self::InvalidIfMatchVersion(e) => e.meta(),
            Self::KeyGroupAlreadyExists(e) => e.meta(),
            Self::NoSuchResource(e) => e.meta(),
            Self::PreconditionFailed(e) => e.meta(),
            Self::TooManyPublicKeysInKeyGroup(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `UpdateKeyGroupError::InvalidArgument`.
    pub fn is_invalid_argument(&self) -> bool {
        matches!(self, Self::InvalidArgument(_))
    }
    /// Returns `true` if the error kind is `UpdateKeyGroupError::InvalidIfMatchVersion`.
    pub fn is_invalid_if_match_version(&self) -> bool {
        matches!(self, Self::InvalidIfMatchVersion(_))
    }
    /// Returns `true` if the error kind is `UpdateKeyGroupError::KeyGroupAlreadyExists`.
    pub fn is_key_group_already_exists(&self) -> bool {
        matches!(self, Self::KeyGroupAlreadyExists(_))
    }
    /// Returns `true` if the error kind is `UpdateKeyGroupError::NoSuchResource`.
    pub fn is_no_such_resource(&self) -> bool {
        matches!(self, Self::NoSuchResource(_))
    }
    /// Returns `true` if the error kind is `UpdateKeyGroupError::PreconditionFailed`.
    pub fn is_precondition_failed(&self) -> bool {
        matches!(self, Self::PreconditionFailed(_))
    }
    /// Returns `true` if the error kind is `UpdateKeyGroupError::TooManyPublicKeysInKeyGroup`.
    pub fn is_too_many_public_keys_in_key_group(&self) -> bool {
        matches!(self, Self::TooManyPublicKeysInKeyGroup(_))
    }
}
impl std::error::Error for UpdateKeyGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::InvalidArgument(_inner) => Some(_inner),
            Self::InvalidIfMatchVersion(_inner) => Some(_inner),
            Self::KeyGroupAlreadyExists(_inner) => Some(_inner),
            Self::NoSuchResource(_inner) => Some(_inner),
            Self::PreconditionFailed(_inner) => Some(_inner),
            Self::TooManyPublicKeysInKeyGroup(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The number of public keys in this key group is more than the maximum allowed. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TooManyPublicKeysInKeyGroup {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl TooManyPublicKeysInKeyGroup {
    /// Creates a new builder-style object to manufacture [`TooManyPublicKeysInKeyGroup`](crate::error::TooManyPublicKeysInKeyGroup).
    pub fn builder() -> crate::error::too_many_public_keys_in_key_group::Builder {
        crate::error::too_many_public_keys_in_key_group::Builder::default()
    }
}
/// See [`TooManyPublicKeysInKeyGroup`](crate::error::TooManyPublicKeysInKeyGroup).
pub mod too_many_public_keys_in_key_group {

    /// A builder for [`TooManyPublicKeysInKeyGroup`](crate::error::TooManyPublicKeysInKeyGroup).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`TooManyPublicKeysInKeyGroup`](crate::error::TooManyPublicKeysInKeyGroup).
        pub fn build(self) -> crate::error::TooManyPublicKeysInKeyGroup {
            crate::error::TooManyPublicKeysInKeyGroup {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl TooManyPublicKeysInKeyGroup {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TooManyPublicKeysInKeyGroup {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TooManyPublicKeysInKeyGroup")?;
        if let Some(inner_30) = &self.message {
            {
                write!(f, ": {}", inner_30)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for TooManyPublicKeysInKeyGroup {}
impl aws_http::request_id::RequestId for crate::error::TooManyPublicKeysInKeyGroup {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for TooManyPublicKeysInKeyGroup {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>A resource that was specified is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct NoSuchResource {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl NoSuchResource {
    /// Creates a new builder-style object to manufacture [`NoSuchResource`](crate::error::NoSuchResource).
    pub fn builder() -> crate::error::no_such_resource::Builder {
        crate::error::no_such_resource::Builder::default()
    }
}
/// See [`NoSuchResource`](crate::error::NoSuchResource).
pub mod no_such_resource {

    /// A builder for [`NoSuchResource`](crate::error::NoSuchResource).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`NoSuchResource`](crate::error::NoSuchResource).
        pub fn build(self) -> crate::error::NoSuchResource {
            crate::error::NoSuchResource {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl NoSuchResource {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for NoSuchResource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "NoSuchResource")?;
        if let Some(inner_31) = &self.message {
            {
                write!(f, ": {}", inner_31)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for NoSuchResource {}
impl aws_http::request_id::RequestId for crate::error::NoSuchResource {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for NoSuchResource {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>A key group with this name already exists. You must provide a unique name. To modify an existing key group, use <code>UpdateKeyGroup</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct KeyGroupAlreadyExists {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl KeyGroupAlreadyExists {
    /// Creates a new builder-style object to manufacture [`KeyGroupAlreadyExists`](crate::error::KeyGroupAlreadyExists).
    pub fn builder() -> crate::error::key_group_already_exists::Builder {
        crate::error::key_group_already_exists::Builder::default()
    }
}
/// See [`KeyGroupAlreadyExists`](crate::error::KeyGroupAlreadyExists).
pub mod key_group_already_exists {

    /// A builder for [`KeyGroupAlreadyExists`](crate::error::KeyGroupAlreadyExists).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`KeyGroupAlreadyExists`](crate::error::KeyGroupAlreadyExists).
        pub fn build(self) -> crate::error::KeyGroupAlreadyExists {
            crate::error::KeyGroupAlreadyExists {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl KeyGroupAlreadyExists {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for KeyGroupAlreadyExists {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "KeyGroupAlreadyExists")?;
        if let Some(inner_32) = &self.message {
            {
                write!(f, ": {}", inner_32)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for KeyGroupAlreadyExists {}
impl aws_http::request_id::RequestId for crate::error::KeyGroupAlreadyExists {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for KeyGroupAlreadyExists {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type UpdateFunctionErrorKind = UpdateFunctionError;
/// Error type for the `UpdateFunctionError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateFunctionError {
    /// <p>The function is too large. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
    FunctionSizeLimitExceeded(crate::error::FunctionSizeLimitExceeded),
    /// <p>An argument is invalid.</p>
    InvalidArgument(crate::error::InvalidArgument),
    /// <p>The <code>If-Match</code> version is missing or not valid.</p>
    InvalidIfMatchVersion(crate::error::InvalidIfMatchVersion),
    /// <p>The function does not exist.</p>
    NoSuchFunctionExists(crate::error::NoSuchFunctionExists),
    /// <p>The precondition in one or more of the request fields evaluated to <code>false</code>.</p>
    PreconditionFailed(crate::error::PreconditionFailed),
    /// <p>This operation is not supported in this region.</p>
    UnsupportedOperation(crate::error::UnsupportedOperation),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for UpdateFunctionError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for UpdateFunctionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::FunctionSizeLimitExceeded(_inner) => _inner.fmt(f),
            Self::InvalidArgument(_inner) => _inner.fmt(f),
            Self::InvalidIfMatchVersion(_inner) => _inner.fmt(f),
            Self::NoSuchFunctionExists(_inner) => _inner.fmt(f),
            Self::PreconditionFailed(_inner) => _inner.fmt(f),
            Self::UnsupportedOperation(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for UpdateFunctionError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::FunctionSizeLimitExceeded(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidArgument(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidIfMatchVersion(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NoSuchFunctionExists(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::PreconditionFailed(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnsupportedOperation(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::UpdateFunctionError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateFunctionError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateFunctionError {
    /// Creates the `UpdateFunctionError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `UpdateFunctionError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::FunctionSizeLimitExceeded(e) => e.meta(),
            Self::InvalidArgument(e) => e.meta(),
            Self::InvalidIfMatchVersion(e) => e.meta(),
            Self::NoSuchFunctionExists(e) => e.meta(),
            Self::PreconditionFailed(e) => e.meta(),
            Self::UnsupportedOperation(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `UpdateFunctionError::FunctionSizeLimitExceeded`.
    pub fn is_function_size_limit_exceeded(&self) -> bool {
        matches!(self, Self::FunctionSizeLimitExceeded(_))
    }
    /// Returns `true` if the error kind is `UpdateFunctionError::InvalidArgument`.
    pub fn is_invalid_argument(&self) -> bool {
        matches!(self, Self::InvalidArgument(_))
    }
    /// Returns `true` if the error kind is `UpdateFunctionError::InvalidIfMatchVersion`.
    pub fn is_invalid_if_match_version(&self) -> bool {
        matches!(self, Self::InvalidIfMatchVersion(_))
    }
    /// Returns `true` if the error kind is `UpdateFunctionError::NoSuchFunctionExists`.
    pub fn is_no_such_function_exists(&self) -> bool {
        matches!(self, Self::NoSuchFunctionExists(_))
    }
    /// Returns `true` if the error kind is `UpdateFunctionError::PreconditionFailed`.
    pub fn is_precondition_failed(&self) -> bool {
        matches!(self, Self::PreconditionFailed(_))
    }
    /// Returns `true` if the error kind is `UpdateFunctionError::UnsupportedOperation`.
    pub fn is_unsupported_operation(&self) -> bool {
        matches!(self, Self::UnsupportedOperation(_))
    }
}
impl std::error::Error for UpdateFunctionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::FunctionSizeLimitExceeded(_inner) => Some(_inner),
            Self::InvalidArgument(_inner) => Some(_inner),
            Self::InvalidIfMatchVersion(_inner) => Some(_inner),
            Self::NoSuchFunctionExists(_inner) => Some(_inner),
            Self::PreconditionFailed(_inner) => Some(_inner),
            Self::UnsupportedOperation(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>This operation is not supported in this region.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UnsupportedOperation {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl UnsupportedOperation {
    /// Creates a new builder-style object to manufacture [`UnsupportedOperation`](crate::error::UnsupportedOperation).
    pub fn builder() -> crate::error::unsupported_operation::Builder {
        crate::error::unsupported_operation::Builder::default()
    }
}
/// See [`UnsupportedOperation`](crate::error::UnsupportedOperation).
pub mod unsupported_operation {

    /// A builder for [`UnsupportedOperation`](crate::error::UnsupportedOperation).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`UnsupportedOperation`](crate::error::UnsupportedOperation).
        pub fn build(self) -> crate::error::UnsupportedOperation {
            crate::error::UnsupportedOperation {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl UnsupportedOperation {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for UnsupportedOperation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "UnsupportedOperation")?;
        if let Some(inner_33) = &self.message {
            {
                write!(f, ": {}", inner_33)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for UnsupportedOperation {}
impl aws_http::request_id::RequestId for crate::error::UnsupportedOperation {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for UnsupportedOperation {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The function does not exist.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct NoSuchFunctionExists {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl NoSuchFunctionExists {
    /// Creates a new builder-style object to manufacture [`NoSuchFunctionExists`](crate::error::NoSuchFunctionExists).
    pub fn builder() -> crate::error::no_such_function_exists::Builder {
        crate::error::no_such_function_exists::Builder::default()
    }
}
/// See [`NoSuchFunctionExists`](crate::error::NoSuchFunctionExists).
pub mod no_such_function_exists {

    /// A builder for [`NoSuchFunctionExists`](crate::error::NoSuchFunctionExists).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`NoSuchFunctionExists`](crate::error::NoSuchFunctionExists).
        pub fn build(self) -> crate::error::NoSuchFunctionExists {
            crate::error::NoSuchFunctionExists {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl NoSuchFunctionExists {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for NoSuchFunctionExists {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "NoSuchFunctionExists")?;
        if let Some(inner_34) = &self.message {
            {
                write!(f, ": {}", inner_34)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for NoSuchFunctionExists {}
impl aws_http::request_id::RequestId for crate::error::NoSuchFunctionExists {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for NoSuchFunctionExists {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The function is too large. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FunctionSizeLimitExceeded {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl FunctionSizeLimitExceeded {
    /// Creates a new builder-style object to manufacture [`FunctionSizeLimitExceeded`](crate::error::FunctionSizeLimitExceeded).
    pub fn builder() -> crate::error::function_size_limit_exceeded::Builder {
        crate::error::function_size_limit_exceeded::Builder::default()
    }
}
/// See [`FunctionSizeLimitExceeded`](crate::error::FunctionSizeLimitExceeded).
pub mod function_size_limit_exceeded {

    /// A builder for [`FunctionSizeLimitExceeded`](crate::error::FunctionSizeLimitExceeded).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`FunctionSizeLimitExceeded`](crate::error::FunctionSizeLimitExceeded).
        pub fn build(self) -> crate::error::FunctionSizeLimitExceeded {
            crate::error::FunctionSizeLimitExceeded {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl FunctionSizeLimitExceeded {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for FunctionSizeLimitExceeded {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "FunctionSizeLimitExceeded")?;
        if let Some(inner_35) = &self.message {
            {
                write!(f, ": {}", inner_35)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for FunctionSizeLimitExceeded {}
impl aws_http::request_id::RequestId for crate::error::FunctionSizeLimitExceeded {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for FunctionSizeLimitExceeded {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type UpdateFieldLevelEncryptionProfileErrorKind = UpdateFieldLevelEncryptionProfileError;
/// Error type for the `UpdateFieldLevelEncryptionProfileError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateFieldLevelEncryptionProfileError {
    /// <p>Access denied.</p>
    AccessDenied(crate::error::AccessDenied),
    /// <p>The specified profile for field-level encryption already exists.</p>
    FieldLevelEncryptionProfileAlreadyExists(
        crate::error::FieldLevelEncryptionProfileAlreadyExists,
    ),
    /// <p>The maximum size of a profile for field-level encryption was exceeded.</p>
    FieldLevelEncryptionProfileSizeExceeded(crate::error::FieldLevelEncryptionProfileSizeExceeded),
    /// <p>The update contains modifications that are not allowed.</p>
    IllegalUpdate(crate::error::IllegalUpdate),
    /// <p>The value of <code>Quantity</code> and the size of <code>Items</code> don't match.</p>
    InconsistentQuantities(crate::error::InconsistentQuantities),
    /// <p>An argument is invalid.</p>
    InvalidArgument(crate::error::InvalidArgument),
    /// <p>The <code>If-Match</code> version is missing or not valid.</p>
    InvalidIfMatchVersion(crate::error::InvalidIfMatchVersion),
    /// <p>The specified profile for field-level encryption doesn't exist.</p>
    NoSuchFieldLevelEncryptionProfile(crate::error::NoSuchFieldLevelEncryptionProfile),
    /// <p>The specified public key doesn't exist.</p>
    NoSuchPublicKey(crate::error::NoSuchPublicKey),
    /// <p>The precondition in one or more of the request fields evaluated to <code>false</code>.</p>
    PreconditionFailed(crate::error::PreconditionFailed),
    /// <p>The maximum number of encryption entities for field-level encryption have been created.</p>
    TooManyFieldLevelEncryptionEncryptionEntities(
        crate::error::TooManyFieldLevelEncryptionEncryptionEntities,
    ),
    /// <p>The maximum number of field patterns for field-level encryption have been created.</p>
    TooManyFieldLevelEncryptionFieldPatterns(
        crate::error::TooManyFieldLevelEncryptionFieldPatterns,
    ),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for UpdateFieldLevelEncryptionProfileError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for UpdateFieldLevelEncryptionProfileError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AccessDenied(_inner) => _inner.fmt(f),
            Self::FieldLevelEncryptionProfileAlreadyExists(_inner) => _inner.fmt(f),
            Self::FieldLevelEncryptionProfileSizeExceeded(_inner) => _inner.fmt(f),
            Self::IllegalUpdate(_inner) => _inner.fmt(f),
            Self::InconsistentQuantities(_inner) => _inner.fmt(f),
            Self::InvalidArgument(_inner) => _inner.fmt(f),
            Self::InvalidIfMatchVersion(_inner) => _inner.fmt(f),
            Self::NoSuchFieldLevelEncryptionProfile(_inner) => _inner.fmt(f),
            Self::NoSuchPublicKey(_inner) => _inner.fmt(f),
            Self::PreconditionFailed(_inner) => _inner.fmt(f),
            Self::TooManyFieldLevelEncryptionEncryptionEntities(_inner) => _inner.fmt(f),
            Self::TooManyFieldLevelEncryptionFieldPatterns(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for UpdateFieldLevelEncryptionProfileError
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AccessDenied(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::FieldLevelEncryptionProfileAlreadyExists(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::FieldLevelEncryptionProfileSizeExceeded(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::IllegalUpdate(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InconsistentQuantities(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidArgument(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidIfMatchVersion(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NoSuchFieldLevelEncryptionProfile(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NoSuchPublicKey(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::PreconditionFailed(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyFieldLevelEncryptionEncryptionEntities(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyFieldLevelEncryptionFieldPatterns(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::UpdateFieldLevelEncryptionProfileError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateFieldLevelEncryptionProfileError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateFieldLevelEncryptionProfileError {
    /// Creates the `UpdateFieldLevelEncryptionProfileError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `UpdateFieldLevelEncryptionProfileError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AccessDenied(e) => e.meta(),
            Self::FieldLevelEncryptionProfileAlreadyExists(e) => e.meta(),
            Self::FieldLevelEncryptionProfileSizeExceeded(e) => e.meta(),
            Self::IllegalUpdate(e) => e.meta(),
            Self::InconsistentQuantities(e) => e.meta(),
            Self::InvalidArgument(e) => e.meta(),
            Self::InvalidIfMatchVersion(e) => e.meta(),
            Self::NoSuchFieldLevelEncryptionProfile(e) => e.meta(),
            Self::NoSuchPublicKey(e) => e.meta(),
            Self::PreconditionFailed(e) => e.meta(),
            Self::TooManyFieldLevelEncryptionEncryptionEntities(e) => e.meta(),
            Self::TooManyFieldLevelEncryptionFieldPatterns(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `UpdateFieldLevelEncryptionProfileError::AccessDenied`.
    pub fn is_access_denied(&self) -> bool {
        matches!(self, Self::AccessDenied(_))
    }
    /// Returns `true` if the error kind is `UpdateFieldLevelEncryptionProfileError::FieldLevelEncryptionProfileAlreadyExists`.
    pub fn is_field_level_encryption_profile_already_exists(&self) -> bool {
        matches!(self, Self::FieldLevelEncryptionProfileAlreadyExists(_))
    }
    /// Returns `true` if the error kind is `UpdateFieldLevelEncryptionProfileError::FieldLevelEncryptionProfileSizeExceeded`.
    pub fn is_field_level_encryption_profile_size_exceeded(&self) -> bool {
        matches!(self, Self::FieldLevelEncryptionProfileSizeExceeded(_))
    }
    /// Returns `true` if the error kind is `UpdateFieldLevelEncryptionProfileError::IllegalUpdate`.
    pub fn is_illegal_update(&self) -> bool {
        matches!(self, Self::IllegalUpdate(_))
    }
    /// Returns `true` if the error kind is `UpdateFieldLevelEncryptionProfileError::InconsistentQuantities`.
    pub fn is_inconsistent_quantities(&self) -> bool {
        matches!(self, Self::InconsistentQuantities(_))
    }
    /// Returns `true` if the error kind is `UpdateFieldLevelEncryptionProfileError::InvalidArgument`.
    pub fn is_invalid_argument(&self) -> bool {
        matches!(self, Self::InvalidArgument(_))
    }
    /// Returns `true` if the error kind is `UpdateFieldLevelEncryptionProfileError::InvalidIfMatchVersion`.
    pub fn is_invalid_if_match_version(&self) -> bool {
        matches!(self, Self::InvalidIfMatchVersion(_))
    }
    /// Returns `true` if the error kind is `UpdateFieldLevelEncryptionProfileError::NoSuchFieldLevelEncryptionProfile`.
    pub fn is_no_such_field_level_encryption_profile(&self) -> bool {
        matches!(self, Self::NoSuchFieldLevelEncryptionProfile(_))
    }
    /// Returns `true` if the error kind is `UpdateFieldLevelEncryptionProfileError::NoSuchPublicKey`.
    pub fn is_no_such_public_key(&self) -> bool {
        matches!(self, Self::NoSuchPublicKey(_))
    }
    /// Returns `true` if the error kind is `UpdateFieldLevelEncryptionProfileError::PreconditionFailed`.
    pub fn is_precondition_failed(&self) -> bool {
        matches!(self, Self::PreconditionFailed(_))
    }
    /// Returns `true` if the error kind is `UpdateFieldLevelEncryptionProfileError::TooManyFieldLevelEncryptionEncryptionEntities`.
    pub fn is_too_many_field_level_encryption_encryption_entities(&self) -> bool {
        matches!(self, Self::TooManyFieldLevelEncryptionEncryptionEntities(_))
    }
    /// Returns `true` if the error kind is `UpdateFieldLevelEncryptionProfileError::TooManyFieldLevelEncryptionFieldPatterns`.
    pub fn is_too_many_field_level_encryption_field_patterns(&self) -> bool {
        matches!(self, Self::TooManyFieldLevelEncryptionFieldPatterns(_))
    }
}
impl std::error::Error for UpdateFieldLevelEncryptionProfileError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AccessDenied(_inner) => Some(_inner),
            Self::FieldLevelEncryptionProfileAlreadyExists(_inner) => Some(_inner),
            Self::FieldLevelEncryptionProfileSizeExceeded(_inner) => Some(_inner),
            Self::IllegalUpdate(_inner) => Some(_inner),
            Self::InconsistentQuantities(_inner) => Some(_inner),
            Self::InvalidArgument(_inner) => Some(_inner),
            Self::InvalidIfMatchVersion(_inner) => Some(_inner),
            Self::NoSuchFieldLevelEncryptionProfile(_inner) => Some(_inner),
            Self::NoSuchPublicKey(_inner) => Some(_inner),
            Self::PreconditionFailed(_inner) => Some(_inner),
            Self::TooManyFieldLevelEncryptionEncryptionEntities(_inner) => Some(_inner),
            Self::TooManyFieldLevelEncryptionFieldPatterns(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The maximum number of field patterns for field-level encryption have been created.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TooManyFieldLevelEncryptionFieldPatterns {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl TooManyFieldLevelEncryptionFieldPatterns {
    /// Creates a new builder-style object to manufacture [`TooManyFieldLevelEncryptionFieldPatterns`](crate::error::TooManyFieldLevelEncryptionFieldPatterns).
    pub fn builder() -> crate::error::too_many_field_level_encryption_field_patterns::Builder {
        crate::error::too_many_field_level_encryption_field_patterns::Builder::default()
    }
}
/// See [`TooManyFieldLevelEncryptionFieldPatterns`](crate::error::TooManyFieldLevelEncryptionFieldPatterns).
pub mod too_many_field_level_encryption_field_patterns {

    /// A builder for [`TooManyFieldLevelEncryptionFieldPatterns`](crate::error::TooManyFieldLevelEncryptionFieldPatterns).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`TooManyFieldLevelEncryptionFieldPatterns`](crate::error::TooManyFieldLevelEncryptionFieldPatterns).
        pub fn build(self) -> crate::error::TooManyFieldLevelEncryptionFieldPatterns {
            crate::error::TooManyFieldLevelEncryptionFieldPatterns {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl TooManyFieldLevelEncryptionFieldPatterns {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TooManyFieldLevelEncryptionFieldPatterns {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TooManyFieldLevelEncryptionFieldPatterns")?;
        if let Some(inner_36) = &self.message {
            {
                write!(f, ": {}", inner_36)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for TooManyFieldLevelEncryptionFieldPatterns {}
impl aws_http::request_id::RequestId for crate::error::TooManyFieldLevelEncryptionFieldPatterns {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for TooManyFieldLevelEncryptionFieldPatterns
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The maximum number of encryption entities for field-level encryption have been created.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TooManyFieldLevelEncryptionEncryptionEntities {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl TooManyFieldLevelEncryptionEncryptionEntities {
    /// Creates a new builder-style object to manufacture [`TooManyFieldLevelEncryptionEncryptionEntities`](crate::error::TooManyFieldLevelEncryptionEncryptionEntities).
    pub fn builder() -> crate::error::too_many_field_level_encryption_encryption_entities::Builder {
        crate::error::too_many_field_level_encryption_encryption_entities::Builder::default()
    }
}
/// See [`TooManyFieldLevelEncryptionEncryptionEntities`](crate::error::TooManyFieldLevelEncryptionEncryptionEntities).
pub mod too_many_field_level_encryption_encryption_entities {

    /// A builder for [`TooManyFieldLevelEncryptionEncryptionEntities`](crate::error::TooManyFieldLevelEncryptionEncryptionEntities).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`TooManyFieldLevelEncryptionEncryptionEntities`](crate::error::TooManyFieldLevelEncryptionEncryptionEntities).
        pub fn build(self) -> crate::error::TooManyFieldLevelEncryptionEncryptionEntities {
            crate::error::TooManyFieldLevelEncryptionEncryptionEntities {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl TooManyFieldLevelEncryptionEncryptionEntities {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TooManyFieldLevelEncryptionEncryptionEntities {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TooManyFieldLevelEncryptionEncryptionEntities")?;
        if let Some(inner_37) = &self.message {
            {
                write!(f, ": {}", inner_37)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for TooManyFieldLevelEncryptionEncryptionEntities {}
impl aws_http::request_id::RequestId
    for crate::error::TooManyFieldLevelEncryptionEncryptionEntities
{
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for TooManyFieldLevelEncryptionEncryptionEntities
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The specified profile for field-level encryption doesn't exist.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct NoSuchFieldLevelEncryptionProfile {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl NoSuchFieldLevelEncryptionProfile {
    /// Creates a new builder-style object to manufacture [`NoSuchFieldLevelEncryptionProfile`](crate::error::NoSuchFieldLevelEncryptionProfile).
    pub fn builder() -> crate::error::no_such_field_level_encryption_profile::Builder {
        crate::error::no_such_field_level_encryption_profile::Builder::default()
    }
}
/// See [`NoSuchFieldLevelEncryptionProfile`](crate::error::NoSuchFieldLevelEncryptionProfile).
pub mod no_such_field_level_encryption_profile {

    /// A builder for [`NoSuchFieldLevelEncryptionProfile`](crate::error::NoSuchFieldLevelEncryptionProfile).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`NoSuchFieldLevelEncryptionProfile`](crate::error::NoSuchFieldLevelEncryptionProfile).
        pub fn build(self) -> crate::error::NoSuchFieldLevelEncryptionProfile {
            crate::error::NoSuchFieldLevelEncryptionProfile {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl NoSuchFieldLevelEncryptionProfile {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for NoSuchFieldLevelEncryptionProfile {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "NoSuchFieldLevelEncryptionProfile")?;
        if let Some(inner_38) = &self.message {
            {
                write!(f, ": {}", inner_38)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for NoSuchFieldLevelEncryptionProfile {}
impl aws_http::request_id::RequestId for crate::error::NoSuchFieldLevelEncryptionProfile {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for NoSuchFieldLevelEncryptionProfile {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The maximum size of a profile for field-level encryption was exceeded.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FieldLevelEncryptionProfileSizeExceeded {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl FieldLevelEncryptionProfileSizeExceeded {
    /// Creates a new builder-style object to manufacture [`FieldLevelEncryptionProfileSizeExceeded`](crate::error::FieldLevelEncryptionProfileSizeExceeded).
    pub fn builder() -> crate::error::field_level_encryption_profile_size_exceeded::Builder {
        crate::error::field_level_encryption_profile_size_exceeded::Builder::default()
    }
}
/// See [`FieldLevelEncryptionProfileSizeExceeded`](crate::error::FieldLevelEncryptionProfileSizeExceeded).
pub mod field_level_encryption_profile_size_exceeded {

    /// A builder for [`FieldLevelEncryptionProfileSizeExceeded`](crate::error::FieldLevelEncryptionProfileSizeExceeded).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`FieldLevelEncryptionProfileSizeExceeded`](crate::error::FieldLevelEncryptionProfileSizeExceeded).
        pub fn build(self) -> crate::error::FieldLevelEncryptionProfileSizeExceeded {
            crate::error::FieldLevelEncryptionProfileSizeExceeded {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl FieldLevelEncryptionProfileSizeExceeded {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for FieldLevelEncryptionProfileSizeExceeded {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "FieldLevelEncryptionProfileSizeExceeded")?;
        if let Some(inner_39) = &self.message {
            {
                write!(f, ": {}", inner_39)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for FieldLevelEncryptionProfileSizeExceeded {}
impl aws_http::request_id::RequestId for crate::error::FieldLevelEncryptionProfileSizeExceeded {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for FieldLevelEncryptionProfileSizeExceeded
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The specified profile for field-level encryption already exists.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FieldLevelEncryptionProfileAlreadyExists {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl FieldLevelEncryptionProfileAlreadyExists {
    /// Creates a new builder-style object to manufacture [`FieldLevelEncryptionProfileAlreadyExists`](crate::error::FieldLevelEncryptionProfileAlreadyExists).
    pub fn builder() -> crate::error::field_level_encryption_profile_already_exists::Builder {
        crate::error::field_level_encryption_profile_already_exists::Builder::default()
    }
}
/// See [`FieldLevelEncryptionProfileAlreadyExists`](crate::error::FieldLevelEncryptionProfileAlreadyExists).
pub mod field_level_encryption_profile_already_exists {

    /// A builder for [`FieldLevelEncryptionProfileAlreadyExists`](crate::error::FieldLevelEncryptionProfileAlreadyExists).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`FieldLevelEncryptionProfileAlreadyExists`](crate::error::FieldLevelEncryptionProfileAlreadyExists).
        pub fn build(self) -> crate::error::FieldLevelEncryptionProfileAlreadyExists {
            crate::error::FieldLevelEncryptionProfileAlreadyExists {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl FieldLevelEncryptionProfileAlreadyExists {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for FieldLevelEncryptionProfileAlreadyExists {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "FieldLevelEncryptionProfileAlreadyExists")?;
        if let Some(inner_40) = &self.message {
            {
                write!(f, ": {}", inner_40)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for FieldLevelEncryptionProfileAlreadyExists {}
impl aws_http::request_id::RequestId for crate::error::FieldLevelEncryptionProfileAlreadyExists {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for FieldLevelEncryptionProfileAlreadyExists
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type UpdateFieldLevelEncryptionConfigErrorKind = UpdateFieldLevelEncryptionConfigError;
/// Error type for the `UpdateFieldLevelEncryptionConfigError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateFieldLevelEncryptionConfigError {
    /// <p>Access denied.</p>
    AccessDenied(crate::error::AccessDenied),
    /// <p>The update contains modifications that are not allowed.</p>
    IllegalUpdate(crate::error::IllegalUpdate),
    /// <p>The value of <code>Quantity</code> and the size of <code>Items</code> don't match.</p>
    InconsistentQuantities(crate::error::InconsistentQuantities),
    /// <p>An argument is invalid.</p>
    InvalidArgument(crate::error::InvalidArgument),
    /// <p>The <code>If-Match</code> version is missing or not valid.</p>
    InvalidIfMatchVersion(crate::error::InvalidIfMatchVersion),
    /// <p>The specified configuration for field-level encryption doesn't exist.</p>
    NoSuchFieldLevelEncryptionConfig(crate::error::NoSuchFieldLevelEncryptionConfig),
    /// <p>The specified profile for field-level encryption doesn't exist.</p>
    NoSuchFieldLevelEncryptionProfile(crate::error::NoSuchFieldLevelEncryptionProfile),
    /// <p>The precondition in one or more of the request fields evaluated to <code>false</code>.</p>
    PreconditionFailed(crate::error::PreconditionFailed),
    /// <p>No profile specified for the field-level encryption query argument.</p>
    QueryArgProfileEmpty(crate::error::QueryArgProfileEmpty),
    /// <p>The maximum number of content type profiles for field-level encryption have been created.</p>
    TooManyFieldLevelEncryptionContentTypeProfiles(
        crate::error::TooManyFieldLevelEncryptionContentTypeProfiles,
    ),
    /// <p>The maximum number of query arg profiles for field-level encryption have been created.</p>
    TooManyFieldLevelEncryptionQueryArgProfiles(
        crate::error::TooManyFieldLevelEncryptionQueryArgProfiles,
    ),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for UpdateFieldLevelEncryptionConfigError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for UpdateFieldLevelEncryptionConfigError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AccessDenied(_inner) => _inner.fmt(f),
            Self::IllegalUpdate(_inner) => _inner.fmt(f),
            Self::InconsistentQuantities(_inner) => _inner.fmt(f),
            Self::InvalidArgument(_inner) => _inner.fmt(f),
            Self::InvalidIfMatchVersion(_inner) => _inner.fmt(f),
            Self::NoSuchFieldLevelEncryptionConfig(_inner) => _inner.fmt(f),
            Self::NoSuchFieldLevelEncryptionProfile(_inner) => _inner.fmt(f),
            Self::PreconditionFailed(_inner) => _inner.fmt(f),
            Self::QueryArgProfileEmpty(_inner) => _inner.fmt(f),
            Self::TooManyFieldLevelEncryptionContentTypeProfiles(_inner) => _inner.fmt(f),
            Self::TooManyFieldLevelEncryptionQueryArgProfiles(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for UpdateFieldLevelEncryptionConfigError
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AccessDenied(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::IllegalUpdate(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InconsistentQuantities(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidArgument(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidIfMatchVersion(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NoSuchFieldLevelEncryptionConfig(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NoSuchFieldLevelEncryptionProfile(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::PreconditionFailed(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::QueryArgProfileEmpty(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyFieldLevelEncryptionContentTypeProfiles(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyFieldLevelEncryptionQueryArgProfiles(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::UpdateFieldLevelEncryptionConfigError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateFieldLevelEncryptionConfigError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateFieldLevelEncryptionConfigError {
    /// Creates the `UpdateFieldLevelEncryptionConfigError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `UpdateFieldLevelEncryptionConfigError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AccessDenied(e) => e.meta(),
            Self::IllegalUpdate(e) => e.meta(),
            Self::InconsistentQuantities(e) => e.meta(),
            Self::InvalidArgument(e) => e.meta(),
            Self::InvalidIfMatchVersion(e) => e.meta(),
            Self::NoSuchFieldLevelEncryptionConfig(e) => e.meta(),
            Self::NoSuchFieldLevelEncryptionProfile(e) => e.meta(),
            Self::PreconditionFailed(e) => e.meta(),
            Self::QueryArgProfileEmpty(e) => e.meta(),
            Self::TooManyFieldLevelEncryptionContentTypeProfiles(e) => e.meta(),
            Self::TooManyFieldLevelEncryptionQueryArgProfiles(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `UpdateFieldLevelEncryptionConfigError::AccessDenied`.
    pub fn is_access_denied(&self) -> bool {
        matches!(self, Self::AccessDenied(_))
    }
    /// Returns `true` if the error kind is `UpdateFieldLevelEncryptionConfigError::IllegalUpdate`.
    pub fn is_illegal_update(&self) -> bool {
        matches!(self, Self::IllegalUpdate(_))
    }
    /// Returns `true` if the error kind is `UpdateFieldLevelEncryptionConfigError::InconsistentQuantities`.
    pub fn is_inconsistent_quantities(&self) -> bool {
        matches!(self, Self::InconsistentQuantities(_))
    }
    /// Returns `true` if the error kind is `UpdateFieldLevelEncryptionConfigError::InvalidArgument`.
    pub fn is_invalid_argument(&self) -> bool {
        matches!(self, Self::InvalidArgument(_))
    }
    /// Returns `true` if the error kind is `UpdateFieldLevelEncryptionConfigError::InvalidIfMatchVersion`.
    pub fn is_invalid_if_match_version(&self) -> bool {
        matches!(self, Self::InvalidIfMatchVersion(_))
    }
    /// Returns `true` if the error kind is `UpdateFieldLevelEncryptionConfigError::NoSuchFieldLevelEncryptionConfig`.
    pub fn is_no_such_field_level_encryption_config(&self) -> bool {
        matches!(self, Self::NoSuchFieldLevelEncryptionConfig(_))
    }
    /// Returns `true` if the error kind is `UpdateFieldLevelEncryptionConfigError::NoSuchFieldLevelEncryptionProfile`.
    pub fn is_no_such_field_level_encryption_profile(&self) -> bool {
        matches!(self, Self::NoSuchFieldLevelEncryptionProfile(_))
    }
    /// Returns `true` if the error kind is `UpdateFieldLevelEncryptionConfigError::PreconditionFailed`.
    pub fn is_precondition_failed(&self) -> bool {
        matches!(self, Self::PreconditionFailed(_))
    }
    /// Returns `true` if the error kind is `UpdateFieldLevelEncryptionConfigError::QueryArgProfileEmpty`.
    pub fn is_query_arg_profile_empty(&self) -> bool {
        matches!(self, Self::QueryArgProfileEmpty(_))
    }
    /// Returns `true` if the error kind is `UpdateFieldLevelEncryptionConfigError::TooManyFieldLevelEncryptionContentTypeProfiles`.
    pub fn is_too_many_field_level_encryption_content_type_profiles(&self) -> bool {
        matches!(
            self,
            Self::TooManyFieldLevelEncryptionContentTypeProfiles(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateFieldLevelEncryptionConfigError::TooManyFieldLevelEncryptionQueryArgProfiles`.
    pub fn is_too_many_field_level_encryption_query_arg_profiles(&self) -> bool {
        matches!(self, Self::TooManyFieldLevelEncryptionQueryArgProfiles(_))
    }
}
impl std::error::Error for UpdateFieldLevelEncryptionConfigError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AccessDenied(_inner) => Some(_inner),
            Self::IllegalUpdate(_inner) => Some(_inner),
            Self::InconsistentQuantities(_inner) => Some(_inner),
            Self::InvalidArgument(_inner) => Some(_inner),
            Self::InvalidIfMatchVersion(_inner) => Some(_inner),
            Self::NoSuchFieldLevelEncryptionConfig(_inner) => Some(_inner),
            Self::NoSuchFieldLevelEncryptionProfile(_inner) => Some(_inner),
            Self::PreconditionFailed(_inner) => Some(_inner),
            Self::QueryArgProfileEmpty(_inner) => Some(_inner),
            Self::TooManyFieldLevelEncryptionContentTypeProfiles(_inner) => Some(_inner),
            Self::TooManyFieldLevelEncryptionQueryArgProfiles(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The maximum number of query arg profiles for field-level encryption have been created.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TooManyFieldLevelEncryptionQueryArgProfiles {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl TooManyFieldLevelEncryptionQueryArgProfiles {
    /// Creates a new builder-style object to manufacture [`TooManyFieldLevelEncryptionQueryArgProfiles`](crate::error::TooManyFieldLevelEncryptionQueryArgProfiles).
    pub fn builder() -> crate::error::too_many_field_level_encryption_query_arg_profiles::Builder {
        crate::error::too_many_field_level_encryption_query_arg_profiles::Builder::default()
    }
}
/// See [`TooManyFieldLevelEncryptionQueryArgProfiles`](crate::error::TooManyFieldLevelEncryptionQueryArgProfiles).
pub mod too_many_field_level_encryption_query_arg_profiles {

    /// A builder for [`TooManyFieldLevelEncryptionQueryArgProfiles`](crate::error::TooManyFieldLevelEncryptionQueryArgProfiles).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`TooManyFieldLevelEncryptionQueryArgProfiles`](crate::error::TooManyFieldLevelEncryptionQueryArgProfiles).
        pub fn build(self) -> crate::error::TooManyFieldLevelEncryptionQueryArgProfiles {
            crate::error::TooManyFieldLevelEncryptionQueryArgProfiles {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl TooManyFieldLevelEncryptionQueryArgProfiles {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TooManyFieldLevelEncryptionQueryArgProfiles {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TooManyFieldLevelEncryptionQueryArgProfiles")?;
        if let Some(inner_41) = &self.message {
            {
                write!(f, ": {}", inner_41)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for TooManyFieldLevelEncryptionQueryArgProfiles {}
impl aws_http::request_id::RequestId for crate::error::TooManyFieldLevelEncryptionQueryArgProfiles {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for TooManyFieldLevelEncryptionQueryArgProfiles
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The maximum number of content type profiles for field-level encryption have been created.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TooManyFieldLevelEncryptionContentTypeProfiles {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl TooManyFieldLevelEncryptionContentTypeProfiles {
    /// Creates a new builder-style object to manufacture [`TooManyFieldLevelEncryptionContentTypeProfiles`](crate::error::TooManyFieldLevelEncryptionContentTypeProfiles).
    pub fn builder() -> crate::error::too_many_field_level_encryption_content_type_profiles::Builder
    {
        crate::error::too_many_field_level_encryption_content_type_profiles::Builder::default()
    }
}
/// See [`TooManyFieldLevelEncryptionContentTypeProfiles`](crate::error::TooManyFieldLevelEncryptionContentTypeProfiles).
pub mod too_many_field_level_encryption_content_type_profiles {

    /// A builder for [`TooManyFieldLevelEncryptionContentTypeProfiles`](crate::error::TooManyFieldLevelEncryptionContentTypeProfiles).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`TooManyFieldLevelEncryptionContentTypeProfiles`](crate::error::TooManyFieldLevelEncryptionContentTypeProfiles).
        pub fn build(self) -> crate::error::TooManyFieldLevelEncryptionContentTypeProfiles {
            crate::error::TooManyFieldLevelEncryptionContentTypeProfiles {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl TooManyFieldLevelEncryptionContentTypeProfiles {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TooManyFieldLevelEncryptionContentTypeProfiles {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TooManyFieldLevelEncryptionContentTypeProfiles")?;
        if let Some(inner_42) = &self.message {
            {
                write!(f, ": {}", inner_42)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for TooManyFieldLevelEncryptionContentTypeProfiles {}
impl aws_http::request_id::RequestId
    for crate::error::TooManyFieldLevelEncryptionContentTypeProfiles
{
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for TooManyFieldLevelEncryptionContentTypeProfiles
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>No profile specified for the field-level encryption query argument.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct QueryArgProfileEmpty {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl QueryArgProfileEmpty {
    /// Creates a new builder-style object to manufacture [`QueryArgProfileEmpty`](crate::error::QueryArgProfileEmpty).
    pub fn builder() -> crate::error::query_arg_profile_empty::Builder {
        crate::error::query_arg_profile_empty::Builder::default()
    }
}
/// See [`QueryArgProfileEmpty`](crate::error::QueryArgProfileEmpty).
pub mod query_arg_profile_empty {

    /// A builder for [`QueryArgProfileEmpty`](crate::error::QueryArgProfileEmpty).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`QueryArgProfileEmpty`](crate::error::QueryArgProfileEmpty).
        pub fn build(self) -> crate::error::QueryArgProfileEmpty {
            crate::error::QueryArgProfileEmpty {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl QueryArgProfileEmpty {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for QueryArgProfileEmpty {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "QueryArgProfileEmpty")?;
        if let Some(inner_43) = &self.message {
            {
                write!(f, ": {}", inner_43)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for QueryArgProfileEmpty {}
impl aws_http::request_id::RequestId for crate::error::QueryArgProfileEmpty {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for QueryArgProfileEmpty {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The specified configuration for field-level encryption doesn't exist.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct NoSuchFieldLevelEncryptionConfig {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl NoSuchFieldLevelEncryptionConfig {
    /// Creates a new builder-style object to manufacture [`NoSuchFieldLevelEncryptionConfig`](crate::error::NoSuchFieldLevelEncryptionConfig).
    pub fn builder() -> crate::error::no_such_field_level_encryption_config::Builder {
        crate::error::no_such_field_level_encryption_config::Builder::default()
    }
}
/// See [`NoSuchFieldLevelEncryptionConfig`](crate::error::NoSuchFieldLevelEncryptionConfig).
pub mod no_such_field_level_encryption_config {

    /// A builder for [`NoSuchFieldLevelEncryptionConfig`](crate::error::NoSuchFieldLevelEncryptionConfig).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`NoSuchFieldLevelEncryptionConfig`](crate::error::NoSuchFieldLevelEncryptionConfig).
        pub fn build(self) -> crate::error::NoSuchFieldLevelEncryptionConfig {
            crate::error::NoSuchFieldLevelEncryptionConfig {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl NoSuchFieldLevelEncryptionConfig {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for NoSuchFieldLevelEncryptionConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "NoSuchFieldLevelEncryptionConfig")?;
        if let Some(inner_44) = &self.message {
            {
                write!(f, ": {}", inner_44)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for NoSuchFieldLevelEncryptionConfig {}
impl aws_http::request_id::RequestId for crate::error::NoSuchFieldLevelEncryptionConfig {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for NoSuchFieldLevelEncryptionConfig {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type UpdateDistributionWithStagingConfigErrorKind = UpdateDistributionWithStagingConfigError;
/// Error type for the `UpdateDistributionWithStagingConfigError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateDistributionWithStagingConfigError {
    /// <p>Access denied.</p>
    AccessDenied(crate::error::AccessDenied),
    /// <p>The CNAME specified is already defined for CloudFront.</p>
    CnameAlreadyExists(crate::error::CnameAlreadyExists),
    /// <p>The specified configuration for field-level encryption can't be associated with the specified cache behavior.</p>
    IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior(
        crate::error::IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior,
    ),
    /// <p>The update contains modifications that are not allowed.</p>
    IllegalUpdate(crate::error::IllegalUpdate),
    /// <p>The value of <code>Quantity</code> and the size of <code>Items</code> don't match.</p>
    InconsistentQuantities(crate::error::InconsistentQuantities),
    /// <p>An argument is invalid.</p>
    InvalidArgument(crate::error::InvalidArgument),
    /// <p>The default root object file name is too big or contains an invalid character.</p>
    InvalidDefaultRootObject(crate::error::InvalidDefaultRootObject),
    /// <p>An invalid error code was specified.</p>
    InvalidErrorCode(crate::error::InvalidErrorCode),
    /// <p>Your request contains forward cookies option which doesn't match with the expectation for the <code>whitelisted</code> list of cookie names. Either list of cookie names has been specified when not allowed or list of cookie names is missing when expected.</p>
    InvalidForwardCookies(crate::error::InvalidForwardCookies),
    /// <p>A CloudFront function association is invalid.</p>
    InvalidFunctionAssociation(crate::error::InvalidFunctionAssociation),
    /// <p>The specified geo restriction parameter is not valid.</p>
    InvalidGeoRestrictionParameter(crate::error::InvalidGeoRestrictionParameter),
    /// <p>The headers specified are not valid for an Amazon S3 origin.</p>
    InvalidHeadersForS3Origin(crate::error::InvalidHeadersForS3Origin),
    /// <p>The <code>If-Match</code> version is missing or not valid.</p>
    InvalidIfMatchVersion(crate::error::InvalidIfMatchVersion),
    /// <p>The specified Lambda@Edge function association is invalid.</p>
    InvalidLambdaFunctionAssociation(crate::error::InvalidLambdaFunctionAssociation),
    /// <p>The location code specified is not valid.</p>
    InvalidLocationCode(crate::error::InvalidLocationCode),
    /// <p>The minimum protocol version specified is not valid.</p>
    InvalidMinimumProtocolVersion(crate::error::InvalidMinimumProtocolVersion),
    /// <p>The origin access control is not valid.</p>
    InvalidOriginAccessControl(crate::error::InvalidOriginAccessControl),
    /// <p>The origin access identity is not valid or doesn't exist.</p>
    InvalidOriginAccessIdentity(crate::error::InvalidOriginAccessIdentity),
    /// <p>The keep alive timeout specified for the origin is not valid.</p>
    InvalidOriginKeepaliveTimeout(crate::error::InvalidOriginKeepaliveTimeout),
    /// <p>The read timeout specified for the origin is not valid.</p>
    InvalidOriginReadTimeout(crate::error::InvalidOriginReadTimeout),
    /// <p>The query string parameters specified are not valid.</p>
    InvalidQueryStringParameters(crate::error::InvalidQueryStringParameters),
    /// <p>The relative path is too big, is not URL-encoded, or does not begin with a slash (/).</p>
    InvalidRelativePath(crate::error::InvalidRelativePath),
    /// <p>This operation requires the HTTPS protocol. Ensure that you specify the HTTPS protocol in your request, or omit the <code>RequiredProtocols</code> element from your distribution configuration.</p>
    InvalidRequiredProtocol(crate::error::InvalidRequiredProtocol),
    /// <p>A response code is not valid.</p>
    InvalidResponseCode(crate::error::InvalidResponseCode),
    /// <p>The TTL order specified is not valid.</p>
    InvalidTtlOrder(crate::error::InvalidTtlOrder),
    /// <p>A viewer certificate specified is not valid.</p>
    InvalidViewerCertificate(crate::error::InvalidViewerCertificate),
    /// <p>A web ACL ID specified is not valid. To specify a web ACL created using the latest version of WAF, use the ACL ARN, for example <code>arn:aws:wafv2:us-east-1:123456789012:global/webacl/ExampleWebACL/473e64fd-f30b-4765-81a0-62ad96dd167a</code>. To specify a web ACL created using WAF Classic, use the ACL ID, for example <code>473e64fd-f30b-4765-81a0-62ad96dd167a</code>.</p>
    InvalidWebAclId(crate::error::InvalidWebAclId),
    /// <p>This operation requires a body. Ensure that the body is present and the <code>Content-Type</code> header is set.</p>
    MissingBody(crate::error::MissingBody),
    /// <p>The cache policy does not exist.</p>
    NoSuchCachePolicy(crate::error::NoSuchCachePolicy),
    /// <p>The specified distribution does not exist.</p>
    NoSuchDistribution(crate::error::NoSuchDistribution),
    /// <p>The specified configuration for field-level encryption doesn't exist.</p>
    NoSuchFieldLevelEncryptionConfig(crate::error::NoSuchFieldLevelEncryptionConfig),
    /// <p>No origin exists with the specified <code>Origin Id</code>.</p>
    NoSuchOrigin(crate::error::NoSuchOrigin),
    /// <p>The origin request policy does not exist.</p>
    NoSuchOriginRequestPolicy(crate::error::NoSuchOriginRequestPolicy),
    /// <p>The real-time log configuration does not exist.</p>
    NoSuchRealtimeLogConfig(crate::error::NoSuchRealtimeLogConfig),
    /// <p>The response headers policy does not exist.</p>
    NoSuchResponseHeadersPolicy(crate::error::NoSuchResponseHeadersPolicy),
    /// <p>The precondition in one or more of the request fields evaluated to <code>false</code>.</p>
    PreconditionFailed(crate::error::PreconditionFailed),
    /// <p>The specified real-time log configuration belongs to a different Amazon Web Services account.</p>
    RealtimeLogConfigOwnerMismatch(crate::error::RealtimeLogConfigOwnerMismatch),
    /// <p>You cannot create more cache behaviors for the distribution.</p>
    TooManyCacheBehaviors(crate::error::TooManyCacheBehaviors),
    /// <p>You cannot create anymore custom SSL/TLS certificates.</p>
    TooManyCertificates(crate::error::TooManyCertificates),
    /// <p>Your request contains more cookie names in the whitelist than are allowed per cache behavior.</p>
    TooManyCookieNamesInWhiteList(crate::error::TooManyCookieNamesInWhiteList),
    /// <p>Your request contains more CNAMEs than are allowed per distribution.</p>
    TooManyDistributionCnamEs(crate::error::TooManyDistributionCnamEs),
    /// <p>The maximum number of distributions have been associated with the specified cache policy. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
    TooManyDistributionsAssociatedToCachePolicy(
        crate::error::TooManyDistributionsAssociatedToCachePolicy,
    ),
    /// <p>The maximum number of distributions have been associated with the specified configuration for field-level encryption.</p>
    TooManyDistributionsAssociatedToFieldLevelEncryptionConfig(
        crate::error::TooManyDistributionsAssociatedToFieldLevelEncryptionConfig,
    ),
    /// <p>The number of distributions that reference this key group is more than the maximum allowed. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
    TooManyDistributionsAssociatedToKeyGroup(
        crate::error::TooManyDistributionsAssociatedToKeyGroup,
    ),
    /// <p>The maximum number of distributions have been associated with the specified origin request policy. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
    TooManyDistributionsAssociatedToOriginRequestPolicy(
        crate::error::TooManyDistributionsAssociatedToOriginRequestPolicy,
    ),
    /// <p>The maximum number of distributions have been associated with the specified response headers policy.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
    TooManyDistributionsAssociatedToResponseHeadersPolicy(
        crate::error::TooManyDistributionsAssociatedToResponseHeadersPolicy,
    ),
    /// <p>You have reached the maximum number of distributions that are associated with a CloudFront function. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
    TooManyDistributionsWithFunctionAssociations(
        crate::error::TooManyDistributionsWithFunctionAssociations,
    ),
    /// <p>Processing your request would cause the maximum number of distributions with Lambda@Edge function associations per owner to be exceeded.</p>
    TooManyDistributionsWithLambdaAssociations(
        crate::error::TooManyDistributionsWithLambdaAssociations,
    ),
    /// <p>The maximum number of distributions have been associated with the specified Lambda@Edge function.</p>
    TooManyDistributionsWithSingleFunctionArn(
        crate::error::TooManyDistributionsWithSingleFunctionArn,
    ),
    /// <p>You have reached the maximum number of CloudFront function associations for this distribution. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
    TooManyFunctionAssociations(crate::error::TooManyFunctionAssociations),
    /// <p>Your request contains too many headers in forwarded values.</p>
    TooManyHeadersInForwardedValues(crate::error::TooManyHeadersInForwardedValues),
    /// <p>The number of key groups referenced by this distribution is more than the maximum allowed. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
    TooManyKeyGroupsAssociatedToDistribution(
        crate::error::TooManyKeyGroupsAssociatedToDistribution,
    ),
    /// <p>Your request contains more Lambda@Edge function associations than are allowed per distribution.</p>
    TooManyLambdaFunctionAssociations(crate::error::TooManyLambdaFunctionAssociations),
    /// <p>Your request contains too many origin custom headers.</p>
    TooManyOriginCustomHeaders(crate::error::TooManyOriginCustomHeaders),
    /// <p>Processing your request would cause you to exceed the maximum number of origin groups allowed.</p>
    TooManyOriginGroupsPerDistribution(crate::error::TooManyOriginGroupsPerDistribution),
    /// <p>You cannot create more origins for the distribution.</p>
    TooManyOrigins(crate::error::TooManyOrigins),
    /// <p>Your request contains too many query string parameters.</p>
    TooManyQueryStringParameters(crate::error::TooManyQueryStringParameters),
    /// <p>Your request contains more trusted signers than are allowed per distribution.</p>
    TooManyTrustedSigners(crate::error::TooManyTrustedSigners),
    /// <p>The specified key group does not exist.</p>
    TrustedKeyGroupDoesNotExist(crate::error::TrustedKeyGroupDoesNotExist),
    /// <p>One or more of your trusted signers don't exist.</p>
    TrustedSignerDoesNotExist(crate::error::TrustedSignerDoesNotExist),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for UpdateDistributionWithStagingConfigError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for UpdateDistributionWithStagingConfigError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AccessDenied(_inner) => _inner.fmt(f),
            Self::CnameAlreadyExists(_inner) => _inner.fmt(f),
            Self::IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior(_inner) => {
                _inner.fmt(f)
            }
            Self::IllegalUpdate(_inner) => _inner.fmt(f),
            Self::InconsistentQuantities(_inner) => _inner.fmt(f),
            Self::InvalidArgument(_inner) => _inner.fmt(f),
            Self::InvalidDefaultRootObject(_inner) => _inner.fmt(f),
            Self::InvalidErrorCode(_inner) => _inner.fmt(f),
            Self::InvalidForwardCookies(_inner) => _inner.fmt(f),
            Self::InvalidFunctionAssociation(_inner) => _inner.fmt(f),
            Self::InvalidGeoRestrictionParameter(_inner) => _inner.fmt(f),
            Self::InvalidHeadersForS3Origin(_inner) => _inner.fmt(f),
            Self::InvalidIfMatchVersion(_inner) => _inner.fmt(f),
            Self::InvalidLambdaFunctionAssociation(_inner) => _inner.fmt(f),
            Self::InvalidLocationCode(_inner) => _inner.fmt(f),
            Self::InvalidMinimumProtocolVersion(_inner) => _inner.fmt(f),
            Self::InvalidOriginAccessControl(_inner) => _inner.fmt(f),
            Self::InvalidOriginAccessIdentity(_inner) => _inner.fmt(f),
            Self::InvalidOriginKeepaliveTimeout(_inner) => _inner.fmt(f),
            Self::InvalidOriginReadTimeout(_inner) => _inner.fmt(f),
            Self::InvalidQueryStringParameters(_inner) => _inner.fmt(f),
            Self::InvalidRelativePath(_inner) => _inner.fmt(f),
            Self::InvalidRequiredProtocol(_inner) => _inner.fmt(f),
            Self::InvalidResponseCode(_inner) => _inner.fmt(f),
            Self::InvalidTtlOrder(_inner) => _inner.fmt(f),
            Self::InvalidViewerCertificate(_inner) => _inner.fmt(f),
            Self::InvalidWebAclId(_inner) => _inner.fmt(f),
            Self::MissingBody(_inner) => _inner.fmt(f),
            Self::NoSuchCachePolicy(_inner) => _inner.fmt(f),
            Self::NoSuchDistribution(_inner) => _inner.fmt(f),
            Self::NoSuchFieldLevelEncryptionConfig(_inner) => _inner.fmt(f),
            Self::NoSuchOrigin(_inner) => _inner.fmt(f),
            Self::NoSuchOriginRequestPolicy(_inner) => _inner.fmt(f),
            Self::NoSuchRealtimeLogConfig(_inner) => _inner.fmt(f),
            Self::NoSuchResponseHeadersPolicy(_inner) => _inner.fmt(f),
            Self::PreconditionFailed(_inner) => _inner.fmt(f),
            Self::RealtimeLogConfigOwnerMismatch(_inner) => _inner.fmt(f),
            Self::TooManyCacheBehaviors(_inner) => _inner.fmt(f),
            Self::TooManyCertificates(_inner) => _inner.fmt(f),
            Self::TooManyCookieNamesInWhiteList(_inner) => _inner.fmt(f),
            Self::TooManyDistributionCnamEs(_inner) => _inner.fmt(f),
            Self::TooManyDistributionsAssociatedToCachePolicy(_inner) => _inner.fmt(f),
            Self::TooManyDistributionsAssociatedToFieldLevelEncryptionConfig(_inner) => {
                _inner.fmt(f)
            }
            Self::TooManyDistributionsAssociatedToKeyGroup(_inner) => _inner.fmt(f),
            Self::TooManyDistributionsAssociatedToOriginRequestPolicy(_inner) => _inner.fmt(f),
            Self::TooManyDistributionsAssociatedToResponseHeadersPolicy(_inner) => _inner.fmt(f),
            Self::TooManyDistributionsWithFunctionAssociations(_inner) => _inner.fmt(f),
            Self::TooManyDistributionsWithLambdaAssociations(_inner) => _inner.fmt(f),
            Self::TooManyDistributionsWithSingleFunctionArn(_inner) => _inner.fmt(f),
            Self::TooManyFunctionAssociations(_inner) => _inner.fmt(f),
            Self::TooManyHeadersInForwardedValues(_inner) => _inner.fmt(f),
            Self::TooManyKeyGroupsAssociatedToDistribution(_inner) => _inner.fmt(f),
            Self::TooManyLambdaFunctionAssociations(_inner) => _inner.fmt(f),
            Self::TooManyOriginCustomHeaders(_inner) => _inner.fmt(f),
            Self::TooManyOriginGroupsPerDistribution(_inner) => _inner.fmt(f),
            Self::TooManyOrigins(_inner) => _inner.fmt(f),
            Self::TooManyQueryStringParameters(_inner) => _inner.fmt(f),
            Self::TooManyTrustedSigners(_inner) => _inner.fmt(f),
            Self::TrustedKeyGroupDoesNotExist(_inner) => _inner.fmt(f),
            Self::TrustedSignerDoesNotExist(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for UpdateDistributionWithStagingConfigError
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AccessDenied(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::CnameAlreadyExists(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::IllegalUpdate(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InconsistentQuantities(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidArgument(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidDefaultRootObject(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidErrorCode(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidForwardCookies(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidFunctionAssociation(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidGeoRestrictionParameter(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidHeadersForS3Origin(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidIfMatchVersion(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidLambdaFunctionAssociation(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidLocationCode(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidMinimumProtocolVersion(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidOriginAccessControl(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidOriginAccessIdentity(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidOriginKeepaliveTimeout(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidOriginReadTimeout(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidQueryStringParameters(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidRelativePath(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidRequiredProtocol(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidResponseCode(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidTtlOrder(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidViewerCertificate(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidWebAclId(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::MissingBody(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NoSuchCachePolicy(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NoSuchDistribution(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NoSuchFieldLevelEncryptionConfig(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NoSuchOrigin(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NoSuchOriginRequestPolicy(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NoSuchRealtimeLogConfig(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NoSuchResponseHeadersPolicy(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::PreconditionFailed(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RealtimeLogConfigOwnerMismatch(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyCacheBehaviors(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyCertificates(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyCookieNamesInWhiteList(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyDistributionCnamEs(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyDistributionsAssociatedToCachePolicy(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyDistributionsAssociatedToFieldLevelEncryptionConfig(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyDistributionsAssociatedToKeyGroup(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyDistributionsAssociatedToOriginRequestPolicy(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyDistributionsAssociatedToResponseHeadersPolicy(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyDistributionsWithFunctionAssociations(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyDistributionsWithLambdaAssociations(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyDistributionsWithSingleFunctionArn(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyFunctionAssociations(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyHeadersInForwardedValues(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyKeyGroupsAssociatedToDistribution(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyLambdaFunctionAssociations(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyOriginCustomHeaders(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyOriginGroupsPerDistribution(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyOrigins(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyQueryStringParameters(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyTrustedSigners(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TrustedKeyGroupDoesNotExist(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TrustedSignerDoesNotExist(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::UpdateDistributionWithStagingConfigError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateDistributionWithStagingConfigError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateDistributionWithStagingConfigError {
    /// Creates the `UpdateDistributionWithStagingConfigError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `UpdateDistributionWithStagingConfigError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AccessDenied(e) => e.meta(),
            Self::CnameAlreadyExists(e) => e.meta(),
            Self::IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior(e) => e.meta(),
            Self::IllegalUpdate(e) => e.meta(),
            Self::InconsistentQuantities(e) => e.meta(),
            Self::InvalidArgument(e) => e.meta(),
            Self::InvalidDefaultRootObject(e) => e.meta(),
            Self::InvalidErrorCode(e) => e.meta(),
            Self::InvalidForwardCookies(e) => e.meta(),
            Self::InvalidFunctionAssociation(e) => e.meta(),
            Self::InvalidGeoRestrictionParameter(e) => e.meta(),
            Self::InvalidHeadersForS3Origin(e) => e.meta(),
            Self::InvalidIfMatchVersion(e) => e.meta(),
            Self::InvalidLambdaFunctionAssociation(e) => e.meta(),
            Self::InvalidLocationCode(e) => e.meta(),
            Self::InvalidMinimumProtocolVersion(e) => e.meta(),
            Self::InvalidOriginAccessControl(e) => e.meta(),
            Self::InvalidOriginAccessIdentity(e) => e.meta(),
            Self::InvalidOriginKeepaliveTimeout(e) => e.meta(),
            Self::InvalidOriginReadTimeout(e) => e.meta(),
            Self::InvalidQueryStringParameters(e) => e.meta(),
            Self::InvalidRelativePath(e) => e.meta(),
            Self::InvalidRequiredProtocol(e) => e.meta(),
            Self::InvalidResponseCode(e) => e.meta(),
            Self::InvalidTtlOrder(e) => e.meta(),
            Self::InvalidViewerCertificate(e) => e.meta(),
            Self::InvalidWebAclId(e) => e.meta(),
            Self::MissingBody(e) => e.meta(),
            Self::NoSuchCachePolicy(e) => e.meta(),
            Self::NoSuchDistribution(e) => e.meta(),
            Self::NoSuchFieldLevelEncryptionConfig(e) => e.meta(),
            Self::NoSuchOrigin(e) => e.meta(),
            Self::NoSuchOriginRequestPolicy(e) => e.meta(),
            Self::NoSuchRealtimeLogConfig(e) => e.meta(),
            Self::NoSuchResponseHeadersPolicy(e) => e.meta(),
            Self::PreconditionFailed(e) => e.meta(),
            Self::RealtimeLogConfigOwnerMismatch(e) => e.meta(),
            Self::TooManyCacheBehaviors(e) => e.meta(),
            Self::TooManyCertificates(e) => e.meta(),
            Self::TooManyCookieNamesInWhiteList(e) => e.meta(),
            Self::TooManyDistributionCnamEs(e) => e.meta(),
            Self::TooManyDistributionsAssociatedToCachePolicy(e) => e.meta(),
            Self::TooManyDistributionsAssociatedToFieldLevelEncryptionConfig(e) => e.meta(),
            Self::TooManyDistributionsAssociatedToKeyGroup(e) => e.meta(),
            Self::TooManyDistributionsAssociatedToOriginRequestPolicy(e) => e.meta(),
            Self::TooManyDistributionsAssociatedToResponseHeadersPolicy(e) => e.meta(),
            Self::TooManyDistributionsWithFunctionAssociations(e) => e.meta(),
            Self::TooManyDistributionsWithLambdaAssociations(e) => e.meta(),
            Self::TooManyDistributionsWithSingleFunctionArn(e) => e.meta(),
            Self::TooManyFunctionAssociations(e) => e.meta(),
            Self::TooManyHeadersInForwardedValues(e) => e.meta(),
            Self::TooManyKeyGroupsAssociatedToDistribution(e) => e.meta(),
            Self::TooManyLambdaFunctionAssociations(e) => e.meta(),
            Self::TooManyOriginCustomHeaders(e) => e.meta(),
            Self::TooManyOriginGroupsPerDistribution(e) => e.meta(),
            Self::TooManyOrigins(e) => e.meta(),
            Self::TooManyQueryStringParameters(e) => e.meta(),
            Self::TooManyTrustedSigners(e) => e.meta(),
            Self::TrustedKeyGroupDoesNotExist(e) => e.meta(),
            Self::TrustedSignerDoesNotExist(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `UpdateDistributionWithStagingConfigError::AccessDenied`.
    pub fn is_access_denied(&self) -> bool {
        matches!(self, Self::AccessDenied(_))
    }
    /// Returns `true` if the error kind is `UpdateDistributionWithStagingConfigError::CnameAlreadyExists`.
    pub fn is_cname_already_exists(&self) -> bool {
        matches!(self, Self::CnameAlreadyExists(_))
    }
    /// Returns `true` if the error kind is `UpdateDistributionWithStagingConfigError::IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior`.
    pub fn is_illegal_field_level_encryption_config_association_with_cache_behavior(&self) -> bool {
        matches!(
            self,
            Self::IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateDistributionWithStagingConfigError::IllegalUpdate`.
    pub fn is_illegal_update(&self) -> bool {
        matches!(self, Self::IllegalUpdate(_))
    }
    /// Returns `true` if the error kind is `UpdateDistributionWithStagingConfigError::InconsistentQuantities`.
    pub fn is_inconsistent_quantities(&self) -> bool {
        matches!(self, Self::InconsistentQuantities(_))
    }
    /// Returns `true` if the error kind is `UpdateDistributionWithStagingConfigError::InvalidArgument`.
    pub fn is_invalid_argument(&self) -> bool {
        matches!(self, Self::InvalidArgument(_))
    }
    /// Returns `true` if the error kind is `UpdateDistributionWithStagingConfigError::InvalidDefaultRootObject`.
    pub fn is_invalid_default_root_object(&self) -> bool {
        matches!(self, Self::InvalidDefaultRootObject(_))
    }
    /// Returns `true` if the error kind is `UpdateDistributionWithStagingConfigError::InvalidErrorCode`.
    pub fn is_invalid_error_code(&self) -> bool {
        matches!(self, Self::InvalidErrorCode(_))
    }
    /// Returns `true` if the error kind is `UpdateDistributionWithStagingConfigError::InvalidForwardCookies`.
    pub fn is_invalid_forward_cookies(&self) -> bool {
        matches!(self, Self::InvalidForwardCookies(_))
    }
    /// Returns `true` if the error kind is `UpdateDistributionWithStagingConfigError::InvalidFunctionAssociation`.
    pub fn is_invalid_function_association(&self) -> bool {
        matches!(self, Self::InvalidFunctionAssociation(_))
    }
    /// Returns `true` if the error kind is `UpdateDistributionWithStagingConfigError::InvalidGeoRestrictionParameter`.
    pub fn is_invalid_geo_restriction_parameter(&self) -> bool {
        matches!(self, Self::InvalidGeoRestrictionParameter(_))
    }
    /// Returns `true` if the error kind is `UpdateDistributionWithStagingConfigError::InvalidHeadersForS3Origin`.
    pub fn is_invalid_headers_for_s3_origin(&self) -> bool {
        matches!(self, Self::InvalidHeadersForS3Origin(_))
    }
    /// Returns `true` if the error kind is `UpdateDistributionWithStagingConfigError::InvalidIfMatchVersion`.
    pub fn is_invalid_if_match_version(&self) -> bool {
        matches!(self, Self::InvalidIfMatchVersion(_))
    }
    /// Returns `true` if the error kind is `UpdateDistributionWithStagingConfigError::InvalidLambdaFunctionAssociation`.
    pub fn is_invalid_lambda_function_association(&self) -> bool {
        matches!(self, Self::InvalidLambdaFunctionAssociation(_))
    }
    /// Returns `true` if the error kind is `UpdateDistributionWithStagingConfigError::InvalidLocationCode`.
    pub fn is_invalid_location_code(&self) -> bool {
        matches!(self, Self::InvalidLocationCode(_))
    }
    /// Returns `true` if the error kind is `UpdateDistributionWithStagingConfigError::InvalidMinimumProtocolVersion`.
    pub fn is_invalid_minimum_protocol_version(&self) -> bool {
        matches!(self, Self::InvalidMinimumProtocolVersion(_))
    }
    /// Returns `true` if the error kind is `UpdateDistributionWithStagingConfigError::InvalidOriginAccessControl`.
    pub fn is_invalid_origin_access_control(&self) -> bool {
        matches!(self, Self::InvalidOriginAccessControl(_))
    }
    /// Returns `true` if the error kind is `UpdateDistributionWithStagingConfigError::InvalidOriginAccessIdentity`.
    pub fn is_invalid_origin_access_identity(&self) -> bool {
        matches!(self, Self::InvalidOriginAccessIdentity(_))
    }
    /// Returns `true` if the error kind is `UpdateDistributionWithStagingConfigError::InvalidOriginKeepaliveTimeout`.
    pub fn is_invalid_origin_keepalive_timeout(&self) -> bool {
        matches!(self, Self::InvalidOriginKeepaliveTimeout(_))
    }
    /// Returns `true` if the error kind is `UpdateDistributionWithStagingConfigError::InvalidOriginReadTimeout`.
    pub fn is_invalid_origin_read_timeout(&self) -> bool {
        matches!(self, Self::InvalidOriginReadTimeout(_))
    }
    /// Returns `true` if the error kind is `UpdateDistributionWithStagingConfigError::InvalidQueryStringParameters`.
    pub fn is_invalid_query_string_parameters(&self) -> bool {
        matches!(self, Self::InvalidQueryStringParameters(_))
    }
    /// Returns `true` if the error kind is `UpdateDistributionWithStagingConfigError::InvalidRelativePath`.
    pub fn is_invalid_relative_path(&self) -> bool {
        matches!(self, Self::InvalidRelativePath(_))
    }
    /// Returns `true` if the error kind is `UpdateDistributionWithStagingConfigError::InvalidRequiredProtocol`.
    pub fn is_invalid_required_protocol(&self) -> bool {
        matches!(self, Self::InvalidRequiredProtocol(_))
    }
    /// Returns `true` if the error kind is `UpdateDistributionWithStagingConfigError::InvalidResponseCode`.
    pub fn is_invalid_response_code(&self) -> bool {
        matches!(self, Self::InvalidResponseCode(_))
    }
    /// Returns `true` if the error kind is `UpdateDistributionWithStagingConfigError::InvalidTtlOrder`.
    pub fn is_invalid_ttl_order(&self) -> bool {
        matches!(self, Self::InvalidTtlOrder(_))
    }
    /// Returns `true` if the error kind is `UpdateDistributionWithStagingConfigError::InvalidViewerCertificate`.
    pub fn is_invalid_viewer_certificate(&self) -> bool {
        matches!(self, Self::InvalidViewerCertificate(_))
    }
    /// Returns `true` if the error kind is `UpdateDistributionWithStagingConfigError::InvalidWebAclId`.
    pub fn is_invalid_web_acl_id(&self) -> bool {
        matches!(self, Self::InvalidWebAclId(_))
    }
    /// Returns `true` if the error kind is `UpdateDistributionWithStagingConfigError::MissingBody`.
    pub fn is_missing_body(&self) -> bool {
        matches!(self, Self::MissingBody(_))
    }
    /// Returns `true` if the error kind is `UpdateDistributionWithStagingConfigError::NoSuchCachePolicy`.
    pub fn is_no_such_cache_policy(&self) -> bool {
        matches!(self, Self::NoSuchCachePolicy(_))
    }
    /// Returns `true` if the error kind is `UpdateDistributionWithStagingConfigError::NoSuchDistribution`.
    pub fn is_no_such_distribution(&self) -> bool {
        matches!(self, Self::NoSuchDistribution(_))
    }
    /// Returns `true` if the error kind is `UpdateDistributionWithStagingConfigError::NoSuchFieldLevelEncryptionConfig`.
    pub fn is_no_such_field_level_encryption_config(&self) -> bool {
        matches!(self, Self::NoSuchFieldLevelEncryptionConfig(_))
    }
    /// Returns `true` if the error kind is `UpdateDistributionWithStagingConfigError::NoSuchOrigin`.
    pub fn is_no_such_origin(&self) -> bool {
        matches!(self, Self::NoSuchOrigin(_))
    }
    /// Returns `true` if the error kind is `UpdateDistributionWithStagingConfigError::NoSuchOriginRequestPolicy`.
    pub fn is_no_such_origin_request_policy(&self) -> bool {
        matches!(self, Self::NoSuchOriginRequestPolicy(_))
    }
    /// Returns `true` if the error kind is `UpdateDistributionWithStagingConfigError::NoSuchRealtimeLogConfig`.
    pub fn is_no_such_realtime_log_config(&self) -> bool {
        matches!(self, Self::NoSuchRealtimeLogConfig(_))
    }
    /// Returns `true` if the error kind is `UpdateDistributionWithStagingConfigError::NoSuchResponseHeadersPolicy`.
    pub fn is_no_such_response_headers_policy(&self) -> bool {
        matches!(self, Self::NoSuchResponseHeadersPolicy(_))
    }
    /// Returns `true` if the error kind is `UpdateDistributionWithStagingConfigError::PreconditionFailed`.
    pub fn is_precondition_failed(&self) -> bool {
        matches!(self, Self::PreconditionFailed(_))
    }
    /// Returns `true` if the error kind is `UpdateDistributionWithStagingConfigError::RealtimeLogConfigOwnerMismatch`.
    pub fn is_realtime_log_config_owner_mismatch(&self) -> bool {
        matches!(self, Self::RealtimeLogConfigOwnerMismatch(_))
    }
    /// Returns `true` if the error kind is `UpdateDistributionWithStagingConfigError::TooManyCacheBehaviors`.
    pub fn is_too_many_cache_behaviors(&self) -> bool {
        matches!(self, Self::TooManyCacheBehaviors(_))
    }
    /// Returns `true` if the error kind is `UpdateDistributionWithStagingConfigError::TooManyCertificates`.
    pub fn is_too_many_certificates(&self) -> bool {
        matches!(self, Self::TooManyCertificates(_))
    }
    /// Returns `true` if the error kind is `UpdateDistributionWithStagingConfigError::TooManyCookieNamesInWhiteList`.
    pub fn is_too_many_cookie_names_in_white_list(&self) -> bool {
        matches!(self, Self::TooManyCookieNamesInWhiteList(_))
    }
    /// Returns `true` if the error kind is `UpdateDistributionWithStagingConfigError::TooManyDistributionCnamEs`.
    pub fn is_too_many_distribution_cnam_es(&self) -> bool {
        matches!(self, Self::TooManyDistributionCnamEs(_))
    }
    /// Returns `true` if the error kind is `UpdateDistributionWithStagingConfigError::TooManyDistributionsAssociatedToCachePolicy`.
    pub fn is_too_many_distributions_associated_to_cache_policy(&self) -> bool {
        matches!(self, Self::TooManyDistributionsAssociatedToCachePolicy(_))
    }
    /// Returns `true` if the error kind is `UpdateDistributionWithStagingConfigError::TooManyDistributionsAssociatedToFieldLevelEncryptionConfig`.
    pub fn is_too_many_distributions_associated_to_field_level_encryption_config(&self) -> bool {
        matches!(
            self,
            Self::TooManyDistributionsAssociatedToFieldLevelEncryptionConfig(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateDistributionWithStagingConfigError::TooManyDistributionsAssociatedToKeyGroup`.
    pub fn is_too_many_distributions_associated_to_key_group(&self) -> bool {
        matches!(self, Self::TooManyDistributionsAssociatedToKeyGroup(_))
    }
    /// Returns `true` if the error kind is `UpdateDistributionWithStagingConfigError::TooManyDistributionsAssociatedToOriginRequestPolicy`.
    pub fn is_too_many_distributions_associated_to_origin_request_policy(&self) -> bool {
        matches!(
            self,
            Self::TooManyDistributionsAssociatedToOriginRequestPolicy(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateDistributionWithStagingConfigError::TooManyDistributionsAssociatedToResponseHeadersPolicy`.
    pub fn is_too_many_distributions_associated_to_response_headers_policy(&self) -> bool {
        matches!(
            self,
            Self::TooManyDistributionsAssociatedToResponseHeadersPolicy(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateDistributionWithStagingConfigError::TooManyDistributionsWithFunctionAssociations`.
    pub fn is_too_many_distributions_with_function_associations(&self) -> bool {
        matches!(self, Self::TooManyDistributionsWithFunctionAssociations(_))
    }
    /// Returns `true` if the error kind is `UpdateDistributionWithStagingConfigError::TooManyDistributionsWithLambdaAssociations`.
    pub fn is_too_many_distributions_with_lambda_associations(&self) -> bool {
        matches!(self, Self::TooManyDistributionsWithLambdaAssociations(_))
    }
    /// Returns `true` if the error kind is `UpdateDistributionWithStagingConfigError::TooManyDistributionsWithSingleFunctionArn`.
    pub fn is_too_many_distributions_with_single_function_arn(&self) -> bool {
        matches!(self, Self::TooManyDistributionsWithSingleFunctionArn(_))
    }
    /// Returns `true` if the error kind is `UpdateDistributionWithStagingConfigError::TooManyFunctionAssociations`.
    pub fn is_too_many_function_associations(&self) -> bool {
        matches!(self, Self::TooManyFunctionAssociations(_))
    }
    /// Returns `true` if the error kind is `UpdateDistributionWithStagingConfigError::TooManyHeadersInForwardedValues`.
    pub fn is_too_many_headers_in_forwarded_values(&self) -> bool {
        matches!(self, Self::TooManyHeadersInForwardedValues(_))
    }
    /// Returns `true` if the error kind is `UpdateDistributionWithStagingConfigError::TooManyKeyGroupsAssociatedToDistribution`.
    pub fn is_too_many_key_groups_associated_to_distribution(&self) -> bool {
        matches!(self, Self::TooManyKeyGroupsAssociatedToDistribution(_))
    }
    /// Returns `true` if the error kind is `UpdateDistributionWithStagingConfigError::TooManyLambdaFunctionAssociations`.
    pub fn is_too_many_lambda_function_associations(&self) -> bool {
        matches!(self, Self::TooManyLambdaFunctionAssociations(_))
    }
    /// Returns `true` if the error kind is `UpdateDistributionWithStagingConfigError::TooManyOriginCustomHeaders`.
    pub fn is_too_many_origin_custom_headers(&self) -> bool {
        matches!(self, Self::TooManyOriginCustomHeaders(_))
    }
    /// Returns `true` if the error kind is `UpdateDistributionWithStagingConfigError::TooManyOriginGroupsPerDistribution`.
    pub fn is_too_many_origin_groups_per_distribution(&self) -> bool {
        matches!(self, Self::TooManyOriginGroupsPerDistribution(_))
    }
    /// Returns `true` if the error kind is `UpdateDistributionWithStagingConfigError::TooManyOrigins`.
    pub fn is_too_many_origins(&self) -> bool {
        matches!(self, Self::TooManyOrigins(_))
    }
    /// Returns `true` if the error kind is `UpdateDistributionWithStagingConfigError::TooManyQueryStringParameters`.
    pub fn is_too_many_query_string_parameters(&self) -> bool {
        matches!(self, Self::TooManyQueryStringParameters(_))
    }
    /// Returns `true` if the error kind is `UpdateDistributionWithStagingConfigError::TooManyTrustedSigners`.
    pub fn is_too_many_trusted_signers(&self) -> bool {
        matches!(self, Self::TooManyTrustedSigners(_))
    }
    /// Returns `true` if the error kind is `UpdateDistributionWithStagingConfigError::TrustedKeyGroupDoesNotExist`.
    pub fn is_trusted_key_group_does_not_exist(&self) -> bool {
        matches!(self, Self::TrustedKeyGroupDoesNotExist(_))
    }
    /// Returns `true` if the error kind is `UpdateDistributionWithStagingConfigError::TrustedSignerDoesNotExist`.
    pub fn is_trusted_signer_does_not_exist(&self) -> bool {
        matches!(self, Self::TrustedSignerDoesNotExist(_))
    }
}
impl std::error::Error for UpdateDistributionWithStagingConfigError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AccessDenied(_inner) => Some(_inner),
            Self::CnameAlreadyExists(_inner) => Some(_inner),
            Self::IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior(_inner) => {
                Some(_inner)
            }
            Self::IllegalUpdate(_inner) => Some(_inner),
            Self::InconsistentQuantities(_inner) => Some(_inner),
            Self::InvalidArgument(_inner) => Some(_inner),
            Self::InvalidDefaultRootObject(_inner) => Some(_inner),
            Self::InvalidErrorCode(_inner) => Some(_inner),
            Self::InvalidForwardCookies(_inner) => Some(_inner),
            Self::InvalidFunctionAssociation(_inner) => Some(_inner),
            Self::InvalidGeoRestrictionParameter(_inner) => Some(_inner),
            Self::InvalidHeadersForS3Origin(_inner) => Some(_inner),
            Self::InvalidIfMatchVersion(_inner) => Some(_inner),
            Self::InvalidLambdaFunctionAssociation(_inner) => Some(_inner),
            Self::InvalidLocationCode(_inner) => Some(_inner),
            Self::InvalidMinimumProtocolVersion(_inner) => Some(_inner),
            Self::InvalidOriginAccessControl(_inner) => Some(_inner),
            Self::InvalidOriginAccessIdentity(_inner) => Some(_inner),
            Self::InvalidOriginKeepaliveTimeout(_inner) => Some(_inner),
            Self::InvalidOriginReadTimeout(_inner) => Some(_inner),
            Self::InvalidQueryStringParameters(_inner) => Some(_inner),
            Self::InvalidRelativePath(_inner) => Some(_inner),
            Self::InvalidRequiredProtocol(_inner) => Some(_inner),
            Self::InvalidResponseCode(_inner) => Some(_inner),
            Self::InvalidTtlOrder(_inner) => Some(_inner),
            Self::InvalidViewerCertificate(_inner) => Some(_inner),
            Self::InvalidWebAclId(_inner) => Some(_inner),
            Self::MissingBody(_inner) => Some(_inner),
            Self::NoSuchCachePolicy(_inner) => Some(_inner),
            Self::NoSuchDistribution(_inner) => Some(_inner),
            Self::NoSuchFieldLevelEncryptionConfig(_inner) => Some(_inner),
            Self::NoSuchOrigin(_inner) => Some(_inner),
            Self::NoSuchOriginRequestPolicy(_inner) => Some(_inner),
            Self::NoSuchRealtimeLogConfig(_inner) => Some(_inner),
            Self::NoSuchResponseHeadersPolicy(_inner) => Some(_inner),
            Self::PreconditionFailed(_inner) => Some(_inner),
            Self::RealtimeLogConfigOwnerMismatch(_inner) => Some(_inner),
            Self::TooManyCacheBehaviors(_inner) => Some(_inner),
            Self::TooManyCertificates(_inner) => Some(_inner),
            Self::TooManyCookieNamesInWhiteList(_inner) => Some(_inner),
            Self::TooManyDistributionCnamEs(_inner) => Some(_inner),
            Self::TooManyDistributionsAssociatedToCachePolicy(_inner) => Some(_inner),
            Self::TooManyDistributionsAssociatedToFieldLevelEncryptionConfig(_inner) => {
                Some(_inner)
            }
            Self::TooManyDistributionsAssociatedToKeyGroup(_inner) => Some(_inner),
            Self::TooManyDistributionsAssociatedToOriginRequestPolicy(_inner) => Some(_inner),
            Self::TooManyDistributionsAssociatedToResponseHeadersPolicy(_inner) => Some(_inner),
            Self::TooManyDistributionsWithFunctionAssociations(_inner) => Some(_inner),
            Self::TooManyDistributionsWithLambdaAssociations(_inner) => Some(_inner),
            Self::TooManyDistributionsWithSingleFunctionArn(_inner) => Some(_inner),
            Self::TooManyFunctionAssociations(_inner) => Some(_inner),
            Self::TooManyHeadersInForwardedValues(_inner) => Some(_inner),
            Self::TooManyKeyGroupsAssociatedToDistribution(_inner) => Some(_inner),
            Self::TooManyLambdaFunctionAssociations(_inner) => Some(_inner),
            Self::TooManyOriginCustomHeaders(_inner) => Some(_inner),
            Self::TooManyOriginGroupsPerDistribution(_inner) => Some(_inner),
            Self::TooManyOrigins(_inner) => Some(_inner),
            Self::TooManyQueryStringParameters(_inner) => Some(_inner),
            Self::TooManyTrustedSigners(_inner) => Some(_inner),
            Self::TrustedKeyGroupDoesNotExist(_inner) => Some(_inner),
            Self::TrustedSignerDoesNotExist(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The specified key group does not exist.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TrustedKeyGroupDoesNotExist {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl TrustedKeyGroupDoesNotExist {
    /// Creates a new builder-style object to manufacture [`TrustedKeyGroupDoesNotExist`](crate::error::TrustedKeyGroupDoesNotExist).
    pub fn builder() -> crate::error::trusted_key_group_does_not_exist::Builder {
        crate::error::trusted_key_group_does_not_exist::Builder::default()
    }
}
/// See [`TrustedKeyGroupDoesNotExist`](crate::error::TrustedKeyGroupDoesNotExist).
pub mod trusted_key_group_does_not_exist {

    /// A builder for [`TrustedKeyGroupDoesNotExist`](crate::error::TrustedKeyGroupDoesNotExist).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`TrustedKeyGroupDoesNotExist`](crate::error::TrustedKeyGroupDoesNotExist).
        pub fn build(self) -> crate::error::TrustedKeyGroupDoesNotExist {
            crate::error::TrustedKeyGroupDoesNotExist {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl TrustedKeyGroupDoesNotExist {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TrustedKeyGroupDoesNotExist {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TrustedKeyGroupDoesNotExist")?;
        if let Some(inner_45) = &self.message {
            {
                write!(f, ": {}", inner_45)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for TrustedKeyGroupDoesNotExist {}
impl aws_http::request_id::RequestId for crate::error::TrustedKeyGroupDoesNotExist {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for TrustedKeyGroupDoesNotExist {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>Your request contains too many query string parameters.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TooManyQueryStringParameters {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl TooManyQueryStringParameters {
    /// Creates a new builder-style object to manufacture [`TooManyQueryStringParameters`](crate::error::TooManyQueryStringParameters).
    pub fn builder() -> crate::error::too_many_query_string_parameters::Builder {
        crate::error::too_many_query_string_parameters::Builder::default()
    }
}
/// See [`TooManyQueryStringParameters`](crate::error::TooManyQueryStringParameters).
pub mod too_many_query_string_parameters {

    /// A builder for [`TooManyQueryStringParameters`](crate::error::TooManyQueryStringParameters).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`TooManyQueryStringParameters`](crate::error::TooManyQueryStringParameters).
        pub fn build(self) -> crate::error::TooManyQueryStringParameters {
            crate::error::TooManyQueryStringParameters {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl TooManyQueryStringParameters {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TooManyQueryStringParameters {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TooManyQueryStringParameters")?;
        if let Some(inner_46) = &self.message {
            {
                write!(f, ": {}", inner_46)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for TooManyQueryStringParameters {}
impl aws_http::request_id::RequestId for crate::error::TooManyQueryStringParameters {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for TooManyQueryStringParameters {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>You cannot create more origins for the distribution.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TooManyOrigins {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl TooManyOrigins {
    /// Creates a new builder-style object to manufacture [`TooManyOrigins`](crate::error::TooManyOrigins).
    pub fn builder() -> crate::error::too_many_origins::Builder {
        crate::error::too_many_origins::Builder::default()
    }
}
/// See [`TooManyOrigins`](crate::error::TooManyOrigins).
pub mod too_many_origins {

    /// A builder for [`TooManyOrigins`](crate::error::TooManyOrigins).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`TooManyOrigins`](crate::error::TooManyOrigins).
        pub fn build(self) -> crate::error::TooManyOrigins {
            crate::error::TooManyOrigins {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl TooManyOrigins {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TooManyOrigins {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TooManyOrigins")?;
        if let Some(inner_47) = &self.message {
            {
                write!(f, ": {}", inner_47)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for TooManyOrigins {}
impl aws_http::request_id::RequestId for crate::error::TooManyOrigins {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for TooManyOrigins {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>Processing your request would cause you to exceed the maximum number of origin groups allowed.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TooManyOriginGroupsPerDistribution {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl TooManyOriginGroupsPerDistribution {
    /// Creates a new builder-style object to manufacture [`TooManyOriginGroupsPerDistribution`](crate::error::TooManyOriginGroupsPerDistribution).
    pub fn builder() -> crate::error::too_many_origin_groups_per_distribution::Builder {
        crate::error::too_many_origin_groups_per_distribution::Builder::default()
    }
}
/// See [`TooManyOriginGroupsPerDistribution`](crate::error::TooManyOriginGroupsPerDistribution).
pub mod too_many_origin_groups_per_distribution {

    /// A builder for [`TooManyOriginGroupsPerDistribution`](crate::error::TooManyOriginGroupsPerDistribution).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`TooManyOriginGroupsPerDistribution`](crate::error::TooManyOriginGroupsPerDistribution).
        pub fn build(self) -> crate::error::TooManyOriginGroupsPerDistribution {
            crate::error::TooManyOriginGroupsPerDistribution {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl TooManyOriginGroupsPerDistribution {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TooManyOriginGroupsPerDistribution {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TooManyOriginGroupsPerDistribution")?;
        if let Some(inner_48) = &self.message {
            {
                write!(f, ": {}", inner_48)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for TooManyOriginGroupsPerDistribution {}
impl aws_http::request_id::RequestId for crate::error::TooManyOriginGroupsPerDistribution {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for TooManyOriginGroupsPerDistribution
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>Your request contains too many origin custom headers.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TooManyOriginCustomHeaders {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl TooManyOriginCustomHeaders {
    /// Creates a new builder-style object to manufacture [`TooManyOriginCustomHeaders`](crate::error::TooManyOriginCustomHeaders).
    pub fn builder() -> crate::error::too_many_origin_custom_headers::Builder {
        crate::error::too_many_origin_custom_headers::Builder::default()
    }
}
/// See [`TooManyOriginCustomHeaders`](crate::error::TooManyOriginCustomHeaders).
pub mod too_many_origin_custom_headers {

    /// A builder for [`TooManyOriginCustomHeaders`](crate::error::TooManyOriginCustomHeaders).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`TooManyOriginCustomHeaders`](crate::error::TooManyOriginCustomHeaders).
        pub fn build(self) -> crate::error::TooManyOriginCustomHeaders {
            crate::error::TooManyOriginCustomHeaders {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl TooManyOriginCustomHeaders {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TooManyOriginCustomHeaders {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TooManyOriginCustomHeaders")?;
        if let Some(inner_49) = &self.message {
            {
                write!(f, ": {}", inner_49)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for TooManyOriginCustomHeaders {}
impl aws_http::request_id::RequestId for crate::error::TooManyOriginCustomHeaders {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for TooManyOriginCustomHeaders {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>Your request contains more Lambda@Edge function associations than are allowed per distribution.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TooManyLambdaFunctionAssociations {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl TooManyLambdaFunctionAssociations {
    /// Creates a new builder-style object to manufacture [`TooManyLambdaFunctionAssociations`](crate::error::TooManyLambdaFunctionAssociations).
    pub fn builder() -> crate::error::too_many_lambda_function_associations::Builder {
        crate::error::too_many_lambda_function_associations::Builder::default()
    }
}
/// See [`TooManyLambdaFunctionAssociations`](crate::error::TooManyLambdaFunctionAssociations).
pub mod too_many_lambda_function_associations {

    /// A builder for [`TooManyLambdaFunctionAssociations`](crate::error::TooManyLambdaFunctionAssociations).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`TooManyLambdaFunctionAssociations`](crate::error::TooManyLambdaFunctionAssociations).
        pub fn build(self) -> crate::error::TooManyLambdaFunctionAssociations {
            crate::error::TooManyLambdaFunctionAssociations {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl TooManyLambdaFunctionAssociations {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TooManyLambdaFunctionAssociations {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TooManyLambdaFunctionAssociations")?;
        if let Some(inner_50) = &self.message {
            {
                write!(f, ": {}", inner_50)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for TooManyLambdaFunctionAssociations {}
impl aws_http::request_id::RequestId for crate::error::TooManyLambdaFunctionAssociations {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for TooManyLambdaFunctionAssociations {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The number of key groups referenced by this distribution is more than the maximum allowed. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TooManyKeyGroupsAssociatedToDistribution {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl TooManyKeyGroupsAssociatedToDistribution {
    /// Creates a new builder-style object to manufacture [`TooManyKeyGroupsAssociatedToDistribution`](crate::error::TooManyKeyGroupsAssociatedToDistribution).
    pub fn builder() -> crate::error::too_many_key_groups_associated_to_distribution::Builder {
        crate::error::too_many_key_groups_associated_to_distribution::Builder::default()
    }
}
/// See [`TooManyKeyGroupsAssociatedToDistribution`](crate::error::TooManyKeyGroupsAssociatedToDistribution).
pub mod too_many_key_groups_associated_to_distribution {

    /// A builder for [`TooManyKeyGroupsAssociatedToDistribution`](crate::error::TooManyKeyGroupsAssociatedToDistribution).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`TooManyKeyGroupsAssociatedToDistribution`](crate::error::TooManyKeyGroupsAssociatedToDistribution).
        pub fn build(self) -> crate::error::TooManyKeyGroupsAssociatedToDistribution {
            crate::error::TooManyKeyGroupsAssociatedToDistribution {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl TooManyKeyGroupsAssociatedToDistribution {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TooManyKeyGroupsAssociatedToDistribution {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TooManyKeyGroupsAssociatedToDistribution")?;
        if let Some(inner_51) = &self.message {
            {
                write!(f, ": {}", inner_51)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for TooManyKeyGroupsAssociatedToDistribution {}
impl aws_http::request_id::RequestId for crate::error::TooManyKeyGroupsAssociatedToDistribution {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for TooManyKeyGroupsAssociatedToDistribution
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>Your request contains too many headers in forwarded values.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TooManyHeadersInForwardedValues {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl TooManyHeadersInForwardedValues {
    /// Creates a new builder-style object to manufacture [`TooManyHeadersInForwardedValues`](crate::error::TooManyHeadersInForwardedValues).
    pub fn builder() -> crate::error::too_many_headers_in_forwarded_values::Builder {
        crate::error::too_many_headers_in_forwarded_values::Builder::default()
    }
}
/// See [`TooManyHeadersInForwardedValues`](crate::error::TooManyHeadersInForwardedValues).
pub mod too_many_headers_in_forwarded_values {

    /// A builder for [`TooManyHeadersInForwardedValues`](crate::error::TooManyHeadersInForwardedValues).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`TooManyHeadersInForwardedValues`](crate::error::TooManyHeadersInForwardedValues).
        pub fn build(self) -> crate::error::TooManyHeadersInForwardedValues {
            crate::error::TooManyHeadersInForwardedValues {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl TooManyHeadersInForwardedValues {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TooManyHeadersInForwardedValues {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TooManyHeadersInForwardedValues")?;
        if let Some(inner_52) = &self.message {
            {
                write!(f, ": {}", inner_52)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for TooManyHeadersInForwardedValues {}
impl aws_http::request_id::RequestId for crate::error::TooManyHeadersInForwardedValues {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for TooManyHeadersInForwardedValues {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>You have reached the maximum number of CloudFront function associations for this distribution. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TooManyFunctionAssociations {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl TooManyFunctionAssociations {
    /// Creates a new builder-style object to manufacture [`TooManyFunctionAssociations`](crate::error::TooManyFunctionAssociations).
    pub fn builder() -> crate::error::too_many_function_associations::Builder {
        crate::error::too_many_function_associations::Builder::default()
    }
}
/// See [`TooManyFunctionAssociations`](crate::error::TooManyFunctionAssociations).
pub mod too_many_function_associations {

    /// A builder for [`TooManyFunctionAssociations`](crate::error::TooManyFunctionAssociations).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`TooManyFunctionAssociations`](crate::error::TooManyFunctionAssociations).
        pub fn build(self) -> crate::error::TooManyFunctionAssociations {
            crate::error::TooManyFunctionAssociations {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl TooManyFunctionAssociations {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TooManyFunctionAssociations {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TooManyFunctionAssociations")?;
        if let Some(inner_53) = &self.message {
            {
                write!(f, ": {}", inner_53)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for TooManyFunctionAssociations {}
impl aws_http::request_id::RequestId for crate::error::TooManyFunctionAssociations {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for TooManyFunctionAssociations {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The maximum number of distributions have been associated with the specified Lambda@Edge function.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TooManyDistributionsWithSingleFunctionArn {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl TooManyDistributionsWithSingleFunctionArn {
    /// Creates a new builder-style object to manufacture [`TooManyDistributionsWithSingleFunctionArn`](crate::error::TooManyDistributionsWithSingleFunctionArn).
    pub fn builder() -> crate::error::too_many_distributions_with_single_function_arn::Builder {
        crate::error::too_many_distributions_with_single_function_arn::Builder::default()
    }
}
/// See [`TooManyDistributionsWithSingleFunctionArn`](crate::error::TooManyDistributionsWithSingleFunctionArn).
pub mod too_many_distributions_with_single_function_arn {

    /// A builder for [`TooManyDistributionsWithSingleFunctionArn`](crate::error::TooManyDistributionsWithSingleFunctionArn).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`TooManyDistributionsWithSingleFunctionArn`](crate::error::TooManyDistributionsWithSingleFunctionArn).
        pub fn build(self) -> crate::error::TooManyDistributionsWithSingleFunctionArn {
            crate::error::TooManyDistributionsWithSingleFunctionArn {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl TooManyDistributionsWithSingleFunctionArn {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TooManyDistributionsWithSingleFunctionArn {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "TooManyDistributionsWithSingleFunctionArn [TooManyDistributionsWithSingleFunctionARN]"
        )?;
        if let Some(inner_54) = &self.message {
            {
                write!(f, ": {}", inner_54)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for TooManyDistributionsWithSingleFunctionArn {}
impl aws_http::request_id::RequestId for crate::error::TooManyDistributionsWithSingleFunctionArn {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for TooManyDistributionsWithSingleFunctionArn
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>Processing your request would cause the maximum number of distributions with Lambda@Edge function associations per owner to be exceeded.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TooManyDistributionsWithLambdaAssociations {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl TooManyDistributionsWithLambdaAssociations {
    /// Creates a new builder-style object to manufacture [`TooManyDistributionsWithLambdaAssociations`](crate::error::TooManyDistributionsWithLambdaAssociations).
    pub fn builder() -> crate::error::too_many_distributions_with_lambda_associations::Builder {
        crate::error::too_many_distributions_with_lambda_associations::Builder::default()
    }
}
/// See [`TooManyDistributionsWithLambdaAssociations`](crate::error::TooManyDistributionsWithLambdaAssociations).
pub mod too_many_distributions_with_lambda_associations {

    /// A builder for [`TooManyDistributionsWithLambdaAssociations`](crate::error::TooManyDistributionsWithLambdaAssociations).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`TooManyDistributionsWithLambdaAssociations`](crate::error::TooManyDistributionsWithLambdaAssociations).
        pub fn build(self) -> crate::error::TooManyDistributionsWithLambdaAssociations {
            crate::error::TooManyDistributionsWithLambdaAssociations {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl TooManyDistributionsWithLambdaAssociations {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TooManyDistributionsWithLambdaAssociations {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TooManyDistributionsWithLambdaAssociations")?;
        if let Some(inner_55) = &self.message {
            {
                write!(f, ": {}", inner_55)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for TooManyDistributionsWithLambdaAssociations {}
impl aws_http::request_id::RequestId for crate::error::TooManyDistributionsWithLambdaAssociations {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for TooManyDistributionsWithLambdaAssociations
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>You have reached the maximum number of distributions that are associated with a CloudFront function. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TooManyDistributionsWithFunctionAssociations {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl TooManyDistributionsWithFunctionAssociations {
    /// Creates a new builder-style object to manufacture [`TooManyDistributionsWithFunctionAssociations`](crate::error::TooManyDistributionsWithFunctionAssociations).
    pub fn builder() -> crate::error::too_many_distributions_with_function_associations::Builder {
        crate::error::too_many_distributions_with_function_associations::Builder::default()
    }
}
/// See [`TooManyDistributionsWithFunctionAssociations`](crate::error::TooManyDistributionsWithFunctionAssociations).
pub mod too_many_distributions_with_function_associations {

    /// A builder for [`TooManyDistributionsWithFunctionAssociations`](crate::error::TooManyDistributionsWithFunctionAssociations).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`TooManyDistributionsWithFunctionAssociations`](crate::error::TooManyDistributionsWithFunctionAssociations).
        pub fn build(self) -> crate::error::TooManyDistributionsWithFunctionAssociations {
            crate::error::TooManyDistributionsWithFunctionAssociations {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl TooManyDistributionsWithFunctionAssociations {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TooManyDistributionsWithFunctionAssociations {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TooManyDistributionsWithFunctionAssociations")?;
        if let Some(inner_56) = &self.message {
            {
                write!(f, ": {}", inner_56)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for TooManyDistributionsWithFunctionAssociations {}
impl aws_http::request_id::RequestId
    for crate::error::TooManyDistributionsWithFunctionAssociations
{
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for TooManyDistributionsWithFunctionAssociations
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The maximum number of distributions have been associated with the specified response headers policy.</p>
/// <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TooManyDistributionsAssociatedToResponseHeadersPolicy {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl TooManyDistributionsAssociatedToResponseHeadersPolicy {
    /// Creates a new builder-style object to manufacture [`TooManyDistributionsAssociatedToResponseHeadersPolicy`](crate::error::TooManyDistributionsAssociatedToResponseHeadersPolicy).
    pub fn builder(
    ) -> crate::error::too_many_distributions_associated_to_response_headers_policy::Builder {
        crate::error::too_many_distributions_associated_to_response_headers_policy::Builder::default(
        )
    }
}
/// See [`TooManyDistributionsAssociatedToResponseHeadersPolicy`](crate::error::TooManyDistributionsAssociatedToResponseHeadersPolicy).
pub mod too_many_distributions_associated_to_response_headers_policy {

    /// A builder for [`TooManyDistributionsAssociatedToResponseHeadersPolicy`](crate::error::TooManyDistributionsAssociatedToResponseHeadersPolicy).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`TooManyDistributionsAssociatedToResponseHeadersPolicy`](crate::error::TooManyDistributionsAssociatedToResponseHeadersPolicy).
        pub fn build(self) -> crate::error::TooManyDistributionsAssociatedToResponseHeadersPolicy {
            crate::error::TooManyDistributionsAssociatedToResponseHeadersPolicy {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl TooManyDistributionsAssociatedToResponseHeadersPolicy {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TooManyDistributionsAssociatedToResponseHeadersPolicy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TooManyDistributionsAssociatedToResponseHeadersPolicy")?;
        if let Some(inner_57) = &self.message {
            {
                write!(f, ": {}", inner_57)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for TooManyDistributionsAssociatedToResponseHeadersPolicy {}
impl aws_http::request_id::RequestId
    for crate::error::TooManyDistributionsAssociatedToResponseHeadersPolicy
{
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for TooManyDistributionsAssociatedToResponseHeadersPolicy
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The maximum number of distributions have been associated with the specified origin request policy. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TooManyDistributionsAssociatedToOriginRequestPolicy {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl TooManyDistributionsAssociatedToOriginRequestPolicy {
    /// Creates a new builder-style object to manufacture [`TooManyDistributionsAssociatedToOriginRequestPolicy`](crate::error::TooManyDistributionsAssociatedToOriginRequestPolicy).
    pub fn builder(
    ) -> crate::error::too_many_distributions_associated_to_origin_request_policy::Builder {
        crate::error::too_many_distributions_associated_to_origin_request_policy::Builder::default()
    }
}
/// See [`TooManyDistributionsAssociatedToOriginRequestPolicy`](crate::error::TooManyDistributionsAssociatedToOriginRequestPolicy).
pub mod too_many_distributions_associated_to_origin_request_policy {

    /// A builder for [`TooManyDistributionsAssociatedToOriginRequestPolicy`](crate::error::TooManyDistributionsAssociatedToOriginRequestPolicy).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`TooManyDistributionsAssociatedToOriginRequestPolicy`](crate::error::TooManyDistributionsAssociatedToOriginRequestPolicy).
        pub fn build(self) -> crate::error::TooManyDistributionsAssociatedToOriginRequestPolicy {
            crate::error::TooManyDistributionsAssociatedToOriginRequestPolicy {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl TooManyDistributionsAssociatedToOriginRequestPolicy {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TooManyDistributionsAssociatedToOriginRequestPolicy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TooManyDistributionsAssociatedToOriginRequestPolicy")?;
        if let Some(inner_58) = &self.message {
            {
                write!(f, ": {}", inner_58)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for TooManyDistributionsAssociatedToOriginRequestPolicy {}
impl aws_http::request_id::RequestId
    for crate::error::TooManyDistributionsAssociatedToOriginRequestPolicy
{
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for TooManyDistributionsAssociatedToOriginRequestPolicy
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The number of distributions that reference this key group is more than the maximum allowed. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TooManyDistributionsAssociatedToKeyGroup {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl TooManyDistributionsAssociatedToKeyGroup {
    /// Creates a new builder-style object to manufacture [`TooManyDistributionsAssociatedToKeyGroup`](crate::error::TooManyDistributionsAssociatedToKeyGroup).
    pub fn builder() -> crate::error::too_many_distributions_associated_to_key_group::Builder {
        crate::error::too_many_distributions_associated_to_key_group::Builder::default()
    }
}
/// See [`TooManyDistributionsAssociatedToKeyGroup`](crate::error::TooManyDistributionsAssociatedToKeyGroup).
pub mod too_many_distributions_associated_to_key_group {

    /// A builder for [`TooManyDistributionsAssociatedToKeyGroup`](crate::error::TooManyDistributionsAssociatedToKeyGroup).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`TooManyDistributionsAssociatedToKeyGroup`](crate::error::TooManyDistributionsAssociatedToKeyGroup).
        pub fn build(self) -> crate::error::TooManyDistributionsAssociatedToKeyGroup {
            crate::error::TooManyDistributionsAssociatedToKeyGroup {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl TooManyDistributionsAssociatedToKeyGroup {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TooManyDistributionsAssociatedToKeyGroup {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TooManyDistributionsAssociatedToKeyGroup")?;
        if let Some(inner_59) = &self.message {
            {
                write!(f, ": {}", inner_59)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for TooManyDistributionsAssociatedToKeyGroup {}
impl aws_http::request_id::RequestId for crate::error::TooManyDistributionsAssociatedToKeyGroup {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for TooManyDistributionsAssociatedToKeyGroup
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The maximum number of distributions have been associated with the specified configuration for field-level encryption.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TooManyDistributionsAssociatedToFieldLevelEncryptionConfig {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl TooManyDistributionsAssociatedToFieldLevelEncryptionConfig {
    /// Creates a new builder-style object to manufacture [`TooManyDistributionsAssociatedToFieldLevelEncryptionConfig`](crate::error::TooManyDistributionsAssociatedToFieldLevelEncryptionConfig).
    pub fn builder(
    ) -> crate::error::too_many_distributions_associated_to_field_level_encryption_config::Builder
    {
        crate::error::too_many_distributions_associated_to_field_level_encryption_config::Builder::default()
    }
}
/// See [`TooManyDistributionsAssociatedToFieldLevelEncryptionConfig`](crate::error::TooManyDistributionsAssociatedToFieldLevelEncryptionConfig).
pub mod too_many_distributions_associated_to_field_level_encryption_config {

    /// A builder for [`TooManyDistributionsAssociatedToFieldLevelEncryptionConfig`](crate::error::TooManyDistributionsAssociatedToFieldLevelEncryptionConfig).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`TooManyDistributionsAssociatedToFieldLevelEncryptionConfig`](crate::error::TooManyDistributionsAssociatedToFieldLevelEncryptionConfig).
        pub fn build(
            self,
        ) -> crate::error::TooManyDistributionsAssociatedToFieldLevelEncryptionConfig {
            crate::error::TooManyDistributionsAssociatedToFieldLevelEncryptionConfig {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl TooManyDistributionsAssociatedToFieldLevelEncryptionConfig {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TooManyDistributionsAssociatedToFieldLevelEncryptionConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "TooManyDistributionsAssociatedToFieldLevelEncryptionConfig"
        )?;
        if let Some(inner_60) = &self.message {
            {
                write!(f, ": {}", inner_60)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for TooManyDistributionsAssociatedToFieldLevelEncryptionConfig {}
impl aws_http::request_id::RequestId
    for crate::error::TooManyDistributionsAssociatedToFieldLevelEncryptionConfig
{
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for TooManyDistributionsAssociatedToFieldLevelEncryptionConfig
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The maximum number of distributions have been associated with the specified cache policy. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TooManyDistributionsAssociatedToCachePolicy {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl TooManyDistributionsAssociatedToCachePolicy {
    /// Creates a new builder-style object to manufacture [`TooManyDistributionsAssociatedToCachePolicy`](crate::error::TooManyDistributionsAssociatedToCachePolicy).
    pub fn builder() -> crate::error::too_many_distributions_associated_to_cache_policy::Builder {
        crate::error::too_many_distributions_associated_to_cache_policy::Builder::default()
    }
}
/// See [`TooManyDistributionsAssociatedToCachePolicy`](crate::error::TooManyDistributionsAssociatedToCachePolicy).
pub mod too_many_distributions_associated_to_cache_policy {

    /// A builder for [`TooManyDistributionsAssociatedToCachePolicy`](crate::error::TooManyDistributionsAssociatedToCachePolicy).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`TooManyDistributionsAssociatedToCachePolicy`](crate::error::TooManyDistributionsAssociatedToCachePolicy).
        pub fn build(self) -> crate::error::TooManyDistributionsAssociatedToCachePolicy {
            crate::error::TooManyDistributionsAssociatedToCachePolicy {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl TooManyDistributionsAssociatedToCachePolicy {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TooManyDistributionsAssociatedToCachePolicy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TooManyDistributionsAssociatedToCachePolicy")?;
        if let Some(inner_61) = &self.message {
            {
                write!(f, ": {}", inner_61)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for TooManyDistributionsAssociatedToCachePolicy {}
impl aws_http::request_id::RequestId for crate::error::TooManyDistributionsAssociatedToCachePolicy {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for TooManyDistributionsAssociatedToCachePolicy
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>Your request contains more CNAMEs than are allowed per distribution.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TooManyDistributionCnamEs {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl TooManyDistributionCnamEs {
    /// Creates a new builder-style object to manufacture [`TooManyDistributionCnamEs`](crate::error::TooManyDistributionCnamEs).
    pub fn builder() -> crate::error::too_many_distribution_cnam_es::Builder {
        crate::error::too_many_distribution_cnam_es::Builder::default()
    }
}
/// See [`TooManyDistributionCnamEs`](crate::error::TooManyDistributionCnamEs).
pub mod too_many_distribution_cnam_es {

    /// A builder for [`TooManyDistributionCnamEs`](crate::error::TooManyDistributionCnamEs).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`TooManyDistributionCnamEs`](crate::error::TooManyDistributionCnamEs).
        pub fn build(self) -> crate::error::TooManyDistributionCnamEs {
            crate::error::TooManyDistributionCnamEs {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl TooManyDistributionCnamEs {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TooManyDistributionCnamEs {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TooManyDistributionCnamEs [TooManyDistributionCNAMEs]")?;
        if let Some(inner_62) = &self.message {
            {
                write!(f, ": {}", inner_62)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for TooManyDistributionCnamEs {}
impl aws_http::request_id::RequestId for crate::error::TooManyDistributionCnamEs {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for TooManyDistributionCnamEs {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>Your request contains more cookie names in the whitelist than are allowed per cache behavior.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TooManyCookieNamesInWhiteList {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl TooManyCookieNamesInWhiteList {
    /// Creates a new builder-style object to manufacture [`TooManyCookieNamesInWhiteList`](crate::error::TooManyCookieNamesInWhiteList).
    pub fn builder() -> crate::error::too_many_cookie_names_in_white_list::Builder {
        crate::error::too_many_cookie_names_in_white_list::Builder::default()
    }
}
/// See [`TooManyCookieNamesInWhiteList`](crate::error::TooManyCookieNamesInWhiteList).
pub mod too_many_cookie_names_in_white_list {

    /// A builder for [`TooManyCookieNamesInWhiteList`](crate::error::TooManyCookieNamesInWhiteList).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`TooManyCookieNamesInWhiteList`](crate::error::TooManyCookieNamesInWhiteList).
        pub fn build(self) -> crate::error::TooManyCookieNamesInWhiteList {
            crate::error::TooManyCookieNamesInWhiteList {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl TooManyCookieNamesInWhiteList {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TooManyCookieNamesInWhiteList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TooManyCookieNamesInWhiteList")?;
        if let Some(inner_63) = &self.message {
            {
                write!(f, ": {}", inner_63)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for TooManyCookieNamesInWhiteList {}
impl aws_http::request_id::RequestId for crate::error::TooManyCookieNamesInWhiteList {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for TooManyCookieNamesInWhiteList {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>You cannot create anymore custom SSL/TLS certificates.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TooManyCertificates {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl TooManyCertificates {
    /// Creates a new builder-style object to manufacture [`TooManyCertificates`](crate::error::TooManyCertificates).
    pub fn builder() -> crate::error::too_many_certificates::Builder {
        crate::error::too_many_certificates::Builder::default()
    }
}
/// See [`TooManyCertificates`](crate::error::TooManyCertificates).
pub mod too_many_certificates {

    /// A builder for [`TooManyCertificates`](crate::error::TooManyCertificates).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`TooManyCertificates`](crate::error::TooManyCertificates).
        pub fn build(self) -> crate::error::TooManyCertificates {
            crate::error::TooManyCertificates {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl TooManyCertificates {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TooManyCertificates {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TooManyCertificates")?;
        if let Some(inner_64) = &self.message {
            {
                write!(f, ": {}", inner_64)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for TooManyCertificates {}
impl aws_http::request_id::RequestId for crate::error::TooManyCertificates {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for TooManyCertificates {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>You cannot create more cache behaviors for the distribution.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TooManyCacheBehaviors {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl TooManyCacheBehaviors {
    /// Creates a new builder-style object to manufacture [`TooManyCacheBehaviors`](crate::error::TooManyCacheBehaviors).
    pub fn builder() -> crate::error::too_many_cache_behaviors::Builder {
        crate::error::too_many_cache_behaviors::Builder::default()
    }
}
/// See [`TooManyCacheBehaviors`](crate::error::TooManyCacheBehaviors).
pub mod too_many_cache_behaviors {

    /// A builder for [`TooManyCacheBehaviors`](crate::error::TooManyCacheBehaviors).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`TooManyCacheBehaviors`](crate::error::TooManyCacheBehaviors).
        pub fn build(self) -> crate::error::TooManyCacheBehaviors {
            crate::error::TooManyCacheBehaviors {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl TooManyCacheBehaviors {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TooManyCacheBehaviors {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TooManyCacheBehaviors")?;
        if let Some(inner_65) = &self.message {
            {
                write!(f, ": {}", inner_65)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for TooManyCacheBehaviors {}
impl aws_http::request_id::RequestId for crate::error::TooManyCacheBehaviors {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for TooManyCacheBehaviors {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The specified real-time log configuration belongs to a different Amazon Web Services account.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RealtimeLogConfigOwnerMismatch {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl RealtimeLogConfigOwnerMismatch {
    /// Creates a new builder-style object to manufacture [`RealtimeLogConfigOwnerMismatch`](crate::error::RealtimeLogConfigOwnerMismatch).
    pub fn builder() -> crate::error::realtime_log_config_owner_mismatch::Builder {
        crate::error::realtime_log_config_owner_mismatch::Builder::default()
    }
}
/// See [`RealtimeLogConfigOwnerMismatch`](crate::error::RealtimeLogConfigOwnerMismatch).
pub mod realtime_log_config_owner_mismatch {

    /// A builder for [`RealtimeLogConfigOwnerMismatch`](crate::error::RealtimeLogConfigOwnerMismatch).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`RealtimeLogConfigOwnerMismatch`](crate::error::RealtimeLogConfigOwnerMismatch).
        pub fn build(self) -> crate::error::RealtimeLogConfigOwnerMismatch {
            crate::error::RealtimeLogConfigOwnerMismatch {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl RealtimeLogConfigOwnerMismatch {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for RealtimeLogConfigOwnerMismatch {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "RealtimeLogConfigOwnerMismatch")?;
        if let Some(inner_66) = &self.message {
            {
                write!(f, ": {}", inner_66)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for RealtimeLogConfigOwnerMismatch {}
impl aws_http::request_id::RequestId for crate::error::RealtimeLogConfigOwnerMismatch {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for RealtimeLogConfigOwnerMismatch {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>No origin exists with the specified <code>Origin Id</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct NoSuchOrigin {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl NoSuchOrigin {
    /// Creates a new builder-style object to manufacture [`NoSuchOrigin`](crate::error::NoSuchOrigin).
    pub fn builder() -> crate::error::no_such_origin::Builder {
        crate::error::no_such_origin::Builder::default()
    }
}
/// See [`NoSuchOrigin`](crate::error::NoSuchOrigin).
pub mod no_such_origin {

    /// A builder for [`NoSuchOrigin`](crate::error::NoSuchOrigin).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`NoSuchOrigin`](crate::error::NoSuchOrigin).
        pub fn build(self) -> crate::error::NoSuchOrigin {
            crate::error::NoSuchOrigin {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl NoSuchOrigin {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for NoSuchOrigin {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "NoSuchOrigin")?;
        if let Some(inner_67) = &self.message {
            {
                write!(f, ": {}", inner_67)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for NoSuchOrigin {}
impl aws_http::request_id::RequestId for crate::error::NoSuchOrigin {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for NoSuchOrigin {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The specified distribution does not exist.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct NoSuchDistribution {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl NoSuchDistribution {
    /// Creates a new builder-style object to manufacture [`NoSuchDistribution`](crate::error::NoSuchDistribution).
    pub fn builder() -> crate::error::no_such_distribution::Builder {
        crate::error::no_such_distribution::Builder::default()
    }
}
/// See [`NoSuchDistribution`](crate::error::NoSuchDistribution).
pub mod no_such_distribution {

    /// A builder for [`NoSuchDistribution`](crate::error::NoSuchDistribution).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`NoSuchDistribution`](crate::error::NoSuchDistribution).
        pub fn build(self) -> crate::error::NoSuchDistribution {
            crate::error::NoSuchDistribution {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl NoSuchDistribution {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for NoSuchDistribution {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "NoSuchDistribution")?;
        if let Some(inner_68) = &self.message {
            {
                write!(f, ": {}", inner_68)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for NoSuchDistribution {}
impl aws_http::request_id::RequestId for crate::error::NoSuchDistribution {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for NoSuchDistribution {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The cache policy does not exist.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct NoSuchCachePolicy {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl NoSuchCachePolicy {
    /// Creates a new builder-style object to manufacture [`NoSuchCachePolicy`](crate::error::NoSuchCachePolicy).
    pub fn builder() -> crate::error::no_such_cache_policy::Builder {
        crate::error::no_such_cache_policy::Builder::default()
    }
}
/// See [`NoSuchCachePolicy`](crate::error::NoSuchCachePolicy).
pub mod no_such_cache_policy {

    /// A builder for [`NoSuchCachePolicy`](crate::error::NoSuchCachePolicy).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`NoSuchCachePolicy`](crate::error::NoSuchCachePolicy).
        pub fn build(self) -> crate::error::NoSuchCachePolicy {
            crate::error::NoSuchCachePolicy {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl NoSuchCachePolicy {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for NoSuchCachePolicy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "NoSuchCachePolicy")?;
        if let Some(inner_69) = &self.message {
            {
                write!(f, ": {}", inner_69)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for NoSuchCachePolicy {}
impl aws_http::request_id::RequestId for crate::error::NoSuchCachePolicy {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for NoSuchCachePolicy {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>A web ACL ID specified is not valid. To specify a web ACL created using the latest version of WAF, use the ACL ARN, for example <code>arn:aws:wafv2:us-east-1:123456789012:global/webacl/ExampleWebACL/473e64fd-f30b-4765-81a0-62ad96dd167a</code>. To specify a web ACL created using WAF Classic, use the ACL ID, for example <code>473e64fd-f30b-4765-81a0-62ad96dd167a</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidWebAclId {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidWebAclId {
    /// Creates a new builder-style object to manufacture [`InvalidWebAclId`](crate::error::InvalidWebAclId).
    pub fn builder() -> crate::error::invalid_web_acl_id::Builder {
        crate::error::invalid_web_acl_id::Builder::default()
    }
}
/// See [`InvalidWebAclId`](crate::error::InvalidWebAclId).
pub mod invalid_web_acl_id {

    /// A builder for [`InvalidWebAclId`](crate::error::InvalidWebAclId).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidWebAclId`](crate::error::InvalidWebAclId).
        pub fn build(self) -> crate::error::InvalidWebAclId {
            crate::error::InvalidWebAclId {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl InvalidWebAclId {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidWebAclId {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidWebAclId [InvalidWebACLId]")?;
        if let Some(inner_70) = &self.message {
            {
                write!(f, ": {}", inner_70)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidWebAclId {}
impl aws_http::request_id::RequestId for crate::error::InvalidWebAclId {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidWebAclId {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>A viewer certificate specified is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidViewerCertificate {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidViewerCertificate {
    /// Creates a new builder-style object to manufacture [`InvalidViewerCertificate`](crate::error::InvalidViewerCertificate).
    pub fn builder() -> crate::error::invalid_viewer_certificate::Builder {
        crate::error::invalid_viewer_certificate::Builder::default()
    }
}
/// See [`InvalidViewerCertificate`](crate::error::InvalidViewerCertificate).
pub mod invalid_viewer_certificate {

    /// A builder for [`InvalidViewerCertificate`](crate::error::InvalidViewerCertificate).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidViewerCertificate`](crate::error::InvalidViewerCertificate).
        pub fn build(self) -> crate::error::InvalidViewerCertificate {
            crate::error::InvalidViewerCertificate {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl InvalidViewerCertificate {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidViewerCertificate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidViewerCertificate")?;
        if let Some(inner_71) = &self.message {
            {
                write!(f, ": {}", inner_71)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidViewerCertificate {}
impl aws_http::request_id::RequestId for crate::error::InvalidViewerCertificate {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidViewerCertificate {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The TTL order specified is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidTtlOrder {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidTtlOrder {
    /// Creates a new builder-style object to manufacture [`InvalidTtlOrder`](crate::error::InvalidTtlOrder).
    pub fn builder() -> crate::error::invalid_ttl_order::Builder {
        crate::error::invalid_ttl_order::Builder::default()
    }
}
/// See [`InvalidTtlOrder`](crate::error::InvalidTtlOrder).
pub mod invalid_ttl_order {

    /// A builder for [`InvalidTtlOrder`](crate::error::InvalidTtlOrder).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidTtlOrder`](crate::error::InvalidTtlOrder).
        pub fn build(self) -> crate::error::InvalidTtlOrder {
            crate::error::InvalidTtlOrder {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl InvalidTtlOrder {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidTtlOrder {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidTtlOrder [InvalidTTLOrder]")?;
        if let Some(inner_72) = &self.message {
            {
                write!(f, ": {}", inner_72)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidTtlOrder {}
impl aws_http::request_id::RequestId for crate::error::InvalidTtlOrder {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidTtlOrder {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>A response code is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidResponseCode {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidResponseCode {
    /// Creates a new builder-style object to manufacture [`InvalidResponseCode`](crate::error::InvalidResponseCode).
    pub fn builder() -> crate::error::invalid_response_code::Builder {
        crate::error::invalid_response_code::Builder::default()
    }
}
/// See [`InvalidResponseCode`](crate::error::InvalidResponseCode).
pub mod invalid_response_code {

    /// A builder for [`InvalidResponseCode`](crate::error::InvalidResponseCode).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidResponseCode`](crate::error::InvalidResponseCode).
        pub fn build(self) -> crate::error::InvalidResponseCode {
            crate::error::InvalidResponseCode {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl InvalidResponseCode {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidResponseCode {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidResponseCode")?;
        if let Some(inner_73) = &self.message {
            {
                write!(f, ": {}", inner_73)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidResponseCode {}
impl aws_http::request_id::RequestId for crate::error::InvalidResponseCode {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidResponseCode {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>This operation requires the HTTPS protocol. Ensure that you specify the HTTPS protocol in your request, or omit the <code>RequiredProtocols</code> element from your distribution configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidRequiredProtocol {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidRequiredProtocol {
    /// Creates a new builder-style object to manufacture [`InvalidRequiredProtocol`](crate::error::InvalidRequiredProtocol).
    pub fn builder() -> crate::error::invalid_required_protocol::Builder {
        crate::error::invalid_required_protocol::Builder::default()
    }
}
/// See [`InvalidRequiredProtocol`](crate::error::InvalidRequiredProtocol).
pub mod invalid_required_protocol {

    /// A builder for [`InvalidRequiredProtocol`](crate::error::InvalidRequiredProtocol).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidRequiredProtocol`](crate::error::InvalidRequiredProtocol).
        pub fn build(self) -> crate::error::InvalidRequiredProtocol {
            crate::error::InvalidRequiredProtocol {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl InvalidRequiredProtocol {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidRequiredProtocol {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidRequiredProtocol")?;
        if let Some(inner_74) = &self.message {
            {
                write!(f, ": {}", inner_74)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidRequiredProtocol {}
impl aws_http::request_id::RequestId for crate::error::InvalidRequiredProtocol {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidRequiredProtocol {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The relative path is too big, is not URL-encoded, or does not begin with a slash (/).</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidRelativePath {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidRelativePath {
    /// Creates a new builder-style object to manufacture [`InvalidRelativePath`](crate::error::InvalidRelativePath).
    pub fn builder() -> crate::error::invalid_relative_path::Builder {
        crate::error::invalid_relative_path::Builder::default()
    }
}
/// See [`InvalidRelativePath`](crate::error::InvalidRelativePath).
pub mod invalid_relative_path {

    /// A builder for [`InvalidRelativePath`](crate::error::InvalidRelativePath).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidRelativePath`](crate::error::InvalidRelativePath).
        pub fn build(self) -> crate::error::InvalidRelativePath {
            crate::error::InvalidRelativePath {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl InvalidRelativePath {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidRelativePath {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidRelativePath")?;
        if let Some(inner_75) = &self.message {
            {
                write!(f, ": {}", inner_75)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidRelativePath {}
impl aws_http::request_id::RequestId for crate::error::InvalidRelativePath {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidRelativePath {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The query string parameters specified are not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidQueryStringParameters {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidQueryStringParameters {
    /// Creates a new builder-style object to manufacture [`InvalidQueryStringParameters`](crate::error::InvalidQueryStringParameters).
    pub fn builder() -> crate::error::invalid_query_string_parameters::Builder {
        crate::error::invalid_query_string_parameters::Builder::default()
    }
}
/// See [`InvalidQueryStringParameters`](crate::error::InvalidQueryStringParameters).
pub mod invalid_query_string_parameters {

    /// A builder for [`InvalidQueryStringParameters`](crate::error::InvalidQueryStringParameters).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidQueryStringParameters`](crate::error::InvalidQueryStringParameters).
        pub fn build(self) -> crate::error::InvalidQueryStringParameters {
            crate::error::InvalidQueryStringParameters {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl InvalidQueryStringParameters {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidQueryStringParameters {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidQueryStringParameters")?;
        if let Some(inner_76) = &self.message {
            {
                write!(f, ": {}", inner_76)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidQueryStringParameters {}
impl aws_http::request_id::RequestId for crate::error::InvalidQueryStringParameters {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidQueryStringParameters {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The read timeout specified for the origin is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidOriginReadTimeout {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidOriginReadTimeout {
    /// Creates a new builder-style object to manufacture [`InvalidOriginReadTimeout`](crate::error::InvalidOriginReadTimeout).
    pub fn builder() -> crate::error::invalid_origin_read_timeout::Builder {
        crate::error::invalid_origin_read_timeout::Builder::default()
    }
}
/// See [`InvalidOriginReadTimeout`](crate::error::InvalidOriginReadTimeout).
pub mod invalid_origin_read_timeout {

    /// A builder for [`InvalidOriginReadTimeout`](crate::error::InvalidOriginReadTimeout).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidOriginReadTimeout`](crate::error::InvalidOriginReadTimeout).
        pub fn build(self) -> crate::error::InvalidOriginReadTimeout {
            crate::error::InvalidOriginReadTimeout {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl InvalidOriginReadTimeout {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidOriginReadTimeout {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidOriginReadTimeout")?;
        if let Some(inner_77) = &self.message {
            {
                write!(f, ": {}", inner_77)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidOriginReadTimeout {}
impl aws_http::request_id::RequestId for crate::error::InvalidOriginReadTimeout {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidOriginReadTimeout {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The keep alive timeout specified for the origin is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidOriginKeepaliveTimeout {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidOriginKeepaliveTimeout {
    /// Creates a new builder-style object to manufacture [`InvalidOriginKeepaliveTimeout`](crate::error::InvalidOriginKeepaliveTimeout).
    pub fn builder() -> crate::error::invalid_origin_keepalive_timeout::Builder {
        crate::error::invalid_origin_keepalive_timeout::Builder::default()
    }
}
/// See [`InvalidOriginKeepaliveTimeout`](crate::error::InvalidOriginKeepaliveTimeout).
pub mod invalid_origin_keepalive_timeout {

    /// A builder for [`InvalidOriginKeepaliveTimeout`](crate::error::InvalidOriginKeepaliveTimeout).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidOriginKeepaliveTimeout`](crate::error::InvalidOriginKeepaliveTimeout).
        pub fn build(self) -> crate::error::InvalidOriginKeepaliveTimeout {
            crate::error::InvalidOriginKeepaliveTimeout {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl InvalidOriginKeepaliveTimeout {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidOriginKeepaliveTimeout {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidOriginKeepaliveTimeout")?;
        if let Some(inner_78) = &self.message {
            {
                write!(f, ": {}", inner_78)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidOriginKeepaliveTimeout {}
impl aws_http::request_id::RequestId for crate::error::InvalidOriginKeepaliveTimeout {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidOriginKeepaliveTimeout {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The minimum protocol version specified is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidMinimumProtocolVersion {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidMinimumProtocolVersion {
    /// Creates a new builder-style object to manufacture [`InvalidMinimumProtocolVersion`](crate::error::InvalidMinimumProtocolVersion).
    pub fn builder() -> crate::error::invalid_minimum_protocol_version::Builder {
        crate::error::invalid_minimum_protocol_version::Builder::default()
    }
}
/// See [`InvalidMinimumProtocolVersion`](crate::error::InvalidMinimumProtocolVersion).
pub mod invalid_minimum_protocol_version {

    /// A builder for [`InvalidMinimumProtocolVersion`](crate::error::InvalidMinimumProtocolVersion).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidMinimumProtocolVersion`](crate::error::InvalidMinimumProtocolVersion).
        pub fn build(self) -> crate::error::InvalidMinimumProtocolVersion {
            crate::error::InvalidMinimumProtocolVersion {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl InvalidMinimumProtocolVersion {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidMinimumProtocolVersion {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidMinimumProtocolVersion")?;
        if let Some(inner_79) = &self.message {
            {
                write!(f, ": {}", inner_79)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidMinimumProtocolVersion {}
impl aws_http::request_id::RequestId for crate::error::InvalidMinimumProtocolVersion {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidMinimumProtocolVersion {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The location code specified is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidLocationCode {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidLocationCode {
    /// Creates a new builder-style object to manufacture [`InvalidLocationCode`](crate::error::InvalidLocationCode).
    pub fn builder() -> crate::error::invalid_location_code::Builder {
        crate::error::invalid_location_code::Builder::default()
    }
}
/// See [`InvalidLocationCode`](crate::error::InvalidLocationCode).
pub mod invalid_location_code {

    /// A builder for [`InvalidLocationCode`](crate::error::InvalidLocationCode).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidLocationCode`](crate::error::InvalidLocationCode).
        pub fn build(self) -> crate::error::InvalidLocationCode {
            crate::error::InvalidLocationCode {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl InvalidLocationCode {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidLocationCode {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidLocationCode")?;
        if let Some(inner_80) = &self.message {
            {
                write!(f, ": {}", inner_80)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidLocationCode {}
impl aws_http::request_id::RequestId for crate::error::InvalidLocationCode {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidLocationCode {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The specified Lambda@Edge function association is invalid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidLambdaFunctionAssociation {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidLambdaFunctionAssociation {
    /// Creates a new builder-style object to manufacture [`InvalidLambdaFunctionAssociation`](crate::error::InvalidLambdaFunctionAssociation).
    pub fn builder() -> crate::error::invalid_lambda_function_association::Builder {
        crate::error::invalid_lambda_function_association::Builder::default()
    }
}
/// See [`InvalidLambdaFunctionAssociation`](crate::error::InvalidLambdaFunctionAssociation).
pub mod invalid_lambda_function_association {

    /// A builder for [`InvalidLambdaFunctionAssociation`](crate::error::InvalidLambdaFunctionAssociation).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidLambdaFunctionAssociation`](crate::error::InvalidLambdaFunctionAssociation).
        pub fn build(self) -> crate::error::InvalidLambdaFunctionAssociation {
            crate::error::InvalidLambdaFunctionAssociation {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl InvalidLambdaFunctionAssociation {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidLambdaFunctionAssociation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidLambdaFunctionAssociation")?;
        if let Some(inner_81) = &self.message {
            {
                write!(f, ": {}", inner_81)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidLambdaFunctionAssociation {}
impl aws_http::request_id::RequestId for crate::error::InvalidLambdaFunctionAssociation {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidLambdaFunctionAssociation {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The headers specified are not valid for an Amazon S3 origin.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidHeadersForS3Origin {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidHeadersForS3Origin {
    /// Creates a new builder-style object to manufacture [`InvalidHeadersForS3Origin`](crate::error::InvalidHeadersForS3Origin).
    pub fn builder() -> crate::error::invalid_headers_for_s3_origin::Builder {
        crate::error::invalid_headers_for_s3_origin::Builder::default()
    }
}
/// See [`InvalidHeadersForS3Origin`](crate::error::InvalidHeadersForS3Origin).
pub mod invalid_headers_for_s3_origin {

    /// A builder for [`InvalidHeadersForS3Origin`](crate::error::InvalidHeadersForS3Origin).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidHeadersForS3Origin`](crate::error::InvalidHeadersForS3Origin).
        pub fn build(self) -> crate::error::InvalidHeadersForS3Origin {
            crate::error::InvalidHeadersForS3Origin {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl InvalidHeadersForS3Origin {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidHeadersForS3Origin {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidHeadersForS3Origin")?;
        if let Some(inner_82) = &self.message {
            {
                write!(f, ": {}", inner_82)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidHeadersForS3Origin {}
impl aws_http::request_id::RequestId for crate::error::InvalidHeadersForS3Origin {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidHeadersForS3Origin {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The specified geo restriction parameter is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidGeoRestrictionParameter {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidGeoRestrictionParameter {
    /// Creates a new builder-style object to manufacture [`InvalidGeoRestrictionParameter`](crate::error::InvalidGeoRestrictionParameter).
    pub fn builder() -> crate::error::invalid_geo_restriction_parameter::Builder {
        crate::error::invalid_geo_restriction_parameter::Builder::default()
    }
}
/// See [`InvalidGeoRestrictionParameter`](crate::error::InvalidGeoRestrictionParameter).
pub mod invalid_geo_restriction_parameter {

    /// A builder for [`InvalidGeoRestrictionParameter`](crate::error::InvalidGeoRestrictionParameter).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidGeoRestrictionParameter`](crate::error::InvalidGeoRestrictionParameter).
        pub fn build(self) -> crate::error::InvalidGeoRestrictionParameter {
            crate::error::InvalidGeoRestrictionParameter {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl InvalidGeoRestrictionParameter {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidGeoRestrictionParameter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidGeoRestrictionParameter")?;
        if let Some(inner_83) = &self.message {
            {
                write!(f, ": {}", inner_83)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidGeoRestrictionParameter {}
impl aws_http::request_id::RequestId for crate::error::InvalidGeoRestrictionParameter {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidGeoRestrictionParameter {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>A CloudFront function association is invalid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidFunctionAssociation {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidFunctionAssociation {
    /// Creates a new builder-style object to manufacture [`InvalidFunctionAssociation`](crate::error::InvalidFunctionAssociation).
    pub fn builder() -> crate::error::invalid_function_association::Builder {
        crate::error::invalid_function_association::Builder::default()
    }
}
/// See [`InvalidFunctionAssociation`](crate::error::InvalidFunctionAssociation).
pub mod invalid_function_association {

    /// A builder for [`InvalidFunctionAssociation`](crate::error::InvalidFunctionAssociation).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidFunctionAssociation`](crate::error::InvalidFunctionAssociation).
        pub fn build(self) -> crate::error::InvalidFunctionAssociation {
            crate::error::InvalidFunctionAssociation {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl InvalidFunctionAssociation {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidFunctionAssociation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidFunctionAssociation")?;
        if let Some(inner_84) = &self.message {
            {
                write!(f, ": {}", inner_84)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidFunctionAssociation {}
impl aws_http::request_id::RequestId for crate::error::InvalidFunctionAssociation {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidFunctionAssociation {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>Your request contains forward cookies option which doesn't match with the expectation for the <code>whitelisted</code> list of cookie names. Either list of cookie names has been specified when not allowed or list of cookie names is missing when expected.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidForwardCookies {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidForwardCookies {
    /// Creates a new builder-style object to manufacture [`InvalidForwardCookies`](crate::error::InvalidForwardCookies).
    pub fn builder() -> crate::error::invalid_forward_cookies::Builder {
        crate::error::invalid_forward_cookies::Builder::default()
    }
}
/// See [`InvalidForwardCookies`](crate::error::InvalidForwardCookies).
pub mod invalid_forward_cookies {

    /// A builder for [`InvalidForwardCookies`](crate::error::InvalidForwardCookies).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidForwardCookies`](crate::error::InvalidForwardCookies).
        pub fn build(self) -> crate::error::InvalidForwardCookies {
            crate::error::InvalidForwardCookies {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl InvalidForwardCookies {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidForwardCookies {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidForwardCookies")?;
        if let Some(inner_85) = &self.message {
            {
                write!(f, ": {}", inner_85)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidForwardCookies {}
impl aws_http::request_id::RequestId for crate::error::InvalidForwardCookies {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidForwardCookies {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>An invalid error code was specified.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidErrorCode {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidErrorCode {
    /// Creates a new builder-style object to manufacture [`InvalidErrorCode`](crate::error::InvalidErrorCode).
    pub fn builder() -> crate::error::invalid_error_code::Builder {
        crate::error::invalid_error_code::Builder::default()
    }
}
/// See [`InvalidErrorCode`](crate::error::InvalidErrorCode).
pub mod invalid_error_code {

    /// A builder for [`InvalidErrorCode`](crate::error::InvalidErrorCode).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidErrorCode`](crate::error::InvalidErrorCode).
        pub fn build(self) -> crate::error::InvalidErrorCode {
            crate::error::InvalidErrorCode {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl InvalidErrorCode {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidErrorCode {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidErrorCode")?;
        if let Some(inner_86) = &self.message {
            {
                write!(f, ": {}", inner_86)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidErrorCode {}
impl aws_http::request_id::RequestId for crate::error::InvalidErrorCode {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidErrorCode {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The default root object file name is too big or contains an invalid character.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidDefaultRootObject {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidDefaultRootObject {
    /// Creates a new builder-style object to manufacture [`InvalidDefaultRootObject`](crate::error::InvalidDefaultRootObject).
    pub fn builder() -> crate::error::invalid_default_root_object::Builder {
        crate::error::invalid_default_root_object::Builder::default()
    }
}
/// See [`InvalidDefaultRootObject`](crate::error::InvalidDefaultRootObject).
pub mod invalid_default_root_object {

    /// A builder for [`InvalidDefaultRootObject`](crate::error::InvalidDefaultRootObject).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidDefaultRootObject`](crate::error::InvalidDefaultRootObject).
        pub fn build(self) -> crate::error::InvalidDefaultRootObject {
            crate::error::InvalidDefaultRootObject {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl InvalidDefaultRootObject {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidDefaultRootObject {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidDefaultRootObject")?;
        if let Some(inner_87) = &self.message {
            {
                write!(f, ": {}", inner_87)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidDefaultRootObject {}
impl aws_http::request_id::RequestId for crate::error::InvalidDefaultRootObject {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidDefaultRootObject {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The specified configuration for field-level encryption can't be associated with the specified cache behavior.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior {
    /// Creates a new builder-style object to manufacture [`IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior`](crate::error::IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior).
    pub fn builder(
    ) -> crate::error::illegal_field_level_encryption_config_association_with_cache_behavior::Builder
    {
        crate::error::illegal_field_level_encryption_config_association_with_cache_behavior::Builder::default()
    }
}
/// See [`IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior`](crate::error::IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior).
pub mod illegal_field_level_encryption_config_association_with_cache_behavior {

    /// A builder for [`IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior`](crate::error::IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior`](crate::error::IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior).
        pub fn build(
            self,
        ) -> crate::error::IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior {
            crate::error::IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior"
        )?;
        if let Some(inner_88) = &self.message {
            {
                write!(f, ": {}", inner_88)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior {}
impl aws_http::request_id::RequestId
    for crate::error::IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior
{
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type UpdateDistributionErrorKind = UpdateDistributionError;
/// Error type for the `UpdateDistributionError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateDistributionError {
    /// <p>Access denied.</p>
    AccessDenied(crate::error::AccessDenied),
    /// <p>The CNAME specified is already defined for CloudFront.</p>
    CnameAlreadyExists(crate::error::CnameAlreadyExists),
    /// <p>You cannot delete a continuous deployment policy that is associated with a primary distribution.</p>
    ContinuousDeploymentPolicyInUse(crate::error::ContinuousDeploymentPolicyInUse),
    /// <p>The specified configuration for field-level encryption can't be associated with the specified cache behavior.</p>
    IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior(
        crate::error::IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior,
    ),
    /// <p>An origin cannot contain both an origin access control (OAC) and an origin access identity (OAI).</p>
    IllegalOriginAccessConfiguration(crate::error::IllegalOriginAccessConfiguration),
    /// <p>The update contains modifications that are not allowed.</p>
    IllegalUpdate(crate::error::IllegalUpdate),
    /// <p>The value of <code>Quantity</code> and the size of <code>Items</code> don't match.</p>
    InconsistentQuantities(crate::error::InconsistentQuantities),
    /// <p>An argument is invalid.</p>
    InvalidArgument(crate::error::InvalidArgument),
    /// <p>The default root object file name is too big or contains an invalid character.</p>
    InvalidDefaultRootObject(crate::error::InvalidDefaultRootObject),
    /// <p>An origin access control is associated with an origin whose domain name is not supported.</p>
    InvalidDomainNameForOriginAccessControl(crate::error::InvalidDomainNameForOriginAccessControl),
    /// <p>An invalid error code was specified.</p>
    InvalidErrorCode(crate::error::InvalidErrorCode),
    /// <p>Your request contains forward cookies option which doesn't match with the expectation for the <code>whitelisted</code> list of cookie names. Either list of cookie names has been specified when not allowed or list of cookie names is missing when expected.</p>
    InvalidForwardCookies(crate::error::InvalidForwardCookies),
    /// <p>A CloudFront function association is invalid.</p>
    InvalidFunctionAssociation(crate::error::InvalidFunctionAssociation),
    /// <p>The specified geo restriction parameter is not valid.</p>
    InvalidGeoRestrictionParameter(crate::error::InvalidGeoRestrictionParameter),
    /// <p>The headers specified are not valid for an Amazon S3 origin.</p>
    InvalidHeadersForS3Origin(crate::error::InvalidHeadersForS3Origin),
    /// <p>The <code>If-Match</code> version is missing or not valid.</p>
    InvalidIfMatchVersion(crate::error::InvalidIfMatchVersion),
    /// <p>The specified Lambda@Edge function association is invalid.</p>
    InvalidLambdaFunctionAssociation(crate::error::InvalidLambdaFunctionAssociation),
    /// <p>The location code specified is not valid.</p>
    InvalidLocationCode(crate::error::InvalidLocationCode),
    /// <p>The minimum protocol version specified is not valid.</p>
    InvalidMinimumProtocolVersion(crate::error::InvalidMinimumProtocolVersion),
    /// <p>The origin access control is not valid.</p>
    InvalidOriginAccessControl(crate::error::InvalidOriginAccessControl),
    /// <p>The origin access identity is not valid or doesn't exist.</p>
    InvalidOriginAccessIdentity(crate::error::InvalidOriginAccessIdentity),
    /// <p>The keep alive timeout specified for the origin is not valid.</p>
    InvalidOriginKeepaliveTimeout(crate::error::InvalidOriginKeepaliveTimeout),
    /// <p>The read timeout specified for the origin is not valid.</p>
    InvalidOriginReadTimeout(crate::error::InvalidOriginReadTimeout),
    /// <p>The query string parameters specified are not valid.</p>
    InvalidQueryStringParameters(crate::error::InvalidQueryStringParameters),
    /// <p>The relative path is too big, is not URL-encoded, or does not begin with a slash (/).</p>
    InvalidRelativePath(crate::error::InvalidRelativePath),
    /// <p>This operation requires the HTTPS protocol. Ensure that you specify the HTTPS protocol in your request, or omit the <code>RequiredProtocols</code> element from your distribution configuration.</p>
    InvalidRequiredProtocol(crate::error::InvalidRequiredProtocol),
    /// <p>A response code is not valid.</p>
    InvalidResponseCode(crate::error::InvalidResponseCode),
    /// <p>The TTL order specified is not valid.</p>
    InvalidTtlOrder(crate::error::InvalidTtlOrder),
    /// <p>A viewer certificate specified is not valid.</p>
    InvalidViewerCertificate(crate::error::InvalidViewerCertificate),
    /// <p>A web ACL ID specified is not valid. To specify a web ACL created using the latest version of WAF, use the ACL ARN, for example <code>arn:aws:wafv2:us-east-1:123456789012:global/webacl/ExampleWebACL/473e64fd-f30b-4765-81a0-62ad96dd167a</code>. To specify a web ACL created using WAF Classic, use the ACL ID, for example <code>473e64fd-f30b-4765-81a0-62ad96dd167a</code>.</p>
    InvalidWebAclId(crate::error::InvalidWebAclId),
    /// <p>This operation requires a body. Ensure that the body is present and the <code>Content-Type</code> header is set.</p>
    MissingBody(crate::error::MissingBody),
    /// <p>The cache policy does not exist.</p>
    NoSuchCachePolicy(crate::error::NoSuchCachePolicy),
    /// <p>The continuous deployment policy doesn't exist.</p>
    NoSuchContinuousDeploymentPolicy(crate::error::NoSuchContinuousDeploymentPolicy),
    /// <p>The specified distribution does not exist.</p>
    NoSuchDistribution(crate::error::NoSuchDistribution),
    /// <p>The specified configuration for field-level encryption doesn't exist.</p>
    NoSuchFieldLevelEncryptionConfig(crate::error::NoSuchFieldLevelEncryptionConfig),
    /// <p>No origin exists with the specified <code>Origin Id</code>.</p>
    NoSuchOrigin(crate::error::NoSuchOrigin),
    /// <p>The origin request policy does not exist.</p>
    NoSuchOriginRequestPolicy(crate::error::NoSuchOriginRequestPolicy),
    /// <p>The real-time log configuration does not exist.</p>
    NoSuchRealtimeLogConfig(crate::error::NoSuchRealtimeLogConfig),
    /// <p>The response headers policy does not exist.</p>
    NoSuchResponseHeadersPolicy(crate::error::NoSuchResponseHeadersPolicy),
    /// <p>The precondition in one or more of the request fields evaluated to <code>false</code>.</p>
    PreconditionFailed(crate::error::PreconditionFailed),
    /// <p>The specified real-time log configuration belongs to a different Amazon Web Services account.</p>
    RealtimeLogConfigOwnerMismatch(crate::error::RealtimeLogConfigOwnerMismatch),
    /// <p>A continuous deployment policy for this staging distribution already exists.</p>
    StagingDistributionInUse(crate::error::StagingDistributionInUse),
    /// <p>You cannot create more cache behaviors for the distribution.</p>
    TooManyCacheBehaviors(crate::error::TooManyCacheBehaviors),
    /// <p>You cannot create anymore custom SSL/TLS certificates.</p>
    TooManyCertificates(crate::error::TooManyCertificates),
    /// <p>Your request contains more cookie names in the whitelist than are allowed per cache behavior.</p>
    TooManyCookieNamesInWhiteList(crate::error::TooManyCookieNamesInWhiteList),
    /// <p>Your request contains more CNAMEs than are allowed per distribution.</p>
    TooManyDistributionCnamEs(crate::error::TooManyDistributionCnamEs),
    /// <p>The maximum number of distributions have been associated with the specified cache policy. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
    TooManyDistributionsAssociatedToCachePolicy(
        crate::error::TooManyDistributionsAssociatedToCachePolicy,
    ),
    /// <p>The maximum number of distributions have been associated with the specified configuration for field-level encryption.</p>
    TooManyDistributionsAssociatedToFieldLevelEncryptionConfig(
        crate::error::TooManyDistributionsAssociatedToFieldLevelEncryptionConfig,
    ),
    /// <p>The number of distributions that reference this key group is more than the maximum allowed. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
    TooManyDistributionsAssociatedToKeyGroup(
        crate::error::TooManyDistributionsAssociatedToKeyGroup,
    ),
    /// <p>The maximum number of distributions have been associated with the specified origin request policy. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
    TooManyDistributionsAssociatedToOriginRequestPolicy(
        crate::error::TooManyDistributionsAssociatedToOriginRequestPolicy,
    ),
    /// <p>The maximum number of distributions have been associated with the specified response headers policy.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
    TooManyDistributionsAssociatedToResponseHeadersPolicy(
        crate::error::TooManyDistributionsAssociatedToResponseHeadersPolicy,
    ),
    /// <p>You have reached the maximum number of distributions that are associated with a CloudFront function. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
    TooManyDistributionsWithFunctionAssociations(
        crate::error::TooManyDistributionsWithFunctionAssociations,
    ),
    /// <p>Processing your request would cause the maximum number of distributions with Lambda@Edge function associations per owner to be exceeded.</p>
    TooManyDistributionsWithLambdaAssociations(
        crate::error::TooManyDistributionsWithLambdaAssociations,
    ),
    /// <p>The maximum number of distributions have been associated with the specified Lambda@Edge function.</p>
    TooManyDistributionsWithSingleFunctionArn(
        crate::error::TooManyDistributionsWithSingleFunctionArn,
    ),
    /// <p>You have reached the maximum number of CloudFront function associations for this distribution. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
    TooManyFunctionAssociations(crate::error::TooManyFunctionAssociations),
    /// <p>Your request contains too many headers in forwarded values.</p>
    TooManyHeadersInForwardedValues(crate::error::TooManyHeadersInForwardedValues),
    /// <p>The number of key groups referenced by this distribution is more than the maximum allowed. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
    TooManyKeyGroupsAssociatedToDistribution(
        crate::error::TooManyKeyGroupsAssociatedToDistribution,
    ),
    /// <p>Your request contains more Lambda@Edge function associations than are allowed per distribution.</p>
    TooManyLambdaFunctionAssociations(crate::error::TooManyLambdaFunctionAssociations),
    /// <p>Your request contains too many origin custom headers.</p>
    TooManyOriginCustomHeaders(crate::error::TooManyOriginCustomHeaders),
    /// <p>Processing your request would cause you to exceed the maximum number of origin groups allowed.</p>
    TooManyOriginGroupsPerDistribution(crate::error::TooManyOriginGroupsPerDistribution),
    /// <p>You cannot create more origins for the distribution.</p>
    TooManyOrigins(crate::error::TooManyOrigins),
    /// <p>Your request contains too many query string parameters.</p>
    TooManyQueryStringParameters(crate::error::TooManyQueryStringParameters),
    /// <p>Your request contains more trusted signers than are allowed per distribution.</p>
    TooManyTrustedSigners(crate::error::TooManyTrustedSigners),
    /// <p>The specified key group does not exist.</p>
    TrustedKeyGroupDoesNotExist(crate::error::TrustedKeyGroupDoesNotExist),
    /// <p>One or more of your trusted signers don't exist.</p>
    TrustedSignerDoesNotExist(crate::error::TrustedSignerDoesNotExist),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for UpdateDistributionError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for UpdateDistributionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AccessDenied(_inner) => _inner.fmt(f),
            Self::CnameAlreadyExists(_inner) => _inner.fmt(f),
            Self::ContinuousDeploymentPolicyInUse(_inner) => _inner.fmt(f),
            Self::IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior(_inner) => {
                _inner.fmt(f)
            }
            Self::IllegalOriginAccessConfiguration(_inner) => _inner.fmt(f),
            Self::IllegalUpdate(_inner) => _inner.fmt(f),
            Self::InconsistentQuantities(_inner) => _inner.fmt(f),
            Self::InvalidArgument(_inner) => _inner.fmt(f),
            Self::InvalidDefaultRootObject(_inner) => _inner.fmt(f),
            Self::InvalidDomainNameForOriginAccessControl(_inner) => _inner.fmt(f),
            Self::InvalidErrorCode(_inner) => _inner.fmt(f),
            Self::InvalidForwardCookies(_inner) => _inner.fmt(f),
            Self::InvalidFunctionAssociation(_inner) => _inner.fmt(f),
            Self::InvalidGeoRestrictionParameter(_inner) => _inner.fmt(f),
            Self::InvalidHeadersForS3Origin(_inner) => _inner.fmt(f),
            Self::InvalidIfMatchVersion(_inner) => _inner.fmt(f),
            Self::InvalidLambdaFunctionAssociation(_inner) => _inner.fmt(f),
            Self::InvalidLocationCode(_inner) => _inner.fmt(f),
            Self::InvalidMinimumProtocolVersion(_inner) => _inner.fmt(f),
            Self::InvalidOriginAccessControl(_inner) => _inner.fmt(f),
            Self::InvalidOriginAccessIdentity(_inner) => _inner.fmt(f),
            Self::InvalidOriginKeepaliveTimeout(_inner) => _inner.fmt(f),
            Self::InvalidOriginReadTimeout(_inner) => _inner.fmt(f),
            Self::InvalidQueryStringParameters(_inner) => _inner.fmt(f),
            Self::InvalidRelativePath(_inner) => _inner.fmt(f),
            Self::InvalidRequiredProtocol(_inner) => _inner.fmt(f),
            Self::InvalidResponseCode(_inner) => _inner.fmt(f),
            Self::InvalidTtlOrder(_inner) => _inner.fmt(f),
            Self::InvalidViewerCertificate(_inner) => _inner.fmt(f),
            Self::InvalidWebAclId(_inner) => _inner.fmt(f),
            Self::MissingBody(_inner) => _inner.fmt(f),
            Self::NoSuchCachePolicy(_inner) => _inner.fmt(f),
            Self::NoSuchContinuousDeploymentPolicy(_inner) => _inner.fmt(f),
            Self::NoSuchDistribution(_inner) => _inner.fmt(f),
            Self::NoSuchFieldLevelEncryptionConfig(_inner) => _inner.fmt(f),
            Self::NoSuchOrigin(_inner) => _inner.fmt(f),
            Self::NoSuchOriginRequestPolicy(_inner) => _inner.fmt(f),
            Self::NoSuchRealtimeLogConfig(_inner) => _inner.fmt(f),
            Self::NoSuchResponseHeadersPolicy(_inner) => _inner.fmt(f),
            Self::PreconditionFailed(_inner) => _inner.fmt(f),
            Self::RealtimeLogConfigOwnerMismatch(_inner) => _inner.fmt(f),
            Self::StagingDistributionInUse(_inner) => _inner.fmt(f),
            Self::TooManyCacheBehaviors(_inner) => _inner.fmt(f),
            Self::TooManyCertificates(_inner) => _inner.fmt(f),
            Self::TooManyCookieNamesInWhiteList(_inner) => _inner.fmt(f),
            Self::TooManyDistributionCnamEs(_inner) => _inner.fmt(f),
            Self::TooManyDistributionsAssociatedToCachePolicy(_inner) => _inner.fmt(f),
            Self::TooManyDistributionsAssociatedToFieldLevelEncryptionConfig(_inner) => {
                _inner.fmt(f)
            }
            Self::TooManyDistributionsAssociatedToKeyGroup(_inner) => _inner.fmt(f),
            Self::TooManyDistributionsAssociatedToOriginRequestPolicy(_inner) => _inner.fmt(f),
            Self::TooManyDistributionsAssociatedToResponseHeadersPolicy(_inner) => _inner.fmt(f),
            Self::TooManyDistributionsWithFunctionAssociations(_inner) => _inner.fmt(f),
            Self::TooManyDistributionsWithLambdaAssociations(_inner) => _inner.fmt(f),
            Self::TooManyDistributionsWithSingleFunctionArn(_inner) => _inner.fmt(f),
            Self::TooManyFunctionAssociations(_inner) => _inner.fmt(f),
            Self::TooManyHeadersInForwardedValues(_inner) => _inner.fmt(f),
            Self::TooManyKeyGroupsAssociatedToDistribution(_inner) => _inner.fmt(f),
            Self::TooManyLambdaFunctionAssociations(_inner) => _inner.fmt(f),
            Self::TooManyOriginCustomHeaders(_inner) => _inner.fmt(f),
            Self::TooManyOriginGroupsPerDistribution(_inner) => _inner.fmt(f),
            Self::TooManyOrigins(_inner) => _inner.fmt(f),
            Self::TooManyQueryStringParameters(_inner) => _inner.fmt(f),
            Self::TooManyTrustedSigners(_inner) => _inner.fmt(f),
            Self::TrustedKeyGroupDoesNotExist(_inner) => _inner.fmt(f),
            Self::TrustedSignerDoesNotExist(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for UpdateDistributionError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AccessDenied(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::CnameAlreadyExists(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ContinuousDeploymentPolicyInUse(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::IllegalOriginAccessConfiguration(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::IllegalUpdate(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InconsistentQuantities(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidArgument(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidDefaultRootObject(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidDomainNameForOriginAccessControl(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidErrorCode(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidForwardCookies(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidFunctionAssociation(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidGeoRestrictionParameter(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidHeadersForS3Origin(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidIfMatchVersion(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidLambdaFunctionAssociation(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidLocationCode(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidMinimumProtocolVersion(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidOriginAccessControl(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidOriginAccessIdentity(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidOriginKeepaliveTimeout(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidOriginReadTimeout(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidQueryStringParameters(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidRelativePath(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidRequiredProtocol(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidResponseCode(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidTtlOrder(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidViewerCertificate(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidWebAclId(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::MissingBody(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NoSuchCachePolicy(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NoSuchContinuousDeploymentPolicy(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NoSuchDistribution(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NoSuchFieldLevelEncryptionConfig(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NoSuchOrigin(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NoSuchOriginRequestPolicy(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NoSuchRealtimeLogConfig(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NoSuchResponseHeadersPolicy(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::PreconditionFailed(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RealtimeLogConfigOwnerMismatch(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::StagingDistributionInUse(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyCacheBehaviors(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyCertificates(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyCookieNamesInWhiteList(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyDistributionCnamEs(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyDistributionsAssociatedToCachePolicy(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyDistributionsAssociatedToFieldLevelEncryptionConfig(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyDistributionsAssociatedToKeyGroup(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyDistributionsAssociatedToOriginRequestPolicy(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyDistributionsAssociatedToResponseHeadersPolicy(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyDistributionsWithFunctionAssociations(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyDistributionsWithLambdaAssociations(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyDistributionsWithSingleFunctionArn(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyFunctionAssociations(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyHeadersInForwardedValues(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyKeyGroupsAssociatedToDistribution(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyLambdaFunctionAssociations(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyOriginCustomHeaders(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyOriginGroupsPerDistribution(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyOrigins(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyQueryStringParameters(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyTrustedSigners(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TrustedKeyGroupDoesNotExist(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TrustedSignerDoesNotExist(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::UpdateDistributionError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateDistributionError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateDistributionError {
    /// Creates the `UpdateDistributionError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `UpdateDistributionError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AccessDenied(e) => e.meta(),
            Self::CnameAlreadyExists(e) => e.meta(),
            Self::ContinuousDeploymentPolicyInUse(e) => e.meta(),
            Self::IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior(e) => e.meta(),
            Self::IllegalOriginAccessConfiguration(e) => e.meta(),
            Self::IllegalUpdate(e) => e.meta(),
            Self::InconsistentQuantities(e) => e.meta(),
            Self::InvalidArgument(e) => e.meta(),
            Self::InvalidDefaultRootObject(e) => e.meta(),
            Self::InvalidDomainNameForOriginAccessControl(e) => e.meta(),
            Self::InvalidErrorCode(e) => e.meta(),
            Self::InvalidForwardCookies(e) => e.meta(),
            Self::InvalidFunctionAssociation(e) => e.meta(),
            Self::InvalidGeoRestrictionParameter(e) => e.meta(),
            Self::InvalidHeadersForS3Origin(e) => e.meta(),
            Self::InvalidIfMatchVersion(e) => e.meta(),
            Self::InvalidLambdaFunctionAssociation(e) => e.meta(),
            Self::InvalidLocationCode(e) => e.meta(),
            Self::InvalidMinimumProtocolVersion(e) => e.meta(),
            Self::InvalidOriginAccessControl(e) => e.meta(),
            Self::InvalidOriginAccessIdentity(e) => e.meta(),
            Self::InvalidOriginKeepaliveTimeout(e) => e.meta(),
            Self::InvalidOriginReadTimeout(e) => e.meta(),
            Self::InvalidQueryStringParameters(e) => e.meta(),
            Self::InvalidRelativePath(e) => e.meta(),
            Self::InvalidRequiredProtocol(e) => e.meta(),
            Self::InvalidResponseCode(e) => e.meta(),
            Self::InvalidTtlOrder(e) => e.meta(),
            Self::InvalidViewerCertificate(e) => e.meta(),
            Self::InvalidWebAclId(e) => e.meta(),
            Self::MissingBody(e) => e.meta(),
            Self::NoSuchCachePolicy(e) => e.meta(),
            Self::NoSuchContinuousDeploymentPolicy(e) => e.meta(),
            Self::NoSuchDistribution(e) => e.meta(),
            Self::NoSuchFieldLevelEncryptionConfig(e) => e.meta(),
            Self::NoSuchOrigin(e) => e.meta(),
            Self::NoSuchOriginRequestPolicy(e) => e.meta(),
            Self::NoSuchRealtimeLogConfig(e) => e.meta(),
            Self::NoSuchResponseHeadersPolicy(e) => e.meta(),
            Self::PreconditionFailed(e) => e.meta(),
            Self::RealtimeLogConfigOwnerMismatch(e) => e.meta(),
            Self::StagingDistributionInUse(e) => e.meta(),
            Self::TooManyCacheBehaviors(e) => e.meta(),
            Self::TooManyCertificates(e) => e.meta(),
            Self::TooManyCookieNamesInWhiteList(e) => e.meta(),
            Self::TooManyDistributionCnamEs(e) => e.meta(),
            Self::TooManyDistributionsAssociatedToCachePolicy(e) => e.meta(),
            Self::TooManyDistributionsAssociatedToFieldLevelEncryptionConfig(e) => e.meta(),
            Self::TooManyDistributionsAssociatedToKeyGroup(e) => e.meta(),
            Self::TooManyDistributionsAssociatedToOriginRequestPolicy(e) => e.meta(),
            Self::TooManyDistributionsAssociatedToResponseHeadersPolicy(e) => e.meta(),
            Self::TooManyDistributionsWithFunctionAssociations(e) => e.meta(),
            Self::TooManyDistributionsWithLambdaAssociations(e) => e.meta(),
            Self::TooManyDistributionsWithSingleFunctionArn(e) => e.meta(),
            Self::TooManyFunctionAssociations(e) => e.meta(),
            Self::TooManyHeadersInForwardedValues(e) => e.meta(),
            Self::TooManyKeyGroupsAssociatedToDistribution(e) => e.meta(),
            Self::TooManyLambdaFunctionAssociations(e) => e.meta(),
            Self::TooManyOriginCustomHeaders(e) => e.meta(),
            Self::TooManyOriginGroupsPerDistribution(e) => e.meta(),
            Self::TooManyOrigins(e) => e.meta(),
            Self::TooManyQueryStringParameters(e) => e.meta(),
            Self::TooManyTrustedSigners(e) => e.meta(),
            Self::TrustedKeyGroupDoesNotExist(e) => e.meta(),
            Self::TrustedSignerDoesNotExist(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `UpdateDistributionError::AccessDenied`.
    pub fn is_access_denied(&self) -> bool {
        matches!(self, Self::AccessDenied(_))
    }
    /// Returns `true` if the error kind is `UpdateDistributionError::CnameAlreadyExists`.
    pub fn is_cname_already_exists(&self) -> bool {
        matches!(self, Self::CnameAlreadyExists(_))
    }
    /// Returns `true` if the error kind is `UpdateDistributionError::ContinuousDeploymentPolicyInUse`.
    pub fn is_continuous_deployment_policy_in_use(&self) -> bool {
        matches!(self, Self::ContinuousDeploymentPolicyInUse(_))
    }
    /// Returns `true` if the error kind is `UpdateDistributionError::IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior`.
    pub fn is_illegal_field_level_encryption_config_association_with_cache_behavior(&self) -> bool {
        matches!(
            self,
            Self::IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateDistributionError::IllegalOriginAccessConfiguration`.
    pub fn is_illegal_origin_access_configuration(&self) -> bool {
        matches!(self, Self::IllegalOriginAccessConfiguration(_))
    }
    /// Returns `true` if the error kind is `UpdateDistributionError::IllegalUpdate`.
    pub fn is_illegal_update(&self) -> bool {
        matches!(self, Self::IllegalUpdate(_))
    }
    /// Returns `true` if the error kind is `UpdateDistributionError::InconsistentQuantities`.
    pub fn is_inconsistent_quantities(&self) -> bool {
        matches!(self, Self::InconsistentQuantities(_))
    }
    /// Returns `true` if the error kind is `UpdateDistributionError::InvalidArgument`.
    pub fn is_invalid_argument(&self) -> bool {
        matches!(self, Self::InvalidArgument(_))
    }
    /// Returns `true` if the error kind is `UpdateDistributionError::InvalidDefaultRootObject`.
    pub fn is_invalid_default_root_object(&self) -> bool {
        matches!(self, Self::InvalidDefaultRootObject(_))
    }
    /// Returns `true` if the error kind is `UpdateDistributionError::InvalidDomainNameForOriginAccessControl`.
    pub fn is_invalid_domain_name_for_origin_access_control(&self) -> bool {
        matches!(self, Self::InvalidDomainNameForOriginAccessControl(_))
    }
    /// Returns `true` if the error kind is `UpdateDistributionError::InvalidErrorCode`.
    pub fn is_invalid_error_code(&self) -> bool {
        matches!(self, Self::InvalidErrorCode(_))
    }
    /// Returns `true` if the error kind is `UpdateDistributionError::InvalidForwardCookies`.
    pub fn is_invalid_forward_cookies(&self) -> bool {
        matches!(self, Self::InvalidForwardCookies(_))
    }
    /// Returns `true` if the error kind is `UpdateDistributionError::InvalidFunctionAssociation`.
    pub fn is_invalid_function_association(&self) -> bool {
        matches!(self, Self::InvalidFunctionAssociation(_))
    }
    /// Returns `true` if the error kind is `UpdateDistributionError::InvalidGeoRestrictionParameter`.
    pub fn is_invalid_geo_restriction_parameter(&self) -> bool {
        matches!(self, Self::InvalidGeoRestrictionParameter(_))
    }
    /// Returns `true` if the error kind is `UpdateDistributionError::InvalidHeadersForS3Origin`.
    pub fn is_invalid_headers_for_s3_origin(&self) -> bool {
        matches!(self, Self::InvalidHeadersForS3Origin(_))
    }
    /// Returns `true` if the error kind is `UpdateDistributionError::InvalidIfMatchVersion`.
    pub fn is_invalid_if_match_version(&self) -> bool {
        matches!(self, Self::InvalidIfMatchVersion(_))
    }
    /// Returns `true` if the error kind is `UpdateDistributionError::InvalidLambdaFunctionAssociation`.
    pub fn is_invalid_lambda_function_association(&self) -> bool {
        matches!(self, Self::InvalidLambdaFunctionAssociation(_))
    }
    /// Returns `true` if the error kind is `UpdateDistributionError::InvalidLocationCode`.
    pub fn is_invalid_location_code(&self) -> bool {
        matches!(self, Self::InvalidLocationCode(_))
    }
    /// Returns `true` if the error kind is `UpdateDistributionError::InvalidMinimumProtocolVersion`.
    pub fn is_invalid_minimum_protocol_version(&self) -> bool {
        matches!(self, Self::InvalidMinimumProtocolVersion(_))
    }
    /// Returns `true` if the error kind is `UpdateDistributionError::InvalidOriginAccessControl`.
    pub fn is_invalid_origin_access_control(&self) -> bool {
        matches!(self, Self::InvalidOriginAccessControl(_))
    }
    /// Returns `true` if the error kind is `UpdateDistributionError::InvalidOriginAccessIdentity`.
    pub fn is_invalid_origin_access_identity(&self) -> bool {
        matches!(self, Self::InvalidOriginAccessIdentity(_))
    }
    /// Returns `true` if the error kind is `UpdateDistributionError::InvalidOriginKeepaliveTimeout`.
    pub fn is_invalid_origin_keepalive_timeout(&self) -> bool {
        matches!(self, Self::InvalidOriginKeepaliveTimeout(_))
    }
    /// Returns `true` if the error kind is `UpdateDistributionError::InvalidOriginReadTimeout`.
    pub fn is_invalid_origin_read_timeout(&self) -> bool {
        matches!(self, Self::InvalidOriginReadTimeout(_))
    }
    /// Returns `true` if the error kind is `UpdateDistributionError::InvalidQueryStringParameters`.
    pub fn is_invalid_query_string_parameters(&self) -> bool {
        matches!(self, Self::InvalidQueryStringParameters(_))
    }
    /// Returns `true` if the error kind is `UpdateDistributionError::InvalidRelativePath`.
    pub fn is_invalid_relative_path(&self) -> bool {
        matches!(self, Self::InvalidRelativePath(_))
    }
    /// Returns `true` if the error kind is `UpdateDistributionError::InvalidRequiredProtocol`.
    pub fn is_invalid_required_protocol(&self) -> bool {
        matches!(self, Self::InvalidRequiredProtocol(_))
    }
    /// Returns `true` if the error kind is `UpdateDistributionError::InvalidResponseCode`.
    pub fn is_invalid_response_code(&self) -> bool {
        matches!(self, Self::InvalidResponseCode(_))
    }
    /// Returns `true` if the error kind is `UpdateDistributionError::InvalidTtlOrder`.
    pub fn is_invalid_ttl_order(&self) -> bool {
        matches!(self, Self::InvalidTtlOrder(_))
    }
    /// Returns `true` if the error kind is `UpdateDistributionError::InvalidViewerCertificate`.
    pub fn is_invalid_viewer_certificate(&self) -> bool {
        matches!(self, Self::InvalidViewerCertificate(_))
    }
    /// Returns `true` if the error kind is `UpdateDistributionError::InvalidWebAclId`.
    pub fn is_invalid_web_acl_id(&self) -> bool {
        matches!(self, Self::InvalidWebAclId(_))
    }
    /// Returns `true` if the error kind is `UpdateDistributionError::MissingBody`.
    pub fn is_missing_body(&self) -> bool {
        matches!(self, Self::MissingBody(_))
    }
    /// Returns `true` if the error kind is `UpdateDistributionError::NoSuchCachePolicy`.
    pub fn is_no_such_cache_policy(&self) -> bool {
        matches!(self, Self::NoSuchCachePolicy(_))
    }
    /// Returns `true` if the error kind is `UpdateDistributionError::NoSuchContinuousDeploymentPolicy`.
    pub fn is_no_such_continuous_deployment_policy(&self) -> bool {
        matches!(self, Self::NoSuchContinuousDeploymentPolicy(_))
    }
    /// Returns `true` if the error kind is `UpdateDistributionError::NoSuchDistribution`.
    pub fn is_no_such_distribution(&self) -> bool {
        matches!(self, Self::NoSuchDistribution(_))
    }
    /// Returns `true` if the error kind is `UpdateDistributionError::NoSuchFieldLevelEncryptionConfig`.
    pub fn is_no_such_field_level_encryption_config(&self) -> bool {
        matches!(self, Self::NoSuchFieldLevelEncryptionConfig(_))
    }
    /// Returns `true` if the error kind is `UpdateDistributionError::NoSuchOrigin`.
    pub fn is_no_such_origin(&self) -> bool {
        matches!(self, Self::NoSuchOrigin(_))
    }
    /// Returns `true` if the error kind is `UpdateDistributionError::NoSuchOriginRequestPolicy`.
    pub fn is_no_such_origin_request_policy(&self) -> bool {
        matches!(self, Self::NoSuchOriginRequestPolicy(_))
    }
    /// Returns `true` if the error kind is `UpdateDistributionError::NoSuchRealtimeLogConfig`.
    pub fn is_no_such_realtime_log_config(&self) -> bool {
        matches!(self, Self::NoSuchRealtimeLogConfig(_))
    }
    /// Returns `true` if the error kind is `UpdateDistributionError::NoSuchResponseHeadersPolicy`.
    pub fn is_no_such_response_headers_policy(&self) -> bool {
        matches!(self, Self::NoSuchResponseHeadersPolicy(_))
    }
    /// Returns `true` if the error kind is `UpdateDistributionError::PreconditionFailed`.
    pub fn is_precondition_failed(&self) -> bool {
        matches!(self, Self::PreconditionFailed(_))
    }
    /// Returns `true` if the error kind is `UpdateDistributionError::RealtimeLogConfigOwnerMismatch`.
    pub fn is_realtime_log_config_owner_mismatch(&self) -> bool {
        matches!(self, Self::RealtimeLogConfigOwnerMismatch(_))
    }
    /// Returns `true` if the error kind is `UpdateDistributionError::StagingDistributionInUse`.
    pub fn is_staging_distribution_in_use(&self) -> bool {
        matches!(self, Self::StagingDistributionInUse(_))
    }
    /// Returns `true` if the error kind is `UpdateDistributionError::TooManyCacheBehaviors`.
    pub fn is_too_many_cache_behaviors(&self) -> bool {
        matches!(self, Self::TooManyCacheBehaviors(_))
    }
    /// Returns `true` if the error kind is `UpdateDistributionError::TooManyCertificates`.
    pub fn is_too_many_certificates(&self) -> bool {
        matches!(self, Self::TooManyCertificates(_))
    }
    /// Returns `true` if the error kind is `UpdateDistributionError::TooManyCookieNamesInWhiteList`.
    pub fn is_too_many_cookie_names_in_white_list(&self) -> bool {
        matches!(self, Self::TooManyCookieNamesInWhiteList(_))
    }
    /// Returns `true` if the error kind is `UpdateDistributionError::TooManyDistributionCnamEs`.
    pub fn is_too_many_distribution_cnam_es(&self) -> bool {
        matches!(self, Self::TooManyDistributionCnamEs(_))
    }
    /// Returns `true` if the error kind is `UpdateDistributionError::TooManyDistributionsAssociatedToCachePolicy`.
    pub fn is_too_many_distributions_associated_to_cache_policy(&self) -> bool {
        matches!(self, Self::TooManyDistributionsAssociatedToCachePolicy(_))
    }
    /// Returns `true` if the error kind is `UpdateDistributionError::TooManyDistributionsAssociatedToFieldLevelEncryptionConfig`.
    pub fn is_too_many_distributions_associated_to_field_level_encryption_config(&self) -> bool {
        matches!(
            self,
            Self::TooManyDistributionsAssociatedToFieldLevelEncryptionConfig(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateDistributionError::TooManyDistributionsAssociatedToKeyGroup`.
    pub fn is_too_many_distributions_associated_to_key_group(&self) -> bool {
        matches!(self, Self::TooManyDistributionsAssociatedToKeyGroup(_))
    }
    /// Returns `true` if the error kind is `UpdateDistributionError::TooManyDistributionsAssociatedToOriginRequestPolicy`.
    pub fn is_too_many_distributions_associated_to_origin_request_policy(&self) -> bool {
        matches!(
            self,
            Self::TooManyDistributionsAssociatedToOriginRequestPolicy(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateDistributionError::TooManyDistributionsAssociatedToResponseHeadersPolicy`.
    pub fn is_too_many_distributions_associated_to_response_headers_policy(&self) -> bool {
        matches!(
            self,
            Self::TooManyDistributionsAssociatedToResponseHeadersPolicy(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateDistributionError::TooManyDistributionsWithFunctionAssociations`.
    pub fn is_too_many_distributions_with_function_associations(&self) -> bool {
        matches!(self, Self::TooManyDistributionsWithFunctionAssociations(_))
    }
    /// Returns `true` if the error kind is `UpdateDistributionError::TooManyDistributionsWithLambdaAssociations`.
    pub fn is_too_many_distributions_with_lambda_associations(&self) -> bool {
        matches!(self, Self::TooManyDistributionsWithLambdaAssociations(_))
    }
    /// Returns `true` if the error kind is `UpdateDistributionError::TooManyDistributionsWithSingleFunctionArn`.
    pub fn is_too_many_distributions_with_single_function_arn(&self) -> bool {
        matches!(self, Self::TooManyDistributionsWithSingleFunctionArn(_))
    }
    /// Returns `true` if the error kind is `UpdateDistributionError::TooManyFunctionAssociations`.
    pub fn is_too_many_function_associations(&self) -> bool {
        matches!(self, Self::TooManyFunctionAssociations(_))
    }
    /// Returns `true` if the error kind is `UpdateDistributionError::TooManyHeadersInForwardedValues`.
    pub fn is_too_many_headers_in_forwarded_values(&self) -> bool {
        matches!(self, Self::TooManyHeadersInForwardedValues(_))
    }
    /// Returns `true` if the error kind is `UpdateDistributionError::TooManyKeyGroupsAssociatedToDistribution`.
    pub fn is_too_many_key_groups_associated_to_distribution(&self) -> bool {
        matches!(self, Self::TooManyKeyGroupsAssociatedToDistribution(_))
    }
    /// Returns `true` if the error kind is `UpdateDistributionError::TooManyLambdaFunctionAssociations`.
    pub fn is_too_many_lambda_function_associations(&self) -> bool {
        matches!(self, Self::TooManyLambdaFunctionAssociations(_))
    }
    /// Returns `true` if the error kind is `UpdateDistributionError::TooManyOriginCustomHeaders`.
    pub fn is_too_many_origin_custom_headers(&self) -> bool {
        matches!(self, Self::TooManyOriginCustomHeaders(_))
    }
    /// Returns `true` if the error kind is `UpdateDistributionError::TooManyOriginGroupsPerDistribution`.
    pub fn is_too_many_origin_groups_per_distribution(&self) -> bool {
        matches!(self, Self::TooManyOriginGroupsPerDistribution(_))
    }
    /// Returns `true` if the error kind is `UpdateDistributionError::TooManyOrigins`.
    pub fn is_too_many_origins(&self) -> bool {
        matches!(self, Self::TooManyOrigins(_))
    }
    /// Returns `true` if the error kind is `UpdateDistributionError::TooManyQueryStringParameters`.
    pub fn is_too_many_query_string_parameters(&self) -> bool {
        matches!(self, Self::TooManyQueryStringParameters(_))
    }
    /// Returns `true` if the error kind is `UpdateDistributionError::TooManyTrustedSigners`.
    pub fn is_too_many_trusted_signers(&self) -> bool {
        matches!(self, Self::TooManyTrustedSigners(_))
    }
    /// Returns `true` if the error kind is `UpdateDistributionError::TrustedKeyGroupDoesNotExist`.
    pub fn is_trusted_key_group_does_not_exist(&self) -> bool {
        matches!(self, Self::TrustedKeyGroupDoesNotExist(_))
    }
    /// Returns `true` if the error kind is `UpdateDistributionError::TrustedSignerDoesNotExist`.
    pub fn is_trusted_signer_does_not_exist(&self) -> bool {
        matches!(self, Self::TrustedSignerDoesNotExist(_))
    }
}
impl std::error::Error for UpdateDistributionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AccessDenied(_inner) => Some(_inner),
            Self::CnameAlreadyExists(_inner) => Some(_inner),
            Self::ContinuousDeploymentPolicyInUse(_inner) => Some(_inner),
            Self::IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior(_inner) => {
                Some(_inner)
            }
            Self::IllegalOriginAccessConfiguration(_inner) => Some(_inner),
            Self::IllegalUpdate(_inner) => Some(_inner),
            Self::InconsistentQuantities(_inner) => Some(_inner),
            Self::InvalidArgument(_inner) => Some(_inner),
            Self::InvalidDefaultRootObject(_inner) => Some(_inner),
            Self::InvalidDomainNameForOriginAccessControl(_inner) => Some(_inner),
            Self::InvalidErrorCode(_inner) => Some(_inner),
            Self::InvalidForwardCookies(_inner) => Some(_inner),
            Self::InvalidFunctionAssociation(_inner) => Some(_inner),
            Self::InvalidGeoRestrictionParameter(_inner) => Some(_inner),
            Self::InvalidHeadersForS3Origin(_inner) => Some(_inner),
            Self::InvalidIfMatchVersion(_inner) => Some(_inner),
            Self::InvalidLambdaFunctionAssociation(_inner) => Some(_inner),
            Self::InvalidLocationCode(_inner) => Some(_inner),
            Self::InvalidMinimumProtocolVersion(_inner) => Some(_inner),
            Self::InvalidOriginAccessControl(_inner) => Some(_inner),
            Self::InvalidOriginAccessIdentity(_inner) => Some(_inner),
            Self::InvalidOriginKeepaliveTimeout(_inner) => Some(_inner),
            Self::InvalidOriginReadTimeout(_inner) => Some(_inner),
            Self::InvalidQueryStringParameters(_inner) => Some(_inner),
            Self::InvalidRelativePath(_inner) => Some(_inner),
            Self::InvalidRequiredProtocol(_inner) => Some(_inner),
            Self::InvalidResponseCode(_inner) => Some(_inner),
            Self::InvalidTtlOrder(_inner) => Some(_inner),
            Self::InvalidViewerCertificate(_inner) => Some(_inner),
            Self::InvalidWebAclId(_inner) => Some(_inner),
            Self::MissingBody(_inner) => Some(_inner),
            Self::NoSuchCachePolicy(_inner) => Some(_inner),
            Self::NoSuchContinuousDeploymentPolicy(_inner) => Some(_inner),
            Self::NoSuchDistribution(_inner) => Some(_inner),
            Self::NoSuchFieldLevelEncryptionConfig(_inner) => Some(_inner),
            Self::NoSuchOrigin(_inner) => Some(_inner),
            Self::NoSuchOriginRequestPolicy(_inner) => Some(_inner),
            Self::NoSuchRealtimeLogConfig(_inner) => Some(_inner),
            Self::NoSuchResponseHeadersPolicy(_inner) => Some(_inner),
            Self::PreconditionFailed(_inner) => Some(_inner),
            Self::RealtimeLogConfigOwnerMismatch(_inner) => Some(_inner),
            Self::StagingDistributionInUse(_inner) => Some(_inner),
            Self::TooManyCacheBehaviors(_inner) => Some(_inner),
            Self::TooManyCertificates(_inner) => Some(_inner),
            Self::TooManyCookieNamesInWhiteList(_inner) => Some(_inner),
            Self::TooManyDistributionCnamEs(_inner) => Some(_inner),
            Self::TooManyDistributionsAssociatedToCachePolicy(_inner) => Some(_inner),
            Self::TooManyDistributionsAssociatedToFieldLevelEncryptionConfig(_inner) => {
                Some(_inner)
            }
            Self::TooManyDistributionsAssociatedToKeyGroup(_inner) => Some(_inner),
            Self::TooManyDistributionsAssociatedToOriginRequestPolicy(_inner) => Some(_inner),
            Self::TooManyDistributionsAssociatedToResponseHeadersPolicy(_inner) => Some(_inner),
            Self::TooManyDistributionsWithFunctionAssociations(_inner) => Some(_inner),
            Self::TooManyDistributionsWithLambdaAssociations(_inner) => Some(_inner),
            Self::TooManyDistributionsWithSingleFunctionArn(_inner) => Some(_inner),
            Self::TooManyFunctionAssociations(_inner) => Some(_inner),
            Self::TooManyHeadersInForwardedValues(_inner) => Some(_inner),
            Self::TooManyKeyGroupsAssociatedToDistribution(_inner) => Some(_inner),
            Self::TooManyLambdaFunctionAssociations(_inner) => Some(_inner),
            Self::TooManyOriginCustomHeaders(_inner) => Some(_inner),
            Self::TooManyOriginGroupsPerDistribution(_inner) => Some(_inner),
            Self::TooManyOrigins(_inner) => Some(_inner),
            Self::TooManyQueryStringParameters(_inner) => Some(_inner),
            Self::TooManyTrustedSigners(_inner) => Some(_inner),
            Self::TrustedKeyGroupDoesNotExist(_inner) => Some(_inner),
            Self::TrustedSignerDoesNotExist(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>A continuous deployment policy for this staging distribution already exists.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct StagingDistributionInUse {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl StagingDistributionInUse {
    /// Creates a new builder-style object to manufacture [`StagingDistributionInUse`](crate::error::StagingDistributionInUse).
    pub fn builder() -> crate::error::staging_distribution_in_use::Builder {
        crate::error::staging_distribution_in_use::Builder::default()
    }
}
/// See [`StagingDistributionInUse`](crate::error::StagingDistributionInUse).
pub mod staging_distribution_in_use {

    /// A builder for [`StagingDistributionInUse`](crate::error::StagingDistributionInUse).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`StagingDistributionInUse`](crate::error::StagingDistributionInUse).
        pub fn build(self) -> crate::error::StagingDistributionInUse {
            crate::error::StagingDistributionInUse {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl StagingDistributionInUse {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for StagingDistributionInUse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "StagingDistributionInUse")?;
        if let Some(inner_89) = &self.message {
            {
                write!(f, ": {}", inner_89)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for StagingDistributionInUse {}
impl aws_http::request_id::RequestId for crate::error::StagingDistributionInUse {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for StagingDistributionInUse {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The continuous deployment policy doesn't exist.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct NoSuchContinuousDeploymentPolicy {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl NoSuchContinuousDeploymentPolicy {
    /// Creates a new builder-style object to manufacture [`NoSuchContinuousDeploymentPolicy`](crate::error::NoSuchContinuousDeploymentPolicy).
    pub fn builder() -> crate::error::no_such_continuous_deployment_policy::Builder {
        crate::error::no_such_continuous_deployment_policy::Builder::default()
    }
}
/// See [`NoSuchContinuousDeploymentPolicy`](crate::error::NoSuchContinuousDeploymentPolicy).
pub mod no_such_continuous_deployment_policy {

    /// A builder for [`NoSuchContinuousDeploymentPolicy`](crate::error::NoSuchContinuousDeploymentPolicy).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`NoSuchContinuousDeploymentPolicy`](crate::error::NoSuchContinuousDeploymentPolicy).
        pub fn build(self) -> crate::error::NoSuchContinuousDeploymentPolicy {
            crate::error::NoSuchContinuousDeploymentPolicy {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl NoSuchContinuousDeploymentPolicy {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for NoSuchContinuousDeploymentPolicy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "NoSuchContinuousDeploymentPolicy")?;
        if let Some(inner_90) = &self.message {
            {
                write!(f, ": {}", inner_90)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for NoSuchContinuousDeploymentPolicy {}
impl aws_http::request_id::RequestId for crate::error::NoSuchContinuousDeploymentPolicy {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for NoSuchContinuousDeploymentPolicy {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>An origin access control is associated with an origin whose domain name is not supported.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidDomainNameForOriginAccessControl {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidDomainNameForOriginAccessControl {
    /// Creates a new builder-style object to manufacture [`InvalidDomainNameForOriginAccessControl`](crate::error::InvalidDomainNameForOriginAccessControl).
    pub fn builder() -> crate::error::invalid_domain_name_for_origin_access_control::Builder {
        crate::error::invalid_domain_name_for_origin_access_control::Builder::default()
    }
}
/// See [`InvalidDomainNameForOriginAccessControl`](crate::error::InvalidDomainNameForOriginAccessControl).
pub mod invalid_domain_name_for_origin_access_control {

    /// A builder for [`InvalidDomainNameForOriginAccessControl`](crate::error::InvalidDomainNameForOriginAccessControl).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidDomainNameForOriginAccessControl`](crate::error::InvalidDomainNameForOriginAccessControl).
        pub fn build(self) -> crate::error::InvalidDomainNameForOriginAccessControl {
            crate::error::InvalidDomainNameForOriginAccessControl {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl InvalidDomainNameForOriginAccessControl {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidDomainNameForOriginAccessControl {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidDomainNameForOriginAccessControl")?;
        if let Some(inner_91) = &self.message {
            {
                write!(f, ": {}", inner_91)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidDomainNameForOriginAccessControl {}
impl aws_http::request_id::RequestId for crate::error::InvalidDomainNameForOriginAccessControl {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for InvalidDomainNameForOriginAccessControl
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>An origin cannot contain both an origin access control (OAC) and an origin access identity (OAI).</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct IllegalOriginAccessConfiguration {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl IllegalOriginAccessConfiguration {
    /// Creates a new builder-style object to manufacture [`IllegalOriginAccessConfiguration`](crate::error::IllegalOriginAccessConfiguration).
    pub fn builder() -> crate::error::illegal_origin_access_configuration::Builder {
        crate::error::illegal_origin_access_configuration::Builder::default()
    }
}
/// See [`IllegalOriginAccessConfiguration`](crate::error::IllegalOriginAccessConfiguration).
pub mod illegal_origin_access_configuration {

    /// A builder for [`IllegalOriginAccessConfiguration`](crate::error::IllegalOriginAccessConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`IllegalOriginAccessConfiguration`](crate::error::IllegalOriginAccessConfiguration).
        pub fn build(self) -> crate::error::IllegalOriginAccessConfiguration {
            crate::error::IllegalOriginAccessConfiguration {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl IllegalOriginAccessConfiguration {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for IllegalOriginAccessConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "IllegalOriginAccessConfiguration")?;
        if let Some(inner_92) = &self.message {
            {
                write!(f, ": {}", inner_92)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for IllegalOriginAccessConfiguration {}
impl aws_http::request_id::RequestId for crate::error::IllegalOriginAccessConfiguration {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for IllegalOriginAccessConfiguration {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>You cannot delete a continuous deployment policy that is associated with a primary distribution.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ContinuousDeploymentPolicyInUse {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl ContinuousDeploymentPolicyInUse {
    /// Creates a new builder-style object to manufacture [`ContinuousDeploymentPolicyInUse`](crate::error::ContinuousDeploymentPolicyInUse).
    pub fn builder() -> crate::error::continuous_deployment_policy_in_use::Builder {
        crate::error::continuous_deployment_policy_in_use::Builder::default()
    }
}
/// See [`ContinuousDeploymentPolicyInUse`](crate::error::ContinuousDeploymentPolicyInUse).
pub mod continuous_deployment_policy_in_use {

    /// A builder for [`ContinuousDeploymentPolicyInUse`](crate::error::ContinuousDeploymentPolicyInUse).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`ContinuousDeploymentPolicyInUse`](crate::error::ContinuousDeploymentPolicyInUse).
        pub fn build(self) -> crate::error::ContinuousDeploymentPolicyInUse {
            crate::error::ContinuousDeploymentPolicyInUse {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl ContinuousDeploymentPolicyInUse {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ContinuousDeploymentPolicyInUse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ContinuousDeploymentPolicyInUse")?;
        if let Some(inner_93) = &self.message {
            {
                write!(f, ": {}", inner_93)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ContinuousDeploymentPolicyInUse {}
impl aws_http::request_id::RequestId for crate::error::ContinuousDeploymentPolicyInUse {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ContinuousDeploymentPolicyInUse {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type UpdateContinuousDeploymentPolicyErrorKind = UpdateContinuousDeploymentPolicyError;
/// Error type for the `UpdateContinuousDeploymentPolicyError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateContinuousDeploymentPolicyError {
    /// <p>Access denied.</p>
    AccessDenied(crate::error::AccessDenied),
    /// <p>The value of <code>Quantity</code> and the size of <code>Items</code> don't match.</p>
    InconsistentQuantities(crate::error::InconsistentQuantities),
    /// <p>An argument is invalid.</p>
    InvalidArgument(crate::error::InvalidArgument),
    /// <p>The <code>If-Match</code> version is missing or not valid.</p>
    InvalidIfMatchVersion(crate::error::InvalidIfMatchVersion),
    /// <p>The continuous deployment policy doesn't exist.</p>
    NoSuchContinuousDeploymentPolicy(crate::error::NoSuchContinuousDeploymentPolicy),
    /// <p>The precondition in one or more of the request fields evaluated to <code>false</code>.</p>
    PreconditionFailed(crate::error::PreconditionFailed),
    /// <p>A continuous deployment policy for this staging distribution already exists.</p>
    StagingDistributionInUse(crate::error::StagingDistributionInUse),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for UpdateContinuousDeploymentPolicyError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for UpdateContinuousDeploymentPolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AccessDenied(_inner) => _inner.fmt(f),
            Self::InconsistentQuantities(_inner) => _inner.fmt(f),
            Self::InvalidArgument(_inner) => _inner.fmt(f),
            Self::InvalidIfMatchVersion(_inner) => _inner.fmt(f),
            Self::NoSuchContinuousDeploymentPolicy(_inner) => _inner.fmt(f),
            Self::PreconditionFailed(_inner) => _inner.fmt(f),
            Self::StagingDistributionInUse(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for UpdateContinuousDeploymentPolicyError
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AccessDenied(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InconsistentQuantities(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidArgument(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidIfMatchVersion(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NoSuchContinuousDeploymentPolicy(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::PreconditionFailed(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::StagingDistributionInUse(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::UpdateContinuousDeploymentPolicyError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateContinuousDeploymentPolicyError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateContinuousDeploymentPolicyError {
    /// Creates the `UpdateContinuousDeploymentPolicyError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `UpdateContinuousDeploymentPolicyError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AccessDenied(e) => e.meta(),
            Self::InconsistentQuantities(e) => e.meta(),
            Self::InvalidArgument(e) => e.meta(),
            Self::InvalidIfMatchVersion(e) => e.meta(),
            Self::NoSuchContinuousDeploymentPolicy(e) => e.meta(),
            Self::PreconditionFailed(e) => e.meta(),
            Self::StagingDistributionInUse(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `UpdateContinuousDeploymentPolicyError::AccessDenied`.
    pub fn is_access_denied(&self) -> bool {
        matches!(self, Self::AccessDenied(_))
    }
    /// Returns `true` if the error kind is `UpdateContinuousDeploymentPolicyError::InconsistentQuantities`.
    pub fn is_inconsistent_quantities(&self) -> bool {
        matches!(self, Self::InconsistentQuantities(_))
    }
    /// Returns `true` if the error kind is `UpdateContinuousDeploymentPolicyError::InvalidArgument`.
    pub fn is_invalid_argument(&self) -> bool {
        matches!(self, Self::InvalidArgument(_))
    }
    /// Returns `true` if the error kind is `UpdateContinuousDeploymentPolicyError::InvalidIfMatchVersion`.
    pub fn is_invalid_if_match_version(&self) -> bool {
        matches!(self, Self::InvalidIfMatchVersion(_))
    }
    /// Returns `true` if the error kind is `UpdateContinuousDeploymentPolicyError::NoSuchContinuousDeploymentPolicy`.
    pub fn is_no_such_continuous_deployment_policy(&self) -> bool {
        matches!(self, Self::NoSuchContinuousDeploymentPolicy(_))
    }
    /// Returns `true` if the error kind is `UpdateContinuousDeploymentPolicyError::PreconditionFailed`.
    pub fn is_precondition_failed(&self) -> bool {
        matches!(self, Self::PreconditionFailed(_))
    }
    /// Returns `true` if the error kind is `UpdateContinuousDeploymentPolicyError::StagingDistributionInUse`.
    pub fn is_staging_distribution_in_use(&self) -> bool {
        matches!(self, Self::StagingDistributionInUse(_))
    }
}
impl std::error::Error for UpdateContinuousDeploymentPolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AccessDenied(_inner) => Some(_inner),
            Self::InconsistentQuantities(_inner) => Some(_inner),
            Self::InvalidArgument(_inner) => Some(_inner),
            Self::InvalidIfMatchVersion(_inner) => Some(_inner),
            Self::NoSuchContinuousDeploymentPolicy(_inner) => Some(_inner),
            Self::PreconditionFailed(_inner) => Some(_inner),
            Self::StagingDistributionInUse(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type UpdateCloudFrontOriginAccessIdentityErrorKind = UpdateCloudFrontOriginAccessIdentityError;
/// Error type for the `UpdateCloudFrontOriginAccessIdentityError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateCloudFrontOriginAccessIdentityError {
    /// <p>Access denied.</p>
    AccessDenied(crate::error::AccessDenied),
    /// <p>The update contains modifications that are not allowed.</p>
    IllegalUpdate(crate::error::IllegalUpdate),
    /// <p>The value of <code>Quantity</code> and the size of <code>Items</code> don't match.</p>
    InconsistentQuantities(crate::error::InconsistentQuantities),
    /// <p>An argument is invalid.</p>
    InvalidArgument(crate::error::InvalidArgument),
    /// <p>The <code>If-Match</code> version is missing or not valid.</p>
    InvalidIfMatchVersion(crate::error::InvalidIfMatchVersion),
    /// <p>This operation requires a body. Ensure that the body is present and the <code>Content-Type</code> header is set.</p>
    MissingBody(crate::error::MissingBody),
    /// <p>The specified origin access identity does not exist.</p>
    NoSuchCloudFrontOriginAccessIdentity(crate::error::NoSuchCloudFrontOriginAccessIdentity),
    /// <p>The precondition in one or more of the request fields evaluated to <code>false</code>.</p>
    PreconditionFailed(crate::error::PreconditionFailed),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for UpdateCloudFrontOriginAccessIdentityError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for UpdateCloudFrontOriginAccessIdentityError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AccessDenied(_inner) => _inner.fmt(f),
            Self::IllegalUpdate(_inner) => _inner.fmt(f),
            Self::InconsistentQuantities(_inner) => _inner.fmt(f),
            Self::InvalidArgument(_inner) => _inner.fmt(f),
            Self::InvalidIfMatchVersion(_inner) => _inner.fmt(f),
            Self::MissingBody(_inner) => _inner.fmt(f),
            Self::NoSuchCloudFrontOriginAccessIdentity(_inner) => _inner.fmt(f),
            Self::PreconditionFailed(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for UpdateCloudFrontOriginAccessIdentityError
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AccessDenied(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::IllegalUpdate(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InconsistentQuantities(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidArgument(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidIfMatchVersion(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::MissingBody(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NoSuchCloudFrontOriginAccessIdentity(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::PreconditionFailed(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::UpdateCloudFrontOriginAccessIdentityError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateCloudFrontOriginAccessIdentityError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateCloudFrontOriginAccessIdentityError {
    /// Creates the `UpdateCloudFrontOriginAccessIdentityError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `UpdateCloudFrontOriginAccessIdentityError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AccessDenied(e) => e.meta(),
            Self::IllegalUpdate(e) => e.meta(),
            Self::InconsistentQuantities(e) => e.meta(),
            Self::InvalidArgument(e) => e.meta(),
            Self::InvalidIfMatchVersion(e) => e.meta(),
            Self::MissingBody(e) => e.meta(),
            Self::NoSuchCloudFrontOriginAccessIdentity(e) => e.meta(),
            Self::PreconditionFailed(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `UpdateCloudFrontOriginAccessIdentityError::AccessDenied`.
    pub fn is_access_denied(&self) -> bool {
        matches!(self, Self::AccessDenied(_))
    }
    /// Returns `true` if the error kind is `UpdateCloudFrontOriginAccessIdentityError::IllegalUpdate`.
    pub fn is_illegal_update(&self) -> bool {
        matches!(self, Self::IllegalUpdate(_))
    }
    /// Returns `true` if the error kind is `UpdateCloudFrontOriginAccessIdentityError::InconsistentQuantities`.
    pub fn is_inconsistent_quantities(&self) -> bool {
        matches!(self, Self::InconsistentQuantities(_))
    }
    /// Returns `true` if the error kind is `UpdateCloudFrontOriginAccessIdentityError::InvalidArgument`.
    pub fn is_invalid_argument(&self) -> bool {
        matches!(self, Self::InvalidArgument(_))
    }
    /// Returns `true` if the error kind is `UpdateCloudFrontOriginAccessIdentityError::InvalidIfMatchVersion`.
    pub fn is_invalid_if_match_version(&self) -> bool {
        matches!(self, Self::InvalidIfMatchVersion(_))
    }
    /// Returns `true` if the error kind is `UpdateCloudFrontOriginAccessIdentityError::MissingBody`.
    pub fn is_missing_body(&self) -> bool {
        matches!(self, Self::MissingBody(_))
    }
    /// Returns `true` if the error kind is `UpdateCloudFrontOriginAccessIdentityError::NoSuchCloudFrontOriginAccessIdentity`.
    pub fn is_no_such_cloud_front_origin_access_identity(&self) -> bool {
        matches!(self, Self::NoSuchCloudFrontOriginAccessIdentity(_))
    }
    /// Returns `true` if the error kind is `UpdateCloudFrontOriginAccessIdentityError::PreconditionFailed`.
    pub fn is_precondition_failed(&self) -> bool {
        matches!(self, Self::PreconditionFailed(_))
    }
}
impl std::error::Error for UpdateCloudFrontOriginAccessIdentityError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AccessDenied(_inner) => Some(_inner),
            Self::IllegalUpdate(_inner) => Some(_inner),
            Self::InconsistentQuantities(_inner) => Some(_inner),
            Self::InvalidArgument(_inner) => Some(_inner),
            Self::InvalidIfMatchVersion(_inner) => Some(_inner),
            Self::MissingBody(_inner) => Some(_inner),
            Self::NoSuchCloudFrontOriginAccessIdentity(_inner) => Some(_inner),
            Self::PreconditionFailed(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The specified origin access identity does not exist.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct NoSuchCloudFrontOriginAccessIdentity {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl NoSuchCloudFrontOriginAccessIdentity {
    /// Creates a new builder-style object to manufacture [`NoSuchCloudFrontOriginAccessIdentity`](crate::error::NoSuchCloudFrontOriginAccessIdentity).
    pub fn builder() -> crate::error::no_such_cloud_front_origin_access_identity::Builder {
        crate::error::no_such_cloud_front_origin_access_identity::Builder::default()
    }
}
/// See [`NoSuchCloudFrontOriginAccessIdentity`](crate::error::NoSuchCloudFrontOriginAccessIdentity).
pub mod no_such_cloud_front_origin_access_identity {

    /// A builder for [`NoSuchCloudFrontOriginAccessIdentity`](crate::error::NoSuchCloudFrontOriginAccessIdentity).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`NoSuchCloudFrontOriginAccessIdentity`](crate::error::NoSuchCloudFrontOriginAccessIdentity).
        pub fn build(self) -> crate::error::NoSuchCloudFrontOriginAccessIdentity {
            crate::error::NoSuchCloudFrontOriginAccessIdentity {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl NoSuchCloudFrontOriginAccessIdentity {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for NoSuchCloudFrontOriginAccessIdentity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "NoSuchCloudFrontOriginAccessIdentity")?;
        if let Some(inner_94) = &self.message {
            {
                write!(f, ": {}", inner_94)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for NoSuchCloudFrontOriginAccessIdentity {}
impl aws_http::request_id::RequestId for crate::error::NoSuchCloudFrontOriginAccessIdentity {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for NoSuchCloudFrontOriginAccessIdentity
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type UpdateCachePolicyErrorKind = UpdateCachePolicyError;
/// Error type for the `UpdateCachePolicyError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateCachePolicyError {
    /// <p>Access denied.</p>
    AccessDenied(crate::error::AccessDenied),
    /// <p>A cache policy with this name already exists. You must provide a unique name. To modify an existing cache policy, use <code>UpdateCachePolicy</code>.</p>
    CachePolicyAlreadyExists(crate::error::CachePolicyAlreadyExists),
    /// <p>The update contains modifications that are not allowed.</p>
    IllegalUpdate(crate::error::IllegalUpdate),
    /// <p>The value of <code>Quantity</code> and the size of <code>Items</code> don't match.</p>
    InconsistentQuantities(crate::error::InconsistentQuantities),
    /// <p>An argument is invalid.</p>
    InvalidArgument(crate::error::InvalidArgument),
    /// <p>The <code>If-Match</code> version is missing or not valid.</p>
    InvalidIfMatchVersion(crate::error::InvalidIfMatchVersion),
    /// <p>The cache policy does not exist.</p>
    NoSuchCachePolicy(crate::error::NoSuchCachePolicy),
    /// <p>The precondition in one or more of the request fields evaluated to <code>false</code>.</p>
    PreconditionFailed(crate::error::PreconditionFailed),
    /// <p>The number of cookies in the cache policy exceeds the maximum. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
    TooManyCookiesInCachePolicy(crate::error::TooManyCookiesInCachePolicy),
    /// <p>The number of headers in the cache policy exceeds the maximum. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
    TooManyHeadersInCachePolicy(crate::error::TooManyHeadersInCachePolicy),
    /// <p>The number of query strings in the cache policy exceeds the maximum. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
    TooManyQueryStringsInCachePolicy(crate::error::TooManyQueryStringsInCachePolicy),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for UpdateCachePolicyError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for UpdateCachePolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AccessDenied(_inner) => _inner.fmt(f),
            Self::CachePolicyAlreadyExists(_inner) => _inner.fmt(f),
            Self::IllegalUpdate(_inner) => _inner.fmt(f),
            Self::InconsistentQuantities(_inner) => _inner.fmt(f),
            Self::InvalidArgument(_inner) => _inner.fmt(f),
            Self::InvalidIfMatchVersion(_inner) => _inner.fmt(f),
            Self::NoSuchCachePolicy(_inner) => _inner.fmt(f),
            Self::PreconditionFailed(_inner) => _inner.fmt(f),
            Self::TooManyCookiesInCachePolicy(_inner) => _inner.fmt(f),
            Self::TooManyHeadersInCachePolicy(_inner) => _inner.fmt(f),
            Self::TooManyQueryStringsInCachePolicy(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for UpdateCachePolicyError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AccessDenied(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::CachePolicyAlreadyExists(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::IllegalUpdate(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InconsistentQuantities(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidArgument(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidIfMatchVersion(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NoSuchCachePolicy(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::PreconditionFailed(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyCookiesInCachePolicy(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyHeadersInCachePolicy(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyQueryStringsInCachePolicy(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::UpdateCachePolicyError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateCachePolicyError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateCachePolicyError {
    /// Creates the `UpdateCachePolicyError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `UpdateCachePolicyError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AccessDenied(e) => e.meta(),
            Self::CachePolicyAlreadyExists(e) => e.meta(),
            Self::IllegalUpdate(e) => e.meta(),
            Self::InconsistentQuantities(e) => e.meta(),
            Self::InvalidArgument(e) => e.meta(),
            Self::InvalidIfMatchVersion(e) => e.meta(),
            Self::NoSuchCachePolicy(e) => e.meta(),
            Self::PreconditionFailed(e) => e.meta(),
            Self::TooManyCookiesInCachePolicy(e) => e.meta(),
            Self::TooManyHeadersInCachePolicy(e) => e.meta(),
            Self::TooManyQueryStringsInCachePolicy(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `UpdateCachePolicyError::AccessDenied`.
    pub fn is_access_denied(&self) -> bool {
        matches!(self, Self::AccessDenied(_))
    }
    /// Returns `true` if the error kind is `UpdateCachePolicyError::CachePolicyAlreadyExists`.
    pub fn is_cache_policy_already_exists(&self) -> bool {
        matches!(self, Self::CachePolicyAlreadyExists(_))
    }
    /// Returns `true` if the error kind is `UpdateCachePolicyError::IllegalUpdate`.
    pub fn is_illegal_update(&self) -> bool {
        matches!(self, Self::IllegalUpdate(_))
    }
    /// Returns `true` if the error kind is `UpdateCachePolicyError::InconsistentQuantities`.
    pub fn is_inconsistent_quantities(&self) -> bool {
        matches!(self, Self::InconsistentQuantities(_))
    }
    /// Returns `true` if the error kind is `UpdateCachePolicyError::InvalidArgument`.
    pub fn is_invalid_argument(&self) -> bool {
        matches!(self, Self::InvalidArgument(_))
    }
    /// Returns `true` if the error kind is `UpdateCachePolicyError::InvalidIfMatchVersion`.
    pub fn is_invalid_if_match_version(&self) -> bool {
        matches!(self, Self::InvalidIfMatchVersion(_))
    }
    /// Returns `true` if the error kind is `UpdateCachePolicyError::NoSuchCachePolicy`.
    pub fn is_no_such_cache_policy(&self) -> bool {
        matches!(self, Self::NoSuchCachePolicy(_))
    }
    /// Returns `true` if the error kind is `UpdateCachePolicyError::PreconditionFailed`.
    pub fn is_precondition_failed(&self) -> bool {
        matches!(self, Self::PreconditionFailed(_))
    }
    /// Returns `true` if the error kind is `UpdateCachePolicyError::TooManyCookiesInCachePolicy`.
    pub fn is_too_many_cookies_in_cache_policy(&self) -> bool {
        matches!(self, Self::TooManyCookiesInCachePolicy(_))
    }
    /// Returns `true` if the error kind is `UpdateCachePolicyError::TooManyHeadersInCachePolicy`.
    pub fn is_too_many_headers_in_cache_policy(&self) -> bool {
        matches!(self, Self::TooManyHeadersInCachePolicy(_))
    }
    /// Returns `true` if the error kind is `UpdateCachePolicyError::TooManyQueryStringsInCachePolicy`.
    pub fn is_too_many_query_strings_in_cache_policy(&self) -> bool {
        matches!(self, Self::TooManyQueryStringsInCachePolicy(_))
    }
}
impl std::error::Error for UpdateCachePolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AccessDenied(_inner) => Some(_inner),
            Self::CachePolicyAlreadyExists(_inner) => Some(_inner),
            Self::IllegalUpdate(_inner) => Some(_inner),
            Self::InconsistentQuantities(_inner) => Some(_inner),
            Self::InvalidArgument(_inner) => Some(_inner),
            Self::InvalidIfMatchVersion(_inner) => Some(_inner),
            Self::NoSuchCachePolicy(_inner) => Some(_inner),
            Self::PreconditionFailed(_inner) => Some(_inner),
            Self::TooManyCookiesInCachePolicy(_inner) => Some(_inner),
            Self::TooManyHeadersInCachePolicy(_inner) => Some(_inner),
            Self::TooManyQueryStringsInCachePolicy(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The number of query strings in the cache policy exceeds the maximum. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TooManyQueryStringsInCachePolicy {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl TooManyQueryStringsInCachePolicy {
    /// Creates a new builder-style object to manufacture [`TooManyQueryStringsInCachePolicy`](crate::error::TooManyQueryStringsInCachePolicy).
    pub fn builder() -> crate::error::too_many_query_strings_in_cache_policy::Builder {
        crate::error::too_many_query_strings_in_cache_policy::Builder::default()
    }
}
/// See [`TooManyQueryStringsInCachePolicy`](crate::error::TooManyQueryStringsInCachePolicy).
pub mod too_many_query_strings_in_cache_policy {

    /// A builder for [`TooManyQueryStringsInCachePolicy`](crate::error::TooManyQueryStringsInCachePolicy).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`TooManyQueryStringsInCachePolicy`](crate::error::TooManyQueryStringsInCachePolicy).
        pub fn build(self) -> crate::error::TooManyQueryStringsInCachePolicy {
            crate::error::TooManyQueryStringsInCachePolicy {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl TooManyQueryStringsInCachePolicy {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TooManyQueryStringsInCachePolicy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TooManyQueryStringsInCachePolicy")?;
        if let Some(inner_95) = &self.message {
            {
                write!(f, ": {}", inner_95)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for TooManyQueryStringsInCachePolicy {}
impl aws_http::request_id::RequestId for crate::error::TooManyQueryStringsInCachePolicy {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for TooManyQueryStringsInCachePolicy {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The number of headers in the cache policy exceeds the maximum. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TooManyHeadersInCachePolicy {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl TooManyHeadersInCachePolicy {
    /// Creates a new builder-style object to manufacture [`TooManyHeadersInCachePolicy`](crate::error::TooManyHeadersInCachePolicy).
    pub fn builder() -> crate::error::too_many_headers_in_cache_policy::Builder {
        crate::error::too_many_headers_in_cache_policy::Builder::default()
    }
}
/// See [`TooManyHeadersInCachePolicy`](crate::error::TooManyHeadersInCachePolicy).
pub mod too_many_headers_in_cache_policy {

    /// A builder for [`TooManyHeadersInCachePolicy`](crate::error::TooManyHeadersInCachePolicy).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`TooManyHeadersInCachePolicy`](crate::error::TooManyHeadersInCachePolicy).
        pub fn build(self) -> crate::error::TooManyHeadersInCachePolicy {
            crate::error::TooManyHeadersInCachePolicy {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl TooManyHeadersInCachePolicy {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TooManyHeadersInCachePolicy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TooManyHeadersInCachePolicy")?;
        if let Some(inner_96) = &self.message {
            {
                write!(f, ": {}", inner_96)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for TooManyHeadersInCachePolicy {}
impl aws_http::request_id::RequestId for crate::error::TooManyHeadersInCachePolicy {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for TooManyHeadersInCachePolicy {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The number of cookies in the cache policy exceeds the maximum. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TooManyCookiesInCachePolicy {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl TooManyCookiesInCachePolicy {
    /// Creates a new builder-style object to manufacture [`TooManyCookiesInCachePolicy`](crate::error::TooManyCookiesInCachePolicy).
    pub fn builder() -> crate::error::too_many_cookies_in_cache_policy::Builder {
        crate::error::too_many_cookies_in_cache_policy::Builder::default()
    }
}
/// See [`TooManyCookiesInCachePolicy`](crate::error::TooManyCookiesInCachePolicy).
pub mod too_many_cookies_in_cache_policy {

    /// A builder for [`TooManyCookiesInCachePolicy`](crate::error::TooManyCookiesInCachePolicy).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`TooManyCookiesInCachePolicy`](crate::error::TooManyCookiesInCachePolicy).
        pub fn build(self) -> crate::error::TooManyCookiesInCachePolicy {
            crate::error::TooManyCookiesInCachePolicy {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl TooManyCookiesInCachePolicy {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TooManyCookiesInCachePolicy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TooManyCookiesInCachePolicy")?;
        if let Some(inner_97) = &self.message {
            {
                write!(f, ": {}", inner_97)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for TooManyCookiesInCachePolicy {}
impl aws_http::request_id::RequestId for crate::error::TooManyCookiesInCachePolicy {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for TooManyCookiesInCachePolicy {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>A cache policy with this name already exists. You must provide a unique name. To modify an existing cache policy, use <code>UpdateCachePolicy</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CachePolicyAlreadyExists {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl CachePolicyAlreadyExists {
    /// Creates a new builder-style object to manufacture [`CachePolicyAlreadyExists`](crate::error::CachePolicyAlreadyExists).
    pub fn builder() -> crate::error::cache_policy_already_exists::Builder {
        crate::error::cache_policy_already_exists::Builder::default()
    }
}
/// See [`CachePolicyAlreadyExists`](crate::error::CachePolicyAlreadyExists).
pub mod cache_policy_already_exists {

    /// A builder for [`CachePolicyAlreadyExists`](crate::error::CachePolicyAlreadyExists).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`CachePolicyAlreadyExists`](crate::error::CachePolicyAlreadyExists).
        pub fn build(self) -> crate::error::CachePolicyAlreadyExists {
            crate::error::CachePolicyAlreadyExists {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl CachePolicyAlreadyExists {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CachePolicyAlreadyExists {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CachePolicyAlreadyExists")?;
        if let Some(inner_98) = &self.message {
            {
                write!(f, ": {}", inner_98)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for CachePolicyAlreadyExists {}
impl aws_http::request_id::RequestId for crate::error::CachePolicyAlreadyExists {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CachePolicyAlreadyExists {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type UntagResourceErrorKind = UntagResourceError;
/// Error type for the `UntagResourceError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UntagResourceError {
    /// <p>Access denied.</p>
    AccessDenied(crate::error::AccessDenied),
    /// <p>An argument is invalid.</p>
    InvalidArgument(crate::error::InvalidArgument),
    /// <p>The tagging specified is not valid.</p>
    InvalidTagging(crate::error::InvalidTagging),
    /// <p>A resource that was specified is not valid.</p>
    NoSuchResource(crate::error::NoSuchResource),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for UntagResourceError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for UntagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AccessDenied(_inner) => _inner.fmt(f),
            Self::InvalidArgument(_inner) => _inner.fmt(f),
            Self::InvalidTagging(_inner) => _inner.fmt(f),
            Self::NoSuchResource(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for UntagResourceError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AccessDenied(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidArgument(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidTagging(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NoSuchResource(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::UntagResourceError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UntagResourceError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UntagResourceError {
    /// Creates the `UntagResourceError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `UntagResourceError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AccessDenied(e) => e.meta(),
            Self::InvalidArgument(e) => e.meta(),
            Self::InvalidTagging(e) => e.meta(),
            Self::NoSuchResource(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `UntagResourceError::AccessDenied`.
    pub fn is_access_denied(&self) -> bool {
        matches!(self, Self::AccessDenied(_))
    }
    /// Returns `true` if the error kind is `UntagResourceError::InvalidArgument`.
    pub fn is_invalid_argument(&self) -> bool {
        matches!(self, Self::InvalidArgument(_))
    }
    /// Returns `true` if the error kind is `UntagResourceError::InvalidTagging`.
    pub fn is_invalid_tagging(&self) -> bool {
        matches!(self, Self::InvalidTagging(_))
    }
    /// Returns `true` if the error kind is `UntagResourceError::NoSuchResource`.
    pub fn is_no_such_resource(&self) -> bool {
        matches!(self, Self::NoSuchResource(_))
    }
}
impl std::error::Error for UntagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AccessDenied(_inner) => Some(_inner),
            Self::InvalidArgument(_inner) => Some(_inner),
            Self::InvalidTagging(_inner) => Some(_inner),
            Self::NoSuchResource(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The tagging specified is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidTagging {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidTagging {
    /// Creates a new builder-style object to manufacture [`InvalidTagging`](crate::error::InvalidTagging).
    pub fn builder() -> crate::error::invalid_tagging::Builder {
        crate::error::invalid_tagging::Builder::default()
    }
}
/// See [`InvalidTagging`](crate::error::InvalidTagging).
pub mod invalid_tagging {

    /// A builder for [`InvalidTagging`](crate::error::InvalidTagging).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidTagging`](crate::error::InvalidTagging).
        pub fn build(self) -> crate::error::InvalidTagging {
            crate::error::InvalidTagging {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl InvalidTagging {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidTagging {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidTagging")?;
        if let Some(inner_99) = &self.message {
            {
                write!(f, ": {}", inner_99)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidTagging {}
impl aws_http::request_id::RequestId for crate::error::InvalidTagging {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidTagging {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type TestFunctionErrorKind = TestFunctionError;
/// Error type for the `TestFunctionError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum TestFunctionError {
    /// <p>An argument is invalid.</p>
    InvalidArgument(crate::error::InvalidArgument),
    /// <p>The <code>If-Match</code> version is missing or not valid.</p>
    InvalidIfMatchVersion(crate::error::InvalidIfMatchVersion),
    /// <p>The function does not exist.</p>
    NoSuchFunctionExists(crate::error::NoSuchFunctionExists),
    /// <p>The CloudFront function failed.</p>
    TestFunctionFailed(crate::error::TestFunctionFailed),
    /// <p>This operation is not supported in this region.</p>
    UnsupportedOperation(crate::error::UnsupportedOperation),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for TestFunctionError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for TestFunctionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::InvalidArgument(_inner) => _inner.fmt(f),
            Self::InvalidIfMatchVersion(_inner) => _inner.fmt(f),
            Self::NoSuchFunctionExists(_inner) => _inner.fmt(f),
            Self::TestFunctionFailed(_inner) => _inner.fmt(f),
            Self::UnsupportedOperation(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for TestFunctionError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::InvalidArgument(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidIfMatchVersion(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NoSuchFunctionExists(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TestFunctionFailed(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnsupportedOperation(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::TestFunctionError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for TestFunctionError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl TestFunctionError {
    /// Creates the `TestFunctionError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `TestFunctionError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::InvalidArgument(e) => e.meta(),
            Self::InvalidIfMatchVersion(e) => e.meta(),
            Self::NoSuchFunctionExists(e) => e.meta(),
            Self::TestFunctionFailed(e) => e.meta(),
            Self::UnsupportedOperation(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `TestFunctionError::InvalidArgument`.
    pub fn is_invalid_argument(&self) -> bool {
        matches!(self, Self::InvalidArgument(_))
    }
    /// Returns `true` if the error kind is `TestFunctionError::InvalidIfMatchVersion`.
    pub fn is_invalid_if_match_version(&self) -> bool {
        matches!(self, Self::InvalidIfMatchVersion(_))
    }
    /// Returns `true` if the error kind is `TestFunctionError::NoSuchFunctionExists`.
    pub fn is_no_such_function_exists(&self) -> bool {
        matches!(self, Self::NoSuchFunctionExists(_))
    }
    /// Returns `true` if the error kind is `TestFunctionError::TestFunctionFailed`.
    pub fn is_test_function_failed(&self) -> bool {
        matches!(self, Self::TestFunctionFailed(_))
    }
    /// Returns `true` if the error kind is `TestFunctionError::UnsupportedOperation`.
    pub fn is_unsupported_operation(&self) -> bool {
        matches!(self, Self::UnsupportedOperation(_))
    }
}
impl std::error::Error for TestFunctionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::InvalidArgument(_inner) => Some(_inner),
            Self::InvalidIfMatchVersion(_inner) => Some(_inner),
            Self::NoSuchFunctionExists(_inner) => Some(_inner),
            Self::TestFunctionFailed(_inner) => Some(_inner),
            Self::UnsupportedOperation(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The CloudFront function failed.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TestFunctionFailed {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl TestFunctionFailed {
    /// Creates a new builder-style object to manufacture [`TestFunctionFailed`](crate::error::TestFunctionFailed).
    pub fn builder() -> crate::error::test_function_failed::Builder {
        crate::error::test_function_failed::Builder::default()
    }
}
/// See [`TestFunctionFailed`](crate::error::TestFunctionFailed).
pub mod test_function_failed {

    /// A builder for [`TestFunctionFailed`](crate::error::TestFunctionFailed).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`TestFunctionFailed`](crate::error::TestFunctionFailed).
        pub fn build(self) -> crate::error::TestFunctionFailed {
            crate::error::TestFunctionFailed {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl TestFunctionFailed {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TestFunctionFailed {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TestFunctionFailed")?;
        if let Some(inner_100) = &self.message {
            {
                write!(f, ": {}", inner_100)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for TestFunctionFailed {}
impl aws_http::request_id::RequestId for crate::error::TestFunctionFailed {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for TestFunctionFailed {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type TagResourceErrorKind = TagResourceError;
/// Error type for the `TagResourceError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum TagResourceError {
    /// <p>Access denied.</p>
    AccessDenied(crate::error::AccessDenied),
    /// <p>An argument is invalid.</p>
    InvalidArgument(crate::error::InvalidArgument),
    /// <p>The tagging specified is not valid.</p>
    InvalidTagging(crate::error::InvalidTagging),
    /// <p>A resource that was specified is not valid.</p>
    NoSuchResource(crate::error::NoSuchResource),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for TagResourceError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for TagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AccessDenied(_inner) => _inner.fmt(f),
            Self::InvalidArgument(_inner) => _inner.fmt(f),
            Self::InvalidTagging(_inner) => _inner.fmt(f),
            Self::NoSuchResource(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for TagResourceError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AccessDenied(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidArgument(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidTagging(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NoSuchResource(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::TagResourceError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for TagResourceError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl TagResourceError {
    /// Creates the `TagResourceError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `TagResourceError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AccessDenied(e) => e.meta(),
            Self::InvalidArgument(e) => e.meta(),
            Self::InvalidTagging(e) => e.meta(),
            Self::NoSuchResource(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `TagResourceError::AccessDenied`.
    pub fn is_access_denied(&self) -> bool {
        matches!(self, Self::AccessDenied(_))
    }
    /// Returns `true` if the error kind is `TagResourceError::InvalidArgument`.
    pub fn is_invalid_argument(&self) -> bool {
        matches!(self, Self::InvalidArgument(_))
    }
    /// Returns `true` if the error kind is `TagResourceError::InvalidTagging`.
    pub fn is_invalid_tagging(&self) -> bool {
        matches!(self, Self::InvalidTagging(_))
    }
    /// Returns `true` if the error kind is `TagResourceError::NoSuchResource`.
    pub fn is_no_such_resource(&self) -> bool {
        matches!(self, Self::NoSuchResource(_))
    }
}
impl std::error::Error for TagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AccessDenied(_inner) => Some(_inner),
            Self::InvalidArgument(_inner) => Some(_inner),
            Self::InvalidTagging(_inner) => Some(_inner),
            Self::NoSuchResource(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type PublishFunctionErrorKind = PublishFunctionError;
/// Error type for the `PublishFunctionError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PublishFunctionError {
    /// <p>An argument is invalid.</p>
    InvalidArgument(crate::error::InvalidArgument),
    /// <p>The <code>If-Match</code> version is missing or not valid.</p>
    InvalidIfMatchVersion(crate::error::InvalidIfMatchVersion),
    /// <p>The function does not exist.</p>
    NoSuchFunctionExists(crate::error::NoSuchFunctionExists),
    /// <p>The precondition in one or more of the request fields evaluated to <code>false</code>.</p>
    PreconditionFailed(crate::error::PreconditionFailed),
    /// <p>This operation is not supported in this region.</p>
    UnsupportedOperation(crate::error::UnsupportedOperation),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for PublishFunctionError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for PublishFunctionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::InvalidArgument(_inner) => _inner.fmt(f),
            Self::InvalidIfMatchVersion(_inner) => _inner.fmt(f),
            Self::NoSuchFunctionExists(_inner) => _inner.fmt(f),
            Self::PreconditionFailed(_inner) => _inner.fmt(f),
            Self::UnsupportedOperation(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for PublishFunctionError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::InvalidArgument(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidIfMatchVersion(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NoSuchFunctionExists(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::PreconditionFailed(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnsupportedOperation(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::PublishFunctionError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for PublishFunctionError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl PublishFunctionError {
    /// Creates the `PublishFunctionError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `PublishFunctionError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::InvalidArgument(e) => e.meta(),
            Self::InvalidIfMatchVersion(e) => e.meta(),
            Self::NoSuchFunctionExists(e) => e.meta(),
            Self::PreconditionFailed(e) => e.meta(),
            Self::UnsupportedOperation(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `PublishFunctionError::InvalidArgument`.
    pub fn is_invalid_argument(&self) -> bool {
        matches!(self, Self::InvalidArgument(_))
    }
    /// Returns `true` if the error kind is `PublishFunctionError::InvalidIfMatchVersion`.
    pub fn is_invalid_if_match_version(&self) -> bool {
        matches!(self, Self::InvalidIfMatchVersion(_))
    }
    /// Returns `true` if the error kind is `PublishFunctionError::NoSuchFunctionExists`.
    pub fn is_no_such_function_exists(&self) -> bool {
        matches!(self, Self::NoSuchFunctionExists(_))
    }
    /// Returns `true` if the error kind is `PublishFunctionError::PreconditionFailed`.
    pub fn is_precondition_failed(&self) -> bool {
        matches!(self, Self::PreconditionFailed(_))
    }
    /// Returns `true` if the error kind is `PublishFunctionError::UnsupportedOperation`.
    pub fn is_unsupported_operation(&self) -> bool {
        matches!(self, Self::UnsupportedOperation(_))
    }
}
impl std::error::Error for PublishFunctionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::InvalidArgument(_inner) => Some(_inner),
            Self::InvalidIfMatchVersion(_inner) => Some(_inner),
            Self::NoSuchFunctionExists(_inner) => Some(_inner),
            Self::PreconditionFailed(_inner) => Some(_inner),
            Self::UnsupportedOperation(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type ListTagsForResourceErrorKind = ListTagsForResourceError;
/// Error type for the `ListTagsForResourceError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListTagsForResourceError {
    /// <p>Access denied.</p>
    AccessDenied(crate::error::AccessDenied),
    /// <p>An argument is invalid.</p>
    InvalidArgument(crate::error::InvalidArgument),
    /// <p>The tagging specified is not valid.</p>
    InvalidTagging(crate::error::InvalidTagging),
    /// <p>A resource that was specified is not valid.</p>
    NoSuchResource(crate::error::NoSuchResource),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for ListTagsForResourceError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for ListTagsForResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AccessDenied(_inner) => _inner.fmt(f),
            Self::InvalidArgument(_inner) => _inner.fmt(f),
            Self::InvalidTagging(_inner) => _inner.fmt(f),
            Self::NoSuchResource(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ListTagsForResourceError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AccessDenied(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidArgument(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidTagging(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NoSuchResource(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::ListTagsForResourceError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListTagsForResourceError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListTagsForResourceError {
    /// Creates the `ListTagsForResourceError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `ListTagsForResourceError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AccessDenied(e) => e.meta(),
            Self::InvalidArgument(e) => e.meta(),
            Self::InvalidTagging(e) => e.meta(),
            Self::NoSuchResource(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ListTagsForResourceError::AccessDenied`.
    pub fn is_access_denied(&self) -> bool {
        matches!(self, Self::AccessDenied(_))
    }
    /// Returns `true` if the error kind is `ListTagsForResourceError::InvalidArgument`.
    pub fn is_invalid_argument(&self) -> bool {
        matches!(self, Self::InvalidArgument(_))
    }
    /// Returns `true` if the error kind is `ListTagsForResourceError::InvalidTagging`.
    pub fn is_invalid_tagging(&self) -> bool {
        matches!(self, Self::InvalidTagging(_))
    }
    /// Returns `true` if the error kind is `ListTagsForResourceError::NoSuchResource`.
    pub fn is_no_such_resource(&self) -> bool {
        matches!(self, Self::NoSuchResource(_))
    }
}
impl std::error::Error for ListTagsForResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AccessDenied(_inner) => Some(_inner),
            Self::InvalidArgument(_inner) => Some(_inner),
            Self::InvalidTagging(_inner) => Some(_inner),
            Self::NoSuchResource(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type ListStreamingDistributionsErrorKind = ListStreamingDistributionsError;
/// Error type for the `ListStreamingDistributionsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListStreamingDistributionsError {
    /// <p>An argument is invalid.</p>
    InvalidArgument(crate::error::InvalidArgument),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for ListStreamingDistributionsError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for ListStreamingDistributionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::InvalidArgument(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ListStreamingDistributionsError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::InvalidArgument(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::ListStreamingDistributionsError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListStreamingDistributionsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListStreamingDistributionsError {
    /// Creates the `ListStreamingDistributionsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `ListStreamingDistributionsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::InvalidArgument(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ListStreamingDistributionsError::InvalidArgument`.
    pub fn is_invalid_argument(&self) -> bool {
        matches!(self, Self::InvalidArgument(_))
    }
}
impl std::error::Error for ListStreamingDistributionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::InvalidArgument(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type ListResponseHeadersPoliciesErrorKind = ListResponseHeadersPoliciesError;
/// Error type for the `ListResponseHeadersPoliciesError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListResponseHeadersPoliciesError {
    /// <p>Access denied.</p>
    AccessDenied(crate::error::AccessDenied),
    /// <p>An argument is invalid.</p>
    InvalidArgument(crate::error::InvalidArgument),
    /// <p>The response headers policy does not exist.</p>
    NoSuchResponseHeadersPolicy(crate::error::NoSuchResponseHeadersPolicy),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for ListResponseHeadersPoliciesError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for ListResponseHeadersPoliciesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AccessDenied(_inner) => _inner.fmt(f),
            Self::InvalidArgument(_inner) => _inner.fmt(f),
            Self::NoSuchResponseHeadersPolicy(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ListResponseHeadersPoliciesError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AccessDenied(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidArgument(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NoSuchResponseHeadersPolicy(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::ListResponseHeadersPoliciesError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListResponseHeadersPoliciesError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListResponseHeadersPoliciesError {
    /// Creates the `ListResponseHeadersPoliciesError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `ListResponseHeadersPoliciesError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AccessDenied(e) => e.meta(),
            Self::InvalidArgument(e) => e.meta(),
            Self::NoSuchResponseHeadersPolicy(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ListResponseHeadersPoliciesError::AccessDenied`.
    pub fn is_access_denied(&self) -> bool {
        matches!(self, Self::AccessDenied(_))
    }
    /// Returns `true` if the error kind is `ListResponseHeadersPoliciesError::InvalidArgument`.
    pub fn is_invalid_argument(&self) -> bool {
        matches!(self, Self::InvalidArgument(_))
    }
    /// Returns `true` if the error kind is `ListResponseHeadersPoliciesError::NoSuchResponseHeadersPolicy`.
    pub fn is_no_such_response_headers_policy(&self) -> bool {
        matches!(self, Self::NoSuchResponseHeadersPolicy(_))
    }
}
impl std::error::Error for ListResponseHeadersPoliciesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AccessDenied(_inner) => Some(_inner),
            Self::InvalidArgument(_inner) => Some(_inner),
            Self::NoSuchResponseHeadersPolicy(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type ListRealtimeLogConfigsErrorKind = ListRealtimeLogConfigsError;
/// Error type for the `ListRealtimeLogConfigsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListRealtimeLogConfigsError {
    /// <p>Access denied.</p>
    AccessDenied(crate::error::AccessDenied),
    /// <p>An argument is invalid.</p>
    InvalidArgument(crate::error::InvalidArgument),
    /// <p>The real-time log configuration does not exist.</p>
    NoSuchRealtimeLogConfig(crate::error::NoSuchRealtimeLogConfig),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for ListRealtimeLogConfigsError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for ListRealtimeLogConfigsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AccessDenied(_inner) => _inner.fmt(f),
            Self::InvalidArgument(_inner) => _inner.fmt(f),
            Self::NoSuchRealtimeLogConfig(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ListRealtimeLogConfigsError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AccessDenied(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidArgument(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NoSuchRealtimeLogConfig(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::ListRealtimeLogConfigsError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListRealtimeLogConfigsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListRealtimeLogConfigsError {
    /// Creates the `ListRealtimeLogConfigsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `ListRealtimeLogConfigsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AccessDenied(e) => e.meta(),
            Self::InvalidArgument(e) => e.meta(),
            Self::NoSuchRealtimeLogConfig(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ListRealtimeLogConfigsError::AccessDenied`.
    pub fn is_access_denied(&self) -> bool {
        matches!(self, Self::AccessDenied(_))
    }
    /// Returns `true` if the error kind is `ListRealtimeLogConfigsError::InvalidArgument`.
    pub fn is_invalid_argument(&self) -> bool {
        matches!(self, Self::InvalidArgument(_))
    }
    /// Returns `true` if the error kind is `ListRealtimeLogConfigsError::NoSuchRealtimeLogConfig`.
    pub fn is_no_such_realtime_log_config(&self) -> bool {
        matches!(self, Self::NoSuchRealtimeLogConfig(_))
    }
}
impl std::error::Error for ListRealtimeLogConfigsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AccessDenied(_inner) => Some(_inner),
            Self::InvalidArgument(_inner) => Some(_inner),
            Self::NoSuchRealtimeLogConfig(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type ListPublicKeysErrorKind = ListPublicKeysError;
/// Error type for the `ListPublicKeysError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListPublicKeysError {
    /// <p>An argument is invalid.</p>
    InvalidArgument(crate::error::InvalidArgument),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for ListPublicKeysError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for ListPublicKeysError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::InvalidArgument(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ListPublicKeysError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::InvalidArgument(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::ListPublicKeysError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListPublicKeysError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListPublicKeysError {
    /// Creates the `ListPublicKeysError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `ListPublicKeysError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::InvalidArgument(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ListPublicKeysError::InvalidArgument`.
    pub fn is_invalid_argument(&self) -> bool {
        matches!(self, Self::InvalidArgument(_))
    }
}
impl std::error::Error for ListPublicKeysError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::InvalidArgument(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type ListOriginRequestPoliciesErrorKind = ListOriginRequestPoliciesError;
/// Error type for the `ListOriginRequestPoliciesError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListOriginRequestPoliciesError {
    /// <p>Access denied.</p>
    AccessDenied(crate::error::AccessDenied),
    /// <p>An argument is invalid.</p>
    InvalidArgument(crate::error::InvalidArgument),
    /// <p>The origin request policy does not exist.</p>
    NoSuchOriginRequestPolicy(crate::error::NoSuchOriginRequestPolicy),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for ListOriginRequestPoliciesError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for ListOriginRequestPoliciesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AccessDenied(_inner) => _inner.fmt(f),
            Self::InvalidArgument(_inner) => _inner.fmt(f),
            Self::NoSuchOriginRequestPolicy(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ListOriginRequestPoliciesError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AccessDenied(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidArgument(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NoSuchOriginRequestPolicy(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::ListOriginRequestPoliciesError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListOriginRequestPoliciesError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListOriginRequestPoliciesError {
    /// Creates the `ListOriginRequestPoliciesError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `ListOriginRequestPoliciesError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AccessDenied(e) => e.meta(),
            Self::InvalidArgument(e) => e.meta(),
            Self::NoSuchOriginRequestPolicy(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ListOriginRequestPoliciesError::AccessDenied`.
    pub fn is_access_denied(&self) -> bool {
        matches!(self, Self::AccessDenied(_))
    }
    /// Returns `true` if the error kind is `ListOriginRequestPoliciesError::InvalidArgument`.
    pub fn is_invalid_argument(&self) -> bool {
        matches!(self, Self::InvalidArgument(_))
    }
    /// Returns `true` if the error kind is `ListOriginRequestPoliciesError::NoSuchOriginRequestPolicy`.
    pub fn is_no_such_origin_request_policy(&self) -> bool {
        matches!(self, Self::NoSuchOriginRequestPolicy(_))
    }
}
impl std::error::Error for ListOriginRequestPoliciesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AccessDenied(_inner) => Some(_inner),
            Self::InvalidArgument(_inner) => Some(_inner),
            Self::NoSuchOriginRequestPolicy(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type ListOriginAccessControlsErrorKind = ListOriginAccessControlsError;
/// Error type for the `ListOriginAccessControlsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListOriginAccessControlsError {
    /// <p>An argument is invalid.</p>
    InvalidArgument(crate::error::InvalidArgument),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for ListOriginAccessControlsError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for ListOriginAccessControlsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::InvalidArgument(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ListOriginAccessControlsError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::InvalidArgument(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::ListOriginAccessControlsError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListOriginAccessControlsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListOriginAccessControlsError {
    /// Creates the `ListOriginAccessControlsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `ListOriginAccessControlsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::InvalidArgument(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ListOriginAccessControlsError::InvalidArgument`.
    pub fn is_invalid_argument(&self) -> bool {
        matches!(self, Self::InvalidArgument(_))
    }
}
impl std::error::Error for ListOriginAccessControlsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::InvalidArgument(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type ListKeyGroupsErrorKind = ListKeyGroupsError;
/// Error type for the `ListKeyGroupsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListKeyGroupsError {
    /// <p>An argument is invalid.</p>
    InvalidArgument(crate::error::InvalidArgument),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for ListKeyGroupsError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for ListKeyGroupsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::InvalidArgument(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ListKeyGroupsError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::InvalidArgument(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::ListKeyGroupsError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListKeyGroupsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListKeyGroupsError {
    /// Creates the `ListKeyGroupsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `ListKeyGroupsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::InvalidArgument(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ListKeyGroupsError::InvalidArgument`.
    pub fn is_invalid_argument(&self) -> bool {
        matches!(self, Self::InvalidArgument(_))
    }
}
impl std::error::Error for ListKeyGroupsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::InvalidArgument(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type ListInvalidationsErrorKind = ListInvalidationsError;
/// Error type for the `ListInvalidationsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListInvalidationsError {
    /// <p>Access denied.</p>
    AccessDenied(crate::error::AccessDenied),
    /// <p>An argument is invalid.</p>
    InvalidArgument(crate::error::InvalidArgument),
    /// <p>The specified distribution does not exist.</p>
    NoSuchDistribution(crate::error::NoSuchDistribution),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for ListInvalidationsError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for ListInvalidationsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AccessDenied(_inner) => _inner.fmt(f),
            Self::InvalidArgument(_inner) => _inner.fmt(f),
            Self::NoSuchDistribution(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ListInvalidationsError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AccessDenied(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidArgument(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NoSuchDistribution(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::ListInvalidationsError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListInvalidationsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListInvalidationsError {
    /// Creates the `ListInvalidationsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `ListInvalidationsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AccessDenied(e) => e.meta(),
            Self::InvalidArgument(e) => e.meta(),
            Self::NoSuchDistribution(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ListInvalidationsError::AccessDenied`.
    pub fn is_access_denied(&self) -> bool {
        matches!(self, Self::AccessDenied(_))
    }
    /// Returns `true` if the error kind is `ListInvalidationsError::InvalidArgument`.
    pub fn is_invalid_argument(&self) -> bool {
        matches!(self, Self::InvalidArgument(_))
    }
    /// Returns `true` if the error kind is `ListInvalidationsError::NoSuchDistribution`.
    pub fn is_no_such_distribution(&self) -> bool {
        matches!(self, Self::NoSuchDistribution(_))
    }
}
impl std::error::Error for ListInvalidationsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AccessDenied(_inner) => Some(_inner),
            Self::InvalidArgument(_inner) => Some(_inner),
            Self::NoSuchDistribution(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type ListFunctionsErrorKind = ListFunctionsError;
/// Error type for the `ListFunctionsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListFunctionsError {
    /// <p>An argument is invalid.</p>
    InvalidArgument(crate::error::InvalidArgument),
    /// <p>This operation is not supported in this region.</p>
    UnsupportedOperation(crate::error::UnsupportedOperation),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for ListFunctionsError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for ListFunctionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::InvalidArgument(_inner) => _inner.fmt(f),
            Self::UnsupportedOperation(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ListFunctionsError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::InvalidArgument(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnsupportedOperation(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::ListFunctionsError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListFunctionsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListFunctionsError {
    /// Creates the `ListFunctionsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `ListFunctionsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::InvalidArgument(e) => e.meta(),
            Self::UnsupportedOperation(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ListFunctionsError::InvalidArgument`.
    pub fn is_invalid_argument(&self) -> bool {
        matches!(self, Self::InvalidArgument(_))
    }
    /// Returns `true` if the error kind is `ListFunctionsError::UnsupportedOperation`.
    pub fn is_unsupported_operation(&self) -> bool {
        matches!(self, Self::UnsupportedOperation(_))
    }
}
impl std::error::Error for ListFunctionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::InvalidArgument(_inner) => Some(_inner),
            Self::UnsupportedOperation(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type ListFieldLevelEncryptionProfilesErrorKind = ListFieldLevelEncryptionProfilesError;
/// Error type for the `ListFieldLevelEncryptionProfilesError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListFieldLevelEncryptionProfilesError {
    /// <p>An argument is invalid.</p>
    InvalidArgument(crate::error::InvalidArgument),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for ListFieldLevelEncryptionProfilesError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for ListFieldLevelEncryptionProfilesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::InvalidArgument(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for ListFieldLevelEncryptionProfilesError
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::InvalidArgument(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::ListFieldLevelEncryptionProfilesError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListFieldLevelEncryptionProfilesError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListFieldLevelEncryptionProfilesError {
    /// Creates the `ListFieldLevelEncryptionProfilesError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `ListFieldLevelEncryptionProfilesError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::InvalidArgument(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ListFieldLevelEncryptionProfilesError::InvalidArgument`.
    pub fn is_invalid_argument(&self) -> bool {
        matches!(self, Self::InvalidArgument(_))
    }
}
impl std::error::Error for ListFieldLevelEncryptionProfilesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::InvalidArgument(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type ListFieldLevelEncryptionConfigsErrorKind = ListFieldLevelEncryptionConfigsError;
/// Error type for the `ListFieldLevelEncryptionConfigsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListFieldLevelEncryptionConfigsError {
    /// <p>An argument is invalid.</p>
    InvalidArgument(crate::error::InvalidArgument),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for ListFieldLevelEncryptionConfigsError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for ListFieldLevelEncryptionConfigsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::InvalidArgument(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for ListFieldLevelEncryptionConfigsError
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::InvalidArgument(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::ListFieldLevelEncryptionConfigsError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListFieldLevelEncryptionConfigsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListFieldLevelEncryptionConfigsError {
    /// Creates the `ListFieldLevelEncryptionConfigsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `ListFieldLevelEncryptionConfigsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::InvalidArgument(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ListFieldLevelEncryptionConfigsError::InvalidArgument`.
    pub fn is_invalid_argument(&self) -> bool {
        matches!(self, Self::InvalidArgument(_))
    }
}
impl std::error::Error for ListFieldLevelEncryptionConfigsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::InvalidArgument(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type ListDistributionsByWebACLIdErrorKind = ListDistributionsByWebACLIdError;
/// Error type for the `ListDistributionsByWebACLIdError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListDistributionsByWebACLIdError {
    /// <p>An argument is invalid.</p>
    InvalidArgument(crate::error::InvalidArgument),
    /// <p>A web ACL ID specified is not valid. To specify a web ACL created using the latest version of WAF, use the ACL ARN, for example <code>arn:aws:wafv2:us-east-1:123456789012:global/webacl/ExampleWebACL/473e64fd-f30b-4765-81a0-62ad96dd167a</code>. To specify a web ACL created using WAF Classic, use the ACL ID, for example <code>473e64fd-f30b-4765-81a0-62ad96dd167a</code>.</p>
    InvalidWebAclId(crate::error::InvalidWebAclId),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for ListDistributionsByWebACLIdError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for ListDistributionsByWebACLIdError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::InvalidArgument(_inner) => _inner.fmt(f),
            Self::InvalidWebAclId(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ListDistributionsByWebACLIdError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::InvalidArgument(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidWebAclId(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::ListDistributionsByWebACLIdError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListDistributionsByWebACLIdError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListDistributionsByWebACLIdError {
    /// Creates the `ListDistributionsByWebACLIdError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `ListDistributionsByWebACLIdError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::InvalidArgument(e) => e.meta(),
            Self::InvalidWebAclId(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ListDistributionsByWebACLIdError::InvalidArgument`.
    pub fn is_invalid_argument(&self) -> bool {
        matches!(self, Self::InvalidArgument(_))
    }
    /// Returns `true` if the error kind is `ListDistributionsByWebACLIdError::InvalidWebAclId`.
    pub fn is_invalid_web_acl_id(&self) -> bool {
        matches!(self, Self::InvalidWebAclId(_))
    }
}
impl std::error::Error for ListDistributionsByWebACLIdError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::InvalidArgument(_inner) => Some(_inner),
            Self::InvalidWebAclId(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type ListDistributionsByResponseHeadersPolicyIdErrorKind =
    ListDistributionsByResponseHeadersPolicyIdError;
/// Error type for the `ListDistributionsByResponseHeadersPolicyIdError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListDistributionsByResponseHeadersPolicyIdError {
    /// <p>Access denied.</p>
    AccessDenied(crate::error::AccessDenied),
    /// <p>An argument is invalid.</p>
    InvalidArgument(crate::error::InvalidArgument),
    /// <p>The response headers policy does not exist.</p>
    NoSuchResponseHeadersPolicy(crate::error::NoSuchResponseHeadersPolicy),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError
    for ListDistributionsByResponseHeadersPolicyIdError
{
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for ListDistributionsByResponseHeadersPolicyIdError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AccessDenied(_inner) => _inner.fmt(f),
            Self::InvalidArgument(_inner) => _inner.fmt(f),
            Self::NoSuchResponseHeadersPolicy(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for ListDistributionsByResponseHeadersPolicyIdError
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AccessDenied(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidArgument(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NoSuchResponseHeadersPolicy(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId
    for crate::error::ListDistributionsByResponseHeadersPolicyIdError
{
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListDistributionsByResponseHeadersPolicyIdError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListDistributionsByResponseHeadersPolicyIdError {
    /// Creates the `ListDistributionsByResponseHeadersPolicyIdError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `ListDistributionsByResponseHeadersPolicyIdError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AccessDenied(e) => e.meta(),
            Self::InvalidArgument(e) => e.meta(),
            Self::NoSuchResponseHeadersPolicy(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ListDistributionsByResponseHeadersPolicyIdError::AccessDenied`.
    pub fn is_access_denied(&self) -> bool {
        matches!(self, Self::AccessDenied(_))
    }
    /// Returns `true` if the error kind is `ListDistributionsByResponseHeadersPolicyIdError::InvalidArgument`.
    pub fn is_invalid_argument(&self) -> bool {
        matches!(self, Self::InvalidArgument(_))
    }
    /// Returns `true` if the error kind is `ListDistributionsByResponseHeadersPolicyIdError::NoSuchResponseHeadersPolicy`.
    pub fn is_no_such_response_headers_policy(&self) -> bool {
        matches!(self, Self::NoSuchResponseHeadersPolicy(_))
    }
}
impl std::error::Error for ListDistributionsByResponseHeadersPolicyIdError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AccessDenied(_inner) => Some(_inner),
            Self::InvalidArgument(_inner) => Some(_inner),
            Self::NoSuchResponseHeadersPolicy(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type ListDistributionsByRealtimeLogConfigErrorKind = ListDistributionsByRealtimeLogConfigError;
/// Error type for the `ListDistributionsByRealtimeLogConfigError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListDistributionsByRealtimeLogConfigError {
    /// <p>An argument is invalid.</p>
    InvalidArgument(crate::error::InvalidArgument),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for ListDistributionsByRealtimeLogConfigError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for ListDistributionsByRealtimeLogConfigError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::InvalidArgument(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for ListDistributionsByRealtimeLogConfigError
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::InvalidArgument(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::ListDistributionsByRealtimeLogConfigError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListDistributionsByRealtimeLogConfigError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListDistributionsByRealtimeLogConfigError {
    /// Creates the `ListDistributionsByRealtimeLogConfigError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `ListDistributionsByRealtimeLogConfigError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::InvalidArgument(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ListDistributionsByRealtimeLogConfigError::InvalidArgument`.
    pub fn is_invalid_argument(&self) -> bool {
        matches!(self, Self::InvalidArgument(_))
    }
}
impl std::error::Error for ListDistributionsByRealtimeLogConfigError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::InvalidArgument(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type ListDistributionsByOriginRequestPolicyIdErrorKind =
    ListDistributionsByOriginRequestPolicyIdError;
/// Error type for the `ListDistributionsByOriginRequestPolicyIdError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListDistributionsByOriginRequestPolicyIdError {
    /// <p>Access denied.</p>
    AccessDenied(crate::error::AccessDenied),
    /// <p>An argument is invalid.</p>
    InvalidArgument(crate::error::InvalidArgument),
    /// <p>The origin request policy does not exist.</p>
    NoSuchOriginRequestPolicy(crate::error::NoSuchOriginRequestPolicy),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError
    for ListDistributionsByOriginRequestPolicyIdError
{
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for ListDistributionsByOriginRequestPolicyIdError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AccessDenied(_inner) => _inner.fmt(f),
            Self::InvalidArgument(_inner) => _inner.fmt(f),
            Self::NoSuchOriginRequestPolicy(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for ListDistributionsByOriginRequestPolicyIdError
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AccessDenied(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidArgument(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NoSuchOriginRequestPolicy(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId
    for crate::error::ListDistributionsByOriginRequestPolicyIdError
{
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListDistributionsByOriginRequestPolicyIdError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListDistributionsByOriginRequestPolicyIdError {
    /// Creates the `ListDistributionsByOriginRequestPolicyIdError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `ListDistributionsByOriginRequestPolicyIdError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AccessDenied(e) => e.meta(),
            Self::InvalidArgument(e) => e.meta(),
            Self::NoSuchOriginRequestPolicy(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ListDistributionsByOriginRequestPolicyIdError::AccessDenied`.
    pub fn is_access_denied(&self) -> bool {
        matches!(self, Self::AccessDenied(_))
    }
    /// Returns `true` if the error kind is `ListDistributionsByOriginRequestPolicyIdError::InvalidArgument`.
    pub fn is_invalid_argument(&self) -> bool {
        matches!(self, Self::InvalidArgument(_))
    }
    /// Returns `true` if the error kind is `ListDistributionsByOriginRequestPolicyIdError::NoSuchOriginRequestPolicy`.
    pub fn is_no_such_origin_request_policy(&self) -> bool {
        matches!(self, Self::NoSuchOriginRequestPolicy(_))
    }
}
impl std::error::Error for ListDistributionsByOriginRequestPolicyIdError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AccessDenied(_inner) => Some(_inner),
            Self::InvalidArgument(_inner) => Some(_inner),
            Self::NoSuchOriginRequestPolicy(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type ListDistributionsByKeyGroupErrorKind = ListDistributionsByKeyGroupError;
/// Error type for the `ListDistributionsByKeyGroupError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListDistributionsByKeyGroupError {
    /// <p>An argument is invalid.</p>
    InvalidArgument(crate::error::InvalidArgument),
    /// <p>A resource that was specified is not valid.</p>
    NoSuchResource(crate::error::NoSuchResource),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for ListDistributionsByKeyGroupError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for ListDistributionsByKeyGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::InvalidArgument(_inner) => _inner.fmt(f),
            Self::NoSuchResource(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ListDistributionsByKeyGroupError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::InvalidArgument(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NoSuchResource(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::ListDistributionsByKeyGroupError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListDistributionsByKeyGroupError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListDistributionsByKeyGroupError {
    /// Creates the `ListDistributionsByKeyGroupError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `ListDistributionsByKeyGroupError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::InvalidArgument(e) => e.meta(),
            Self::NoSuchResource(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ListDistributionsByKeyGroupError::InvalidArgument`.
    pub fn is_invalid_argument(&self) -> bool {
        matches!(self, Self::InvalidArgument(_))
    }
    /// Returns `true` if the error kind is `ListDistributionsByKeyGroupError::NoSuchResource`.
    pub fn is_no_such_resource(&self) -> bool {
        matches!(self, Self::NoSuchResource(_))
    }
}
impl std::error::Error for ListDistributionsByKeyGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::InvalidArgument(_inner) => Some(_inner),
            Self::NoSuchResource(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type ListDistributionsByCachePolicyIdErrorKind = ListDistributionsByCachePolicyIdError;
/// Error type for the `ListDistributionsByCachePolicyIdError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListDistributionsByCachePolicyIdError {
    /// <p>Access denied.</p>
    AccessDenied(crate::error::AccessDenied),
    /// <p>An argument is invalid.</p>
    InvalidArgument(crate::error::InvalidArgument),
    /// <p>The cache policy does not exist.</p>
    NoSuchCachePolicy(crate::error::NoSuchCachePolicy),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for ListDistributionsByCachePolicyIdError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for ListDistributionsByCachePolicyIdError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AccessDenied(_inner) => _inner.fmt(f),
            Self::InvalidArgument(_inner) => _inner.fmt(f),
            Self::NoSuchCachePolicy(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for ListDistributionsByCachePolicyIdError
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AccessDenied(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidArgument(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NoSuchCachePolicy(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::ListDistributionsByCachePolicyIdError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListDistributionsByCachePolicyIdError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListDistributionsByCachePolicyIdError {
    /// Creates the `ListDistributionsByCachePolicyIdError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `ListDistributionsByCachePolicyIdError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AccessDenied(e) => e.meta(),
            Self::InvalidArgument(e) => e.meta(),
            Self::NoSuchCachePolicy(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ListDistributionsByCachePolicyIdError::AccessDenied`.
    pub fn is_access_denied(&self) -> bool {
        matches!(self, Self::AccessDenied(_))
    }
    /// Returns `true` if the error kind is `ListDistributionsByCachePolicyIdError::InvalidArgument`.
    pub fn is_invalid_argument(&self) -> bool {
        matches!(self, Self::InvalidArgument(_))
    }
    /// Returns `true` if the error kind is `ListDistributionsByCachePolicyIdError::NoSuchCachePolicy`.
    pub fn is_no_such_cache_policy(&self) -> bool {
        matches!(self, Self::NoSuchCachePolicy(_))
    }
}
impl std::error::Error for ListDistributionsByCachePolicyIdError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AccessDenied(_inner) => Some(_inner),
            Self::InvalidArgument(_inner) => Some(_inner),
            Self::NoSuchCachePolicy(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type ListDistributionsErrorKind = ListDistributionsError;
/// Error type for the `ListDistributionsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListDistributionsError {
    /// <p>An argument is invalid.</p>
    InvalidArgument(crate::error::InvalidArgument),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for ListDistributionsError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for ListDistributionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::InvalidArgument(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ListDistributionsError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::InvalidArgument(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::ListDistributionsError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListDistributionsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListDistributionsError {
    /// Creates the `ListDistributionsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `ListDistributionsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::InvalidArgument(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ListDistributionsError::InvalidArgument`.
    pub fn is_invalid_argument(&self) -> bool {
        matches!(self, Self::InvalidArgument(_))
    }
}
impl std::error::Error for ListDistributionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::InvalidArgument(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type ListContinuousDeploymentPoliciesErrorKind = ListContinuousDeploymentPoliciesError;
/// Error type for the `ListContinuousDeploymentPoliciesError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListContinuousDeploymentPoliciesError {
    /// <p>Access denied.</p>
    AccessDenied(crate::error::AccessDenied),
    /// <p>An argument is invalid.</p>
    InvalidArgument(crate::error::InvalidArgument),
    /// <p>The continuous deployment policy doesn't exist.</p>
    NoSuchContinuousDeploymentPolicy(crate::error::NoSuchContinuousDeploymentPolicy),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for ListContinuousDeploymentPoliciesError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for ListContinuousDeploymentPoliciesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AccessDenied(_inner) => _inner.fmt(f),
            Self::InvalidArgument(_inner) => _inner.fmt(f),
            Self::NoSuchContinuousDeploymentPolicy(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for ListContinuousDeploymentPoliciesError
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AccessDenied(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidArgument(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NoSuchContinuousDeploymentPolicy(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::ListContinuousDeploymentPoliciesError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListContinuousDeploymentPoliciesError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListContinuousDeploymentPoliciesError {
    /// Creates the `ListContinuousDeploymentPoliciesError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `ListContinuousDeploymentPoliciesError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AccessDenied(e) => e.meta(),
            Self::InvalidArgument(e) => e.meta(),
            Self::NoSuchContinuousDeploymentPolicy(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ListContinuousDeploymentPoliciesError::AccessDenied`.
    pub fn is_access_denied(&self) -> bool {
        matches!(self, Self::AccessDenied(_))
    }
    /// Returns `true` if the error kind is `ListContinuousDeploymentPoliciesError::InvalidArgument`.
    pub fn is_invalid_argument(&self) -> bool {
        matches!(self, Self::InvalidArgument(_))
    }
    /// Returns `true` if the error kind is `ListContinuousDeploymentPoliciesError::NoSuchContinuousDeploymentPolicy`.
    pub fn is_no_such_continuous_deployment_policy(&self) -> bool {
        matches!(self, Self::NoSuchContinuousDeploymentPolicy(_))
    }
}
impl std::error::Error for ListContinuousDeploymentPoliciesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AccessDenied(_inner) => Some(_inner),
            Self::InvalidArgument(_inner) => Some(_inner),
            Self::NoSuchContinuousDeploymentPolicy(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type ListConflictingAliasesErrorKind = ListConflictingAliasesError;
/// Error type for the `ListConflictingAliasesError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListConflictingAliasesError {
    /// <p>An argument is invalid.</p>
    InvalidArgument(crate::error::InvalidArgument),
    /// <p>The specified distribution does not exist.</p>
    NoSuchDistribution(crate::error::NoSuchDistribution),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for ListConflictingAliasesError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for ListConflictingAliasesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::InvalidArgument(_inner) => _inner.fmt(f),
            Self::NoSuchDistribution(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ListConflictingAliasesError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::InvalidArgument(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NoSuchDistribution(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::ListConflictingAliasesError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListConflictingAliasesError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListConflictingAliasesError {
    /// Creates the `ListConflictingAliasesError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `ListConflictingAliasesError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::InvalidArgument(e) => e.meta(),
            Self::NoSuchDistribution(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ListConflictingAliasesError::InvalidArgument`.
    pub fn is_invalid_argument(&self) -> bool {
        matches!(self, Self::InvalidArgument(_))
    }
    /// Returns `true` if the error kind is `ListConflictingAliasesError::NoSuchDistribution`.
    pub fn is_no_such_distribution(&self) -> bool {
        matches!(self, Self::NoSuchDistribution(_))
    }
}
impl std::error::Error for ListConflictingAliasesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::InvalidArgument(_inner) => Some(_inner),
            Self::NoSuchDistribution(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type ListCloudFrontOriginAccessIdentitiesErrorKind = ListCloudFrontOriginAccessIdentitiesError;
/// Error type for the `ListCloudFrontOriginAccessIdentitiesError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListCloudFrontOriginAccessIdentitiesError {
    /// <p>An argument is invalid.</p>
    InvalidArgument(crate::error::InvalidArgument),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for ListCloudFrontOriginAccessIdentitiesError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for ListCloudFrontOriginAccessIdentitiesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::InvalidArgument(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for ListCloudFrontOriginAccessIdentitiesError
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::InvalidArgument(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::ListCloudFrontOriginAccessIdentitiesError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListCloudFrontOriginAccessIdentitiesError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListCloudFrontOriginAccessIdentitiesError {
    /// Creates the `ListCloudFrontOriginAccessIdentitiesError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `ListCloudFrontOriginAccessIdentitiesError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::InvalidArgument(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ListCloudFrontOriginAccessIdentitiesError::InvalidArgument`.
    pub fn is_invalid_argument(&self) -> bool {
        matches!(self, Self::InvalidArgument(_))
    }
}
impl std::error::Error for ListCloudFrontOriginAccessIdentitiesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::InvalidArgument(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type ListCachePoliciesErrorKind = ListCachePoliciesError;
/// Error type for the `ListCachePoliciesError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListCachePoliciesError {
    /// <p>Access denied.</p>
    AccessDenied(crate::error::AccessDenied),
    /// <p>An argument is invalid.</p>
    InvalidArgument(crate::error::InvalidArgument),
    /// <p>The cache policy does not exist.</p>
    NoSuchCachePolicy(crate::error::NoSuchCachePolicy),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for ListCachePoliciesError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for ListCachePoliciesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AccessDenied(_inner) => _inner.fmt(f),
            Self::InvalidArgument(_inner) => _inner.fmt(f),
            Self::NoSuchCachePolicy(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ListCachePoliciesError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AccessDenied(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidArgument(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NoSuchCachePolicy(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::ListCachePoliciesError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListCachePoliciesError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListCachePoliciesError {
    /// Creates the `ListCachePoliciesError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `ListCachePoliciesError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AccessDenied(e) => e.meta(),
            Self::InvalidArgument(e) => e.meta(),
            Self::NoSuchCachePolicy(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ListCachePoliciesError::AccessDenied`.
    pub fn is_access_denied(&self) -> bool {
        matches!(self, Self::AccessDenied(_))
    }
    /// Returns `true` if the error kind is `ListCachePoliciesError::InvalidArgument`.
    pub fn is_invalid_argument(&self) -> bool {
        matches!(self, Self::InvalidArgument(_))
    }
    /// Returns `true` if the error kind is `ListCachePoliciesError::NoSuchCachePolicy`.
    pub fn is_no_such_cache_policy(&self) -> bool {
        matches!(self, Self::NoSuchCachePolicy(_))
    }
}
impl std::error::Error for ListCachePoliciesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AccessDenied(_inner) => Some(_inner),
            Self::InvalidArgument(_inner) => Some(_inner),
            Self::NoSuchCachePolicy(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type GetStreamingDistributionConfigErrorKind = GetStreamingDistributionConfigError;
/// Error type for the `GetStreamingDistributionConfigError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetStreamingDistributionConfigError {
    /// <p>Access denied.</p>
    AccessDenied(crate::error::AccessDenied),
    /// <p>The specified streaming distribution does not exist.</p>
    NoSuchStreamingDistribution(crate::error::NoSuchStreamingDistribution),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for GetStreamingDistributionConfigError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for GetStreamingDistributionConfigError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AccessDenied(_inner) => _inner.fmt(f),
            Self::NoSuchStreamingDistribution(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for GetStreamingDistributionConfigError
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AccessDenied(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NoSuchStreamingDistribution(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::GetStreamingDistributionConfigError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetStreamingDistributionConfigError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetStreamingDistributionConfigError {
    /// Creates the `GetStreamingDistributionConfigError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `GetStreamingDistributionConfigError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AccessDenied(e) => e.meta(),
            Self::NoSuchStreamingDistribution(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `GetStreamingDistributionConfigError::AccessDenied`.
    pub fn is_access_denied(&self) -> bool {
        matches!(self, Self::AccessDenied(_))
    }
    /// Returns `true` if the error kind is `GetStreamingDistributionConfigError::NoSuchStreamingDistribution`.
    pub fn is_no_such_streaming_distribution(&self) -> bool {
        matches!(self, Self::NoSuchStreamingDistribution(_))
    }
}
impl std::error::Error for GetStreamingDistributionConfigError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AccessDenied(_inner) => Some(_inner),
            Self::NoSuchStreamingDistribution(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type GetStreamingDistributionErrorKind = GetStreamingDistributionError;
/// Error type for the `GetStreamingDistributionError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetStreamingDistributionError {
    /// <p>Access denied.</p>
    AccessDenied(crate::error::AccessDenied),
    /// <p>The specified streaming distribution does not exist.</p>
    NoSuchStreamingDistribution(crate::error::NoSuchStreamingDistribution),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for GetStreamingDistributionError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for GetStreamingDistributionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AccessDenied(_inner) => _inner.fmt(f),
            Self::NoSuchStreamingDistribution(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for GetStreamingDistributionError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AccessDenied(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NoSuchStreamingDistribution(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::GetStreamingDistributionError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetStreamingDistributionError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetStreamingDistributionError {
    /// Creates the `GetStreamingDistributionError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `GetStreamingDistributionError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AccessDenied(e) => e.meta(),
            Self::NoSuchStreamingDistribution(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `GetStreamingDistributionError::AccessDenied`.
    pub fn is_access_denied(&self) -> bool {
        matches!(self, Self::AccessDenied(_))
    }
    /// Returns `true` if the error kind is `GetStreamingDistributionError::NoSuchStreamingDistribution`.
    pub fn is_no_such_streaming_distribution(&self) -> bool {
        matches!(self, Self::NoSuchStreamingDistribution(_))
    }
}
impl std::error::Error for GetStreamingDistributionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AccessDenied(_inner) => Some(_inner),
            Self::NoSuchStreamingDistribution(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type GetResponseHeadersPolicyConfigErrorKind = GetResponseHeadersPolicyConfigError;
/// Error type for the `GetResponseHeadersPolicyConfigError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetResponseHeadersPolicyConfigError {
    /// <p>Access denied.</p>
    AccessDenied(crate::error::AccessDenied),
    /// <p>The response headers policy does not exist.</p>
    NoSuchResponseHeadersPolicy(crate::error::NoSuchResponseHeadersPolicy),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for GetResponseHeadersPolicyConfigError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for GetResponseHeadersPolicyConfigError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AccessDenied(_inner) => _inner.fmt(f),
            Self::NoSuchResponseHeadersPolicy(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for GetResponseHeadersPolicyConfigError
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AccessDenied(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NoSuchResponseHeadersPolicy(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::GetResponseHeadersPolicyConfigError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetResponseHeadersPolicyConfigError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetResponseHeadersPolicyConfigError {
    /// Creates the `GetResponseHeadersPolicyConfigError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `GetResponseHeadersPolicyConfigError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AccessDenied(e) => e.meta(),
            Self::NoSuchResponseHeadersPolicy(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `GetResponseHeadersPolicyConfigError::AccessDenied`.
    pub fn is_access_denied(&self) -> bool {
        matches!(self, Self::AccessDenied(_))
    }
    /// Returns `true` if the error kind is `GetResponseHeadersPolicyConfigError::NoSuchResponseHeadersPolicy`.
    pub fn is_no_such_response_headers_policy(&self) -> bool {
        matches!(self, Self::NoSuchResponseHeadersPolicy(_))
    }
}
impl std::error::Error for GetResponseHeadersPolicyConfigError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AccessDenied(_inner) => Some(_inner),
            Self::NoSuchResponseHeadersPolicy(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type GetResponseHeadersPolicyErrorKind = GetResponseHeadersPolicyError;
/// Error type for the `GetResponseHeadersPolicyError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetResponseHeadersPolicyError {
    /// <p>Access denied.</p>
    AccessDenied(crate::error::AccessDenied),
    /// <p>The response headers policy does not exist.</p>
    NoSuchResponseHeadersPolicy(crate::error::NoSuchResponseHeadersPolicy),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for GetResponseHeadersPolicyError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for GetResponseHeadersPolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AccessDenied(_inner) => _inner.fmt(f),
            Self::NoSuchResponseHeadersPolicy(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for GetResponseHeadersPolicyError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AccessDenied(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NoSuchResponseHeadersPolicy(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::GetResponseHeadersPolicyError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetResponseHeadersPolicyError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetResponseHeadersPolicyError {
    /// Creates the `GetResponseHeadersPolicyError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `GetResponseHeadersPolicyError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AccessDenied(e) => e.meta(),
            Self::NoSuchResponseHeadersPolicy(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `GetResponseHeadersPolicyError::AccessDenied`.
    pub fn is_access_denied(&self) -> bool {
        matches!(self, Self::AccessDenied(_))
    }
    /// Returns `true` if the error kind is `GetResponseHeadersPolicyError::NoSuchResponseHeadersPolicy`.
    pub fn is_no_such_response_headers_policy(&self) -> bool {
        matches!(self, Self::NoSuchResponseHeadersPolicy(_))
    }
}
impl std::error::Error for GetResponseHeadersPolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AccessDenied(_inner) => Some(_inner),
            Self::NoSuchResponseHeadersPolicy(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type GetRealtimeLogConfigErrorKind = GetRealtimeLogConfigError;
/// Error type for the `GetRealtimeLogConfigError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetRealtimeLogConfigError {
    /// <p>Access denied.</p>
    AccessDenied(crate::error::AccessDenied),
    /// <p>An argument is invalid.</p>
    InvalidArgument(crate::error::InvalidArgument),
    /// <p>The real-time log configuration does not exist.</p>
    NoSuchRealtimeLogConfig(crate::error::NoSuchRealtimeLogConfig),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for GetRealtimeLogConfigError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for GetRealtimeLogConfigError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AccessDenied(_inner) => _inner.fmt(f),
            Self::InvalidArgument(_inner) => _inner.fmt(f),
            Self::NoSuchRealtimeLogConfig(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for GetRealtimeLogConfigError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AccessDenied(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidArgument(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NoSuchRealtimeLogConfig(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::GetRealtimeLogConfigError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetRealtimeLogConfigError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetRealtimeLogConfigError {
    /// Creates the `GetRealtimeLogConfigError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `GetRealtimeLogConfigError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AccessDenied(e) => e.meta(),
            Self::InvalidArgument(e) => e.meta(),
            Self::NoSuchRealtimeLogConfig(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `GetRealtimeLogConfigError::AccessDenied`.
    pub fn is_access_denied(&self) -> bool {
        matches!(self, Self::AccessDenied(_))
    }
    /// Returns `true` if the error kind is `GetRealtimeLogConfigError::InvalidArgument`.
    pub fn is_invalid_argument(&self) -> bool {
        matches!(self, Self::InvalidArgument(_))
    }
    /// Returns `true` if the error kind is `GetRealtimeLogConfigError::NoSuchRealtimeLogConfig`.
    pub fn is_no_such_realtime_log_config(&self) -> bool {
        matches!(self, Self::NoSuchRealtimeLogConfig(_))
    }
}
impl std::error::Error for GetRealtimeLogConfigError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AccessDenied(_inner) => Some(_inner),
            Self::InvalidArgument(_inner) => Some(_inner),
            Self::NoSuchRealtimeLogConfig(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type GetPublicKeyConfigErrorKind = GetPublicKeyConfigError;
/// Error type for the `GetPublicKeyConfigError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetPublicKeyConfigError {
    /// <p>Access denied.</p>
    AccessDenied(crate::error::AccessDenied),
    /// <p>The specified public key doesn't exist.</p>
    NoSuchPublicKey(crate::error::NoSuchPublicKey),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for GetPublicKeyConfigError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for GetPublicKeyConfigError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AccessDenied(_inner) => _inner.fmt(f),
            Self::NoSuchPublicKey(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for GetPublicKeyConfigError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AccessDenied(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NoSuchPublicKey(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::GetPublicKeyConfigError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetPublicKeyConfigError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetPublicKeyConfigError {
    /// Creates the `GetPublicKeyConfigError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `GetPublicKeyConfigError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AccessDenied(e) => e.meta(),
            Self::NoSuchPublicKey(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `GetPublicKeyConfigError::AccessDenied`.
    pub fn is_access_denied(&self) -> bool {
        matches!(self, Self::AccessDenied(_))
    }
    /// Returns `true` if the error kind is `GetPublicKeyConfigError::NoSuchPublicKey`.
    pub fn is_no_such_public_key(&self) -> bool {
        matches!(self, Self::NoSuchPublicKey(_))
    }
}
impl std::error::Error for GetPublicKeyConfigError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AccessDenied(_inner) => Some(_inner),
            Self::NoSuchPublicKey(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type GetPublicKeyErrorKind = GetPublicKeyError;
/// Error type for the `GetPublicKeyError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetPublicKeyError {
    /// <p>Access denied.</p>
    AccessDenied(crate::error::AccessDenied),
    /// <p>The specified public key doesn't exist.</p>
    NoSuchPublicKey(crate::error::NoSuchPublicKey),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for GetPublicKeyError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for GetPublicKeyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AccessDenied(_inner) => _inner.fmt(f),
            Self::NoSuchPublicKey(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for GetPublicKeyError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AccessDenied(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NoSuchPublicKey(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::GetPublicKeyError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetPublicKeyError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetPublicKeyError {
    /// Creates the `GetPublicKeyError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `GetPublicKeyError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AccessDenied(e) => e.meta(),
            Self::NoSuchPublicKey(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `GetPublicKeyError::AccessDenied`.
    pub fn is_access_denied(&self) -> bool {
        matches!(self, Self::AccessDenied(_))
    }
    /// Returns `true` if the error kind is `GetPublicKeyError::NoSuchPublicKey`.
    pub fn is_no_such_public_key(&self) -> bool {
        matches!(self, Self::NoSuchPublicKey(_))
    }
}
impl std::error::Error for GetPublicKeyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AccessDenied(_inner) => Some(_inner),
            Self::NoSuchPublicKey(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type GetOriginRequestPolicyConfigErrorKind = GetOriginRequestPolicyConfigError;
/// Error type for the `GetOriginRequestPolicyConfigError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetOriginRequestPolicyConfigError {
    /// <p>Access denied.</p>
    AccessDenied(crate::error::AccessDenied),
    /// <p>The origin request policy does not exist.</p>
    NoSuchOriginRequestPolicy(crate::error::NoSuchOriginRequestPolicy),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for GetOriginRequestPolicyConfigError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for GetOriginRequestPolicyConfigError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AccessDenied(_inner) => _inner.fmt(f),
            Self::NoSuchOriginRequestPolicy(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for GetOriginRequestPolicyConfigError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AccessDenied(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NoSuchOriginRequestPolicy(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::GetOriginRequestPolicyConfigError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetOriginRequestPolicyConfigError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetOriginRequestPolicyConfigError {
    /// Creates the `GetOriginRequestPolicyConfigError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `GetOriginRequestPolicyConfigError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AccessDenied(e) => e.meta(),
            Self::NoSuchOriginRequestPolicy(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `GetOriginRequestPolicyConfigError::AccessDenied`.
    pub fn is_access_denied(&self) -> bool {
        matches!(self, Self::AccessDenied(_))
    }
    /// Returns `true` if the error kind is `GetOriginRequestPolicyConfigError::NoSuchOriginRequestPolicy`.
    pub fn is_no_such_origin_request_policy(&self) -> bool {
        matches!(self, Self::NoSuchOriginRequestPolicy(_))
    }
}
impl std::error::Error for GetOriginRequestPolicyConfigError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AccessDenied(_inner) => Some(_inner),
            Self::NoSuchOriginRequestPolicy(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type GetOriginRequestPolicyErrorKind = GetOriginRequestPolicyError;
/// Error type for the `GetOriginRequestPolicyError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetOriginRequestPolicyError {
    /// <p>Access denied.</p>
    AccessDenied(crate::error::AccessDenied),
    /// <p>The origin request policy does not exist.</p>
    NoSuchOriginRequestPolicy(crate::error::NoSuchOriginRequestPolicy),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for GetOriginRequestPolicyError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for GetOriginRequestPolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AccessDenied(_inner) => _inner.fmt(f),
            Self::NoSuchOriginRequestPolicy(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for GetOriginRequestPolicyError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AccessDenied(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NoSuchOriginRequestPolicy(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::GetOriginRequestPolicyError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetOriginRequestPolicyError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetOriginRequestPolicyError {
    /// Creates the `GetOriginRequestPolicyError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `GetOriginRequestPolicyError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AccessDenied(e) => e.meta(),
            Self::NoSuchOriginRequestPolicy(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `GetOriginRequestPolicyError::AccessDenied`.
    pub fn is_access_denied(&self) -> bool {
        matches!(self, Self::AccessDenied(_))
    }
    /// Returns `true` if the error kind is `GetOriginRequestPolicyError::NoSuchOriginRequestPolicy`.
    pub fn is_no_such_origin_request_policy(&self) -> bool {
        matches!(self, Self::NoSuchOriginRequestPolicy(_))
    }
}
impl std::error::Error for GetOriginRequestPolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AccessDenied(_inner) => Some(_inner),
            Self::NoSuchOriginRequestPolicy(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type GetOriginAccessControlConfigErrorKind = GetOriginAccessControlConfigError;
/// Error type for the `GetOriginAccessControlConfigError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetOriginAccessControlConfigError {
    /// <p>Access denied.</p>
    AccessDenied(crate::error::AccessDenied),
    /// <p>The origin access control does not exist.</p>
    NoSuchOriginAccessControl(crate::error::NoSuchOriginAccessControl),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for GetOriginAccessControlConfigError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for GetOriginAccessControlConfigError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AccessDenied(_inner) => _inner.fmt(f),
            Self::NoSuchOriginAccessControl(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for GetOriginAccessControlConfigError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AccessDenied(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NoSuchOriginAccessControl(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::GetOriginAccessControlConfigError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetOriginAccessControlConfigError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetOriginAccessControlConfigError {
    /// Creates the `GetOriginAccessControlConfigError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `GetOriginAccessControlConfigError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AccessDenied(e) => e.meta(),
            Self::NoSuchOriginAccessControl(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `GetOriginAccessControlConfigError::AccessDenied`.
    pub fn is_access_denied(&self) -> bool {
        matches!(self, Self::AccessDenied(_))
    }
    /// Returns `true` if the error kind is `GetOriginAccessControlConfigError::NoSuchOriginAccessControl`.
    pub fn is_no_such_origin_access_control(&self) -> bool {
        matches!(self, Self::NoSuchOriginAccessControl(_))
    }
}
impl std::error::Error for GetOriginAccessControlConfigError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AccessDenied(_inner) => Some(_inner),
            Self::NoSuchOriginAccessControl(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type GetOriginAccessControlErrorKind = GetOriginAccessControlError;
/// Error type for the `GetOriginAccessControlError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetOriginAccessControlError {
    /// <p>Access denied.</p>
    AccessDenied(crate::error::AccessDenied),
    /// <p>The origin access control does not exist.</p>
    NoSuchOriginAccessControl(crate::error::NoSuchOriginAccessControl),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for GetOriginAccessControlError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for GetOriginAccessControlError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AccessDenied(_inner) => _inner.fmt(f),
            Self::NoSuchOriginAccessControl(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for GetOriginAccessControlError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AccessDenied(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NoSuchOriginAccessControl(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::GetOriginAccessControlError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetOriginAccessControlError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetOriginAccessControlError {
    /// Creates the `GetOriginAccessControlError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `GetOriginAccessControlError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AccessDenied(e) => e.meta(),
            Self::NoSuchOriginAccessControl(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `GetOriginAccessControlError::AccessDenied`.
    pub fn is_access_denied(&self) -> bool {
        matches!(self, Self::AccessDenied(_))
    }
    /// Returns `true` if the error kind is `GetOriginAccessControlError::NoSuchOriginAccessControl`.
    pub fn is_no_such_origin_access_control(&self) -> bool {
        matches!(self, Self::NoSuchOriginAccessControl(_))
    }
}
impl std::error::Error for GetOriginAccessControlError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AccessDenied(_inner) => Some(_inner),
            Self::NoSuchOriginAccessControl(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type GetMonitoringSubscriptionErrorKind = GetMonitoringSubscriptionError;
/// Error type for the `GetMonitoringSubscriptionError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetMonitoringSubscriptionError {
    /// <p>Access denied.</p>
    AccessDenied(crate::error::AccessDenied),
    /// <p>The specified distribution does not exist.</p>
    NoSuchDistribution(crate::error::NoSuchDistribution),
    /// <p>A monitoring subscription does not exist for the specified distribution.</p>
    NoSuchMonitoringSubscription(crate::error::NoSuchMonitoringSubscription),
    /// <p>This operation is not supported in this region.</p>
    UnsupportedOperation(crate::error::UnsupportedOperation),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for GetMonitoringSubscriptionError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for GetMonitoringSubscriptionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AccessDenied(_inner) => _inner.fmt(f),
            Self::NoSuchDistribution(_inner) => _inner.fmt(f),
            Self::NoSuchMonitoringSubscription(_inner) => _inner.fmt(f),
            Self::UnsupportedOperation(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for GetMonitoringSubscriptionError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AccessDenied(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NoSuchDistribution(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NoSuchMonitoringSubscription(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnsupportedOperation(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::GetMonitoringSubscriptionError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetMonitoringSubscriptionError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetMonitoringSubscriptionError {
    /// Creates the `GetMonitoringSubscriptionError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `GetMonitoringSubscriptionError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AccessDenied(e) => e.meta(),
            Self::NoSuchDistribution(e) => e.meta(),
            Self::NoSuchMonitoringSubscription(e) => e.meta(),
            Self::UnsupportedOperation(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `GetMonitoringSubscriptionError::AccessDenied`.
    pub fn is_access_denied(&self) -> bool {
        matches!(self, Self::AccessDenied(_))
    }
    /// Returns `true` if the error kind is `GetMonitoringSubscriptionError::NoSuchDistribution`.
    pub fn is_no_such_distribution(&self) -> bool {
        matches!(self, Self::NoSuchDistribution(_))
    }
    /// Returns `true` if the error kind is `GetMonitoringSubscriptionError::NoSuchMonitoringSubscription`.
    pub fn is_no_such_monitoring_subscription(&self) -> bool {
        matches!(self, Self::NoSuchMonitoringSubscription(_))
    }
    /// Returns `true` if the error kind is `GetMonitoringSubscriptionError::UnsupportedOperation`.
    pub fn is_unsupported_operation(&self) -> bool {
        matches!(self, Self::UnsupportedOperation(_))
    }
}
impl std::error::Error for GetMonitoringSubscriptionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AccessDenied(_inner) => Some(_inner),
            Self::NoSuchDistribution(_inner) => Some(_inner),
            Self::NoSuchMonitoringSubscription(_inner) => Some(_inner),
            Self::UnsupportedOperation(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>A monitoring subscription does not exist for the specified distribution.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct NoSuchMonitoringSubscription {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl NoSuchMonitoringSubscription {
    /// Creates a new builder-style object to manufacture [`NoSuchMonitoringSubscription`](crate::error::NoSuchMonitoringSubscription).
    pub fn builder() -> crate::error::no_such_monitoring_subscription::Builder {
        crate::error::no_such_monitoring_subscription::Builder::default()
    }
}
/// See [`NoSuchMonitoringSubscription`](crate::error::NoSuchMonitoringSubscription).
pub mod no_such_monitoring_subscription {

    /// A builder for [`NoSuchMonitoringSubscription`](crate::error::NoSuchMonitoringSubscription).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`NoSuchMonitoringSubscription`](crate::error::NoSuchMonitoringSubscription).
        pub fn build(self) -> crate::error::NoSuchMonitoringSubscription {
            crate::error::NoSuchMonitoringSubscription {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl NoSuchMonitoringSubscription {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for NoSuchMonitoringSubscription {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "NoSuchMonitoringSubscription")?;
        if let Some(inner_101) = &self.message {
            {
                write!(f, ": {}", inner_101)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for NoSuchMonitoringSubscription {}
impl aws_http::request_id::RequestId for crate::error::NoSuchMonitoringSubscription {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for NoSuchMonitoringSubscription {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type GetKeyGroupConfigErrorKind = GetKeyGroupConfigError;
/// Error type for the `GetKeyGroupConfigError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetKeyGroupConfigError {
    /// <p>A resource that was specified is not valid.</p>
    NoSuchResource(crate::error::NoSuchResource),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for GetKeyGroupConfigError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for GetKeyGroupConfigError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::NoSuchResource(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for GetKeyGroupConfigError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::NoSuchResource(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::GetKeyGroupConfigError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetKeyGroupConfigError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetKeyGroupConfigError {
    /// Creates the `GetKeyGroupConfigError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `GetKeyGroupConfigError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::NoSuchResource(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `GetKeyGroupConfigError::NoSuchResource`.
    pub fn is_no_such_resource(&self) -> bool {
        matches!(self, Self::NoSuchResource(_))
    }
}
impl std::error::Error for GetKeyGroupConfigError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::NoSuchResource(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type GetKeyGroupErrorKind = GetKeyGroupError;
/// Error type for the `GetKeyGroupError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetKeyGroupError {
    /// <p>A resource that was specified is not valid.</p>
    NoSuchResource(crate::error::NoSuchResource),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for GetKeyGroupError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for GetKeyGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::NoSuchResource(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for GetKeyGroupError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::NoSuchResource(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::GetKeyGroupError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetKeyGroupError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetKeyGroupError {
    /// Creates the `GetKeyGroupError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `GetKeyGroupError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::NoSuchResource(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `GetKeyGroupError::NoSuchResource`.
    pub fn is_no_such_resource(&self) -> bool {
        matches!(self, Self::NoSuchResource(_))
    }
}
impl std::error::Error for GetKeyGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::NoSuchResource(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type GetInvalidationErrorKind = GetInvalidationError;
/// Error type for the `GetInvalidationError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetInvalidationError {
    /// <p>Access denied.</p>
    AccessDenied(crate::error::AccessDenied),
    /// <p>The specified distribution does not exist.</p>
    NoSuchDistribution(crate::error::NoSuchDistribution),
    /// <p>The specified invalidation does not exist.</p>
    NoSuchInvalidation(crate::error::NoSuchInvalidation),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for GetInvalidationError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for GetInvalidationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AccessDenied(_inner) => _inner.fmt(f),
            Self::NoSuchDistribution(_inner) => _inner.fmt(f),
            Self::NoSuchInvalidation(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for GetInvalidationError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AccessDenied(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NoSuchDistribution(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NoSuchInvalidation(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::GetInvalidationError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetInvalidationError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetInvalidationError {
    /// Creates the `GetInvalidationError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `GetInvalidationError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AccessDenied(e) => e.meta(),
            Self::NoSuchDistribution(e) => e.meta(),
            Self::NoSuchInvalidation(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `GetInvalidationError::AccessDenied`.
    pub fn is_access_denied(&self) -> bool {
        matches!(self, Self::AccessDenied(_))
    }
    /// Returns `true` if the error kind is `GetInvalidationError::NoSuchDistribution`.
    pub fn is_no_such_distribution(&self) -> bool {
        matches!(self, Self::NoSuchDistribution(_))
    }
    /// Returns `true` if the error kind is `GetInvalidationError::NoSuchInvalidation`.
    pub fn is_no_such_invalidation(&self) -> bool {
        matches!(self, Self::NoSuchInvalidation(_))
    }
}
impl std::error::Error for GetInvalidationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AccessDenied(_inner) => Some(_inner),
            Self::NoSuchDistribution(_inner) => Some(_inner),
            Self::NoSuchInvalidation(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The specified invalidation does not exist.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct NoSuchInvalidation {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl NoSuchInvalidation {
    /// Creates a new builder-style object to manufacture [`NoSuchInvalidation`](crate::error::NoSuchInvalidation).
    pub fn builder() -> crate::error::no_such_invalidation::Builder {
        crate::error::no_such_invalidation::Builder::default()
    }
}
/// See [`NoSuchInvalidation`](crate::error::NoSuchInvalidation).
pub mod no_such_invalidation {

    /// A builder for [`NoSuchInvalidation`](crate::error::NoSuchInvalidation).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`NoSuchInvalidation`](crate::error::NoSuchInvalidation).
        pub fn build(self) -> crate::error::NoSuchInvalidation {
            crate::error::NoSuchInvalidation {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl NoSuchInvalidation {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for NoSuchInvalidation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "NoSuchInvalidation")?;
        if let Some(inner_102) = &self.message {
            {
                write!(f, ": {}", inner_102)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for NoSuchInvalidation {}
impl aws_http::request_id::RequestId for crate::error::NoSuchInvalidation {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for NoSuchInvalidation {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type GetFunctionErrorKind = GetFunctionError;
/// Error type for the `GetFunctionError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetFunctionError {
    /// <p>The function does not exist.</p>
    NoSuchFunctionExists(crate::error::NoSuchFunctionExists),
    /// <p>This operation is not supported in this region.</p>
    UnsupportedOperation(crate::error::UnsupportedOperation),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for GetFunctionError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for GetFunctionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::NoSuchFunctionExists(_inner) => _inner.fmt(f),
            Self::UnsupportedOperation(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for GetFunctionError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::NoSuchFunctionExists(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnsupportedOperation(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::GetFunctionError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetFunctionError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetFunctionError {
    /// Creates the `GetFunctionError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `GetFunctionError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::NoSuchFunctionExists(e) => e.meta(),
            Self::UnsupportedOperation(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `GetFunctionError::NoSuchFunctionExists`.
    pub fn is_no_such_function_exists(&self) -> bool {
        matches!(self, Self::NoSuchFunctionExists(_))
    }
    /// Returns `true` if the error kind is `GetFunctionError::UnsupportedOperation`.
    pub fn is_unsupported_operation(&self) -> bool {
        matches!(self, Self::UnsupportedOperation(_))
    }
}
impl std::error::Error for GetFunctionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::NoSuchFunctionExists(_inner) => Some(_inner),
            Self::UnsupportedOperation(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type GetFieldLevelEncryptionProfileConfigErrorKind = GetFieldLevelEncryptionProfileConfigError;
/// Error type for the `GetFieldLevelEncryptionProfileConfigError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetFieldLevelEncryptionProfileConfigError {
    /// <p>Access denied.</p>
    AccessDenied(crate::error::AccessDenied),
    /// <p>The specified profile for field-level encryption doesn't exist.</p>
    NoSuchFieldLevelEncryptionProfile(crate::error::NoSuchFieldLevelEncryptionProfile),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for GetFieldLevelEncryptionProfileConfigError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for GetFieldLevelEncryptionProfileConfigError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AccessDenied(_inner) => _inner.fmt(f),
            Self::NoSuchFieldLevelEncryptionProfile(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for GetFieldLevelEncryptionProfileConfigError
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AccessDenied(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NoSuchFieldLevelEncryptionProfile(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::GetFieldLevelEncryptionProfileConfigError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetFieldLevelEncryptionProfileConfigError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetFieldLevelEncryptionProfileConfigError {
    /// Creates the `GetFieldLevelEncryptionProfileConfigError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `GetFieldLevelEncryptionProfileConfigError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AccessDenied(e) => e.meta(),
            Self::NoSuchFieldLevelEncryptionProfile(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `GetFieldLevelEncryptionProfileConfigError::AccessDenied`.
    pub fn is_access_denied(&self) -> bool {
        matches!(self, Self::AccessDenied(_))
    }
    /// Returns `true` if the error kind is `GetFieldLevelEncryptionProfileConfigError::NoSuchFieldLevelEncryptionProfile`.
    pub fn is_no_such_field_level_encryption_profile(&self) -> bool {
        matches!(self, Self::NoSuchFieldLevelEncryptionProfile(_))
    }
}
impl std::error::Error for GetFieldLevelEncryptionProfileConfigError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AccessDenied(_inner) => Some(_inner),
            Self::NoSuchFieldLevelEncryptionProfile(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type GetFieldLevelEncryptionProfileErrorKind = GetFieldLevelEncryptionProfileError;
/// Error type for the `GetFieldLevelEncryptionProfileError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetFieldLevelEncryptionProfileError {
    /// <p>Access denied.</p>
    AccessDenied(crate::error::AccessDenied),
    /// <p>The specified profile for field-level encryption doesn't exist.</p>
    NoSuchFieldLevelEncryptionProfile(crate::error::NoSuchFieldLevelEncryptionProfile),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for GetFieldLevelEncryptionProfileError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for GetFieldLevelEncryptionProfileError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AccessDenied(_inner) => _inner.fmt(f),
            Self::NoSuchFieldLevelEncryptionProfile(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for GetFieldLevelEncryptionProfileError
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AccessDenied(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NoSuchFieldLevelEncryptionProfile(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::GetFieldLevelEncryptionProfileError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetFieldLevelEncryptionProfileError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetFieldLevelEncryptionProfileError {
    /// Creates the `GetFieldLevelEncryptionProfileError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `GetFieldLevelEncryptionProfileError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AccessDenied(e) => e.meta(),
            Self::NoSuchFieldLevelEncryptionProfile(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `GetFieldLevelEncryptionProfileError::AccessDenied`.
    pub fn is_access_denied(&self) -> bool {
        matches!(self, Self::AccessDenied(_))
    }
    /// Returns `true` if the error kind is `GetFieldLevelEncryptionProfileError::NoSuchFieldLevelEncryptionProfile`.
    pub fn is_no_such_field_level_encryption_profile(&self) -> bool {
        matches!(self, Self::NoSuchFieldLevelEncryptionProfile(_))
    }
}
impl std::error::Error for GetFieldLevelEncryptionProfileError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AccessDenied(_inner) => Some(_inner),
            Self::NoSuchFieldLevelEncryptionProfile(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type GetFieldLevelEncryptionConfigErrorKind = GetFieldLevelEncryptionConfigError;
/// Error type for the `GetFieldLevelEncryptionConfigError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetFieldLevelEncryptionConfigError {
    /// <p>Access denied.</p>
    AccessDenied(crate::error::AccessDenied),
    /// <p>The specified configuration for field-level encryption doesn't exist.</p>
    NoSuchFieldLevelEncryptionConfig(crate::error::NoSuchFieldLevelEncryptionConfig),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for GetFieldLevelEncryptionConfigError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for GetFieldLevelEncryptionConfigError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AccessDenied(_inner) => _inner.fmt(f),
            Self::NoSuchFieldLevelEncryptionConfig(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for GetFieldLevelEncryptionConfigError
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AccessDenied(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NoSuchFieldLevelEncryptionConfig(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::GetFieldLevelEncryptionConfigError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetFieldLevelEncryptionConfigError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetFieldLevelEncryptionConfigError {
    /// Creates the `GetFieldLevelEncryptionConfigError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `GetFieldLevelEncryptionConfigError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AccessDenied(e) => e.meta(),
            Self::NoSuchFieldLevelEncryptionConfig(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `GetFieldLevelEncryptionConfigError::AccessDenied`.
    pub fn is_access_denied(&self) -> bool {
        matches!(self, Self::AccessDenied(_))
    }
    /// Returns `true` if the error kind is `GetFieldLevelEncryptionConfigError::NoSuchFieldLevelEncryptionConfig`.
    pub fn is_no_such_field_level_encryption_config(&self) -> bool {
        matches!(self, Self::NoSuchFieldLevelEncryptionConfig(_))
    }
}
impl std::error::Error for GetFieldLevelEncryptionConfigError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AccessDenied(_inner) => Some(_inner),
            Self::NoSuchFieldLevelEncryptionConfig(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type GetFieldLevelEncryptionErrorKind = GetFieldLevelEncryptionError;
/// Error type for the `GetFieldLevelEncryptionError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetFieldLevelEncryptionError {
    /// <p>Access denied.</p>
    AccessDenied(crate::error::AccessDenied),
    /// <p>The specified configuration for field-level encryption doesn't exist.</p>
    NoSuchFieldLevelEncryptionConfig(crate::error::NoSuchFieldLevelEncryptionConfig),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for GetFieldLevelEncryptionError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for GetFieldLevelEncryptionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AccessDenied(_inner) => _inner.fmt(f),
            Self::NoSuchFieldLevelEncryptionConfig(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for GetFieldLevelEncryptionError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AccessDenied(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NoSuchFieldLevelEncryptionConfig(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::GetFieldLevelEncryptionError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetFieldLevelEncryptionError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetFieldLevelEncryptionError {
    /// Creates the `GetFieldLevelEncryptionError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `GetFieldLevelEncryptionError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AccessDenied(e) => e.meta(),
            Self::NoSuchFieldLevelEncryptionConfig(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `GetFieldLevelEncryptionError::AccessDenied`.
    pub fn is_access_denied(&self) -> bool {
        matches!(self, Self::AccessDenied(_))
    }
    /// Returns `true` if the error kind is `GetFieldLevelEncryptionError::NoSuchFieldLevelEncryptionConfig`.
    pub fn is_no_such_field_level_encryption_config(&self) -> bool {
        matches!(self, Self::NoSuchFieldLevelEncryptionConfig(_))
    }
}
impl std::error::Error for GetFieldLevelEncryptionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AccessDenied(_inner) => Some(_inner),
            Self::NoSuchFieldLevelEncryptionConfig(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type GetDistributionConfigErrorKind = GetDistributionConfigError;
/// Error type for the `GetDistributionConfigError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetDistributionConfigError {
    /// <p>Access denied.</p>
    AccessDenied(crate::error::AccessDenied),
    /// <p>The specified distribution does not exist.</p>
    NoSuchDistribution(crate::error::NoSuchDistribution),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for GetDistributionConfigError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for GetDistributionConfigError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AccessDenied(_inner) => _inner.fmt(f),
            Self::NoSuchDistribution(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for GetDistributionConfigError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AccessDenied(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NoSuchDistribution(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::GetDistributionConfigError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetDistributionConfigError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetDistributionConfigError {
    /// Creates the `GetDistributionConfigError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `GetDistributionConfigError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AccessDenied(e) => e.meta(),
            Self::NoSuchDistribution(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `GetDistributionConfigError::AccessDenied`.
    pub fn is_access_denied(&self) -> bool {
        matches!(self, Self::AccessDenied(_))
    }
    /// Returns `true` if the error kind is `GetDistributionConfigError::NoSuchDistribution`.
    pub fn is_no_such_distribution(&self) -> bool {
        matches!(self, Self::NoSuchDistribution(_))
    }
}
impl std::error::Error for GetDistributionConfigError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AccessDenied(_inner) => Some(_inner),
            Self::NoSuchDistribution(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type GetDistributionErrorKind = GetDistributionError;
/// Error type for the `GetDistributionError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetDistributionError {
    /// <p>Access denied.</p>
    AccessDenied(crate::error::AccessDenied),
    /// <p>The specified distribution does not exist.</p>
    NoSuchDistribution(crate::error::NoSuchDistribution),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for GetDistributionError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for GetDistributionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AccessDenied(_inner) => _inner.fmt(f),
            Self::NoSuchDistribution(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for GetDistributionError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AccessDenied(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NoSuchDistribution(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::GetDistributionError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetDistributionError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetDistributionError {
    /// Creates the `GetDistributionError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `GetDistributionError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AccessDenied(e) => e.meta(),
            Self::NoSuchDistribution(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `GetDistributionError::AccessDenied`.
    pub fn is_access_denied(&self) -> bool {
        matches!(self, Self::AccessDenied(_))
    }
    /// Returns `true` if the error kind is `GetDistributionError::NoSuchDistribution`.
    pub fn is_no_such_distribution(&self) -> bool {
        matches!(self, Self::NoSuchDistribution(_))
    }
}
impl std::error::Error for GetDistributionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AccessDenied(_inner) => Some(_inner),
            Self::NoSuchDistribution(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type GetContinuousDeploymentPolicyConfigErrorKind = GetContinuousDeploymentPolicyConfigError;
/// Error type for the `GetContinuousDeploymentPolicyConfigError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetContinuousDeploymentPolicyConfigError {
    /// <p>Access denied.</p>
    AccessDenied(crate::error::AccessDenied),
    /// <p>The continuous deployment policy doesn't exist.</p>
    NoSuchContinuousDeploymentPolicy(crate::error::NoSuchContinuousDeploymentPolicy),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for GetContinuousDeploymentPolicyConfigError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for GetContinuousDeploymentPolicyConfigError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AccessDenied(_inner) => _inner.fmt(f),
            Self::NoSuchContinuousDeploymentPolicy(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for GetContinuousDeploymentPolicyConfigError
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AccessDenied(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NoSuchContinuousDeploymentPolicy(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::GetContinuousDeploymentPolicyConfigError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetContinuousDeploymentPolicyConfigError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetContinuousDeploymentPolicyConfigError {
    /// Creates the `GetContinuousDeploymentPolicyConfigError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `GetContinuousDeploymentPolicyConfigError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AccessDenied(e) => e.meta(),
            Self::NoSuchContinuousDeploymentPolicy(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `GetContinuousDeploymentPolicyConfigError::AccessDenied`.
    pub fn is_access_denied(&self) -> bool {
        matches!(self, Self::AccessDenied(_))
    }
    /// Returns `true` if the error kind is `GetContinuousDeploymentPolicyConfigError::NoSuchContinuousDeploymentPolicy`.
    pub fn is_no_such_continuous_deployment_policy(&self) -> bool {
        matches!(self, Self::NoSuchContinuousDeploymentPolicy(_))
    }
}
impl std::error::Error for GetContinuousDeploymentPolicyConfigError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AccessDenied(_inner) => Some(_inner),
            Self::NoSuchContinuousDeploymentPolicy(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type GetContinuousDeploymentPolicyErrorKind = GetContinuousDeploymentPolicyError;
/// Error type for the `GetContinuousDeploymentPolicyError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetContinuousDeploymentPolicyError {
    /// <p>Access denied.</p>
    AccessDenied(crate::error::AccessDenied),
    /// <p>The continuous deployment policy doesn't exist.</p>
    NoSuchContinuousDeploymentPolicy(crate::error::NoSuchContinuousDeploymentPolicy),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for GetContinuousDeploymentPolicyError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for GetContinuousDeploymentPolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AccessDenied(_inner) => _inner.fmt(f),
            Self::NoSuchContinuousDeploymentPolicy(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for GetContinuousDeploymentPolicyError
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AccessDenied(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NoSuchContinuousDeploymentPolicy(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::GetContinuousDeploymentPolicyError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetContinuousDeploymentPolicyError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetContinuousDeploymentPolicyError {
    /// Creates the `GetContinuousDeploymentPolicyError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `GetContinuousDeploymentPolicyError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AccessDenied(e) => e.meta(),
            Self::NoSuchContinuousDeploymentPolicy(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `GetContinuousDeploymentPolicyError::AccessDenied`.
    pub fn is_access_denied(&self) -> bool {
        matches!(self, Self::AccessDenied(_))
    }
    /// Returns `true` if the error kind is `GetContinuousDeploymentPolicyError::NoSuchContinuousDeploymentPolicy`.
    pub fn is_no_such_continuous_deployment_policy(&self) -> bool {
        matches!(self, Self::NoSuchContinuousDeploymentPolicy(_))
    }
}
impl std::error::Error for GetContinuousDeploymentPolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AccessDenied(_inner) => Some(_inner),
            Self::NoSuchContinuousDeploymentPolicy(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type GetCloudFrontOriginAccessIdentityConfigErrorKind =
    GetCloudFrontOriginAccessIdentityConfigError;
/// Error type for the `GetCloudFrontOriginAccessIdentityConfigError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetCloudFrontOriginAccessIdentityConfigError {
    /// <p>Access denied.</p>
    AccessDenied(crate::error::AccessDenied),
    /// <p>The specified origin access identity does not exist.</p>
    NoSuchCloudFrontOriginAccessIdentity(crate::error::NoSuchCloudFrontOriginAccessIdentity),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError
    for GetCloudFrontOriginAccessIdentityConfigError
{
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for GetCloudFrontOriginAccessIdentityConfigError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AccessDenied(_inner) => _inner.fmt(f),
            Self::NoSuchCloudFrontOriginAccessIdentity(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for GetCloudFrontOriginAccessIdentityConfigError
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AccessDenied(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NoSuchCloudFrontOriginAccessIdentity(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId
    for crate::error::GetCloudFrontOriginAccessIdentityConfigError
{
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetCloudFrontOriginAccessIdentityConfigError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetCloudFrontOriginAccessIdentityConfigError {
    /// Creates the `GetCloudFrontOriginAccessIdentityConfigError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `GetCloudFrontOriginAccessIdentityConfigError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AccessDenied(e) => e.meta(),
            Self::NoSuchCloudFrontOriginAccessIdentity(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `GetCloudFrontOriginAccessIdentityConfigError::AccessDenied`.
    pub fn is_access_denied(&self) -> bool {
        matches!(self, Self::AccessDenied(_))
    }
    /// Returns `true` if the error kind is `GetCloudFrontOriginAccessIdentityConfigError::NoSuchCloudFrontOriginAccessIdentity`.
    pub fn is_no_such_cloud_front_origin_access_identity(&self) -> bool {
        matches!(self, Self::NoSuchCloudFrontOriginAccessIdentity(_))
    }
}
impl std::error::Error for GetCloudFrontOriginAccessIdentityConfigError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AccessDenied(_inner) => Some(_inner),
            Self::NoSuchCloudFrontOriginAccessIdentity(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type GetCloudFrontOriginAccessIdentityErrorKind = GetCloudFrontOriginAccessIdentityError;
/// Error type for the `GetCloudFrontOriginAccessIdentityError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetCloudFrontOriginAccessIdentityError {
    /// <p>Access denied.</p>
    AccessDenied(crate::error::AccessDenied),
    /// <p>The specified origin access identity does not exist.</p>
    NoSuchCloudFrontOriginAccessIdentity(crate::error::NoSuchCloudFrontOriginAccessIdentity),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for GetCloudFrontOriginAccessIdentityError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for GetCloudFrontOriginAccessIdentityError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AccessDenied(_inner) => _inner.fmt(f),
            Self::NoSuchCloudFrontOriginAccessIdentity(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for GetCloudFrontOriginAccessIdentityError
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AccessDenied(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NoSuchCloudFrontOriginAccessIdentity(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::GetCloudFrontOriginAccessIdentityError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetCloudFrontOriginAccessIdentityError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetCloudFrontOriginAccessIdentityError {
    /// Creates the `GetCloudFrontOriginAccessIdentityError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `GetCloudFrontOriginAccessIdentityError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AccessDenied(e) => e.meta(),
            Self::NoSuchCloudFrontOriginAccessIdentity(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `GetCloudFrontOriginAccessIdentityError::AccessDenied`.
    pub fn is_access_denied(&self) -> bool {
        matches!(self, Self::AccessDenied(_))
    }
    /// Returns `true` if the error kind is `GetCloudFrontOriginAccessIdentityError::NoSuchCloudFrontOriginAccessIdentity`.
    pub fn is_no_such_cloud_front_origin_access_identity(&self) -> bool {
        matches!(self, Self::NoSuchCloudFrontOriginAccessIdentity(_))
    }
}
impl std::error::Error for GetCloudFrontOriginAccessIdentityError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AccessDenied(_inner) => Some(_inner),
            Self::NoSuchCloudFrontOriginAccessIdentity(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type GetCachePolicyConfigErrorKind = GetCachePolicyConfigError;
/// Error type for the `GetCachePolicyConfigError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetCachePolicyConfigError {
    /// <p>Access denied.</p>
    AccessDenied(crate::error::AccessDenied),
    /// <p>The cache policy does not exist.</p>
    NoSuchCachePolicy(crate::error::NoSuchCachePolicy),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for GetCachePolicyConfigError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for GetCachePolicyConfigError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AccessDenied(_inner) => _inner.fmt(f),
            Self::NoSuchCachePolicy(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for GetCachePolicyConfigError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AccessDenied(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NoSuchCachePolicy(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::GetCachePolicyConfigError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetCachePolicyConfigError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetCachePolicyConfigError {
    /// Creates the `GetCachePolicyConfigError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `GetCachePolicyConfigError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AccessDenied(e) => e.meta(),
            Self::NoSuchCachePolicy(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `GetCachePolicyConfigError::AccessDenied`.
    pub fn is_access_denied(&self) -> bool {
        matches!(self, Self::AccessDenied(_))
    }
    /// Returns `true` if the error kind is `GetCachePolicyConfigError::NoSuchCachePolicy`.
    pub fn is_no_such_cache_policy(&self) -> bool {
        matches!(self, Self::NoSuchCachePolicy(_))
    }
}
impl std::error::Error for GetCachePolicyConfigError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AccessDenied(_inner) => Some(_inner),
            Self::NoSuchCachePolicy(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type GetCachePolicyErrorKind = GetCachePolicyError;
/// Error type for the `GetCachePolicyError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetCachePolicyError {
    /// <p>Access denied.</p>
    AccessDenied(crate::error::AccessDenied),
    /// <p>The cache policy does not exist.</p>
    NoSuchCachePolicy(crate::error::NoSuchCachePolicy),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for GetCachePolicyError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for GetCachePolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AccessDenied(_inner) => _inner.fmt(f),
            Self::NoSuchCachePolicy(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for GetCachePolicyError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AccessDenied(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NoSuchCachePolicy(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::GetCachePolicyError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetCachePolicyError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetCachePolicyError {
    /// Creates the `GetCachePolicyError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `GetCachePolicyError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AccessDenied(e) => e.meta(),
            Self::NoSuchCachePolicy(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `GetCachePolicyError::AccessDenied`.
    pub fn is_access_denied(&self) -> bool {
        matches!(self, Self::AccessDenied(_))
    }
    /// Returns `true` if the error kind is `GetCachePolicyError::NoSuchCachePolicy`.
    pub fn is_no_such_cache_policy(&self) -> bool {
        matches!(self, Self::NoSuchCachePolicy(_))
    }
}
impl std::error::Error for GetCachePolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AccessDenied(_inner) => Some(_inner),
            Self::NoSuchCachePolicy(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DescribeFunctionErrorKind = DescribeFunctionError;
/// Error type for the `DescribeFunctionError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeFunctionError {
    /// <p>The function does not exist.</p>
    NoSuchFunctionExists(crate::error::NoSuchFunctionExists),
    /// <p>This operation is not supported in this region.</p>
    UnsupportedOperation(crate::error::UnsupportedOperation),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DescribeFunctionError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DescribeFunctionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::NoSuchFunctionExists(_inner) => _inner.fmt(f),
            Self::UnsupportedOperation(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DescribeFunctionError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::NoSuchFunctionExists(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnsupportedOperation(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DescribeFunctionError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeFunctionError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeFunctionError {
    /// Creates the `DescribeFunctionError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DescribeFunctionError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::NoSuchFunctionExists(e) => e.meta(),
            Self::UnsupportedOperation(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DescribeFunctionError::NoSuchFunctionExists`.
    pub fn is_no_such_function_exists(&self) -> bool {
        matches!(self, Self::NoSuchFunctionExists(_))
    }
    /// Returns `true` if the error kind is `DescribeFunctionError::UnsupportedOperation`.
    pub fn is_unsupported_operation(&self) -> bool {
        matches!(self, Self::UnsupportedOperation(_))
    }
}
impl std::error::Error for DescribeFunctionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::NoSuchFunctionExists(_inner) => Some(_inner),
            Self::UnsupportedOperation(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DeleteStreamingDistributionErrorKind = DeleteStreamingDistributionError;
/// Error type for the `DeleteStreamingDistributionError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteStreamingDistributionError {
    /// <p>Access denied.</p>
    AccessDenied(crate::error::AccessDenied),
    /// <p>The <code>If-Match</code> version is missing or not valid.</p>
    InvalidIfMatchVersion(crate::error::InvalidIfMatchVersion),
    /// <p>The specified streaming distribution does not exist.</p>
    NoSuchStreamingDistribution(crate::error::NoSuchStreamingDistribution),
    /// <p>The precondition in one or more of the request fields evaluated to <code>false</code>.</p>
    PreconditionFailed(crate::error::PreconditionFailed),
    /// <p>The specified CloudFront distribution is not disabled. You must disable the distribution before you can delete it.</p>
    StreamingDistributionNotDisabled(crate::error::StreamingDistributionNotDisabled),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DeleteStreamingDistributionError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DeleteStreamingDistributionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AccessDenied(_inner) => _inner.fmt(f),
            Self::InvalidIfMatchVersion(_inner) => _inner.fmt(f),
            Self::NoSuchStreamingDistribution(_inner) => _inner.fmt(f),
            Self::PreconditionFailed(_inner) => _inner.fmt(f),
            Self::StreamingDistributionNotDisabled(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DeleteStreamingDistributionError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AccessDenied(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidIfMatchVersion(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NoSuchStreamingDistribution(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::PreconditionFailed(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::StreamingDistributionNotDisabled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DeleteStreamingDistributionError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteStreamingDistributionError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteStreamingDistributionError {
    /// Creates the `DeleteStreamingDistributionError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DeleteStreamingDistributionError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AccessDenied(e) => e.meta(),
            Self::InvalidIfMatchVersion(e) => e.meta(),
            Self::NoSuchStreamingDistribution(e) => e.meta(),
            Self::PreconditionFailed(e) => e.meta(),
            Self::StreamingDistributionNotDisabled(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DeleteStreamingDistributionError::AccessDenied`.
    pub fn is_access_denied(&self) -> bool {
        matches!(self, Self::AccessDenied(_))
    }
    /// Returns `true` if the error kind is `DeleteStreamingDistributionError::InvalidIfMatchVersion`.
    pub fn is_invalid_if_match_version(&self) -> bool {
        matches!(self, Self::InvalidIfMatchVersion(_))
    }
    /// Returns `true` if the error kind is `DeleteStreamingDistributionError::NoSuchStreamingDistribution`.
    pub fn is_no_such_streaming_distribution(&self) -> bool {
        matches!(self, Self::NoSuchStreamingDistribution(_))
    }
    /// Returns `true` if the error kind is `DeleteStreamingDistributionError::PreconditionFailed`.
    pub fn is_precondition_failed(&self) -> bool {
        matches!(self, Self::PreconditionFailed(_))
    }
    /// Returns `true` if the error kind is `DeleteStreamingDistributionError::StreamingDistributionNotDisabled`.
    pub fn is_streaming_distribution_not_disabled(&self) -> bool {
        matches!(self, Self::StreamingDistributionNotDisabled(_))
    }
}
impl std::error::Error for DeleteStreamingDistributionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AccessDenied(_inner) => Some(_inner),
            Self::InvalidIfMatchVersion(_inner) => Some(_inner),
            Self::NoSuchStreamingDistribution(_inner) => Some(_inner),
            Self::PreconditionFailed(_inner) => Some(_inner),
            Self::StreamingDistributionNotDisabled(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The specified CloudFront distribution is not disabled. You must disable the distribution before you can delete it.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct StreamingDistributionNotDisabled {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl StreamingDistributionNotDisabled {
    /// Creates a new builder-style object to manufacture [`StreamingDistributionNotDisabled`](crate::error::StreamingDistributionNotDisabled).
    pub fn builder() -> crate::error::streaming_distribution_not_disabled::Builder {
        crate::error::streaming_distribution_not_disabled::Builder::default()
    }
}
/// See [`StreamingDistributionNotDisabled`](crate::error::StreamingDistributionNotDisabled).
pub mod streaming_distribution_not_disabled {

    /// A builder for [`StreamingDistributionNotDisabled`](crate::error::StreamingDistributionNotDisabled).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`StreamingDistributionNotDisabled`](crate::error::StreamingDistributionNotDisabled).
        pub fn build(self) -> crate::error::StreamingDistributionNotDisabled {
            crate::error::StreamingDistributionNotDisabled {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl StreamingDistributionNotDisabled {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for StreamingDistributionNotDisabled {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "StreamingDistributionNotDisabled")?;
        if let Some(inner_103) = &self.message {
            {
                write!(f, ": {}", inner_103)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for StreamingDistributionNotDisabled {}
impl aws_http::request_id::RequestId for crate::error::StreamingDistributionNotDisabled {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for StreamingDistributionNotDisabled {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DeleteResponseHeadersPolicyErrorKind = DeleteResponseHeadersPolicyError;
/// Error type for the `DeleteResponseHeadersPolicyError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteResponseHeadersPolicyError {
    /// <p>Access denied.</p>
    AccessDenied(crate::error::AccessDenied),
    /// <p>You cannot delete a managed policy.</p>
    IllegalDelete(crate::error::IllegalDelete),
    /// <p>The <code>If-Match</code> version is missing or not valid.</p>
    InvalidIfMatchVersion(crate::error::InvalidIfMatchVersion),
    /// <p>The response headers policy does not exist.</p>
    NoSuchResponseHeadersPolicy(crate::error::NoSuchResponseHeadersPolicy),
    /// <p>The precondition in one or more of the request fields evaluated to <code>false</code>.</p>
    PreconditionFailed(crate::error::PreconditionFailed),
    /// <p>Cannot delete the response headers policy because it is attached to one or more cache behaviors in a CloudFront distribution.</p>
    ResponseHeadersPolicyInUse(crate::error::ResponseHeadersPolicyInUse),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DeleteResponseHeadersPolicyError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DeleteResponseHeadersPolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AccessDenied(_inner) => _inner.fmt(f),
            Self::IllegalDelete(_inner) => _inner.fmt(f),
            Self::InvalidIfMatchVersion(_inner) => _inner.fmt(f),
            Self::NoSuchResponseHeadersPolicy(_inner) => _inner.fmt(f),
            Self::PreconditionFailed(_inner) => _inner.fmt(f),
            Self::ResponseHeadersPolicyInUse(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DeleteResponseHeadersPolicyError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AccessDenied(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::IllegalDelete(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidIfMatchVersion(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NoSuchResponseHeadersPolicy(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::PreconditionFailed(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ResponseHeadersPolicyInUse(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DeleteResponseHeadersPolicyError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteResponseHeadersPolicyError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteResponseHeadersPolicyError {
    /// Creates the `DeleteResponseHeadersPolicyError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DeleteResponseHeadersPolicyError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AccessDenied(e) => e.meta(),
            Self::IllegalDelete(e) => e.meta(),
            Self::InvalidIfMatchVersion(e) => e.meta(),
            Self::NoSuchResponseHeadersPolicy(e) => e.meta(),
            Self::PreconditionFailed(e) => e.meta(),
            Self::ResponseHeadersPolicyInUse(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DeleteResponseHeadersPolicyError::AccessDenied`.
    pub fn is_access_denied(&self) -> bool {
        matches!(self, Self::AccessDenied(_))
    }
    /// Returns `true` if the error kind is `DeleteResponseHeadersPolicyError::IllegalDelete`.
    pub fn is_illegal_delete(&self) -> bool {
        matches!(self, Self::IllegalDelete(_))
    }
    /// Returns `true` if the error kind is `DeleteResponseHeadersPolicyError::InvalidIfMatchVersion`.
    pub fn is_invalid_if_match_version(&self) -> bool {
        matches!(self, Self::InvalidIfMatchVersion(_))
    }
    /// Returns `true` if the error kind is `DeleteResponseHeadersPolicyError::NoSuchResponseHeadersPolicy`.
    pub fn is_no_such_response_headers_policy(&self) -> bool {
        matches!(self, Self::NoSuchResponseHeadersPolicy(_))
    }
    /// Returns `true` if the error kind is `DeleteResponseHeadersPolicyError::PreconditionFailed`.
    pub fn is_precondition_failed(&self) -> bool {
        matches!(self, Self::PreconditionFailed(_))
    }
    /// Returns `true` if the error kind is `DeleteResponseHeadersPolicyError::ResponseHeadersPolicyInUse`.
    pub fn is_response_headers_policy_in_use(&self) -> bool {
        matches!(self, Self::ResponseHeadersPolicyInUse(_))
    }
}
impl std::error::Error for DeleteResponseHeadersPolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AccessDenied(_inner) => Some(_inner),
            Self::IllegalDelete(_inner) => Some(_inner),
            Self::InvalidIfMatchVersion(_inner) => Some(_inner),
            Self::NoSuchResponseHeadersPolicy(_inner) => Some(_inner),
            Self::PreconditionFailed(_inner) => Some(_inner),
            Self::ResponseHeadersPolicyInUse(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>Cannot delete the response headers policy because it is attached to one or more cache behaviors in a CloudFront distribution.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ResponseHeadersPolicyInUse {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl ResponseHeadersPolicyInUse {
    /// Creates a new builder-style object to manufacture [`ResponseHeadersPolicyInUse`](crate::error::ResponseHeadersPolicyInUse).
    pub fn builder() -> crate::error::response_headers_policy_in_use::Builder {
        crate::error::response_headers_policy_in_use::Builder::default()
    }
}
/// See [`ResponseHeadersPolicyInUse`](crate::error::ResponseHeadersPolicyInUse).
pub mod response_headers_policy_in_use {

    /// A builder for [`ResponseHeadersPolicyInUse`](crate::error::ResponseHeadersPolicyInUse).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`ResponseHeadersPolicyInUse`](crate::error::ResponseHeadersPolicyInUse).
        pub fn build(self) -> crate::error::ResponseHeadersPolicyInUse {
            crate::error::ResponseHeadersPolicyInUse {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl ResponseHeadersPolicyInUse {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ResponseHeadersPolicyInUse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResponseHeadersPolicyInUse")?;
        if let Some(inner_104) = &self.message {
            {
                write!(f, ": {}", inner_104)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ResponseHeadersPolicyInUse {}
impl aws_http::request_id::RequestId for crate::error::ResponseHeadersPolicyInUse {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ResponseHeadersPolicyInUse {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>You cannot delete a managed policy.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct IllegalDelete {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl IllegalDelete {
    /// Creates a new builder-style object to manufacture [`IllegalDelete`](crate::error::IllegalDelete).
    pub fn builder() -> crate::error::illegal_delete::Builder {
        crate::error::illegal_delete::Builder::default()
    }
}
/// See [`IllegalDelete`](crate::error::IllegalDelete).
pub mod illegal_delete {

    /// A builder for [`IllegalDelete`](crate::error::IllegalDelete).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`IllegalDelete`](crate::error::IllegalDelete).
        pub fn build(self) -> crate::error::IllegalDelete {
            crate::error::IllegalDelete {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl IllegalDelete {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for IllegalDelete {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "IllegalDelete")?;
        if let Some(inner_105) = &self.message {
            {
                write!(f, ": {}", inner_105)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for IllegalDelete {}
impl aws_http::request_id::RequestId for crate::error::IllegalDelete {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for IllegalDelete {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DeleteRealtimeLogConfigErrorKind = DeleteRealtimeLogConfigError;
/// Error type for the `DeleteRealtimeLogConfigError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteRealtimeLogConfigError {
    /// <p>Access denied.</p>
    AccessDenied(crate::error::AccessDenied),
    /// <p>An argument is invalid.</p>
    InvalidArgument(crate::error::InvalidArgument),
    /// <p>The real-time log configuration does not exist.</p>
    NoSuchRealtimeLogConfig(crate::error::NoSuchRealtimeLogConfig),
    /// <p>Cannot delete the real-time log configuration because it is attached to one or more cache behaviors.</p>
    RealtimeLogConfigInUse(crate::error::RealtimeLogConfigInUse),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DeleteRealtimeLogConfigError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DeleteRealtimeLogConfigError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AccessDenied(_inner) => _inner.fmt(f),
            Self::InvalidArgument(_inner) => _inner.fmt(f),
            Self::NoSuchRealtimeLogConfig(_inner) => _inner.fmt(f),
            Self::RealtimeLogConfigInUse(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DeleteRealtimeLogConfigError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AccessDenied(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidArgument(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NoSuchRealtimeLogConfig(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RealtimeLogConfigInUse(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DeleteRealtimeLogConfigError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteRealtimeLogConfigError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteRealtimeLogConfigError {
    /// Creates the `DeleteRealtimeLogConfigError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DeleteRealtimeLogConfigError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AccessDenied(e) => e.meta(),
            Self::InvalidArgument(e) => e.meta(),
            Self::NoSuchRealtimeLogConfig(e) => e.meta(),
            Self::RealtimeLogConfigInUse(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DeleteRealtimeLogConfigError::AccessDenied`.
    pub fn is_access_denied(&self) -> bool {
        matches!(self, Self::AccessDenied(_))
    }
    /// Returns `true` if the error kind is `DeleteRealtimeLogConfigError::InvalidArgument`.
    pub fn is_invalid_argument(&self) -> bool {
        matches!(self, Self::InvalidArgument(_))
    }
    /// Returns `true` if the error kind is `DeleteRealtimeLogConfigError::NoSuchRealtimeLogConfig`.
    pub fn is_no_such_realtime_log_config(&self) -> bool {
        matches!(self, Self::NoSuchRealtimeLogConfig(_))
    }
    /// Returns `true` if the error kind is `DeleteRealtimeLogConfigError::RealtimeLogConfigInUse`.
    pub fn is_realtime_log_config_in_use(&self) -> bool {
        matches!(self, Self::RealtimeLogConfigInUse(_))
    }
}
impl std::error::Error for DeleteRealtimeLogConfigError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AccessDenied(_inner) => Some(_inner),
            Self::InvalidArgument(_inner) => Some(_inner),
            Self::NoSuchRealtimeLogConfig(_inner) => Some(_inner),
            Self::RealtimeLogConfigInUse(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>Cannot delete the real-time log configuration because it is attached to one or more cache behaviors.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RealtimeLogConfigInUse {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl RealtimeLogConfigInUse {
    /// Creates a new builder-style object to manufacture [`RealtimeLogConfigInUse`](crate::error::RealtimeLogConfigInUse).
    pub fn builder() -> crate::error::realtime_log_config_in_use::Builder {
        crate::error::realtime_log_config_in_use::Builder::default()
    }
}
/// See [`RealtimeLogConfigInUse`](crate::error::RealtimeLogConfigInUse).
pub mod realtime_log_config_in_use {

    /// A builder for [`RealtimeLogConfigInUse`](crate::error::RealtimeLogConfigInUse).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`RealtimeLogConfigInUse`](crate::error::RealtimeLogConfigInUse).
        pub fn build(self) -> crate::error::RealtimeLogConfigInUse {
            crate::error::RealtimeLogConfigInUse {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl RealtimeLogConfigInUse {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for RealtimeLogConfigInUse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "RealtimeLogConfigInUse")?;
        if let Some(inner_106) = &self.message {
            {
                write!(f, ": {}", inner_106)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for RealtimeLogConfigInUse {}
impl aws_http::request_id::RequestId for crate::error::RealtimeLogConfigInUse {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for RealtimeLogConfigInUse {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DeletePublicKeyErrorKind = DeletePublicKeyError;
/// Error type for the `DeletePublicKeyError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeletePublicKeyError {
    /// <p>Access denied.</p>
    AccessDenied(crate::error::AccessDenied),
    /// <p>The <code>If-Match</code> version is missing or not valid.</p>
    InvalidIfMatchVersion(crate::error::InvalidIfMatchVersion),
    /// <p>The specified public key doesn't exist.</p>
    NoSuchPublicKey(crate::error::NoSuchPublicKey),
    /// <p>The precondition in one or more of the request fields evaluated to <code>false</code>.</p>
    PreconditionFailed(crate::error::PreconditionFailed),
    /// <p>The specified public key is in use.</p>
    PublicKeyInUse(crate::error::PublicKeyInUse),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DeletePublicKeyError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DeletePublicKeyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AccessDenied(_inner) => _inner.fmt(f),
            Self::InvalidIfMatchVersion(_inner) => _inner.fmt(f),
            Self::NoSuchPublicKey(_inner) => _inner.fmt(f),
            Self::PreconditionFailed(_inner) => _inner.fmt(f),
            Self::PublicKeyInUse(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DeletePublicKeyError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AccessDenied(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidIfMatchVersion(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NoSuchPublicKey(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::PreconditionFailed(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::PublicKeyInUse(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DeletePublicKeyError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeletePublicKeyError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeletePublicKeyError {
    /// Creates the `DeletePublicKeyError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DeletePublicKeyError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AccessDenied(e) => e.meta(),
            Self::InvalidIfMatchVersion(e) => e.meta(),
            Self::NoSuchPublicKey(e) => e.meta(),
            Self::PreconditionFailed(e) => e.meta(),
            Self::PublicKeyInUse(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DeletePublicKeyError::AccessDenied`.
    pub fn is_access_denied(&self) -> bool {
        matches!(self, Self::AccessDenied(_))
    }
    /// Returns `true` if the error kind is `DeletePublicKeyError::InvalidIfMatchVersion`.
    pub fn is_invalid_if_match_version(&self) -> bool {
        matches!(self, Self::InvalidIfMatchVersion(_))
    }
    /// Returns `true` if the error kind is `DeletePublicKeyError::NoSuchPublicKey`.
    pub fn is_no_such_public_key(&self) -> bool {
        matches!(self, Self::NoSuchPublicKey(_))
    }
    /// Returns `true` if the error kind is `DeletePublicKeyError::PreconditionFailed`.
    pub fn is_precondition_failed(&self) -> bool {
        matches!(self, Self::PreconditionFailed(_))
    }
    /// Returns `true` if the error kind is `DeletePublicKeyError::PublicKeyInUse`.
    pub fn is_public_key_in_use(&self) -> bool {
        matches!(self, Self::PublicKeyInUse(_))
    }
}
impl std::error::Error for DeletePublicKeyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AccessDenied(_inner) => Some(_inner),
            Self::InvalidIfMatchVersion(_inner) => Some(_inner),
            Self::NoSuchPublicKey(_inner) => Some(_inner),
            Self::PreconditionFailed(_inner) => Some(_inner),
            Self::PublicKeyInUse(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The specified public key is in use.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PublicKeyInUse {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl PublicKeyInUse {
    /// Creates a new builder-style object to manufacture [`PublicKeyInUse`](crate::error::PublicKeyInUse).
    pub fn builder() -> crate::error::public_key_in_use::Builder {
        crate::error::public_key_in_use::Builder::default()
    }
}
/// See [`PublicKeyInUse`](crate::error::PublicKeyInUse).
pub mod public_key_in_use {

    /// A builder for [`PublicKeyInUse`](crate::error::PublicKeyInUse).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`PublicKeyInUse`](crate::error::PublicKeyInUse).
        pub fn build(self) -> crate::error::PublicKeyInUse {
            crate::error::PublicKeyInUse {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl PublicKeyInUse {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for PublicKeyInUse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "PublicKeyInUse")?;
        if let Some(inner_107) = &self.message {
            {
                write!(f, ": {}", inner_107)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for PublicKeyInUse {}
impl aws_http::request_id::RequestId for crate::error::PublicKeyInUse {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for PublicKeyInUse {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DeleteOriginRequestPolicyErrorKind = DeleteOriginRequestPolicyError;
/// Error type for the `DeleteOriginRequestPolicyError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteOriginRequestPolicyError {
    /// <p>Access denied.</p>
    AccessDenied(crate::error::AccessDenied),
    /// <p>You cannot delete a managed policy.</p>
    IllegalDelete(crate::error::IllegalDelete),
    /// <p>The <code>If-Match</code> version is missing or not valid.</p>
    InvalidIfMatchVersion(crate::error::InvalidIfMatchVersion),
    /// <p>The origin request policy does not exist.</p>
    NoSuchOriginRequestPolicy(crate::error::NoSuchOriginRequestPolicy),
    /// <p>Cannot delete the origin request policy because it is attached to one or more cache behaviors.</p>
    OriginRequestPolicyInUse(crate::error::OriginRequestPolicyInUse),
    /// <p>The precondition in one or more of the request fields evaluated to <code>false</code>.</p>
    PreconditionFailed(crate::error::PreconditionFailed),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DeleteOriginRequestPolicyError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DeleteOriginRequestPolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AccessDenied(_inner) => _inner.fmt(f),
            Self::IllegalDelete(_inner) => _inner.fmt(f),
            Self::InvalidIfMatchVersion(_inner) => _inner.fmt(f),
            Self::NoSuchOriginRequestPolicy(_inner) => _inner.fmt(f),
            Self::OriginRequestPolicyInUse(_inner) => _inner.fmt(f),
            Self::PreconditionFailed(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DeleteOriginRequestPolicyError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AccessDenied(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::IllegalDelete(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidIfMatchVersion(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NoSuchOriginRequestPolicy(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::OriginRequestPolicyInUse(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::PreconditionFailed(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DeleteOriginRequestPolicyError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteOriginRequestPolicyError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteOriginRequestPolicyError {
    /// Creates the `DeleteOriginRequestPolicyError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DeleteOriginRequestPolicyError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AccessDenied(e) => e.meta(),
            Self::IllegalDelete(e) => e.meta(),
            Self::InvalidIfMatchVersion(e) => e.meta(),
            Self::NoSuchOriginRequestPolicy(e) => e.meta(),
            Self::OriginRequestPolicyInUse(e) => e.meta(),
            Self::PreconditionFailed(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DeleteOriginRequestPolicyError::AccessDenied`.
    pub fn is_access_denied(&self) -> bool {
        matches!(self, Self::AccessDenied(_))
    }
    /// Returns `true` if the error kind is `DeleteOriginRequestPolicyError::IllegalDelete`.
    pub fn is_illegal_delete(&self) -> bool {
        matches!(self, Self::IllegalDelete(_))
    }
    /// Returns `true` if the error kind is `DeleteOriginRequestPolicyError::InvalidIfMatchVersion`.
    pub fn is_invalid_if_match_version(&self) -> bool {
        matches!(self, Self::InvalidIfMatchVersion(_))
    }
    /// Returns `true` if the error kind is `DeleteOriginRequestPolicyError::NoSuchOriginRequestPolicy`.
    pub fn is_no_such_origin_request_policy(&self) -> bool {
        matches!(self, Self::NoSuchOriginRequestPolicy(_))
    }
    /// Returns `true` if the error kind is `DeleteOriginRequestPolicyError::OriginRequestPolicyInUse`.
    pub fn is_origin_request_policy_in_use(&self) -> bool {
        matches!(self, Self::OriginRequestPolicyInUse(_))
    }
    /// Returns `true` if the error kind is `DeleteOriginRequestPolicyError::PreconditionFailed`.
    pub fn is_precondition_failed(&self) -> bool {
        matches!(self, Self::PreconditionFailed(_))
    }
}
impl std::error::Error for DeleteOriginRequestPolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AccessDenied(_inner) => Some(_inner),
            Self::IllegalDelete(_inner) => Some(_inner),
            Self::InvalidIfMatchVersion(_inner) => Some(_inner),
            Self::NoSuchOriginRequestPolicy(_inner) => Some(_inner),
            Self::OriginRequestPolicyInUse(_inner) => Some(_inner),
            Self::PreconditionFailed(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>Cannot delete the origin request policy because it is attached to one or more cache behaviors.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct OriginRequestPolicyInUse {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl OriginRequestPolicyInUse {
    /// Creates a new builder-style object to manufacture [`OriginRequestPolicyInUse`](crate::error::OriginRequestPolicyInUse).
    pub fn builder() -> crate::error::origin_request_policy_in_use::Builder {
        crate::error::origin_request_policy_in_use::Builder::default()
    }
}
/// See [`OriginRequestPolicyInUse`](crate::error::OriginRequestPolicyInUse).
pub mod origin_request_policy_in_use {

    /// A builder for [`OriginRequestPolicyInUse`](crate::error::OriginRequestPolicyInUse).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`OriginRequestPolicyInUse`](crate::error::OriginRequestPolicyInUse).
        pub fn build(self) -> crate::error::OriginRequestPolicyInUse {
            crate::error::OriginRequestPolicyInUse {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl OriginRequestPolicyInUse {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for OriginRequestPolicyInUse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "OriginRequestPolicyInUse")?;
        if let Some(inner_108) = &self.message {
            {
                write!(f, ": {}", inner_108)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for OriginRequestPolicyInUse {}
impl aws_http::request_id::RequestId for crate::error::OriginRequestPolicyInUse {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for OriginRequestPolicyInUse {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DeleteOriginAccessControlErrorKind = DeleteOriginAccessControlError;
/// Error type for the `DeleteOriginAccessControlError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteOriginAccessControlError {
    /// <p>Access denied.</p>
    AccessDenied(crate::error::AccessDenied),
    /// <p>The <code>If-Match</code> version is missing or not valid.</p>
    InvalidIfMatchVersion(crate::error::InvalidIfMatchVersion),
    /// <p>The origin access control does not exist.</p>
    NoSuchOriginAccessControl(crate::error::NoSuchOriginAccessControl),
    /// <p>Cannot delete the origin access control because it's in use by one or more distributions.</p>
    OriginAccessControlInUse(crate::error::OriginAccessControlInUse),
    /// <p>The precondition in one or more of the request fields evaluated to <code>false</code>.</p>
    PreconditionFailed(crate::error::PreconditionFailed),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DeleteOriginAccessControlError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DeleteOriginAccessControlError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AccessDenied(_inner) => _inner.fmt(f),
            Self::InvalidIfMatchVersion(_inner) => _inner.fmt(f),
            Self::NoSuchOriginAccessControl(_inner) => _inner.fmt(f),
            Self::OriginAccessControlInUse(_inner) => _inner.fmt(f),
            Self::PreconditionFailed(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DeleteOriginAccessControlError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AccessDenied(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidIfMatchVersion(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NoSuchOriginAccessControl(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::OriginAccessControlInUse(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::PreconditionFailed(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DeleteOriginAccessControlError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteOriginAccessControlError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteOriginAccessControlError {
    /// Creates the `DeleteOriginAccessControlError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DeleteOriginAccessControlError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AccessDenied(e) => e.meta(),
            Self::InvalidIfMatchVersion(e) => e.meta(),
            Self::NoSuchOriginAccessControl(e) => e.meta(),
            Self::OriginAccessControlInUse(e) => e.meta(),
            Self::PreconditionFailed(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DeleteOriginAccessControlError::AccessDenied`.
    pub fn is_access_denied(&self) -> bool {
        matches!(self, Self::AccessDenied(_))
    }
    /// Returns `true` if the error kind is `DeleteOriginAccessControlError::InvalidIfMatchVersion`.
    pub fn is_invalid_if_match_version(&self) -> bool {
        matches!(self, Self::InvalidIfMatchVersion(_))
    }
    /// Returns `true` if the error kind is `DeleteOriginAccessControlError::NoSuchOriginAccessControl`.
    pub fn is_no_such_origin_access_control(&self) -> bool {
        matches!(self, Self::NoSuchOriginAccessControl(_))
    }
    /// Returns `true` if the error kind is `DeleteOriginAccessControlError::OriginAccessControlInUse`.
    pub fn is_origin_access_control_in_use(&self) -> bool {
        matches!(self, Self::OriginAccessControlInUse(_))
    }
    /// Returns `true` if the error kind is `DeleteOriginAccessControlError::PreconditionFailed`.
    pub fn is_precondition_failed(&self) -> bool {
        matches!(self, Self::PreconditionFailed(_))
    }
}
impl std::error::Error for DeleteOriginAccessControlError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AccessDenied(_inner) => Some(_inner),
            Self::InvalidIfMatchVersion(_inner) => Some(_inner),
            Self::NoSuchOriginAccessControl(_inner) => Some(_inner),
            Self::OriginAccessControlInUse(_inner) => Some(_inner),
            Self::PreconditionFailed(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>Cannot delete the origin access control because it's in use by one or more distributions.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct OriginAccessControlInUse {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl OriginAccessControlInUse {
    /// Creates a new builder-style object to manufacture [`OriginAccessControlInUse`](crate::error::OriginAccessControlInUse).
    pub fn builder() -> crate::error::origin_access_control_in_use::Builder {
        crate::error::origin_access_control_in_use::Builder::default()
    }
}
/// See [`OriginAccessControlInUse`](crate::error::OriginAccessControlInUse).
pub mod origin_access_control_in_use {

    /// A builder for [`OriginAccessControlInUse`](crate::error::OriginAccessControlInUse).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`OriginAccessControlInUse`](crate::error::OriginAccessControlInUse).
        pub fn build(self) -> crate::error::OriginAccessControlInUse {
            crate::error::OriginAccessControlInUse {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl OriginAccessControlInUse {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for OriginAccessControlInUse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "OriginAccessControlInUse")?;
        if let Some(inner_109) = &self.message {
            {
                write!(f, ": {}", inner_109)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for OriginAccessControlInUse {}
impl aws_http::request_id::RequestId for crate::error::OriginAccessControlInUse {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for OriginAccessControlInUse {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DeleteMonitoringSubscriptionErrorKind = DeleteMonitoringSubscriptionError;
/// Error type for the `DeleteMonitoringSubscriptionError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteMonitoringSubscriptionError {
    /// <p>Access denied.</p>
    AccessDenied(crate::error::AccessDenied),
    /// <p>The specified distribution does not exist.</p>
    NoSuchDistribution(crate::error::NoSuchDistribution),
    /// <p>A monitoring subscription does not exist for the specified distribution.</p>
    NoSuchMonitoringSubscription(crate::error::NoSuchMonitoringSubscription),
    /// <p>This operation is not supported in this region.</p>
    UnsupportedOperation(crate::error::UnsupportedOperation),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DeleteMonitoringSubscriptionError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DeleteMonitoringSubscriptionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AccessDenied(_inner) => _inner.fmt(f),
            Self::NoSuchDistribution(_inner) => _inner.fmt(f),
            Self::NoSuchMonitoringSubscription(_inner) => _inner.fmt(f),
            Self::UnsupportedOperation(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DeleteMonitoringSubscriptionError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AccessDenied(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NoSuchDistribution(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NoSuchMonitoringSubscription(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnsupportedOperation(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DeleteMonitoringSubscriptionError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteMonitoringSubscriptionError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteMonitoringSubscriptionError {
    /// Creates the `DeleteMonitoringSubscriptionError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DeleteMonitoringSubscriptionError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AccessDenied(e) => e.meta(),
            Self::NoSuchDistribution(e) => e.meta(),
            Self::NoSuchMonitoringSubscription(e) => e.meta(),
            Self::UnsupportedOperation(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DeleteMonitoringSubscriptionError::AccessDenied`.
    pub fn is_access_denied(&self) -> bool {
        matches!(self, Self::AccessDenied(_))
    }
    /// Returns `true` if the error kind is `DeleteMonitoringSubscriptionError::NoSuchDistribution`.
    pub fn is_no_such_distribution(&self) -> bool {
        matches!(self, Self::NoSuchDistribution(_))
    }
    /// Returns `true` if the error kind is `DeleteMonitoringSubscriptionError::NoSuchMonitoringSubscription`.
    pub fn is_no_such_monitoring_subscription(&self) -> bool {
        matches!(self, Self::NoSuchMonitoringSubscription(_))
    }
    /// Returns `true` if the error kind is `DeleteMonitoringSubscriptionError::UnsupportedOperation`.
    pub fn is_unsupported_operation(&self) -> bool {
        matches!(self, Self::UnsupportedOperation(_))
    }
}
impl std::error::Error for DeleteMonitoringSubscriptionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AccessDenied(_inner) => Some(_inner),
            Self::NoSuchDistribution(_inner) => Some(_inner),
            Self::NoSuchMonitoringSubscription(_inner) => Some(_inner),
            Self::UnsupportedOperation(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DeleteKeyGroupErrorKind = DeleteKeyGroupError;
/// Error type for the `DeleteKeyGroupError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteKeyGroupError {
    /// <p>The <code>If-Match</code> version is missing or not valid.</p>
    InvalidIfMatchVersion(crate::error::InvalidIfMatchVersion),
    /// <p>A resource that was specified is not valid.</p>
    NoSuchResource(crate::error::NoSuchResource),
    /// <p>The precondition in one or more of the request fields evaluated to <code>false</code>.</p>
    PreconditionFailed(crate::error::PreconditionFailed),
    /// <p>Cannot delete this resource because it is in use.</p>
    ResourceInUse(crate::error::ResourceInUse),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DeleteKeyGroupError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DeleteKeyGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::InvalidIfMatchVersion(_inner) => _inner.fmt(f),
            Self::NoSuchResource(_inner) => _inner.fmt(f),
            Self::PreconditionFailed(_inner) => _inner.fmt(f),
            Self::ResourceInUse(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DeleteKeyGroupError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::InvalidIfMatchVersion(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NoSuchResource(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::PreconditionFailed(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ResourceInUse(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DeleteKeyGroupError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteKeyGroupError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteKeyGroupError {
    /// Creates the `DeleteKeyGroupError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DeleteKeyGroupError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::InvalidIfMatchVersion(e) => e.meta(),
            Self::NoSuchResource(e) => e.meta(),
            Self::PreconditionFailed(e) => e.meta(),
            Self::ResourceInUse(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DeleteKeyGroupError::InvalidIfMatchVersion`.
    pub fn is_invalid_if_match_version(&self) -> bool {
        matches!(self, Self::InvalidIfMatchVersion(_))
    }
    /// Returns `true` if the error kind is `DeleteKeyGroupError::NoSuchResource`.
    pub fn is_no_such_resource(&self) -> bool {
        matches!(self, Self::NoSuchResource(_))
    }
    /// Returns `true` if the error kind is `DeleteKeyGroupError::PreconditionFailed`.
    pub fn is_precondition_failed(&self) -> bool {
        matches!(self, Self::PreconditionFailed(_))
    }
    /// Returns `true` if the error kind is `DeleteKeyGroupError::ResourceInUse`.
    pub fn is_resource_in_use(&self) -> bool {
        matches!(self, Self::ResourceInUse(_))
    }
}
impl std::error::Error for DeleteKeyGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::InvalidIfMatchVersion(_inner) => Some(_inner),
            Self::NoSuchResource(_inner) => Some(_inner),
            Self::PreconditionFailed(_inner) => Some(_inner),
            Self::ResourceInUse(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>Cannot delete this resource because it is in use.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ResourceInUse {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl ResourceInUse {
    /// Creates a new builder-style object to manufacture [`ResourceInUse`](crate::error::ResourceInUse).
    pub fn builder() -> crate::error::resource_in_use::Builder {
        crate::error::resource_in_use::Builder::default()
    }
}
/// See [`ResourceInUse`](crate::error::ResourceInUse).
pub mod resource_in_use {

    /// A builder for [`ResourceInUse`](crate::error::ResourceInUse).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`ResourceInUse`](crate::error::ResourceInUse).
        pub fn build(self) -> crate::error::ResourceInUse {
            crate::error::ResourceInUse {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl ResourceInUse {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ResourceInUse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResourceInUse")?;
        if let Some(inner_110) = &self.message {
            {
                write!(f, ": {}", inner_110)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ResourceInUse {}
impl aws_http::request_id::RequestId for crate::error::ResourceInUse {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ResourceInUse {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DeleteFunctionErrorKind = DeleteFunctionError;
/// Error type for the `DeleteFunctionError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteFunctionError {
    /// <p>Cannot delete the function because it's attached to one or more cache behaviors.</p>
    FunctionInUse(crate::error::FunctionInUse),
    /// <p>The <code>If-Match</code> version is missing or not valid.</p>
    InvalidIfMatchVersion(crate::error::InvalidIfMatchVersion),
    /// <p>The function does not exist.</p>
    NoSuchFunctionExists(crate::error::NoSuchFunctionExists),
    /// <p>The precondition in one or more of the request fields evaluated to <code>false</code>.</p>
    PreconditionFailed(crate::error::PreconditionFailed),
    /// <p>This operation is not supported in this region.</p>
    UnsupportedOperation(crate::error::UnsupportedOperation),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DeleteFunctionError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DeleteFunctionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::FunctionInUse(_inner) => _inner.fmt(f),
            Self::InvalidIfMatchVersion(_inner) => _inner.fmt(f),
            Self::NoSuchFunctionExists(_inner) => _inner.fmt(f),
            Self::PreconditionFailed(_inner) => _inner.fmt(f),
            Self::UnsupportedOperation(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DeleteFunctionError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::FunctionInUse(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidIfMatchVersion(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NoSuchFunctionExists(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::PreconditionFailed(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnsupportedOperation(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DeleteFunctionError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteFunctionError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteFunctionError {
    /// Creates the `DeleteFunctionError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DeleteFunctionError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::FunctionInUse(e) => e.meta(),
            Self::InvalidIfMatchVersion(e) => e.meta(),
            Self::NoSuchFunctionExists(e) => e.meta(),
            Self::PreconditionFailed(e) => e.meta(),
            Self::UnsupportedOperation(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DeleteFunctionError::FunctionInUse`.
    pub fn is_function_in_use(&self) -> bool {
        matches!(self, Self::FunctionInUse(_))
    }
    /// Returns `true` if the error kind is `DeleteFunctionError::InvalidIfMatchVersion`.
    pub fn is_invalid_if_match_version(&self) -> bool {
        matches!(self, Self::InvalidIfMatchVersion(_))
    }
    /// Returns `true` if the error kind is `DeleteFunctionError::NoSuchFunctionExists`.
    pub fn is_no_such_function_exists(&self) -> bool {
        matches!(self, Self::NoSuchFunctionExists(_))
    }
    /// Returns `true` if the error kind is `DeleteFunctionError::PreconditionFailed`.
    pub fn is_precondition_failed(&self) -> bool {
        matches!(self, Self::PreconditionFailed(_))
    }
    /// Returns `true` if the error kind is `DeleteFunctionError::UnsupportedOperation`.
    pub fn is_unsupported_operation(&self) -> bool {
        matches!(self, Self::UnsupportedOperation(_))
    }
}
impl std::error::Error for DeleteFunctionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::FunctionInUse(_inner) => Some(_inner),
            Self::InvalidIfMatchVersion(_inner) => Some(_inner),
            Self::NoSuchFunctionExists(_inner) => Some(_inner),
            Self::PreconditionFailed(_inner) => Some(_inner),
            Self::UnsupportedOperation(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>Cannot delete the function because it's attached to one or more cache behaviors.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FunctionInUse {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl FunctionInUse {
    /// Creates a new builder-style object to manufacture [`FunctionInUse`](crate::error::FunctionInUse).
    pub fn builder() -> crate::error::function_in_use::Builder {
        crate::error::function_in_use::Builder::default()
    }
}
/// See [`FunctionInUse`](crate::error::FunctionInUse).
pub mod function_in_use {

    /// A builder for [`FunctionInUse`](crate::error::FunctionInUse).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`FunctionInUse`](crate::error::FunctionInUse).
        pub fn build(self) -> crate::error::FunctionInUse {
            crate::error::FunctionInUse {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl FunctionInUse {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for FunctionInUse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "FunctionInUse")?;
        if let Some(inner_111) = &self.message {
            {
                write!(f, ": {}", inner_111)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for FunctionInUse {}
impl aws_http::request_id::RequestId for crate::error::FunctionInUse {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for FunctionInUse {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DeleteFieldLevelEncryptionProfileErrorKind = DeleteFieldLevelEncryptionProfileError;
/// Error type for the `DeleteFieldLevelEncryptionProfileError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteFieldLevelEncryptionProfileError {
    /// <p>Access denied.</p>
    AccessDenied(crate::error::AccessDenied),
    /// <p>The specified profile for field-level encryption is in use.</p>
    FieldLevelEncryptionProfileInUse(crate::error::FieldLevelEncryptionProfileInUse),
    /// <p>The <code>If-Match</code> version is missing or not valid.</p>
    InvalidIfMatchVersion(crate::error::InvalidIfMatchVersion),
    /// <p>The specified profile for field-level encryption doesn't exist.</p>
    NoSuchFieldLevelEncryptionProfile(crate::error::NoSuchFieldLevelEncryptionProfile),
    /// <p>The precondition in one or more of the request fields evaluated to <code>false</code>.</p>
    PreconditionFailed(crate::error::PreconditionFailed),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DeleteFieldLevelEncryptionProfileError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DeleteFieldLevelEncryptionProfileError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AccessDenied(_inner) => _inner.fmt(f),
            Self::FieldLevelEncryptionProfileInUse(_inner) => _inner.fmt(f),
            Self::InvalidIfMatchVersion(_inner) => _inner.fmt(f),
            Self::NoSuchFieldLevelEncryptionProfile(_inner) => _inner.fmt(f),
            Self::PreconditionFailed(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for DeleteFieldLevelEncryptionProfileError
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AccessDenied(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::FieldLevelEncryptionProfileInUse(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidIfMatchVersion(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NoSuchFieldLevelEncryptionProfile(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::PreconditionFailed(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DeleteFieldLevelEncryptionProfileError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteFieldLevelEncryptionProfileError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteFieldLevelEncryptionProfileError {
    /// Creates the `DeleteFieldLevelEncryptionProfileError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DeleteFieldLevelEncryptionProfileError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AccessDenied(e) => e.meta(),
            Self::FieldLevelEncryptionProfileInUse(e) => e.meta(),
            Self::InvalidIfMatchVersion(e) => e.meta(),
            Self::NoSuchFieldLevelEncryptionProfile(e) => e.meta(),
            Self::PreconditionFailed(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DeleteFieldLevelEncryptionProfileError::AccessDenied`.
    pub fn is_access_denied(&self) -> bool {
        matches!(self, Self::AccessDenied(_))
    }
    /// Returns `true` if the error kind is `DeleteFieldLevelEncryptionProfileError::FieldLevelEncryptionProfileInUse`.
    pub fn is_field_level_encryption_profile_in_use(&self) -> bool {
        matches!(self, Self::FieldLevelEncryptionProfileInUse(_))
    }
    /// Returns `true` if the error kind is `DeleteFieldLevelEncryptionProfileError::InvalidIfMatchVersion`.
    pub fn is_invalid_if_match_version(&self) -> bool {
        matches!(self, Self::InvalidIfMatchVersion(_))
    }
    /// Returns `true` if the error kind is `DeleteFieldLevelEncryptionProfileError::NoSuchFieldLevelEncryptionProfile`.
    pub fn is_no_such_field_level_encryption_profile(&self) -> bool {
        matches!(self, Self::NoSuchFieldLevelEncryptionProfile(_))
    }
    /// Returns `true` if the error kind is `DeleteFieldLevelEncryptionProfileError::PreconditionFailed`.
    pub fn is_precondition_failed(&self) -> bool {
        matches!(self, Self::PreconditionFailed(_))
    }
}
impl std::error::Error for DeleteFieldLevelEncryptionProfileError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AccessDenied(_inner) => Some(_inner),
            Self::FieldLevelEncryptionProfileInUse(_inner) => Some(_inner),
            Self::InvalidIfMatchVersion(_inner) => Some(_inner),
            Self::NoSuchFieldLevelEncryptionProfile(_inner) => Some(_inner),
            Self::PreconditionFailed(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The specified profile for field-level encryption is in use.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FieldLevelEncryptionProfileInUse {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl FieldLevelEncryptionProfileInUse {
    /// Creates a new builder-style object to manufacture [`FieldLevelEncryptionProfileInUse`](crate::error::FieldLevelEncryptionProfileInUse).
    pub fn builder() -> crate::error::field_level_encryption_profile_in_use::Builder {
        crate::error::field_level_encryption_profile_in_use::Builder::default()
    }
}
/// See [`FieldLevelEncryptionProfileInUse`](crate::error::FieldLevelEncryptionProfileInUse).
pub mod field_level_encryption_profile_in_use {

    /// A builder for [`FieldLevelEncryptionProfileInUse`](crate::error::FieldLevelEncryptionProfileInUse).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`FieldLevelEncryptionProfileInUse`](crate::error::FieldLevelEncryptionProfileInUse).
        pub fn build(self) -> crate::error::FieldLevelEncryptionProfileInUse {
            crate::error::FieldLevelEncryptionProfileInUse {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl FieldLevelEncryptionProfileInUse {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for FieldLevelEncryptionProfileInUse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "FieldLevelEncryptionProfileInUse")?;
        if let Some(inner_112) = &self.message {
            {
                write!(f, ": {}", inner_112)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for FieldLevelEncryptionProfileInUse {}
impl aws_http::request_id::RequestId for crate::error::FieldLevelEncryptionProfileInUse {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for FieldLevelEncryptionProfileInUse {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DeleteFieldLevelEncryptionConfigErrorKind = DeleteFieldLevelEncryptionConfigError;
/// Error type for the `DeleteFieldLevelEncryptionConfigError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteFieldLevelEncryptionConfigError {
    /// <p>Access denied.</p>
    AccessDenied(crate::error::AccessDenied),
    /// <p>The specified configuration for field-level encryption is in use.</p>
    FieldLevelEncryptionConfigInUse(crate::error::FieldLevelEncryptionConfigInUse),
    /// <p>The <code>If-Match</code> version is missing or not valid.</p>
    InvalidIfMatchVersion(crate::error::InvalidIfMatchVersion),
    /// <p>The specified configuration for field-level encryption doesn't exist.</p>
    NoSuchFieldLevelEncryptionConfig(crate::error::NoSuchFieldLevelEncryptionConfig),
    /// <p>The precondition in one or more of the request fields evaluated to <code>false</code>.</p>
    PreconditionFailed(crate::error::PreconditionFailed),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DeleteFieldLevelEncryptionConfigError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DeleteFieldLevelEncryptionConfigError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AccessDenied(_inner) => _inner.fmt(f),
            Self::FieldLevelEncryptionConfigInUse(_inner) => _inner.fmt(f),
            Self::InvalidIfMatchVersion(_inner) => _inner.fmt(f),
            Self::NoSuchFieldLevelEncryptionConfig(_inner) => _inner.fmt(f),
            Self::PreconditionFailed(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for DeleteFieldLevelEncryptionConfigError
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AccessDenied(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::FieldLevelEncryptionConfigInUse(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidIfMatchVersion(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NoSuchFieldLevelEncryptionConfig(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::PreconditionFailed(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DeleteFieldLevelEncryptionConfigError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteFieldLevelEncryptionConfigError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteFieldLevelEncryptionConfigError {
    /// Creates the `DeleteFieldLevelEncryptionConfigError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DeleteFieldLevelEncryptionConfigError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AccessDenied(e) => e.meta(),
            Self::FieldLevelEncryptionConfigInUse(e) => e.meta(),
            Self::InvalidIfMatchVersion(e) => e.meta(),
            Self::NoSuchFieldLevelEncryptionConfig(e) => e.meta(),
            Self::PreconditionFailed(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DeleteFieldLevelEncryptionConfigError::AccessDenied`.
    pub fn is_access_denied(&self) -> bool {
        matches!(self, Self::AccessDenied(_))
    }
    /// Returns `true` if the error kind is `DeleteFieldLevelEncryptionConfigError::FieldLevelEncryptionConfigInUse`.
    pub fn is_field_level_encryption_config_in_use(&self) -> bool {
        matches!(self, Self::FieldLevelEncryptionConfigInUse(_))
    }
    /// Returns `true` if the error kind is `DeleteFieldLevelEncryptionConfigError::InvalidIfMatchVersion`.
    pub fn is_invalid_if_match_version(&self) -> bool {
        matches!(self, Self::InvalidIfMatchVersion(_))
    }
    /// Returns `true` if the error kind is `DeleteFieldLevelEncryptionConfigError::NoSuchFieldLevelEncryptionConfig`.
    pub fn is_no_such_field_level_encryption_config(&self) -> bool {
        matches!(self, Self::NoSuchFieldLevelEncryptionConfig(_))
    }
    /// Returns `true` if the error kind is `DeleteFieldLevelEncryptionConfigError::PreconditionFailed`.
    pub fn is_precondition_failed(&self) -> bool {
        matches!(self, Self::PreconditionFailed(_))
    }
}
impl std::error::Error for DeleteFieldLevelEncryptionConfigError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AccessDenied(_inner) => Some(_inner),
            Self::FieldLevelEncryptionConfigInUse(_inner) => Some(_inner),
            Self::InvalidIfMatchVersion(_inner) => Some(_inner),
            Self::NoSuchFieldLevelEncryptionConfig(_inner) => Some(_inner),
            Self::PreconditionFailed(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The specified configuration for field-level encryption is in use.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FieldLevelEncryptionConfigInUse {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl FieldLevelEncryptionConfigInUse {
    /// Creates a new builder-style object to manufacture [`FieldLevelEncryptionConfigInUse`](crate::error::FieldLevelEncryptionConfigInUse).
    pub fn builder() -> crate::error::field_level_encryption_config_in_use::Builder {
        crate::error::field_level_encryption_config_in_use::Builder::default()
    }
}
/// See [`FieldLevelEncryptionConfigInUse`](crate::error::FieldLevelEncryptionConfigInUse).
pub mod field_level_encryption_config_in_use {

    /// A builder for [`FieldLevelEncryptionConfigInUse`](crate::error::FieldLevelEncryptionConfigInUse).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`FieldLevelEncryptionConfigInUse`](crate::error::FieldLevelEncryptionConfigInUse).
        pub fn build(self) -> crate::error::FieldLevelEncryptionConfigInUse {
            crate::error::FieldLevelEncryptionConfigInUse {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl FieldLevelEncryptionConfigInUse {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for FieldLevelEncryptionConfigInUse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "FieldLevelEncryptionConfigInUse")?;
        if let Some(inner_113) = &self.message {
            {
                write!(f, ": {}", inner_113)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for FieldLevelEncryptionConfigInUse {}
impl aws_http::request_id::RequestId for crate::error::FieldLevelEncryptionConfigInUse {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for FieldLevelEncryptionConfigInUse {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DeleteDistributionErrorKind = DeleteDistributionError;
/// Error type for the `DeleteDistributionError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteDistributionError {
    /// <p>Access denied.</p>
    AccessDenied(crate::error::AccessDenied),
    /// <p>The specified CloudFront distribution is not disabled. You must disable the distribution before you can delete it.</p>
    DistributionNotDisabled(crate::error::DistributionNotDisabled),
    /// <p>The <code>If-Match</code> version is missing or not valid.</p>
    InvalidIfMatchVersion(crate::error::InvalidIfMatchVersion),
    /// <p>The specified distribution does not exist.</p>
    NoSuchDistribution(crate::error::NoSuchDistribution),
    /// <p>The precondition in one or more of the request fields evaluated to <code>false</code>.</p>
    PreconditionFailed(crate::error::PreconditionFailed),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DeleteDistributionError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DeleteDistributionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AccessDenied(_inner) => _inner.fmt(f),
            Self::DistributionNotDisabled(_inner) => _inner.fmt(f),
            Self::InvalidIfMatchVersion(_inner) => _inner.fmt(f),
            Self::NoSuchDistribution(_inner) => _inner.fmt(f),
            Self::PreconditionFailed(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DeleteDistributionError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AccessDenied(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DistributionNotDisabled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidIfMatchVersion(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NoSuchDistribution(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::PreconditionFailed(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DeleteDistributionError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteDistributionError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteDistributionError {
    /// Creates the `DeleteDistributionError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DeleteDistributionError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AccessDenied(e) => e.meta(),
            Self::DistributionNotDisabled(e) => e.meta(),
            Self::InvalidIfMatchVersion(e) => e.meta(),
            Self::NoSuchDistribution(e) => e.meta(),
            Self::PreconditionFailed(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DeleteDistributionError::AccessDenied`.
    pub fn is_access_denied(&self) -> bool {
        matches!(self, Self::AccessDenied(_))
    }
    /// Returns `true` if the error kind is `DeleteDistributionError::DistributionNotDisabled`.
    pub fn is_distribution_not_disabled(&self) -> bool {
        matches!(self, Self::DistributionNotDisabled(_))
    }
    /// Returns `true` if the error kind is `DeleteDistributionError::InvalidIfMatchVersion`.
    pub fn is_invalid_if_match_version(&self) -> bool {
        matches!(self, Self::InvalidIfMatchVersion(_))
    }
    /// Returns `true` if the error kind is `DeleteDistributionError::NoSuchDistribution`.
    pub fn is_no_such_distribution(&self) -> bool {
        matches!(self, Self::NoSuchDistribution(_))
    }
    /// Returns `true` if the error kind is `DeleteDistributionError::PreconditionFailed`.
    pub fn is_precondition_failed(&self) -> bool {
        matches!(self, Self::PreconditionFailed(_))
    }
}
impl std::error::Error for DeleteDistributionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AccessDenied(_inner) => Some(_inner),
            Self::DistributionNotDisabled(_inner) => Some(_inner),
            Self::InvalidIfMatchVersion(_inner) => Some(_inner),
            Self::NoSuchDistribution(_inner) => Some(_inner),
            Self::PreconditionFailed(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The specified CloudFront distribution is not disabled. You must disable the distribution before you can delete it.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DistributionNotDisabled {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl DistributionNotDisabled {
    /// Creates a new builder-style object to manufacture [`DistributionNotDisabled`](crate::error::DistributionNotDisabled).
    pub fn builder() -> crate::error::distribution_not_disabled::Builder {
        crate::error::distribution_not_disabled::Builder::default()
    }
}
/// See [`DistributionNotDisabled`](crate::error::DistributionNotDisabled).
pub mod distribution_not_disabled {

    /// A builder for [`DistributionNotDisabled`](crate::error::DistributionNotDisabled).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`DistributionNotDisabled`](crate::error::DistributionNotDisabled).
        pub fn build(self) -> crate::error::DistributionNotDisabled {
            crate::error::DistributionNotDisabled {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl DistributionNotDisabled {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DistributionNotDisabled {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DistributionNotDisabled")?;
        if let Some(inner_114) = &self.message {
            {
                write!(f, ": {}", inner_114)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for DistributionNotDisabled {}
impl aws_http::request_id::RequestId for crate::error::DistributionNotDisabled {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DistributionNotDisabled {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DeleteContinuousDeploymentPolicyErrorKind = DeleteContinuousDeploymentPolicyError;
/// Error type for the `DeleteContinuousDeploymentPolicyError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteContinuousDeploymentPolicyError {
    /// <p>Access denied.</p>
    AccessDenied(crate::error::AccessDenied),
    /// <p>You cannot delete a continuous deployment policy that is associated with a primary distribution.</p>
    ContinuousDeploymentPolicyInUse(crate::error::ContinuousDeploymentPolicyInUse),
    /// <p>An argument is invalid.</p>
    InvalidArgument(crate::error::InvalidArgument),
    /// <p>The <code>If-Match</code> version is missing or not valid.</p>
    InvalidIfMatchVersion(crate::error::InvalidIfMatchVersion),
    /// <p>The continuous deployment policy doesn't exist.</p>
    NoSuchContinuousDeploymentPolicy(crate::error::NoSuchContinuousDeploymentPolicy),
    /// <p>The precondition in one or more of the request fields evaluated to <code>false</code>.</p>
    PreconditionFailed(crate::error::PreconditionFailed),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DeleteContinuousDeploymentPolicyError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DeleteContinuousDeploymentPolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AccessDenied(_inner) => _inner.fmt(f),
            Self::ContinuousDeploymentPolicyInUse(_inner) => _inner.fmt(f),
            Self::InvalidArgument(_inner) => _inner.fmt(f),
            Self::InvalidIfMatchVersion(_inner) => _inner.fmt(f),
            Self::NoSuchContinuousDeploymentPolicy(_inner) => _inner.fmt(f),
            Self::PreconditionFailed(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for DeleteContinuousDeploymentPolicyError
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AccessDenied(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ContinuousDeploymentPolicyInUse(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidArgument(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidIfMatchVersion(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NoSuchContinuousDeploymentPolicy(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::PreconditionFailed(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DeleteContinuousDeploymentPolicyError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteContinuousDeploymentPolicyError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteContinuousDeploymentPolicyError {
    /// Creates the `DeleteContinuousDeploymentPolicyError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DeleteContinuousDeploymentPolicyError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AccessDenied(e) => e.meta(),
            Self::ContinuousDeploymentPolicyInUse(e) => e.meta(),
            Self::InvalidArgument(e) => e.meta(),
            Self::InvalidIfMatchVersion(e) => e.meta(),
            Self::NoSuchContinuousDeploymentPolicy(e) => e.meta(),
            Self::PreconditionFailed(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DeleteContinuousDeploymentPolicyError::AccessDenied`.
    pub fn is_access_denied(&self) -> bool {
        matches!(self, Self::AccessDenied(_))
    }
    /// Returns `true` if the error kind is `DeleteContinuousDeploymentPolicyError::ContinuousDeploymentPolicyInUse`.
    pub fn is_continuous_deployment_policy_in_use(&self) -> bool {
        matches!(self, Self::ContinuousDeploymentPolicyInUse(_))
    }
    /// Returns `true` if the error kind is `DeleteContinuousDeploymentPolicyError::InvalidArgument`.
    pub fn is_invalid_argument(&self) -> bool {
        matches!(self, Self::InvalidArgument(_))
    }
    /// Returns `true` if the error kind is `DeleteContinuousDeploymentPolicyError::InvalidIfMatchVersion`.
    pub fn is_invalid_if_match_version(&self) -> bool {
        matches!(self, Self::InvalidIfMatchVersion(_))
    }
    /// Returns `true` if the error kind is `DeleteContinuousDeploymentPolicyError::NoSuchContinuousDeploymentPolicy`.
    pub fn is_no_such_continuous_deployment_policy(&self) -> bool {
        matches!(self, Self::NoSuchContinuousDeploymentPolicy(_))
    }
    /// Returns `true` if the error kind is `DeleteContinuousDeploymentPolicyError::PreconditionFailed`.
    pub fn is_precondition_failed(&self) -> bool {
        matches!(self, Self::PreconditionFailed(_))
    }
}
impl std::error::Error for DeleteContinuousDeploymentPolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AccessDenied(_inner) => Some(_inner),
            Self::ContinuousDeploymentPolicyInUse(_inner) => Some(_inner),
            Self::InvalidArgument(_inner) => Some(_inner),
            Self::InvalidIfMatchVersion(_inner) => Some(_inner),
            Self::NoSuchContinuousDeploymentPolicy(_inner) => Some(_inner),
            Self::PreconditionFailed(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DeleteCloudFrontOriginAccessIdentityErrorKind = DeleteCloudFrontOriginAccessIdentityError;
/// Error type for the `DeleteCloudFrontOriginAccessIdentityError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteCloudFrontOriginAccessIdentityError {
    /// <p>Access denied.</p>
    AccessDenied(crate::error::AccessDenied),
    /// <p>The Origin Access Identity specified is already in use.</p>
    CloudFrontOriginAccessIdentityInUse(crate::error::CloudFrontOriginAccessIdentityInUse),
    /// <p>The <code>If-Match</code> version is missing or not valid.</p>
    InvalidIfMatchVersion(crate::error::InvalidIfMatchVersion),
    /// <p>The specified origin access identity does not exist.</p>
    NoSuchCloudFrontOriginAccessIdentity(crate::error::NoSuchCloudFrontOriginAccessIdentity),
    /// <p>The precondition in one or more of the request fields evaluated to <code>false</code>.</p>
    PreconditionFailed(crate::error::PreconditionFailed),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DeleteCloudFrontOriginAccessIdentityError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DeleteCloudFrontOriginAccessIdentityError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AccessDenied(_inner) => _inner.fmt(f),
            Self::CloudFrontOriginAccessIdentityInUse(_inner) => _inner.fmt(f),
            Self::InvalidIfMatchVersion(_inner) => _inner.fmt(f),
            Self::NoSuchCloudFrontOriginAccessIdentity(_inner) => _inner.fmt(f),
            Self::PreconditionFailed(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for DeleteCloudFrontOriginAccessIdentityError
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AccessDenied(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::CloudFrontOriginAccessIdentityInUse(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidIfMatchVersion(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NoSuchCloudFrontOriginAccessIdentity(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::PreconditionFailed(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DeleteCloudFrontOriginAccessIdentityError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteCloudFrontOriginAccessIdentityError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteCloudFrontOriginAccessIdentityError {
    /// Creates the `DeleteCloudFrontOriginAccessIdentityError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DeleteCloudFrontOriginAccessIdentityError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AccessDenied(e) => e.meta(),
            Self::CloudFrontOriginAccessIdentityInUse(e) => e.meta(),
            Self::InvalidIfMatchVersion(e) => e.meta(),
            Self::NoSuchCloudFrontOriginAccessIdentity(e) => e.meta(),
            Self::PreconditionFailed(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DeleteCloudFrontOriginAccessIdentityError::AccessDenied`.
    pub fn is_access_denied(&self) -> bool {
        matches!(self, Self::AccessDenied(_))
    }
    /// Returns `true` if the error kind is `DeleteCloudFrontOriginAccessIdentityError::CloudFrontOriginAccessIdentityInUse`.
    pub fn is_cloud_front_origin_access_identity_in_use(&self) -> bool {
        matches!(self, Self::CloudFrontOriginAccessIdentityInUse(_))
    }
    /// Returns `true` if the error kind is `DeleteCloudFrontOriginAccessIdentityError::InvalidIfMatchVersion`.
    pub fn is_invalid_if_match_version(&self) -> bool {
        matches!(self, Self::InvalidIfMatchVersion(_))
    }
    /// Returns `true` if the error kind is `DeleteCloudFrontOriginAccessIdentityError::NoSuchCloudFrontOriginAccessIdentity`.
    pub fn is_no_such_cloud_front_origin_access_identity(&self) -> bool {
        matches!(self, Self::NoSuchCloudFrontOriginAccessIdentity(_))
    }
    /// Returns `true` if the error kind is `DeleteCloudFrontOriginAccessIdentityError::PreconditionFailed`.
    pub fn is_precondition_failed(&self) -> bool {
        matches!(self, Self::PreconditionFailed(_))
    }
}
impl std::error::Error for DeleteCloudFrontOriginAccessIdentityError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AccessDenied(_inner) => Some(_inner),
            Self::CloudFrontOriginAccessIdentityInUse(_inner) => Some(_inner),
            Self::InvalidIfMatchVersion(_inner) => Some(_inner),
            Self::NoSuchCloudFrontOriginAccessIdentity(_inner) => Some(_inner),
            Self::PreconditionFailed(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The Origin Access Identity specified is already in use.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CloudFrontOriginAccessIdentityInUse {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl CloudFrontOriginAccessIdentityInUse {
    /// Creates a new builder-style object to manufacture [`CloudFrontOriginAccessIdentityInUse`](crate::error::CloudFrontOriginAccessIdentityInUse).
    pub fn builder() -> crate::error::cloud_front_origin_access_identity_in_use::Builder {
        crate::error::cloud_front_origin_access_identity_in_use::Builder::default()
    }
}
/// See [`CloudFrontOriginAccessIdentityInUse`](crate::error::CloudFrontOriginAccessIdentityInUse).
pub mod cloud_front_origin_access_identity_in_use {

    /// A builder for [`CloudFrontOriginAccessIdentityInUse`](crate::error::CloudFrontOriginAccessIdentityInUse).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`CloudFrontOriginAccessIdentityInUse`](crate::error::CloudFrontOriginAccessIdentityInUse).
        pub fn build(self) -> crate::error::CloudFrontOriginAccessIdentityInUse {
            crate::error::CloudFrontOriginAccessIdentityInUse {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl CloudFrontOriginAccessIdentityInUse {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CloudFrontOriginAccessIdentityInUse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CloudFrontOriginAccessIdentityInUse")?;
        if let Some(inner_115) = &self.message {
            {
                write!(f, ": {}", inner_115)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for CloudFrontOriginAccessIdentityInUse {}
impl aws_http::request_id::RequestId for crate::error::CloudFrontOriginAccessIdentityInUse {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for CloudFrontOriginAccessIdentityInUse
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DeleteCachePolicyErrorKind = DeleteCachePolicyError;
/// Error type for the `DeleteCachePolicyError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteCachePolicyError {
    /// <p>Access denied.</p>
    AccessDenied(crate::error::AccessDenied),
    /// <p>Cannot delete the cache policy because it is attached to one or more cache behaviors.</p>
    CachePolicyInUse(crate::error::CachePolicyInUse),
    /// <p>You cannot delete a managed policy.</p>
    IllegalDelete(crate::error::IllegalDelete),
    /// <p>The <code>If-Match</code> version is missing or not valid.</p>
    InvalidIfMatchVersion(crate::error::InvalidIfMatchVersion),
    /// <p>The cache policy does not exist.</p>
    NoSuchCachePolicy(crate::error::NoSuchCachePolicy),
    /// <p>The precondition in one or more of the request fields evaluated to <code>false</code>.</p>
    PreconditionFailed(crate::error::PreconditionFailed),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DeleteCachePolicyError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DeleteCachePolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AccessDenied(_inner) => _inner.fmt(f),
            Self::CachePolicyInUse(_inner) => _inner.fmt(f),
            Self::IllegalDelete(_inner) => _inner.fmt(f),
            Self::InvalidIfMatchVersion(_inner) => _inner.fmt(f),
            Self::NoSuchCachePolicy(_inner) => _inner.fmt(f),
            Self::PreconditionFailed(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DeleteCachePolicyError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AccessDenied(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::CachePolicyInUse(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::IllegalDelete(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidIfMatchVersion(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NoSuchCachePolicy(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::PreconditionFailed(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DeleteCachePolicyError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteCachePolicyError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteCachePolicyError {
    /// Creates the `DeleteCachePolicyError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DeleteCachePolicyError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AccessDenied(e) => e.meta(),
            Self::CachePolicyInUse(e) => e.meta(),
            Self::IllegalDelete(e) => e.meta(),
            Self::InvalidIfMatchVersion(e) => e.meta(),
            Self::NoSuchCachePolicy(e) => e.meta(),
            Self::PreconditionFailed(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DeleteCachePolicyError::AccessDenied`.
    pub fn is_access_denied(&self) -> bool {
        matches!(self, Self::AccessDenied(_))
    }
    /// Returns `true` if the error kind is `DeleteCachePolicyError::CachePolicyInUse`.
    pub fn is_cache_policy_in_use(&self) -> bool {
        matches!(self, Self::CachePolicyInUse(_))
    }
    /// Returns `true` if the error kind is `DeleteCachePolicyError::IllegalDelete`.
    pub fn is_illegal_delete(&self) -> bool {
        matches!(self, Self::IllegalDelete(_))
    }
    /// Returns `true` if the error kind is `DeleteCachePolicyError::InvalidIfMatchVersion`.
    pub fn is_invalid_if_match_version(&self) -> bool {
        matches!(self, Self::InvalidIfMatchVersion(_))
    }
    /// Returns `true` if the error kind is `DeleteCachePolicyError::NoSuchCachePolicy`.
    pub fn is_no_such_cache_policy(&self) -> bool {
        matches!(self, Self::NoSuchCachePolicy(_))
    }
    /// Returns `true` if the error kind is `DeleteCachePolicyError::PreconditionFailed`.
    pub fn is_precondition_failed(&self) -> bool {
        matches!(self, Self::PreconditionFailed(_))
    }
}
impl std::error::Error for DeleteCachePolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AccessDenied(_inner) => Some(_inner),
            Self::CachePolicyInUse(_inner) => Some(_inner),
            Self::IllegalDelete(_inner) => Some(_inner),
            Self::InvalidIfMatchVersion(_inner) => Some(_inner),
            Self::NoSuchCachePolicy(_inner) => Some(_inner),
            Self::PreconditionFailed(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>Cannot delete the cache policy because it is attached to one or more cache behaviors.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CachePolicyInUse {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl CachePolicyInUse {
    /// Creates a new builder-style object to manufacture [`CachePolicyInUse`](crate::error::CachePolicyInUse).
    pub fn builder() -> crate::error::cache_policy_in_use::Builder {
        crate::error::cache_policy_in_use::Builder::default()
    }
}
/// See [`CachePolicyInUse`](crate::error::CachePolicyInUse).
pub mod cache_policy_in_use {

    /// A builder for [`CachePolicyInUse`](crate::error::CachePolicyInUse).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`CachePolicyInUse`](crate::error::CachePolicyInUse).
        pub fn build(self) -> crate::error::CachePolicyInUse {
            crate::error::CachePolicyInUse {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl CachePolicyInUse {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CachePolicyInUse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CachePolicyInUse")?;
        if let Some(inner_116) = &self.message {
            {
                write!(f, ": {}", inner_116)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for CachePolicyInUse {}
impl aws_http::request_id::RequestId for crate::error::CachePolicyInUse {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CachePolicyInUse {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type CreateStreamingDistributionWithTagsErrorKind = CreateStreamingDistributionWithTagsError;
/// Error type for the `CreateStreamingDistributionWithTagsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateStreamingDistributionWithTagsError {
    /// <p>Access denied.</p>
    AccessDenied(crate::error::AccessDenied),
    /// <p>The CNAME specified is already defined for CloudFront.</p>
    CnameAlreadyExists(crate::error::CnameAlreadyExists),
    /// <p>The value of <code>Quantity</code> and the size of <code>Items</code> don't match.</p>
    InconsistentQuantities(crate::error::InconsistentQuantities),
    /// <p>An argument is invalid.</p>
    InvalidArgument(crate::error::InvalidArgument),
    /// <p>The Amazon S3 origin server specified does not refer to a valid Amazon S3 bucket.</p>
    InvalidOrigin(crate::error::InvalidOrigin),
    /// <p>The origin access control is not valid.</p>
    InvalidOriginAccessControl(crate::error::InvalidOriginAccessControl),
    /// <p>The origin access identity is not valid or doesn't exist.</p>
    InvalidOriginAccessIdentity(crate::error::InvalidOriginAccessIdentity),
    /// <p>The tagging specified is not valid.</p>
    InvalidTagging(crate::error::InvalidTagging),
    /// <p>This operation requires a body. Ensure that the body is present and the <code>Content-Type</code> header is set.</p>
    MissingBody(crate::error::MissingBody),
    /// <p>The caller reference you attempted to create the streaming distribution with is associated with another distribution</p>
    StreamingDistributionAlreadyExists(crate::error::StreamingDistributionAlreadyExists),
    /// <p>Your request contains more CNAMEs than are allowed per distribution.</p>
    TooManyStreamingDistributionCnamEs(crate::error::TooManyStreamingDistributionCnamEs),
    /// <p>Processing your request would cause you to exceed the maximum number of streaming distributions allowed.</p>
    TooManyStreamingDistributions(crate::error::TooManyStreamingDistributions),
    /// <p>Your request contains more trusted signers than are allowed per distribution.</p>
    TooManyTrustedSigners(crate::error::TooManyTrustedSigners),
    /// <p>One or more of your trusted signers don't exist.</p>
    TrustedSignerDoesNotExist(crate::error::TrustedSignerDoesNotExist),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for CreateStreamingDistributionWithTagsError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for CreateStreamingDistributionWithTagsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AccessDenied(_inner) => _inner.fmt(f),
            Self::CnameAlreadyExists(_inner) => _inner.fmt(f),
            Self::InconsistentQuantities(_inner) => _inner.fmt(f),
            Self::InvalidArgument(_inner) => _inner.fmt(f),
            Self::InvalidOrigin(_inner) => _inner.fmt(f),
            Self::InvalidOriginAccessControl(_inner) => _inner.fmt(f),
            Self::InvalidOriginAccessIdentity(_inner) => _inner.fmt(f),
            Self::InvalidTagging(_inner) => _inner.fmt(f),
            Self::MissingBody(_inner) => _inner.fmt(f),
            Self::StreamingDistributionAlreadyExists(_inner) => _inner.fmt(f),
            Self::TooManyStreamingDistributionCnamEs(_inner) => _inner.fmt(f),
            Self::TooManyStreamingDistributions(_inner) => _inner.fmt(f),
            Self::TooManyTrustedSigners(_inner) => _inner.fmt(f),
            Self::TrustedSignerDoesNotExist(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for CreateStreamingDistributionWithTagsError
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AccessDenied(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::CnameAlreadyExists(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InconsistentQuantities(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidArgument(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidOrigin(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidOriginAccessControl(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidOriginAccessIdentity(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidTagging(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::MissingBody(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::StreamingDistributionAlreadyExists(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyStreamingDistributionCnamEs(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyStreamingDistributions(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyTrustedSigners(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TrustedSignerDoesNotExist(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::CreateStreamingDistributionWithTagsError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateStreamingDistributionWithTagsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateStreamingDistributionWithTagsError {
    /// Creates the `CreateStreamingDistributionWithTagsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `CreateStreamingDistributionWithTagsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AccessDenied(e) => e.meta(),
            Self::CnameAlreadyExists(e) => e.meta(),
            Self::InconsistentQuantities(e) => e.meta(),
            Self::InvalidArgument(e) => e.meta(),
            Self::InvalidOrigin(e) => e.meta(),
            Self::InvalidOriginAccessControl(e) => e.meta(),
            Self::InvalidOriginAccessIdentity(e) => e.meta(),
            Self::InvalidTagging(e) => e.meta(),
            Self::MissingBody(e) => e.meta(),
            Self::StreamingDistributionAlreadyExists(e) => e.meta(),
            Self::TooManyStreamingDistributionCnamEs(e) => e.meta(),
            Self::TooManyStreamingDistributions(e) => e.meta(),
            Self::TooManyTrustedSigners(e) => e.meta(),
            Self::TrustedSignerDoesNotExist(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `CreateStreamingDistributionWithTagsError::AccessDenied`.
    pub fn is_access_denied(&self) -> bool {
        matches!(self, Self::AccessDenied(_))
    }
    /// Returns `true` if the error kind is `CreateStreamingDistributionWithTagsError::CnameAlreadyExists`.
    pub fn is_cname_already_exists(&self) -> bool {
        matches!(self, Self::CnameAlreadyExists(_))
    }
    /// Returns `true` if the error kind is `CreateStreamingDistributionWithTagsError::InconsistentQuantities`.
    pub fn is_inconsistent_quantities(&self) -> bool {
        matches!(self, Self::InconsistentQuantities(_))
    }
    /// Returns `true` if the error kind is `CreateStreamingDistributionWithTagsError::InvalidArgument`.
    pub fn is_invalid_argument(&self) -> bool {
        matches!(self, Self::InvalidArgument(_))
    }
    /// Returns `true` if the error kind is `CreateStreamingDistributionWithTagsError::InvalidOrigin`.
    pub fn is_invalid_origin(&self) -> bool {
        matches!(self, Self::InvalidOrigin(_))
    }
    /// Returns `true` if the error kind is `CreateStreamingDistributionWithTagsError::InvalidOriginAccessControl`.
    pub fn is_invalid_origin_access_control(&self) -> bool {
        matches!(self, Self::InvalidOriginAccessControl(_))
    }
    /// Returns `true` if the error kind is `CreateStreamingDistributionWithTagsError::InvalidOriginAccessIdentity`.
    pub fn is_invalid_origin_access_identity(&self) -> bool {
        matches!(self, Self::InvalidOriginAccessIdentity(_))
    }
    /// Returns `true` if the error kind is `CreateStreamingDistributionWithTagsError::InvalidTagging`.
    pub fn is_invalid_tagging(&self) -> bool {
        matches!(self, Self::InvalidTagging(_))
    }
    /// Returns `true` if the error kind is `CreateStreamingDistributionWithTagsError::MissingBody`.
    pub fn is_missing_body(&self) -> bool {
        matches!(self, Self::MissingBody(_))
    }
    /// Returns `true` if the error kind is `CreateStreamingDistributionWithTagsError::StreamingDistributionAlreadyExists`.
    pub fn is_streaming_distribution_already_exists(&self) -> bool {
        matches!(self, Self::StreamingDistributionAlreadyExists(_))
    }
    /// Returns `true` if the error kind is `CreateStreamingDistributionWithTagsError::TooManyStreamingDistributionCnamEs`.
    pub fn is_too_many_streaming_distribution_cnam_es(&self) -> bool {
        matches!(self, Self::TooManyStreamingDistributionCnamEs(_))
    }
    /// Returns `true` if the error kind is `CreateStreamingDistributionWithTagsError::TooManyStreamingDistributions`.
    pub fn is_too_many_streaming_distributions(&self) -> bool {
        matches!(self, Self::TooManyStreamingDistributions(_))
    }
    /// Returns `true` if the error kind is `CreateStreamingDistributionWithTagsError::TooManyTrustedSigners`.
    pub fn is_too_many_trusted_signers(&self) -> bool {
        matches!(self, Self::TooManyTrustedSigners(_))
    }
    /// Returns `true` if the error kind is `CreateStreamingDistributionWithTagsError::TrustedSignerDoesNotExist`.
    pub fn is_trusted_signer_does_not_exist(&self) -> bool {
        matches!(self, Self::TrustedSignerDoesNotExist(_))
    }
}
impl std::error::Error for CreateStreamingDistributionWithTagsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AccessDenied(_inner) => Some(_inner),
            Self::CnameAlreadyExists(_inner) => Some(_inner),
            Self::InconsistentQuantities(_inner) => Some(_inner),
            Self::InvalidArgument(_inner) => Some(_inner),
            Self::InvalidOrigin(_inner) => Some(_inner),
            Self::InvalidOriginAccessControl(_inner) => Some(_inner),
            Self::InvalidOriginAccessIdentity(_inner) => Some(_inner),
            Self::InvalidTagging(_inner) => Some(_inner),
            Self::MissingBody(_inner) => Some(_inner),
            Self::StreamingDistributionAlreadyExists(_inner) => Some(_inner),
            Self::TooManyStreamingDistributionCnamEs(_inner) => Some(_inner),
            Self::TooManyStreamingDistributions(_inner) => Some(_inner),
            Self::TooManyTrustedSigners(_inner) => Some(_inner),
            Self::TrustedSignerDoesNotExist(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>Processing your request would cause you to exceed the maximum number of streaming distributions allowed.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TooManyStreamingDistributions {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl TooManyStreamingDistributions {
    /// Creates a new builder-style object to manufacture [`TooManyStreamingDistributions`](crate::error::TooManyStreamingDistributions).
    pub fn builder() -> crate::error::too_many_streaming_distributions::Builder {
        crate::error::too_many_streaming_distributions::Builder::default()
    }
}
/// See [`TooManyStreamingDistributions`](crate::error::TooManyStreamingDistributions).
pub mod too_many_streaming_distributions {

    /// A builder for [`TooManyStreamingDistributions`](crate::error::TooManyStreamingDistributions).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`TooManyStreamingDistributions`](crate::error::TooManyStreamingDistributions).
        pub fn build(self) -> crate::error::TooManyStreamingDistributions {
            crate::error::TooManyStreamingDistributions {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl TooManyStreamingDistributions {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TooManyStreamingDistributions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TooManyStreamingDistributions")?;
        if let Some(inner_117) = &self.message {
            {
                write!(f, ": {}", inner_117)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for TooManyStreamingDistributions {}
impl aws_http::request_id::RequestId for crate::error::TooManyStreamingDistributions {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for TooManyStreamingDistributions {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The caller reference you attempted to create the streaming distribution with is associated with another distribution</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct StreamingDistributionAlreadyExists {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl StreamingDistributionAlreadyExists {
    /// Creates a new builder-style object to manufacture [`StreamingDistributionAlreadyExists`](crate::error::StreamingDistributionAlreadyExists).
    pub fn builder() -> crate::error::streaming_distribution_already_exists::Builder {
        crate::error::streaming_distribution_already_exists::Builder::default()
    }
}
/// See [`StreamingDistributionAlreadyExists`](crate::error::StreamingDistributionAlreadyExists).
pub mod streaming_distribution_already_exists {

    /// A builder for [`StreamingDistributionAlreadyExists`](crate::error::StreamingDistributionAlreadyExists).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`StreamingDistributionAlreadyExists`](crate::error::StreamingDistributionAlreadyExists).
        pub fn build(self) -> crate::error::StreamingDistributionAlreadyExists {
            crate::error::StreamingDistributionAlreadyExists {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl StreamingDistributionAlreadyExists {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for StreamingDistributionAlreadyExists {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "StreamingDistributionAlreadyExists")?;
        if let Some(inner_118) = &self.message {
            {
                write!(f, ": {}", inner_118)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for StreamingDistributionAlreadyExists {}
impl aws_http::request_id::RequestId for crate::error::StreamingDistributionAlreadyExists {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for StreamingDistributionAlreadyExists
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The Amazon S3 origin server specified does not refer to a valid Amazon S3 bucket.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidOrigin {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidOrigin {
    /// Creates a new builder-style object to manufacture [`InvalidOrigin`](crate::error::InvalidOrigin).
    pub fn builder() -> crate::error::invalid_origin::Builder {
        crate::error::invalid_origin::Builder::default()
    }
}
/// See [`InvalidOrigin`](crate::error::InvalidOrigin).
pub mod invalid_origin {

    /// A builder for [`InvalidOrigin`](crate::error::InvalidOrigin).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidOrigin`](crate::error::InvalidOrigin).
        pub fn build(self) -> crate::error::InvalidOrigin {
            crate::error::InvalidOrigin {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl InvalidOrigin {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidOrigin {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidOrigin")?;
        if let Some(inner_119) = &self.message {
            {
                write!(f, ": {}", inner_119)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidOrigin {}
impl aws_http::request_id::RequestId for crate::error::InvalidOrigin {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidOrigin {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type CreateStreamingDistributionErrorKind = CreateStreamingDistributionError;
/// Error type for the `CreateStreamingDistributionError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateStreamingDistributionError {
    /// <p>Access denied.</p>
    AccessDenied(crate::error::AccessDenied),
    /// <p>The CNAME specified is already defined for CloudFront.</p>
    CnameAlreadyExists(crate::error::CnameAlreadyExists),
    /// <p>The value of <code>Quantity</code> and the size of <code>Items</code> don't match.</p>
    InconsistentQuantities(crate::error::InconsistentQuantities),
    /// <p>An argument is invalid.</p>
    InvalidArgument(crate::error::InvalidArgument),
    /// <p>The Amazon S3 origin server specified does not refer to a valid Amazon S3 bucket.</p>
    InvalidOrigin(crate::error::InvalidOrigin),
    /// <p>The origin access control is not valid.</p>
    InvalidOriginAccessControl(crate::error::InvalidOriginAccessControl),
    /// <p>The origin access identity is not valid or doesn't exist.</p>
    InvalidOriginAccessIdentity(crate::error::InvalidOriginAccessIdentity),
    /// <p>This operation requires a body. Ensure that the body is present and the <code>Content-Type</code> header is set.</p>
    MissingBody(crate::error::MissingBody),
    /// <p>The caller reference you attempted to create the streaming distribution with is associated with another distribution</p>
    StreamingDistributionAlreadyExists(crate::error::StreamingDistributionAlreadyExists),
    /// <p>Your request contains more CNAMEs than are allowed per distribution.</p>
    TooManyStreamingDistributionCnamEs(crate::error::TooManyStreamingDistributionCnamEs),
    /// <p>Processing your request would cause you to exceed the maximum number of streaming distributions allowed.</p>
    TooManyStreamingDistributions(crate::error::TooManyStreamingDistributions),
    /// <p>Your request contains more trusted signers than are allowed per distribution.</p>
    TooManyTrustedSigners(crate::error::TooManyTrustedSigners),
    /// <p>One or more of your trusted signers don't exist.</p>
    TrustedSignerDoesNotExist(crate::error::TrustedSignerDoesNotExist),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for CreateStreamingDistributionError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for CreateStreamingDistributionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AccessDenied(_inner) => _inner.fmt(f),
            Self::CnameAlreadyExists(_inner) => _inner.fmt(f),
            Self::InconsistentQuantities(_inner) => _inner.fmt(f),
            Self::InvalidArgument(_inner) => _inner.fmt(f),
            Self::InvalidOrigin(_inner) => _inner.fmt(f),
            Self::InvalidOriginAccessControl(_inner) => _inner.fmt(f),
            Self::InvalidOriginAccessIdentity(_inner) => _inner.fmt(f),
            Self::MissingBody(_inner) => _inner.fmt(f),
            Self::StreamingDistributionAlreadyExists(_inner) => _inner.fmt(f),
            Self::TooManyStreamingDistributionCnamEs(_inner) => _inner.fmt(f),
            Self::TooManyStreamingDistributions(_inner) => _inner.fmt(f),
            Self::TooManyTrustedSigners(_inner) => _inner.fmt(f),
            Self::TrustedSignerDoesNotExist(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CreateStreamingDistributionError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AccessDenied(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::CnameAlreadyExists(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InconsistentQuantities(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidArgument(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidOrigin(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidOriginAccessControl(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidOriginAccessIdentity(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::MissingBody(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::StreamingDistributionAlreadyExists(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyStreamingDistributionCnamEs(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyStreamingDistributions(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyTrustedSigners(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TrustedSignerDoesNotExist(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::CreateStreamingDistributionError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateStreamingDistributionError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateStreamingDistributionError {
    /// Creates the `CreateStreamingDistributionError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `CreateStreamingDistributionError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AccessDenied(e) => e.meta(),
            Self::CnameAlreadyExists(e) => e.meta(),
            Self::InconsistentQuantities(e) => e.meta(),
            Self::InvalidArgument(e) => e.meta(),
            Self::InvalidOrigin(e) => e.meta(),
            Self::InvalidOriginAccessControl(e) => e.meta(),
            Self::InvalidOriginAccessIdentity(e) => e.meta(),
            Self::MissingBody(e) => e.meta(),
            Self::StreamingDistributionAlreadyExists(e) => e.meta(),
            Self::TooManyStreamingDistributionCnamEs(e) => e.meta(),
            Self::TooManyStreamingDistributions(e) => e.meta(),
            Self::TooManyTrustedSigners(e) => e.meta(),
            Self::TrustedSignerDoesNotExist(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `CreateStreamingDistributionError::AccessDenied`.
    pub fn is_access_denied(&self) -> bool {
        matches!(self, Self::AccessDenied(_))
    }
    /// Returns `true` if the error kind is `CreateStreamingDistributionError::CnameAlreadyExists`.
    pub fn is_cname_already_exists(&self) -> bool {
        matches!(self, Self::CnameAlreadyExists(_))
    }
    /// Returns `true` if the error kind is `CreateStreamingDistributionError::InconsistentQuantities`.
    pub fn is_inconsistent_quantities(&self) -> bool {
        matches!(self, Self::InconsistentQuantities(_))
    }
    /// Returns `true` if the error kind is `CreateStreamingDistributionError::InvalidArgument`.
    pub fn is_invalid_argument(&self) -> bool {
        matches!(self, Self::InvalidArgument(_))
    }
    /// Returns `true` if the error kind is `CreateStreamingDistributionError::InvalidOrigin`.
    pub fn is_invalid_origin(&self) -> bool {
        matches!(self, Self::InvalidOrigin(_))
    }
    /// Returns `true` if the error kind is `CreateStreamingDistributionError::InvalidOriginAccessControl`.
    pub fn is_invalid_origin_access_control(&self) -> bool {
        matches!(self, Self::InvalidOriginAccessControl(_))
    }
    /// Returns `true` if the error kind is `CreateStreamingDistributionError::InvalidOriginAccessIdentity`.
    pub fn is_invalid_origin_access_identity(&self) -> bool {
        matches!(self, Self::InvalidOriginAccessIdentity(_))
    }
    /// Returns `true` if the error kind is `CreateStreamingDistributionError::MissingBody`.
    pub fn is_missing_body(&self) -> bool {
        matches!(self, Self::MissingBody(_))
    }
    /// Returns `true` if the error kind is `CreateStreamingDistributionError::StreamingDistributionAlreadyExists`.
    pub fn is_streaming_distribution_already_exists(&self) -> bool {
        matches!(self, Self::StreamingDistributionAlreadyExists(_))
    }
    /// Returns `true` if the error kind is `CreateStreamingDistributionError::TooManyStreamingDistributionCnamEs`.
    pub fn is_too_many_streaming_distribution_cnam_es(&self) -> bool {
        matches!(self, Self::TooManyStreamingDistributionCnamEs(_))
    }
    /// Returns `true` if the error kind is `CreateStreamingDistributionError::TooManyStreamingDistributions`.
    pub fn is_too_many_streaming_distributions(&self) -> bool {
        matches!(self, Self::TooManyStreamingDistributions(_))
    }
    /// Returns `true` if the error kind is `CreateStreamingDistributionError::TooManyTrustedSigners`.
    pub fn is_too_many_trusted_signers(&self) -> bool {
        matches!(self, Self::TooManyTrustedSigners(_))
    }
    /// Returns `true` if the error kind is `CreateStreamingDistributionError::TrustedSignerDoesNotExist`.
    pub fn is_trusted_signer_does_not_exist(&self) -> bool {
        matches!(self, Self::TrustedSignerDoesNotExist(_))
    }
}
impl std::error::Error for CreateStreamingDistributionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AccessDenied(_inner) => Some(_inner),
            Self::CnameAlreadyExists(_inner) => Some(_inner),
            Self::InconsistentQuantities(_inner) => Some(_inner),
            Self::InvalidArgument(_inner) => Some(_inner),
            Self::InvalidOrigin(_inner) => Some(_inner),
            Self::InvalidOriginAccessControl(_inner) => Some(_inner),
            Self::InvalidOriginAccessIdentity(_inner) => Some(_inner),
            Self::MissingBody(_inner) => Some(_inner),
            Self::StreamingDistributionAlreadyExists(_inner) => Some(_inner),
            Self::TooManyStreamingDistributionCnamEs(_inner) => Some(_inner),
            Self::TooManyStreamingDistributions(_inner) => Some(_inner),
            Self::TooManyTrustedSigners(_inner) => Some(_inner),
            Self::TrustedSignerDoesNotExist(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type CreateResponseHeadersPolicyErrorKind = CreateResponseHeadersPolicyError;
/// Error type for the `CreateResponseHeadersPolicyError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateResponseHeadersPolicyError {
    /// <p>Access denied.</p>
    AccessDenied(crate::error::AccessDenied),
    /// <p>The value of <code>Quantity</code> and the size of <code>Items</code> don't match.</p>
    InconsistentQuantities(crate::error::InconsistentQuantities),
    /// <p>An argument is invalid.</p>
    InvalidArgument(crate::error::InvalidArgument),
    /// <p>A response headers policy with this name already exists. You must provide a unique name. To modify an existing response headers policy, use <code>UpdateResponseHeadersPolicy</code>.</p>
    ResponseHeadersPolicyAlreadyExists(crate::error::ResponseHeadersPolicyAlreadyExists),
    /// <p>The length of the <code>Content-Security-Policy</code> header value in the response headers policy exceeds the maximum.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
    TooLongCspInResponseHeadersPolicy(crate::error::TooLongCspInResponseHeadersPolicy),
    /// <p>The number of custom headers in the response headers policy exceeds the maximum.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
    TooManyCustomHeadersInResponseHeadersPolicy(
        crate::error::TooManyCustomHeadersInResponseHeadersPolicy,
    ),
    /// <p>The number of headers in <code>RemoveHeadersConfig</code> in the response headers policy exceeds the maximum.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
    TooManyRemoveHeadersInResponseHeadersPolicy(
        crate::error::TooManyRemoveHeadersInResponseHeadersPolicy,
    ),
    /// <p>You have reached the maximum number of response headers policies for this Amazon Web Services account.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
    TooManyResponseHeadersPolicies(crate::error::TooManyResponseHeadersPolicies),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for CreateResponseHeadersPolicyError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for CreateResponseHeadersPolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AccessDenied(_inner) => _inner.fmt(f),
            Self::InconsistentQuantities(_inner) => _inner.fmt(f),
            Self::InvalidArgument(_inner) => _inner.fmt(f),
            Self::ResponseHeadersPolicyAlreadyExists(_inner) => _inner.fmt(f),
            Self::TooLongCspInResponseHeadersPolicy(_inner) => _inner.fmt(f),
            Self::TooManyCustomHeadersInResponseHeadersPolicy(_inner) => _inner.fmt(f),
            Self::TooManyRemoveHeadersInResponseHeadersPolicy(_inner) => _inner.fmt(f),
            Self::TooManyResponseHeadersPolicies(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CreateResponseHeadersPolicyError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AccessDenied(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InconsistentQuantities(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidArgument(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ResponseHeadersPolicyAlreadyExists(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooLongCspInResponseHeadersPolicy(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyCustomHeadersInResponseHeadersPolicy(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyRemoveHeadersInResponseHeadersPolicy(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyResponseHeadersPolicies(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::CreateResponseHeadersPolicyError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateResponseHeadersPolicyError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateResponseHeadersPolicyError {
    /// Creates the `CreateResponseHeadersPolicyError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `CreateResponseHeadersPolicyError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AccessDenied(e) => e.meta(),
            Self::InconsistentQuantities(e) => e.meta(),
            Self::InvalidArgument(e) => e.meta(),
            Self::ResponseHeadersPolicyAlreadyExists(e) => e.meta(),
            Self::TooLongCspInResponseHeadersPolicy(e) => e.meta(),
            Self::TooManyCustomHeadersInResponseHeadersPolicy(e) => e.meta(),
            Self::TooManyRemoveHeadersInResponseHeadersPolicy(e) => e.meta(),
            Self::TooManyResponseHeadersPolicies(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `CreateResponseHeadersPolicyError::AccessDenied`.
    pub fn is_access_denied(&self) -> bool {
        matches!(self, Self::AccessDenied(_))
    }
    /// Returns `true` if the error kind is `CreateResponseHeadersPolicyError::InconsistentQuantities`.
    pub fn is_inconsistent_quantities(&self) -> bool {
        matches!(self, Self::InconsistentQuantities(_))
    }
    /// Returns `true` if the error kind is `CreateResponseHeadersPolicyError::InvalidArgument`.
    pub fn is_invalid_argument(&self) -> bool {
        matches!(self, Self::InvalidArgument(_))
    }
    /// Returns `true` if the error kind is `CreateResponseHeadersPolicyError::ResponseHeadersPolicyAlreadyExists`.
    pub fn is_response_headers_policy_already_exists(&self) -> bool {
        matches!(self, Self::ResponseHeadersPolicyAlreadyExists(_))
    }
    /// Returns `true` if the error kind is `CreateResponseHeadersPolicyError::TooLongCspInResponseHeadersPolicy`.
    pub fn is_too_long_csp_in_response_headers_policy(&self) -> bool {
        matches!(self, Self::TooLongCspInResponseHeadersPolicy(_))
    }
    /// Returns `true` if the error kind is `CreateResponseHeadersPolicyError::TooManyCustomHeadersInResponseHeadersPolicy`.
    pub fn is_too_many_custom_headers_in_response_headers_policy(&self) -> bool {
        matches!(self, Self::TooManyCustomHeadersInResponseHeadersPolicy(_))
    }
    /// Returns `true` if the error kind is `CreateResponseHeadersPolicyError::TooManyRemoveHeadersInResponseHeadersPolicy`.
    pub fn is_too_many_remove_headers_in_response_headers_policy(&self) -> bool {
        matches!(self, Self::TooManyRemoveHeadersInResponseHeadersPolicy(_))
    }
    /// Returns `true` if the error kind is `CreateResponseHeadersPolicyError::TooManyResponseHeadersPolicies`.
    pub fn is_too_many_response_headers_policies(&self) -> bool {
        matches!(self, Self::TooManyResponseHeadersPolicies(_))
    }
}
impl std::error::Error for CreateResponseHeadersPolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AccessDenied(_inner) => Some(_inner),
            Self::InconsistentQuantities(_inner) => Some(_inner),
            Self::InvalidArgument(_inner) => Some(_inner),
            Self::ResponseHeadersPolicyAlreadyExists(_inner) => Some(_inner),
            Self::TooLongCspInResponseHeadersPolicy(_inner) => Some(_inner),
            Self::TooManyCustomHeadersInResponseHeadersPolicy(_inner) => Some(_inner),
            Self::TooManyRemoveHeadersInResponseHeadersPolicy(_inner) => Some(_inner),
            Self::TooManyResponseHeadersPolicies(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>You have reached the maximum number of response headers policies for this Amazon Web Services account.</p>
/// <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TooManyResponseHeadersPolicies {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl TooManyResponseHeadersPolicies {
    /// Creates a new builder-style object to manufacture [`TooManyResponseHeadersPolicies`](crate::error::TooManyResponseHeadersPolicies).
    pub fn builder() -> crate::error::too_many_response_headers_policies::Builder {
        crate::error::too_many_response_headers_policies::Builder::default()
    }
}
/// See [`TooManyResponseHeadersPolicies`](crate::error::TooManyResponseHeadersPolicies).
pub mod too_many_response_headers_policies {

    /// A builder for [`TooManyResponseHeadersPolicies`](crate::error::TooManyResponseHeadersPolicies).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`TooManyResponseHeadersPolicies`](crate::error::TooManyResponseHeadersPolicies).
        pub fn build(self) -> crate::error::TooManyResponseHeadersPolicies {
            crate::error::TooManyResponseHeadersPolicies {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl TooManyResponseHeadersPolicies {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TooManyResponseHeadersPolicies {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TooManyResponseHeadersPolicies")?;
        if let Some(inner_120) = &self.message {
            {
                write!(f, ": {}", inner_120)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for TooManyResponseHeadersPolicies {}
impl aws_http::request_id::RequestId for crate::error::TooManyResponseHeadersPolicies {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for TooManyResponseHeadersPolicies {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type CreateRealtimeLogConfigErrorKind = CreateRealtimeLogConfigError;
/// Error type for the `CreateRealtimeLogConfigError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateRealtimeLogConfigError {
    /// <p>Access denied.</p>
    AccessDenied(crate::error::AccessDenied),
    /// <p>An argument is invalid.</p>
    InvalidArgument(crate::error::InvalidArgument),
    /// <p>A real-time log configuration with this name already exists. You must provide a unique name. To modify an existing real-time log configuration, use <code>UpdateRealtimeLogConfig</code>.</p>
    RealtimeLogConfigAlreadyExists(crate::error::RealtimeLogConfigAlreadyExists),
    /// <p>You have reached the maximum number of real-time log configurations for this Amazon Web Services account. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
    TooManyRealtimeLogConfigs(crate::error::TooManyRealtimeLogConfigs),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for CreateRealtimeLogConfigError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for CreateRealtimeLogConfigError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AccessDenied(_inner) => _inner.fmt(f),
            Self::InvalidArgument(_inner) => _inner.fmt(f),
            Self::RealtimeLogConfigAlreadyExists(_inner) => _inner.fmt(f),
            Self::TooManyRealtimeLogConfigs(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CreateRealtimeLogConfigError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AccessDenied(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidArgument(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RealtimeLogConfigAlreadyExists(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyRealtimeLogConfigs(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::CreateRealtimeLogConfigError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateRealtimeLogConfigError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateRealtimeLogConfigError {
    /// Creates the `CreateRealtimeLogConfigError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `CreateRealtimeLogConfigError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AccessDenied(e) => e.meta(),
            Self::InvalidArgument(e) => e.meta(),
            Self::RealtimeLogConfigAlreadyExists(e) => e.meta(),
            Self::TooManyRealtimeLogConfigs(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `CreateRealtimeLogConfigError::AccessDenied`.
    pub fn is_access_denied(&self) -> bool {
        matches!(self, Self::AccessDenied(_))
    }
    /// Returns `true` if the error kind is `CreateRealtimeLogConfigError::InvalidArgument`.
    pub fn is_invalid_argument(&self) -> bool {
        matches!(self, Self::InvalidArgument(_))
    }
    /// Returns `true` if the error kind is `CreateRealtimeLogConfigError::RealtimeLogConfigAlreadyExists`.
    pub fn is_realtime_log_config_already_exists(&self) -> bool {
        matches!(self, Self::RealtimeLogConfigAlreadyExists(_))
    }
    /// Returns `true` if the error kind is `CreateRealtimeLogConfigError::TooManyRealtimeLogConfigs`.
    pub fn is_too_many_realtime_log_configs(&self) -> bool {
        matches!(self, Self::TooManyRealtimeLogConfigs(_))
    }
}
impl std::error::Error for CreateRealtimeLogConfigError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AccessDenied(_inner) => Some(_inner),
            Self::InvalidArgument(_inner) => Some(_inner),
            Self::RealtimeLogConfigAlreadyExists(_inner) => Some(_inner),
            Self::TooManyRealtimeLogConfigs(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>You have reached the maximum number of real-time log configurations for this Amazon Web Services account. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TooManyRealtimeLogConfigs {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl TooManyRealtimeLogConfigs {
    /// Creates a new builder-style object to manufacture [`TooManyRealtimeLogConfigs`](crate::error::TooManyRealtimeLogConfigs).
    pub fn builder() -> crate::error::too_many_realtime_log_configs::Builder {
        crate::error::too_many_realtime_log_configs::Builder::default()
    }
}
/// See [`TooManyRealtimeLogConfigs`](crate::error::TooManyRealtimeLogConfigs).
pub mod too_many_realtime_log_configs {

    /// A builder for [`TooManyRealtimeLogConfigs`](crate::error::TooManyRealtimeLogConfigs).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`TooManyRealtimeLogConfigs`](crate::error::TooManyRealtimeLogConfigs).
        pub fn build(self) -> crate::error::TooManyRealtimeLogConfigs {
            crate::error::TooManyRealtimeLogConfigs {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl TooManyRealtimeLogConfigs {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TooManyRealtimeLogConfigs {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TooManyRealtimeLogConfigs")?;
        if let Some(inner_121) = &self.message {
            {
                write!(f, ": {}", inner_121)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for TooManyRealtimeLogConfigs {}
impl aws_http::request_id::RequestId for crate::error::TooManyRealtimeLogConfigs {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for TooManyRealtimeLogConfigs {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>A real-time log configuration with this name already exists. You must provide a unique name. To modify an existing real-time log configuration, use <code>UpdateRealtimeLogConfig</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RealtimeLogConfigAlreadyExists {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl RealtimeLogConfigAlreadyExists {
    /// Creates a new builder-style object to manufacture [`RealtimeLogConfigAlreadyExists`](crate::error::RealtimeLogConfigAlreadyExists).
    pub fn builder() -> crate::error::realtime_log_config_already_exists::Builder {
        crate::error::realtime_log_config_already_exists::Builder::default()
    }
}
/// See [`RealtimeLogConfigAlreadyExists`](crate::error::RealtimeLogConfigAlreadyExists).
pub mod realtime_log_config_already_exists {

    /// A builder for [`RealtimeLogConfigAlreadyExists`](crate::error::RealtimeLogConfigAlreadyExists).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`RealtimeLogConfigAlreadyExists`](crate::error::RealtimeLogConfigAlreadyExists).
        pub fn build(self) -> crate::error::RealtimeLogConfigAlreadyExists {
            crate::error::RealtimeLogConfigAlreadyExists {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl RealtimeLogConfigAlreadyExists {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for RealtimeLogConfigAlreadyExists {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "RealtimeLogConfigAlreadyExists")?;
        if let Some(inner_122) = &self.message {
            {
                write!(f, ": {}", inner_122)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for RealtimeLogConfigAlreadyExists {}
impl aws_http::request_id::RequestId for crate::error::RealtimeLogConfigAlreadyExists {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for RealtimeLogConfigAlreadyExists {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type CreatePublicKeyErrorKind = CreatePublicKeyError;
/// Error type for the `CreatePublicKeyError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreatePublicKeyError {
    /// <p>An argument is invalid.</p>
    InvalidArgument(crate::error::InvalidArgument),
    /// <p>The specified public key already exists.</p>
    PublicKeyAlreadyExists(crate::error::PublicKeyAlreadyExists),
    /// <p>The maximum number of public keys for field-level encryption have been created. To create a new public key, delete one of the existing keys.</p>
    TooManyPublicKeys(crate::error::TooManyPublicKeys),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for CreatePublicKeyError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for CreatePublicKeyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::InvalidArgument(_inner) => _inner.fmt(f),
            Self::PublicKeyAlreadyExists(_inner) => _inner.fmt(f),
            Self::TooManyPublicKeys(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CreatePublicKeyError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::InvalidArgument(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::PublicKeyAlreadyExists(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyPublicKeys(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::CreatePublicKeyError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreatePublicKeyError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreatePublicKeyError {
    /// Creates the `CreatePublicKeyError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `CreatePublicKeyError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::InvalidArgument(e) => e.meta(),
            Self::PublicKeyAlreadyExists(e) => e.meta(),
            Self::TooManyPublicKeys(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `CreatePublicKeyError::InvalidArgument`.
    pub fn is_invalid_argument(&self) -> bool {
        matches!(self, Self::InvalidArgument(_))
    }
    /// Returns `true` if the error kind is `CreatePublicKeyError::PublicKeyAlreadyExists`.
    pub fn is_public_key_already_exists(&self) -> bool {
        matches!(self, Self::PublicKeyAlreadyExists(_))
    }
    /// Returns `true` if the error kind is `CreatePublicKeyError::TooManyPublicKeys`.
    pub fn is_too_many_public_keys(&self) -> bool {
        matches!(self, Self::TooManyPublicKeys(_))
    }
}
impl std::error::Error for CreatePublicKeyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::InvalidArgument(_inner) => Some(_inner),
            Self::PublicKeyAlreadyExists(_inner) => Some(_inner),
            Self::TooManyPublicKeys(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The maximum number of public keys for field-level encryption have been created. To create a new public key, delete one of the existing keys.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TooManyPublicKeys {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl TooManyPublicKeys {
    /// Creates a new builder-style object to manufacture [`TooManyPublicKeys`](crate::error::TooManyPublicKeys).
    pub fn builder() -> crate::error::too_many_public_keys::Builder {
        crate::error::too_many_public_keys::Builder::default()
    }
}
/// See [`TooManyPublicKeys`](crate::error::TooManyPublicKeys).
pub mod too_many_public_keys {

    /// A builder for [`TooManyPublicKeys`](crate::error::TooManyPublicKeys).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`TooManyPublicKeys`](crate::error::TooManyPublicKeys).
        pub fn build(self) -> crate::error::TooManyPublicKeys {
            crate::error::TooManyPublicKeys {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl TooManyPublicKeys {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TooManyPublicKeys {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TooManyPublicKeys")?;
        if let Some(inner_123) = &self.message {
            {
                write!(f, ": {}", inner_123)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for TooManyPublicKeys {}
impl aws_http::request_id::RequestId for crate::error::TooManyPublicKeys {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for TooManyPublicKeys {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The specified public key already exists.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PublicKeyAlreadyExists {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl PublicKeyAlreadyExists {
    /// Creates a new builder-style object to manufacture [`PublicKeyAlreadyExists`](crate::error::PublicKeyAlreadyExists).
    pub fn builder() -> crate::error::public_key_already_exists::Builder {
        crate::error::public_key_already_exists::Builder::default()
    }
}
/// See [`PublicKeyAlreadyExists`](crate::error::PublicKeyAlreadyExists).
pub mod public_key_already_exists {

    /// A builder for [`PublicKeyAlreadyExists`](crate::error::PublicKeyAlreadyExists).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`PublicKeyAlreadyExists`](crate::error::PublicKeyAlreadyExists).
        pub fn build(self) -> crate::error::PublicKeyAlreadyExists {
            crate::error::PublicKeyAlreadyExists {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl PublicKeyAlreadyExists {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for PublicKeyAlreadyExists {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "PublicKeyAlreadyExists")?;
        if let Some(inner_124) = &self.message {
            {
                write!(f, ": {}", inner_124)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for PublicKeyAlreadyExists {}
impl aws_http::request_id::RequestId for crate::error::PublicKeyAlreadyExists {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for PublicKeyAlreadyExists {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type CreateOriginRequestPolicyErrorKind = CreateOriginRequestPolicyError;
/// Error type for the `CreateOriginRequestPolicyError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateOriginRequestPolicyError {
    /// <p>Access denied.</p>
    AccessDenied(crate::error::AccessDenied),
    /// <p>The value of <code>Quantity</code> and the size of <code>Items</code> don't match.</p>
    InconsistentQuantities(crate::error::InconsistentQuantities),
    /// <p>An argument is invalid.</p>
    InvalidArgument(crate::error::InvalidArgument),
    /// <p>An origin request policy with this name already exists. You must provide a unique name. To modify an existing origin request policy, use <code>UpdateOriginRequestPolicy</code>.</p>
    OriginRequestPolicyAlreadyExists(crate::error::OriginRequestPolicyAlreadyExists),
    /// <p>The number of cookies in the origin request policy exceeds the maximum. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
    TooManyCookiesInOriginRequestPolicy(crate::error::TooManyCookiesInOriginRequestPolicy),
    /// <p>The number of headers in the origin request policy exceeds the maximum. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
    TooManyHeadersInOriginRequestPolicy(crate::error::TooManyHeadersInOriginRequestPolicy),
    /// <p>You have reached the maximum number of origin request policies for this Amazon Web Services account. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
    TooManyOriginRequestPolicies(crate::error::TooManyOriginRequestPolicies),
    /// <p>The number of query strings in the origin request policy exceeds the maximum. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
    TooManyQueryStringsInOriginRequestPolicy(
        crate::error::TooManyQueryStringsInOriginRequestPolicy,
    ),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for CreateOriginRequestPolicyError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for CreateOriginRequestPolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AccessDenied(_inner) => _inner.fmt(f),
            Self::InconsistentQuantities(_inner) => _inner.fmt(f),
            Self::InvalidArgument(_inner) => _inner.fmt(f),
            Self::OriginRequestPolicyAlreadyExists(_inner) => _inner.fmt(f),
            Self::TooManyCookiesInOriginRequestPolicy(_inner) => _inner.fmt(f),
            Self::TooManyHeadersInOriginRequestPolicy(_inner) => _inner.fmt(f),
            Self::TooManyOriginRequestPolicies(_inner) => _inner.fmt(f),
            Self::TooManyQueryStringsInOriginRequestPolicy(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CreateOriginRequestPolicyError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AccessDenied(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InconsistentQuantities(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidArgument(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::OriginRequestPolicyAlreadyExists(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyCookiesInOriginRequestPolicy(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyHeadersInOriginRequestPolicy(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyOriginRequestPolicies(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyQueryStringsInOriginRequestPolicy(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::CreateOriginRequestPolicyError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateOriginRequestPolicyError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateOriginRequestPolicyError {
    /// Creates the `CreateOriginRequestPolicyError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `CreateOriginRequestPolicyError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AccessDenied(e) => e.meta(),
            Self::InconsistentQuantities(e) => e.meta(),
            Self::InvalidArgument(e) => e.meta(),
            Self::OriginRequestPolicyAlreadyExists(e) => e.meta(),
            Self::TooManyCookiesInOriginRequestPolicy(e) => e.meta(),
            Self::TooManyHeadersInOriginRequestPolicy(e) => e.meta(),
            Self::TooManyOriginRequestPolicies(e) => e.meta(),
            Self::TooManyQueryStringsInOriginRequestPolicy(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `CreateOriginRequestPolicyError::AccessDenied`.
    pub fn is_access_denied(&self) -> bool {
        matches!(self, Self::AccessDenied(_))
    }
    /// Returns `true` if the error kind is `CreateOriginRequestPolicyError::InconsistentQuantities`.
    pub fn is_inconsistent_quantities(&self) -> bool {
        matches!(self, Self::InconsistentQuantities(_))
    }
    /// Returns `true` if the error kind is `CreateOriginRequestPolicyError::InvalidArgument`.
    pub fn is_invalid_argument(&self) -> bool {
        matches!(self, Self::InvalidArgument(_))
    }
    /// Returns `true` if the error kind is `CreateOriginRequestPolicyError::OriginRequestPolicyAlreadyExists`.
    pub fn is_origin_request_policy_already_exists(&self) -> bool {
        matches!(self, Self::OriginRequestPolicyAlreadyExists(_))
    }
    /// Returns `true` if the error kind is `CreateOriginRequestPolicyError::TooManyCookiesInOriginRequestPolicy`.
    pub fn is_too_many_cookies_in_origin_request_policy(&self) -> bool {
        matches!(self, Self::TooManyCookiesInOriginRequestPolicy(_))
    }
    /// Returns `true` if the error kind is `CreateOriginRequestPolicyError::TooManyHeadersInOriginRequestPolicy`.
    pub fn is_too_many_headers_in_origin_request_policy(&self) -> bool {
        matches!(self, Self::TooManyHeadersInOriginRequestPolicy(_))
    }
    /// Returns `true` if the error kind is `CreateOriginRequestPolicyError::TooManyOriginRequestPolicies`.
    pub fn is_too_many_origin_request_policies(&self) -> bool {
        matches!(self, Self::TooManyOriginRequestPolicies(_))
    }
    /// Returns `true` if the error kind is `CreateOriginRequestPolicyError::TooManyQueryStringsInOriginRequestPolicy`.
    pub fn is_too_many_query_strings_in_origin_request_policy(&self) -> bool {
        matches!(self, Self::TooManyQueryStringsInOriginRequestPolicy(_))
    }
}
impl std::error::Error for CreateOriginRequestPolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AccessDenied(_inner) => Some(_inner),
            Self::InconsistentQuantities(_inner) => Some(_inner),
            Self::InvalidArgument(_inner) => Some(_inner),
            Self::OriginRequestPolicyAlreadyExists(_inner) => Some(_inner),
            Self::TooManyCookiesInOriginRequestPolicy(_inner) => Some(_inner),
            Self::TooManyHeadersInOriginRequestPolicy(_inner) => Some(_inner),
            Self::TooManyOriginRequestPolicies(_inner) => Some(_inner),
            Self::TooManyQueryStringsInOriginRequestPolicy(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>You have reached the maximum number of origin request policies for this Amazon Web Services account. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TooManyOriginRequestPolicies {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl TooManyOriginRequestPolicies {
    /// Creates a new builder-style object to manufacture [`TooManyOriginRequestPolicies`](crate::error::TooManyOriginRequestPolicies).
    pub fn builder() -> crate::error::too_many_origin_request_policies::Builder {
        crate::error::too_many_origin_request_policies::Builder::default()
    }
}
/// See [`TooManyOriginRequestPolicies`](crate::error::TooManyOriginRequestPolicies).
pub mod too_many_origin_request_policies {

    /// A builder for [`TooManyOriginRequestPolicies`](crate::error::TooManyOriginRequestPolicies).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`TooManyOriginRequestPolicies`](crate::error::TooManyOriginRequestPolicies).
        pub fn build(self) -> crate::error::TooManyOriginRequestPolicies {
            crate::error::TooManyOriginRequestPolicies {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl TooManyOriginRequestPolicies {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TooManyOriginRequestPolicies {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TooManyOriginRequestPolicies")?;
        if let Some(inner_125) = &self.message {
            {
                write!(f, ": {}", inner_125)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for TooManyOriginRequestPolicies {}
impl aws_http::request_id::RequestId for crate::error::TooManyOriginRequestPolicies {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for TooManyOriginRequestPolicies {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type CreateOriginAccessControlErrorKind = CreateOriginAccessControlError;
/// Error type for the `CreateOriginAccessControlError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateOriginAccessControlError {
    /// <p>An argument is invalid.</p>
    InvalidArgument(crate::error::InvalidArgument),
    /// <p>An origin access control with the specified parameters already exists.</p>
    OriginAccessControlAlreadyExists(crate::error::OriginAccessControlAlreadyExists),
    /// <p>The number of origin access controls in your Amazon Web Services account exceeds the maximum allowed.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
    TooManyOriginAccessControls(crate::error::TooManyOriginAccessControls),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for CreateOriginAccessControlError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for CreateOriginAccessControlError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::InvalidArgument(_inner) => _inner.fmt(f),
            Self::OriginAccessControlAlreadyExists(_inner) => _inner.fmt(f),
            Self::TooManyOriginAccessControls(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CreateOriginAccessControlError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::InvalidArgument(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::OriginAccessControlAlreadyExists(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyOriginAccessControls(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::CreateOriginAccessControlError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateOriginAccessControlError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateOriginAccessControlError {
    /// Creates the `CreateOriginAccessControlError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `CreateOriginAccessControlError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::InvalidArgument(e) => e.meta(),
            Self::OriginAccessControlAlreadyExists(e) => e.meta(),
            Self::TooManyOriginAccessControls(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `CreateOriginAccessControlError::InvalidArgument`.
    pub fn is_invalid_argument(&self) -> bool {
        matches!(self, Self::InvalidArgument(_))
    }
    /// Returns `true` if the error kind is `CreateOriginAccessControlError::OriginAccessControlAlreadyExists`.
    pub fn is_origin_access_control_already_exists(&self) -> bool {
        matches!(self, Self::OriginAccessControlAlreadyExists(_))
    }
    /// Returns `true` if the error kind is `CreateOriginAccessControlError::TooManyOriginAccessControls`.
    pub fn is_too_many_origin_access_controls(&self) -> bool {
        matches!(self, Self::TooManyOriginAccessControls(_))
    }
}
impl std::error::Error for CreateOriginAccessControlError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::InvalidArgument(_inner) => Some(_inner),
            Self::OriginAccessControlAlreadyExists(_inner) => Some(_inner),
            Self::TooManyOriginAccessControls(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The number of origin access controls in your Amazon Web Services account exceeds the maximum allowed.</p>
/// <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TooManyOriginAccessControls {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl TooManyOriginAccessControls {
    /// Creates a new builder-style object to manufacture [`TooManyOriginAccessControls`](crate::error::TooManyOriginAccessControls).
    pub fn builder() -> crate::error::too_many_origin_access_controls::Builder {
        crate::error::too_many_origin_access_controls::Builder::default()
    }
}
/// See [`TooManyOriginAccessControls`](crate::error::TooManyOriginAccessControls).
pub mod too_many_origin_access_controls {

    /// A builder for [`TooManyOriginAccessControls`](crate::error::TooManyOriginAccessControls).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`TooManyOriginAccessControls`](crate::error::TooManyOriginAccessControls).
        pub fn build(self) -> crate::error::TooManyOriginAccessControls {
            crate::error::TooManyOriginAccessControls {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl TooManyOriginAccessControls {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TooManyOriginAccessControls {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TooManyOriginAccessControls")?;
        if let Some(inner_126) = &self.message {
            {
                write!(f, ": {}", inner_126)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for TooManyOriginAccessControls {}
impl aws_http::request_id::RequestId for crate::error::TooManyOriginAccessControls {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for TooManyOriginAccessControls {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type CreateMonitoringSubscriptionErrorKind = CreateMonitoringSubscriptionError;
/// Error type for the `CreateMonitoringSubscriptionError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateMonitoringSubscriptionError {
    /// <p>Access denied.</p>
    AccessDenied(crate::error::AccessDenied),
    /// <p>A monitoring subscription already exists for the specified distribution.</p>
    MonitoringSubscriptionAlreadyExists(crate::error::MonitoringSubscriptionAlreadyExists),
    /// <p>The specified distribution does not exist.</p>
    NoSuchDistribution(crate::error::NoSuchDistribution),
    /// <p>This operation is not supported in this region.</p>
    UnsupportedOperation(crate::error::UnsupportedOperation),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for CreateMonitoringSubscriptionError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for CreateMonitoringSubscriptionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AccessDenied(_inner) => _inner.fmt(f),
            Self::MonitoringSubscriptionAlreadyExists(_inner) => _inner.fmt(f),
            Self::NoSuchDistribution(_inner) => _inner.fmt(f),
            Self::UnsupportedOperation(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CreateMonitoringSubscriptionError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AccessDenied(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::MonitoringSubscriptionAlreadyExists(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NoSuchDistribution(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnsupportedOperation(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::CreateMonitoringSubscriptionError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateMonitoringSubscriptionError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateMonitoringSubscriptionError {
    /// Creates the `CreateMonitoringSubscriptionError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `CreateMonitoringSubscriptionError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AccessDenied(e) => e.meta(),
            Self::MonitoringSubscriptionAlreadyExists(e) => e.meta(),
            Self::NoSuchDistribution(e) => e.meta(),
            Self::UnsupportedOperation(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `CreateMonitoringSubscriptionError::AccessDenied`.
    pub fn is_access_denied(&self) -> bool {
        matches!(self, Self::AccessDenied(_))
    }
    /// Returns `true` if the error kind is `CreateMonitoringSubscriptionError::MonitoringSubscriptionAlreadyExists`.
    pub fn is_monitoring_subscription_already_exists(&self) -> bool {
        matches!(self, Self::MonitoringSubscriptionAlreadyExists(_))
    }
    /// Returns `true` if the error kind is `CreateMonitoringSubscriptionError::NoSuchDistribution`.
    pub fn is_no_such_distribution(&self) -> bool {
        matches!(self, Self::NoSuchDistribution(_))
    }
    /// Returns `true` if the error kind is `CreateMonitoringSubscriptionError::UnsupportedOperation`.
    pub fn is_unsupported_operation(&self) -> bool {
        matches!(self, Self::UnsupportedOperation(_))
    }
}
impl std::error::Error for CreateMonitoringSubscriptionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AccessDenied(_inner) => Some(_inner),
            Self::MonitoringSubscriptionAlreadyExists(_inner) => Some(_inner),
            Self::NoSuchDistribution(_inner) => Some(_inner),
            Self::UnsupportedOperation(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>A monitoring subscription already exists for the specified distribution.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct MonitoringSubscriptionAlreadyExists {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl MonitoringSubscriptionAlreadyExists {
    /// Creates a new builder-style object to manufacture [`MonitoringSubscriptionAlreadyExists`](crate::error::MonitoringSubscriptionAlreadyExists).
    pub fn builder() -> crate::error::monitoring_subscription_already_exists::Builder {
        crate::error::monitoring_subscription_already_exists::Builder::default()
    }
}
/// See [`MonitoringSubscriptionAlreadyExists`](crate::error::MonitoringSubscriptionAlreadyExists).
pub mod monitoring_subscription_already_exists {

    /// A builder for [`MonitoringSubscriptionAlreadyExists`](crate::error::MonitoringSubscriptionAlreadyExists).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`MonitoringSubscriptionAlreadyExists`](crate::error::MonitoringSubscriptionAlreadyExists).
        pub fn build(self) -> crate::error::MonitoringSubscriptionAlreadyExists {
            crate::error::MonitoringSubscriptionAlreadyExists {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl MonitoringSubscriptionAlreadyExists {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for MonitoringSubscriptionAlreadyExists {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "MonitoringSubscriptionAlreadyExists")?;
        if let Some(inner_127) = &self.message {
            {
                write!(f, ": {}", inner_127)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for MonitoringSubscriptionAlreadyExists {}
impl aws_http::request_id::RequestId for crate::error::MonitoringSubscriptionAlreadyExists {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for MonitoringSubscriptionAlreadyExists
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type CreateKeyGroupErrorKind = CreateKeyGroupError;
/// Error type for the `CreateKeyGroupError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateKeyGroupError {
    /// <p>An argument is invalid.</p>
    InvalidArgument(crate::error::InvalidArgument),
    /// <p>A key group with this name already exists. You must provide a unique name. To modify an existing key group, use <code>UpdateKeyGroup</code>.</p>
    KeyGroupAlreadyExists(crate::error::KeyGroupAlreadyExists),
    /// <p>You have reached the maximum number of key groups for this Amazon Web Services account. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
    TooManyKeyGroups(crate::error::TooManyKeyGroups),
    /// <p>The number of public keys in this key group is more than the maximum allowed. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
    TooManyPublicKeysInKeyGroup(crate::error::TooManyPublicKeysInKeyGroup),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for CreateKeyGroupError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for CreateKeyGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::InvalidArgument(_inner) => _inner.fmt(f),
            Self::KeyGroupAlreadyExists(_inner) => _inner.fmt(f),
            Self::TooManyKeyGroups(_inner) => _inner.fmt(f),
            Self::TooManyPublicKeysInKeyGroup(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CreateKeyGroupError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::InvalidArgument(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::KeyGroupAlreadyExists(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyKeyGroups(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyPublicKeysInKeyGroup(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::CreateKeyGroupError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateKeyGroupError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateKeyGroupError {
    /// Creates the `CreateKeyGroupError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `CreateKeyGroupError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::InvalidArgument(e) => e.meta(),
            Self::KeyGroupAlreadyExists(e) => e.meta(),
            Self::TooManyKeyGroups(e) => e.meta(),
            Self::TooManyPublicKeysInKeyGroup(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `CreateKeyGroupError::InvalidArgument`.
    pub fn is_invalid_argument(&self) -> bool {
        matches!(self, Self::InvalidArgument(_))
    }
    /// Returns `true` if the error kind is `CreateKeyGroupError::KeyGroupAlreadyExists`.
    pub fn is_key_group_already_exists(&self) -> bool {
        matches!(self, Self::KeyGroupAlreadyExists(_))
    }
    /// Returns `true` if the error kind is `CreateKeyGroupError::TooManyKeyGroups`.
    pub fn is_too_many_key_groups(&self) -> bool {
        matches!(self, Self::TooManyKeyGroups(_))
    }
    /// Returns `true` if the error kind is `CreateKeyGroupError::TooManyPublicKeysInKeyGroup`.
    pub fn is_too_many_public_keys_in_key_group(&self) -> bool {
        matches!(self, Self::TooManyPublicKeysInKeyGroup(_))
    }
}
impl std::error::Error for CreateKeyGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::InvalidArgument(_inner) => Some(_inner),
            Self::KeyGroupAlreadyExists(_inner) => Some(_inner),
            Self::TooManyKeyGroups(_inner) => Some(_inner),
            Self::TooManyPublicKeysInKeyGroup(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>You have reached the maximum number of key groups for this Amazon Web Services account. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TooManyKeyGroups {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl TooManyKeyGroups {
    /// Creates a new builder-style object to manufacture [`TooManyKeyGroups`](crate::error::TooManyKeyGroups).
    pub fn builder() -> crate::error::too_many_key_groups::Builder {
        crate::error::too_many_key_groups::Builder::default()
    }
}
/// See [`TooManyKeyGroups`](crate::error::TooManyKeyGroups).
pub mod too_many_key_groups {

    /// A builder for [`TooManyKeyGroups`](crate::error::TooManyKeyGroups).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`TooManyKeyGroups`](crate::error::TooManyKeyGroups).
        pub fn build(self) -> crate::error::TooManyKeyGroups {
            crate::error::TooManyKeyGroups {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl TooManyKeyGroups {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TooManyKeyGroups {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TooManyKeyGroups")?;
        if let Some(inner_128) = &self.message {
            {
                write!(f, ": {}", inner_128)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for TooManyKeyGroups {}
impl aws_http::request_id::RequestId for crate::error::TooManyKeyGroups {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for TooManyKeyGroups {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type CreateInvalidationErrorKind = CreateInvalidationError;
/// Error type for the `CreateInvalidationError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateInvalidationError {
    /// <p>Access denied.</p>
    AccessDenied(crate::error::AccessDenied),
    /// <p>Invalidation batch specified is too large.</p>
    BatchTooLarge(crate::error::BatchTooLarge),
    /// <p>The value of <code>Quantity</code> and the size of <code>Items</code> don't match.</p>
    InconsistentQuantities(crate::error::InconsistentQuantities),
    /// <p>An argument is invalid.</p>
    InvalidArgument(crate::error::InvalidArgument),
    /// <p>This operation requires a body. Ensure that the body is present and the <code>Content-Type</code> header is set.</p>
    MissingBody(crate::error::MissingBody),
    /// <p>The specified distribution does not exist.</p>
    NoSuchDistribution(crate::error::NoSuchDistribution),
    /// <p>You have exceeded the maximum number of allowable InProgress invalidation batch requests, or invalidation objects.</p>
    TooManyInvalidationsInProgress(crate::error::TooManyInvalidationsInProgress),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for CreateInvalidationError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for CreateInvalidationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AccessDenied(_inner) => _inner.fmt(f),
            Self::BatchTooLarge(_inner) => _inner.fmt(f),
            Self::InconsistentQuantities(_inner) => _inner.fmt(f),
            Self::InvalidArgument(_inner) => _inner.fmt(f),
            Self::MissingBody(_inner) => _inner.fmt(f),
            Self::NoSuchDistribution(_inner) => _inner.fmt(f),
            Self::TooManyInvalidationsInProgress(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CreateInvalidationError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AccessDenied(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::BatchTooLarge(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InconsistentQuantities(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidArgument(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::MissingBody(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NoSuchDistribution(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyInvalidationsInProgress(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::CreateInvalidationError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateInvalidationError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateInvalidationError {
    /// Creates the `CreateInvalidationError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `CreateInvalidationError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AccessDenied(e) => e.meta(),
            Self::BatchTooLarge(e) => e.meta(),
            Self::InconsistentQuantities(e) => e.meta(),
            Self::InvalidArgument(e) => e.meta(),
            Self::MissingBody(e) => e.meta(),
            Self::NoSuchDistribution(e) => e.meta(),
            Self::TooManyInvalidationsInProgress(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `CreateInvalidationError::AccessDenied`.
    pub fn is_access_denied(&self) -> bool {
        matches!(self, Self::AccessDenied(_))
    }
    /// Returns `true` if the error kind is `CreateInvalidationError::BatchTooLarge`.
    pub fn is_batch_too_large(&self) -> bool {
        matches!(self, Self::BatchTooLarge(_))
    }
    /// Returns `true` if the error kind is `CreateInvalidationError::InconsistentQuantities`.
    pub fn is_inconsistent_quantities(&self) -> bool {
        matches!(self, Self::InconsistentQuantities(_))
    }
    /// Returns `true` if the error kind is `CreateInvalidationError::InvalidArgument`.
    pub fn is_invalid_argument(&self) -> bool {
        matches!(self, Self::InvalidArgument(_))
    }
    /// Returns `true` if the error kind is `CreateInvalidationError::MissingBody`.
    pub fn is_missing_body(&self) -> bool {
        matches!(self, Self::MissingBody(_))
    }
    /// Returns `true` if the error kind is `CreateInvalidationError::NoSuchDistribution`.
    pub fn is_no_such_distribution(&self) -> bool {
        matches!(self, Self::NoSuchDistribution(_))
    }
    /// Returns `true` if the error kind is `CreateInvalidationError::TooManyInvalidationsInProgress`.
    pub fn is_too_many_invalidations_in_progress(&self) -> bool {
        matches!(self, Self::TooManyInvalidationsInProgress(_))
    }
}
impl std::error::Error for CreateInvalidationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AccessDenied(_inner) => Some(_inner),
            Self::BatchTooLarge(_inner) => Some(_inner),
            Self::InconsistentQuantities(_inner) => Some(_inner),
            Self::InvalidArgument(_inner) => Some(_inner),
            Self::MissingBody(_inner) => Some(_inner),
            Self::NoSuchDistribution(_inner) => Some(_inner),
            Self::TooManyInvalidationsInProgress(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>You have exceeded the maximum number of allowable InProgress invalidation batch requests, or invalidation objects.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TooManyInvalidationsInProgress {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl TooManyInvalidationsInProgress {
    /// Creates a new builder-style object to manufacture [`TooManyInvalidationsInProgress`](crate::error::TooManyInvalidationsInProgress).
    pub fn builder() -> crate::error::too_many_invalidations_in_progress::Builder {
        crate::error::too_many_invalidations_in_progress::Builder::default()
    }
}
/// See [`TooManyInvalidationsInProgress`](crate::error::TooManyInvalidationsInProgress).
pub mod too_many_invalidations_in_progress {

    /// A builder for [`TooManyInvalidationsInProgress`](crate::error::TooManyInvalidationsInProgress).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`TooManyInvalidationsInProgress`](crate::error::TooManyInvalidationsInProgress).
        pub fn build(self) -> crate::error::TooManyInvalidationsInProgress {
            crate::error::TooManyInvalidationsInProgress {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl TooManyInvalidationsInProgress {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TooManyInvalidationsInProgress {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TooManyInvalidationsInProgress")?;
        if let Some(inner_129) = &self.message {
            {
                write!(f, ": {}", inner_129)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for TooManyInvalidationsInProgress {}
impl aws_http::request_id::RequestId for crate::error::TooManyInvalidationsInProgress {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for TooManyInvalidationsInProgress {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>Invalidation batch specified is too large.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BatchTooLarge {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl BatchTooLarge {
    /// Creates a new builder-style object to manufacture [`BatchTooLarge`](crate::error::BatchTooLarge).
    pub fn builder() -> crate::error::batch_too_large::Builder {
        crate::error::batch_too_large::Builder::default()
    }
}
/// See [`BatchTooLarge`](crate::error::BatchTooLarge).
pub mod batch_too_large {

    /// A builder for [`BatchTooLarge`](crate::error::BatchTooLarge).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`BatchTooLarge`](crate::error::BatchTooLarge).
        pub fn build(self) -> crate::error::BatchTooLarge {
            crate::error::BatchTooLarge {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl BatchTooLarge {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for BatchTooLarge {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "BatchTooLarge")?;
        if let Some(inner_130) = &self.message {
            {
                write!(f, ": {}", inner_130)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for BatchTooLarge {}
impl aws_http::request_id::RequestId for crate::error::BatchTooLarge {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for BatchTooLarge {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type CreateFunctionErrorKind = CreateFunctionError;
/// Error type for the `CreateFunctionError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateFunctionError {
    /// <p>A function with the same name already exists in this Amazon Web Services account. To create a function, you must provide a unique name. To update an existing function, use <code>UpdateFunction</code>.</p>
    FunctionAlreadyExists(crate::error::FunctionAlreadyExists),
    /// <p>The function is too large. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
    FunctionSizeLimitExceeded(crate::error::FunctionSizeLimitExceeded),
    /// <p>An argument is invalid.</p>
    InvalidArgument(crate::error::InvalidArgument),
    /// <p>You have reached the maximum number of CloudFront functions for this Amazon Web Services account. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
    TooManyFunctions(crate::error::TooManyFunctions),
    /// <p>This operation is not supported in this region.</p>
    UnsupportedOperation(crate::error::UnsupportedOperation),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for CreateFunctionError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for CreateFunctionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::FunctionAlreadyExists(_inner) => _inner.fmt(f),
            Self::FunctionSizeLimitExceeded(_inner) => _inner.fmt(f),
            Self::InvalidArgument(_inner) => _inner.fmt(f),
            Self::TooManyFunctions(_inner) => _inner.fmt(f),
            Self::UnsupportedOperation(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CreateFunctionError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::FunctionAlreadyExists(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::FunctionSizeLimitExceeded(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidArgument(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyFunctions(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnsupportedOperation(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::CreateFunctionError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateFunctionError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateFunctionError {
    /// Creates the `CreateFunctionError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `CreateFunctionError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::FunctionAlreadyExists(e) => e.meta(),
            Self::FunctionSizeLimitExceeded(e) => e.meta(),
            Self::InvalidArgument(e) => e.meta(),
            Self::TooManyFunctions(e) => e.meta(),
            Self::UnsupportedOperation(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `CreateFunctionError::FunctionAlreadyExists`.
    pub fn is_function_already_exists(&self) -> bool {
        matches!(self, Self::FunctionAlreadyExists(_))
    }
    /// Returns `true` if the error kind is `CreateFunctionError::FunctionSizeLimitExceeded`.
    pub fn is_function_size_limit_exceeded(&self) -> bool {
        matches!(self, Self::FunctionSizeLimitExceeded(_))
    }
    /// Returns `true` if the error kind is `CreateFunctionError::InvalidArgument`.
    pub fn is_invalid_argument(&self) -> bool {
        matches!(self, Self::InvalidArgument(_))
    }
    /// Returns `true` if the error kind is `CreateFunctionError::TooManyFunctions`.
    pub fn is_too_many_functions(&self) -> bool {
        matches!(self, Self::TooManyFunctions(_))
    }
    /// Returns `true` if the error kind is `CreateFunctionError::UnsupportedOperation`.
    pub fn is_unsupported_operation(&self) -> bool {
        matches!(self, Self::UnsupportedOperation(_))
    }
}
impl std::error::Error for CreateFunctionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::FunctionAlreadyExists(_inner) => Some(_inner),
            Self::FunctionSizeLimitExceeded(_inner) => Some(_inner),
            Self::InvalidArgument(_inner) => Some(_inner),
            Self::TooManyFunctions(_inner) => Some(_inner),
            Self::UnsupportedOperation(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>You have reached the maximum number of CloudFront functions for this Amazon Web Services account. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TooManyFunctions {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl TooManyFunctions {
    /// Creates a new builder-style object to manufacture [`TooManyFunctions`](crate::error::TooManyFunctions).
    pub fn builder() -> crate::error::too_many_functions::Builder {
        crate::error::too_many_functions::Builder::default()
    }
}
/// See [`TooManyFunctions`](crate::error::TooManyFunctions).
pub mod too_many_functions {

    /// A builder for [`TooManyFunctions`](crate::error::TooManyFunctions).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`TooManyFunctions`](crate::error::TooManyFunctions).
        pub fn build(self) -> crate::error::TooManyFunctions {
            crate::error::TooManyFunctions {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl TooManyFunctions {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TooManyFunctions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TooManyFunctions")?;
        if let Some(inner_131) = &self.message {
            {
                write!(f, ": {}", inner_131)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for TooManyFunctions {}
impl aws_http::request_id::RequestId for crate::error::TooManyFunctions {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for TooManyFunctions {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>A function with the same name already exists in this Amazon Web Services account. To create a function, you must provide a unique name. To update an existing function, use <code>UpdateFunction</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FunctionAlreadyExists {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl FunctionAlreadyExists {
    /// Creates a new builder-style object to manufacture [`FunctionAlreadyExists`](crate::error::FunctionAlreadyExists).
    pub fn builder() -> crate::error::function_already_exists::Builder {
        crate::error::function_already_exists::Builder::default()
    }
}
/// See [`FunctionAlreadyExists`](crate::error::FunctionAlreadyExists).
pub mod function_already_exists {

    /// A builder for [`FunctionAlreadyExists`](crate::error::FunctionAlreadyExists).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`FunctionAlreadyExists`](crate::error::FunctionAlreadyExists).
        pub fn build(self) -> crate::error::FunctionAlreadyExists {
            crate::error::FunctionAlreadyExists {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl FunctionAlreadyExists {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for FunctionAlreadyExists {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "FunctionAlreadyExists")?;
        if let Some(inner_132) = &self.message {
            {
                write!(f, ": {}", inner_132)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for FunctionAlreadyExists {}
impl aws_http::request_id::RequestId for crate::error::FunctionAlreadyExists {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for FunctionAlreadyExists {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type CreateFieldLevelEncryptionProfileErrorKind = CreateFieldLevelEncryptionProfileError;
/// Error type for the `CreateFieldLevelEncryptionProfileError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateFieldLevelEncryptionProfileError {
    /// <p>The specified profile for field-level encryption already exists.</p>
    FieldLevelEncryptionProfileAlreadyExists(
        crate::error::FieldLevelEncryptionProfileAlreadyExists,
    ),
    /// <p>The maximum size of a profile for field-level encryption was exceeded.</p>
    FieldLevelEncryptionProfileSizeExceeded(crate::error::FieldLevelEncryptionProfileSizeExceeded),
    /// <p>The value of <code>Quantity</code> and the size of <code>Items</code> don't match.</p>
    InconsistentQuantities(crate::error::InconsistentQuantities),
    /// <p>An argument is invalid.</p>
    InvalidArgument(crate::error::InvalidArgument),
    /// <p>The specified public key doesn't exist.</p>
    NoSuchPublicKey(crate::error::NoSuchPublicKey),
    /// <p>The maximum number of encryption entities for field-level encryption have been created.</p>
    TooManyFieldLevelEncryptionEncryptionEntities(
        crate::error::TooManyFieldLevelEncryptionEncryptionEntities,
    ),
    /// <p>The maximum number of field patterns for field-level encryption have been created.</p>
    TooManyFieldLevelEncryptionFieldPatterns(
        crate::error::TooManyFieldLevelEncryptionFieldPatterns,
    ),
    /// <p>The maximum number of profiles for field-level encryption have been created.</p>
    TooManyFieldLevelEncryptionProfiles(crate::error::TooManyFieldLevelEncryptionProfiles),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for CreateFieldLevelEncryptionProfileError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for CreateFieldLevelEncryptionProfileError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::FieldLevelEncryptionProfileAlreadyExists(_inner) => _inner.fmt(f),
            Self::FieldLevelEncryptionProfileSizeExceeded(_inner) => _inner.fmt(f),
            Self::InconsistentQuantities(_inner) => _inner.fmt(f),
            Self::InvalidArgument(_inner) => _inner.fmt(f),
            Self::NoSuchPublicKey(_inner) => _inner.fmt(f),
            Self::TooManyFieldLevelEncryptionEncryptionEntities(_inner) => _inner.fmt(f),
            Self::TooManyFieldLevelEncryptionFieldPatterns(_inner) => _inner.fmt(f),
            Self::TooManyFieldLevelEncryptionProfiles(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for CreateFieldLevelEncryptionProfileError
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::FieldLevelEncryptionProfileAlreadyExists(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::FieldLevelEncryptionProfileSizeExceeded(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InconsistentQuantities(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidArgument(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NoSuchPublicKey(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyFieldLevelEncryptionEncryptionEntities(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyFieldLevelEncryptionFieldPatterns(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyFieldLevelEncryptionProfiles(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::CreateFieldLevelEncryptionProfileError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateFieldLevelEncryptionProfileError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateFieldLevelEncryptionProfileError {
    /// Creates the `CreateFieldLevelEncryptionProfileError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `CreateFieldLevelEncryptionProfileError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::FieldLevelEncryptionProfileAlreadyExists(e) => e.meta(),
            Self::FieldLevelEncryptionProfileSizeExceeded(e) => e.meta(),
            Self::InconsistentQuantities(e) => e.meta(),
            Self::InvalidArgument(e) => e.meta(),
            Self::NoSuchPublicKey(e) => e.meta(),
            Self::TooManyFieldLevelEncryptionEncryptionEntities(e) => e.meta(),
            Self::TooManyFieldLevelEncryptionFieldPatterns(e) => e.meta(),
            Self::TooManyFieldLevelEncryptionProfiles(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `CreateFieldLevelEncryptionProfileError::FieldLevelEncryptionProfileAlreadyExists`.
    pub fn is_field_level_encryption_profile_already_exists(&self) -> bool {
        matches!(self, Self::FieldLevelEncryptionProfileAlreadyExists(_))
    }
    /// Returns `true` if the error kind is `CreateFieldLevelEncryptionProfileError::FieldLevelEncryptionProfileSizeExceeded`.
    pub fn is_field_level_encryption_profile_size_exceeded(&self) -> bool {
        matches!(self, Self::FieldLevelEncryptionProfileSizeExceeded(_))
    }
    /// Returns `true` if the error kind is `CreateFieldLevelEncryptionProfileError::InconsistentQuantities`.
    pub fn is_inconsistent_quantities(&self) -> bool {
        matches!(self, Self::InconsistentQuantities(_))
    }
    /// Returns `true` if the error kind is `CreateFieldLevelEncryptionProfileError::InvalidArgument`.
    pub fn is_invalid_argument(&self) -> bool {
        matches!(self, Self::InvalidArgument(_))
    }
    /// Returns `true` if the error kind is `CreateFieldLevelEncryptionProfileError::NoSuchPublicKey`.
    pub fn is_no_such_public_key(&self) -> bool {
        matches!(self, Self::NoSuchPublicKey(_))
    }
    /// Returns `true` if the error kind is `CreateFieldLevelEncryptionProfileError::TooManyFieldLevelEncryptionEncryptionEntities`.
    pub fn is_too_many_field_level_encryption_encryption_entities(&self) -> bool {
        matches!(self, Self::TooManyFieldLevelEncryptionEncryptionEntities(_))
    }
    /// Returns `true` if the error kind is `CreateFieldLevelEncryptionProfileError::TooManyFieldLevelEncryptionFieldPatterns`.
    pub fn is_too_many_field_level_encryption_field_patterns(&self) -> bool {
        matches!(self, Self::TooManyFieldLevelEncryptionFieldPatterns(_))
    }
    /// Returns `true` if the error kind is `CreateFieldLevelEncryptionProfileError::TooManyFieldLevelEncryptionProfiles`.
    pub fn is_too_many_field_level_encryption_profiles(&self) -> bool {
        matches!(self, Self::TooManyFieldLevelEncryptionProfiles(_))
    }
}
impl std::error::Error for CreateFieldLevelEncryptionProfileError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::FieldLevelEncryptionProfileAlreadyExists(_inner) => Some(_inner),
            Self::FieldLevelEncryptionProfileSizeExceeded(_inner) => Some(_inner),
            Self::InconsistentQuantities(_inner) => Some(_inner),
            Self::InvalidArgument(_inner) => Some(_inner),
            Self::NoSuchPublicKey(_inner) => Some(_inner),
            Self::TooManyFieldLevelEncryptionEncryptionEntities(_inner) => Some(_inner),
            Self::TooManyFieldLevelEncryptionFieldPatterns(_inner) => Some(_inner),
            Self::TooManyFieldLevelEncryptionProfiles(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The maximum number of profiles for field-level encryption have been created.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TooManyFieldLevelEncryptionProfiles {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl TooManyFieldLevelEncryptionProfiles {
    /// Creates a new builder-style object to manufacture [`TooManyFieldLevelEncryptionProfiles`](crate::error::TooManyFieldLevelEncryptionProfiles).
    pub fn builder() -> crate::error::too_many_field_level_encryption_profiles::Builder {
        crate::error::too_many_field_level_encryption_profiles::Builder::default()
    }
}
/// See [`TooManyFieldLevelEncryptionProfiles`](crate::error::TooManyFieldLevelEncryptionProfiles).
pub mod too_many_field_level_encryption_profiles {

    /// A builder for [`TooManyFieldLevelEncryptionProfiles`](crate::error::TooManyFieldLevelEncryptionProfiles).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`TooManyFieldLevelEncryptionProfiles`](crate::error::TooManyFieldLevelEncryptionProfiles).
        pub fn build(self) -> crate::error::TooManyFieldLevelEncryptionProfiles {
            crate::error::TooManyFieldLevelEncryptionProfiles {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl TooManyFieldLevelEncryptionProfiles {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TooManyFieldLevelEncryptionProfiles {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TooManyFieldLevelEncryptionProfiles")?;
        if let Some(inner_133) = &self.message {
            {
                write!(f, ": {}", inner_133)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for TooManyFieldLevelEncryptionProfiles {}
impl aws_http::request_id::RequestId for crate::error::TooManyFieldLevelEncryptionProfiles {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for TooManyFieldLevelEncryptionProfiles
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type CreateFieldLevelEncryptionConfigErrorKind = CreateFieldLevelEncryptionConfigError;
/// Error type for the `CreateFieldLevelEncryptionConfigError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateFieldLevelEncryptionConfigError {
    /// <p>The specified configuration for field-level encryption already exists.</p>
    FieldLevelEncryptionConfigAlreadyExists(crate::error::FieldLevelEncryptionConfigAlreadyExists),
    /// <p>The value of <code>Quantity</code> and the size of <code>Items</code> don't match.</p>
    InconsistentQuantities(crate::error::InconsistentQuantities),
    /// <p>An argument is invalid.</p>
    InvalidArgument(crate::error::InvalidArgument),
    /// <p>The specified profile for field-level encryption doesn't exist.</p>
    NoSuchFieldLevelEncryptionProfile(crate::error::NoSuchFieldLevelEncryptionProfile),
    /// <p>No profile specified for the field-level encryption query argument.</p>
    QueryArgProfileEmpty(crate::error::QueryArgProfileEmpty),
    /// <p>The maximum number of configurations for field-level encryption have been created.</p>
    TooManyFieldLevelEncryptionConfigs(crate::error::TooManyFieldLevelEncryptionConfigs),
    /// <p>The maximum number of content type profiles for field-level encryption have been created.</p>
    TooManyFieldLevelEncryptionContentTypeProfiles(
        crate::error::TooManyFieldLevelEncryptionContentTypeProfiles,
    ),
    /// <p>The maximum number of query arg profiles for field-level encryption have been created.</p>
    TooManyFieldLevelEncryptionQueryArgProfiles(
        crate::error::TooManyFieldLevelEncryptionQueryArgProfiles,
    ),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for CreateFieldLevelEncryptionConfigError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for CreateFieldLevelEncryptionConfigError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::FieldLevelEncryptionConfigAlreadyExists(_inner) => _inner.fmt(f),
            Self::InconsistentQuantities(_inner) => _inner.fmt(f),
            Self::InvalidArgument(_inner) => _inner.fmt(f),
            Self::NoSuchFieldLevelEncryptionProfile(_inner) => _inner.fmt(f),
            Self::QueryArgProfileEmpty(_inner) => _inner.fmt(f),
            Self::TooManyFieldLevelEncryptionConfigs(_inner) => _inner.fmt(f),
            Self::TooManyFieldLevelEncryptionContentTypeProfiles(_inner) => _inner.fmt(f),
            Self::TooManyFieldLevelEncryptionQueryArgProfiles(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for CreateFieldLevelEncryptionConfigError
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::FieldLevelEncryptionConfigAlreadyExists(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InconsistentQuantities(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidArgument(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NoSuchFieldLevelEncryptionProfile(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::QueryArgProfileEmpty(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyFieldLevelEncryptionConfigs(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyFieldLevelEncryptionContentTypeProfiles(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyFieldLevelEncryptionQueryArgProfiles(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::CreateFieldLevelEncryptionConfigError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateFieldLevelEncryptionConfigError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateFieldLevelEncryptionConfigError {
    /// Creates the `CreateFieldLevelEncryptionConfigError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `CreateFieldLevelEncryptionConfigError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::FieldLevelEncryptionConfigAlreadyExists(e) => e.meta(),
            Self::InconsistentQuantities(e) => e.meta(),
            Self::InvalidArgument(e) => e.meta(),
            Self::NoSuchFieldLevelEncryptionProfile(e) => e.meta(),
            Self::QueryArgProfileEmpty(e) => e.meta(),
            Self::TooManyFieldLevelEncryptionConfigs(e) => e.meta(),
            Self::TooManyFieldLevelEncryptionContentTypeProfiles(e) => e.meta(),
            Self::TooManyFieldLevelEncryptionQueryArgProfiles(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `CreateFieldLevelEncryptionConfigError::FieldLevelEncryptionConfigAlreadyExists`.
    pub fn is_field_level_encryption_config_already_exists(&self) -> bool {
        matches!(self, Self::FieldLevelEncryptionConfigAlreadyExists(_))
    }
    /// Returns `true` if the error kind is `CreateFieldLevelEncryptionConfigError::InconsistentQuantities`.
    pub fn is_inconsistent_quantities(&self) -> bool {
        matches!(self, Self::InconsistentQuantities(_))
    }
    /// Returns `true` if the error kind is `CreateFieldLevelEncryptionConfigError::InvalidArgument`.
    pub fn is_invalid_argument(&self) -> bool {
        matches!(self, Self::InvalidArgument(_))
    }
    /// Returns `true` if the error kind is `CreateFieldLevelEncryptionConfigError::NoSuchFieldLevelEncryptionProfile`.
    pub fn is_no_such_field_level_encryption_profile(&self) -> bool {
        matches!(self, Self::NoSuchFieldLevelEncryptionProfile(_))
    }
    /// Returns `true` if the error kind is `CreateFieldLevelEncryptionConfigError::QueryArgProfileEmpty`.
    pub fn is_query_arg_profile_empty(&self) -> bool {
        matches!(self, Self::QueryArgProfileEmpty(_))
    }
    /// Returns `true` if the error kind is `CreateFieldLevelEncryptionConfigError::TooManyFieldLevelEncryptionConfigs`.
    pub fn is_too_many_field_level_encryption_configs(&self) -> bool {
        matches!(self, Self::TooManyFieldLevelEncryptionConfigs(_))
    }
    /// Returns `true` if the error kind is `CreateFieldLevelEncryptionConfigError::TooManyFieldLevelEncryptionContentTypeProfiles`.
    pub fn is_too_many_field_level_encryption_content_type_profiles(&self) -> bool {
        matches!(
            self,
            Self::TooManyFieldLevelEncryptionContentTypeProfiles(_)
        )
    }
    /// Returns `true` if the error kind is `CreateFieldLevelEncryptionConfigError::TooManyFieldLevelEncryptionQueryArgProfiles`.
    pub fn is_too_many_field_level_encryption_query_arg_profiles(&self) -> bool {
        matches!(self, Self::TooManyFieldLevelEncryptionQueryArgProfiles(_))
    }
}
impl std::error::Error for CreateFieldLevelEncryptionConfigError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::FieldLevelEncryptionConfigAlreadyExists(_inner) => Some(_inner),
            Self::InconsistentQuantities(_inner) => Some(_inner),
            Self::InvalidArgument(_inner) => Some(_inner),
            Self::NoSuchFieldLevelEncryptionProfile(_inner) => Some(_inner),
            Self::QueryArgProfileEmpty(_inner) => Some(_inner),
            Self::TooManyFieldLevelEncryptionConfigs(_inner) => Some(_inner),
            Self::TooManyFieldLevelEncryptionContentTypeProfiles(_inner) => Some(_inner),
            Self::TooManyFieldLevelEncryptionQueryArgProfiles(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The maximum number of configurations for field-level encryption have been created.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TooManyFieldLevelEncryptionConfigs {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl TooManyFieldLevelEncryptionConfigs {
    /// Creates a new builder-style object to manufacture [`TooManyFieldLevelEncryptionConfigs`](crate::error::TooManyFieldLevelEncryptionConfigs).
    pub fn builder() -> crate::error::too_many_field_level_encryption_configs::Builder {
        crate::error::too_many_field_level_encryption_configs::Builder::default()
    }
}
/// See [`TooManyFieldLevelEncryptionConfigs`](crate::error::TooManyFieldLevelEncryptionConfigs).
pub mod too_many_field_level_encryption_configs {

    /// A builder for [`TooManyFieldLevelEncryptionConfigs`](crate::error::TooManyFieldLevelEncryptionConfigs).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`TooManyFieldLevelEncryptionConfigs`](crate::error::TooManyFieldLevelEncryptionConfigs).
        pub fn build(self) -> crate::error::TooManyFieldLevelEncryptionConfigs {
            crate::error::TooManyFieldLevelEncryptionConfigs {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl TooManyFieldLevelEncryptionConfigs {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TooManyFieldLevelEncryptionConfigs {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TooManyFieldLevelEncryptionConfigs")?;
        if let Some(inner_134) = &self.message {
            {
                write!(f, ": {}", inner_134)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for TooManyFieldLevelEncryptionConfigs {}
impl aws_http::request_id::RequestId for crate::error::TooManyFieldLevelEncryptionConfigs {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for TooManyFieldLevelEncryptionConfigs
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The specified configuration for field-level encryption already exists.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FieldLevelEncryptionConfigAlreadyExists {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl FieldLevelEncryptionConfigAlreadyExists {
    /// Creates a new builder-style object to manufacture [`FieldLevelEncryptionConfigAlreadyExists`](crate::error::FieldLevelEncryptionConfigAlreadyExists).
    pub fn builder() -> crate::error::field_level_encryption_config_already_exists::Builder {
        crate::error::field_level_encryption_config_already_exists::Builder::default()
    }
}
/// See [`FieldLevelEncryptionConfigAlreadyExists`](crate::error::FieldLevelEncryptionConfigAlreadyExists).
pub mod field_level_encryption_config_already_exists {

    /// A builder for [`FieldLevelEncryptionConfigAlreadyExists`](crate::error::FieldLevelEncryptionConfigAlreadyExists).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`FieldLevelEncryptionConfigAlreadyExists`](crate::error::FieldLevelEncryptionConfigAlreadyExists).
        pub fn build(self) -> crate::error::FieldLevelEncryptionConfigAlreadyExists {
            crate::error::FieldLevelEncryptionConfigAlreadyExists {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl FieldLevelEncryptionConfigAlreadyExists {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for FieldLevelEncryptionConfigAlreadyExists {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "FieldLevelEncryptionConfigAlreadyExists")?;
        if let Some(inner_135) = &self.message {
            {
                write!(f, ": {}", inner_135)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for FieldLevelEncryptionConfigAlreadyExists {}
impl aws_http::request_id::RequestId for crate::error::FieldLevelEncryptionConfigAlreadyExists {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for FieldLevelEncryptionConfigAlreadyExists
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type CreateDistributionWithTagsErrorKind = CreateDistributionWithTagsError;
/// Error type for the `CreateDistributionWithTagsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateDistributionWithTagsError {
    /// <p>Access denied.</p>
    AccessDenied(crate::error::AccessDenied),
    /// <p>The CNAME specified is already defined for CloudFront.</p>
    CnameAlreadyExists(crate::error::CnameAlreadyExists),
    /// <p>You cannot delete a continuous deployment policy that is associated with a primary distribution.</p>
    ContinuousDeploymentPolicyInUse(crate::error::ContinuousDeploymentPolicyInUse),
    /// <p>The caller reference you attempted to create the distribution with is associated with another distribution.</p>
    DistributionAlreadyExists(crate::error::DistributionAlreadyExists),
    /// <p>The specified configuration for field-level encryption can't be associated with the specified cache behavior.</p>
    IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior(
        crate::error::IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior,
    ),
    /// <p>The value of <code>Quantity</code> and the size of <code>Items</code> don't match.</p>
    InconsistentQuantities(crate::error::InconsistentQuantities),
    /// <p>An argument is invalid.</p>
    InvalidArgument(crate::error::InvalidArgument),
    /// <p>The default root object file name is too big or contains an invalid character.</p>
    InvalidDefaultRootObject(crate::error::InvalidDefaultRootObject),
    /// <p>An origin access control is associated with an origin whose domain name is not supported.</p>
    InvalidDomainNameForOriginAccessControl(crate::error::InvalidDomainNameForOriginAccessControl),
    /// <p>An invalid error code was specified.</p>
    InvalidErrorCode(crate::error::InvalidErrorCode),
    /// <p>Your request contains forward cookies option which doesn't match with the expectation for the <code>whitelisted</code> list of cookie names. Either list of cookie names has been specified when not allowed or list of cookie names is missing when expected.</p>
    InvalidForwardCookies(crate::error::InvalidForwardCookies),
    /// <p>A CloudFront function association is invalid.</p>
    InvalidFunctionAssociation(crate::error::InvalidFunctionAssociation),
    /// <p>The specified geo restriction parameter is not valid.</p>
    InvalidGeoRestrictionParameter(crate::error::InvalidGeoRestrictionParameter),
    /// <p>The headers specified are not valid for an Amazon S3 origin.</p>
    InvalidHeadersForS3Origin(crate::error::InvalidHeadersForS3Origin),
    /// <p>The specified Lambda@Edge function association is invalid.</p>
    InvalidLambdaFunctionAssociation(crate::error::InvalidLambdaFunctionAssociation),
    /// <p>The location code specified is not valid.</p>
    InvalidLocationCode(crate::error::InvalidLocationCode),
    /// <p>The minimum protocol version specified is not valid.</p>
    InvalidMinimumProtocolVersion(crate::error::InvalidMinimumProtocolVersion),
    /// <p>The Amazon S3 origin server specified does not refer to a valid Amazon S3 bucket.</p>
    InvalidOrigin(crate::error::InvalidOrigin),
    /// <p>The origin access control is not valid.</p>
    InvalidOriginAccessControl(crate::error::InvalidOriginAccessControl),
    /// <p>The origin access identity is not valid or doesn't exist.</p>
    InvalidOriginAccessIdentity(crate::error::InvalidOriginAccessIdentity),
    /// <p>The keep alive timeout specified for the origin is not valid.</p>
    InvalidOriginKeepaliveTimeout(crate::error::InvalidOriginKeepaliveTimeout),
    /// <p>The read timeout specified for the origin is not valid.</p>
    InvalidOriginReadTimeout(crate::error::InvalidOriginReadTimeout),
    /// <p>You cannot specify SSLv3 as the minimum protocol version if you only want to support only clients that support Server Name Indication (SNI).</p>
    InvalidProtocolSettings(crate::error::InvalidProtocolSettings),
    /// <p>The query string parameters specified are not valid.</p>
    InvalidQueryStringParameters(crate::error::InvalidQueryStringParameters),
    /// <p>The relative path is too big, is not URL-encoded, or does not begin with a slash (/).</p>
    InvalidRelativePath(crate::error::InvalidRelativePath),
    /// <p>This operation requires the HTTPS protocol. Ensure that you specify the HTTPS protocol in your request, or omit the <code>RequiredProtocols</code> element from your distribution configuration.</p>
    InvalidRequiredProtocol(crate::error::InvalidRequiredProtocol),
    /// <p>A response code is not valid.</p>
    InvalidResponseCode(crate::error::InvalidResponseCode),
    /// <p>The tagging specified is not valid.</p>
    InvalidTagging(crate::error::InvalidTagging),
    /// <p>The TTL order specified is not valid.</p>
    InvalidTtlOrder(crate::error::InvalidTtlOrder),
    /// <p>A viewer certificate specified is not valid.</p>
    InvalidViewerCertificate(crate::error::InvalidViewerCertificate),
    /// <p>A web ACL ID specified is not valid. To specify a web ACL created using the latest version of WAF, use the ACL ARN, for example <code>arn:aws:wafv2:us-east-1:123456789012:global/webacl/ExampleWebACL/473e64fd-f30b-4765-81a0-62ad96dd167a</code>. To specify a web ACL created using WAF Classic, use the ACL ID, for example <code>473e64fd-f30b-4765-81a0-62ad96dd167a</code>.</p>
    InvalidWebAclId(crate::error::InvalidWebAclId),
    /// <p>This operation requires a body. Ensure that the body is present and the <code>Content-Type</code> header is set.</p>
    MissingBody(crate::error::MissingBody),
    /// <p>The cache policy does not exist.</p>
    NoSuchCachePolicy(crate::error::NoSuchCachePolicy),
    /// <p>The continuous deployment policy doesn't exist.</p>
    NoSuchContinuousDeploymentPolicy(crate::error::NoSuchContinuousDeploymentPolicy),
    /// <p>The specified configuration for field-level encryption doesn't exist.</p>
    NoSuchFieldLevelEncryptionConfig(crate::error::NoSuchFieldLevelEncryptionConfig),
    /// <p>No origin exists with the specified <code>Origin Id</code>.</p>
    NoSuchOrigin(crate::error::NoSuchOrigin),
    /// <p>The origin request policy does not exist.</p>
    NoSuchOriginRequestPolicy(crate::error::NoSuchOriginRequestPolicy),
    /// <p>The real-time log configuration does not exist.</p>
    NoSuchRealtimeLogConfig(crate::error::NoSuchRealtimeLogConfig),
    /// <p>The response headers policy does not exist.</p>
    NoSuchResponseHeadersPolicy(crate::error::NoSuchResponseHeadersPolicy),
    /// <p>The specified real-time log configuration belongs to a different Amazon Web Services account.</p>
    RealtimeLogConfigOwnerMismatch(crate::error::RealtimeLogConfigOwnerMismatch),
    /// <p>You cannot create more cache behaviors for the distribution.</p>
    TooManyCacheBehaviors(crate::error::TooManyCacheBehaviors),
    /// <p>You cannot create anymore custom SSL/TLS certificates.</p>
    TooManyCertificates(crate::error::TooManyCertificates),
    /// <p>Your request contains more cookie names in the whitelist than are allowed per cache behavior.</p>
    TooManyCookieNamesInWhiteList(crate::error::TooManyCookieNamesInWhiteList),
    /// <p>Your request contains more CNAMEs than are allowed per distribution.</p>
    TooManyDistributionCnamEs(crate::error::TooManyDistributionCnamEs),
    /// <p>Processing your request would cause you to exceed the maximum number of distributions allowed.</p>
    TooManyDistributions(crate::error::TooManyDistributions),
    /// <p>The maximum number of distributions have been associated with the specified cache policy. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
    TooManyDistributionsAssociatedToCachePolicy(
        crate::error::TooManyDistributionsAssociatedToCachePolicy,
    ),
    /// <p>The maximum number of distributions have been associated with the specified configuration for field-level encryption.</p>
    TooManyDistributionsAssociatedToFieldLevelEncryptionConfig(
        crate::error::TooManyDistributionsAssociatedToFieldLevelEncryptionConfig,
    ),
    /// <p>The number of distributions that reference this key group is more than the maximum allowed. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
    TooManyDistributionsAssociatedToKeyGroup(
        crate::error::TooManyDistributionsAssociatedToKeyGroup,
    ),
    /// <p>The maximum number of distributions have been associated with the specified origin request policy. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
    TooManyDistributionsAssociatedToOriginRequestPolicy(
        crate::error::TooManyDistributionsAssociatedToOriginRequestPolicy,
    ),
    /// <p>The maximum number of distributions have been associated with the specified response headers policy.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
    TooManyDistributionsAssociatedToResponseHeadersPolicy(
        crate::error::TooManyDistributionsAssociatedToResponseHeadersPolicy,
    ),
    /// <p>You have reached the maximum number of distributions that are associated with a CloudFront function. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
    TooManyDistributionsWithFunctionAssociations(
        crate::error::TooManyDistributionsWithFunctionAssociations,
    ),
    /// <p>Processing your request would cause the maximum number of distributions with Lambda@Edge function associations per owner to be exceeded.</p>
    TooManyDistributionsWithLambdaAssociations(
        crate::error::TooManyDistributionsWithLambdaAssociations,
    ),
    /// <p>The maximum number of distributions have been associated with the specified Lambda@Edge function.</p>
    TooManyDistributionsWithSingleFunctionArn(
        crate::error::TooManyDistributionsWithSingleFunctionArn,
    ),
    /// <p>You have reached the maximum number of CloudFront function associations for this distribution. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
    TooManyFunctionAssociations(crate::error::TooManyFunctionAssociations),
    /// <p>Your request contains too many headers in forwarded values.</p>
    TooManyHeadersInForwardedValues(crate::error::TooManyHeadersInForwardedValues),
    /// <p>The number of key groups referenced by this distribution is more than the maximum allowed. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
    TooManyKeyGroupsAssociatedToDistribution(
        crate::error::TooManyKeyGroupsAssociatedToDistribution,
    ),
    /// <p>Your request contains more Lambda@Edge function associations than are allowed per distribution.</p>
    TooManyLambdaFunctionAssociations(crate::error::TooManyLambdaFunctionAssociations),
    /// <p>Your request contains too many origin custom headers.</p>
    TooManyOriginCustomHeaders(crate::error::TooManyOriginCustomHeaders),
    /// <p>Processing your request would cause you to exceed the maximum number of origin groups allowed.</p>
    TooManyOriginGroupsPerDistribution(crate::error::TooManyOriginGroupsPerDistribution),
    /// <p>You cannot create more origins for the distribution.</p>
    TooManyOrigins(crate::error::TooManyOrigins),
    /// <p>Your request contains too many query string parameters.</p>
    TooManyQueryStringParameters(crate::error::TooManyQueryStringParameters),
    /// <p>Your request contains more trusted signers than are allowed per distribution.</p>
    TooManyTrustedSigners(crate::error::TooManyTrustedSigners),
    /// <p>The specified key group does not exist.</p>
    TrustedKeyGroupDoesNotExist(crate::error::TrustedKeyGroupDoesNotExist),
    /// <p>One or more of your trusted signers don't exist.</p>
    TrustedSignerDoesNotExist(crate::error::TrustedSignerDoesNotExist),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for CreateDistributionWithTagsError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for CreateDistributionWithTagsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AccessDenied(_inner) => _inner.fmt(f),
            Self::CnameAlreadyExists(_inner) => _inner.fmt(f),
            Self::ContinuousDeploymentPolicyInUse(_inner) => _inner.fmt(f),
            Self::DistributionAlreadyExists(_inner) => _inner.fmt(f),
            Self::IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior(_inner) => {
                _inner.fmt(f)
            }
            Self::InconsistentQuantities(_inner) => _inner.fmt(f),
            Self::InvalidArgument(_inner) => _inner.fmt(f),
            Self::InvalidDefaultRootObject(_inner) => _inner.fmt(f),
            Self::InvalidDomainNameForOriginAccessControl(_inner) => _inner.fmt(f),
            Self::InvalidErrorCode(_inner) => _inner.fmt(f),
            Self::InvalidForwardCookies(_inner) => _inner.fmt(f),
            Self::InvalidFunctionAssociation(_inner) => _inner.fmt(f),
            Self::InvalidGeoRestrictionParameter(_inner) => _inner.fmt(f),
            Self::InvalidHeadersForS3Origin(_inner) => _inner.fmt(f),
            Self::InvalidLambdaFunctionAssociation(_inner) => _inner.fmt(f),
            Self::InvalidLocationCode(_inner) => _inner.fmt(f),
            Self::InvalidMinimumProtocolVersion(_inner) => _inner.fmt(f),
            Self::InvalidOrigin(_inner) => _inner.fmt(f),
            Self::InvalidOriginAccessControl(_inner) => _inner.fmt(f),
            Self::InvalidOriginAccessIdentity(_inner) => _inner.fmt(f),
            Self::InvalidOriginKeepaliveTimeout(_inner) => _inner.fmt(f),
            Self::InvalidOriginReadTimeout(_inner) => _inner.fmt(f),
            Self::InvalidProtocolSettings(_inner) => _inner.fmt(f),
            Self::InvalidQueryStringParameters(_inner) => _inner.fmt(f),
            Self::InvalidRelativePath(_inner) => _inner.fmt(f),
            Self::InvalidRequiredProtocol(_inner) => _inner.fmt(f),
            Self::InvalidResponseCode(_inner) => _inner.fmt(f),
            Self::InvalidTagging(_inner) => _inner.fmt(f),
            Self::InvalidTtlOrder(_inner) => _inner.fmt(f),
            Self::InvalidViewerCertificate(_inner) => _inner.fmt(f),
            Self::InvalidWebAclId(_inner) => _inner.fmt(f),
            Self::MissingBody(_inner) => _inner.fmt(f),
            Self::NoSuchCachePolicy(_inner) => _inner.fmt(f),
            Self::NoSuchContinuousDeploymentPolicy(_inner) => _inner.fmt(f),
            Self::NoSuchFieldLevelEncryptionConfig(_inner) => _inner.fmt(f),
            Self::NoSuchOrigin(_inner) => _inner.fmt(f),
            Self::NoSuchOriginRequestPolicy(_inner) => _inner.fmt(f),
            Self::NoSuchRealtimeLogConfig(_inner) => _inner.fmt(f),
            Self::NoSuchResponseHeadersPolicy(_inner) => _inner.fmt(f),
            Self::RealtimeLogConfigOwnerMismatch(_inner) => _inner.fmt(f),
            Self::TooManyCacheBehaviors(_inner) => _inner.fmt(f),
            Self::TooManyCertificates(_inner) => _inner.fmt(f),
            Self::TooManyCookieNamesInWhiteList(_inner) => _inner.fmt(f),
            Self::TooManyDistributionCnamEs(_inner) => _inner.fmt(f),
            Self::TooManyDistributions(_inner) => _inner.fmt(f),
            Self::TooManyDistributionsAssociatedToCachePolicy(_inner) => _inner.fmt(f),
            Self::TooManyDistributionsAssociatedToFieldLevelEncryptionConfig(_inner) => {
                _inner.fmt(f)
            }
            Self::TooManyDistributionsAssociatedToKeyGroup(_inner) => _inner.fmt(f),
            Self::TooManyDistributionsAssociatedToOriginRequestPolicy(_inner) => _inner.fmt(f),
            Self::TooManyDistributionsAssociatedToResponseHeadersPolicy(_inner) => _inner.fmt(f),
            Self::TooManyDistributionsWithFunctionAssociations(_inner) => _inner.fmt(f),
            Self::TooManyDistributionsWithLambdaAssociations(_inner) => _inner.fmt(f),
            Self::TooManyDistributionsWithSingleFunctionArn(_inner) => _inner.fmt(f),
            Self::TooManyFunctionAssociations(_inner) => _inner.fmt(f),
            Self::TooManyHeadersInForwardedValues(_inner) => _inner.fmt(f),
            Self::TooManyKeyGroupsAssociatedToDistribution(_inner) => _inner.fmt(f),
            Self::TooManyLambdaFunctionAssociations(_inner) => _inner.fmt(f),
            Self::TooManyOriginCustomHeaders(_inner) => _inner.fmt(f),
            Self::TooManyOriginGroupsPerDistribution(_inner) => _inner.fmt(f),
            Self::TooManyOrigins(_inner) => _inner.fmt(f),
            Self::TooManyQueryStringParameters(_inner) => _inner.fmt(f),
            Self::TooManyTrustedSigners(_inner) => _inner.fmt(f),
            Self::TrustedKeyGroupDoesNotExist(_inner) => _inner.fmt(f),
            Self::TrustedSignerDoesNotExist(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CreateDistributionWithTagsError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AccessDenied(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::CnameAlreadyExists(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ContinuousDeploymentPolicyInUse(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DistributionAlreadyExists(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InconsistentQuantities(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidArgument(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidDefaultRootObject(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidDomainNameForOriginAccessControl(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidErrorCode(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidForwardCookies(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidFunctionAssociation(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidGeoRestrictionParameter(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidHeadersForS3Origin(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidLambdaFunctionAssociation(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidLocationCode(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidMinimumProtocolVersion(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidOrigin(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidOriginAccessControl(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidOriginAccessIdentity(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidOriginKeepaliveTimeout(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidOriginReadTimeout(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidProtocolSettings(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidQueryStringParameters(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidRelativePath(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidRequiredProtocol(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidResponseCode(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidTagging(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidTtlOrder(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidViewerCertificate(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidWebAclId(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::MissingBody(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NoSuchCachePolicy(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NoSuchContinuousDeploymentPolicy(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NoSuchFieldLevelEncryptionConfig(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NoSuchOrigin(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NoSuchOriginRequestPolicy(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NoSuchRealtimeLogConfig(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NoSuchResponseHeadersPolicy(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RealtimeLogConfigOwnerMismatch(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyCacheBehaviors(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyCertificates(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyCookieNamesInWhiteList(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyDistributionCnamEs(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyDistributions(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyDistributionsAssociatedToCachePolicy(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyDistributionsAssociatedToFieldLevelEncryptionConfig(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyDistributionsAssociatedToKeyGroup(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyDistributionsAssociatedToOriginRequestPolicy(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyDistributionsAssociatedToResponseHeadersPolicy(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyDistributionsWithFunctionAssociations(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyDistributionsWithLambdaAssociations(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyDistributionsWithSingleFunctionArn(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyFunctionAssociations(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyHeadersInForwardedValues(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyKeyGroupsAssociatedToDistribution(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyLambdaFunctionAssociations(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyOriginCustomHeaders(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyOriginGroupsPerDistribution(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyOrigins(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyQueryStringParameters(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyTrustedSigners(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TrustedKeyGroupDoesNotExist(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TrustedSignerDoesNotExist(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::CreateDistributionWithTagsError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateDistributionWithTagsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateDistributionWithTagsError {
    /// Creates the `CreateDistributionWithTagsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `CreateDistributionWithTagsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AccessDenied(e) => e.meta(),
            Self::CnameAlreadyExists(e) => e.meta(),
            Self::ContinuousDeploymentPolicyInUse(e) => e.meta(),
            Self::DistributionAlreadyExists(e) => e.meta(),
            Self::IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior(e) => e.meta(),
            Self::InconsistentQuantities(e) => e.meta(),
            Self::InvalidArgument(e) => e.meta(),
            Self::InvalidDefaultRootObject(e) => e.meta(),
            Self::InvalidDomainNameForOriginAccessControl(e) => e.meta(),
            Self::InvalidErrorCode(e) => e.meta(),
            Self::InvalidForwardCookies(e) => e.meta(),
            Self::InvalidFunctionAssociation(e) => e.meta(),
            Self::InvalidGeoRestrictionParameter(e) => e.meta(),
            Self::InvalidHeadersForS3Origin(e) => e.meta(),
            Self::InvalidLambdaFunctionAssociation(e) => e.meta(),
            Self::InvalidLocationCode(e) => e.meta(),
            Self::InvalidMinimumProtocolVersion(e) => e.meta(),
            Self::InvalidOrigin(e) => e.meta(),
            Self::InvalidOriginAccessControl(e) => e.meta(),
            Self::InvalidOriginAccessIdentity(e) => e.meta(),
            Self::InvalidOriginKeepaliveTimeout(e) => e.meta(),
            Self::InvalidOriginReadTimeout(e) => e.meta(),
            Self::InvalidProtocolSettings(e) => e.meta(),
            Self::InvalidQueryStringParameters(e) => e.meta(),
            Self::InvalidRelativePath(e) => e.meta(),
            Self::InvalidRequiredProtocol(e) => e.meta(),
            Self::InvalidResponseCode(e) => e.meta(),
            Self::InvalidTagging(e) => e.meta(),
            Self::InvalidTtlOrder(e) => e.meta(),
            Self::InvalidViewerCertificate(e) => e.meta(),
            Self::InvalidWebAclId(e) => e.meta(),
            Self::MissingBody(e) => e.meta(),
            Self::NoSuchCachePolicy(e) => e.meta(),
            Self::NoSuchContinuousDeploymentPolicy(e) => e.meta(),
            Self::NoSuchFieldLevelEncryptionConfig(e) => e.meta(),
            Self::NoSuchOrigin(e) => e.meta(),
            Self::NoSuchOriginRequestPolicy(e) => e.meta(),
            Self::NoSuchRealtimeLogConfig(e) => e.meta(),
            Self::NoSuchResponseHeadersPolicy(e) => e.meta(),
            Self::RealtimeLogConfigOwnerMismatch(e) => e.meta(),
            Self::TooManyCacheBehaviors(e) => e.meta(),
            Self::TooManyCertificates(e) => e.meta(),
            Self::TooManyCookieNamesInWhiteList(e) => e.meta(),
            Self::TooManyDistributionCnamEs(e) => e.meta(),
            Self::TooManyDistributions(e) => e.meta(),
            Self::TooManyDistributionsAssociatedToCachePolicy(e) => e.meta(),
            Self::TooManyDistributionsAssociatedToFieldLevelEncryptionConfig(e) => e.meta(),
            Self::TooManyDistributionsAssociatedToKeyGroup(e) => e.meta(),
            Self::TooManyDistributionsAssociatedToOriginRequestPolicy(e) => e.meta(),
            Self::TooManyDistributionsAssociatedToResponseHeadersPolicy(e) => e.meta(),
            Self::TooManyDistributionsWithFunctionAssociations(e) => e.meta(),
            Self::TooManyDistributionsWithLambdaAssociations(e) => e.meta(),
            Self::TooManyDistributionsWithSingleFunctionArn(e) => e.meta(),
            Self::TooManyFunctionAssociations(e) => e.meta(),
            Self::TooManyHeadersInForwardedValues(e) => e.meta(),
            Self::TooManyKeyGroupsAssociatedToDistribution(e) => e.meta(),
            Self::TooManyLambdaFunctionAssociations(e) => e.meta(),
            Self::TooManyOriginCustomHeaders(e) => e.meta(),
            Self::TooManyOriginGroupsPerDistribution(e) => e.meta(),
            Self::TooManyOrigins(e) => e.meta(),
            Self::TooManyQueryStringParameters(e) => e.meta(),
            Self::TooManyTrustedSigners(e) => e.meta(),
            Self::TrustedKeyGroupDoesNotExist(e) => e.meta(),
            Self::TrustedSignerDoesNotExist(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `CreateDistributionWithTagsError::AccessDenied`.
    pub fn is_access_denied(&self) -> bool {
        matches!(self, Self::AccessDenied(_))
    }
    /// Returns `true` if the error kind is `CreateDistributionWithTagsError::CnameAlreadyExists`.
    pub fn is_cname_already_exists(&self) -> bool {
        matches!(self, Self::CnameAlreadyExists(_))
    }
    /// Returns `true` if the error kind is `CreateDistributionWithTagsError::ContinuousDeploymentPolicyInUse`.
    pub fn is_continuous_deployment_policy_in_use(&self) -> bool {
        matches!(self, Self::ContinuousDeploymentPolicyInUse(_))
    }
    /// Returns `true` if the error kind is `CreateDistributionWithTagsError::DistributionAlreadyExists`.
    pub fn is_distribution_already_exists(&self) -> bool {
        matches!(self, Self::DistributionAlreadyExists(_))
    }
    /// Returns `true` if the error kind is `CreateDistributionWithTagsError::IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior`.
    pub fn is_illegal_field_level_encryption_config_association_with_cache_behavior(&self) -> bool {
        matches!(
            self,
            Self::IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior(_)
        )
    }
    /// Returns `true` if the error kind is `CreateDistributionWithTagsError::InconsistentQuantities`.
    pub fn is_inconsistent_quantities(&self) -> bool {
        matches!(self, Self::InconsistentQuantities(_))
    }
    /// Returns `true` if the error kind is `CreateDistributionWithTagsError::InvalidArgument`.
    pub fn is_invalid_argument(&self) -> bool {
        matches!(self, Self::InvalidArgument(_))
    }
    /// Returns `true` if the error kind is `CreateDistributionWithTagsError::InvalidDefaultRootObject`.
    pub fn is_invalid_default_root_object(&self) -> bool {
        matches!(self, Self::InvalidDefaultRootObject(_))
    }
    /// Returns `true` if the error kind is `CreateDistributionWithTagsError::InvalidDomainNameForOriginAccessControl`.
    pub fn is_invalid_domain_name_for_origin_access_control(&self) -> bool {
        matches!(self, Self::InvalidDomainNameForOriginAccessControl(_))
    }
    /// Returns `true` if the error kind is `CreateDistributionWithTagsError::InvalidErrorCode`.
    pub fn is_invalid_error_code(&self) -> bool {
        matches!(self, Self::InvalidErrorCode(_))
    }
    /// Returns `true` if the error kind is `CreateDistributionWithTagsError::InvalidForwardCookies`.
    pub fn is_invalid_forward_cookies(&self) -> bool {
        matches!(self, Self::InvalidForwardCookies(_))
    }
    /// Returns `true` if the error kind is `CreateDistributionWithTagsError::InvalidFunctionAssociation`.
    pub fn is_invalid_function_association(&self) -> bool {
        matches!(self, Self::InvalidFunctionAssociation(_))
    }
    /// Returns `true` if the error kind is `CreateDistributionWithTagsError::InvalidGeoRestrictionParameter`.
    pub fn is_invalid_geo_restriction_parameter(&self) -> bool {
        matches!(self, Self::InvalidGeoRestrictionParameter(_))
    }
    /// Returns `true` if the error kind is `CreateDistributionWithTagsError::InvalidHeadersForS3Origin`.
    pub fn is_invalid_headers_for_s3_origin(&self) -> bool {
        matches!(self, Self::InvalidHeadersForS3Origin(_))
    }
    /// Returns `true` if the error kind is `CreateDistributionWithTagsError::InvalidLambdaFunctionAssociation`.
    pub fn is_invalid_lambda_function_association(&self) -> bool {
        matches!(self, Self::InvalidLambdaFunctionAssociation(_))
    }
    /// Returns `true` if the error kind is `CreateDistributionWithTagsError::InvalidLocationCode`.
    pub fn is_invalid_location_code(&self) -> bool {
        matches!(self, Self::InvalidLocationCode(_))
    }
    /// Returns `true` if the error kind is `CreateDistributionWithTagsError::InvalidMinimumProtocolVersion`.
    pub fn is_invalid_minimum_protocol_version(&self) -> bool {
        matches!(self, Self::InvalidMinimumProtocolVersion(_))
    }
    /// Returns `true` if the error kind is `CreateDistributionWithTagsError::InvalidOrigin`.
    pub fn is_invalid_origin(&self) -> bool {
        matches!(self, Self::InvalidOrigin(_))
    }
    /// Returns `true` if the error kind is `CreateDistributionWithTagsError::InvalidOriginAccessControl`.
    pub fn is_invalid_origin_access_control(&self) -> bool {
        matches!(self, Self::InvalidOriginAccessControl(_))
    }
    /// Returns `true` if the error kind is `CreateDistributionWithTagsError::InvalidOriginAccessIdentity`.
    pub fn is_invalid_origin_access_identity(&self) -> bool {
        matches!(self, Self::InvalidOriginAccessIdentity(_))
    }
    /// Returns `true` if the error kind is `CreateDistributionWithTagsError::InvalidOriginKeepaliveTimeout`.
    pub fn is_invalid_origin_keepalive_timeout(&self) -> bool {
        matches!(self, Self::InvalidOriginKeepaliveTimeout(_))
    }
    /// Returns `true` if the error kind is `CreateDistributionWithTagsError::InvalidOriginReadTimeout`.
    pub fn is_invalid_origin_read_timeout(&self) -> bool {
        matches!(self, Self::InvalidOriginReadTimeout(_))
    }
    /// Returns `true` if the error kind is `CreateDistributionWithTagsError::InvalidProtocolSettings`.
    pub fn is_invalid_protocol_settings(&self) -> bool {
        matches!(self, Self::InvalidProtocolSettings(_))
    }
    /// Returns `true` if the error kind is `CreateDistributionWithTagsError::InvalidQueryStringParameters`.
    pub fn is_invalid_query_string_parameters(&self) -> bool {
        matches!(self, Self::InvalidQueryStringParameters(_))
    }
    /// Returns `true` if the error kind is `CreateDistributionWithTagsError::InvalidRelativePath`.
    pub fn is_invalid_relative_path(&self) -> bool {
        matches!(self, Self::InvalidRelativePath(_))
    }
    /// Returns `true` if the error kind is `CreateDistributionWithTagsError::InvalidRequiredProtocol`.
    pub fn is_invalid_required_protocol(&self) -> bool {
        matches!(self, Self::InvalidRequiredProtocol(_))
    }
    /// Returns `true` if the error kind is `CreateDistributionWithTagsError::InvalidResponseCode`.
    pub fn is_invalid_response_code(&self) -> bool {
        matches!(self, Self::InvalidResponseCode(_))
    }
    /// Returns `true` if the error kind is `CreateDistributionWithTagsError::InvalidTagging`.
    pub fn is_invalid_tagging(&self) -> bool {
        matches!(self, Self::InvalidTagging(_))
    }
    /// Returns `true` if the error kind is `CreateDistributionWithTagsError::InvalidTtlOrder`.
    pub fn is_invalid_ttl_order(&self) -> bool {
        matches!(self, Self::InvalidTtlOrder(_))
    }
    /// Returns `true` if the error kind is `CreateDistributionWithTagsError::InvalidViewerCertificate`.
    pub fn is_invalid_viewer_certificate(&self) -> bool {
        matches!(self, Self::InvalidViewerCertificate(_))
    }
    /// Returns `true` if the error kind is `CreateDistributionWithTagsError::InvalidWebAclId`.
    pub fn is_invalid_web_acl_id(&self) -> bool {
        matches!(self, Self::InvalidWebAclId(_))
    }
    /// Returns `true` if the error kind is `CreateDistributionWithTagsError::MissingBody`.
    pub fn is_missing_body(&self) -> bool {
        matches!(self, Self::MissingBody(_))
    }
    /// Returns `true` if the error kind is `CreateDistributionWithTagsError::NoSuchCachePolicy`.
    pub fn is_no_such_cache_policy(&self) -> bool {
        matches!(self, Self::NoSuchCachePolicy(_))
    }
    /// Returns `true` if the error kind is `CreateDistributionWithTagsError::NoSuchContinuousDeploymentPolicy`.
    pub fn is_no_such_continuous_deployment_policy(&self) -> bool {
        matches!(self, Self::NoSuchContinuousDeploymentPolicy(_))
    }
    /// Returns `true` if the error kind is `CreateDistributionWithTagsError::NoSuchFieldLevelEncryptionConfig`.
    pub fn is_no_such_field_level_encryption_config(&self) -> bool {
        matches!(self, Self::NoSuchFieldLevelEncryptionConfig(_))
    }
    /// Returns `true` if the error kind is `CreateDistributionWithTagsError::NoSuchOrigin`.
    pub fn is_no_such_origin(&self) -> bool {
        matches!(self, Self::NoSuchOrigin(_))
    }
    /// Returns `true` if the error kind is `CreateDistributionWithTagsError::NoSuchOriginRequestPolicy`.
    pub fn is_no_such_origin_request_policy(&self) -> bool {
        matches!(self, Self::NoSuchOriginRequestPolicy(_))
    }
    /// Returns `true` if the error kind is `CreateDistributionWithTagsError::NoSuchRealtimeLogConfig`.
    pub fn is_no_such_realtime_log_config(&self) -> bool {
        matches!(self, Self::NoSuchRealtimeLogConfig(_))
    }
    /// Returns `true` if the error kind is `CreateDistributionWithTagsError::NoSuchResponseHeadersPolicy`.
    pub fn is_no_such_response_headers_policy(&self) -> bool {
        matches!(self, Self::NoSuchResponseHeadersPolicy(_))
    }
    /// Returns `true` if the error kind is `CreateDistributionWithTagsError::RealtimeLogConfigOwnerMismatch`.
    pub fn is_realtime_log_config_owner_mismatch(&self) -> bool {
        matches!(self, Self::RealtimeLogConfigOwnerMismatch(_))
    }
    /// Returns `true` if the error kind is `CreateDistributionWithTagsError::TooManyCacheBehaviors`.
    pub fn is_too_many_cache_behaviors(&self) -> bool {
        matches!(self, Self::TooManyCacheBehaviors(_))
    }
    /// Returns `true` if the error kind is `CreateDistributionWithTagsError::TooManyCertificates`.
    pub fn is_too_many_certificates(&self) -> bool {
        matches!(self, Self::TooManyCertificates(_))
    }
    /// Returns `true` if the error kind is `CreateDistributionWithTagsError::TooManyCookieNamesInWhiteList`.
    pub fn is_too_many_cookie_names_in_white_list(&self) -> bool {
        matches!(self, Self::TooManyCookieNamesInWhiteList(_))
    }
    /// Returns `true` if the error kind is `CreateDistributionWithTagsError::TooManyDistributionCnamEs`.
    pub fn is_too_many_distribution_cnam_es(&self) -> bool {
        matches!(self, Self::TooManyDistributionCnamEs(_))
    }
    /// Returns `true` if the error kind is `CreateDistributionWithTagsError::TooManyDistributions`.
    pub fn is_too_many_distributions(&self) -> bool {
        matches!(self, Self::TooManyDistributions(_))
    }
    /// Returns `true` if the error kind is `CreateDistributionWithTagsError::TooManyDistributionsAssociatedToCachePolicy`.
    pub fn is_too_many_distributions_associated_to_cache_policy(&self) -> bool {
        matches!(self, Self::TooManyDistributionsAssociatedToCachePolicy(_))
    }
    /// Returns `true` if the error kind is `CreateDistributionWithTagsError::TooManyDistributionsAssociatedToFieldLevelEncryptionConfig`.
    pub fn is_too_many_distributions_associated_to_field_level_encryption_config(&self) -> bool {
        matches!(
            self,
            Self::TooManyDistributionsAssociatedToFieldLevelEncryptionConfig(_)
        )
    }
    /// Returns `true` if the error kind is `CreateDistributionWithTagsError::TooManyDistributionsAssociatedToKeyGroup`.
    pub fn is_too_many_distributions_associated_to_key_group(&self) -> bool {
        matches!(self, Self::TooManyDistributionsAssociatedToKeyGroup(_))
    }
    /// Returns `true` if the error kind is `CreateDistributionWithTagsError::TooManyDistributionsAssociatedToOriginRequestPolicy`.
    pub fn is_too_many_distributions_associated_to_origin_request_policy(&self) -> bool {
        matches!(
            self,
            Self::TooManyDistributionsAssociatedToOriginRequestPolicy(_)
        )
    }
    /// Returns `true` if the error kind is `CreateDistributionWithTagsError::TooManyDistributionsAssociatedToResponseHeadersPolicy`.
    pub fn is_too_many_distributions_associated_to_response_headers_policy(&self) -> bool {
        matches!(
            self,
            Self::TooManyDistributionsAssociatedToResponseHeadersPolicy(_)
        )
    }
    /// Returns `true` if the error kind is `CreateDistributionWithTagsError::TooManyDistributionsWithFunctionAssociations`.
    pub fn is_too_many_distributions_with_function_associations(&self) -> bool {
        matches!(self, Self::TooManyDistributionsWithFunctionAssociations(_))
    }
    /// Returns `true` if the error kind is `CreateDistributionWithTagsError::TooManyDistributionsWithLambdaAssociations`.
    pub fn is_too_many_distributions_with_lambda_associations(&self) -> bool {
        matches!(self, Self::TooManyDistributionsWithLambdaAssociations(_))
    }
    /// Returns `true` if the error kind is `CreateDistributionWithTagsError::TooManyDistributionsWithSingleFunctionArn`.
    pub fn is_too_many_distributions_with_single_function_arn(&self) -> bool {
        matches!(self, Self::TooManyDistributionsWithSingleFunctionArn(_))
    }
    /// Returns `true` if the error kind is `CreateDistributionWithTagsError::TooManyFunctionAssociations`.
    pub fn is_too_many_function_associations(&self) -> bool {
        matches!(self, Self::TooManyFunctionAssociations(_))
    }
    /// Returns `true` if the error kind is `CreateDistributionWithTagsError::TooManyHeadersInForwardedValues`.
    pub fn is_too_many_headers_in_forwarded_values(&self) -> bool {
        matches!(self, Self::TooManyHeadersInForwardedValues(_))
    }
    /// Returns `true` if the error kind is `CreateDistributionWithTagsError::TooManyKeyGroupsAssociatedToDistribution`.
    pub fn is_too_many_key_groups_associated_to_distribution(&self) -> bool {
        matches!(self, Self::TooManyKeyGroupsAssociatedToDistribution(_))
    }
    /// Returns `true` if the error kind is `CreateDistributionWithTagsError::TooManyLambdaFunctionAssociations`.
    pub fn is_too_many_lambda_function_associations(&self) -> bool {
        matches!(self, Self::TooManyLambdaFunctionAssociations(_))
    }
    /// Returns `true` if the error kind is `CreateDistributionWithTagsError::TooManyOriginCustomHeaders`.
    pub fn is_too_many_origin_custom_headers(&self) -> bool {
        matches!(self, Self::TooManyOriginCustomHeaders(_))
    }
    /// Returns `true` if the error kind is `CreateDistributionWithTagsError::TooManyOriginGroupsPerDistribution`.
    pub fn is_too_many_origin_groups_per_distribution(&self) -> bool {
        matches!(self, Self::TooManyOriginGroupsPerDistribution(_))
    }
    /// Returns `true` if the error kind is `CreateDistributionWithTagsError::TooManyOrigins`.
    pub fn is_too_many_origins(&self) -> bool {
        matches!(self, Self::TooManyOrigins(_))
    }
    /// Returns `true` if the error kind is `CreateDistributionWithTagsError::TooManyQueryStringParameters`.
    pub fn is_too_many_query_string_parameters(&self) -> bool {
        matches!(self, Self::TooManyQueryStringParameters(_))
    }
    /// Returns `true` if the error kind is `CreateDistributionWithTagsError::TooManyTrustedSigners`.
    pub fn is_too_many_trusted_signers(&self) -> bool {
        matches!(self, Self::TooManyTrustedSigners(_))
    }
    /// Returns `true` if the error kind is `CreateDistributionWithTagsError::TrustedKeyGroupDoesNotExist`.
    pub fn is_trusted_key_group_does_not_exist(&self) -> bool {
        matches!(self, Self::TrustedKeyGroupDoesNotExist(_))
    }
    /// Returns `true` if the error kind is `CreateDistributionWithTagsError::TrustedSignerDoesNotExist`.
    pub fn is_trusted_signer_does_not_exist(&self) -> bool {
        matches!(self, Self::TrustedSignerDoesNotExist(_))
    }
}
impl std::error::Error for CreateDistributionWithTagsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AccessDenied(_inner) => Some(_inner),
            Self::CnameAlreadyExists(_inner) => Some(_inner),
            Self::ContinuousDeploymentPolicyInUse(_inner) => Some(_inner),
            Self::DistributionAlreadyExists(_inner) => Some(_inner),
            Self::IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior(_inner) => {
                Some(_inner)
            }
            Self::InconsistentQuantities(_inner) => Some(_inner),
            Self::InvalidArgument(_inner) => Some(_inner),
            Self::InvalidDefaultRootObject(_inner) => Some(_inner),
            Self::InvalidDomainNameForOriginAccessControl(_inner) => Some(_inner),
            Self::InvalidErrorCode(_inner) => Some(_inner),
            Self::InvalidForwardCookies(_inner) => Some(_inner),
            Self::InvalidFunctionAssociation(_inner) => Some(_inner),
            Self::InvalidGeoRestrictionParameter(_inner) => Some(_inner),
            Self::InvalidHeadersForS3Origin(_inner) => Some(_inner),
            Self::InvalidLambdaFunctionAssociation(_inner) => Some(_inner),
            Self::InvalidLocationCode(_inner) => Some(_inner),
            Self::InvalidMinimumProtocolVersion(_inner) => Some(_inner),
            Self::InvalidOrigin(_inner) => Some(_inner),
            Self::InvalidOriginAccessControl(_inner) => Some(_inner),
            Self::InvalidOriginAccessIdentity(_inner) => Some(_inner),
            Self::InvalidOriginKeepaliveTimeout(_inner) => Some(_inner),
            Self::InvalidOriginReadTimeout(_inner) => Some(_inner),
            Self::InvalidProtocolSettings(_inner) => Some(_inner),
            Self::InvalidQueryStringParameters(_inner) => Some(_inner),
            Self::InvalidRelativePath(_inner) => Some(_inner),
            Self::InvalidRequiredProtocol(_inner) => Some(_inner),
            Self::InvalidResponseCode(_inner) => Some(_inner),
            Self::InvalidTagging(_inner) => Some(_inner),
            Self::InvalidTtlOrder(_inner) => Some(_inner),
            Self::InvalidViewerCertificate(_inner) => Some(_inner),
            Self::InvalidWebAclId(_inner) => Some(_inner),
            Self::MissingBody(_inner) => Some(_inner),
            Self::NoSuchCachePolicy(_inner) => Some(_inner),
            Self::NoSuchContinuousDeploymentPolicy(_inner) => Some(_inner),
            Self::NoSuchFieldLevelEncryptionConfig(_inner) => Some(_inner),
            Self::NoSuchOrigin(_inner) => Some(_inner),
            Self::NoSuchOriginRequestPolicy(_inner) => Some(_inner),
            Self::NoSuchRealtimeLogConfig(_inner) => Some(_inner),
            Self::NoSuchResponseHeadersPolicy(_inner) => Some(_inner),
            Self::RealtimeLogConfigOwnerMismatch(_inner) => Some(_inner),
            Self::TooManyCacheBehaviors(_inner) => Some(_inner),
            Self::TooManyCertificates(_inner) => Some(_inner),
            Self::TooManyCookieNamesInWhiteList(_inner) => Some(_inner),
            Self::TooManyDistributionCnamEs(_inner) => Some(_inner),
            Self::TooManyDistributions(_inner) => Some(_inner),
            Self::TooManyDistributionsAssociatedToCachePolicy(_inner) => Some(_inner),
            Self::TooManyDistributionsAssociatedToFieldLevelEncryptionConfig(_inner) => {
                Some(_inner)
            }
            Self::TooManyDistributionsAssociatedToKeyGroup(_inner) => Some(_inner),
            Self::TooManyDistributionsAssociatedToOriginRequestPolicy(_inner) => Some(_inner),
            Self::TooManyDistributionsAssociatedToResponseHeadersPolicy(_inner) => Some(_inner),
            Self::TooManyDistributionsWithFunctionAssociations(_inner) => Some(_inner),
            Self::TooManyDistributionsWithLambdaAssociations(_inner) => Some(_inner),
            Self::TooManyDistributionsWithSingleFunctionArn(_inner) => Some(_inner),
            Self::TooManyFunctionAssociations(_inner) => Some(_inner),
            Self::TooManyHeadersInForwardedValues(_inner) => Some(_inner),
            Self::TooManyKeyGroupsAssociatedToDistribution(_inner) => Some(_inner),
            Self::TooManyLambdaFunctionAssociations(_inner) => Some(_inner),
            Self::TooManyOriginCustomHeaders(_inner) => Some(_inner),
            Self::TooManyOriginGroupsPerDistribution(_inner) => Some(_inner),
            Self::TooManyOrigins(_inner) => Some(_inner),
            Self::TooManyQueryStringParameters(_inner) => Some(_inner),
            Self::TooManyTrustedSigners(_inner) => Some(_inner),
            Self::TrustedKeyGroupDoesNotExist(_inner) => Some(_inner),
            Self::TrustedSignerDoesNotExist(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>Processing your request would cause you to exceed the maximum number of distributions allowed.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TooManyDistributions {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl TooManyDistributions {
    /// Creates a new builder-style object to manufacture [`TooManyDistributions`](crate::error::TooManyDistributions).
    pub fn builder() -> crate::error::too_many_distributions::Builder {
        crate::error::too_many_distributions::Builder::default()
    }
}
/// See [`TooManyDistributions`](crate::error::TooManyDistributions).
pub mod too_many_distributions {

    /// A builder for [`TooManyDistributions`](crate::error::TooManyDistributions).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`TooManyDistributions`](crate::error::TooManyDistributions).
        pub fn build(self) -> crate::error::TooManyDistributions {
            crate::error::TooManyDistributions {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl TooManyDistributions {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TooManyDistributions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TooManyDistributions")?;
        if let Some(inner_136) = &self.message {
            {
                write!(f, ": {}", inner_136)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for TooManyDistributions {}
impl aws_http::request_id::RequestId for crate::error::TooManyDistributions {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for TooManyDistributions {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>You cannot specify SSLv3 as the minimum protocol version if you only want to support only clients that support Server Name Indication (SNI).</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidProtocolSettings {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidProtocolSettings {
    /// Creates a new builder-style object to manufacture [`InvalidProtocolSettings`](crate::error::InvalidProtocolSettings).
    pub fn builder() -> crate::error::invalid_protocol_settings::Builder {
        crate::error::invalid_protocol_settings::Builder::default()
    }
}
/// See [`InvalidProtocolSettings`](crate::error::InvalidProtocolSettings).
pub mod invalid_protocol_settings {

    /// A builder for [`InvalidProtocolSettings`](crate::error::InvalidProtocolSettings).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidProtocolSettings`](crate::error::InvalidProtocolSettings).
        pub fn build(self) -> crate::error::InvalidProtocolSettings {
            crate::error::InvalidProtocolSettings {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl InvalidProtocolSettings {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidProtocolSettings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidProtocolSettings")?;
        if let Some(inner_137) = &self.message {
            {
                write!(f, ": {}", inner_137)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidProtocolSettings {}
impl aws_http::request_id::RequestId for crate::error::InvalidProtocolSettings {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidProtocolSettings {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The caller reference you attempted to create the distribution with is associated with another distribution.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DistributionAlreadyExists {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl DistributionAlreadyExists {
    /// Creates a new builder-style object to manufacture [`DistributionAlreadyExists`](crate::error::DistributionAlreadyExists).
    pub fn builder() -> crate::error::distribution_already_exists::Builder {
        crate::error::distribution_already_exists::Builder::default()
    }
}
/// See [`DistributionAlreadyExists`](crate::error::DistributionAlreadyExists).
pub mod distribution_already_exists {

    /// A builder for [`DistributionAlreadyExists`](crate::error::DistributionAlreadyExists).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`DistributionAlreadyExists`](crate::error::DistributionAlreadyExists).
        pub fn build(self) -> crate::error::DistributionAlreadyExists {
            crate::error::DistributionAlreadyExists {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl DistributionAlreadyExists {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DistributionAlreadyExists {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DistributionAlreadyExists")?;
        if let Some(inner_138) = &self.message {
            {
                write!(f, ": {}", inner_138)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for DistributionAlreadyExists {}
impl aws_http::request_id::RequestId for crate::error::DistributionAlreadyExists {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DistributionAlreadyExists {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type CreateDistributionErrorKind = CreateDistributionError;
/// Error type for the `CreateDistributionError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateDistributionError {
    /// <p>Access denied.</p>
    AccessDenied(crate::error::AccessDenied),
    /// <p>The CNAME specified is already defined for CloudFront.</p>
    CnameAlreadyExists(crate::error::CnameAlreadyExists),
    /// <p>You cannot delete a continuous deployment policy that is associated with a primary distribution.</p>
    ContinuousDeploymentPolicyInUse(crate::error::ContinuousDeploymentPolicyInUse),
    /// <p>The caller reference you attempted to create the distribution with is associated with another distribution.</p>
    DistributionAlreadyExists(crate::error::DistributionAlreadyExists),
    /// <p>The specified configuration for field-level encryption can't be associated with the specified cache behavior.</p>
    IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior(
        crate::error::IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior,
    ),
    /// <p>An origin cannot contain both an origin access control (OAC) and an origin access identity (OAI).</p>
    IllegalOriginAccessConfiguration(crate::error::IllegalOriginAccessConfiguration),
    /// <p>The value of <code>Quantity</code> and the size of <code>Items</code> don't match.</p>
    InconsistentQuantities(crate::error::InconsistentQuantities),
    /// <p>An argument is invalid.</p>
    InvalidArgument(crate::error::InvalidArgument),
    /// <p>The default root object file name is too big or contains an invalid character.</p>
    InvalidDefaultRootObject(crate::error::InvalidDefaultRootObject),
    /// <p>An origin access control is associated with an origin whose domain name is not supported.</p>
    InvalidDomainNameForOriginAccessControl(crate::error::InvalidDomainNameForOriginAccessControl),
    /// <p>An invalid error code was specified.</p>
    InvalidErrorCode(crate::error::InvalidErrorCode),
    /// <p>Your request contains forward cookies option which doesn't match with the expectation for the <code>whitelisted</code> list of cookie names. Either list of cookie names has been specified when not allowed or list of cookie names is missing when expected.</p>
    InvalidForwardCookies(crate::error::InvalidForwardCookies),
    /// <p>A CloudFront function association is invalid.</p>
    InvalidFunctionAssociation(crate::error::InvalidFunctionAssociation),
    /// <p>The specified geo restriction parameter is not valid.</p>
    InvalidGeoRestrictionParameter(crate::error::InvalidGeoRestrictionParameter),
    /// <p>The headers specified are not valid for an Amazon S3 origin.</p>
    InvalidHeadersForS3Origin(crate::error::InvalidHeadersForS3Origin),
    /// <p>The specified Lambda@Edge function association is invalid.</p>
    InvalidLambdaFunctionAssociation(crate::error::InvalidLambdaFunctionAssociation),
    /// <p>The location code specified is not valid.</p>
    InvalidLocationCode(crate::error::InvalidLocationCode),
    /// <p>The minimum protocol version specified is not valid.</p>
    InvalidMinimumProtocolVersion(crate::error::InvalidMinimumProtocolVersion),
    /// <p>The Amazon S3 origin server specified does not refer to a valid Amazon S3 bucket.</p>
    InvalidOrigin(crate::error::InvalidOrigin),
    /// <p>The origin access control is not valid.</p>
    InvalidOriginAccessControl(crate::error::InvalidOriginAccessControl),
    /// <p>The origin access identity is not valid or doesn't exist.</p>
    InvalidOriginAccessIdentity(crate::error::InvalidOriginAccessIdentity),
    /// <p>The keep alive timeout specified for the origin is not valid.</p>
    InvalidOriginKeepaliveTimeout(crate::error::InvalidOriginKeepaliveTimeout),
    /// <p>The read timeout specified for the origin is not valid.</p>
    InvalidOriginReadTimeout(crate::error::InvalidOriginReadTimeout),
    /// <p>You cannot specify SSLv3 as the minimum protocol version if you only want to support only clients that support Server Name Indication (SNI).</p>
    InvalidProtocolSettings(crate::error::InvalidProtocolSettings),
    /// <p>The query string parameters specified are not valid.</p>
    InvalidQueryStringParameters(crate::error::InvalidQueryStringParameters),
    /// <p>The relative path is too big, is not URL-encoded, or does not begin with a slash (/).</p>
    InvalidRelativePath(crate::error::InvalidRelativePath),
    /// <p>This operation requires the HTTPS protocol. Ensure that you specify the HTTPS protocol in your request, or omit the <code>RequiredProtocols</code> element from your distribution configuration.</p>
    InvalidRequiredProtocol(crate::error::InvalidRequiredProtocol),
    /// <p>A response code is not valid.</p>
    InvalidResponseCode(crate::error::InvalidResponseCode),
    /// <p>The TTL order specified is not valid.</p>
    InvalidTtlOrder(crate::error::InvalidTtlOrder),
    /// <p>A viewer certificate specified is not valid.</p>
    InvalidViewerCertificate(crate::error::InvalidViewerCertificate),
    /// <p>A web ACL ID specified is not valid. To specify a web ACL created using the latest version of WAF, use the ACL ARN, for example <code>arn:aws:wafv2:us-east-1:123456789012:global/webacl/ExampleWebACL/473e64fd-f30b-4765-81a0-62ad96dd167a</code>. To specify a web ACL created using WAF Classic, use the ACL ID, for example <code>473e64fd-f30b-4765-81a0-62ad96dd167a</code>.</p>
    InvalidWebAclId(crate::error::InvalidWebAclId),
    /// <p>This operation requires a body. Ensure that the body is present and the <code>Content-Type</code> header is set.</p>
    MissingBody(crate::error::MissingBody),
    /// <p>The cache policy does not exist.</p>
    NoSuchCachePolicy(crate::error::NoSuchCachePolicy),
    /// <p>The continuous deployment policy doesn't exist.</p>
    NoSuchContinuousDeploymentPolicy(crate::error::NoSuchContinuousDeploymentPolicy),
    /// <p>The specified configuration for field-level encryption doesn't exist.</p>
    NoSuchFieldLevelEncryptionConfig(crate::error::NoSuchFieldLevelEncryptionConfig),
    /// <p>No origin exists with the specified <code>Origin Id</code>.</p>
    NoSuchOrigin(crate::error::NoSuchOrigin),
    /// <p>The origin request policy does not exist.</p>
    NoSuchOriginRequestPolicy(crate::error::NoSuchOriginRequestPolicy),
    /// <p>The real-time log configuration does not exist.</p>
    NoSuchRealtimeLogConfig(crate::error::NoSuchRealtimeLogConfig),
    /// <p>The response headers policy does not exist.</p>
    NoSuchResponseHeadersPolicy(crate::error::NoSuchResponseHeadersPolicy),
    /// <p>The specified real-time log configuration belongs to a different Amazon Web Services account.</p>
    RealtimeLogConfigOwnerMismatch(crate::error::RealtimeLogConfigOwnerMismatch),
    /// <p>You cannot create more cache behaviors for the distribution.</p>
    TooManyCacheBehaviors(crate::error::TooManyCacheBehaviors),
    /// <p>You cannot create anymore custom SSL/TLS certificates.</p>
    TooManyCertificates(crate::error::TooManyCertificates),
    /// <p>Your request contains more cookie names in the whitelist than are allowed per cache behavior.</p>
    TooManyCookieNamesInWhiteList(crate::error::TooManyCookieNamesInWhiteList),
    /// <p>Your request contains more CNAMEs than are allowed per distribution.</p>
    TooManyDistributionCnamEs(crate::error::TooManyDistributionCnamEs),
    /// <p>Processing your request would cause you to exceed the maximum number of distributions allowed.</p>
    TooManyDistributions(crate::error::TooManyDistributions),
    /// <p>The maximum number of distributions have been associated with the specified cache policy. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
    TooManyDistributionsAssociatedToCachePolicy(
        crate::error::TooManyDistributionsAssociatedToCachePolicy,
    ),
    /// <p>The maximum number of distributions have been associated with the specified configuration for field-level encryption.</p>
    TooManyDistributionsAssociatedToFieldLevelEncryptionConfig(
        crate::error::TooManyDistributionsAssociatedToFieldLevelEncryptionConfig,
    ),
    /// <p>The number of distributions that reference this key group is more than the maximum allowed. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
    TooManyDistributionsAssociatedToKeyGroup(
        crate::error::TooManyDistributionsAssociatedToKeyGroup,
    ),
    /// <p>The maximum number of distributions have been associated with the specified origin access control.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
    TooManyDistributionsAssociatedToOriginAccessControl(
        crate::error::TooManyDistributionsAssociatedToOriginAccessControl,
    ),
    /// <p>The maximum number of distributions have been associated with the specified origin request policy. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
    TooManyDistributionsAssociatedToOriginRequestPolicy(
        crate::error::TooManyDistributionsAssociatedToOriginRequestPolicy,
    ),
    /// <p>The maximum number of distributions have been associated with the specified response headers policy.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
    TooManyDistributionsAssociatedToResponseHeadersPolicy(
        crate::error::TooManyDistributionsAssociatedToResponseHeadersPolicy,
    ),
    /// <p>You have reached the maximum number of distributions that are associated with a CloudFront function. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
    TooManyDistributionsWithFunctionAssociations(
        crate::error::TooManyDistributionsWithFunctionAssociations,
    ),
    /// <p>Processing your request would cause the maximum number of distributions with Lambda@Edge function associations per owner to be exceeded.</p>
    TooManyDistributionsWithLambdaAssociations(
        crate::error::TooManyDistributionsWithLambdaAssociations,
    ),
    /// <p>The maximum number of distributions have been associated with the specified Lambda@Edge function.</p>
    TooManyDistributionsWithSingleFunctionArn(
        crate::error::TooManyDistributionsWithSingleFunctionArn,
    ),
    /// <p>You have reached the maximum number of CloudFront function associations for this distribution. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
    TooManyFunctionAssociations(crate::error::TooManyFunctionAssociations),
    /// <p>Your request contains too many headers in forwarded values.</p>
    TooManyHeadersInForwardedValues(crate::error::TooManyHeadersInForwardedValues),
    /// <p>The number of key groups referenced by this distribution is more than the maximum allowed. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
    TooManyKeyGroupsAssociatedToDistribution(
        crate::error::TooManyKeyGroupsAssociatedToDistribution,
    ),
    /// <p>Your request contains more Lambda@Edge function associations than are allowed per distribution.</p>
    TooManyLambdaFunctionAssociations(crate::error::TooManyLambdaFunctionAssociations),
    /// <p>Your request contains too many origin custom headers.</p>
    TooManyOriginCustomHeaders(crate::error::TooManyOriginCustomHeaders),
    /// <p>Processing your request would cause you to exceed the maximum number of origin groups allowed.</p>
    TooManyOriginGroupsPerDistribution(crate::error::TooManyOriginGroupsPerDistribution),
    /// <p>You cannot create more origins for the distribution.</p>
    TooManyOrigins(crate::error::TooManyOrigins),
    /// <p>Your request contains too many query string parameters.</p>
    TooManyQueryStringParameters(crate::error::TooManyQueryStringParameters),
    /// <p>Your request contains more trusted signers than are allowed per distribution.</p>
    TooManyTrustedSigners(crate::error::TooManyTrustedSigners),
    /// <p>The specified key group does not exist.</p>
    TrustedKeyGroupDoesNotExist(crate::error::TrustedKeyGroupDoesNotExist),
    /// <p>One or more of your trusted signers don't exist.</p>
    TrustedSignerDoesNotExist(crate::error::TrustedSignerDoesNotExist),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for CreateDistributionError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for CreateDistributionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AccessDenied(_inner) => _inner.fmt(f),
            Self::CnameAlreadyExists(_inner) => _inner.fmt(f),
            Self::ContinuousDeploymentPolicyInUse(_inner) => _inner.fmt(f),
            Self::DistributionAlreadyExists(_inner) => _inner.fmt(f),
            Self::IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior(_inner) => {
                _inner.fmt(f)
            }
            Self::IllegalOriginAccessConfiguration(_inner) => _inner.fmt(f),
            Self::InconsistentQuantities(_inner) => _inner.fmt(f),
            Self::InvalidArgument(_inner) => _inner.fmt(f),
            Self::InvalidDefaultRootObject(_inner) => _inner.fmt(f),
            Self::InvalidDomainNameForOriginAccessControl(_inner) => _inner.fmt(f),
            Self::InvalidErrorCode(_inner) => _inner.fmt(f),
            Self::InvalidForwardCookies(_inner) => _inner.fmt(f),
            Self::InvalidFunctionAssociation(_inner) => _inner.fmt(f),
            Self::InvalidGeoRestrictionParameter(_inner) => _inner.fmt(f),
            Self::InvalidHeadersForS3Origin(_inner) => _inner.fmt(f),
            Self::InvalidLambdaFunctionAssociation(_inner) => _inner.fmt(f),
            Self::InvalidLocationCode(_inner) => _inner.fmt(f),
            Self::InvalidMinimumProtocolVersion(_inner) => _inner.fmt(f),
            Self::InvalidOrigin(_inner) => _inner.fmt(f),
            Self::InvalidOriginAccessControl(_inner) => _inner.fmt(f),
            Self::InvalidOriginAccessIdentity(_inner) => _inner.fmt(f),
            Self::InvalidOriginKeepaliveTimeout(_inner) => _inner.fmt(f),
            Self::InvalidOriginReadTimeout(_inner) => _inner.fmt(f),
            Self::InvalidProtocolSettings(_inner) => _inner.fmt(f),
            Self::InvalidQueryStringParameters(_inner) => _inner.fmt(f),
            Self::InvalidRelativePath(_inner) => _inner.fmt(f),
            Self::InvalidRequiredProtocol(_inner) => _inner.fmt(f),
            Self::InvalidResponseCode(_inner) => _inner.fmt(f),
            Self::InvalidTtlOrder(_inner) => _inner.fmt(f),
            Self::InvalidViewerCertificate(_inner) => _inner.fmt(f),
            Self::InvalidWebAclId(_inner) => _inner.fmt(f),
            Self::MissingBody(_inner) => _inner.fmt(f),
            Self::NoSuchCachePolicy(_inner) => _inner.fmt(f),
            Self::NoSuchContinuousDeploymentPolicy(_inner) => _inner.fmt(f),
            Self::NoSuchFieldLevelEncryptionConfig(_inner) => _inner.fmt(f),
            Self::NoSuchOrigin(_inner) => _inner.fmt(f),
            Self::NoSuchOriginRequestPolicy(_inner) => _inner.fmt(f),
            Self::NoSuchRealtimeLogConfig(_inner) => _inner.fmt(f),
            Self::NoSuchResponseHeadersPolicy(_inner) => _inner.fmt(f),
            Self::RealtimeLogConfigOwnerMismatch(_inner) => _inner.fmt(f),
            Self::TooManyCacheBehaviors(_inner) => _inner.fmt(f),
            Self::TooManyCertificates(_inner) => _inner.fmt(f),
            Self::TooManyCookieNamesInWhiteList(_inner) => _inner.fmt(f),
            Self::TooManyDistributionCnamEs(_inner) => _inner.fmt(f),
            Self::TooManyDistributions(_inner) => _inner.fmt(f),
            Self::TooManyDistributionsAssociatedToCachePolicy(_inner) => _inner.fmt(f),
            Self::TooManyDistributionsAssociatedToFieldLevelEncryptionConfig(_inner) => {
                _inner.fmt(f)
            }
            Self::TooManyDistributionsAssociatedToKeyGroup(_inner) => _inner.fmt(f),
            Self::TooManyDistributionsAssociatedToOriginAccessControl(_inner) => _inner.fmt(f),
            Self::TooManyDistributionsAssociatedToOriginRequestPolicy(_inner) => _inner.fmt(f),
            Self::TooManyDistributionsAssociatedToResponseHeadersPolicy(_inner) => _inner.fmt(f),
            Self::TooManyDistributionsWithFunctionAssociations(_inner) => _inner.fmt(f),
            Self::TooManyDistributionsWithLambdaAssociations(_inner) => _inner.fmt(f),
            Self::TooManyDistributionsWithSingleFunctionArn(_inner) => _inner.fmt(f),
            Self::TooManyFunctionAssociations(_inner) => _inner.fmt(f),
            Self::TooManyHeadersInForwardedValues(_inner) => _inner.fmt(f),
            Self::TooManyKeyGroupsAssociatedToDistribution(_inner) => _inner.fmt(f),
            Self::TooManyLambdaFunctionAssociations(_inner) => _inner.fmt(f),
            Self::TooManyOriginCustomHeaders(_inner) => _inner.fmt(f),
            Self::TooManyOriginGroupsPerDistribution(_inner) => _inner.fmt(f),
            Self::TooManyOrigins(_inner) => _inner.fmt(f),
            Self::TooManyQueryStringParameters(_inner) => _inner.fmt(f),
            Self::TooManyTrustedSigners(_inner) => _inner.fmt(f),
            Self::TrustedKeyGroupDoesNotExist(_inner) => _inner.fmt(f),
            Self::TrustedSignerDoesNotExist(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CreateDistributionError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AccessDenied(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::CnameAlreadyExists(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ContinuousDeploymentPolicyInUse(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DistributionAlreadyExists(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::IllegalOriginAccessConfiguration(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InconsistentQuantities(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidArgument(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidDefaultRootObject(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidDomainNameForOriginAccessControl(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidErrorCode(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidForwardCookies(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidFunctionAssociation(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidGeoRestrictionParameter(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidHeadersForS3Origin(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidLambdaFunctionAssociation(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidLocationCode(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidMinimumProtocolVersion(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidOrigin(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidOriginAccessControl(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidOriginAccessIdentity(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidOriginKeepaliveTimeout(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidOriginReadTimeout(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidProtocolSettings(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidQueryStringParameters(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidRelativePath(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidRequiredProtocol(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidResponseCode(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidTtlOrder(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidViewerCertificate(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidWebAclId(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::MissingBody(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NoSuchCachePolicy(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NoSuchContinuousDeploymentPolicy(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NoSuchFieldLevelEncryptionConfig(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NoSuchOrigin(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NoSuchOriginRequestPolicy(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NoSuchRealtimeLogConfig(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NoSuchResponseHeadersPolicy(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RealtimeLogConfigOwnerMismatch(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyCacheBehaviors(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyCertificates(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyCookieNamesInWhiteList(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyDistributionCnamEs(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyDistributions(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyDistributionsAssociatedToCachePolicy(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyDistributionsAssociatedToFieldLevelEncryptionConfig(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyDistributionsAssociatedToKeyGroup(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyDistributionsAssociatedToOriginAccessControl(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyDistributionsAssociatedToOriginRequestPolicy(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyDistributionsAssociatedToResponseHeadersPolicy(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyDistributionsWithFunctionAssociations(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyDistributionsWithLambdaAssociations(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyDistributionsWithSingleFunctionArn(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyFunctionAssociations(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyHeadersInForwardedValues(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyKeyGroupsAssociatedToDistribution(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyLambdaFunctionAssociations(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyOriginCustomHeaders(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyOriginGroupsPerDistribution(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyOrigins(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyQueryStringParameters(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyTrustedSigners(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TrustedKeyGroupDoesNotExist(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TrustedSignerDoesNotExist(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::CreateDistributionError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateDistributionError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateDistributionError {
    /// Creates the `CreateDistributionError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `CreateDistributionError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AccessDenied(e) => e.meta(),
            Self::CnameAlreadyExists(e) => e.meta(),
            Self::ContinuousDeploymentPolicyInUse(e) => e.meta(),
            Self::DistributionAlreadyExists(e) => e.meta(),
            Self::IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior(e) => e.meta(),
            Self::IllegalOriginAccessConfiguration(e) => e.meta(),
            Self::InconsistentQuantities(e) => e.meta(),
            Self::InvalidArgument(e) => e.meta(),
            Self::InvalidDefaultRootObject(e) => e.meta(),
            Self::InvalidDomainNameForOriginAccessControl(e) => e.meta(),
            Self::InvalidErrorCode(e) => e.meta(),
            Self::InvalidForwardCookies(e) => e.meta(),
            Self::InvalidFunctionAssociation(e) => e.meta(),
            Self::InvalidGeoRestrictionParameter(e) => e.meta(),
            Self::InvalidHeadersForS3Origin(e) => e.meta(),
            Self::InvalidLambdaFunctionAssociation(e) => e.meta(),
            Self::InvalidLocationCode(e) => e.meta(),
            Self::InvalidMinimumProtocolVersion(e) => e.meta(),
            Self::InvalidOrigin(e) => e.meta(),
            Self::InvalidOriginAccessControl(e) => e.meta(),
            Self::InvalidOriginAccessIdentity(e) => e.meta(),
            Self::InvalidOriginKeepaliveTimeout(e) => e.meta(),
            Self::InvalidOriginReadTimeout(e) => e.meta(),
            Self::InvalidProtocolSettings(e) => e.meta(),
            Self::InvalidQueryStringParameters(e) => e.meta(),
            Self::InvalidRelativePath(e) => e.meta(),
            Self::InvalidRequiredProtocol(e) => e.meta(),
            Self::InvalidResponseCode(e) => e.meta(),
            Self::InvalidTtlOrder(e) => e.meta(),
            Self::InvalidViewerCertificate(e) => e.meta(),
            Self::InvalidWebAclId(e) => e.meta(),
            Self::MissingBody(e) => e.meta(),
            Self::NoSuchCachePolicy(e) => e.meta(),
            Self::NoSuchContinuousDeploymentPolicy(e) => e.meta(),
            Self::NoSuchFieldLevelEncryptionConfig(e) => e.meta(),
            Self::NoSuchOrigin(e) => e.meta(),
            Self::NoSuchOriginRequestPolicy(e) => e.meta(),
            Self::NoSuchRealtimeLogConfig(e) => e.meta(),
            Self::NoSuchResponseHeadersPolicy(e) => e.meta(),
            Self::RealtimeLogConfigOwnerMismatch(e) => e.meta(),
            Self::TooManyCacheBehaviors(e) => e.meta(),
            Self::TooManyCertificates(e) => e.meta(),
            Self::TooManyCookieNamesInWhiteList(e) => e.meta(),
            Self::TooManyDistributionCnamEs(e) => e.meta(),
            Self::TooManyDistributions(e) => e.meta(),
            Self::TooManyDistributionsAssociatedToCachePolicy(e) => e.meta(),
            Self::TooManyDistributionsAssociatedToFieldLevelEncryptionConfig(e) => e.meta(),
            Self::TooManyDistributionsAssociatedToKeyGroup(e) => e.meta(),
            Self::TooManyDistributionsAssociatedToOriginAccessControl(e) => e.meta(),
            Self::TooManyDistributionsAssociatedToOriginRequestPolicy(e) => e.meta(),
            Self::TooManyDistributionsAssociatedToResponseHeadersPolicy(e) => e.meta(),
            Self::TooManyDistributionsWithFunctionAssociations(e) => e.meta(),
            Self::TooManyDistributionsWithLambdaAssociations(e) => e.meta(),
            Self::TooManyDistributionsWithSingleFunctionArn(e) => e.meta(),
            Self::TooManyFunctionAssociations(e) => e.meta(),
            Self::TooManyHeadersInForwardedValues(e) => e.meta(),
            Self::TooManyKeyGroupsAssociatedToDistribution(e) => e.meta(),
            Self::TooManyLambdaFunctionAssociations(e) => e.meta(),
            Self::TooManyOriginCustomHeaders(e) => e.meta(),
            Self::TooManyOriginGroupsPerDistribution(e) => e.meta(),
            Self::TooManyOrigins(e) => e.meta(),
            Self::TooManyQueryStringParameters(e) => e.meta(),
            Self::TooManyTrustedSigners(e) => e.meta(),
            Self::TrustedKeyGroupDoesNotExist(e) => e.meta(),
            Self::TrustedSignerDoesNotExist(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `CreateDistributionError::AccessDenied`.
    pub fn is_access_denied(&self) -> bool {
        matches!(self, Self::AccessDenied(_))
    }
    /// Returns `true` if the error kind is `CreateDistributionError::CnameAlreadyExists`.
    pub fn is_cname_already_exists(&self) -> bool {
        matches!(self, Self::CnameAlreadyExists(_))
    }
    /// Returns `true` if the error kind is `CreateDistributionError::ContinuousDeploymentPolicyInUse`.
    pub fn is_continuous_deployment_policy_in_use(&self) -> bool {
        matches!(self, Self::ContinuousDeploymentPolicyInUse(_))
    }
    /// Returns `true` if the error kind is `CreateDistributionError::DistributionAlreadyExists`.
    pub fn is_distribution_already_exists(&self) -> bool {
        matches!(self, Self::DistributionAlreadyExists(_))
    }
    /// Returns `true` if the error kind is `CreateDistributionError::IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior`.
    pub fn is_illegal_field_level_encryption_config_association_with_cache_behavior(&self) -> bool {
        matches!(
            self,
            Self::IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior(_)
        )
    }
    /// Returns `true` if the error kind is `CreateDistributionError::IllegalOriginAccessConfiguration`.
    pub fn is_illegal_origin_access_configuration(&self) -> bool {
        matches!(self, Self::IllegalOriginAccessConfiguration(_))
    }
    /// Returns `true` if the error kind is `CreateDistributionError::InconsistentQuantities`.
    pub fn is_inconsistent_quantities(&self) -> bool {
        matches!(self, Self::InconsistentQuantities(_))
    }
    /// Returns `true` if the error kind is `CreateDistributionError::InvalidArgument`.
    pub fn is_invalid_argument(&self) -> bool {
        matches!(self, Self::InvalidArgument(_))
    }
    /// Returns `true` if the error kind is `CreateDistributionError::InvalidDefaultRootObject`.
    pub fn is_invalid_default_root_object(&self) -> bool {
        matches!(self, Self::InvalidDefaultRootObject(_))
    }
    /// Returns `true` if the error kind is `CreateDistributionError::InvalidDomainNameForOriginAccessControl`.
    pub fn is_invalid_domain_name_for_origin_access_control(&self) -> bool {
        matches!(self, Self::InvalidDomainNameForOriginAccessControl(_))
    }
    /// Returns `true` if the error kind is `CreateDistributionError::InvalidErrorCode`.
    pub fn is_invalid_error_code(&self) -> bool {
        matches!(self, Self::InvalidErrorCode(_))
    }
    /// Returns `true` if the error kind is `CreateDistributionError::InvalidForwardCookies`.
    pub fn is_invalid_forward_cookies(&self) -> bool {
        matches!(self, Self::InvalidForwardCookies(_))
    }
    /// Returns `true` if the error kind is `CreateDistributionError::InvalidFunctionAssociation`.
    pub fn is_invalid_function_association(&self) -> bool {
        matches!(self, Self::InvalidFunctionAssociation(_))
    }
    /// Returns `true` if the error kind is `CreateDistributionError::InvalidGeoRestrictionParameter`.
    pub fn is_invalid_geo_restriction_parameter(&self) -> bool {
        matches!(self, Self::InvalidGeoRestrictionParameter(_))
    }
    /// Returns `true` if the error kind is `CreateDistributionError::InvalidHeadersForS3Origin`.
    pub fn is_invalid_headers_for_s3_origin(&self) -> bool {
        matches!(self, Self::InvalidHeadersForS3Origin(_))
    }
    /// Returns `true` if the error kind is `CreateDistributionError::InvalidLambdaFunctionAssociation`.
    pub fn is_invalid_lambda_function_association(&self) -> bool {
        matches!(self, Self::InvalidLambdaFunctionAssociation(_))
    }
    /// Returns `true` if the error kind is `CreateDistributionError::InvalidLocationCode`.
    pub fn is_invalid_location_code(&self) -> bool {
        matches!(self, Self::InvalidLocationCode(_))
    }
    /// Returns `true` if the error kind is `CreateDistributionError::InvalidMinimumProtocolVersion`.
    pub fn is_invalid_minimum_protocol_version(&self) -> bool {
        matches!(self, Self::InvalidMinimumProtocolVersion(_))
    }
    /// Returns `true` if the error kind is `CreateDistributionError::InvalidOrigin`.
    pub fn is_invalid_origin(&self) -> bool {
        matches!(self, Self::InvalidOrigin(_))
    }
    /// Returns `true` if the error kind is `CreateDistributionError::InvalidOriginAccessControl`.
    pub fn is_invalid_origin_access_control(&self) -> bool {
        matches!(self, Self::InvalidOriginAccessControl(_))
    }
    /// Returns `true` if the error kind is `CreateDistributionError::InvalidOriginAccessIdentity`.
    pub fn is_invalid_origin_access_identity(&self) -> bool {
        matches!(self, Self::InvalidOriginAccessIdentity(_))
    }
    /// Returns `true` if the error kind is `CreateDistributionError::InvalidOriginKeepaliveTimeout`.
    pub fn is_invalid_origin_keepalive_timeout(&self) -> bool {
        matches!(self, Self::InvalidOriginKeepaliveTimeout(_))
    }
    /// Returns `true` if the error kind is `CreateDistributionError::InvalidOriginReadTimeout`.
    pub fn is_invalid_origin_read_timeout(&self) -> bool {
        matches!(self, Self::InvalidOriginReadTimeout(_))
    }
    /// Returns `true` if the error kind is `CreateDistributionError::InvalidProtocolSettings`.
    pub fn is_invalid_protocol_settings(&self) -> bool {
        matches!(self, Self::InvalidProtocolSettings(_))
    }
    /// Returns `true` if the error kind is `CreateDistributionError::InvalidQueryStringParameters`.
    pub fn is_invalid_query_string_parameters(&self) -> bool {
        matches!(self, Self::InvalidQueryStringParameters(_))
    }
    /// Returns `true` if the error kind is `CreateDistributionError::InvalidRelativePath`.
    pub fn is_invalid_relative_path(&self) -> bool {
        matches!(self, Self::InvalidRelativePath(_))
    }
    /// Returns `true` if the error kind is `CreateDistributionError::InvalidRequiredProtocol`.
    pub fn is_invalid_required_protocol(&self) -> bool {
        matches!(self, Self::InvalidRequiredProtocol(_))
    }
    /// Returns `true` if the error kind is `CreateDistributionError::InvalidResponseCode`.
    pub fn is_invalid_response_code(&self) -> bool {
        matches!(self, Self::InvalidResponseCode(_))
    }
    /// Returns `true` if the error kind is `CreateDistributionError::InvalidTtlOrder`.
    pub fn is_invalid_ttl_order(&self) -> bool {
        matches!(self, Self::InvalidTtlOrder(_))
    }
    /// Returns `true` if the error kind is `CreateDistributionError::InvalidViewerCertificate`.
    pub fn is_invalid_viewer_certificate(&self) -> bool {
        matches!(self, Self::InvalidViewerCertificate(_))
    }
    /// Returns `true` if the error kind is `CreateDistributionError::InvalidWebAclId`.
    pub fn is_invalid_web_acl_id(&self) -> bool {
        matches!(self, Self::InvalidWebAclId(_))
    }
    /// Returns `true` if the error kind is `CreateDistributionError::MissingBody`.
    pub fn is_missing_body(&self) -> bool {
        matches!(self, Self::MissingBody(_))
    }
    /// Returns `true` if the error kind is `CreateDistributionError::NoSuchCachePolicy`.
    pub fn is_no_such_cache_policy(&self) -> bool {
        matches!(self, Self::NoSuchCachePolicy(_))
    }
    /// Returns `true` if the error kind is `CreateDistributionError::NoSuchContinuousDeploymentPolicy`.
    pub fn is_no_such_continuous_deployment_policy(&self) -> bool {
        matches!(self, Self::NoSuchContinuousDeploymentPolicy(_))
    }
    /// Returns `true` if the error kind is `CreateDistributionError::NoSuchFieldLevelEncryptionConfig`.
    pub fn is_no_such_field_level_encryption_config(&self) -> bool {
        matches!(self, Self::NoSuchFieldLevelEncryptionConfig(_))
    }
    /// Returns `true` if the error kind is `CreateDistributionError::NoSuchOrigin`.
    pub fn is_no_such_origin(&self) -> bool {
        matches!(self, Self::NoSuchOrigin(_))
    }
    /// Returns `true` if the error kind is `CreateDistributionError::NoSuchOriginRequestPolicy`.
    pub fn is_no_such_origin_request_policy(&self) -> bool {
        matches!(self, Self::NoSuchOriginRequestPolicy(_))
    }
    /// Returns `true` if the error kind is `CreateDistributionError::NoSuchRealtimeLogConfig`.
    pub fn is_no_such_realtime_log_config(&self) -> bool {
        matches!(self, Self::NoSuchRealtimeLogConfig(_))
    }
    /// Returns `true` if the error kind is `CreateDistributionError::NoSuchResponseHeadersPolicy`.
    pub fn is_no_such_response_headers_policy(&self) -> bool {
        matches!(self, Self::NoSuchResponseHeadersPolicy(_))
    }
    /// Returns `true` if the error kind is `CreateDistributionError::RealtimeLogConfigOwnerMismatch`.
    pub fn is_realtime_log_config_owner_mismatch(&self) -> bool {
        matches!(self, Self::RealtimeLogConfigOwnerMismatch(_))
    }
    /// Returns `true` if the error kind is `CreateDistributionError::TooManyCacheBehaviors`.
    pub fn is_too_many_cache_behaviors(&self) -> bool {
        matches!(self, Self::TooManyCacheBehaviors(_))
    }
    /// Returns `true` if the error kind is `CreateDistributionError::TooManyCertificates`.
    pub fn is_too_many_certificates(&self) -> bool {
        matches!(self, Self::TooManyCertificates(_))
    }
    /// Returns `true` if the error kind is `CreateDistributionError::TooManyCookieNamesInWhiteList`.
    pub fn is_too_many_cookie_names_in_white_list(&self) -> bool {
        matches!(self, Self::TooManyCookieNamesInWhiteList(_))
    }
    /// Returns `true` if the error kind is `CreateDistributionError::TooManyDistributionCnamEs`.
    pub fn is_too_many_distribution_cnam_es(&self) -> bool {
        matches!(self, Self::TooManyDistributionCnamEs(_))
    }
    /// Returns `true` if the error kind is `CreateDistributionError::TooManyDistributions`.
    pub fn is_too_many_distributions(&self) -> bool {
        matches!(self, Self::TooManyDistributions(_))
    }
    /// Returns `true` if the error kind is `CreateDistributionError::TooManyDistributionsAssociatedToCachePolicy`.
    pub fn is_too_many_distributions_associated_to_cache_policy(&self) -> bool {
        matches!(self, Self::TooManyDistributionsAssociatedToCachePolicy(_))
    }
    /// Returns `true` if the error kind is `CreateDistributionError::TooManyDistributionsAssociatedToFieldLevelEncryptionConfig`.
    pub fn is_too_many_distributions_associated_to_field_level_encryption_config(&self) -> bool {
        matches!(
            self,
            Self::TooManyDistributionsAssociatedToFieldLevelEncryptionConfig(_)
        )
    }
    /// Returns `true` if the error kind is `CreateDistributionError::TooManyDistributionsAssociatedToKeyGroup`.
    pub fn is_too_many_distributions_associated_to_key_group(&self) -> bool {
        matches!(self, Self::TooManyDistributionsAssociatedToKeyGroup(_))
    }
    /// Returns `true` if the error kind is `CreateDistributionError::TooManyDistributionsAssociatedToOriginAccessControl`.
    pub fn is_too_many_distributions_associated_to_origin_access_control(&self) -> bool {
        matches!(
            self,
            Self::TooManyDistributionsAssociatedToOriginAccessControl(_)
        )
    }
    /// Returns `true` if the error kind is `CreateDistributionError::TooManyDistributionsAssociatedToOriginRequestPolicy`.
    pub fn is_too_many_distributions_associated_to_origin_request_policy(&self) -> bool {
        matches!(
            self,
            Self::TooManyDistributionsAssociatedToOriginRequestPolicy(_)
        )
    }
    /// Returns `true` if the error kind is `CreateDistributionError::TooManyDistributionsAssociatedToResponseHeadersPolicy`.
    pub fn is_too_many_distributions_associated_to_response_headers_policy(&self) -> bool {
        matches!(
            self,
            Self::TooManyDistributionsAssociatedToResponseHeadersPolicy(_)
        )
    }
    /// Returns `true` if the error kind is `CreateDistributionError::TooManyDistributionsWithFunctionAssociations`.
    pub fn is_too_many_distributions_with_function_associations(&self) -> bool {
        matches!(self, Self::TooManyDistributionsWithFunctionAssociations(_))
    }
    /// Returns `true` if the error kind is `CreateDistributionError::TooManyDistributionsWithLambdaAssociations`.
    pub fn is_too_many_distributions_with_lambda_associations(&self) -> bool {
        matches!(self, Self::TooManyDistributionsWithLambdaAssociations(_))
    }
    /// Returns `true` if the error kind is `CreateDistributionError::TooManyDistributionsWithSingleFunctionArn`.
    pub fn is_too_many_distributions_with_single_function_arn(&self) -> bool {
        matches!(self, Self::TooManyDistributionsWithSingleFunctionArn(_))
    }
    /// Returns `true` if the error kind is `CreateDistributionError::TooManyFunctionAssociations`.
    pub fn is_too_many_function_associations(&self) -> bool {
        matches!(self, Self::TooManyFunctionAssociations(_))
    }
    /// Returns `true` if the error kind is `CreateDistributionError::TooManyHeadersInForwardedValues`.
    pub fn is_too_many_headers_in_forwarded_values(&self) -> bool {
        matches!(self, Self::TooManyHeadersInForwardedValues(_))
    }
    /// Returns `true` if the error kind is `CreateDistributionError::TooManyKeyGroupsAssociatedToDistribution`.
    pub fn is_too_many_key_groups_associated_to_distribution(&self) -> bool {
        matches!(self, Self::TooManyKeyGroupsAssociatedToDistribution(_))
    }
    /// Returns `true` if the error kind is `CreateDistributionError::TooManyLambdaFunctionAssociations`.
    pub fn is_too_many_lambda_function_associations(&self) -> bool {
        matches!(self, Self::TooManyLambdaFunctionAssociations(_))
    }
    /// Returns `true` if the error kind is `CreateDistributionError::TooManyOriginCustomHeaders`.
    pub fn is_too_many_origin_custom_headers(&self) -> bool {
        matches!(self, Self::TooManyOriginCustomHeaders(_))
    }
    /// Returns `true` if the error kind is `CreateDistributionError::TooManyOriginGroupsPerDistribution`.
    pub fn is_too_many_origin_groups_per_distribution(&self) -> bool {
        matches!(self, Self::TooManyOriginGroupsPerDistribution(_))
    }
    /// Returns `true` if the error kind is `CreateDistributionError::TooManyOrigins`.
    pub fn is_too_many_origins(&self) -> bool {
        matches!(self, Self::TooManyOrigins(_))
    }
    /// Returns `true` if the error kind is `CreateDistributionError::TooManyQueryStringParameters`.
    pub fn is_too_many_query_string_parameters(&self) -> bool {
        matches!(self, Self::TooManyQueryStringParameters(_))
    }
    /// Returns `true` if the error kind is `CreateDistributionError::TooManyTrustedSigners`.
    pub fn is_too_many_trusted_signers(&self) -> bool {
        matches!(self, Self::TooManyTrustedSigners(_))
    }
    /// Returns `true` if the error kind is `CreateDistributionError::TrustedKeyGroupDoesNotExist`.
    pub fn is_trusted_key_group_does_not_exist(&self) -> bool {
        matches!(self, Self::TrustedKeyGroupDoesNotExist(_))
    }
    /// Returns `true` if the error kind is `CreateDistributionError::TrustedSignerDoesNotExist`.
    pub fn is_trusted_signer_does_not_exist(&self) -> bool {
        matches!(self, Self::TrustedSignerDoesNotExist(_))
    }
}
impl std::error::Error for CreateDistributionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AccessDenied(_inner) => Some(_inner),
            Self::CnameAlreadyExists(_inner) => Some(_inner),
            Self::ContinuousDeploymentPolicyInUse(_inner) => Some(_inner),
            Self::DistributionAlreadyExists(_inner) => Some(_inner),
            Self::IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior(_inner) => {
                Some(_inner)
            }
            Self::IllegalOriginAccessConfiguration(_inner) => Some(_inner),
            Self::InconsistentQuantities(_inner) => Some(_inner),
            Self::InvalidArgument(_inner) => Some(_inner),
            Self::InvalidDefaultRootObject(_inner) => Some(_inner),
            Self::InvalidDomainNameForOriginAccessControl(_inner) => Some(_inner),
            Self::InvalidErrorCode(_inner) => Some(_inner),
            Self::InvalidForwardCookies(_inner) => Some(_inner),
            Self::InvalidFunctionAssociation(_inner) => Some(_inner),
            Self::InvalidGeoRestrictionParameter(_inner) => Some(_inner),
            Self::InvalidHeadersForS3Origin(_inner) => Some(_inner),
            Self::InvalidLambdaFunctionAssociation(_inner) => Some(_inner),
            Self::InvalidLocationCode(_inner) => Some(_inner),
            Self::InvalidMinimumProtocolVersion(_inner) => Some(_inner),
            Self::InvalidOrigin(_inner) => Some(_inner),
            Self::InvalidOriginAccessControl(_inner) => Some(_inner),
            Self::InvalidOriginAccessIdentity(_inner) => Some(_inner),
            Self::InvalidOriginKeepaliveTimeout(_inner) => Some(_inner),
            Self::InvalidOriginReadTimeout(_inner) => Some(_inner),
            Self::InvalidProtocolSettings(_inner) => Some(_inner),
            Self::InvalidQueryStringParameters(_inner) => Some(_inner),
            Self::InvalidRelativePath(_inner) => Some(_inner),
            Self::InvalidRequiredProtocol(_inner) => Some(_inner),
            Self::InvalidResponseCode(_inner) => Some(_inner),
            Self::InvalidTtlOrder(_inner) => Some(_inner),
            Self::InvalidViewerCertificate(_inner) => Some(_inner),
            Self::InvalidWebAclId(_inner) => Some(_inner),
            Self::MissingBody(_inner) => Some(_inner),
            Self::NoSuchCachePolicy(_inner) => Some(_inner),
            Self::NoSuchContinuousDeploymentPolicy(_inner) => Some(_inner),
            Self::NoSuchFieldLevelEncryptionConfig(_inner) => Some(_inner),
            Self::NoSuchOrigin(_inner) => Some(_inner),
            Self::NoSuchOriginRequestPolicy(_inner) => Some(_inner),
            Self::NoSuchRealtimeLogConfig(_inner) => Some(_inner),
            Self::NoSuchResponseHeadersPolicy(_inner) => Some(_inner),
            Self::RealtimeLogConfigOwnerMismatch(_inner) => Some(_inner),
            Self::TooManyCacheBehaviors(_inner) => Some(_inner),
            Self::TooManyCertificates(_inner) => Some(_inner),
            Self::TooManyCookieNamesInWhiteList(_inner) => Some(_inner),
            Self::TooManyDistributionCnamEs(_inner) => Some(_inner),
            Self::TooManyDistributions(_inner) => Some(_inner),
            Self::TooManyDistributionsAssociatedToCachePolicy(_inner) => Some(_inner),
            Self::TooManyDistributionsAssociatedToFieldLevelEncryptionConfig(_inner) => {
                Some(_inner)
            }
            Self::TooManyDistributionsAssociatedToKeyGroup(_inner) => Some(_inner),
            Self::TooManyDistributionsAssociatedToOriginAccessControl(_inner) => Some(_inner),
            Self::TooManyDistributionsAssociatedToOriginRequestPolicy(_inner) => Some(_inner),
            Self::TooManyDistributionsAssociatedToResponseHeadersPolicy(_inner) => Some(_inner),
            Self::TooManyDistributionsWithFunctionAssociations(_inner) => Some(_inner),
            Self::TooManyDistributionsWithLambdaAssociations(_inner) => Some(_inner),
            Self::TooManyDistributionsWithSingleFunctionArn(_inner) => Some(_inner),
            Self::TooManyFunctionAssociations(_inner) => Some(_inner),
            Self::TooManyHeadersInForwardedValues(_inner) => Some(_inner),
            Self::TooManyKeyGroupsAssociatedToDistribution(_inner) => Some(_inner),
            Self::TooManyLambdaFunctionAssociations(_inner) => Some(_inner),
            Self::TooManyOriginCustomHeaders(_inner) => Some(_inner),
            Self::TooManyOriginGroupsPerDistribution(_inner) => Some(_inner),
            Self::TooManyOrigins(_inner) => Some(_inner),
            Self::TooManyQueryStringParameters(_inner) => Some(_inner),
            Self::TooManyTrustedSigners(_inner) => Some(_inner),
            Self::TrustedKeyGroupDoesNotExist(_inner) => Some(_inner),
            Self::TrustedSignerDoesNotExist(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The maximum number of distributions have been associated with the specified origin access control.</p>
/// <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TooManyDistributionsAssociatedToOriginAccessControl {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl TooManyDistributionsAssociatedToOriginAccessControl {
    /// Creates a new builder-style object to manufacture [`TooManyDistributionsAssociatedToOriginAccessControl`](crate::error::TooManyDistributionsAssociatedToOriginAccessControl).
    pub fn builder(
    ) -> crate::error::too_many_distributions_associated_to_origin_access_control::Builder {
        crate::error::too_many_distributions_associated_to_origin_access_control::Builder::default()
    }
}
/// See [`TooManyDistributionsAssociatedToOriginAccessControl`](crate::error::TooManyDistributionsAssociatedToOriginAccessControl).
pub mod too_many_distributions_associated_to_origin_access_control {

    /// A builder for [`TooManyDistributionsAssociatedToOriginAccessControl`](crate::error::TooManyDistributionsAssociatedToOriginAccessControl).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`TooManyDistributionsAssociatedToOriginAccessControl`](crate::error::TooManyDistributionsAssociatedToOriginAccessControl).
        pub fn build(self) -> crate::error::TooManyDistributionsAssociatedToOriginAccessControl {
            crate::error::TooManyDistributionsAssociatedToOriginAccessControl {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl TooManyDistributionsAssociatedToOriginAccessControl {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TooManyDistributionsAssociatedToOriginAccessControl {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TooManyDistributionsAssociatedToOriginAccessControl")?;
        if let Some(inner_139) = &self.message {
            {
                write!(f, ": {}", inner_139)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for TooManyDistributionsAssociatedToOriginAccessControl {}
impl aws_http::request_id::RequestId
    for crate::error::TooManyDistributionsAssociatedToOriginAccessControl
{
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for TooManyDistributionsAssociatedToOriginAccessControl
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type CreateContinuousDeploymentPolicyErrorKind = CreateContinuousDeploymentPolicyError;
/// Error type for the `CreateContinuousDeploymentPolicyError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateContinuousDeploymentPolicyError {
    /// <p>Access denied.</p>
    AccessDenied(crate::error::AccessDenied),
    /// <p>A continuous deployment policy with this configuration already exists.</p>
    ContinuousDeploymentPolicyAlreadyExists(crate::error::ContinuousDeploymentPolicyAlreadyExists),
    /// <p>The value of <code>Quantity</code> and the size of <code>Items</code> don't match.</p>
    InconsistentQuantities(crate::error::InconsistentQuantities),
    /// <p>An argument is invalid.</p>
    InvalidArgument(crate::error::InvalidArgument),
    /// <p>A continuous deployment policy for this staging distribution already exists.</p>
    StagingDistributionInUse(crate::error::StagingDistributionInUse),
    /// <p>You have reached the maximum number of continuous deployment policies for this Amazon Web Services account.</p>
    TooManyContinuousDeploymentPolicies(crate::error::TooManyContinuousDeploymentPolicies),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for CreateContinuousDeploymentPolicyError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for CreateContinuousDeploymentPolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AccessDenied(_inner) => _inner.fmt(f),
            Self::ContinuousDeploymentPolicyAlreadyExists(_inner) => _inner.fmt(f),
            Self::InconsistentQuantities(_inner) => _inner.fmt(f),
            Self::InvalidArgument(_inner) => _inner.fmt(f),
            Self::StagingDistributionInUse(_inner) => _inner.fmt(f),
            Self::TooManyContinuousDeploymentPolicies(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for CreateContinuousDeploymentPolicyError
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AccessDenied(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ContinuousDeploymentPolicyAlreadyExists(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InconsistentQuantities(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidArgument(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::StagingDistributionInUse(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyContinuousDeploymentPolicies(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::CreateContinuousDeploymentPolicyError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateContinuousDeploymentPolicyError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateContinuousDeploymentPolicyError {
    /// Creates the `CreateContinuousDeploymentPolicyError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `CreateContinuousDeploymentPolicyError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AccessDenied(e) => e.meta(),
            Self::ContinuousDeploymentPolicyAlreadyExists(e) => e.meta(),
            Self::InconsistentQuantities(e) => e.meta(),
            Self::InvalidArgument(e) => e.meta(),
            Self::StagingDistributionInUse(e) => e.meta(),
            Self::TooManyContinuousDeploymentPolicies(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `CreateContinuousDeploymentPolicyError::AccessDenied`.
    pub fn is_access_denied(&self) -> bool {
        matches!(self, Self::AccessDenied(_))
    }
    /// Returns `true` if the error kind is `CreateContinuousDeploymentPolicyError::ContinuousDeploymentPolicyAlreadyExists`.
    pub fn is_continuous_deployment_policy_already_exists(&self) -> bool {
        matches!(self, Self::ContinuousDeploymentPolicyAlreadyExists(_))
    }
    /// Returns `true` if the error kind is `CreateContinuousDeploymentPolicyError::InconsistentQuantities`.
    pub fn is_inconsistent_quantities(&self) -> bool {
        matches!(self, Self::InconsistentQuantities(_))
    }
    /// Returns `true` if the error kind is `CreateContinuousDeploymentPolicyError::InvalidArgument`.
    pub fn is_invalid_argument(&self) -> bool {
        matches!(self, Self::InvalidArgument(_))
    }
    /// Returns `true` if the error kind is `CreateContinuousDeploymentPolicyError::StagingDistributionInUse`.
    pub fn is_staging_distribution_in_use(&self) -> bool {
        matches!(self, Self::StagingDistributionInUse(_))
    }
    /// Returns `true` if the error kind is `CreateContinuousDeploymentPolicyError::TooManyContinuousDeploymentPolicies`.
    pub fn is_too_many_continuous_deployment_policies(&self) -> bool {
        matches!(self, Self::TooManyContinuousDeploymentPolicies(_))
    }
}
impl std::error::Error for CreateContinuousDeploymentPolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AccessDenied(_inner) => Some(_inner),
            Self::ContinuousDeploymentPolicyAlreadyExists(_inner) => Some(_inner),
            Self::InconsistentQuantities(_inner) => Some(_inner),
            Self::InvalidArgument(_inner) => Some(_inner),
            Self::StagingDistributionInUse(_inner) => Some(_inner),
            Self::TooManyContinuousDeploymentPolicies(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>You have reached the maximum number of continuous deployment policies for this Amazon Web Services account.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TooManyContinuousDeploymentPolicies {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl TooManyContinuousDeploymentPolicies {
    /// Creates a new builder-style object to manufacture [`TooManyContinuousDeploymentPolicies`](crate::error::TooManyContinuousDeploymentPolicies).
    pub fn builder() -> crate::error::too_many_continuous_deployment_policies::Builder {
        crate::error::too_many_continuous_deployment_policies::Builder::default()
    }
}
/// See [`TooManyContinuousDeploymentPolicies`](crate::error::TooManyContinuousDeploymentPolicies).
pub mod too_many_continuous_deployment_policies {

    /// A builder for [`TooManyContinuousDeploymentPolicies`](crate::error::TooManyContinuousDeploymentPolicies).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`TooManyContinuousDeploymentPolicies`](crate::error::TooManyContinuousDeploymentPolicies).
        pub fn build(self) -> crate::error::TooManyContinuousDeploymentPolicies {
            crate::error::TooManyContinuousDeploymentPolicies {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl TooManyContinuousDeploymentPolicies {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TooManyContinuousDeploymentPolicies {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TooManyContinuousDeploymentPolicies")?;
        if let Some(inner_140) = &self.message {
            {
                write!(f, ": {}", inner_140)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for TooManyContinuousDeploymentPolicies {}
impl aws_http::request_id::RequestId for crate::error::TooManyContinuousDeploymentPolicies {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for TooManyContinuousDeploymentPolicies
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>A continuous deployment policy with this configuration already exists.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ContinuousDeploymentPolicyAlreadyExists {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl ContinuousDeploymentPolicyAlreadyExists {
    /// Creates a new builder-style object to manufacture [`ContinuousDeploymentPolicyAlreadyExists`](crate::error::ContinuousDeploymentPolicyAlreadyExists).
    pub fn builder() -> crate::error::continuous_deployment_policy_already_exists::Builder {
        crate::error::continuous_deployment_policy_already_exists::Builder::default()
    }
}
/// See [`ContinuousDeploymentPolicyAlreadyExists`](crate::error::ContinuousDeploymentPolicyAlreadyExists).
pub mod continuous_deployment_policy_already_exists {

    /// A builder for [`ContinuousDeploymentPolicyAlreadyExists`](crate::error::ContinuousDeploymentPolicyAlreadyExists).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`ContinuousDeploymentPolicyAlreadyExists`](crate::error::ContinuousDeploymentPolicyAlreadyExists).
        pub fn build(self) -> crate::error::ContinuousDeploymentPolicyAlreadyExists {
            crate::error::ContinuousDeploymentPolicyAlreadyExists {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl ContinuousDeploymentPolicyAlreadyExists {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ContinuousDeploymentPolicyAlreadyExists {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ContinuousDeploymentPolicyAlreadyExists")?;
        if let Some(inner_141) = &self.message {
            {
                write!(f, ": {}", inner_141)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ContinuousDeploymentPolicyAlreadyExists {}
impl aws_http::request_id::RequestId for crate::error::ContinuousDeploymentPolicyAlreadyExists {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for ContinuousDeploymentPolicyAlreadyExists
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type CreateCloudFrontOriginAccessIdentityErrorKind = CreateCloudFrontOriginAccessIdentityError;
/// Error type for the `CreateCloudFrontOriginAccessIdentityError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateCloudFrontOriginAccessIdentityError {
    /// <p>If the <code>CallerReference</code> is a value you already sent in a previous request to create an identity but the content of the <code>CloudFrontOriginAccessIdentityConfig</code> is different from the original request, CloudFront returns a <code>CloudFrontOriginAccessIdentityAlreadyExists</code> error. </p>
    CloudFrontOriginAccessIdentityAlreadyExists(
        crate::error::CloudFrontOriginAccessIdentityAlreadyExists,
    ),
    /// <p>The value of <code>Quantity</code> and the size of <code>Items</code> don't match.</p>
    InconsistentQuantities(crate::error::InconsistentQuantities),
    /// <p>An argument is invalid.</p>
    InvalidArgument(crate::error::InvalidArgument),
    /// <p>This operation requires a body. Ensure that the body is present and the <code>Content-Type</code> header is set.</p>
    MissingBody(crate::error::MissingBody),
    /// <p>Processing your request would cause you to exceed the maximum number of origin access identities allowed.</p>
    TooManyCloudFrontOriginAccessIdentities(crate::error::TooManyCloudFrontOriginAccessIdentities),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for CreateCloudFrontOriginAccessIdentityError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for CreateCloudFrontOriginAccessIdentityError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::CloudFrontOriginAccessIdentityAlreadyExists(_inner) => _inner.fmt(f),
            Self::InconsistentQuantities(_inner) => _inner.fmt(f),
            Self::InvalidArgument(_inner) => _inner.fmt(f),
            Self::MissingBody(_inner) => _inner.fmt(f),
            Self::TooManyCloudFrontOriginAccessIdentities(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for CreateCloudFrontOriginAccessIdentityError
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::CloudFrontOriginAccessIdentityAlreadyExists(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InconsistentQuantities(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidArgument(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::MissingBody(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyCloudFrontOriginAccessIdentities(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::CreateCloudFrontOriginAccessIdentityError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateCloudFrontOriginAccessIdentityError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateCloudFrontOriginAccessIdentityError {
    /// Creates the `CreateCloudFrontOriginAccessIdentityError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `CreateCloudFrontOriginAccessIdentityError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::CloudFrontOriginAccessIdentityAlreadyExists(e) => e.meta(),
            Self::InconsistentQuantities(e) => e.meta(),
            Self::InvalidArgument(e) => e.meta(),
            Self::MissingBody(e) => e.meta(),
            Self::TooManyCloudFrontOriginAccessIdentities(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `CreateCloudFrontOriginAccessIdentityError::CloudFrontOriginAccessIdentityAlreadyExists`.
    pub fn is_cloud_front_origin_access_identity_already_exists(&self) -> bool {
        matches!(self, Self::CloudFrontOriginAccessIdentityAlreadyExists(_))
    }
    /// Returns `true` if the error kind is `CreateCloudFrontOriginAccessIdentityError::InconsistentQuantities`.
    pub fn is_inconsistent_quantities(&self) -> bool {
        matches!(self, Self::InconsistentQuantities(_))
    }
    /// Returns `true` if the error kind is `CreateCloudFrontOriginAccessIdentityError::InvalidArgument`.
    pub fn is_invalid_argument(&self) -> bool {
        matches!(self, Self::InvalidArgument(_))
    }
    /// Returns `true` if the error kind is `CreateCloudFrontOriginAccessIdentityError::MissingBody`.
    pub fn is_missing_body(&self) -> bool {
        matches!(self, Self::MissingBody(_))
    }
    /// Returns `true` if the error kind is `CreateCloudFrontOriginAccessIdentityError::TooManyCloudFrontOriginAccessIdentities`.
    pub fn is_too_many_cloud_front_origin_access_identities(&self) -> bool {
        matches!(self, Self::TooManyCloudFrontOriginAccessIdentities(_))
    }
}
impl std::error::Error for CreateCloudFrontOriginAccessIdentityError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::CloudFrontOriginAccessIdentityAlreadyExists(_inner) => Some(_inner),
            Self::InconsistentQuantities(_inner) => Some(_inner),
            Self::InvalidArgument(_inner) => Some(_inner),
            Self::MissingBody(_inner) => Some(_inner),
            Self::TooManyCloudFrontOriginAccessIdentities(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>Processing your request would cause you to exceed the maximum number of origin access identities allowed.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TooManyCloudFrontOriginAccessIdentities {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl TooManyCloudFrontOriginAccessIdentities {
    /// Creates a new builder-style object to manufacture [`TooManyCloudFrontOriginAccessIdentities`](crate::error::TooManyCloudFrontOriginAccessIdentities).
    pub fn builder() -> crate::error::too_many_cloud_front_origin_access_identities::Builder {
        crate::error::too_many_cloud_front_origin_access_identities::Builder::default()
    }
}
/// See [`TooManyCloudFrontOriginAccessIdentities`](crate::error::TooManyCloudFrontOriginAccessIdentities).
pub mod too_many_cloud_front_origin_access_identities {

    /// A builder for [`TooManyCloudFrontOriginAccessIdentities`](crate::error::TooManyCloudFrontOriginAccessIdentities).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`TooManyCloudFrontOriginAccessIdentities`](crate::error::TooManyCloudFrontOriginAccessIdentities).
        pub fn build(self) -> crate::error::TooManyCloudFrontOriginAccessIdentities {
            crate::error::TooManyCloudFrontOriginAccessIdentities {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl TooManyCloudFrontOriginAccessIdentities {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TooManyCloudFrontOriginAccessIdentities {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TooManyCloudFrontOriginAccessIdentities")?;
        if let Some(inner_142) = &self.message {
            {
                write!(f, ": {}", inner_142)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for TooManyCloudFrontOriginAccessIdentities {}
impl aws_http::request_id::RequestId for crate::error::TooManyCloudFrontOriginAccessIdentities {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for TooManyCloudFrontOriginAccessIdentities
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>If the <code>CallerReference</code> is a value you already sent in a previous request to create an identity but the content of the <code>CloudFrontOriginAccessIdentityConfig</code> is different from the original request, CloudFront returns a <code>CloudFrontOriginAccessIdentityAlreadyExists</code> error. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CloudFrontOriginAccessIdentityAlreadyExists {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl CloudFrontOriginAccessIdentityAlreadyExists {
    /// Creates a new builder-style object to manufacture [`CloudFrontOriginAccessIdentityAlreadyExists`](crate::error::CloudFrontOriginAccessIdentityAlreadyExists).
    pub fn builder() -> crate::error::cloud_front_origin_access_identity_already_exists::Builder {
        crate::error::cloud_front_origin_access_identity_already_exists::Builder::default()
    }
}
/// See [`CloudFrontOriginAccessIdentityAlreadyExists`](crate::error::CloudFrontOriginAccessIdentityAlreadyExists).
pub mod cloud_front_origin_access_identity_already_exists {

    /// A builder for [`CloudFrontOriginAccessIdentityAlreadyExists`](crate::error::CloudFrontOriginAccessIdentityAlreadyExists).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`CloudFrontOriginAccessIdentityAlreadyExists`](crate::error::CloudFrontOriginAccessIdentityAlreadyExists).
        pub fn build(self) -> crate::error::CloudFrontOriginAccessIdentityAlreadyExists {
            crate::error::CloudFrontOriginAccessIdentityAlreadyExists {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl CloudFrontOriginAccessIdentityAlreadyExists {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CloudFrontOriginAccessIdentityAlreadyExists {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CloudFrontOriginAccessIdentityAlreadyExists")?;
        if let Some(inner_143) = &self.message {
            {
                write!(f, ": {}", inner_143)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for CloudFrontOriginAccessIdentityAlreadyExists {}
impl aws_http::request_id::RequestId for crate::error::CloudFrontOriginAccessIdentityAlreadyExists {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for CloudFrontOriginAccessIdentityAlreadyExists
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type CreateCachePolicyErrorKind = CreateCachePolicyError;
/// Error type for the `CreateCachePolicyError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateCachePolicyError {
    /// <p>Access denied.</p>
    AccessDenied(crate::error::AccessDenied),
    /// <p>A cache policy with this name already exists. You must provide a unique name. To modify an existing cache policy, use <code>UpdateCachePolicy</code>.</p>
    CachePolicyAlreadyExists(crate::error::CachePolicyAlreadyExists),
    /// <p>The value of <code>Quantity</code> and the size of <code>Items</code> don't match.</p>
    InconsistentQuantities(crate::error::InconsistentQuantities),
    /// <p>An argument is invalid.</p>
    InvalidArgument(crate::error::InvalidArgument),
    /// <p>You have reached the maximum number of cache policies for this Amazon Web Services account. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
    TooManyCachePolicies(crate::error::TooManyCachePolicies),
    /// <p>The number of cookies in the cache policy exceeds the maximum. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
    TooManyCookiesInCachePolicy(crate::error::TooManyCookiesInCachePolicy),
    /// <p>The number of headers in the cache policy exceeds the maximum. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
    TooManyHeadersInCachePolicy(crate::error::TooManyHeadersInCachePolicy),
    /// <p>The number of query strings in the cache policy exceeds the maximum. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
    TooManyQueryStringsInCachePolicy(crate::error::TooManyQueryStringsInCachePolicy),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for CreateCachePolicyError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for CreateCachePolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AccessDenied(_inner) => _inner.fmt(f),
            Self::CachePolicyAlreadyExists(_inner) => _inner.fmt(f),
            Self::InconsistentQuantities(_inner) => _inner.fmt(f),
            Self::InvalidArgument(_inner) => _inner.fmt(f),
            Self::TooManyCachePolicies(_inner) => _inner.fmt(f),
            Self::TooManyCookiesInCachePolicy(_inner) => _inner.fmt(f),
            Self::TooManyHeadersInCachePolicy(_inner) => _inner.fmt(f),
            Self::TooManyQueryStringsInCachePolicy(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CreateCachePolicyError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AccessDenied(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::CachePolicyAlreadyExists(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InconsistentQuantities(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidArgument(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyCachePolicies(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyCookiesInCachePolicy(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyHeadersInCachePolicy(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyQueryStringsInCachePolicy(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::CreateCachePolicyError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateCachePolicyError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateCachePolicyError {
    /// Creates the `CreateCachePolicyError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `CreateCachePolicyError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AccessDenied(e) => e.meta(),
            Self::CachePolicyAlreadyExists(e) => e.meta(),
            Self::InconsistentQuantities(e) => e.meta(),
            Self::InvalidArgument(e) => e.meta(),
            Self::TooManyCachePolicies(e) => e.meta(),
            Self::TooManyCookiesInCachePolicy(e) => e.meta(),
            Self::TooManyHeadersInCachePolicy(e) => e.meta(),
            Self::TooManyQueryStringsInCachePolicy(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `CreateCachePolicyError::AccessDenied`.
    pub fn is_access_denied(&self) -> bool {
        matches!(self, Self::AccessDenied(_))
    }
    /// Returns `true` if the error kind is `CreateCachePolicyError::CachePolicyAlreadyExists`.
    pub fn is_cache_policy_already_exists(&self) -> bool {
        matches!(self, Self::CachePolicyAlreadyExists(_))
    }
    /// Returns `true` if the error kind is `CreateCachePolicyError::InconsistentQuantities`.
    pub fn is_inconsistent_quantities(&self) -> bool {
        matches!(self, Self::InconsistentQuantities(_))
    }
    /// Returns `true` if the error kind is `CreateCachePolicyError::InvalidArgument`.
    pub fn is_invalid_argument(&self) -> bool {
        matches!(self, Self::InvalidArgument(_))
    }
    /// Returns `true` if the error kind is `CreateCachePolicyError::TooManyCachePolicies`.
    pub fn is_too_many_cache_policies(&self) -> bool {
        matches!(self, Self::TooManyCachePolicies(_))
    }
    /// Returns `true` if the error kind is `CreateCachePolicyError::TooManyCookiesInCachePolicy`.
    pub fn is_too_many_cookies_in_cache_policy(&self) -> bool {
        matches!(self, Self::TooManyCookiesInCachePolicy(_))
    }
    /// Returns `true` if the error kind is `CreateCachePolicyError::TooManyHeadersInCachePolicy`.
    pub fn is_too_many_headers_in_cache_policy(&self) -> bool {
        matches!(self, Self::TooManyHeadersInCachePolicy(_))
    }
    /// Returns `true` if the error kind is `CreateCachePolicyError::TooManyQueryStringsInCachePolicy`.
    pub fn is_too_many_query_strings_in_cache_policy(&self) -> bool {
        matches!(self, Self::TooManyQueryStringsInCachePolicy(_))
    }
}
impl std::error::Error for CreateCachePolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AccessDenied(_inner) => Some(_inner),
            Self::CachePolicyAlreadyExists(_inner) => Some(_inner),
            Self::InconsistentQuantities(_inner) => Some(_inner),
            Self::InvalidArgument(_inner) => Some(_inner),
            Self::TooManyCachePolicies(_inner) => Some(_inner),
            Self::TooManyCookiesInCachePolicy(_inner) => Some(_inner),
            Self::TooManyHeadersInCachePolicy(_inner) => Some(_inner),
            Self::TooManyQueryStringsInCachePolicy(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>You have reached the maximum number of cache policies for this Amazon Web Services account. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TooManyCachePolicies {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl TooManyCachePolicies {
    /// Creates a new builder-style object to manufacture [`TooManyCachePolicies`](crate::error::TooManyCachePolicies).
    pub fn builder() -> crate::error::too_many_cache_policies::Builder {
        crate::error::too_many_cache_policies::Builder::default()
    }
}
/// See [`TooManyCachePolicies`](crate::error::TooManyCachePolicies).
pub mod too_many_cache_policies {

    /// A builder for [`TooManyCachePolicies`](crate::error::TooManyCachePolicies).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`TooManyCachePolicies`](crate::error::TooManyCachePolicies).
        pub fn build(self) -> crate::error::TooManyCachePolicies {
            crate::error::TooManyCachePolicies {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl TooManyCachePolicies {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TooManyCachePolicies {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TooManyCachePolicies")?;
        if let Some(inner_144) = &self.message {
            {
                write!(f, ": {}", inner_144)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for TooManyCachePolicies {}
impl aws_http::request_id::RequestId for crate::error::TooManyCachePolicies {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for TooManyCachePolicies {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type CopyDistributionErrorKind = CopyDistributionError;
/// Error type for the `CopyDistributionError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CopyDistributionError {
    /// <p>Access denied.</p>
    AccessDenied(crate::error::AccessDenied),
    /// <p>The CNAME specified is already defined for CloudFront.</p>
    CnameAlreadyExists(crate::error::CnameAlreadyExists),
    /// <p>The caller reference you attempted to create the distribution with is associated with another distribution.</p>
    DistributionAlreadyExists(crate::error::DistributionAlreadyExists),
    /// <p>The specified configuration for field-level encryption can't be associated with the specified cache behavior.</p>
    IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior(
        crate::error::IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior,
    ),
    /// <p>The value of <code>Quantity</code> and the size of <code>Items</code> don't match.</p>
    InconsistentQuantities(crate::error::InconsistentQuantities),
    /// <p>An argument is invalid.</p>
    InvalidArgument(crate::error::InvalidArgument),
    /// <p>The default root object file name is too big or contains an invalid character.</p>
    InvalidDefaultRootObject(crate::error::InvalidDefaultRootObject),
    /// <p>An invalid error code was specified.</p>
    InvalidErrorCode(crate::error::InvalidErrorCode),
    /// <p>Your request contains forward cookies option which doesn't match with the expectation for the <code>whitelisted</code> list of cookie names. Either list of cookie names has been specified when not allowed or list of cookie names is missing when expected.</p>
    InvalidForwardCookies(crate::error::InvalidForwardCookies),
    /// <p>A CloudFront function association is invalid.</p>
    InvalidFunctionAssociation(crate::error::InvalidFunctionAssociation),
    /// <p>The specified geo restriction parameter is not valid.</p>
    InvalidGeoRestrictionParameter(crate::error::InvalidGeoRestrictionParameter),
    /// <p>The headers specified are not valid for an Amazon S3 origin.</p>
    InvalidHeadersForS3Origin(crate::error::InvalidHeadersForS3Origin),
    /// <p>The <code>If-Match</code> version is missing or not valid.</p>
    InvalidIfMatchVersion(crate::error::InvalidIfMatchVersion),
    /// <p>The specified Lambda@Edge function association is invalid.</p>
    InvalidLambdaFunctionAssociation(crate::error::InvalidLambdaFunctionAssociation),
    /// <p>The location code specified is not valid.</p>
    InvalidLocationCode(crate::error::InvalidLocationCode),
    /// <p>The minimum protocol version specified is not valid.</p>
    InvalidMinimumProtocolVersion(crate::error::InvalidMinimumProtocolVersion),
    /// <p>The Amazon S3 origin server specified does not refer to a valid Amazon S3 bucket.</p>
    InvalidOrigin(crate::error::InvalidOrigin),
    /// <p>The origin access control is not valid.</p>
    InvalidOriginAccessControl(crate::error::InvalidOriginAccessControl),
    /// <p>The origin access identity is not valid or doesn't exist.</p>
    InvalidOriginAccessIdentity(crate::error::InvalidOriginAccessIdentity),
    /// <p>The keep alive timeout specified for the origin is not valid.</p>
    InvalidOriginKeepaliveTimeout(crate::error::InvalidOriginKeepaliveTimeout),
    /// <p>The read timeout specified for the origin is not valid.</p>
    InvalidOriginReadTimeout(crate::error::InvalidOriginReadTimeout),
    /// <p>You cannot specify SSLv3 as the minimum protocol version if you only want to support only clients that support Server Name Indication (SNI).</p>
    InvalidProtocolSettings(crate::error::InvalidProtocolSettings),
    /// <p>The query string parameters specified are not valid.</p>
    InvalidQueryStringParameters(crate::error::InvalidQueryStringParameters),
    /// <p>The relative path is too big, is not URL-encoded, or does not begin with a slash (/).</p>
    InvalidRelativePath(crate::error::InvalidRelativePath),
    /// <p>This operation requires the HTTPS protocol. Ensure that you specify the HTTPS protocol in your request, or omit the <code>RequiredProtocols</code> element from your distribution configuration.</p>
    InvalidRequiredProtocol(crate::error::InvalidRequiredProtocol),
    /// <p>A response code is not valid.</p>
    InvalidResponseCode(crate::error::InvalidResponseCode),
    /// <p>The TTL order specified is not valid.</p>
    InvalidTtlOrder(crate::error::InvalidTtlOrder),
    /// <p>A viewer certificate specified is not valid.</p>
    InvalidViewerCertificate(crate::error::InvalidViewerCertificate),
    /// <p>A web ACL ID specified is not valid. To specify a web ACL created using the latest version of WAF, use the ACL ARN, for example <code>arn:aws:wafv2:us-east-1:123456789012:global/webacl/ExampleWebACL/473e64fd-f30b-4765-81a0-62ad96dd167a</code>. To specify a web ACL created using WAF Classic, use the ACL ID, for example <code>473e64fd-f30b-4765-81a0-62ad96dd167a</code>.</p>
    InvalidWebAclId(crate::error::InvalidWebAclId),
    /// <p>This operation requires a body. Ensure that the body is present and the <code>Content-Type</code> header is set.</p>
    MissingBody(crate::error::MissingBody),
    /// <p>The cache policy does not exist.</p>
    NoSuchCachePolicy(crate::error::NoSuchCachePolicy),
    /// <p>The specified distribution does not exist.</p>
    NoSuchDistribution(crate::error::NoSuchDistribution),
    /// <p>The specified configuration for field-level encryption doesn't exist.</p>
    NoSuchFieldLevelEncryptionConfig(crate::error::NoSuchFieldLevelEncryptionConfig),
    /// <p>No origin exists with the specified <code>Origin Id</code>.</p>
    NoSuchOrigin(crate::error::NoSuchOrigin),
    /// <p>The origin request policy does not exist.</p>
    NoSuchOriginRequestPolicy(crate::error::NoSuchOriginRequestPolicy),
    /// <p>The real-time log configuration does not exist.</p>
    NoSuchRealtimeLogConfig(crate::error::NoSuchRealtimeLogConfig),
    /// <p>The response headers policy does not exist.</p>
    NoSuchResponseHeadersPolicy(crate::error::NoSuchResponseHeadersPolicy),
    /// <p>The precondition in one or more of the request fields evaluated to <code>false</code>.</p>
    PreconditionFailed(crate::error::PreconditionFailed),
    /// <p>The specified real-time log configuration belongs to a different Amazon Web Services account.</p>
    RealtimeLogConfigOwnerMismatch(crate::error::RealtimeLogConfigOwnerMismatch),
    /// <p>You cannot create more cache behaviors for the distribution.</p>
    TooManyCacheBehaviors(crate::error::TooManyCacheBehaviors),
    /// <p>You cannot create anymore custom SSL/TLS certificates.</p>
    TooManyCertificates(crate::error::TooManyCertificates),
    /// <p>Your request contains more cookie names in the whitelist than are allowed per cache behavior.</p>
    TooManyCookieNamesInWhiteList(crate::error::TooManyCookieNamesInWhiteList),
    /// <p>Your request contains more CNAMEs than are allowed per distribution.</p>
    TooManyDistributionCnamEs(crate::error::TooManyDistributionCnamEs),
    /// <p>Processing your request would cause you to exceed the maximum number of distributions allowed.</p>
    TooManyDistributions(crate::error::TooManyDistributions),
    /// <p>The maximum number of distributions have been associated with the specified cache policy. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
    TooManyDistributionsAssociatedToCachePolicy(
        crate::error::TooManyDistributionsAssociatedToCachePolicy,
    ),
    /// <p>The maximum number of distributions have been associated with the specified configuration for field-level encryption.</p>
    TooManyDistributionsAssociatedToFieldLevelEncryptionConfig(
        crate::error::TooManyDistributionsAssociatedToFieldLevelEncryptionConfig,
    ),
    /// <p>The number of distributions that reference this key group is more than the maximum allowed. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
    TooManyDistributionsAssociatedToKeyGroup(
        crate::error::TooManyDistributionsAssociatedToKeyGroup,
    ),
    /// <p>The maximum number of distributions have been associated with the specified origin request policy. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
    TooManyDistributionsAssociatedToOriginRequestPolicy(
        crate::error::TooManyDistributionsAssociatedToOriginRequestPolicy,
    ),
    /// <p>The maximum number of distributions have been associated with the specified response headers policy.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
    TooManyDistributionsAssociatedToResponseHeadersPolicy(
        crate::error::TooManyDistributionsAssociatedToResponseHeadersPolicy,
    ),
    /// <p>You have reached the maximum number of distributions that are associated with a CloudFront function. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
    TooManyDistributionsWithFunctionAssociations(
        crate::error::TooManyDistributionsWithFunctionAssociations,
    ),
    /// <p>Processing your request would cause the maximum number of distributions with Lambda@Edge function associations per owner to be exceeded.</p>
    TooManyDistributionsWithLambdaAssociations(
        crate::error::TooManyDistributionsWithLambdaAssociations,
    ),
    /// <p>The maximum number of distributions have been associated with the specified Lambda@Edge function.</p>
    TooManyDistributionsWithSingleFunctionArn(
        crate::error::TooManyDistributionsWithSingleFunctionArn,
    ),
    /// <p>You have reached the maximum number of CloudFront function associations for this distribution. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
    TooManyFunctionAssociations(crate::error::TooManyFunctionAssociations),
    /// <p>Your request contains too many headers in forwarded values.</p>
    TooManyHeadersInForwardedValues(crate::error::TooManyHeadersInForwardedValues),
    /// <p>The number of key groups referenced by this distribution is more than the maximum allowed. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
    TooManyKeyGroupsAssociatedToDistribution(
        crate::error::TooManyKeyGroupsAssociatedToDistribution,
    ),
    /// <p>Your request contains more Lambda@Edge function associations than are allowed per distribution.</p>
    TooManyLambdaFunctionAssociations(crate::error::TooManyLambdaFunctionAssociations),
    /// <p>Your request contains too many origin custom headers.</p>
    TooManyOriginCustomHeaders(crate::error::TooManyOriginCustomHeaders),
    /// <p>Processing your request would cause you to exceed the maximum number of origin groups allowed.</p>
    TooManyOriginGroupsPerDistribution(crate::error::TooManyOriginGroupsPerDistribution),
    /// <p>You cannot create more origins for the distribution.</p>
    TooManyOrigins(crate::error::TooManyOrigins),
    /// <p>Your request contains too many query string parameters.</p>
    TooManyQueryStringParameters(crate::error::TooManyQueryStringParameters),
    /// <p>Your request contains more trusted signers than are allowed per distribution.</p>
    TooManyTrustedSigners(crate::error::TooManyTrustedSigners),
    /// <p>The specified key group does not exist.</p>
    TrustedKeyGroupDoesNotExist(crate::error::TrustedKeyGroupDoesNotExist),
    /// <p>One or more of your trusted signers don't exist.</p>
    TrustedSignerDoesNotExist(crate::error::TrustedSignerDoesNotExist),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for CopyDistributionError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for CopyDistributionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AccessDenied(_inner) => _inner.fmt(f),
            Self::CnameAlreadyExists(_inner) => _inner.fmt(f),
            Self::DistributionAlreadyExists(_inner) => _inner.fmt(f),
            Self::IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior(_inner) => {
                _inner.fmt(f)
            }
            Self::InconsistentQuantities(_inner) => _inner.fmt(f),
            Self::InvalidArgument(_inner) => _inner.fmt(f),
            Self::InvalidDefaultRootObject(_inner) => _inner.fmt(f),
            Self::InvalidErrorCode(_inner) => _inner.fmt(f),
            Self::InvalidForwardCookies(_inner) => _inner.fmt(f),
            Self::InvalidFunctionAssociation(_inner) => _inner.fmt(f),
            Self::InvalidGeoRestrictionParameter(_inner) => _inner.fmt(f),
            Self::InvalidHeadersForS3Origin(_inner) => _inner.fmt(f),
            Self::InvalidIfMatchVersion(_inner) => _inner.fmt(f),
            Self::InvalidLambdaFunctionAssociation(_inner) => _inner.fmt(f),
            Self::InvalidLocationCode(_inner) => _inner.fmt(f),
            Self::InvalidMinimumProtocolVersion(_inner) => _inner.fmt(f),
            Self::InvalidOrigin(_inner) => _inner.fmt(f),
            Self::InvalidOriginAccessControl(_inner) => _inner.fmt(f),
            Self::InvalidOriginAccessIdentity(_inner) => _inner.fmt(f),
            Self::InvalidOriginKeepaliveTimeout(_inner) => _inner.fmt(f),
            Self::InvalidOriginReadTimeout(_inner) => _inner.fmt(f),
            Self::InvalidProtocolSettings(_inner) => _inner.fmt(f),
            Self::InvalidQueryStringParameters(_inner) => _inner.fmt(f),
            Self::InvalidRelativePath(_inner) => _inner.fmt(f),
            Self::InvalidRequiredProtocol(_inner) => _inner.fmt(f),
            Self::InvalidResponseCode(_inner) => _inner.fmt(f),
            Self::InvalidTtlOrder(_inner) => _inner.fmt(f),
            Self::InvalidViewerCertificate(_inner) => _inner.fmt(f),
            Self::InvalidWebAclId(_inner) => _inner.fmt(f),
            Self::MissingBody(_inner) => _inner.fmt(f),
            Self::NoSuchCachePolicy(_inner) => _inner.fmt(f),
            Self::NoSuchDistribution(_inner) => _inner.fmt(f),
            Self::NoSuchFieldLevelEncryptionConfig(_inner) => _inner.fmt(f),
            Self::NoSuchOrigin(_inner) => _inner.fmt(f),
            Self::NoSuchOriginRequestPolicy(_inner) => _inner.fmt(f),
            Self::NoSuchRealtimeLogConfig(_inner) => _inner.fmt(f),
            Self::NoSuchResponseHeadersPolicy(_inner) => _inner.fmt(f),
            Self::PreconditionFailed(_inner) => _inner.fmt(f),
            Self::RealtimeLogConfigOwnerMismatch(_inner) => _inner.fmt(f),
            Self::TooManyCacheBehaviors(_inner) => _inner.fmt(f),
            Self::TooManyCertificates(_inner) => _inner.fmt(f),
            Self::TooManyCookieNamesInWhiteList(_inner) => _inner.fmt(f),
            Self::TooManyDistributionCnamEs(_inner) => _inner.fmt(f),
            Self::TooManyDistributions(_inner) => _inner.fmt(f),
            Self::TooManyDistributionsAssociatedToCachePolicy(_inner) => _inner.fmt(f),
            Self::TooManyDistributionsAssociatedToFieldLevelEncryptionConfig(_inner) => {
                _inner.fmt(f)
            }
            Self::TooManyDistributionsAssociatedToKeyGroup(_inner) => _inner.fmt(f),
            Self::TooManyDistributionsAssociatedToOriginRequestPolicy(_inner) => _inner.fmt(f),
            Self::TooManyDistributionsAssociatedToResponseHeadersPolicy(_inner) => _inner.fmt(f),
            Self::TooManyDistributionsWithFunctionAssociations(_inner) => _inner.fmt(f),
            Self::TooManyDistributionsWithLambdaAssociations(_inner) => _inner.fmt(f),
            Self::TooManyDistributionsWithSingleFunctionArn(_inner) => _inner.fmt(f),
            Self::TooManyFunctionAssociations(_inner) => _inner.fmt(f),
            Self::TooManyHeadersInForwardedValues(_inner) => _inner.fmt(f),
            Self::TooManyKeyGroupsAssociatedToDistribution(_inner) => _inner.fmt(f),
            Self::TooManyLambdaFunctionAssociations(_inner) => _inner.fmt(f),
            Self::TooManyOriginCustomHeaders(_inner) => _inner.fmt(f),
            Self::TooManyOriginGroupsPerDistribution(_inner) => _inner.fmt(f),
            Self::TooManyOrigins(_inner) => _inner.fmt(f),
            Self::TooManyQueryStringParameters(_inner) => _inner.fmt(f),
            Self::TooManyTrustedSigners(_inner) => _inner.fmt(f),
            Self::TrustedKeyGroupDoesNotExist(_inner) => _inner.fmt(f),
            Self::TrustedSignerDoesNotExist(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CopyDistributionError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AccessDenied(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::CnameAlreadyExists(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DistributionAlreadyExists(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InconsistentQuantities(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidArgument(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidDefaultRootObject(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidErrorCode(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidForwardCookies(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidFunctionAssociation(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidGeoRestrictionParameter(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidHeadersForS3Origin(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidIfMatchVersion(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidLambdaFunctionAssociation(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidLocationCode(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidMinimumProtocolVersion(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidOrigin(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidOriginAccessControl(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidOriginAccessIdentity(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidOriginKeepaliveTimeout(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidOriginReadTimeout(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidProtocolSettings(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidQueryStringParameters(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidRelativePath(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidRequiredProtocol(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidResponseCode(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidTtlOrder(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidViewerCertificate(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidWebAclId(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::MissingBody(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NoSuchCachePolicy(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NoSuchDistribution(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NoSuchFieldLevelEncryptionConfig(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NoSuchOrigin(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NoSuchOriginRequestPolicy(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NoSuchRealtimeLogConfig(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NoSuchResponseHeadersPolicy(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::PreconditionFailed(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RealtimeLogConfigOwnerMismatch(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyCacheBehaviors(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyCertificates(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyCookieNamesInWhiteList(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyDistributionCnamEs(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyDistributions(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyDistributionsAssociatedToCachePolicy(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyDistributionsAssociatedToFieldLevelEncryptionConfig(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyDistributionsAssociatedToKeyGroup(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyDistributionsAssociatedToOriginRequestPolicy(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyDistributionsAssociatedToResponseHeadersPolicy(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyDistributionsWithFunctionAssociations(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyDistributionsWithLambdaAssociations(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyDistributionsWithSingleFunctionArn(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyFunctionAssociations(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyHeadersInForwardedValues(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyKeyGroupsAssociatedToDistribution(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyLambdaFunctionAssociations(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyOriginCustomHeaders(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyOriginGroupsPerDistribution(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyOrigins(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyQueryStringParameters(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyTrustedSigners(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TrustedKeyGroupDoesNotExist(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TrustedSignerDoesNotExist(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::CopyDistributionError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CopyDistributionError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CopyDistributionError {
    /// Creates the `CopyDistributionError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `CopyDistributionError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AccessDenied(e) => e.meta(),
            Self::CnameAlreadyExists(e) => e.meta(),
            Self::DistributionAlreadyExists(e) => e.meta(),
            Self::IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior(e) => e.meta(),
            Self::InconsistentQuantities(e) => e.meta(),
            Self::InvalidArgument(e) => e.meta(),
            Self::InvalidDefaultRootObject(e) => e.meta(),
            Self::InvalidErrorCode(e) => e.meta(),
            Self::InvalidForwardCookies(e) => e.meta(),
            Self::InvalidFunctionAssociation(e) => e.meta(),
            Self::InvalidGeoRestrictionParameter(e) => e.meta(),
            Self::InvalidHeadersForS3Origin(e) => e.meta(),
            Self::InvalidIfMatchVersion(e) => e.meta(),
            Self::InvalidLambdaFunctionAssociation(e) => e.meta(),
            Self::InvalidLocationCode(e) => e.meta(),
            Self::InvalidMinimumProtocolVersion(e) => e.meta(),
            Self::InvalidOrigin(e) => e.meta(),
            Self::InvalidOriginAccessControl(e) => e.meta(),
            Self::InvalidOriginAccessIdentity(e) => e.meta(),
            Self::InvalidOriginKeepaliveTimeout(e) => e.meta(),
            Self::InvalidOriginReadTimeout(e) => e.meta(),
            Self::InvalidProtocolSettings(e) => e.meta(),
            Self::InvalidQueryStringParameters(e) => e.meta(),
            Self::InvalidRelativePath(e) => e.meta(),
            Self::InvalidRequiredProtocol(e) => e.meta(),
            Self::InvalidResponseCode(e) => e.meta(),
            Self::InvalidTtlOrder(e) => e.meta(),
            Self::InvalidViewerCertificate(e) => e.meta(),
            Self::InvalidWebAclId(e) => e.meta(),
            Self::MissingBody(e) => e.meta(),
            Self::NoSuchCachePolicy(e) => e.meta(),
            Self::NoSuchDistribution(e) => e.meta(),
            Self::NoSuchFieldLevelEncryptionConfig(e) => e.meta(),
            Self::NoSuchOrigin(e) => e.meta(),
            Self::NoSuchOriginRequestPolicy(e) => e.meta(),
            Self::NoSuchRealtimeLogConfig(e) => e.meta(),
            Self::NoSuchResponseHeadersPolicy(e) => e.meta(),
            Self::PreconditionFailed(e) => e.meta(),
            Self::RealtimeLogConfigOwnerMismatch(e) => e.meta(),
            Self::TooManyCacheBehaviors(e) => e.meta(),
            Self::TooManyCertificates(e) => e.meta(),
            Self::TooManyCookieNamesInWhiteList(e) => e.meta(),
            Self::TooManyDistributionCnamEs(e) => e.meta(),
            Self::TooManyDistributions(e) => e.meta(),
            Self::TooManyDistributionsAssociatedToCachePolicy(e) => e.meta(),
            Self::TooManyDistributionsAssociatedToFieldLevelEncryptionConfig(e) => e.meta(),
            Self::TooManyDistributionsAssociatedToKeyGroup(e) => e.meta(),
            Self::TooManyDistributionsAssociatedToOriginRequestPolicy(e) => e.meta(),
            Self::TooManyDistributionsAssociatedToResponseHeadersPolicy(e) => e.meta(),
            Self::TooManyDistributionsWithFunctionAssociations(e) => e.meta(),
            Self::TooManyDistributionsWithLambdaAssociations(e) => e.meta(),
            Self::TooManyDistributionsWithSingleFunctionArn(e) => e.meta(),
            Self::TooManyFunctionAssociations(e) => e.meta(),
            Self::TooManyHeadersInForwardedValues(e) => e.meta(),
            Self::TooManyKeyGroupsAssociatedToDistribution(e) => e.meta(),
            Self::TooManyLambdaFunctionAssociations(e) => e.meta(),
            Self::TooManyOriginCustomHeaders(e) => e.meta(),
            Self::TooManyOriginGroupsPerDistribution(e) => e.meta(),
            Self::TooManyOrigins(e) => e.meta(),
            Self::TooManyQueryStringParameters(e) => e.meta(),
            Self::TooManyTrustedSigners(e) => e.meta(),
            Self::TrustedKeyGroupDoesNotExist(e) => e.meta(),
            Self::TrustedSignerDoesNotExist(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `CopyDistributionError::AccessDenied`.
    pub fn is_access_denied(&self) -> bool {
        matches!(self, Self::AccessDenied(_))
    }
    /// Returns `true` if the error kind is `CopyDistributionError::CnameAlreadyExists`.
    pub fn is_cname_already_exists(&self) -> bool {
        matches!(self, Self::CnameAlreadyExists(_))
    }
    /// Returns `true` if the error kind is `CopyDistributionError::DistributionAlreadyExists`.
    pub fn is_distribution_already_exists(&self) -> bool {
        matches!(self, Self::DistributionAlreadyExists(_))
    }
    /// Returns `true` if the error kind is `CopyDistributionError::IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior`.
    pub fn is_illegal_field_level_encryption_config_association_with_cache_behavior(&self) -> bool {
        matches!(
            self,
            Self::IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior(_)
        )
    }
    /// Returns `true` if the error kind is `CopyDistributionError::InconsistentQuantities`.
    pub fn is_inconsistent_quantities(&self) -> bool {
        matches!(self, Self::InconsistentQuantities(_))
    }
    /// Returns `true` if the error kind is `CopyDistributionError::InvalidArgument`.
    pub fn is_invalid_argument(&self) -> bool {
        matches!(self, Self::InvalidArgument(_))
    }
    /// Returns `true` if the error kind is `CopyDistributionError::InvalidDefaultRootObject`.
    pub fn is_invalid_default_root_object(&self) -> bool {
        matches!(self, Self::InvalidDefaultRootObject(_))
    }
    /// Returns `true` if the error kind is `CopyDistributionError::InvalidErrorCode`.
    pub fn is_invalid_error_code(&self) -> bool {
        matches!(self, Self::InvalidErrorCode(_))
    }
    /// Returns `true` if the error kind is `CopyDistributionError::InvalidForwardCookies`.
    pub fn is_invalid_forward_cookies(&self) -> bool {
        matches!(self, Self::InvalidForwardCookies(_))
    }
    /// Returns `true` if the error kind is `CopyDistributionError::InvalidFunctionAssociation`.
    pub fn is_invalid_function_association(&self) -> bool {
        matches!(self, Self::InvalidFunctionAssociation(_))
    }
    /// Returns `true` if the error kind is `CopyDistributionError::InvalidGeoRestrictionParameter`.
    pub fn is_invalid_geo_restriction_parameter(&self) -> bool {
        matches!(self, Self::InvalidGeoRestrictionParameter(_))
    }
    /// Returns `true` if the error kind is `CopyDistributionError::InvalidHeadersForS3Origin`.
    pub fn is_invalid_headers_for_s3_origin(&self) -> bool {
        matches!(self, Self::InvalidHeadersForS3Origin(_))
    }
    /// Returns `true` if the error kind is `CopyDistributionError::InvalidIfMatchVersion`.
    pub fn is_invalid_if_match_version(&self) -> bool {
        matches!(self, Self::InvalidIfMatchVersion(_))
    }
    /// Returns `true` if the error kind is `CopyDistributionError::InvalidLambdaFunctionAssociation`.
    pub fn is_invalid_lambda_function_association(&self) -> bool {
        matches!(self, Self::InvalidLambdaFunctionAssociation(_))
    }
    /// Returns `true` if the error kind is `CopyDistributionError::InvalidLocationCode`.
    pub fn is_invalid_location_code(&self) -> bool {
        matches!(self, Self::InvalidLocationCode(_))
    }
    /// Returns `true` if the error kind is `CopyDistributionError::InvalidMinimumProtocolVersion`.
    pub fn is_invalid_minimum_protocol_version(&self) -> bool {
        matches!(self, Self::InvalidMinimumProtocolVersion(_))
    }
    /// Returns `true` if the error kind is `CopyDistributionError::InvalidOrigin`.
    pub fn is_invalid_origin(&self) -> bool {
        matches!(self, Self::InvalidOrigin(_))
    }
    /// Returns `true` if the error kind is `CopyDistributionError::InvalidOriginAccessControl`.
    pub fn is_invalid_origin_access_control(&self) -> bool {
        matches!(self, Self::InvalidOriginAccessControl(_))
    }
    /// Returns `true` if the error kind is `CopyDistributionError::InvalidOriginAccessIdentity`.
    pub fn is_invalid_origin_access_identity(&self) -> bool {
        matches!(self, Self::InvalidOriginAccessIdentity(_))
    }
    /// Returns `true` if the error kind is `CopyDistributionError::InvalidOriginKeepaliveTimeout`.
    pub fn is_invalid_origin_keepalive_timeout(&self) -> bool {
        matches!(self, Self::InvalidOriginKeepaliveTimeout(_))
    }
    /// Returns `true` if the error kind is `CopyDistributionError::InvalidOriginReadTimeout`.
    pub fn is_invalid_origin_read_timeout(&self) -> bool {
        matches!(self, Self::InvalidOriginReadTimeout(_))
    }
    /// Returns `true` if the error kind is `CopyDistributionError::InvalidProtocolSettings`.
    pub fn is_invalid_protocol_settings(&self) -> bool {
        matches!(self, Self::InvalidProtocolSettings(_))
    }
    /// Returns `true` if the error kind is `CopyDistributionError::InvalidQueryStringParameters`.
    pub fn is_invalid_query_string_parameters(&self) -> bool {
        matches!(self, Self::InvalidQueryStringParameters(_))
    }
    /// Returns `true` if the error kind is `CopyDistributionError::InvalidRelativePath`.
    pub fn is_invalid_relative_path(&self) -> bool {
        matches!(self, Self::InvalidRelativePath(_))
    }
    /// Returns `true` if the error kind is `CopyDistributionError::InvalidRequiredProtocol`.
    pub fn is_invalid_required_protocol(&self) -> bool {
        matches!(self, Self::InvalidRequiredProtocol(_))
    }
    /// Returns `true` if the error kind is `CopyDistributionError::InvalidResponseCode`.
    pub fn is_invalid_response_code(&self) -> bool {
        matches!(self, Self::InvalidResponseCode(_))
    }
    /// Returns `true` if the error kind is `CopyDistributionError::InvalidTtlOrder`.
    pub fn is_invalid_ttl_order(&self) -> bool {
        matches!(self, Self::InvalidTtlOrder(_))
    }
    /// Returns `true` if the error kind is `CopyDistributionError::InvalidViewerCertificate`.
    pub fn is_invalid_viewer_certificate(&self) -> bool {
        matches!(self, Self::InvalidViewerCertificate(_))
    }
    /// Returns `true` if the error kind is `CopyDistributionError::InvalidWebAclId`.
    pub fn is_invalid_web_acl_id(&self) -> bool {
        matches!(self, Self::InvalidWebAclId(_))
    }
    /// Returns `true` if the error kind is `CopyDistributionError::MissingBody`.
    pub fn is_missing_body(&self) -> bool {
        matches!(self, Self::MissingBody(_))
    }
    /// Returns `true` if the error kind is `CopyDistributionError::NoSuchCachePolicy`.
    pub fn is_no_such_cache_policy(&self) -> bool {
        matches!(self, Self::NoSuchCachePolicy(_))
    }
    /// Returns `true` if the error kind is `CopyDistributionError::NoSuchDistribution`.
    pub fn is_no_such_distribution(&self) -> bool {
        matches!(self, Self::NoSuchDistribution(_))
    }
    /// Returns `true` if the error kind is `CopyDistributionError::NoSuchFieldLevelEncryptionConfig`.
    pub fn is_no_such_field_level_encryption_config(&self) -> bool {
        matches!(self, Self::NoSuchFieldLevelEncryptionConfig(_))
    }
    /// Returns `true` if the error kind is `CopyDistributionError::NoSuchOrigin`.
    pub fn is_no_such_origin(&self) -> bool {
        matches!(self, Self::NoSuchOrigin(_))
    }
    /// Returns `true` if the error kind is `CopyDistributionError::NoSuchOriginRequestPolicy`.
    pub fn is_no_such_origin_request_policy(&self) -> bool {
        matches!(self, Self::NoSuchOriginRequestPolicy(_))
    }
    /// Returns `true` if the error kind is `CopyDistributionError::NoSuchRealtimeLogConfig`.
    pub fn is_no_such_realtime_log_config(&self) -> bool {
        matches!(self, Self::NoSuchRealtimeLogConfig(_))
    }
    /// Returns `true` if the error kind is `CopyDistributionError::NoSuchResponseHeadersPolicy`.
    pub fn is_no_such_response_headers_policy(&self) -> bool {
        matches!(self, Self::NoSuchResponseHeadersPolicy(_))
    }
    /// Returns `true` if the error kind is `CopyDistributionError::PreconditionFailed`.
    pub fn is_precondition_failed(&self) -> bool {
        matches!(self, Self::PreconditionFailed(_))
    }
    /// Returns `true` if the error kind is `CopyDistributionError::RealtimeLogConfigOwnerMismatch`.
    pub fn is_realtime_log_config_owner_mismatch(&self) -> bool {
        matches!(self, Self::RealtimeLogConfigOwnerMismatch(_))
    }
    /// Returns `true` if the error kind is `CopyDistributionError::TooManyCacheBehaviors`.
    pub fn is_too_many_cache_behaviors(&self) -> bool {
        matches!(self, Self::TooManyCacheBehaviors(_))
    }
    /// Returns `true` if the error kind is `CopyDistributionError::TooManyCertificates`.
    pub fn is_too_many_certificates(&self) -> bool {
        matches!(self, Self::TooManyCertificates(_))
    }
    /// Returns `true` if the error kind is `CopyDistributionError::TooManyCookieNamesInWhiteList`.
    pub fn is_too_many_cookie_names_in_white_list(&self) -> bool {
        matches!(self, Self::TooManyCookieNamesInWhiteList(_))
    }
    /// Returns `true` if the error kind is `CopyDistributionError::TooManyDistributionCnamEs`.
    pub fn is_too_many_distribution_cnam_es(&self) -> bool {
        matches!(self, Self::TooManyDistributionCnamEs(_))
    }
    /// Returns `true` if the error kind is `CopyDistributionError::TooManyDistributions`.
    pub fn is_too_many_distributions(&self) -> bool {
        matches!(self, Self::TooManyDistributions(_))
    }
    /// Returns `true` if the error kind is `CopyDistributionError::TooManyDistributionsAssociatedToCachePolicy`.
    pub fn is_too_many_distributions_associated_to_cache_policy(&self) -> bool {
        matches!(self, Self::TooManyDistributionsAssociatedToCachePolicy(_))
    }
    /// Returns `true` if the error kind is `CopyDistributionError::TooManyDistributionsAssociatedToFieldLevelEncryptionConfig`.
    pub fn is_too_many_distributions_associated_to_field_level_encryption_config(&self) -> bool {
        matches!(
            self,
            Self::TooManyDistributionsAssociatedToFieldLevelEncryptionConfig(_)
        )
    }
    /// Returns `true` if the error kind is `CopyDistributionError::TooManyDistributionsAssociatedToKeyGroup`.
    pub fn is_too_many_distributions_associated_to_key_group(&self) -> bool {
        matches!(self, Self::TooManyDistributionsAssociatedToKeyGroup(_))
    }
    /// Returns `true` if the error kind is `CopyDistributionError::TooManyDistributionsAssociatedToOriginRequestPolicy`.
    pub fn is_too_many_distributions_associated_to_origin_request_policy(&self) -> bool {
        matches!(
            self,
            Self::TooManyDistributionsAssociatedToOriginRequestPolicy(_)
        )
    }
    /// Returns `true` if the error kind is `CopyDistributionError::TooManyDistributionsAssociatedToResponseHeadersPolicy`.
    pub fn is_too_many_distributions_associated_to_response_headers_policy(&self) -> bool {
        matches!(
            self,
            Self::TooManyDistributionsAssociatedToResponseHeadersPolicy(_)
        )
    }
    /// Returns `true` if the error kind is `CopyDistributionError::TooManyDistributionsWithFunctionAssociations`.
    pub fn is_too_many_distributions_with_function_associations(&self) -> bool {
        matches!(self, Self::TooManyDistributionsWithFunctionAssociations(_))
    }
    /// Returns `true` if the error kind is `CopyDistributionError::TooManyDistributionsWithLambdaAssociations`.
    pub fn is_too_many_distributions_with_lambda_associations(&self) -> bool {
        matches!(self, Self::TooManyDistributionsWithLambdaAssociations(_))
    }
    /// Returns `true` if the error kind is `CopyDistributionError::TooManyDistributionsWithSingleFunctionArn`.
    pub fn is_too_many_distributions_with_single_function_arn(&self) -> bool {
        matches!(self, Self::TooManyDistributionsWithSingleFunctionArn(_))
    }
    /// Returns `true` if the error kind is `CopyDistributionError::TooManyFunctionAssociations`.
    pub fn is_too_many_function_associations(&self) -> bool {
        matches!(self, Self::TooManyFunctionAssociations(_))
    }
    /// Returns `true` if the error kind is `CopyDistributionError::TooManyHeadersInForwardedValues`.
    pub fn is_too_many_headers_in_forwarded_values(&self) -> bool {
        matches!(self, Self::TooManyHeadersInForwardedValues(_))
    }
    /// Returns `true` if the error kind is `CopyDistributionError::TooManyKeyGroupsAssociatedToDistribution`.
    pub fn is_too_many_key_groups_associated_to_distribution(&self) -> bool {
        matches!(self, Self::TooManyKeyGroupsAssociatedToDistribution(_))
    }
    /// Returns `true` if the error kind is `CopyDistributionError::TooManyLambdaFunctionAssociations`.
    pub fn is_too_many_lambda_function_associations(&self) -> bool {
        matches!(self, Self::TooManyLambdaFunctionAssociations(_))
    }
    /// Returns `true` if the error kind is `CopyDistributionError::TooManyOriginCustomHeaders`.
    pub fn is_too_many_origin_custom_headers(&self) -> bool {
        matches!(self, Self::TooManyOriginCustomHeaders(_))
    }
    /// Returns `true` if the error kind is `CopyDistributionError::TooManyOriginGroupsPerDistribution`.
    pub fn is_too_many_origin_groups_per_distribution(&self) -> bool {
        matches!(self, Self::TooManyOriginGroupsPerDistribution(_))
    }
    /// Returns `true` if the error kind is `CopyDistributionError::TooManyOrigins`.
    pub fn is_too_many_origins(&self) -> bool {
        matches!(self, Self::TooManyOrigins(_))
    }
    /// Returns `true` if the error kind is `CopyDistributionError::TooManyQueryStringParameters`.
    pub fn is_too_many_query_string_parameters(&self) -> bool {
        matches!(self, Self::TooManyQueryStringParameters(_))
    }
    /// Returns `true` if the error kind is `CopyDistributionError::TooManyTrustedSigners`.
    pub fn is_too_many_trusted_signers(&self) -> bool {
        matches!(self, Self::TooManyTrustedSigners(_))
    }
    /// Returns `true` if the error kind is `CopyDistributionError::TrustedKeyGroupDoesNotExist`.
    pub fn is_trusted_key_group_does_not_exist(&self) -> bool {
        matches!(self, Self::TrustedKeyGroupDoesNotExist(_))
    }
    /// Returns `true` if the error kind is `CopyDistributionError::TrustedSignerDoesNotExist`.
    pub fn is_trusted_signer_does_not_exist(&self) -> bool {
        matches!(self, Self::TrustedSignerDoesNotExist(_))
    }
}
impl std::error::Error for CopyDistributionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AccessDenied(_inner) => Some(_inner),
            Self::CnameAlreadyExists(_inner) => Some(_inner),
            Self::DistributionAlreadyExists(_inner) => Some(_inner),
            Self::IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior(_inner) => {
                Some(_inner)
            }
            Self::InconsistentQuantities(_inner) => Some(_inner),
            Self::InvalidArgument(_inner) => Some(_inner),
            Self::InvalidDefaultRootObject(_inner) => Some(_inner),
            Self::InvalidErrorCode(_inner) => Some(_inner),
            Self::InvalidForwardCookies(_inner) => Some(_inner),
            Self::InvalidFunctionAssociation(_inner) => Some(_inner),
            Self::InvalidGeoRestrictionParameter(_inner) => Some(_inner),
            Self::InvalidHeadersForS3Origin(_inner) => Some(_inner),
            Self::InvalidIfMatchVersion(_inner) => Some(_inner),
            Self::InvalidLambdaFunctionAssociation(_inner) => Some(_inner),
            Self::InvalidLocationCode(_inner) => Some(_inner),
            Self::InvalidMinimumProtocolVersion(_inner) => Some(_inner),
            Self::InvalidOrigin(_inner) => Some(_inner),
            Self::InvalidOriginAccessControl(_inner) => Some(_inner),
            Self::InvalidOriginAccessIdentity(_inner) => Some(_inner),
            Self::InvalidOriginKeepaliveTimeout(_inner) => Some(_inner),
            Self::InvalidOriginReadTimeout(_inner) => Some(_inner),
            Self::InvalidProtocolSettings(_inner) => Some(_inner),
            Self::InvalidQueryStringParameters(_inner) => Some(_inner),
            Self::InvalidRelativePath(_inner) => Some(_inner),
            Self::InvalidRequiredProtocol(_inner) => Some(_inner),
            Self::InvalidResponseCode(_inner) => Some(_inner),
            Self::InvalidTtlOrder(_inner) => Some(_inner),
            Self::InvalidViewerCertificate(_inner) => Some(_inner),
            Self::InvalidWebAclId(_inner) => Some(_inner),
            Self::MissingBody(_inner) => Some(_inner),
            Self::NoSuchCachePolicy(_inner) => Some(_inner),
            Self::NoSuchDistribution(_inner) => Some(_inner),
            Self::NoSuchFieldLevelEncryptionConfig(_inner) => Some(_inner),
            Self::NoSuchOrigin(_inner) => Some(_inner),
            Self::NoSuchOriginRequestPolicy(_inner) => Some(_inner),
            Self::NoSuchRealtimeLogConfig(_inner) => Some(_inner),
            Self::NoSuchResponseHeadersPolicy(_inner) => Some(_inner),
            Self::PreconditionFailed(_inner) => Some(_inner),
            Self::RealtimeLogConfigOwnerMismatch(_inner) => Some(_inner),
            Self::TooManyCacheBehaviors(_inner) => Some(_inner),
            Self::TooManyCertificates(_inner) => Some(_inner),
            Self::TooManyCookieNamesInWhiteList(_inner) => Some(_inner),
            Self::TooManyDistributionCnamEs(_inner) => Some(_inner),
            Self::TooManyDistributions(_inner) => Some(_inner),
            Self::TooManyDistributionsAssociatedToCachePolicy(_inner) => Some(_inner),
            Self::TooManyDistributionsAssociatedToFieldLevelEncryptionConfig(_inner) => {
                Some(_inner)
            }
            Self::TooManyDistributionsAssociatedToKeyGroup(_inner) => Some(_inner),
            Self::TooManyDistributionsAssociatedToOriginRequestPolicy(_inner) => Some(_inner),
            Self::TooManyDistributionsAssociatedToResponseHeadersPolicy(_inner) => Some(_inner),
            Self::TooManyDistributionsWithFunctionAssociations(_inner) => Some(_inner),
            Self::TooManyDistributionsWithLambdaAssociations(_inner) => Some(_inner),
            Self::TooManyDistributionsWithSingleFunctionArn(_inner) => Some(_inner),
            Self::TooManyFunctionAssociations(_inner) => Some(_inner),
            Self::TooManyHeadersInForwardedValues(_inner) => Some(_inner),
            Self::TooManyKeyGroupsAssociatedToDistribution(_inner) => Some(_inner),
            Self::TooManyLambdaFunctionAssociations(_inner) => Some(_inner),
            Self::TooManyOriginCustomHeaders(_inner) => Some(_inner),
            Self::TooManyOriginGroupsPerDistribution(_inner) => Some(_inner),
            Self::TooManyOrigins(_inner) => Some(_inner),
            Self::TooManyQueryStringParameters(_inner) => Some(_inner),
            Self::TooManyTrustedSigners(_inner) => Some(_inner),
            Self::TrustedKeyGroupDoesNotExist(_inner) => Some(_inner),
            Self::TrustedSignerDoesNotExist(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type AssociateAliasErrorKind = AssociateAliasError;
/// Error type for the `AssociateAliasError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AssociateAliasError {
    /// <p>Access denied.</p>
    AccessDenied(crate::error::AccessDenied),
    /// <p>The update contains modifications that are not allowed.</p>
    IllegalUpdate(crate::error::IllegalUpdate),
    /// <p>An argument is invalid.</p>
    InvalidArgument(crate::error::InvalidArgument),
    /// <p>The specified distribution does not exist.</p>
    NoSuchDistribution(crate::error::NoSuchDistribution),
    /// <p>Your request contains more CNAMEs than are allowed per distribution.</p>
    TooManyDistributionCnamEs(crate::error::TooManyDistributionCnamEs),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for AssociateAliasError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for AssociateAliasError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AccessDenied(_inner) => _inner.fmt(f),
            Self::IllegalUpdate(_inner) => _inner.fmt(f),
            Self::InvalidArgument(_inner) => _inner.fmt(f),
            Self::NoSuchDistribution(_inner) => _inner.fmt(f),
            Self::TooManyDistributionCnamEs(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for AssociateAliasError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AccessDenied(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::IllegalUpdate(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidArgument(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NoSuchDistribution(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyDistributionCnamEs(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::AssociateAliasError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for AssociateAliasError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl AssociateAliasError {
    /// Creates the `AssociateAliasError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `AssociateAliasError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AccessDenied(e) => e.meta(),
            Self::IllegalUpdate(e) => e.meta(),
            Self::InvalidArgument(e) => e.meta(),
            Self::NoSuchDistribution(e) => e.meta(),
            Self::TooManyDistributionCnamEs(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `AssociateAliasError::AccessDenied`.
    pub fn is_access_denied(&self) -> bool {
        matches!(self, Self::AccessDenied(_))
    }
    /// Returns `true` if the error kind is `AssociateAliasError::IllegalUpdate`.
    pub fn is_illegal_update(&self) -> bool {
        matches!(self, Self::IllegalUpdate(_))
    }
    /// Returns `true` if the error kind is `AssociateAliasError::InvalidArgument`.
    pub fn is_invalid_argument(&self) -> bool {
        matches!(self, Self::InvalidArgument(_))
    }
    /// Returns `true` if the error kind is `AssociateAliasError::NoSuchDistribution`.
    pub fn is_no_such_distribution(&self) -> bool {
        matches!(self, Self::NoSuchDistribution(_))
    }
    /// Returns `true` if the error kind is `AssociateAliasError::TooManyDistributionCnamEs`.
    pub fn is_too_many_distribution_cnam_es(&self) -> bool {
        matches!(self, Self::TooManyDistributionCnamEs(_))
    }
}
impl std::error::Error for AssociateAliasError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AccessDenied(_inner) => Some(_inner),
            Self::IllegalUpdate(_inner) => Some(_inner),
            Self::InvalidArgument(_inner) => Some(_inner),
            Self::NoSuchDistribution(_inner) => Some(_inner),
            Self::TooManyDistributionCnamEs(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}
