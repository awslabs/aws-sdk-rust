// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>The Anycast static IP list collection.</p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct AnycastIpListCollection {
    /// <p>Items in the Anycast static IP list collection. Each item is of the <code>AnycastIpListSummary</code> structure type.</p>
    pub items: ::std::option::Option<::std::vec::Vec<crate::types::AnycastIpListSummary>>,
    /// <p>Use this field when paginating results to indicate where to begin in your list. The response includes items in the list that occur after the marker. To get the next page of the list, set this field's value to the value of <code>NextMarker</code> from the current page's response.</p>
    pub marker: ::std::string::String,
    /// <p>Indicates the next page of the Anycast static IP list collection. To get the next page of the list, use this value in the <code>Marker</code> field of your request.</p>
    pub next_marker: ::std::option::Option<::std::string::String>,
    /// <p>The maximum number of Anycast static IP list collections that you want returned in the response.</p>
    pub max_items: i32,
    /// <p>If there are more items in the list collection than are in this response, this value is <code>true</code>.</p>
    pub is_truncated: bool,
    /// <p>The quantity of Anycast static IP lists in the collection.</p>
    pub quantity: i32,
}
impl AnycastIpListCollection {
    /// <p>Items in the Anycast static IP list collection. Each item is of the <code>AnycastIpListSummary</code> structure type.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.items.is_none()`.
    pub fn items(&self) -> &[crate::types::AnycastIpListSummary] {
        self.items.as_deref().unwrap_or_default()
    }
    /// <p>Use this field when paginating results to indicate where to begin in your list. The response includes items in the list that occur after the marker. To get the next page of the list, set this field's value to the value of <code>NextMarker</code> from the current page's response.</p>
    pub fn marker(&self) -> &str {
        use std::ops::Deref;
        self.marker.deref()
    }
    /// <p>Indicates the next page of the Anycast static IP list collection. To get the next page of the list, use this value in the <code>Marker</code> field of your request.</p>
    pub fn next_marker(&self) -> ::std::option::Option<&str> {
        self.next_marker.as_deref()
    }
    /// <p>The maximum number of Anycast static IP list collections that you want returned in the response.</p>
    pub fn max_items(&self) -> i32 {
        self.max_items
    }
    /// <p>If there are more items in the list collection than are in this response, this value is <code>true</code>.</p>
    pub fn is_truncated(&self) -> bool {
        self.is_truncated
    }
    /// <p>The quantity of Anycast static IP lists in the collection.</p>
    pub fn quantity(&self) -> i32 {
        self.quantity
    }
}
impl AnycastIpListCollection {
    /// Creates a new builder-style object to manufacture [`AnycastIpListCollection`](crate::types::AnycastIpListCollection).
    pub fn builder() -> crate::types::builders::AnycastIpListCollectionBuilder {
        crate::types::builders::AnycastIpListCollectionBuilder::default()
    }
}

/// A builder for [`AnycastIpListCollection`](crate::types::AnycastIpListCollection).
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
#[non_exhaustive]
pub struct AnycastIpListCollectionBuilder {
    pub(crate) items: ::std::option::Option<::std::vec::Vec<crate::types::AnycastIpListSummary>>,
    pub(crate) marker: ::std::option::Option<::std::string::String>,
    pub(crate) next_marker: ::std::option::Option<::std::string::String>,
    pub(crate) max_items: ::std::option::Option<i32>,
    pub(crate) is_truncated: ::std::option::Option<bool>,
    pub(crate) quantity: ::std::option::Option<i32>,
}
impl AnycastIpListCollectionBuilder {
    /// Appends an item to `items`.
    ///
    /// To override the contents of this collection use [`set_items`](Self::set_items).
    ///
    /// <p>Items in the Anycast static IP list collection. Each item is of the <code>AnycastIpListSummary</code> structure type.</p>
    pub fn items(mut self, input: crate::types::AnycastIpListSummary) -> Self {
        let mut v = self.items.unwrap_or_default();
        v.push(input);
        self.items = ::std::option::Option::Some(v);
        self
    }
    /// <p>Items in the Anycast static IP list collection. Each item is of the <code>AnycastIpListSummary</code> structure type.</p>
    pub fn set_items(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::AnycastIpListSummary>>) -> Self {
        self.items = input;
        self
    }
    /// <p>Items in the Anycast static IP list collection. Each item is of the <code>AnycastIpListSummary</code> structure type.</p>
    pub fn get_items(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::AnycastIpListSummary>> {
        &self.items
    }
    /// <p>Use this field when paginating results to indicate where to begin in your list. The response includes items in the list that occur after the marker. To get the next page of the list, set this field's value to the value of <code>NextMarker</code> from the current page's response.</p>
    /// This field is required.
    pub fn marker(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.marker = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>Use this field when paginating results to indicate where to begin in your list. The response includes items in the list that occur after the marker. To get the next page of the list, set this field's value to the value of <code>NextMarker</code> from the current page's response.</p>
    pub fn set_marker(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.marker = input;
        self
    }
    /// <p>Use this field when paginating results to indicate where to begin in your list. The response includes items in the list that occur after the marker. To get the next page of the list, set this field's value to the value of <code>NextMarker</code> from the current page's response.</p>
    pub fn get_marker(&self) -> &::std::option::Option<::std::string::String> {
        &self.marker
    }
    /// <p>Indicates the next page of the Anycast static IP list collection. To get the next page of the list, use this value in the <code>Marker</code> field of your request.</p>
    pub fn next_marker(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.next_marker = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>Indicates the next page of the Anycast static IP list collection. To get the next page of the list, use this value in the <code>Marker</code> field of your request.</p>
    pub fn set_next_marker(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.next_marker = input;
        self
    }
    /// <p>Indicates the next page of the Anycast static IP list collection. To get the next page of the list, use this value in the <code>Marker</code> field of your request.</p>
    pub fn get_next_marker(&self) -> &::std::option::Option<::std::string::String> {
        &self.next_marker
    }
    /// <p>The maximum number of Anycast static IP list collections that you want returned in the response.</p>
    /// This field is required.
    pub fn max_items(mut self, input: i32) -> Self {
        self.max_items = ::std::option::Option::Some(input);
        self
    }
    /// <p>The maximum number of Anycast static IP list collections that you want returned in the response.</p>
    pub fn set_max_items(mut self, input: ::std::option::Option<i32>) -> Self {
        self.max_items = input;
        self
    }
    /// <p>The maximum number of Anycast static IP list collections that you want returned in the response.</p>
    pub fn get_max_items(&self) -> &::std::option::Option<i32> {
        &self.max_items
    }
    /// <p>If there are more items in the list collection than are in this response, this value is <code>true</code>.</p>
    /// This field is required.
    pub fn is_truncated(mut self, input: bool) -> Self {
        self.is_truncated = ::std::option::Option::Some(input);
        self
    }
    /// <p>If there are more items in the list collection than are in this response, this value is <code>true</code>.</p>
    pub fn set_is_truncated(mut self, input: ::std::option::Option<bool>) -> Self {
        self.is_truncated = input;
        self
    }
    /// <p>If there are more items in the list collection than are in this response, this value is <code>true</code>.</p>
    pub fn get_is_truncated(&self) -> &::std::option::Option<bool> {
        &self.is_truncated
    }
    /// <p>The quantity of Anycast static IP lists in the collection.</p>
    /// This field is required.
    pub fn quantity(mut self, input: i32) -> Self {
        self.quantity = ::std::option::Option::Some(input);
        self
    }
    /// <p>The quantity of Anycast static IP lists in the collection.</p>
    pub fn set_quantity(mut self, input: ::std::option::Option<i32>) -> Self {
        self.quantity = input;
        self
    }
    /// <p>The quantity of Anycast static IP lists in the collection.</p>
    pub fn get_quantity(&self) -> &::std::option::Option<i32> {
        &self.quantity
    }
    /// Consumes the builder and constructs a [`AnycastIpListCollection`](crate::types::AnycastIpListCollection).
    /// This method will fail if any of the following fields are not set:
    /// - [`marker`](crate::types::builders::AnycastIpListCollectionBuilder::marker)
    /// - [`max_items`](crate::types::builders::AnycastIpListCollectionBuilder::max_items)
    /// - [`is_truncated`](crate::types::builders::AnycastIpListCollectionBuilder::is_truncated)
    /// - [`quantity`](crate::types::builders::AnycastIpListCollectionBuilder::quantity)
    pub fn build(self) -> ::std::result::Result<crate::types::AnycastIpListCollection, ::aws_smithy_types::error::operation::BuildError> {
        ::std::result::Result::Ok(crate::types::AnycastIpListCollection {
            items: self.items,
            marker: self.marker.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "marker",
                    "marker was not specified but it is required when building AnycastIpListCollection",
                )
            })?,
            next_marker: self.next_marker,
            max_items: self.max_items.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "max_items",
                    "max_items was not specified but it is required when building AnycastIpListCollection",
                )
            })?,
            is_truncated: self.is_truncated.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "is_truncated",
                    "is_truncated was not specified but it is required when building AnycastIpListCollection",
                )
            })?,
            quantity: self.quantity.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "quantity",
                    "quantity was not specified but it is required when building AnycastIpListCollection",
                )
            })?,
        })
    }
}
