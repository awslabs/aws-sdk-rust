// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>A list of aliases (also called CNAMEs) and the CloudFront distributions and Amazon Web Services accounts that they are associated with. In the list, the distribution and account IDs are partially hidden, which allows you to identify the distributions and accounts that you own, but helps to protect the information of ones that you don't own.</p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct ConflictingAliasesList {
    /// <p>If there are more items in the list than are in this response, this element is present. It contains the value that you should use in the <code>Marker</code> field of a subsequent request to continue listing conflicting aliases where you left off.</p>
    pub next_marker: ::std::option::Option<::std::string::String>,
    /// <p>The maximum number of conflicting aliases requested.</p>
    pub max_items: ::std::option::Option<i32>,
    /// <p>The number of conflicting aliases returned in the response.</p>
    pub quantity: ::std::option::Option<i32>,
    /// <p>Contains the conflicting aliases in the list.</p>
    pub items: ::std::option::Option<::std::vec::Vec<crate::types::ConflictingAlias>>,
}
impl ConflictingAliasesList {
    /// <p>If there are more items in the list than are in this response, this element is present. It contains the value that you should use in the <code>Marker</code> field of a subsequent request to continue listing conflicting aliases where you left off.</p>
    pub fn next_marker(&self) -> ::std::option::Option<&str> {
        self.next_marker.as_deref()
    }
    /// <p>The maximum number of conflicting aliases requested.</p>
    pub fn max_items(&self) -> ::std::option::Option<i32> {
        self.max_items
    }
    /// <p>The number of conflicting aliases returned in the response.</p>
    pub fn quantity(&self) -> ::std::option::Option<i32> {
        self.quantity
    }
    /// <p>Contains the conflicting aliases in the list.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.items.is_none()`.
    pub fn items(&self) -> &[crate::types::ConflictingAlias] {
        self.items.as_deref().unwrap_or_default()
    }
}
impl ConflictingAliasesList {
    /// Creates a new builder-style object to manufacture [`ConflictingAliasesList`](crate::types::ConflictingAliasesList).
    pub fn builder() -> crate::types::builders::ConflictingAliasesListBuilder {
        crate::types::builders::ConflictingAliasesListBuilder::default()
    }
}

/// A builder for [`ConflictingAliasesList`](crate::types::ConflictingAliasesList).
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
pub struct ConflictingAliasesListBuilder {
    pub(crate) next_marker: ::std::option::Option<::std::string::String>,
    pub(crate) max_items: ::std::option::Option<i32>,
    pub(crate) quantity: ::std::option::Option<i32>,
    pub(crate) items: ::std::option::Option<::std::vec::Vec<crate::types::ConflictingAlias>>,
}
impl ConflictingAliasesListBuilder {
    /// <p>If there are more items in the list than are in this response, this element is present. It contains the value that you should use in the <code>Marker</code> field of a subsequent request to continue listing conflicting aliases where you left off.</p>
    pub fn next_marker(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.next_marker = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>If there are more items in the list than are in this response, this element is present. It contains the value that you should use in the <code>Marker</code> field of a subsequent request to continue listing conflicting aliases where you left off.</p>
    pub fn set_next_marker(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.next_marker = input;
        self
    }
    /// <p>If there are more items in the list than are in this response, this element is present. It contains the value that you should use in the <code>Marker</code> field of a subsequent request to continue listing conflicting aliases where you left off.</p>
    pub fn get_next_marker(&self) -> &::std::option::Option<::std::string::String> {
        &self.next_marker
    }
    /// <p>The maximum number of conflicting aliases requested.</p>
    pub fn max_items(mut self, input: i32) -> Self {
        self.max_items = ::std::option::Option::Some(input);
        self
    }
    /// <p>The maximum number of conflicting aliases requested.</p>
    pub fn set_max_items(mut self, input: ::std::option::Option<i32>) -> Self {
        self.max_items = input;
        self
    }
    /// <p>The maximum number of conflicting aliases requested.</p>
    pub fn get_max_items(&self) -> &::std::option::Option<i32> {
        &self.max_items
    }
    /// <p>The number of conflicting aliases returned in the response.</p>
    pub fn quantity(mut self, input: i32) -> Self {
        self.quantity = ::std::option::Option::Some(input);
        self
    }
    /// <p>The number of conflicting aliases returned in the response.</p>
    pub fn set_quantity(mut self, input: ::std::option::Option<i32>) -> Self {
        self.quantity = input;
        self
    }
    /// <p>The number of conflicting aliases returned in the response.</p>
    pub fn get_quantity(&self) -> &::std::option::Option<i32> {
        &self.quantity
    }
    /// Appends an item to `items`.
    ///
    /// To override the contents of this collection use [`set_items`](Self::set_items).
    ///
    /// <p>Contains the conflicting aliases in the list.</p>
    pub fn items(mut self, input: crate::types::ConflictingAlias) -> Self {
        let mut v = self.items.unwrap_or_default();
        v.push(input);
        self.items = ::std::option::Option::Some(v);
        self
    }
    /// <p>Contains the conflicting aliases in the list.</p>
    pub fn set_items(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::ConflictingAlias>>) -> Self {
        self.items = input;
        self
    }
    /// <p>Contains the conflicting aliases in the list.</p>
    pub fn get_items(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::ConflictingAlias>> {
        &self.items
    }
    /// Consumes the builder and constructs a [`ConflictingAliasesList`](crate::types::ConflictingAliasesList).
    pub fn build(self) -> crate::types::ConflictingAliasesList {
        crate::types::ConflictingAliasesList {
            next_marker: self.next_marker,
            max_items: self.max_items,
            quantity: self.quantity,
            items: self.items,
        }
    }
}
