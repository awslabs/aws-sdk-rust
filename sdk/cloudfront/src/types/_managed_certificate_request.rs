// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>An object that represents the request for the Amazon CloudFront managed ACM certificate.</p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct ManagedCertificateRequest {
    /// <p>Specify how the HTTP validation token will be served when requesting the CloudFront managed ACM certificate.</p>
    /// <ul>
    /// <li>
    /// <p>For <code>cloudfront</code>, CloudFront will automatically serve the validation token. Choose this mode if you can point the domain's DNS to CloudFront immediately.</p></li>
    /// <li>
    /// <p>For <code>self-hosted</code>, you serve the validation token from your existing infrastructure. Choose this mode when you need to maintain current traffic flow while your certificate is being issued. You can place the validation token at the well-known path on your existing web server, wait for ACM to validate and issue the certificate, and then update your DNS to point to CloudFront.</p></li>
    /// </ul>
    pub validation_token_host: crate::types::ValidationTokenHost,
    /// <p>The primary domain name associated with the CloudFront managed ACM certificate.</p>
    pub primary_domain_name: ::std::option::Option<::std::string::String>,
    /// <p>You can opt out of certificate transparency logging by specifying the <code>disabled</code> option. Opt in by specifying <code>enabled</code>. For more information, see <a href="https://docs.aws.amazon.com/acm/latest/userguide/acm-concepts.html#concept-transparency">Certificate Transparency Logging </a> in the <i>Certificate Manager User Guide</i>.</p>
    pub certificate_transparency_logging_preference: ::std::option::Option<crate::types::CertificateTransparencyLoggingPreference>,
}
impl ManagedCertificateRequest {
    /// <p>Specify how the HTTP validation token will be served when requesting the CloudFront managed ACM certificate.</p>
    /// <ul>
    /// <li>
    /// <p>For <code>cloudfront</code>, CloudFront will automatically serve the validation token. Choose this mode if you can point the domain's DNS to CloudFront immediately.</p></li>
    /// <li>
    /// <p>For <code>self-hosted</code>, you serve the validation token from your existing infrastructure. Choose this mode when you need to maintain current traffic flow while your certificate is being issued. You can place the validation token at the well-known path on your existing web server, wait for ACM to validate and issue the certificate, and then update your DNS to point to CloudFront.</p></li>
    /// </ul>
    pub fn validation_token_host(&self) -> &crate::types::ValidationTokenHost {
        &self.validation_token_host
    }
    /// <p>The primary domain name associated with the CloudFront managed ACM certificate.</p>
    pub fn primary_domain_name(&self) -> ::std::option::Option<&str> {
        self.primary_domain_name.as_deref()
    }
    /// <p>You can opt out of certificate transparency logging by specifying the <code>disabled</code> option. Opt in by specifying <code>enabled</code>. For more information, see <a href="https://docs.aws.amazon.com/acm/latest/userguide/acm-concepts.html#concept-transparency">Certificate Transparency Logging </a> in the <i>Certificate Manager User Guide</i>.</p>
    pub fn certificate_transparency_logging_preference(&self) -> ::std::option::Option<&crate::types::CertificateTransparencyLoggingPreference> {
        self.certificate_transparency_logging_preference.as_ref()
    }
}
impl ManagedCertificateRequest {
    /// Creates a new builder-style object to manufacture [`ManagedCertificateRequest`](crate::types::ManagedCertificateRequest).
    pub fn builder() -> crate::types::builders::ManagedCertificateRequestBuilder {
        crate::types::builders::ManagedCertificateRequestBuilder::default()
    }
}

/// A builder for [`ManagedCertificateRequest`](crate::types::ManagedCertificateRequest).
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
#[non_exhaustive]
pub struct ManagedCertificateRequestBuilder {
    pub(crate) validation_token_host: ::std::option::Option<crate::types::ValidationTokenHost>,
    pub(crate) primary_domain_name: ::std::option::Option<::std::string::String>,
    pub(crate) certificate_transparency_logging_preference: ::std::option::Option<crate::types::CertificateTransparencyLoggingPreference>,
}
impl ManagedCertificateRequestBuilder {
    /// <p>Specify how the HTTP validation token will be served when requesting the CloudFront managed ACM certificate.</p>
    /// <ul>
    /// <li>
    /// <p>For <code>cloudfront</code>, CloudFront will automatically serve the validation token. Choose this mode if you can point the domain's DNS to CloudFront immediately.</p></li>
    /// <li>
    /// <p>For <code>self-hosted</code>, you serve the validation token from your existing infrastructure. Choose this mode when you need to maintain current traffic flow while your certificate is being issued. You can place the validation token at the well-known path on your existing web server, wait for ACM to validate and issue the certificate, and then update your DNS to point to CloudFront.</p></li>
    /// </ul>
    /// This field is required.
    pub fn validation_token_host(mut self, input: crate::types::ValidationTokenHost) -> Self {
        self.validation_token_host = ::std::option::Option::Some(input);
        self
    }
    /// <p>Specify how the HTTP validation token will be served when requesting the CloudFront managed ACM certificate.</p>
    /// <ul>
    /// <li>
    /// <p>For <code>cloudfront</code>, CloudFront will automatically serve the validation token. Choose this mode if you can point the domain's DNS to CloudFront immediately.</p></li>
    /// <li>
    /// <p>For <code>self-hosted</code>, you serve the validation token from your existing infrastructure. Choose this mode when you need to maintain current traffic flow while your certificate is being issued. You can place the validation token at the well-known path on your existing web server, wait for ACM to validate and issue the certificate, and then update your DNS to point to CloudFront.</p></li>
    /// </ul>
    pub fn set_validation_token_host(mut self, input: ::std::option::Option<crate::types::ValidationTokenHost>) -> Self {
        self.validation_token_host = input;
        self
    }
    /// <p>Specify how the HTTP validation token will be served when requesting the CloudFront managed ACM certificate.</p>
    /// <ul>
    /// <li>
    /// <p>For <code>cloudfront</code>, CloudFront will automatically serve the validation token. Choose this mode if you can point the domain's DNS to CloudFront immediately.</p></li>
    /// <li>
    /// <p>For <code>self-hosted</code>, you serve the validation token from your existing infrastructure. Choose this mode when you need to maintain current traffic flow while your certificate is being issued. You can place the validation token at the well-known path on your existing web server, wait for ACM to validate and issue the certificate, and then update your DNS to point to CloudFront.</p></li>
    /// </ul>
    pub fn get_validation_token_host(&self) -> &::std::option::Option<crate::types::ValidationTokenHost> {
        &self.validation_token_host
    }
    /// <p>The primary domain name associated with the CloudFront managed ACM certificate.</p>
    pub fn primary_domain_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.primary_domain_name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The primary domain name associated with the CloudFront managed ACM certificate.</p>
    pub fn set_primary_domain_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.primary_domain_name = input;
        self
    }
    /// <p>The primary domain name associated with the CloudFront managed ACM certificate.</p>
    pub fn get_primary_domain_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.primary_domain_name
    }
    /// <p>You can opt out of certificate transparency logging by specifying the <code>disabled</code> option. Opt in by specifying <code>enabled</code>. For more information, see <a href="https://docs.aws.amazon.com/acm/latest/userguide/acm-concepts.html#concept-transparency">Certificate Transparency Logging </a> in the <i>Certificate Manager User Guide</i>.</p>
    pub fn certificate_transparency_logging_preference(mut self, input: crate::types::CertificateTransparencyLoggingPreference) -> Self {
        self.certificate_transparency_logging_preference = ::std::option::Option::Some(input);
        self
    }
    /// <p>You can opt out of certificate transparency logging by specifying the <code>disabled</code> option. Opt in by specifying <code>enabled</code>. For more information, see <a href="https://docs.aws.amazon.com/acm/latest/userguide/acm-concepts.html#concept-transparency">Certificate Transparency Logging </a> in the <i>Certificate Manager User Guide</i>.</p>
    pub fn set_certificate_transparency_logging_preference(
        mut self,
        input: ::std::option::Option<crate::types::CertificateTransparencyLoggingPreference>,
    ) -> Self {
        self.certificate_transparency_logging_preference = input;
        self
    }
    /// <p>You can opt out of certificate transparency logging by specifying the <code>disabled</code> option. Opt in by specifying <code>enabled</code>. For more information, see <a href="https://docs.aws.amazon.com/acm/latest/userguide/acm-concepts.html#concept-transparency">Certificate Transparency Logging </a> in the <i>Certificate Manager User Guide</i>.</p>
    pub fn get_certificate_transparency_logging_preference(&self) -> &::std::option::Option<crate::types::CertificateTransparencyLoggingPreference> {
        &self.certificate_transparency_logging_preference
    }
    /// Consumes the builder and constructs a [`ManagedCertificateRequest`](crate::types::ManagedCertificateRequest).
    /// This method will fail if any of the following fields are not set:
    /// - [`validation_token_host`](crate::types::builders::ManagedCertificateRequestBuilder::validation_token_host)
    pub fn build(self) -> ::std::result::Result<crate::types::ManagedCertificateRequest, ::aws_smithy_types::error::operation::BuildError> {
        ::std::result::Result::Ok(crate::types::ManagedCertificateRequest {
            validation_token_host: self.validation_token_host.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "validation_token_host",
                    "validation_token_host was not specified but it is required when building ManagedCertificateRequest",
                )
            })?,
            primary_domain_name: self.primary_domain_name,
            certificate_transparency_logging_preference: self.certificate_transparency_logging_preference,
        })
    }
}
