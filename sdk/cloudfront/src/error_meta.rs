// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// All possible error types for this service.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum Error {
    /// <p>Access denied.</p>
    AccessDenied(crate::types::error::AccessDenied),
    /// <p>Invalidation batch specified is too large.</p>
    BatchTooLarge(crate::types::error::BatchTooLarge),
    /// <p>The CNAME specified is already defined for CloudFront.</p>
    CnameAlreadyExists(crate::types::error::CnameAlreadyExists),
    /// <p>A cache policy with this name already exists. You must provide a unique name. To modify an existing cache policy, use <code>UpdateCachePolicy</code>.</p>
    CachePolicyAlreadyExists(crate::types::error::CachePolicyAlreadyExists),
    /// <p>Cannot delete the cache policy because it is attached to one or more cache behaviors.</p>
    CachePolicyInUse(crate::types::error::CachePolicyInUse),
    /// <p>You can't change the value of a public key.</p>
    CannotChangeImmutablePublicKeyFields(crate::types::error::CannotChangeImmutablePublicKeyFields),
    /// <p>If the <code>CallerReference</code> is a value you already sent in a previous request to create an identity but the content of the <code>CloudFrontOriginAccessIdentityConfig</code> is different from the original request, CloudFront returns a <code>CloudFrontOriginAccessIdentityAlreadyExists</code> error. </p>
    CloudFrontOriginAccessIdentityAlreadyExists(crate::types::error::CloudFrontOriginAccessIdentityAlreadyExists),
    /// <p>The Origin Access Identity specified is already in use.</p>
    CloudFrontOriginAccessIdentityInUse(crate::types::error::CloudFrontOriginAccessIdentityInUse),
    /// <p>A continuous deployment policy with this configuration already exists.</p>
    ContinuousDeploymentPolicyAlreadyExists(crate::types::error::ContinuousDeploymentPolicyAlreadyExists),
    /// <p>You cannot delete a continuous deployment policy that is associated with a primary distribution.</p>
    ContinuousDeploymentPolicyInUse(crate::types::error::ContinuousDeploymentPolicyInUse),
    /// <p>The caller reference you attempted to create the distribution with is associated with another distribution.</p>
    DistributionAlreadyExists(crate::types::error::DistributionAlreadyExists),
    /// <p>The specified CloudFront distribution is not disabled. You must disable the distribution before you can delete it.</p>
    DistributionNotDisabled(crate::types::error::DistributionNotDisabled),
    /// <p>The specified configuration for field-level encryption already exists.</p>
    FieldLevelEncryptionConfigAlreadyExists(crate::types::error::FieldLevelEncryptionConfigAlreadyExists),
    /// <p>The specified configuration for field-level encryption is in use.</p>
    FieldLevelEncryptionConfigInUse(crate::types::error::FieldLevelEncryptionConfigInUse),
    /// <p>The specified profile for field-level encryption already exists.</p>
    FieldLevelEncryptionProfileAlreadyExists(crate::types::error::FieldLevelEncryptionProfileAlreadyExists),
    /// <p>The specified profile for field-level encryption is in use.</p>
    FieldLevelEncryptionProfileInUse(crate::types::error::FieldLevelEncryptionProfileInUse),
    /// <p>The maximum size of a profile for field-level encryption was exceeded.</p>
    FieldLevelEncryptionProfileSizeExceeded(crate::types::error::FieldLevelEncryptionProfileSizeExceeded),
    /// <p>A function with the same name already exists in this Amazon Web Services account. To create a function, you must provide a unique name. To update an existing function, use <code>UpdateFunction</code>.</p>
    FunctionAlreadyExists(crate::types::error::FunctionAlreadyExists),
    /// <p>Cannot delete the function because it's attached to one or more cache behaviors.</p>
    FunctionInUse(crate::types::error::FunctionInUse),
    /// <p>The function is too large. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
    FunctionSizeLimitExceeded(crate::types::error::FunctionSizeLimitExceeded),
    /// <p>You cannot delete a managed policy.</p>
    IllegalDelete(crate::types::error::IllegalDelete),
    /// <p>The specified configuration for field-level encryption can't be associated with the specified cache behavior.</p>
    IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior(crate::types::error::IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior),
    /// <p>An origin cannot contain both an origin access control (OAC) and an origin access identity (OAI).</p>
    IllegalOriginAccessConfiguration(crate::types::error::IllegalOriginAccessConfiguration),
    /// <p>The update contains modifications that are not allowed.</p>
    IllegalUpdate(crate::types::error::IllegalUpdate),
    /// <p>The value of <code>Quantity</code> and the size of <code>Items</code> don't match.</p>
    InconsistentQuantities(crate::types::error::InconsistentQuantities),
    /// <p>An argument is invalid.</p>
    InvalidArgument(crate::types::error::InvalidArgument),
    /// <p>The default root object file name is too big or contains an invalid character.</p>
    InvalidDefaultRootObject(crate::types::error::InvalidDefaultRootObject),
    /// <p>An origin access control is associated with an origin whose domain name is not supported.</p>
    InvalidDomainNameForOriginAccessControl(crate::types::error::InvalidDomainNameForOriginAccessControl),
    /// <p>An invalid error code was specified.</p>
    InvalidErrorCode(crate::types::error::InvalidErrorCode),
    /// <p>Your request contains forward cookies option which doesn't match with the expectation for the <code>whitelisted</code> list of cookie names. Either list of cookie names has been specified when not allowed or list of cookie names is missing when expected.</p>
    InvalidForwardCookies(crate::types::error::InvalidForwardCookies),
    /// <p>A CloudFront function association is invalid.</p>
    InvalidFunctionAssociation(crate::types::error::InvalidFunctionAssociation),
    /// <p>The specified geo restriction parameter is not valid.</p>
    InvalidGeoRestrictionParameter(crate::types::error::InvalidGeoRestrictionParameter),
    /// <p>The headers specified are not valid for an Amazon S3 origin.</p>
    InvalidHeadersForS3Origin(crate::types::error::InvalidHeadersForS3Origin),
    /// <p>The <code>If-Match</code> version is missing or not valid.</p>
    InvalidIfMatchVersion(crate::types::error::InvalidIfMatchVersion),
    /// <p>The specified Lambda@Edge function association is invalid.</p>
    InvalidLambdaFunctionAssociation(crate::types::error::InvalidLambdaFunctionAssociation),
    /// <p>The location code specified is not valid.</p>
    InvalidLocationCode(crate::types::error::InvalidLocationCode),
    /// <p>The minimum protocol version specified is not valid.</p>
    InvalidMinimumProtocolVersion(crate::types::error::InvalidMinimumProtocolVersion),
    /// <p>The Amazon S3 origin server specified does not refer to a valid Amazon S3 bucket.</p>
    InvalidOrigin(crate::types::error::InvalidOrigin),
    /// <p>The origin access control is not valid.</p>
    InvalidOriginAccessControl(crate::types::error::InvalidOriginAccessControl),
    /// <p>The origin access identity is not valid or doesn't exist.</p>
    InvalidOriginAccessIdentity(crate::types::error::InvalidOriginAccessIdentity),
    /// <p>The keep alive timeout specified for the origin is not valid.</p>
    InvalidOriginKeepaliveTimeout(crate::types::error::InvalidOriginKeepaliveTimeout),
    /// <p>The read timeout specified for the origin is not valid.</p>
    InvalidOriginReadTimeout(crate::types::error::InvalidOriginReadTimeout),
    /// <p>You cannot specify SSLv3 as the minimum protocol version if you only want to support only clients that support Server Name Indication (SNI).</p>
    InvalidProtocolSettings(crate::types::error::InvalidProtocolSettings),
    /// <p>The query string parameters specified are not valid.</p>
    InvalidQueryStringParameters(crate::types::error::InvalidQueryStringParameters),
    /// <p>The relative path is too big, is not URL-encoded, or does not begin with a slash (/).</p>
    InvalidRelativePath(crate::types::error::InvalidRelativePath),
    /// <p>This operation requires the HTTPS protocol. Ensure that you specify the HTTPS protocol in your request, or omit the <code>RequiredProtocols</code> element from your distribution configuration.</p>
    InvalidRequiredProtocol(crate::types::error::InvalidRequiredProtocol),
    /// <p>A response code is not valid.</p>
    InvalidResponseCode(crate::types::error::InvalidResponseCode),
    /// <p>The TTL order specified is not valid.</p>
    InvalidTtlOrder(crate::types::error::InvalidTtlOrder),
    /// <p>The tagging specified is not valid.</p>
    InvalidTagging(crate::types::error::InvalidTagging),
    /// <p>A viewer certificate specified is not valid.</p>
    InvalidViewerCertificate(crate::types::error::InvalidViewerCertificate),
    /// <p>A web ACL ID specified is not valid. To specify a web ACL created using the latest version of WAF, use the ACL ARN, for example <code>arn:aws:wafv2:us-east-1:123456789012:global/webacl/ExampleWebACL/473e64fd-f30b-4765-81a0-62ad96dd167a</code>. To specify a web ACL created using WAF Classic, use the ACL ID, for example <code>473e64fd-f30b-4765-81a0-62ad96dd167a</code>.</p>
    InvalidWebAclId(crate::types::error::InvalidWebAclId),
    /// <p>A key group with this name already exists. You must provide a unique name. To modify an existing key group, use <code>UpdateKeyGroup</code>.</p>
    KeyGroupAlreadyExists(crate::types::error::KeyGroupAlreadyExists),
    /// <p>This operation requires a body. Ensure that the body is present and the <code>Content-Type</code> header is set.</p>
    MissingBody(crate::types::error::MissingBody),
    /// <p>A monitoring subscription already exists for the specified distribution.</p>
    MonitoringSubscriptionAlreadyExists(crate::types::error::MonitoringSubscriptionAlreadyExists),
    /// <p>The cache policy does not exist.</p>
    NoSuchCachePolicy(crate::types::error::NoSuchCachePolicy),
    /// <p>The specified origin access identity does not exist.</p>
    NoSuchCloudFrontOriginAccessIdentity(crate::types::error::NoSuchCloudFrontOriginAccessIdentity),
    /// <p>The continuous deployment policy doesn't exist.</p>
    NoSuchContinuousDeploymentPolicy(crate::types::error::NoSuchContinuousDeploymentPolicy),
    /// <p>The specified distribution does not exist.</p>
    NoSuchDistribution(crate::types::error::NoSuchDistribution),
    /// <p>The specified configuration for field-level encryption doesn't exist.</p>
    NoSuchFieldLevelEncryptionConfig(crate::types::error::NoSuchFieldLevelEncryptionConfig),
    /// <p>The specified profile for field-level encryption doesn't exist.</p>
    NoSuchFieldLevelEncryptionProfile(crate::types::error::NoSuchFieldLevelEncryptionProfile),
    /// <p>The function does not exist.</p>
    NoSuchFunctionExists(crate::types::error::NoSuchFunctionExists),
    /// <p>The specified invalidation does not exist.</p>
    NoSuchInvalidation(crate::types::error::NoSuchInvalidation),
    /// <p>A monitoring subscription does not exist for the specified distribution.</p>
    NoSuchMonitoringSubscription(crate::types::error::NoSuchMonitoringSubscription),
    /// <p>No origin exists with the specified <code>Origin Id</code>.</p>
    NoSuchOrigin(crate::types::error::NoSuchOrigin),
    /// <p>The origin access control does not exist.</p>
    NoSuchOriginAccessControl(crate::types::error::NoSuchOriginAccessControl),
    /// <p>The origin request policy does not exist.</p>
    NoSuchOriginRequestPolicy(crate::types::error::NoSuchOriginRequestPolicy),
    /// <p>The specified public key doesn't exist.</p>
    NoSuchPublicKey(crate::types::error::NoSuchPublicKey),
    /// <p>The real-time log configuration does not exist.</p>
    NoSuchRealtimeLogConfig(crate::types::error::NoSuchRealtimeLogConfig),
    /// <p>A resource that was specified is not valid.</p>
    NoSuchResource(crate::types::error::NoSuchResource),
    /// <p>The response headers policy does not exist.</p>
    NoSuchResponseHeadersPolicy(crate::types::error::NoSuchResponseHeadersPolicy),
    /// <p>The specified streaming distribution does not exist.</p>
    NoSuchStreamingDistribution(crate::types::error::NoSuchStreamingDistribution),
    /// <p>An origin access control with the specified parameters already exists.</p>
    OriginAccessControlAlreadyExists(crate::types::error::OriginAccessControlAlreadyExists),
    /// <p>Cannot delete the origin access control because it's in use by one or more distributions.</p>
    OriginAccessControlInUse(crate::types::error::OriginAccessControlInUse),
    /// <p>An origin request policy with this name already exists. You must provide a unique name. To modify an existing origin request policy, use <code>UpdateOriginRequestPolicy</code>.</p>
    OriginRequestPolicyAlreadyExists(crate::types::error::OriginRequestPolicyAlreadyExists),
    /// <p>Cannot delete the origin request policy because it is attached to one or more cache behaviors.</p>
    OriginRequestPolicyInUse(crate::types::error::OriginRequestPolicyInUse),
    /// <p>The precondition in one or more of the request fields evaluated to <code>false</code>.</p>
    PreconditionFailed(crate::types::error::PreconditionFailed),
    /// <p>The specified public key already exists.</p>
    PublicKeyAlreadyExists(crate::types::error::PublicKeyAlreadyExists),
    /// <p>The specified public key is in use.</p>
    PublicKeyInUse(crate::types::error::PublicKeyInUse),
    /// <p>No profile specified for the field-level encryption query argument.</p>
    QueryArgProfileEmpty(crate::types::error::QueryArgProfileEmpty),
    /// <p>A real-time log configuration with this name already exists. You must provide a unique name. To modify an existing real-time log configuration, use <code>UpdateRealtimeLogConfig</code>.</p>
    RealtimeLogConfigAlreadyExists(crate::types::error::RealtimeLogConfigAlreadyExists),
    /// <p>Cannot delete the real-time log configuration because it is attached to one or more cache behaviors.</p>
    RealtimeLogConfigInUse(crate::types::error::RealtimeLogConfigInUse),
    /// <p>The specified real-time log configuration belongs to a different Amazon Web Services account.</p>
    RealtimeLogConfigOwnerMismatch(crate::types::error::RealtimeLogConfigOwnerMismatch),
    /// <p>Cannot delete this resource because it is in use.</p>
    ResourceInUse(crate::types::error::ResourceInUse),
    /// <p>A response headers policy with this name already exists. You must provide a unique name. To modify an existing response headers policy, use <code>UpdateResponseHeadersPolicy</code>.</p>
    ResponseHeadersPolicyAlreadyExists(crate::types::error::ResponseHeadersPolicyAlreadyExists),
    /// <p>Cannot delete the response headers policy because it is attached to one or more cache behaviors in a CloudFront distribution.</p>
    ResponseHeadersPolicyInUse(crate::types::error::ResponseHeadersPolicyInUse),
    /// <p>A continuous deployment policy for this staging distribution already exists.</p>
    StagingDistributionInUse(crate::types::error::StagingDistributionInUse),
    /// <p>The caller reference you attempted to create the streaming distribution with is associated with another distribution</p>
    StreamingDistributionAlreadyExists(crate::types::error::StreamingDistributionAlreadyExists),
    /// <p>The specified CloudFront distribution is not disabled. You must disable the distribution before you can delete it.</p>
    StreamingDistributionNotDisabled(crate::types::error::StreamingDistributionNotDisabled),
    /// <p>The CloudFront function failed.</p>
    TestFunctionFailed(crate::types::error::TestFunctionFailed),
    /// <p>The length of the <code>Content-Security-Policy</code> header value in the response headers policy exceeds the maximum.</p> 
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
    TooLongCspInResponseHeadersPolicy(crate::types::error::TooLongCspInResponseHeadersPolicy),
    /// <p>You cannot create more cache behaviors for the distribution.</p>
    TooManyCacheBehaviors(crate::types::error::TooManyCacheBehaviors),
    /// <p>You have reached the maximum number of cache policies for this Amazon Web Services account. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
    TooManyCachePolicies(crate::types::error::TooManyCachePolicies),
    /// <p>You cannot create anymore custom SSL/TLS certificates.</p>
    TooManyCertificates(crate::types::error::TooManyCertificates),
    /// <p>Processing your request would cause you to exceed the maximum number of origin access identities allowed.</p>
    TooManyCloudFrontOriginAccessIdentities(crate::types::error::TooManyCloudFrontOriginAccessIdentities),
    /// <p>You have reached the maximum number of continuous deployment policies for this Amazon Web Services account.</p>
    TooManyContinuousDeploymentPolicies(crate::types::error::TooManyContinuousDeploymentPolicies),
    /// <p>Your request contains more cookie names in the whitelist than are allowed per cache behavior.</p>
    TooManyCookieNamesInWhiteList(crate::types::error::TooManyCookieNamesInWhiteList),
    /// <p>The number of cookies in the cache policy exceeds the maximum. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
    TooManyCookiesInCachePolicy(crate::types::error::TooManyCookiesInCachePolicy),
    /// <p>The number of cookies in the origin request policy exceeds the maximum. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
    TooManyCookiesInOriginRequestPolicy(crate::types::error::TooManyCookiesInOriginRequestPolicy),
    /// <p>The number of custom headers in the response headers policy exceeds the maximum.</p> 
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
    TooManyCustomHeadersInResponseHeadersPolicy(crate::types::error::TooManyCustomHeadersInResponseHeadersPolicy),
    /// <p>Your request contains more CNAMEs than are allowed per distribution.</p>
    TooManyDistributionCnamEs(crate::types::error::TooManyDistributionCnamEs),
    /// <p>Processing your request would cause you to exceed the maximum number of distributions allowed.</p>
    TooManyDistributions(crate::types::error::TooManyDistributions),
    /// <p>The maximum number of distributions have been associated with the specified cache policy. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
    TooManyDistributionsAssociatedToCachePolicy(crate::types::error::TooManyDistributionsAssociatedToCachePolicy),
    /// <p>The maximum number of distributions have been associated with the specified configuration for field-level encryption.</p>
    TooManyDistributionsAssociatedToFieldLevelEncryptionConfig(crate::types::error::TooManyDistributionsAssociatedToFieldLevelEncryptionConfig),
    /// <p>The number of distributions that reference this key group is more than the maximum allowed. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
    TooManyDistributionsAssociatedToKeyGroup(crate::types::error::TooManyDistributionsAssociatedToKeyGroup),
    /// <p>The maximum number of distributions have been associated with the specified origin access control.</p> 
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
    TooManyDistributionsAssociatedToOriginAccessControl(crate::types::error::TooManyDistributionsAssociatedToOriginAccessControl),
    /// <p>The maximum number of distributions have been associated with the specified origin request policy. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
    TooManyDistributionsAssociatedToOriginRequestPolicy(crate::types::error::TooManyDistributionsAssociatedToOriginRequestPolicy),
    /// <p>The maximum number of distributions have been associated with the specified response headers policy.</p> 
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
    TooManyDistributionsAssociatedToResponseHeadersPolicy(crate::types::error::TooManyDistributionsAssociatedToResponseHeadersPolicy),
    /// <p>You have reached the maximum number of distributions that are associated with a CloudFront function. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
    TooManyDistributionsWithFunctionAssociations(crate::types::error::TooManyDistributionsWithFunctionAssociations),
    /// <p>Processing your request would cause the maximum number of distributions with Lambda@Edge function associations per owner to be exceeded.</p>
    TooManyDistributionsWithLambdaAssociations(crate::types::error::TooManyDistributionsWithLambdaAssociations),
    /// <p>The maximum number of distributions have been associated with the specified Lambda@Edge function.</p>
    TooManyDistributionsWithSingleFunctionArn(crate::types::error::TooManyDistributionsWithSingleFunctionArn),
    /// <p>The maximum number of configurations for field-level encryption have been created.</p>
    TooManyFieldLevelEncryptionConfigs(crate::types::error::TooManyFieldLevelEncryptionConfigs),
    /// <p>The maximum number of content type profiles for field-level encryption have been created.</p>
    TooManyFieldLevelEncryptionContentTypeProfiles(crate::types::error::TooManyFieldLevelEncryptionContentTypeProfiles),
    /// <p>The maximum number of encryption entities for field-level encryption have been created.</p>
    TooManyFieldLevelEncryptionEncryptionEntities(crate::types::error::TooManyFieldLevelEncryptionEncryptionEntities),
    /// <p>The maximum number of field patterns for field-level encryption have been created.</p>
    TooManyFieldLevelEncryptionFieldPatterns(crate::types::error::TooManyFieldLevelEncryptionFieldPatterns),
    /// <p>The maximum number of profiles for field-level encryption have been created.</p>
    TooManyFieldLevelEncryptionProfiles(crate::types::error::TooManyFieldLevelEncryptionProfiles),
    /// <p>The maximum number of query arg profiles for field-level encryption have been created.</p>
    TooManyFieldLevelEncryptionQueryArgProfiles(crate::types::error::TooManyFieldLevelEncryptionQueryArgProfiles),
    /// <p>You have reached the maximum number of CloudFront function associations for this distribution. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
    TooManyFunctionAssociations(crate::types::error::TooManyFunctionAssociations),
    /// <p>You have reached the maximum number of CloudFront functions for this Amazon Web Services account. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
    TooManyFunctions(crate::types::error::TooManyFunctions),
    /// <p>The number of headers in the cache policy exceeds the maximum. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
    TooManyHeadersInCachePolicy(crate::types::error::TooManyHeadersInCachePolicy),
    /// <p>Your request contains too many headers in forwarded values.</p>
    TooManyHeadersInForwardedValues(crate::types::error::TooManyHeadersInForwardedValues),
    /// <p>The number of headers in the origin request policy exceeds the maximum. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
    TooManyHeadersInOriginRequestPolicy(crate::types::error::TooManyHeadersInOriginRequestPolicy),
    /// <p>You have exceeded the maximum number of allowable InProgress invalidation batch requests, or invalidation objects.</p>
    TooManyInvalidationsInProgress(crate::types::error::TooManyInvalidationsInProgress),
    /// <p>You have reached the maximum number of key groups for this Amazon Web Services account. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
    TooManyKeyGroups(crate::types::error::TooManyKeyGroups),
    /// <p>The number of key groups referenced by this distribution is more than the maximum allowed. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
    TooManyKeyGroupsAssociatedToDistribution(crate::types::error::TooManyKeyGroupsAssociatedToDistribution),
    /// <p>Your request contains more Lambda@Edge function associations than are allowed per distribution.</p>
    TooManyLambdaFunctionAssociations(crate::types::error::TooManyLambdaFunctionAssociations),
    /// <p>The number of origin access controls in your Amazon Web Services account exceeds the maximum allowed.</p> 
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
    TooManyOriginAccessControls(crate::types::error::TooManyOriginAccessControls),
    /// <p>Your request contains too many origin custom headers.</p>
    TooManyOriginCustomHeaders(crate::types::error::TooManyOriginCustomHeaders),
    /// <p>Processing your request would cause you to exceed the maximum number of origin groups allowed.</p>
    TooManyOriginGroupsPerDistribution(crate::types::error::TooManyOriginGroupsPerDistribution),
    /// <p>You have reached the maximum number of origin request policies for this Amazon Web Services account. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
    TooManyOriginRequestPolicies(crate::types::error::TooManyOriginRequestPolicies),
    /// <p>You cannot create more origins for the distribution.</p>
    TooManyOrigins(crate::types::error::TooManyOrigins),
    /// <p>The maximum number of public keys for field-level encryption have been created. To create a new public key, delete one of the existing keys.</p>
    TooManyPublicKeys(crate::types::error::TooManyPublicKeys),
    /// <p>The number of public keys in this key group is more than the maximum allowed. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
    TooManyPublicKeysInKeyGroup(crate::types::error::TooManyPublicKeysInKeyGroup),
    /// <p>Your request contains too many query string parameters.</p>
    TooManyQueryStringParameters(crate::types::error::TooManyQueryStringParameters),
    /// <p>The number of query strings in the cache policy exceeds the maximum. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
    TooManyQueryStringsInCachePolicy(crate::types::error::TooManyQueryStringsInCachePolicy),
    /// <p>The number of query strings in the origin request policy exceeds the maximum. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
    TooManyQueryStringsInOriginRequestPolicy(crate::types::error::TooManyQueryStringsInOriginRequestPolicy),
    /// <p>You have reached the maximum number of real-time log configurations for this Amazon Web Services account. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
    TooManyRealtimeLogConfigs(crate::types::error::TooManyRealtimeLogConfigs),
    /// <p>The number of headers in <code>RemoveHeadersConfig</code> in the response headers policy exceeds the maximum.</p> 
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
    TooManyRemoveHeadersInResponseHeadersPolicy(crate::types::error::TooManyRemoveHeadersInResponseHeadersPolicy),
    /// <p>You have reached the maximum number of response headers policies for this Amazon Web Services account.</p> 
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
    TooManyResponseHeadersPolicies(crate::types::error::TooManyResponseHeadersPolicies),
    /// <p>Your request contains more CNAMEs than are allowed per distribution.</p>
    TooManyStreamingDistributionCnamEs(crate::types::error::TooManyStreamingDistributionCnamEs),
    /// <p>Processing your request would cause you to exceed the maximum number of streaming distributions allowed.</p>
    TooManyStreamingDistributions(crate::types::error::TooManyStreamingDistributions),
    /// <p>Your request contains more trusted signers than are allowed per distribution.</p>
    TooManyTrustedSigners(crate::types::error::TooManyTrustedSigners),
    /// <p>The specified key group does not exist.</p>
    TrustedKeyGroupDoesNotExist(crate::types::error::TrustedKeyGroupDoesNotExist),
    /// <p>One or more of your trusted signers don't exist.</p>
    TrustedSignerDoesNotExist(crate::types::error::TrustedSignerDoesNotExist),
    /// <p>This operation is not supported in this region.</p>
    UnsupportedOperation(crate::types::error::UnsupportedOperation),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled)
}
impl std::fmt::Display for Error {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Error::AccessDenied(inner) => inner.fmt(f),
            Error::BatchTooLarge(inner) => inner.fmt(f),
            Error::CnameAlreadyExists(inner) => inner.fmt(f),
            Error::CachePolicyAlreadyExists(inner) => inner.fmt(f),
            Error::CachePolicyInUse(inner) => inner.fmt(f),
            Error::CannotChangeImmutablePublicKeyFields(inner) => inner.fmt(f),
            Error::CloudFrontOriginAccessIdentityAlreadyExists(inner) => inner.fmt(f),
            Error::CloudFrontOriginAccessIdentityInUse(inner) => inner.fmt(f),
            Error::ContinuousDeploymentPolicyAlreadyExists(inner) => inner.fmt(f),
            Error::ContinuousDeploymentPolicyInUse(inner) => inner.fmt(f),
            Error::DistributionAlreadyExists(inner) => inner.fmt(f),
            Error::DistributionNotDisabled(inner) => inner.fmt(f),
            Error::FieldLevelEncryptionConfigAlreadyExists(inner) => inner.fmt(f),
            Error::FieldLevelEncryptionConfigInUse(inner) => inner.fmt(f),
            Error::FieldLevelEncryptionProfileAlreadyExists(inner) => inner.fmt(f),
            Error::FieldLevelEncryptionProfileInUse(inner) => inner.fmt(f),
            Error::FieldLevelEncryptionProfileSizeExceeded(inner) => inner.fmt(f),
            Error::FunctionAlreadyExists(inner) => inner.fmt(f),
            Error::FunctionInUse(inner) => inner.fmt(f),
            Error::FunctionSizeLimitExceeded(inner) => inner.fmt(f),
            Error::IllegalDelete(inner) => inner.fmt(f),
            Error::IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior(inner) => inner.fmt(f),
            Error::IllegalOriginAccessConfiguration(inner) => inner.fmt(f),
            Error::IllegalUpdate(inner) => inner.fmt(f),
            Error::InconsistentQuantities(inner) => inner.fmt(f),
            Error::InvalidArgument(inner) => inner.fmt(f),
            Error::InvalidDefaultRootObject(inner) => inner.fmt(f),
            Error::InvalidDomainNameForOriginAccessControl(inner) => inner.fmt(f),
            Error::InvalidErrorCode(inner) => inner.fmt(f),
            Error::InvalidForwardCookies(inner) => inner.fmt(f),
            Error::InvalidFunctionAssociation(inner) => inner.fmt(f),
            Error::InvalidGeoRestrictionParameter(inner) => inner.fmt(f),
            Error::InvalidHeadersForS3Origin(inner) => inner.fmt(f),
            Error::InvalidIfMatchVersion(inner) => inner.fmt(f),
            Error::InvalidLambdaFunctionAssociation(inner) => inner.fmt(f),
            Error::InvalidLocationCode(inner) => inner.fmt(f),
            Error::InvalidMinimumProtocolVersion(inner) => inner.fmt(f),
            Error::InvalidOrigin(inner) => inner.fmt(f),
            Error::InvalidOriginAccessControl(inner) => inner.fmt(f),
            Error::InvalidOriginAccessIdentity(inner) => inner.fmt(f),
            Error::InvalidOriginKeepaliveTimeout(inner) => inner.fmt(f),
            Error::InvalidOriginReadTimeout(inner) => inner.fmt(f),
            Error::InvalidProtocolSettings(inner) => inner.fmt(f),
            Error::InvalidQueryStringParameters(inner) => inner.fmt(f),
            Error::InvalidRelativePath(inner) => inner.fmt(f),
            Error::InvalidRequiredProtocol(inner) => inner.fmt(f),
            Error::InvalidResponseCode(inner) => inner.fmt(f),
            Error::InvalidTtlOrder(inner) => inner.fmt(f),
            Error::InvalidTagging(inner) => inner.fmt(f),
            Error::InvalidViewerCertificate(inner) => inner.fmt(f),
            Error::InvalidWebAclId(inner) => inner.fmt(f),
            Error::KeyGroupAlreadyExists(inner) => inner.fmt(f),
            Error::MissingBody(inner) => inner.fmt(f),
            Error::MonitoringSubscriptionAlreadyExists(inner) => inner.fmt(f),
            Error::NoSuchCachePolicy(inner) => inner.fmt(f),
            Error::NoSuchCloudFrontOriginAccessIdentity(inner) => inner.fmt(f),
            Error::NoSuchContinuousDeploymentPolicy(inner) => inner.fmt(f),
            Error::NoSuchDistribution(inner) => inner.fmt(f),
            Error::NoSuchFieldLevelEncryptionConfig(inner) => inner.fmt(f),
            Error::NoSuchFieldLevelEncryptionProfile(inner) => inner.fmt(f),
            Error::NoSuchFunctionExists(inner) => inner.fmt(f),
            Error::NoSuchInvalidation(inner) => inner.fmt(f),
            Error::NoSuchMonitoringSubscription(inner) => inner.fmt(f),
            Error::NoSuchOrigin(inner) => inner.fmt(f),
            Error::NoSuchOriginAccessControl(inner) => inner.fmt(f),
            Error::NoSuchOriginRequestPolicy(inner) => inner.fmt(f),
            Error::NoSuchPublicKey(inner) => inner.fmt(f),
            Error::NoSuchRealtimeLogConfig(inner) => inner.fmt(f),
            Error::NoSuchResource(inner) => inner.fmt(f),
            Error::NoSuchResponseHeadersPolicy(inner) => inner.fmt(f),
            Error::NoSuchStreamingDistribution(inner) => inner.fmt(f),
            Error::OriginAccessControlAlreadyExists(inner) => inner.fmt(f),
            Error::OriginAccessControlInUse(inner) => inner.fmt(f),
            Error::OriginRequestPolicyAlreadyExists(inner) => inner.fmt(f),
            Error::OriginRequestPolicyInUse(inner) => inner.fmt(f),
            Error::PreconditionFailed(inner) => inner.fmt(f),
            Error::PublicKeyAlreadyExists(inner) => inner.fmt(f),
            Error::PublicKeyInUse(inner) => inner.fmt(f),
            Error::QueryArgProfileEmpty(inner) => inner.fmt(f),
            Error::RealtimeLogConfigAlreadyExists(inner) => inner.fmt(f),
            Error::RealtimeLogConfigInUse(inner) => inner.fmt(f),
            Error::RealtimeLogConfigOwnerMismatch(inner) => inner.fmt(f),
            Error::ResourceInUse(inner) => inner.fmt(f),
            Error::ResponseHeadersPolicyAlreadyExists(inner) => inner.fmt(f),
            Error::ResponseHeadersPolicyInUse(inner) => inner.fmt(f),
            Error::StagingDistributionInUse(inner) => inner.fmt(f),
            Error::StreamingDistributionAlreadyExists(inner) => inner.fmt(f),
            Error::StreamingDistributionNotDisabled(inner) => inner.fmt(f),
            Error::TestFunctionFailed(inner) => inner.fmt(f),
            Error::TooLongCspInResponseHeadersPolicy(inner) => inner.fmt(f),
            Error::TooManyCacheBehaviors(inner) => inner.fmt(f),
            Error::TooManyCachePolicies(inner) => inner.fmt(f),
            Error::TooManyCertificates(inner) => inner.fmt(f),
            Error::TooManyCloudFrontOriginAccessIdentities(inner) => inner.fmt(f),
            Error::TooManyContinuousDeploymentPolicies(inner) => inner.fmt(f),
            Error::TooManyCookieNamesInWhiteList(inner) => inner.fmt(f),
            Error::TooManyCookiesInCachePolicy(inner) => inner.fmt(f),
            Error::TooManyCookiesInOriginRequestPolicy(inner) => inner.fmt(f),
            Error::TooManyCustomHeadersInResponseHeadersPolicy(inner) => inner.fmt(f),
            Error::TooManyDistributionCnamEs(inner) => inner.fmt(f),
            Error::TooManyDistributions(inner) => inner.fmt(f),
            Error::TooManyDistributionsAssociatedToCachePolicy(inner) => inner.fmt(f),
            Error::TooManyDistributionsAssociatedToFieldLevelEncryptionConfig(inner) => inner.fmt(f),
            Error::TooManyDistributionsAssociatedToKeyGroup(inner) => inner.fmt(f),
            Error::TooManyDistributionsAssociatedToOriginAccessControl(inner) => inner.fmt(f),
            Error::TooManyDistributionsAssociatedToOriginRequestPolicy(inner) => inner.fmt(f),
            Error::TooManyDistributionsAssociatedToResponseHeadersPolicy(inner) => inner.fmt(f),
            Error::TooManyDistributionsWithFunctionAssociations(inner) => inner.fmt(f),
            Error::TooManyDistributionsWithLambdaAssociations(inner) => inner.fmt(f),
            Error::TooManyDistributionsWithSingleFunctionArn(inner) => inner.fmt(f),
            Error::TooManyFieldLevelEncryptionConfigs(inner) => inner.fmt(f),
            Error::TooManyFieldLevelEncryptionContentTypeProfiles(inner) => inner.fmt(f),
            Error::TooManyFieldLevelEncryptionEncryptionEntities(inner) => inner.fmt(f),
            Error::TooManyFieldLevelEncryptionFieldPatterns(inner) => inner.fmt(f),
            Error::TooManyFieldLevelEncryptionProfiles(inner) => inner.fmt(f),
            Error::TooManyFieldLevelEncryptionQueryArgProfiles(inner) => inner.fmt(f),
            Error::TooManyFunctionAssociations(inner) => inner.fmt(f),
            Error::TooManyFunctions(inner) => inner.fmt(f),
            Error::TooManyHeadersInCachePolicy(inner) => inner.fmt(f),
            Error::TooManyHeadersInForwardedValues(inner) => inner.fmt(f),
            Error::TooManyHeadersInOriginRequestPolicy(inner) => inner.fmt(f),
            Error::TooManyInvalidationsInProgress(inner) => inner.fmt(f),
            Error::TooManyKeyGroups(inner) => inner.fmt(f),
            Error::TooManyKeyGroupsAssociatedToDistribution(inner) => inner.fmt(f),
            Error::TooManyLambdaFunctionAssociations(inner) => inner.fmt(f),
            Error::TooManyOriginAccessControls(inner) => inner.fmt(f),
            Error::TooManyOriginCustomHeaders(inner) => inner.fmt(f),
            Error::TooManyOriginGroupsPerDistribution(inner) => inner.fmt(f),
            Error::TooManyOriginRequestPolicies(inner) => inner.fmt(f),
            Error::TooManyOrigins(inner) => inner.fmt(f),
            Error::TooManyPublicKeys(inner) => inner.fmt(f),
            Error::TooManyPublicKeysInKeyGroup(inner) => inner.fmt(f),
            Error::TooManyQueryStringParameters(inner) => inner.fmt(f),
            Error::TooManyQueryStringsInCachePolicy(inner) => inner.fmt(f),
            Error::TooManyQueryStringsInOriginRequestPolicy(inner) => inner.fmt(f),
            Error::TooManyRealtimeLogConfigs(inner) => inner.fmt(f),
            Error::TooManyRemoveHeadersInResponseHeadersPolicy(inner) => inner.fmt(f),
            Error::TooManyResponseHeadersPolicies(inner) => inner.fmt(f),
            Error::TooManyStreamingDistributionCnamEs(inner) => inner.fmt(f),
            Error::TooManyStreamingDistributions(inner) => inner.fmt(f),
            Error::TooManyTrustedSigners(inner) => inner.fmt(f),
            Error::TrustedKeyGroupDoesNotExist(inner) => inner.fmt(f),
            Error::TrustedSignerDoesNotExist(inner) => inner.fmt(f),
            Error::UnsupportedOperation(inner) => inner.fmt(f),
            Error::Unhandled(inner) => inner.fmt(f)
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::associate_alias::AssociateAliasError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::associate_alias::AssociateAliasError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::associate_alias::AssociateAliasError> for Error {
    fn from(err: crate::operation::associate_alias::AssociateAliasError) -> Self {
        match err {
            crate::operation::associate_alias::AssociateAliasError::AccessDenied(inner) => Error::AccessDenied(inner),
            crate::operation::associate_alias::AssociateAliasError::IllegalUpdate(inner) => Error::IllegalUpdate(inner),
            crate::operation::associate_alias::AssociateAliasError::InvalidArgument(inner) => Error::InvalidArgument(inner),
            crate::operation::associate_alias::AssociateAliasError::NoSuchDistribution(inner) => Error::NoSuchDistribution(inner),
            crate::operation::associate_alias::AssociateAliasError::TooManyDistributionCnamEs(inner) => Error::TooManyDistributionCnamEs(inner),
            crate::operation::associate_alias::AssociateAliasError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::copy_distribution::CopyDistributionError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::copy_distribution::CopyDistributionError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::copy_distribution::CopyDistributionError> for Error {
    fn from(err: crate::operation::copy_distribution::CopyDistributionError) -> Self {
        match err {
            crate::operation::copy_distribution::CopyDistributionError::AccessDenied(inner) => Error::AccessDenied(inner),
            crate::operation::copy_distribution::CopyDistributionError::CnameAlreadyExists(inner) => Error::CnameAlreadyExists(inner),
            crate::operation::copy_distribution::CopyDistributionError::DistributionAlreadyExists(inner) => Error::DistributionAlreadyExists(inner),
            crate::operation::copy_distribution::CopyDistributionError::IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior(inner) => Error::IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior(inner),
            crate::operation::copy_distribution::CopyDistributionError::InconsistentQuantities(inner) => Error::InconsistentQuantities(inner),
            crate::operation::copy_distribution::CopyDistributionError::InvalidArgument(inner) => Error::InvalidArgument(inner),
            crate::operation::copy_distribution::CopyDistributionError::InvalidDefaultRootObject(inner) => Error::InvalidDefaultRootObject(inner),
            crate::operation::copy_distribution::CopyDistributionError::InvalidErrorCode(inner) => Error::InvalidErrorCode(inner),
            crate::operation::copy_distribution::CopyDistributionError::InvalidForwardCookies(inner) => Error::InvalidForwardCookies(inner),
            crate::operation::copy_distribution::CopyDistributionError::InvalidFunctionAssociation(inner) => Error::InvalidFunctionAssociation(inner),
            crate::operation::copy_distribution::CopyDistributionError::InvalidGeoRestrictionParameter(inner) => Error::InvalidGeoRestrictionParameter(inner),
            crate::operation::copy_distribution::CopyDistributionError::InvalidHeadersForS3Origin(inner) => Error::InvalidHeadersForS3Origin(inner),
            crate::operation::copy_distribution::CopyDistributionError::InvalidIfMatchVersion(inner) => Error::InvalidIfMatchVersion(inner),
            crate::operation::copy_distribution::CopyDistributionError::InvalidLambdaFunctionAssociation(inner) => Error::InvalidLambdaFunctionAssociation(inner),
            crate::operation::copy_distribution::CopyDistributionError::InvalidLocationCode(inner) => Error::InvalidLocationCode(inner),
            crate::operation::copy_distribution::CopyDistributionError::InvalidMinimumProtocolVersion(inner) => Error::InvalidMinimumProtocolVersion(inner),
            crate::operation::copy_distribution::CopyDistributionError::InvalidOrigin(inner) => Error::InvalidOrigin(inner),
            crate::operation::copy_distribution::CopyDistributionError::InvalidOriginAccessControl(inner) => Error::InvalidOriginAccessControl(inner),
            crate::operation::copy_distribution::CopyDistributionError::InvalidOriginAccessIdentity(inner) => Error::InvalidOriginAccessIdentity(inner),
            crate::operation::copy_distribution::CopyDistributionError::InvalidOriginKeepaliveTimeout(inner) => Error::InvalidOriginKeepaliveTimeout(inner),
            crate::operation::copy_distribution::CopyDistributionError::InvalidOriginReadTimeout(inner) => Error::InvalidOriginReadTimeout(inner),
            crate::operation::copy_distribution::CopyDistributionError::InvalidProtocolSettings(inner) => Error::InvalidProtocolSettings(inner),
            crate::operation::copy_distribution::CopyDistributionError::InvalidQueryStringParameters(inner) => Error::InvalidQueryStringParameters(inner),
            crate::operation::copy_distribution::CopyDistributionError::InvalidRelativePath(inner) => Error::InvalidRelativePath(inner),
            crate::operation::copy_distribution::CopyDistributionError::InvalidRequiredProtocol(inner) => Error::InvalidRequiredProtocol(inner),
            crate::operation::copy_distribution::CopyDistributionError::InvalidResponseCode(inner) => Error::InvalidResponseCode(inner),
            crate::operation::copy_distribution::CopyDistributionError::InvalidTtlOrder(inner) => Error::InvalidTtlOrder(inner),
            crate::operation::copy_distribution::CopyDistributionError::InvalidViewerCertificate(inner) => Error::InvalidViewerCertificate(inner),
            crate::operation::copy_distribution::CopyDistributionError::InvalidWebAclId(inner) => Error::InvalidWebAclId(inner),
            crate::operation::copy_distribution::CopyDistributionError::MissingBody(inner) => Error::MissingBody(inner),
            crate::operation::copy_distribution::CopyDistributionError::NoSuchCachePolicy(inner) => Error::NoSuchCachePolicy(inner),
            crate::operation::copy_distribution::CopyDistributionError::NoSuchDistribution(inner) => Error::NoSuchDistribution(inner),
            crate::operation::copy_distribution::CopyDistributionError::NoSuchFieldLevelEncryptionConfig(inner) => Error::NoSuchFieldLevelEncryptionConfig(inner),
            crate::operation::copy_distribution::CopyDistributionError::NoSuchOrigin(inner) => Error::NoSuchOrigin(inner),
            crate::operation::copy_distribution::CopyDistributionError::NoSuchOriginRequestPolicy(inner) => Error::NoSuchOriginRequestPolicy(inner),
            crate::operation::copy_distribution::CopyDistributionError::NoSuchRealtimeLogConfig(inner) => Error::NoSuchRealtimeLogConfig(inner),
            crate::operation::copy_distribution::CopyDistributionError::NoSuchResponseHeadersPolicy(inner) => Error::NoSuchResponseHeadersPolicy(inner),
            crate::operation::copy_distribution::CopyDistributionError::PreconditionFailed(inner) => Error::PreconditionFailed(inner),
            crate::operation::copy_distribution::CopyDistributionError::RealtimeLogConfigOwnerMismatch(inner) => Error::RealtimeLogConfigOwnerMismatch(inner),
            crate::operation::copy_distribution::CopyDistributionError::TooManyCacheBehaviors(inner) => Error::TooManyCacheBehaviors(inner),
            crate::operation::copy_distribution::CopyDistributionError::TooManyCertificates(inner) => Error::TooManyCertificates(inner),
            crate::operation::copy_distribution::CopyDistributionError::TooManyCookieNamesInWhiteList(inner) => Error::TooManyCookieNamesInWhiteList(inner),
            crate::operation::copy_distribution::CopyDistributionError::TooManyDistributionCnamEs(inner) => Error::TooManyDistributionCnamEs(inner),
            crate::operation::copy_distribution::CopyDistributionError::TooManyDistributions(inner) => Error::TooManyDistributions(inner),
            crate::operation::copy_distribution::CopyDistributionError::TooManyDistributionsAssociatedToCachePolicy(inner) => Error::TooManyDistributionsAssociatedToCachePolicy(inner),
            crate::operation::copy_distribution::CopyDistributionError::TooManyDistributionsAssociatedToFieldLevelEncryptionConfig(inner) => Error::TooManyDistributionsAssociatedToFieldLevelEncryptionConfig(inner),
            crate::operation::copy_distribution::CopyDistributionError::TooManyDistributionsAssociatedToKeyGroup(inner) => Error::TooManyDistributionsAssociatedToKeyGroup(inner),
            crate::operation::copy_distribution::CopyDistributionError::TooManyDistributionsAssociatedToOriginRequestPolicy(inner) => Error::TooManyDistributionsAssociatedToOriginRequestPolicy(inner),
            crate::operation::copy_distribution::CopyDistributionError::TooManyDistributionsAssociatedToResponseHeadersPolicy(inner) => Error::TooManyDistributionsAssociatedToResponseHeadersPolicy(inner),
            crate::operation::copy_distribution::CopyDistributionError::TooManyDistributionsWithFunctionAssociations(inner) => Error::TooManyDistributionsWithFunctionAssociations(inner),
            crate::operation::copy_distribution::CopyDistributionError::TooManyDistributionsWithLambdaAssociations(inner) => Error::TooManyDistributionsWithLambdaAssociations(inner),
            crate::operation::copy_distribution::CopyDistributionError::TooManyDistributionsWithSingleFunctionArn(inner) => Error::TooManyDistributionsWithSingleFunctionArn(inner),
            crate::operation::copy_distribution::CopyDistributionError::TooManyFunctionAssociations(inner) => Error::TooManyFunctionAssociations(inner),
            crate::operation::copy_distribution::CopyDistributionError::TooManyHeadersInForwardedValues(inner) => Error::TooManyHeadersInForwardedValues(inner),
            crate::operation::copy_distribution::CopyDistributionError::TooManyKeyGroupsAssociatedToDistribution(inner) => Error::TooManyKeyGroupsAssociatedToDistribution(inner),
            crate::operation::copy_distribution::CopyDistributionError::TooManyLambdaFunctionAssociations(inner) => Error::TooManyLambdaFunctionAssociations(inner),
            crate::operation::copy_distribution::CopyDistributionError::TooManyOriginCustomHeaders(inner) => Error::TooManyOriginCustomHeaders(inner),
            crate::operation::copy_distribution::CopyDistributionError::TooManyOriginGroupsPerDistribution(inner) => Error::TooManyOriginGroupsPerDistribution(inner),
            crate::operation::copy_distribution::CopyDistributionError::TooManyOrigins(inner) => Error::TooManyOrigins(inner),
            crate::operation::copy_distribution::CopyDistributionError::TooManyQueryStringParameters(inner) => Error::TooManyQueryStringParameters(inner),
            crate::operation::copy_distribution::CopyDistributionError::TooManyTrustedSigners(inner) => Error::TooManyTrustedSigners(inner),
            crate::operation::copy_distribution::CopyDistributionError::TrustedKeyGroupDoesNotExist(inner) => Error::TrustedKeyGroupDoesNotExist(inner),
            crate::operation::copy_distribution::CopyDistributionError::TrustedSignerDoesNotExist(inner) => Error::TrustedSignerDoesNotExist(inner),
            crate::operation::copy_distribution::CopyDistributionError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::create_cache_policy::CreateCachePolicyError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::create_cache_policy::CreateCachePolicyError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::create_cache_policy::CreateCachePolicyError> for Error {
    fn from(err: crate::operation::create_cache_policy::CreateCachePolicyError) -> Self {
        match err {
            crate::operation::create_cache_policy::CreateCachePolicyError::AccessDenied(inner) => Error::AccessDenied(inner),
            crate::operation::create_cache_policy::CreateCachePolicyError::CachePolicyAlreadyExists(inner) => Error::CachePolicyAlreadyExists(inner),
            crate::operation::create_cache_policy::CreateCachePolicyError::InconsistentQuantities(inner) => Error::InconsistentQuantities(inner),
            crate::operation::create_cache_policy::CreateCachePolicyError::InvalidArgument(inner) => Error::InvalidArgument(inner),
            crate::operation::create_cache_policy::CreateCachePolicyError::TooManyCachePolicies(inner) => Error::TooManyCachePolicies(inner),
            crate::operation::create_cache_policy::CreateCachePolicyError::TooManyCookiesInCachePolicy(inner) => Error::TooManyCookiesInCachePolicy(inner),
            crate::operation::create_cache_policy::CreateCachePolicyError::TooManyHeadersInCachePolicy(inner) => Error::TooManyHeadersInCachePolicy(inner),
            crate::operation::create_cache_policy::CreateCachePolicyError::TooManyQueryStringsInCachePolicy(inner) => Error::TooManyQueryStringsInCachePolicy(inner),
            crate::operation::create_cache_policy::CreateCachePolicyError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::create_cloud_front_origin_access_identity::CreateCloudFrontOriginAccessIdentityError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::create_cloud_front_origin_access_identity::CreateCloudFrontOriginAccessIdentityError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::create_cloud_front_origin_access_identity::CreateCloudFrontOriginAccessIdentityError> for Error {
    fn from(err: crate::operation::create_cloud_front_origin_access_identity::CreateCloudFrontOriginAccessIdentityError) -> Self {
        match err {
            crate::operation::create_cloud_front_origin_access_identity::CreateCloudFrontOriginAccessIdentityError::CloudFrontOriginAccessIdentityAlreadyExists(inner) => Error::CloudFrontOriginAccessIdentityAlreadyExists(inner),
            crate::operation::create_cloud_front_origin_access_identity::CreateCloudFrontOriginAccessIdentityError::InconsistentQuantities(inner) => Error::InconsistentQuantities(inner),
            crate::operation::create_cloud_front_origin_access_identity::CreateCloudFrontOriginAccessIdentityError::InvalidArgument(inner) => Error::InvalidArgument(inner),
            crate::operation::create_cloud_front_origin_access_identity::CreateCloudFrontOriginAccessIdentityError::MissingBody(inner) => Error::MissingBody(inner),
            crate::operation::create_cloud_front_origin_access_identity::CreateCloudFrontOriginAccessIdentityError::TooManyCloudFrontOriginAccessIdentities(inner) => Error::TooManyCloudFrontOriginAccessIdentities(inner),
            crate::operation::create_cloud_front_origin_access_identity::CreateCloudFrontOriginAccessIdentityError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::create_continuous_deployment_policy::CreateContinuousDeploymentPolicyError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::create_continuous_deployment_policy::CreateContinuousDeploymentPolicyError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::create_continuous_deployment_policy::CreateContinuousDeploymentPolicyError> for Error {
    fn from(err: crate::operation::create_continuous_deployment_policy::CreateContinuousDeploymentPolicyError) -> Self {
        match err {
            crate::operation::create_continuous_deployment_policy::CreateContinuousDeploymentPolicyError::AccessDenied(inner) => Error::AccessDenied(inner),
            crate::operation::create_continuous_deployment_policy::CreateContinuousDeploymentPolicyError::ContinuousDeploymentPolicyAlreadyExists(inner) => Error::ContinuousDeploymentPolicyAlreadyExists(inner),
            crate::operation::create_continuous_deployment_policy::CreateContinuousDeploymentPolicyError::InconsistentQuantities(inner) => Error::InconsistentQuantities(inner),
            crate::operation::create_continuous_deployment_policy::CreateContinuousDeploymentPolicyError::InvalidArgument(inner) => Error::InvalidArgument(inner),
            crate::operation::create_continuous_deployment_policy::CreateContinuousDeploymentPolicyError::StagingDistributionInUse(inner) => Error::StagingDistributionInUse(inner),
            crate::operation::create_continuous_deployment_policy::CreateContinuousDeploymentPolicyError::TooManyContinuousDeploymentPolicies(inner) => Error::TooManyContinuousDeploymentPolicies(inner),
            crate::operation::create_continuous_deployment_policy::CreateContinuousDeploymentPolicyError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::create_distribution::CreateDistributionError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::create_distribution::CreateDistributionError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::create_distribution::CreateDistributionError> for Error {
    fn from(err: crate::operation::create_distribution::CreateDistributionError) -> Self {
        match err {
            crate::operation::create_distribution::CreateDistributionError::AccessDenied(inner) => Error::AccessDenied(inner),
            crate::operation::create_distribution::CreateDistributionError::CnameAlreadyExists(inner) => Error::CnameAlreadyExists(inner),
            crate::operation::create_distribution::CreateDistributionError::ContinuousDeploymentPolicyInUse(inner) => Error::ContinuousDeploymentPolicyInUse(inner),
            crate::operation::create_distribution::CreateDistributionError::DistributionAlreadyExists(inner) => Error::DistributionAlreadyExists(inner),
            crate::operation::create_distribution::CreateDistributionError::IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior(inner) => Error::IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior(inner),
            crate::operation::create_distribution::CreateDistributionError::IllegalOriginAccessConfiguration(inner) => Error::IllegalOriginAccessConfiguration(inner),
            crate::operation::create_distribution::CreateDistributionError::InconsistentQuantities(inner) => Error::InconsistentQuantities(inner),
            crate::operation::create_distribution::CreateDistributionError::InvalidArgument(inner) => Error::InvalidArgument(inner),
            crate::operation::create_distribution::CreateDistributionError::InvalidDefaultRootObject(inner) => Error::InvalidDefaultRootObject(inner),
            crate::operation::create_distribution::CreateDistributionError::InvalidDomainNameForOriginAccessControl(inner) => Error::InvalidDomainNameForOriginAccessControl(inner),
            crate::operation::create_distribution::CreateDistributionError::InvalidErrorCode(inner) => Error::InvalidErrorCode(inner),
            crate::operation::create_distribution::CreateDistributionError::InvalidForwardCookies(inner) => Error::InvalidForwardCookies(inner),
            crate::operation::create_distribution::CreateDistributionError::InvalidFunctionAssociation(inner) => Error::InvalidFunctionAssociation(inner),
            crate::operation::create_distribution::CreateDistributionError::InvalidGeoRestrictionParameter(inner) => Error::InvalidGeoRestrictionParameter(inner),
            crate::operation::create_distribution::CreateDistributionError::InvalidHeadersForS3Origin(inner) => Error::InvalidHeadersForS3Origin(inner),
            crate::operation::create_distribution::CreateDistributionError::InvalidLambdaFunctionAssociation(inner) => Error::InvalidLambdaFunctionAssociation(inner),
            crate::operation::create_distribution::CreateDistributionError::InvalidLocationCode(inner) => Error::InvalidLocationCode(inner),
            crate::operation::create_distribution::CreateDistributionError::InvalidMinimumProtocolVersion(inner) => Error::InvalidMinimumProtocolVersion(inner),
            crate::operation::create_distribution::CreateDistributionError::InvalidOrigin(inner) => Error::InvalidOrigin(inner),
            crate::operation::create_distribution::CreateDistributionError::InvalidOriginAccessControl(inner) => Error::InvalidOriginAccessControl(inner),
            crate::operation::create_distribution::CreateDistributionError::InvalidOriginAccessIdentity(inner) => Error::InvalidOriginAccessIdentity(inner),
            crate::operation::create_distribution::CreateDistributionError::InvalidOriginKeepaliveTimeout(inner) => Error::InvalidOriginKeepaliveTimeout(inner),
            crate::operation::create_distribution::CreateDistributionError::InvalidOriginReadTimeout(inner) => Error::InvalidOriginReadTimeout(inner),
            crate::operation::create_distribution::CreateDistributionError::InvalidProtocolSettings(inner) => Error::InvalidProtocolSettings(inner),
            crate::operation::create_distribution::CreateDistributionError::InvalidQueryStringParameters(inner) => Error::InvalidQueryStringParameters(inner),
            crate::operation::create_distribution::CreateDistributionError::InvalidRelativePath(inner) => Error::InvalidRelativePath(inner),
            crate::operation::create_distribution::CreateDistributionError::InvalidRequiredProtocol(inner) => Error::InvalidRequiredProtocol(inner),
            crate::operation::create_distribution::CreateDistributionError::InvalidResponseCode(inner) => Error::InvalidResponseCode(inner),
            crate::operation::create_distribution::CreateDistributionError::InvalidTtlOrder(inner) => Error::InvalidTtlOrder(inner),
            crate::operation::create_distribution::CreateDistributionError::InvalidViewerCertificate(inner) => Error::InvalidViewerCertificate(inner),
            crate::operation::create_distribution::CreateDistributionError::InvalidWebAclId(inner) => Error::InvalidWebAclId(inner),
            crate::operation::create_distribution::CreateDistributionError::MissingBody(inner) => Error::MissingBody(inner),
            crate::operation::create_distribution::CreateDistributionError::NoSuchCachePolicy(inner) => Error::NoSuchCachePolicy(inner),
            crate::operation::create_distribution::CreateDistributionError::NoSuchContinuousDeploymentPolicy(inner) => Error::NoSuchContinuousDeploymentPolicy(inner),
            crate::operation::create_distribution::CreateDistributionError::NoSuchFieldLevelEncryptionConfig(inner) => Error::NoSuchFieldLevelEncryptionConfig(inner),
            crate::operation::create_distribution::CreateDistributionError::NoSuchOrigin(inner) => Error::NoSuchOrigin(inner),
            crate::operation::create_distribution::CreateDistributionError::NoSuchOriginRequestPolicy(inner) => Error::NoSuchOriginRequestPolicy(inner),
            crate::operation::create_distribution::CreateDistributionError::NoSuchRealtimeLogConfig(inner) => Error::NoSuchRealtimeLogConfig(inner),
            crate::operation::create_distribution::CreateDistributionError::NoSuchResponseHeadersPolicy(inner) => Error::NoSuchResponseHeadersPolicy(inner),
            crate::operation::create_distribution::CreateDistributionError::RealtimeLogConfigOwnerMismatch(inner) => Error::RealtimeLogConfigOwnerMismatch(inner),
            crate::operation::create_distribution::CreateDistributionError::TooManyCacheBehaviors(inner) => Error::TooManyCacheBehaviors(inner),
            crate::operation::create_distribution::CreateDistributionError::TooManyCertificates(inner) => Error::TooManyCertificates(inner),
            crate::operation::create_distribution::CreateDistributionError::TooManyCookieNamesInWhiteList(inner) => Error::TooManyCookieNamesInWhiteList(inner),
            crate::operation::create_distribution::CreateDistributionError::TooManyDistributionCnamEs(inner) => Error::TooManyDistributionCnamEs(inner),
            crate::operation::create_distribution::CreateDistributionError::TooManyDistributions(inner) => Error::TooManyDistributions(inner),
            crate::operation::create_distribution::CreateDistributionError::TooManyDistributionsAssociatedToCachePolicy(inner) => Error::TooManyDistributionsAssociatedToCachePolicy(inner),
            crate::operation::create_distribution::CreateDistributionError::TooManyDistributionsAssociatedToFieldLevelEncryptionConfig(inner) => Error::TooManyDistributionsAssociatedToFieldLevelEncryptionConfig(inner),
            crate::operation::create_distribution::CreateDistributionError::TooManyDistributionsAssociatedToKeyGroup(inner) => Error::TooManyDistributionsAssociatedToKeyGroup(inner),
            crate::operation::create_distribution::CreateDistributionError::TooManyDistributionsAssociatedToOriginAccessControl(inner) => Error::TooManyDistributionsAssociatedToOriginAccessControl(inner),
            crate::operation::create_distribution::CreateDistributionError::TooManyDistributionsAssociatedToOriginRequestPolicy(inner) => Error::TooManyDistributionsAssociatedToOriginRequestPolicy(inner),
            crate::operation::create_distribution::CreateDistributionError::TooManyDistributionsAssociatedToResponseHeadersPolicy(inner) => Error::TooManyDistributionsAssociatedToResponseHeadersPolicy(inner),
            crate::operation::create_distribution::CreateDistributionError::TooManyDistributionsWithFunctionAssociations(inner) => Error::TooManyDistributionsWithFunctionAssociations(inner),
            crate::operation::create_distribution::CreateDistributionError::TooManyDistributionsWithLambdaAssociations(inner) => Error::TooManyDistributionsWithLambdaAssociations(inner),
            crate::operation::create_distribution::CreateDistributionError::TooManyDistributionsWithSingleFunctionArn(inner) => Error::TooManyDistributionsWithSingleFunctionArn(inner),
            crate::operation::create_distribution::CreateDistributionError::TooManyFunctionAssociations(inner) => Error::TooManyFunctionAssociations(inner),
            crate::operation::create_distribution::CreateDistributionError::TooManyHeadersInForwardedValues(inner) => Error::TooManyHeadersInForwardedValues(inner),
            crate::operation::create_distribution::CreateDistributionError::TooManyKeyGroupsAssociatedToDistribution(inner) => Error::TooManyKeyGroupsAssociatedToDistribution(inner),
            crate::operation::create_distribution::CreateDistributionError::TooManyLambdaFunctionAssociations(inner) => Error::TooManyLambdaFunctionAssociations(inner),
            crate::operation::create_distribution::CreateDistributionError::TooManyOriginCustomHeaders(inner) => Error::TooManyOriginCustomHeaders(inner),
            crate::operation::create_distribution::CreateDistributionError::TooManyOriginGroupsPerDistribution(inner) => Error::TooManyOriginGroupsPerDistribution(inner),
            crate::operation::create_distribution::CreateDistributionError::TooManyOrigins(inner) => Error::TooManyOrigins(inner),
            crate::operation::create_distribution::CreateDistributionError::TooManyQueryStringParameters(inner) => Error::TooManyQueryStringParameters(inner),
            crate::operation::create_distribution::CreateDistributionError::TooManyTrustedSigners(inner) => Error::TooManyTrustedSigners(inner),
            crate::operation::create_distribution::CreateDistributionError::TrustedKeyGroupDoesNotExist(inner) => Error::TrustedKeyGroupDoesNotExist(inner),
            crate::operation::create_distribution::CreateDistributionError::TrustedSignerDoesNotExist(inner) => Error::TrustedSignerDoesNotExist(inner),
            crate::operation::create_distribution::CreateDistributionError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::create_distribution_with_tags::CreateDistributionWithTagsError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::create_distribution_with_tags::CreateDistributionWithTagsError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::create_distribution_with_tags::CreateDistributionWithTagsError> for Error {
    fn from(err: crate::operation::create_distribution_with_tags::CreateDistributionWithTagsError) -> Self {
        match err {
            crate::operation::create_distribution_with_tags::CreateDistributionWithTagsError::AccessDenied(inner) => Error::AccessDenied(inner),
            crate::operation::create_distribution_with_tags::CreateDistributionWithTagsError::CnameAlreadyExists(inner) => Error::CnameAlreadyExists(inner),
            crate::operation::create_distribution_with_tags::CreateDistributionWithTagsError::ContinuousDeploymentPolicyInUse(inner) => Error::ContinuousDeploymentPolicyInUse(inner),
            crate::operation::create_distribution_with_tags::CreateDistributionWithTagsError::DistributionAlreadyExists(inner) => Error::DistributionAlreadyExists(inner),
            crate::operation::create_distribution_with_tags::CreateDistributionWithTagsError::IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior(inner) => Error::IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior(inner),
            crate::operation::create_distribution_with_tags::CreateDistributionWithTagsError::InconsistentQuantities(inner) => Error::InconsistentQuantities(inner),
            crate::operation::create_distribution_with_tags::CreateDistributionWithTagsError::InvalidArgument(inner) => Error::InvalidArgument(inner),
            crate::operation::create_distribution_with_tags::CreateDistributionWithTagsError::InvalidDefaultRootObject(inner) => Error::InvalidDefaultRootObject(inner),
            crate::operation::create_distribution_with_tags::CreateDistributionWithTagsError::InvalidDomainNameForOriginAccessControl(inner) => Error::InvalidDomainNameForOriginAccessControl(inner),
            crate::operation::create_distribution_with_tags::CreateDistributionWithTagsError::InvalidErrorCode(inner) => Error::InvalidErrorCode(inner),
            crate::operation::create_distribution_with_tags::CreateDistributionWithTagsError::InvalidForwardCookies(inner) => Error::InvalidForwardCookies(inner),
            crate::operation::create_distribution_with_tags::CreateDistributionWithTagsError::InvalidFunctionAssociation(inner) => Error::InvalidFunctionAssociation(inner),
            crate::operation::create_distribution_with_tags::CreateDistributionWithTagsError::InvalidGeoRestrictionParameter(inner) => Error::InvalidGeoRestrictionParameter(inner),
            crate::operation::create_distribution_with_tags::CreateDistributionWithTagsError::InvalidHeadersForS3Origin(inner) => Error::InvalidHeadersForS3Origin(inner),
            crate::operation::create_distribution_with_tags::CreateDistributionWithTagsError::InvalidLambdaFunctionAssociation(inner) => Error::InvalidLambdaFunctionAssociation(inner),
            crate::operation::create_distribution_with_tags::CreateDistributionWithTagsError::InvalidLocationCode(inner) => Error::InvalidLocationCode(inner),
            crate::operation::create_distribution_with_tags::CreateDistributionWithTagsError::InvalidMinimumProtocolVersion(inner) => Error::InvalidMinimumProtocolVersion(inner),
            crate::operation::create_distribution_with_tags::CreateDistributionWithTagsError::InvalidOrigin(inner) => Error::InvalidOrigin(inner),
            crate::operation::create_distribution_with_tags::CreateDistributionWithTagsError::InvalidOriginAccessControl(inner) => Error::InvalidOriginAccessControl(inner),
            crate::operation::create_distribution_with_tags::CreateDistributionWithTagsError::InvalidOriginAccessIdentity(inner) => Error::InvalidOriginAccessIdentity(inner),
            crate::operation::create_distribution_with_tags::CreateDistributionWithTagsError::InvalidOriginKeepaliveTimeout(inner) => Error::InvalidOriginKeepaliveTimeout(inner),
            crate::operation::create_distribution_with_tags::CreateDistributionWithTagsError::InvalidOriginReadTimeout(inner) => Error::InvalidOriginReadTimeout(inner),
            crate::operation::create_distribution_with_tags::CreateDistributionWithTagsError::InvalidProtocolSettings(inner) => Error::InvalidProtocolSettings(inner),
            crate::operation::create_distribution_with_tags::CreateDistributionWithTagsError::InvalidQueryStringParameters(inner) => Error::InvalidQueryStringParameters(inner),
            crate::operation::create_distribution_with_tags::CreateDistributionWithTagsError::InvalidRelativePath(inner) => Error::InvalidRelativePath(inner),
            crate::operation::create_distribution_with_tags::CreateDistributionWithTagsError::InvalidRequiredProtocol(inner) => Error::InvalidRequiredProtocol(inner),
            crate::operation::create_distribution_with_tags::CreateDistributionWithTagsError::InvalidResponseCode(inner) => Error::InvalidResponseCode(inner),
            crate::operation::create_distribution_with_tags::CreateDistributionWithTagsError::InvalidTagging(inner) => Error::InvalidTagging(inner),
            crate::operation::create_distribution_with_tags::CreateDistributionWithTagsError::InvalidTtlOrder(inner) => Error::InvalidTtlOrder(inner),
            crate::operation::create_distribution_with_tags::CreateDistributionWithTagsError::InvalidViewerCertificate(inner) => Error::InvalidViewerCertificate(inner),
            crate::operation::create_distribution_with_tags::CreateDistributionWithTagsError::InvalidWebAclId(inner) => Error::InvalidWebAclId(inner),
            crate::operation::create_distribution_with_tags::CreateDistributionWithTagsError::MissingBody(inner) => Error::MissingBody(inner),
            crate::operation::create_distribution_with_tags::CreateDistributionWithTagsError::NoSuchCachePolicy(inner) => Error::NoSuchCachePolicy(inner),
            crate::operation::create_distribution_with_tags::CreateDistributionWithTagsError::NoSuchContinuousDeploymentPolicy(inner) => Error::NoSuchContinuousDeploymentPolicy(inner),
            crate::operation::create_distribution_with_tags::CreateDistributionWithTagsError::NoSuchFieldLevelEncryptionConfig(inner) => Error::NoSuchFieldLevelEncryptionConfig(inner),
            crate::operation::create_distribution_with_tags::CreateDistributionWithTagsError::NoSuchOrigin(inner) => Error::NoSuchOrigin(inner),
            crate::operation::create_distribution_with_tags::CreateDistributionWithTagsError::NoSuchOriginRequestPolicy(inner) => Error::NoSuchOriginRequestPolicy(inner),
            crate::operation::create_distribution_with_tags::CreateDistributionWithTagsError::NoSuchRealtimeLogConfig(inner) => Error::NoSuchRealtimeLogConfig(inner),
            crate::operation::create_distribution_with_tags::CreateDistributionWithTagsError::NoSuchResponseHeadersPolicy(inner) => Error::NoSuchResponseHeadersPolicy(inner),
            crate::operation::create_distribution_with_tags::CreateDistributionWithTagsError::RealtimeLogConfigOwnerMismatch(inner) => Error::RealtimeLogConfigOwnerMismatch(inner),
            crate::operation::create_distribution_with_tags::CreateDistributionWithTagsError::TooManyCacheBehaviors(inner) => Error::TooManyCacheBehaviors(inner),
            crate::operation::create_distribution_with_tags::CreateDistributionWithTagsError::TooManyCertificates(inner) => Error::TooManyCertificates(inner),
            crate::operation::create_distribution_with_tags::CreateDistributionWithTagsError::TooManyCookieNamesInWhiteList(inner) => Error::TooManyCookieNamesInWhiteList(inner),
            crate::operation::create_distribution_with_tags::CreateDistributionWithTagsError::TooManyDistributionCnamEs(inner) => Error::TooManyDistributionCnamEs(inner),
            crate::operation::create_distribution_with_tags::CreateDistributionWithTagsError::TooManyDistributions(inner) => Error::TooManyDistributions(inner),
            crate::operation::create_distribution_with_tags::CreateDistributionWithTagsError::TooManyDistributionsAssociatedToCachePolicy(inner) => Error::TooManyDistributionsAssociatedToCachePolicy(inner),
            crate::operation::create_distribution_with_tags::CreateDistributionWithTagsError::TooManyDistributionsAssociatedToFieldLevelEncryptionConfig(inner) => Error::TooManyDistributionsAssociatedToFieldLevelEncryptionConfig(inner),
            crate::operation::create_distribution_with_tags::CreateDistributionWithTagsError::TooManyDistributionsAssociatedToKeyGroup(inner) => Error::TooManyDistributionsAssociatedToKeyGroup(inner),
            crate::operation::create_distribution_with_tags::CreateDistributionWithTagsError::TooManyDistributionsAssociatedToOriginRequestPolicy(inner) => Error::TooManyDistributionsAssociatedToOriginRequestPolicy(inner),
            crate::operation::create_distribution_with_tags::CreateDistributionWithTagsError::TooManyDistributionsAssociatedToResponseHeadersPolicy(inner) => Error::TooManyDistributionsAssociatedToResponseHeadersPolicy(inner),
            crate::operation::create_distribution_with_tags::CreateDistributionWithTagsError::TooManyDistributionsWithFunctionAssociations(inner) => Error::TooManyDistributionsWithFunctionAssociations(inner),
            crate::operation::create_distribution_with_tags::CreateDistributionWithTagsError::TooManyDistributionsWithLambdaAssociations(inner) => Error::TooManyDistributionsWithLambdaAssociations(inner),
            crate::operation::create_distribution_with_tags::CreateDistributionWithTagsError::TooManyDistributionsWithSingleFunctionArn(inner) => Error::TooManyDistributionsWithSingleFunctionArn(inner),
            crate::operation::create_distribution_with_tags::CreateDistributionWithTagsError::TooManyFunctionAssociations(inner) => Error::TooManyFunctionAssociations(inner),
            crate::operation::create_distribution_with_tags::CreateDistributionWithTagsError::TooManyHeadersInForwardedValues(inner) => Error::TooManyHeadersInForwardedValues(inner),
            crate::operation::create_distribution_with_tags::CreateDistributionWithTagsError::TooManyKeyGroupsAssociatedToDistribution(inner) => Error::TooManyKeyGroupsAssociatedToDistribution(inner),
            crate::operation::create_distribution_with_tags::CreateDistributionWithTagsError::TooManyLambdaFunctionAssociations(inner) => Error::TooManyLambdaFunctionAssociations(inner),
            crate::operation::create_distribution_with_tags::CreateDistributionWithTagsError::TooManyOriginCustomHeaders(inner) => Error::TooManyOriginCustomHeaders(inner),
            crate::operation::create_distribution_with_tags::CreateDistributionWithTagsError::TooManyOriginGroupsPerDistribution(inner) => Error::TooManyOriginGroupsPerDistribution(inner),
            crate::operation::create_distribution_with_tags::CreateDistributionWithTagsError::TooManyOrigins(inner) => Error::TooManyOrigins(inner),
            crate::operation::create_distribution_with_tags::CreateDistributionWithTagsError::TooManyQueryStringParameters(inner) => Error::TooManyQueryStringParameters(inner),
            crate::operation::create_distribution_with_tags::CreateDistributionWithTagsError::TooManyTrustedSigners(inner) => Error::TooManyTrustedSigners(inner),
            crate::operation::create_distribution_with_tags::CreateDistributionWithTagsError::TrustedKeyGroupDoesNotExist(inner) => Error::TrustedKeyGroupDoesNotExist(inner),
            crate::operation::create_distribution_with_tags::CreateDistributionWithTagsError::TrustedSignerDoesNotExist(inner) => Error::TrustedSignerDoesNotExist(inner),
            crate::operation::create_distribution_with_tags::CreateDistributionWithTagsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::create_field_level_encryption_config::CreateFieldLevelEncryptionConfigError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::create_field_level_encryption_config::CreateFieldLevelEncryptionConfigError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::create_field_level_encryption_config::CreateFieldLevelEncryptionConfigError> for Error {
    fn from(err: crate::operation::create_field_level_encryption_config::CreateFieldLevelEncryptionConfigError) -> Self {
        match err {
            crate::operation::create_field_level_encryption_config::CreateFieldLevelEncryptionConfigError::FieldLevelEncryptionConfigAlreadyExists(inner) => Error::FieldLevelEncryptionConfigAlreadyExists(inner),
            crate::operation::create_field_level_encryption_config::CreateFieldLevelEncryptionConfigError::InconsistentQuantities(inner) => Error::InconsistentQuantities(inner),
            crate::operation::create_field_level_encryption_config::CreateFieldLevelEncryptionConfigError::InvalidArgument(inner) => Error::InvalidArgument(inner),
            crate::operation::create_field_level_encryption_config::CreateFieldLevelEncryptionConfigError::NoSuchFieldLevelEncryptionProfile(inner) => Error::NoSuchFieldLevelEncryptionProfile(inner),
            crate::operation::create_field_level_encryption_config::CreateFieldLevelEncryptionConfigError::QueryArgProfileEmpty(inner) => Error::QueryArgProfileEmpty(inner),
            crate::operation::create_field_level_encryption_config::CreateFieldLevelEncryptionConfigError::TooManyFieldLevelEncryptionConfigs(inner) => Error::TooManyFieldLevelEncryptionConfigs(inner),
            crate::operation::create_field_level_encryption_config::CreateFieldLevelEncryptionConfigError::TooManyFieldLevelEncryptionContentTypeProfiles(inner) => Error::TooManyFieldLevelEncryptionContentTypeProfiles(inner),
            crate::operation::create_field_level_encryption_config::CreateFieldLevelEncryptionConfigError::TooManyFieldLevelEncryptionQueryArgProfiles(inner) => Error::TooManyFieldLevelEncryptionQueryArgProfiles(inner),
            crate::operation::create_field_level_encryption_config::CreateFieldLevelEncryptionConfigError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::create_field_level_encryption_profile::CreateFieldLevelEncryptionProfileError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::create_field_level_encryption_profile::CreateFieldLevelEncryptionProfileError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::create_field_level_encryption_profile::CreateFieldLevelEncryptionProfileError> for Error {
    fn from(err: crate::operation::create_field_level_encryption_profile::CreateFieldLevelEncryptionProfileError) -> Self {
        match err {
            crate::operation::create_field_level_encryption_profile::CreateFieldLevelEncryptionProfileError::FieldLevelEncryptionProfileAlreadyExists(inner) => Error::FieldLevelEncryptionProfileAlreadyExists(inner),
            crate::operation::create_field_level_encryption_profile::CreateFieldLevelEncryptionProfileError::FieldLevelEncryptionProfileSizeExceeded(inner) => Error::FieldLevelEncryptionProfileSizeExceeded(inner),
            crate::operation::create_field_level_encryption_profile::CreateFieldLevelEncryptionProfileError::InconsistentQuantities(inner) => Error::InconsistentQuantities(inner),
            crate::operation::create_field_level_encryption_profile::CreateFieldLevelEncryptionProfileError::InvalidArgument(inner) => Error::InvalidArgument(inner),
            crate::operation::create_field_level_encryption_profile::CreateFieldLevelEncryptionProfileError::NoSuchPublicKey(inner) => Error::NoSuchPublicKey(inner),
            crate::operation::create_field_level_encryption_profile::CreateFieldLevelEncryptionProfileError::TooManyFieldLevelEncryptionEncryptionEntities(inner) => Error::TooManyFieldLevelEncryptionEncryptionEntities(inner),
            crate::operation::create_field_level_encryption_profile::CreateFieldLevelEncryptionProfileError::TooManyFieldLevelEncryptionFieldPatterns(inner) => Error::TooManyFieldLevelEncryptionFieldPatterns(inner),
            crate::operation::create_field_level_encryption_profile::CreateFieldLevelEncryptionProfileError::TooManyFieldLevelEncryptionProfiles(inner) => Error::TooManyFieldLevelEncryptionProfiles(inner),
            crate::operation::create_field_level_encryption_profile::CreateFieldLevelEncryptionProfileError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::create_function::CreateFunctionError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::create_function::CreateFunctionError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::create_function::CreateFunctionError> for Error {
    fn from(err: crate::operation::create_function::CreateFunctionError) -> Self {
        match err {
            crate::operation::create_function::CreateFunctionError::FunctionAlreadyExists(inner) => Error::FunctionAlreadyExists(inner),
            crate::operation::create_function::CreateFunctionError::FunctionSizeLimitExceeded(inner) => Error::FunctionSizeLimitExceeded(inner),
            crate::operation::create_function::CreateFunctionError::InvalidArgument(inner) => Error::InvalidArgument(inner),
            crate::operation::create_function::CreateFunctionError::TooManyFunctions(inner) => Error::TooManyFunctions(inner),
            crate::operation::create_function::CreateFunctionError::UnsupportedOperation(inner) => Error::UnsupportedOperation(inner),
            crate::operation::create_function::CreateFunctionError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::create_invalidation::CreateInvalidationError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::create_invalidation::CreateInvalidationError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::create_invalidation::CreateInvalidationError> for Error {
    fn from(err: crate::operation::create_invalidation::CreateInvalidationError) -> Self {
        match err {
            crate::operation::create_invalidation::CreateInvalidationError::AccessDenied(inner) => Error::AccessDenied(inner),
            crate::operation::create_invalidation::CreateInvalidationError::BatchTooLarge(inner) => Error::BatchTooLarge(inner),
            crate::operation::create_invalidation::CreateInvalidationError::InconsistentQuantities(inner) => Error::InconsistentQuantities(inner),
            crate::operation::create_invalidation::CreateInvalidationError::InvalidArgument(inner) => Error::InvalidArgument(inner),
            crate::operation::create_invalidation::CreateInvalidationError::MissingBody(inner) => Error::MissingBody(inner),
            crate::operation::create_invalidation::CreateInvalidationError::NoSuchDistribution(inner) => Error::NoSuchDistribution(inner),
            crate::operation::create_invalidation::CreateInvalidationError::TooManyInvalidationsInProgress(inner) => Error::TooManyInvalidationsInProgress(inner),
            crate::operation::create_invalidation::CreateInvalidationError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::create_key_group::CreateKeyGroupError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::create_key_group::CreateKeyGroupError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::create_key_group::CreateKeyGroupError> for Error {
    fn from(err: crate::operation::create_key_group::CreateKeyGroupError) -> Self {
        match err {
            crate::operation::create_key_group::CreateKeyGroupError::InvalidArgument(inner) => Error::InvalidArgument(inner),
            crate::operation::create_key_group::CreateKeyGroupError::KeyGroupAlreadyExists(inner) => Error::KeyGroupAlreadyExists(inner),
            crate::operation::create_key_group::CreateKeyGroupError::TooManyKeyGroups(inner) => Error::TooManyKeyGroups(inner),
            crate::operation::create_key_group::CreateKeyGroupError::TooManyPublicKeysInKeyGroup(inner) => Error::TooManyPublicKeysInKeyGroup(inner),
            crate::operation::create_key_group::CreateKeyGroupError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::create_monitoring_subscription::CreateMonitoringSubscriptionError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::create_monitoring_subscription::CreateMonitoringSubscriptionError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::create_monitoring_subscription::CreateMonitoringSubscriptionError> for Error {
    fn from(err: crate::operation::create_monitoring_subscription::CreateMonitoringSubscriptionError) -> Self {
        match err {
            crate::operation::create_monitoring_subscription::CreateMonitoringSubscriptionError::AccessDenied(inner) => Error::AccessDenied(inner),
            crate::operation::create_monitoring_subscription::CreateMonitoringSubscriptionError::MonitoringSubscriptionAlreadyExists(inner) => Error::MonitoringSubscriptionAlreadyExists(inner),
            crate::operation::create_monitoring_subscription::CreateMonitoringSubscriptionError::NoSuchDistribution(inner) => Error::NoSuchDistribution(inner),
            crate::operation::create_monitoring_subscription::CreateMonitoringSubscriptionError::UnsupportedOperation(inner) => Error::UnsupportedOperation(inner),
            crate::operation::create_monitoring_subscription::CreateMonitoringSubscriptionError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::create_origin_access_control::CreateOriginAccessControlError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::create_origin_access_control::CreateOriginAccessControlError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::create_origin_access_control::CreateOriginAccessControlError> for Error {
    fn from(err: crate::operation::create_origin_access_control::CreateOriginAccessControlError) -> Self {
        match err {
            crate::operation::create_origin_access_control::CreateOriginAccessControlError::InvalidArgument(inner) => Error::InvalidArgument(inner),
            crate::operation::create_origin_access_control::CreateOriginAccessControlError::OriginAccessControlAlreadyExists(inner) => Error::OriginAccessControlAlreadyExists(inner),
            crate::operation::create_origin_access_control::CreateOriginAccessControlError::TooManyOriginAccessControls(inner) => Error::TooManyOriginAccessControls(inner),
            crate::operation::create_origin_access_control::CreateOriginAccessControlError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::create_origin_request_policy::CreateOriginRequestPolicyError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::create_origin_request_policy::CreateOriginRequestPolicyError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::create_origin_request_policy::CreateOriginRequestPolicyError> for Error {
    fn from(err: crate::operation::create_origin_request_policy::CreateOriginRequestPolicyError) -> Self {
        match err {
            crate::operation::create_origin_request_policy::CreateOriginRequestPolicyError::AccessDenied(inner) => Error::AccessDenied(inner),
            crate::operation::create_origin_request_policy::CreateOriginRequestPolicyError::InconsistentQuantities(inner) => Error::InconsistentQuantities(inner),
            crate::operation::create_origin_request_policy::CreateOriginRequestPolicyError::InvalidArgument(inner) => Error::InvalidArgument(inner),
            crate::operation::create_origin_request_policy::CreateOriginRequestPolicyError::OriginRequestPolicyAlreadyExists(inner) => Error::OriginRequestPolicyAlreadyExists(inner),
            crate::operation::create_origin_request_policy::CreateOriginRequestPolicyError::TooManyCookiesInOriginRequestPolicy(inner) => Error::TooManyCookiesInOriginRequestPolicy(inner),
            crate::operation::create_origin_request_policy::CreateOriginRequestPolicyError::TooManyHeadersInOriginRequestPolicy(inner) => Error::TooManyHeadersInOriginRequestPolicy(inner),
            crate::operation::create_origin_request_policy::CreateOriginRequestPolicyError::TooManyOriginRequestPolicies(inner) => Error::TooManyOriginRequestPolicies(inner),
            crate::operation::create_origin_request_policy::CreateOriginRequestPolicyError::TooManyQueryStringsInOriginRequestPolicy(inner) => Error::TooManyQueryStringsInOriginRequestPolicy(inner),
            crate::operation::create_origin_request_policy::CreateOriginRequestPolicyError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::create_public_key::CreatePublicKeyError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::create_public_key::CreatePublicKeyError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::create_public_key::CreatePublicKeyError> for Error {
    fn from(err: crate::operation::create_public_key::CreatePublicKeyError) -> Self {
        match err {
            crate::operation::create_public_key::CreatePublicKeyError::InvalidArgument(inner) => Error::InvalidArgument(inner),
            crate::operation::create_public_key::CreatePublicKeyError::PublicKeyAlreadyExists(inner) => Error::PublicKeyAlreadyExists(inner),
            crate::operation::create_public_key::CreatePublicKeyError::TooManyPublicKeys(inner) => Error::TooManyPublicKeys(inner),
            crate::operation::create_public_key::CreatePublicKeyError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::create_realtime_log_config::CreateRealtimeLogConfigError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::create_realtime_log_config::CreateRealtimeLogConfigError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::create_realtime_log_config::CreateRealtimeLogConfigError> for Error {
    fn from(err: crate::operation::create_realtime_log_config::CreateRealtimeLogConfigError) -> Self {
        match err {
            crate::operation::create_realtime_log_config::CreateRealtimeLogConfigError::AccessDenied(inner) => Error::AccessDenied(inner),
            crate::operation::create_realtime_log_config::CreateRealtimeLogConfigError::InvalidArgument(inner) => Error::InvalidArgument(inner),
            crate::operation::create_realtime_log_config::CreateRealtimeLogConfigError::RealtimeLogConfigAlreadyExists(inner) => Error::RealtimeLogConfigAlreadyExists(inner),
            crate::operation::create_realtime_log_config::CreateRealtimeLogConfigError::TooManyRealtimeLogConfigs(inner) => Error::TooManyRealtimeLogConfigs(inner),
            crate::operation::create_realtime_log_config::CreateRealtimeLogConfigError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::create_response_headers_policy::CreateResponseHeadersPolicyError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::create_response_headers_policy::CreateResponseHeadersPolicyError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::create_response_headers_policy::CreateResponseHeadersPolicyError> for Error {
    fn from(err: crate::operation::create_response_headers_policy::CreateResponseHeadersPolicyError) -> Self {
        match err {
            crate::operation::create_response_headers_policy::CreateResponseHeadersPolicyError::AccessDenied(inner) => Error::AccessDenied(inner),
            crate::operation::create_response_headers_policy::CreateResponseHeadersPolicyError::InconsistentQuantities(inner) => Error::InconsistentQuantities(inner),
            crate::operation::create_response_headers_policy::CreateResponseHeadersPolicyError::InvalidArgument(inner) => Error::InvalidArgument(inner),
            crate::operation::create_response_headers_policy::CreateResponseHeadersPolicyError::ResponseHeadersPolicyAlreadyExists(inner) => Error::ResponseHeadersPolicyAlreadyExists(inner),
            crate::operation::create_response_headers_policy::CreateResponseHeadersPolicyError::TooLongCspInResponseHeadersPolicy(inner) => Error::TooLongCspInResponseHeadersPolicy(inner),
            crate::operation::create_response_headers_policy::CreateResponseHeadersPolicyError::TooManyCustomHeadersInResponseHeadersPolicy(inner) => Error::TooManyCustomHeadersInResponseHeadersPolicy(inner),
            crate::operation::create_response_headers_policy::CreateResponseHeadersPolicyError::TooManyRemoveHeadersInResponseHeadersPolicy(inner) => Error::TooManyRemoveHeadersInResponseHeadersPolicy(inner),
            crate::operation::create_response_headers_policy::CreateResponseHeadersPolicyError::TooManyResponseHeadersPolicies(inner) => Error::TooManyResponseHeadersPolicies(inner),
            crate::operation::create_response_headers_policy::CreateResponseHeadersPolicyError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::create_streaming_distribution::CreateStreamingDistributionError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::create_streaming_distribution::CreateStreamingDistributionError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::create_streaming_distribution::CreateStreamingDistributionError> for Error {
    fn from(err: crate::operation::create_streaming_distribution::CreateStreamingDistributionError) -> Self {
        match err {
            crate::operation::create_streaming_distribution::CreateStreamingDistributionError::AccessDenied(inner) => Error::AccessDenied(inner),
            crate::operation::create_streaming_distribution::CreateStreamingDistributionError::CnameAlreadyExists(inner) => Error::CnameAlreadyExists(inner),
            crate::operation::create_streaming_distribution::CreateStreamingDistributionError::InconsistentQuantities(inner) => Error::InconsistentQuantities(inner),
            crate::operation::create_streaming_distribution::CreateStreamingDistributionError::InvalidArgument(inner) => Error::InvalidArgument(inner),
            crate::operation::create_streaming_distribution::CreateStreamingDistributionError::InvalidOrigin(inner) => Error::InvalidOrigin(inner),
            crate::operation::create_streaming_distribution::CreateStreamingDistributionError::InvalidOriginAccessControl(inner) => Error::InvalidOriginAccessControl(inner),
            crate::operation::create_streaming_distribution::CreateStreamingDistributionError::InvalidOriginAccessIdentity(inner) => Error::InvalidOriginAccessIdentity(inner),
            crate::operation::create_streaming_distribution::CreateStreamingDistributionError::MissingBody(inner) => Error::MissingBody(inner),
            crate::operation::create_streaming_distribution::CreateStreamingDistributionError::StreamingDistributionAlreadyExists(inner) => Error::StreamingDistributionAlreadyExists(inner),
            crate::operation::create_streaming_distribution::CreateStreamingDistributionError::TooManyStreamingDistributionCnamEs(inner) => Error::TooManyStreamingDistributionCnamEs(inner),
            crate::operation::create_streaming_distribution::CreateStreamingDistributionError::TooManyStreamingDistributions(inner) => Error::TooManyStreamingDistributions(inner),
            crate::operation::create_streaming_distribution::CreateStreamingDistributionError::TooManyTrustedSigners(inner) => Error::TooManyTrustedSigners(inner),
            crate::operation::create_streaming_distribution::CreateStreamingDistributionError::TrustedSignerDoesNotExist(inner) => Error::TrustedSignerDoesNotExist(inner),
            crate::operation::create_streaming_distribution::CreateStreamingDistributionError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::create_streaming_distribution_with_tags::CreateStreamingDistributionWithTagsError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::create_streaming_distribution_with_tags::CreateStreamingDistributionWithTagsError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::create_streaming_distribution_with_tags::CreateStreamingDistributionWithTagsError> for Error {
    fn from(err: crate::operation::create_streaming_distribution_with_tags::CreateStreamingDistributionWithTagsError) -> Self {
        match err {
            crate::operation::create_streaming_distribution_with_tags::CreateStreamingDistributionWithTagsError::AccessDenied(inner) => Error::AccessDenied(inner),
            crate::operation::create_streaming_distribution_with_tags::CreateStreamingDistributionWithTagsError::CnameAlreadyExists(inner) => Error::CnameAlreadyExists(inner),
            crate::operation::create_streaming_distribution_with_tags::CreateStreamingDistributionWithTagsError::InconsistentQuantities(inner) => Error::InconsistentQuantities(inner),
            crate::operation::create_streaming_distribution_with_tags::CreateStreamingDistributionWithTagsError::InvalidArgument(inner) => Error::InvalidArgument(inner),
            crate::operation::create_streaming_distribution_with_tags::CreateStreamingDistributionWithTagsError::InvalidOrigin(inner) => Error::InvalidOrigin(inner),
            crate::operation::create_streaming_distribution_with_tags::CreateStreamingDistributionWithTagsError::InvalidOriginAccessControl(inner) => Error::InvalidOriginAccessControl(inner),
            crate::operation::create_streaming_distribution_with_tags::CreateStreamingDistributionWithTagsError::InvalidOriginAccessIdentity(inner) => Error::InvalidOriginAccessIdentity(inner),
            crate::operation::create_streaming_distribution_with_tags::CreateStreamingDistributionWithTagsError::InvalidTagging(inner) => Error::InvalidTagging(inner),
            crate::operation::create_streaming_distribution_with_tags::CreateStreamingDistributionWithTagsError::MissingBody(inner) => Error::MissingBody(inner),
            crate::operation::create_streaming_distribution_with_tags::CreateStreamingDistributionWithTagsError::StreamingDistributionAlreadyExists(inner) => Error::StreamingDistributionAlreadyExists(inner),
            crate::operation::create_streaming_distribution_with_tags::CreateStreamingDistributionWithTagsError::TooManyStreamingDistributionCnamEs(inner) => Error::TooManyStreamingDistributionCnamEs(inner),
            crate::operation::create_streaming_distribution_with_tags::CreateStreamingDistributionWithTagsError::TooManyStreamingDistributions(inner) => Error::TooManyStreamingDistributions(inner),
            crate::operation::create_streaming_distribution_with_tags::CreateStreamingDistributionWithTagsError::TooManyTrustedSigners(inner) => Error::TooManyTrustedSigners(inner),
            crate::operation::create_streaming_distribution_with_tags::CreateStreamingDistributionWithTagsError::TrustedSignerDoesNotExist(inner) => Error::TrustedSignerDoesNotExist(inner),
            crate::operation::create_streaming_distribution_with_tags::CreateStreamingDistributionWithTagsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::delete_cache_policy::DeleteCachePolicyError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::delete_cache_policy::DeleteCachePolicyError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::delete_cache_policy::DeleteCachePolicyError> for Error {
    fn from(err: crate::operation::delete_cache_policy::DeleteCachePolicyError) -> Self {
        match err {
            crate::operation::delete_cache_policy::DeleteCachePolicyError::AccessDenied(inner) => Error::AccessDenied(inner),
            crate::operation::delete_cache_policy::DeleteCachePolicyError::CachePolicyInUse(inner) => Error::CachePolicyInUse(inner),
            crate::operation::delete_cache_policy::DeleteCachePolicyError::IllegalDelete(inner) => Error::IllegalDelete(inner),
            crate::operation::delete_cache_policy::DeleteCachePolicyError::InvalidIfMatchVersion(inner) => Error::InvalidIfMatchVersion(inner),
            crate::operation::delete_cache_policy::DeleteCachePolicyError::NoSuchCachePolicy(inner) => Error::NoSuchCachePolicy(inner),
            crate::operation::delete_cache_policy::DeleteCachePolicyError::PreconditionFailed(inner) => Error::PreconditionFailed(inner),
            crate::operation::delete_cache_policy::DeleteCachePolicyError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::delete_cloud_front_origin_access_identity::DeleteCloudFrontOriginAccessIdentityError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::delete_cloud_front_origin_access_identity::DeleteCloudFrontOriginAccessIdentityError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::delete_cloud_front_origin_access_identity::DeleteCloudFrontOriginAccessIdentityError> for Error {
    fn from(err: crate::operation::delete_cloud_front_origin_access_identity::DeleteCloudFrontOriginAccessIdentityError) -> Self {
        match err {
            crate::operation::delete_cloud_front_origin_access_identity::DeleteCloudFrontOriginAccessIdentityError::AccessDenied(inner) => Error::AccessDenied(inner),
            crate::operation::delete_cloud_front_origin_access_identity::DeleteCloudFrontOriginAccessIdentityError::CloudFrontOriginAccessIdentityInUse(inner) => Error::CloudFrontOriginAccessIdentityInUse(inner),
            crate::operation::delete_cloud_front_origin_access_identity::DeleteCloudFrontOriginAccessIdentityError::InvalidIfMatchVersion(inner) => Error::InvalidIfMatchVersion(inner),
            crate::operation::delete_cloud_front_origin_access_identity::DeleteCloudFrontOriginAccessIdentityError::NoSuchCloudFrontOriginAccessIdentity(inner) => Error::NoSuchCloudFrontOriginAccessIdentity(inner),
            crate::operation::delete_cloud_front_origin_access_identity::DeleteCloudFrontOriginAccessIdentityError::PreconditionFailed(inner) => Error::PreconditionFailed(inner),
            crate::operation::delete_cloud_front_origin_access_identity::DeleteCloudFrontOriginAccessIdentityError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::delete_continuous_deployment_policy::DeleteContinuousDeploymentPolicyError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::delete_continuous_deployment_policy::DeleteContinuousDeploymentPolicyError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::delete_continuous_deployment_policy::DeleteContinuousDeploymentPolicyError> for Error {
    fn from(err: crate::operation::delete_continuous_deployment_policy::DeleteContinuousDeploymentPolicyError) -> Self {
        match err {
            crate::operation::delete_continuous_deployment_policy::DeleteContinuousDeploymentPolicyError::AccessDenied(inner) => Error::AccessDenied(inner),
            crate::operation::delete_continuous_deployment_policy::DeleteContinuousDeploymentPolicyError::ContinuousDeploymentPolicyInUse(inner) => Error::ContinuousDeploymentPolicyInUse(inner),
            crate::operation::delete_continuous_deployment_policy::DeleteContinuousDeploymentPolicyError::InvalidArgument(inner) => Error::InvalidArgument(inner),
            crate::operation::delete_continuous_deployment_policy::DeleteContinuousDeploymentPolicyError::InvalidIfMatchVersion(inner) => Error::InvalidIfMatchVersion(inner),
            crate::operation::delete_continuous_deployment_policy::DeleteContinuousDeploymentPolicyError::NoSuchContinuousDeploymentPolicy(inner) => Error::NoSuchContinuousDeploymentPolicy(inner),
            crate::operation::delete_continuous_deployment_policy::DeleteContinuousDeploymentPolicyError::PreconditionFailed(inner) => Error::PreconditionFailed(inner),
            crate::operation::delete_continuous_deployment_policy::DeleteContinuousDeploymentPolicyError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::delete_distribution::DeleteDistributionError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::delete_distribution::DeleteDistributionError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::delete_distribution::DeleteDistributionError> for Error {
    fn from(err: crate::operation::delete_distribution::DeleteDistributionError) -> Self {
        match err {
            crate::operation::delete_distribution::DeleteDistributionError::AccessDenied(inner) => Error::AccessDenied(inner),
            crate::operation::delete_distribution::DeleteDistributionError::DistributionNotDisabled(inner) => Error::DistributionNotDisabled(inner),
            crate::operation::delete_distribution::DeleteDistributionError::InvalidIfMatchVersion(inner) => Error::InvalidIfMatchVersion(inner),
            crate::operation::delete_distribution::DeleteDistributionError::NoSuchDistribution(inner) => Error::NoSuchDistribution(inner),
            crate::operation::delete_distribution::DeleteDistributionError::PreconditionFailed(inner) => Error::PreconditionFailed(inner),
            crate::operation::delete_distribution::DeleteDistributionError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::delete_field_level_encryption_config::DeleteFieldLevelEncryptionConfigError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::delete_field_level_encryption_config::DeleteFieldLevelEncryptionConfigError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::delete_field_level_encryption_config::DeleteFieldLevelEncryptionConfigError> for Error {
    fn from(err: crate::operation::delete_field_level_encryption_config::DeleteFieldLevelEncryptionConfigError) -> Self {
        match err {
            crate::operation::delete_field_level_encryption_config::DeleteFieldLevelEncryptionConfigError::AccessDenied(inner) => Error::AccessDenied(inner),
            crate::operation::delete_field_level_encryption_config::DeleteFieldLevelEncryptionConfigError::FieldLevelEncryptionConfigInUse(inner) => Error::FieldLevelEncryptionConfigInUse(inner),
            crate::operation::delete_field_level_encryption_config::DeleteFieldLevelEncryptionConfigError::InvalidIfMatchVersion(inner) => Error::InvalidIfMatchVersion(inner),
            crate::operation::delete_field_level_encryption_config::DeleteFieldLevelEncryptionConfigError::NoSuchFieldLevelEncryptionConfig(inner) => Error::NoSuchFieldLevelEncryptionConfig(inner),
            crate::operation::delete_field_level_encryption_config::DeleteFieldLevelEncryptionConfigError::PreconditionFailed(inner) => Error::PreconditionFailed(inner),
            crate::operation::delete_field_level_encryption_config::DeleteFieldLevelEncryptionConfigError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::delete_field_level_encryption_profile::DeleteFieldLevelEncryptionProfileError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::delete_field_level_encryption_profile::DeleteFieldLevelEncryptionProfileError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::delete_field_level_encryption_profile::DeleteFieldLevelEncryptionProfileError> for Error {
    fn from(err: crate::operation::delete_field_level_encryption_profile::DeleteFieldLevelEncryptionProfileError) -> Self {
        match err {
            crate::operation::delete_field_level_encryption_profile::DeleteFieldLevelEncryptionProfileError::AccessDenied(inner) => Error::AccessDenied(inner),
            crate::operation::delete_field_level_encryption_profile::DeleteFieldLevelEncryptionProfileError::FieldLevelEncryptionProfileInUse(inner) => Error::FieldLevelEncryptionProfileInUse(inner),
            crate::operation::delete_field_level_encryption_profile::DeleteFieldLevelEncryptionProfileError::InvalidIfMatchVersion(inner) => Error::InvalidIfMatchVersion(inner),
            crate::operation::delete_field_level_encryption_profile::DeleteFieldLevelEncryptionProfileError::NoSuchFieldLevelEncryptionProfile(inner) => Error::NoSuchFieldLevelEncryptionProfile(inner),
            crate::operation::delete_field_level_encryption_profile::DeleteFieldLevelEncryptionProfileError::PreconditionFailed(inner) => Error::PreconditionFailed(inner),
            crate::operation::delete_field_level_encryption_profile::DeleteFieldLevelEncryptionProfileError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::delete_function::DeleteFunctionError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::delete_function::DeleteFunctionError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::delete_function::DeleteFunctionError> for Error {
    fn from(err: crate::operation::delete_function::DeleteFunctionError) -> Self {
        match err {
            crate::operation::delete_function::DeleteFunctionError::FunctionInUse(inner) => Error::FunctionInUse(inner),
            crate::operation::delete_function::DeleteFunctionError::InvalidIfMatchVersion(inner) => Error::InvalidIfMatchVersion(inner),
            crate::operation::delete_function::DeleteFunctionError::NoSuchFunctionExists(inner) => Error::NoSuchFunctionExists(inner),
            crate::operation::delete_function::DeleteFunctionError::PreconditionFailed(inner) => Error::PreconditionFailed(inner),
            crate::operation::delete_function::DeleteFunctionError::UnsupportedOperation(inner) => Error::UnsupportedOperation(inner),
            crate::operation::delete_function::DeleteFunctionError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::delete_key_group::DeleteKeyGroupError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::delete_key_group::DeleteKeyGroupError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::delete_key_group::DeleteKeyGroupError> for Error {
    fn from(err: crate::operation::delete_key_group::DeleteKeyGroupError) -> Self {
        match err {
            crate::operation::delete_key_group::DeleteKeyGroupError::InvalidIfMatchVersion(inner) => Error::InvalidIfMatchVersion(inner),
            crate::operation::delete_key_group::DeleteKeyGroupError::NoSuchResource(inner) => Error::NoSuchResource(inner),
            crate::operation::delete_key_group::DeleteKeyGroupError::PreconditionFailed(inner) => Error::PreconditionFailed(inner),
            crate::operation::delete_key_group::DeleteKeyGroupError::ResourceInUse(inner) => Error::ResourceInUse(inner),
            crate::operation::delete_key_group::DeleteKeyGroupError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::delete_monitoring_subscription::DeleteMonitoringSubscriptionError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::delete_monitoring_subscription::DeleteMonitoringSubscriptionError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::delete_monitoring_subscription::DeleteMonitoringSubscriptionError> for Error {
    fn from(err: crate::operation::delete_monitoring_subscription::DeleteMonitoringSubscriptionError) -> Self {
        match err {
            crate::operation::delete_monitoring_subscription::DeleteMonitoringSubscriptionError::AccessDenied(inner) => Error::AccessDenied(inner),
            crate::operation::delete_monitoring_subscription::DeleteMonitoringSubscriptionError::NoSuchDistribution(inner) => Error::NoSuchDistribution(inner),
            crate::operation::delete_monitoring_subscription::DeleteMonitoringSubscriptionError::NoSuchMonitoringSubscription(inner) => Error::NoSuchMonitoringSubscription(inner),
            crate::operation::delete_monitoring_subscription::DeleteMonitoringSubscriptionError::UnsupportedOperation(inner) => Error::UnsupportedOperation(inner),
            crate::operation::delete_monitoring_subscription::DeleteMonitoringSubscriptionError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::delete_origin_access_control::DeleteOriginAccessControlError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::delete_origin_access_control::DeleteOriginAccessControlError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::delete_origin_access_control::DeleteOriginAccessControlError> for Error {
    fn from(err: crate::operation::delete_origin_access_control::DeleteOriginAccessControlError) -> Self {
        match err {
            crate::operation::delete_origin_access_control::DeleteOriginAccessControlError::AccessDenied(inner) => Error::AccessDenied(inner),
            crate::operation::delete_origin_access_control::DeleteOriginAccessControlError::InvalidIfMatchVersion(inner) => Error::InvalidIfMatchVersion(inner),
            crate::operation::delete_origin_access_control::DeleteOriginAccessControlError::NoSuchOriginAccessControl(inner) => Error::NoSuchOriginAccessControl(inner),
            crate::operation::delete_origin_access_control::DeleteOriginAccessControlError::OriginAccessControlInUse(inner) => Error::OriginAccessControlInUse(inner),
            crate::operation::delete_origin_access_control::DeleteOriginAccessControlError::PreconditionFailed(inner) => Error::PreconditionFailed(inner),
            crate::operation::delete_origin_access_control::DeleteOriginAccessControlError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::delete_origin_request_policy::DeleteOriginRequestPolicyError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::delete_origin_request_policy::DeleteOriginRequestPolicyError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::delete_origin_request_policy::DeleteOriginRequestPolicyError> for Error {
    fn from(err: crate::operation::delete_origin_request_policy::DeleteOriginRequestPolicyError) -> Self {
        match err {
            crate::operation::delete_origin_request_policy::DeleteOriginRequestPolicyError::AccessDenied(inner) => Error::AccessDenied(inner),
            crate::operation::delete_origin_request_policy::DeleteOriginRequestPolicyError::IllegalDelete(inner) => Error::IllegalDelete(inner),
            crate::operation::delete_origin_request_policy::DeleteOriginRequestPolicyError::InvalidIfMatchVersion(inner) => Error::InvalidIfMatchVersion(inner),
            crate::operation::delete_origin_request_policy::DeleteOriginRequestPolicyError::NoSuchOriginRequestPolicy(inner) => Error::NoSuchOriginRequestPolicy(inner),
            crate::operation::delete_origin_request_policy::DeleteOriginRequestPolicyError::OriginRequestPolicyInUse(inner) => Error::OriginRequestPolicyInUse(inner),
            crate::operation::delete_origin_request_policy::DeleteOriginRequestPolicyError::PreconditionFailed(inner) => Error::PreconditionFailed(inner),
            crate::operation::delete_origin_request_policy::DeleteOriginRequestPolicyError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::delete_public_key::DeletePublicKeyError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::delete_public_key::DeletePublicKeyError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::delete_public_key::DeletePublicKeyError> for Error {
    fn from(err: crate::operation::delete_public_key::DeletePublicKeyError) -> Self {
        match err {
            crate::operation::delete_public_key::DeletePublicKeyError::AccessDenied(inner) => Error::AccessDenied(inner),
            crate::operation::delete_public_key::DeletePublicKeyError::InvalidIfMatchVersion(inner) => Error::InvalidIfMatchVersion(inner),
            crate::operation::delete_public_key::DeletePublicKeyError::NoSuchPublicKey(inner) => Error::NoSuchPublicKey(inner),
            crate::operation::delete_public_key::DeletePublicKeyError::PreconditionFailed(inner) => Error::PreconditionFailed(inner),
            crate::operation::delete_public_key::DeletePublicKeyError::PublicKeyInUse(inner) => Error::PublicKeyInUse(inner),
            crate::operation::delete_public_key::DeletePublicKeyError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::delete_realtime_log_config::DeleteRealtimeLogConfigError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::delete_realtime_log_config::DeleteRealtimeLogConfigError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::delete_realtime_log_config::DeleteRealtimeLogConfigError> for Error {
    fn from(err: crate::operation::delete_realtime_log_config::DeleteRealtimeLogConfigError) -> Self {
        match err {
            crate::operation::delete_realtime_log_config::DeleteRealtimeLogConfigError::AccessDenied(inner) => Error::AccessDenied(inner),
            crate::operation::delete_realtime_log_config::DeleteRealtimeLogConfigError::InvalidArgument(inner) => Error::InvalidArgument(inner),
            crate::operation::delete_realtime_log_config::DeleteRealtimeLogConfigError::NoSuchRealtimeLogConfig(inner) => Error::NoSuchRealtimeLogConfig(inner),
            crate::operation::delete_realtime_log_config::DeleteRealtimeLogConfigError::RealtimeLogConfigInUse(inner) => Error::RealtimeLogConfigInUse(inner),
            crate::operation::delete_realtime_log_config::DeleteRealtimeLogConfigError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::delete_response_headers_policy::DeleteResponseHeadersPolicyError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::delete_response_headers_policy::DeleteResponseHeadersPolicyError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::delete_response_headers_policy::DeleteResponseHeadersPolicyError> for Error {
    fn from(err: crate::operation::delete_response_headers_policy::DeleteResponseHeadersPolicyError) -> Self {
        match err {
            crate::operation::delete_response_headers_policy::DeleteResponseHeadersPolicyError::AccessDenied(inner) => Error::AccessDenied(inner),
            crate::operation::delete_response_headers_policy::DeleteResponseHeadersPolicyError::IllegalDelete(inner) => Error::IllegalDelete(inner),
            crate::operation::delete_response_headers_policy::DeleteResponseHeadersPolicyError::InvalidIfMatchVersion(inner) => Error::InvalidIfMatchVersion(inner),
            crate::operation::delete_response_headers_policy::DeleteResponseHeadersPolicyError::NoSuchResponseHeadersPolicy(inner) => Error::NoSuchResponseHeadersPolicy(inner),
            crate::operation::delete_response_headers_policy::DeleteResponseHeadersPolicyError::PreconditionFailed(inner) => Error::PreconditionFailed(inner),
            crate::operation::delete_response_headers_policy::DeleteResponseHeadersPolicyError::ResponseHeadersPolicyInUse(inner) => Error::ResponseHeadersPolicyInUse(inner),
            crate::operation::delete_response_headers_policy::DeleteResponseHeadersPolicyError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::delete_streaming_distribution::DeleteStreamingDistributionError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::delete_streaming_distribution::DeleteStreamingDistributionError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::delete_streaming_distribution::DeleteStreamingDistributionError> for Error {
    fn from(err: crate::operation::delete_streaming_distribution::DeleteStreamingDistributionError) -> Self {
        match err {
            crate::operation::delete_streaming_distribution::DeleteStreamingDistributionError::AccessDenied(inner) => Error::AccessDenied(inner),
            crate::operation::delete_streaming_distribution::DeleteStreamingDistributionError::InvalidIfMatchVersion(inner) => Error::InvalidIfMatchVersion(inner),
            crate::operation::delete_streaming_distribution::DeleteStreamingDistributionError::NoSuchStreamingDistribution(inner) => Error::NoSuchStreamingDistribution(inner),
            crate::operation::delete_streaming_distribution::DeleteStreamingDistributionError::PreconditionFailed(inner) => Error::PreconditionFailed(inner),
            crate::operation::delete_streaming_distribution::DeleteStreamingDistributionError::StreamingDistributionNotDisabled(inner) => Error::StreamingDistributionNotDisabled(inner),
            crate::operation::delete_streaming_distribution::DeleteStreamingDistributionError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::describe_function::DescribeFunctionError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::describe_function::DescribeFunctionError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::describe_function::DescribeFunctionError> for Error {
    fn from(err: crate::operation::describe_function::DescribeFunctionError) -> Self {
        match err {
            crate::operation::describe_function::DescribeFunctionError::NoSuchFunctionExists(inner) => Error::NoSuchFunctionExists(inner),
            crate::operation::describe_function::DescribeFunctionError::UnsupportedOperation(inner) => Error::UnsupportedOperation(inner),
            crate::operation::describe_function::DescribeFunctionError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::get_cache_policy::GetCachePolicyError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::get_cache_policy::GetCachePolicyError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::get_cache_policy::GetCachePolicyError> for Error {
    fn from(err: crate::operation::get_cache_policy::GetCachePolicyError) -> Self {
        match err {
            crate::operation::get_cache_policy::GetCachePolicyError::AccessDenied(inner) => Error::AccessDenied(inner),
            crate::operation::get_cache_policy::GetCachePolicyError::NoSuchCachePolicy(inner) => Error::NoSuchCachePolicy(inner),
            crate::operation::get_cache_policy::GetCachePolicyError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::get_cache_policy_config::GetCachePolicyConfigError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::get_cache_policy_config::GetCachePolicyConfigError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::get_cache_policy_config::GetCachePolicyConfigError> for Error {
    fn from(err: crate::operation::get_cache_policy_config::GetCachePolicyConfigError) -> Self {
        match err {
            crate::operation::get_cache_policy_config::GetCachePolicyConfigError::AccessDenied(inner) => Error::AccessDenied(inner),
            crate::operation::get_cache_policy_config::GetCachePolicyConfigError::NoSuchCachePolicy(inner) => Error::NoSuchCachePolicy(inner),
            crate::operation::get_cache_policy_config::GetCachePolicyConfigError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::get_cloud_front_origin_access_identity::GetCloudFrontOriginAccessIdentityError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::get_cloud_front_origin_access_identity::GetCloudFrontOriginAccessIdentityError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::get_cloud_front_origin_access_identity::GetCloudFrontOriginAccessIdentityError> for Error {
    fn from(err: crate::operation::get_cloud_front_origin_access_identity::GetCloudFrontOriginAccessIdentityError) -> Self {
        match err {
            crate::operation::get_cloud_front_origin_access_identity::GetCloudFrontOriginAccessIdentityError::AccessDenied(inner) => Error::AccessDenied(inner),
            crate::operation::get_cloud_front_origin_access_identity::GetCloudFrontOriginAccessIdentityError::NoSuchCloudFrontOriginAccessIdentity(inner) => Error::NoSuchCloudFrontOriginAccessIdentity(inner),
            crate::operation::get_cloud_front_origin_access_identity::GetCloudFrontOriginAccessIdentityError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::get_cloud_front_origin_access_identity_config::GetCloudFrontOriginAccessIdentityConfigError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::get_cloud_front_origin_access_identity_config::GetCloudFrontOriginAccessIdentityConfigError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::get_cloud_front_origin_access_identity_config::GetCloudFrontOriginAccessIdentityConfigError> for Error {
    fn from(err: crate::operation::get_cloud_front_origin_access_identity_config::GetCloudFrontOriginAccessIdentityConfigError) -> Self {
        match err {
            crate::operation::get_cloud_front_origin_access_identity_config::GetCloudFrontOriginAccessIdentityConfigError::AccessDenied(inner) => Error::AccessDenied(inner),
            crate::operation::get_cloud_front_origin_access_identity_config::GetCloudFrontOriginAccessIdentityConfigError::NoSuchCloudFrontOriginAccessIdentity(inner) => Error::NoSuchCloudFrontOriginAccessIdentity(inner),
            crate::operation::get_cloud_front_origin_access_identity_config::GetCloudFrontOriginAccessIdentityConfigError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::get_continuous_deployment_policy::GetContinuousDeploymentPolicyError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::get_continuous_deployment_policy::GetContinuousDeploymentPolicyError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::get_continuous_deployment_policy::GetContinuousDeploymentPolicyError> for Error {
    fn from(err: crate::operation::get_continuous_deployment_policy::GetContinuousDeploymentPolicyError) -> Self {
        match err {
            crate::operation::get_continuous_deployment_policy::GetContinuousDeploymentPolicyError::AccessDenied(inner) => Error::AccessDenied(inner),
            crate::operation::get_continuous_deployment_policy::GetContinuousDeploymentPolicyError::NoSuchContinuousDeploymentPolicy(inner) => Error::NoSuchContinuousDeploymentPolicy(inner),
            crate::operation::get_continuous_deployment_policy::GetContinuousDeploymentPolicyError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::get_continuous_deployment_policy_config::GetContinuousDeploymentPolicyConfigError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::get_continuous_deployment_policy_config::GetContinuousDeploymentPolicyConfigError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::get_continuous_deployment_policy_config::GetContinuousDeploymentPolicyConfigError> for Error {
    fn from(err: crate::operation::get_continuous_deployment_policy_config::GetContinuousDeploymentPolicyConfigError) -> Self {
        match err {
            crate::operation::get_continuous_deployment_policy_config::GetContinuousDeploymentPolicyConfigError::AccessDenied(inner) => Error::AccessDenied(inner),
            crate::operation::get_continuous_deployment_policy_config::GetContinuousDeploymentPolicyConfigError::NoSuchContinuousDeploymentPolicy(inner) => Error::NoSuchContinuousDeploymentPolicy(inner),
            crate::operation::get_continuous_deployment_policy_config::GetContinuousDeploymentPolicyConfigError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::get_distribution::GetDistributionError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::get_distribution::GetDistributionError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::get_distribution::GetDistributionError> for Error {
    fn from(err: crate::operation::get_distribution::GetDistributionError) -> Self {
        match err {
            crate::operation::get_distribution::GetDistributionError::AccessDenied(inner) => Error::AccessDenied(inner),
            crate::operation::get_distribution::GetDistributionError::NoSuchDistribution(inner) => Error::NoSuchDistribution(inner),
            crate::operation::get_distribution::GetDistributionError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::get_distribution_config::GetDistributionConfigError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::get_distribution_config::GetDistributionConfigError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::get_distribution_config::GetDistributionConfigError> for Error {
    fn from(err: crate::operation::get_distribution_config::GetDistributionConfigError) -> Self {
        match err {
            crate::operation::get_distribution_config::GetDistributionConfigError::AccessDenied(inner) => Error::AccessDenied(inner),
            crate::operation::get_distribution_config::GetDistributionConfigError::NoSuchDistribution(inner) => Error::NoSuchDistribution(inner),
            crate::operation::get_distribution_config::GetDistributionConfigError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::get_field_level_encryption::GetFieldLevelEncryptionError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::get_field_level_encryption::GetFieldLevelEncryptionError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::get_field_level_encryption::GetFieldLevelEncryptionError> for Error {
    fn from(err: crate::operation::get_field_level_encryption::GetFieldLevelEncryptionError) -> Self {
        match err {
            crate::operation::get_field_level_encryption::GetFieldLevelEncryptionError::AccessDenied(inner) => Error::AccessDenied(inner),
            crate::operation::get_field_level_encryption::GetFieldLevelEncryptionError::NoSuchFieldLevelEncryptionConfig(inner) => Error::NoSuchFieldLevelEncryptionConfig(inner),
            crate::operation::get_field_level_encryption::GetFieldLevelEncryptionError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::get_field_level_encryption_config::GetFieldLevelEncryptionConfigError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::get_field_level_encryption_config::GetFieldLevelEncryptionConfigError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::get_field_level_encryption_config::GetFieldLevelEncryptionConfigError> for Error {
    fn from(err: crate::operation::get_field_level_encryption_config::GetFieldLevelEncryptionConfigError) -> Self {
        match err {
            crate::operation::get_field_level_encryption_config::GetFieldLevelEncryptionConfigError::AccessDenied(inner) => Error::AccessDenied(inner),
            crate::operation::get_field_level_encryption_config::GetFieldLevelEncryptionConfigError::NoSuchFieldLevelEncryptionConfig(inner) => Error::NoSuchFieldLevelEncryptionConfig(inner),
            crate::operation::get_field_level_encryption_config::GetFieldLevelEncryptionConfigError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::get_field_level_encryption_profile::GetFieldLevelEncryptionProfileError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::get_field_level_encryption_profile::GetFieldLevelEncryptionProfileError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::get_field_level_encryption_profile::GetFieldLevelEncryptionProfileError> for Error {
    fn from(err: crate::operation::get_field_level_encryption_profile::GetFieldLevelEncryptionProfileError) -> Self {
        match err {
            crate::operation::get_field_level_encryption_profile::GetFieldLevelEncryptionProfileError::AccessDenied(inner) => Error::AccessDenied(inner),
            crate::operation::get_field_level_encryption_profile::GetFieldLevelEncryptionProfileError::NoSuchFieldLevelEncryptionProfile(inner) => Error::NoSuchFieldLevelEncryptionProfile(inner),
            crate::operation::get_field_level_encryption_profile::GetFieldLevelEncryptionProfileError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::get_field_level_encryption_profile_config::GetFieldLevelEncryptionProfileConfigError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::get_field_level_encryption_profile_config::GetFieldLevelEncryptionProfileConfigError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::get_field_level_encryption_profile_config::GetFieldLevelEncryptionProfileConfigError> for Error {
    fn from(err: crate::operation::get_field_level_encryption_profile_config::GetFieldLevelEncryptionProfileConfigError) -> Self {
        match err {
            crate::operation::get_field_level_encryption_profile_config::GetFieldLevelEncryptionProfileConfigError::AccessDenied(inner) => Error::AccessDenied(inner),
            crate::operation::get_field_level_encryption_profile_config::GetFieldLevelEncryptionProfileConfigError::NoSuchFieldLevelEncryptionProfile(inner) => Error::NoSuchFieldLevelEncryptionProfile(inner),
            crate::operation::get_field_level_encryption_profile_config::GetFieldLevelEncryptionProfileConfigError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::get_function::GetFunctionError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::get_function::GetFunctionError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::get_function::GetFunctionError> for Error {
    fn from(err: crate::operation::get_function::GetFunctionError) -> Self {
        match err {
            crate::operation::get_function::GetFunctionError::NoSuchFunctionExists(inner) => Error::NoSuchFunctionExists(inner),
            crate::operation::get_function::GetFunctionError::UnsupportedOperation(inner) => Error::UnsupportedOperation(inner),
            crate::operation::get_function::GetFunctionError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::get_invalidation::GetInvalidationError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::get_invalidation::GetInvalidationError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::get_invalidation::GetInvalidationError> for Error {
    fn from(err: crate::operation::get_invalidation::GetInvalidationError) -> Self {
        match err {
            crate::operation::get_invalidation::GetInvalidationError::AccessDenied(inner) => Error::AccessDenied(inner),
            crate::operation::get_invalidation::GetInvalidationError::NoSuchDistribution(inner) => Error::NoSuchDistribution(inner),
            crate::operation::get_invalidation::GetInvalidationError::NoSuchInvalidation(inner) => Error::NoSuchInvalidation(inner),
            crate::operation::get_invalidation::GetInvalidationError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::get_key_group::GetKeyGroupError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::get_key_group::GetKeyGroupError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::get_key_group::GetKeyGroupError> for Error {
    fn from(err: crate::operation::get_key_group::GetKeyGroupError) -> Self {
        match err {
            crate::operation::get_key_group::GetKeyGroupError::NoSuchResource(inner) => Error::NoSuchResource(inner),
            crate::operation::get_key_group::GetKeyGroupError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::get_key_group_config::GetKeyGroupConfigError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::get_key_group_config::GetKeyGroupConfigError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::get_key_group_config::GetKeyGroupConfigError> for Error {
    fn from(err: crate::operation::get_key_group_config::GetKeyGroupConfigError) -> Self {
        match err {
            crate::operation::get_key_group_config::GetKeyGroupConfigError::NoSuchResource(inner) => Error::NoSuchResource(inner),
            crate::operation::get_key_group_config::GetKeyGroupConfigError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::get_monitoring_subscription::GetMonitoringSubscriptionError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::get_monitoring_subscription::GetMonitoringSubscriptionError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::get_monitoring_subscription::GetMonitoringSubscriptionError> for Error {
    fn from(err: crate::operation::get_monitoring_subscription::GetMonitoringSubscriptionError) -> Self {
        match err {
            crate::operation::get_monitoring_subscription::GetMonitoringSubscriptionError::AccessDenied(inner) => Error::AccessDenied(inner),
            crate::operation::get_monitoring_subscription::GetMonitoringSubscriptionError::NoSuchDistribution(inner) => Error::NoSuchDistribution(inner),
            crate::operation::get_monitoring_subscription::GetMonitoringSubscriptionError::NoSuchMonitoringSubscription(inner) => Error::NoSuchMonitoringSubscription(inner),
            crate::operation::get_monitoring_subscription::GetMonitoringSubscriptionError::UnsupportedOperation(inner) => Error::UnsupportedOperation(inner),
            crate::operation::get_monitoring_subscription::GetMonitoringSubscriptionError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::get_origin_access_control::GetOriginAccessControlError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::get_origin_access_control::GetOriginAccessControlError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::get_origin_access_control::GetOriginAccessControlError> for Error {
    fn from(err: crate::operation::get_origin_access_control::GetOriginAccessControlError) -> Self {
        match err {
            crate::operation::get_origin_access_control::GetOriginAccessControlError::AccessDenied(inner) => Error::AccessDenied(inner),
            crate::operation::get_origin_access_control::GetOriginAccessControlError::NoSuchOriginAccessControl(inner) => Error::NoSuchOriginAccessControl(inner),
            crate::operation::get_origin_access_control::GetOriginAccessControlError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::get_origin_access_control_config::GetOriginAccessControlConfigError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::get_origin_access_control_config::GetOriginAccessControlConfigError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::get_origin_access_control_config::GetOriginAccessControlConfigError> for Error {
    fn from(err: crate::operation::get_origin_access_control_config::GetOriginAccessControlConfigError) -> Self {
        match err {
            crate::operation::get_origin_access_control_config::GetOriginAccessControlConfigError::AccessDenied(inner) => Error::AccessDenied(inner),
            crate::operation::get_origin_access_control_config::GetOriginAccessControlConfigError::NoSuchOriginAccessControl(inner) => Error::NoSuchOriginAccessControl(inner),
            crate::operation::get_origin_access_control_config::GetOriginAccessControlConfigError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::get_origin_request_policy::GetOriginRequestPolicyError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::get_origin_request_policy::GetOriginRequestPolicyError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::get_origin_request_policy::GetOriginRequestPolicyError> for Error {
    fn from(err: crate::operation::get_origin_request_policy::GetOriginRequestPolicyError) -> Self {
        match err {
            crate::operation::get_origin_request_policy::GetOriginRequestPolicyError::AccessDenied(inner) => Error::AccessDenied(inner),
            crate::operation::get_origin_request_policy::GetOriginRequestPolicyError::NoSuchOriginRequestPolicy(inner) => Error::NoSuchOriginRequestPolicy(inner),
            crate::operation::get_origin_request_policy::GetOriginRequestPolicyError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::get_origin_request_policy_config::GetOriginRequestPolicyConfigError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::get_origin_request_policy_config::GetOriginRequestPolicyConfigError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::get_origin_request_policy_config::GetOriginRequestPolicyConfigError> for Error {
    fn from(err: crate::operation::get_origin_request_policy_config::GetOriginRequestPolicyConfigError) -> Self {
        match err {
            crate::operation::get_origin_request_policy_config::GetOriginRequestPolicyConfigError::AccessDenied(inner) => Error::AccessDenied(inner),
            crate::operation::get_origin_request_policy_config::GetOriginRequestPolicyConfigError::NoSuchOriginRequestPolicy(inner) => Error::NoSuchOriginRequestPolicy(inner),
            crate::operation::get_origin_request_policy_config::GetOriginRequestPolicyConfigError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::get_public_key::GetPublicKeyError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::get_public_key::GetPublicKeyError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::get_public_key::GetPublicKeyError> for Error {
    fn from(err: crate::operation::get_public_key::GetPublicKeyError) -> Self {
        match err {
            crate::operation::get_public_key::GetPublicKeyError::AccessDenied(inner) => Error::AccessDenied(inner),
            crate::operation::get_public_key::GetPublicKeyError::NoSuchPublicKey(inner) => Error::NoSuchPublicKey(inner),
            crate::operation::get_public_key::GetPublicKeyError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::get_public_key_config::GetPublicKeyConfigError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::get_public_key_config::GetPublicKeyConfigError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::get_public_key_config::GetPublicKeyConfigError> for Error {
    fn from(err: crate::operation::get_public_key_config::GetPublicKeyConfigError) -> Self {
        match err {
            crate::operation::get_public_key_config::GetPublicKeyConfigError::AccessDenied(inner) => Error::AccessDenied(inner),
            crate::operation::get_public_key_config::GetPublicKeyConfigError::NoSuchPublicKey(inner) => Error::NoSuchPublicKey(inner),
            crate::operation::get_public_key_config::GetPublicKeyConfigError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::get_realtime_log_config::GetRealtimeLogConfigError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::get_realtime_log_config::GetRealtimeLogConfigError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::get_realtime_log_config::GetRealtimeLogConfigError> for Error {
    fn from(err: crate::operation::get_realtime_log_config::GetRealtimeLogConfigError) -> Self {
        match err {
            crate::operation::get_realtime_log_config::GetRealtimeLogConfigError::AccessDenied(inner) => Error::AccessDenied(inner),
            crate::operation::get_realtime_log_config::GetRealtimeLogConfigError::InvalidArgument(inner) => Error::InvalidArgument(inner),
            crate::operation::get_realtime_log_config::GetRealtimeLogConfigError::NoSuchRealtimeLogConfig(inner) => Error::NoSuchRealtimeLogConfig(inner),
            crate::operation::get_realtime_log_config::GetRealtimeLogConfigError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::get_response_headers_policy::GetResponseHeadersPolicyError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::get_response_headers_policy::GetResponseHeadersPolicyError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::get_response_headers_policy::GetResponseHeadersPolicyError> for Error {
    fn from(err: crate::operation::get_response_headers_policy::GetResponseHeadersPolicyError) -> Self {
        match err {
            crate::operation::get_response_headers_policy::GetResponseHeadersPolicyError::AccessDenied(inner) => Error::AccessDenied(inner),
            crate::operation::get_response_headers_policy::GetResponseHeadersPolicyError::NoSuchResponseHeadersPolicy(inner) => Error::NoSuchResponseHeadersPolicy(inner),
            crate::operation::get_response_headers_policy::GetResponseHeadersPolicyError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::get_response_headers_policy_config::GetResponseHeadersPolicyConfigError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::get_response_headers_policy_config::GetResponseHeadersPolicyConfigError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::get_response_headers_policy_config::GetResponseHeadersPolicyConfigError> for Error {
    fn from(err: crate::operation::get_response_headers_policy_config::GetResponseHeadersPolicyConfigError) -> Self {
        match err {
            crate::operation::get_response_headers_policy_config::GetResponseHeadersPolicyConfigError::AccessDenied(inner) => Error::AccessDenied(inner),
            crate::operation::get_response_headers_policy_config::GetResponseHeadersPolicyConfigError::NoSuchResponseHeadersPolicy(inner) => Error::NoSuchResponseHeadersPolicy(inner),
            crate::operation::get_response_headers_policy_config::GetResponseHeadersPolicyConfigError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::get_streaming_distribution::GetStreamingDistributionError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::get_streaming_distribution::GetStreamingDistributionError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::get_streaming_distribution::GetStreamingDistributionError> for Error {
    fn from(err: crate::operation::get_streaming_distribution::GetStreamingDistributionError) -> Self {
        match err {
            crate::operation::get_streaming_distribution::GetStreamingDistributionError::AccessDenied(inner) => Error::AccessDenied(inner),
            crate::operation::get_streaming_distribution::GetStreamingDistributionError::NoSuchStreamingDistribution(inner) => Error::NoSuchStreamingDistribution(inner),
            crate::operation::get_streaming_distribution::GetStreamingDistributionError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::get_streaming_distribution_config::GetStreamingDistributionConfigError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::get_streaming_distribution_config::GetStreamingDistributionConfigError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::get_streaming_distribution_config::GetStreamingDistributionConfigError> for Error {
    fn from(err: crate::operation::get_streaming_distribution_config::GetStreamingDistributionConfigError) -> Self {
        match err {
            crate::operation::get_streaming_distribution_config::GetStreamingDistributionConfigError::AccessDenied(inner) => Error::AccessDenied(inner),
            crate::operation::get_streaming_distribution_config::GetStreamingDistributionConfigError::NoSuchStreamingDistribution(inner) => Error::NoSuchStreamingDistribution(inner),
            crate::operation::get_streaming_distribution_config::GetStreamingDistributionConfigError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::list_cache_policies::ListCachePoliciesError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::list_cache_policies::ListCachePoliciesError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::list_cache_policies::ListCachePoliciesError> for Error {
    fn from(err: crate::operation::list_cache_policies::ListCachePoliciesError) -> Self {
        match err {
            crate::operation::list_cache_policies::ListCachePoliciesError::AccessDenied(inner) => Error::AccessDenied(inner),
            crate::operation::list_cache_policies::ListCachePoliciesError::InvalidArgument(inner) => Error::InvalidArgument(inner),
            crate::operation::list_cache_policies::ListCachePoliciesError::NoSuchCachePolicy(inner) => Error::NoSuchCachePolicy(inner),
            crate::operation::list_cache_policies::ListCachePoliciesError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::list_cloud_front_origin_access_identities::ListCloudFrontOriginAccessIdentitiesError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::list_cloud_front_origin_access_identities::ListCloudFrontOriginAccessIdentitiesError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::list_cloud_front_origin_access_identities::ListCloudFrontOriginAccessIdentitiesError> for Error {
    fn from(err: crate::operation::list_cloud_front_origin_access_identities::ListCloudFrontOriginAccessIdentitiesError) -> Self {
        match err {
            crate::operation::list_cloud_front_origin_access_identities::ListCloudFrontOriginAccessIdentitiesError::InvalidArgument(inner) => Error::InvalidArgument(inner),
            crate::operation::list_cloud_front_origin_access_identities::ListCloudFrontOriginAccessIdentitiesError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::list_conflicting_aliases::ListConflictingAliasesError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::list_conflicting_aliases::ListConflictingAliasesError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::list_conflicting_aliases::ListConflictingAliasesError> for Error {
    fn from(err: crate::operation::list_conflicting_aliases::ListConflictingAliasesError) -> Self {
        match err {
            crate::operation::list_conflicting_aliases::ListConflictingAliasesError::InvalidArgument(inner) => Error::InvalidArgument(inner),
            crate::operation::list_conflicting_aliases::ListConflictingAliasesError::NoSuchDistribution(inner) => Error::NoSuchDistribution(inner),
            crate::operation::list_conflicting_aliases::ListConflictingAliasesError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::list_continuous_deployment_policies::ListContinuousDeploymentPoliciesError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::list_continuous_deployment_policies::ListContinuousDeploymentPoliciesError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::list_continuous_deployment_policies::ListContinuousDeploymentPoliciesError> for Error {
    fn from(err: crate::operation::list_continuous_deployment_policies::ListContinuousDeploymentPoliciesError) -> Self {
        match err {
            crate::operation::list_continuous_deployment_policies::ListContinuousDeploymentPoliciesError::AccessDenied(inner) => Error::AccessDenied(inner),
            crate::operation::list_continuous_deployment_policies::ListContinuousDeploymentPoliciesError::InvalidArgument(inner) => Error::InvalidArgument(inner),
            crate::operation::list_continuous_deployment_policies::ListContinuousDeploymentPoliciesError::NoSuchContinuousDeploymentPolicy(inner) => Error::NoSuchContinuousDeploymentPolicy(inner),
            crate::operation::list_continuous_deployment_policies::ListContinuousDeploymentPoliciesError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::list_distributions::ListDistributionsError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::list_distributions::ListDistributionsError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::list_distributions::ListDistributionsError> for Error {
    fn from(err: crate::operation::list_distributions::ListDistributionsError) -> Self {
        match err {
            crate::operation::list_distributions::ListDistributionsError::InvalidArgument(inner) => Error::InvalidArgument(inner),
            crate::operation::list_distributions::ListDistributionsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::list_distributions_by_cache_policy_id::ListDistributionsByCachePolicyIdError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::list_distributions_by_cache_policy_id::ListDistributionsByCachePolicyIdError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::list_distributions_by_cache_policy_id::ListDistributionsByCachePolicyIdError> for Error {
    fn from(err: crate::operation::list_distributions_by_cache_policy_id::ListDistributionsByCachePolicyIdError) -> Self {
        match err {
            crate::operation::list_distributions_by_cache_policy_id::ListDistributionsByCachePolicyIdError::AccessDenied(inner) => Error::AccessDenied(inner),
            crate::operation::list_distributions_by_cache_policy_id::ListDistributionsByCachePolicyIdError::InvalidArgument(inner) => Error::InvalidArgument(inner),
            crate::operation::list_distributions_by_cache_policy_id::ListDistributionsByCachePolicyIdError::NoSuchCachePolicy(inner) => Error::NoSuchCachePolicy(inner),
            crate::operation::list_distributions_by_cache_policy_id::ListDistributionsByCachePolicyIdError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::list_distributions_by_key_group::ListDistributionsByKeyGroupError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::list_distributions_by_key_group::ListDistributionsByKeyGroupError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::list_distributions_by_key_group::ListDistributionsByKeyGroupError> for Error {
    fn from(err: crate::operation::list_distributions_by_key_group::ListDistributionsByKeyGroupError) -> Self {
        match err {
            crate::operation::list_distributions_by_key_group::ListDistributionsByKeyGroupError::InvalidArgument(inner) => Error::InvalidArgument(inner),
            crate::operation::list_distributions_by_key_group::ListDistributionsByKeyGroupError::NoSuchResource(inner) => Error::NoSuchResource(inner),
            crate::operation::list_distributions_by_key_group::ListDistributionsByKeyGroupError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::list_distributions_by_origin_request_policy_id::ListDistributionsByOriginRequestPolicyIdError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::list_distributions_by_origin_request_policy_id::ListDistributionsByOriginRequestPolicyIdError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::list_distributions_by_origin_request_policy_id::ListDistributionsByOriginRequestPolicyIdError> for Error {
    fn from(err: crate::operation::list_distributions_by_origin_request_policy_id::ListDistributionsByOriginRequestPolicyIdError) -> Self {
        match err {
            crate::operation::list_distributions_by_origin_request_policy_id::ListDistributionsByOriginRequestPolicyIdError::AccessDenied(inner) => Error::AccessDenied(inner),
            crate::operation::list_distributions_by_origin_request_policy_id::ListDistributionsByOriginRequestPolicyIdError::InvalidArgument(inner) => Error::InvalidArgument(inner),
            crate::operation::list_distributions_by_origin_request_policy_id::ListDistributionsByOriginRequestPolicyIdError::NoSuchOriginRequestPolicy(inner) => Error::NoSuchOriginRequestPolicy(inner),
            crate::operation::list_distributions_by_origin_request_policy_id::ListDistributionsByOriginRequestPolicyIdError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::list_distributions_by_realtime_log_config::ListDistributionsByRealtimeLogConfigError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::list_distributions_by_realtime_log_config::ListDistributionsByRealtimeLogConfigError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::list_distributions_by_realtime_log_config::ListDistributionsByRealtimeLogConfigError> for Error {
    fn from(err: crate::operation::list_distributions_by_realtime_log_config::ListDistributionsByRealtimeLogConfigError) -> Self {
        match err {
            crate::operation::list_distributions_by_realtime_log_config::ListDistributionsByRealtimeLogConfigError::InvalidArgument(inner) => Error::InvalidArgument(inner),
            crate::operation::list_distributions_by_realtime_log_config::ListDistributionsByRealtimeLogConfigError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::list_distributions_by_response_headers_policy_id::ListDistributionsByResponseHeadersPolicyIdError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::list_distributions_by_response_headers_policy_id::ListDistributionsByResponseHeadersPolicyIdError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::list_distributions_by_response_headers_policy_id::ListDistributionsByResponseHeadersPolicyIdError> for Error {
    fn from(err: crate::operation::list_distributions_by_response_headers_policy_id::ListDistributionsByResponseHeadersPolicyIdError) -> Self {
        match err {
            crate::operation::list_distributions_by_response_headers_policy_id::ListDistributionsByResponseHeadersPolicyIdError::AccessDenied(inner) => Error::AccessDenied(inner),
            crate::operation::list_distributions_by_response_headers_policy_id::ListDistributionsByResponseHeadersPolicyIdError::InvalidArgument(inner) => Error::InvalidArgument(inner),
            crate::operation::list_distributions_by_response_headers_policy_id::ListDistributionsByResponseHeadersPolicyIdError::NoSuchResponseHeadersPolicy(inner) => Error::NoSuchResponseHeadersPolicy(inner),
            crate::operation::list_distributions_by_response_headers_policy_id::ListDistributionsByResponseHeadersPolicyIdError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::list_distributions_by_web_acl_id::ListDistributionsByWebACLIdError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::list_distributions_by_web_acl_id::ListDistributionsByWebACLIdError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::list_distributions_by_web_acl_id::ListDistributionsByWebACLIdError> for Error {
    fn from(err: crate::operation::list_distributions_by_web_acl_id::ListDistributionsByWebACLIdError) -> Self {
        match err {
            crate::operation::list_distributions_by_web_acl_id::ListDistributionsByWebACLIdError::InvalidArgument(inner) => Error::InvalidArgument(inner),
            crate::operation::list_distributions_by_web_acl_id::ListDistributionsByWebACLIdError::InvalidWebAclId(inner) => Error::InvalidWebAclId(inner),
            crate::operation::list_distributions_by_web_acl_id::ListDistributionsByWebACLIdError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::list_field_level_encryption_configs::ListFieldLevelEncryptionConfigsError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::list_field_level_encryption_configs::ListFieldLevelEncryptionConfigsError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::list_field_level_encryption_configs::ListFieldLevelEncryptionConfigsError> for Error {
    fn from(err: crate::operation::list_field_level_encryption_configs::ListFieldLevelEncryptionConfigsError) -> Self {
        match err {
            crate::operation::list_field_level_encryption_configs::ListFieldLevelEncryptionConfigsError::InvalidArgument(inner) => Error::InvalidArgument(inner),
            crate::operation::list_field_level_encryption_configs::ListFieldLevelEncryptionConfigsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::list_field_level_encryption_profiles::ListFieldLevelEncryptionProfilesError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::list_field_level_encryption_profiles::ListFieldLevelEncryptionProfilesError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::list_field_level_encryption_profiles::ListFieldLevelEncryptionProfilesError> for Error {
    fn from(err: crate::operation::list_field_level_encryption_profiles::ListFieldLevelEncryptionProfilesError) -> Self {
        match err {
            crate::operation::list_field_level_encryption_profiles::ListFieldLevelEncryptionProfilesError::InvalidArgument(inner) => Error::InvalidArgument(inner),
            crate::operation::list_field_level_encryption_profiles::ListFieldLevelEncryptionProfilesError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::list_functions::ListFunctionsError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::list_functions::ListFunctionsError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::list_functions::ListFunctionsError> for Error {
    fn from(err: crate::operation::list_functions::ListFunctionsError) -> Self {
        match err {
            crate::operation::list_functions::ListFunctionsError::InvalidArgument(inner) => Error::InvalidArgument(inner),
            crate::operation::list_functions::ListFunctionsError::UnsupportedOperation(inner) => Error::UnsupportedOperation(inner),
            crate::operation::list_functions::ListFunctionsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::list_invalidations::ListInvalidationsError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::list_invalidations::ListInvalidationsError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::list_invalidations::ListInvalidationsError> for Error {
    fn from(err: crate::operation::list_invalidations::ListInvalidationsError) -> Self {
        match err {
            crate::operation::list_invalidations::ListInvalidationsError::AccessDenied(inner) => Error::AccessDenied(inner),
            crate::operation::list_invalidations::ListInvalidationsError::InvalidArgument(inner) => Error::InvalidArgument(inner),
            crate::operation::list_invalidations::ListInvalidationsError::NoSuchDistribution(inner) => Error::NoSuchDistribution(inner),
            crate::operation::list_invalidations::ListInvalidationsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::list_key_groups::ListKeyGroupsError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::list_key_groups::ListKeyGroupsError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::list_key_groups::ListKeyGroupsError> for Error {
    fn from(err: crate::operation::list_key_groups::ListKeyGroupsError) -> Self {
        match err {
            crate::operation::list_key_groups::ListKeyGroupsError::InvalidArgument(inner) => Error::InvalidArgument(inner),
            crate::operation::list_key_groups::ListKeyGroupsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::list_origin_access_controls::ListOriginAccessControlsError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::list_origin_access_controls::ListOriginAccessControlsError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::list_origin_access_controls::ListOriginAccessControlsError> for Error {
    fn from(err: crate::operation::list_origin_access_controls::ListOriginAccessControlsError) -> Self {
        match err {
            crate::operation::list_origin_access_controls::ListOriginAccessControlsError::InvalidArgument(inner) => Error::InvalidArgument(inner),
            crate::operation::list_origin_access_controls::ListOriginAccessControlsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::list_origin_request_policies::ListOriginRequestPoliciesError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::list_origin_request_policies::ListOriginRequestPoliciesError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::list_origin_request_policies::ListOriginRequestPoliciesError> for Error {
    fn from(err: crate::operation::list_origin_request_policies::ListOriginRequestPoliciesError) -> Self {
        match err {
            crate::operation::list_origin_request_policies::ListOriginRequestPoliciesError::AccessDenied(inner) => Error::AccessDenied(inner),
            crate::operation::list_origin_request_policies::ListOriginRequestPoliciesError::InvalidArgument(inner) => Error::InvalidArgument(inner),
            crate::operation::list_origin_request_policies::ListOriginRequestPoliciesError::NoSuchOriginRequestPolicy(inner) => Error::NoSuchOriginRequestPolicy(inner),
            crate::operation::list_origin_request_policies::ListOriginRequestPoliciesError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::list_public_keys::ListPublicKeysError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::list_public_keys::ListPublicKeysError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::list_public_keys::ListPublicKeysError> for Error {
    fn from(err: crate::operation::list_public_keys::ListPublicKeysError) -> Self {
        match err {
            crate::operation::list_public_keys::ListPublicKeysError::InvalidArgument(inner) => Error::InvalidArgument(inner),
            crate::operation::list_public_keys::ListPublicKeysError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::list_realtime_log_configs::ListRealtimeLogConfigsError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::list_realtime_log_configs::ListRealtimeLogConfigsError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::list_realtime_log_configs::ListRealtimeLogConfigsError> for Error {
    fn from(err: crate::operation::list_realtime_log_configs::ListRealtimeLogConfigsError) -> Self {
        match err {
            crate::operation::list_realtime_log_configs::ListRealtimeLogConfigsError::AccessDenied(inner) => Error::AccessDenied(inner),
            crate::operation::list_realtime_log_configs::ListRealtimeLogConfigsError::InvalidArgument(inner) => Error::InvalidArgument(inner),
            crate::operation::list_realtime_log_configs::ListRealtimeLogConfigsError::NoSuchRealtimeLogConfig(inner) => Error::NoSuchRealtimeLogConfig(inner),
            crate::operation::list_realtime_log_configs::ListRealtimeLogConfigsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::list_response_headers_policies::ListResponseHeadersPoliciesError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::list_response_headers_policies::ListResponseHeadersPoliciesError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::list_response_headers_policies::ListResponseHeadersPoliciesError> for Error {
    fn from(err: crate::operation::list_response_headers_policies::ListResponseHeadersPoliciesError) -> Self {
        match err {
            crate::operation::list_response_headers_policies::ListResponseHeadersPoliciesError::AccessDenied(inner) => Error::AccessDenied(inner),
            crate::operation::list_response_headers_policies::ListResponseHeadersPoliciesError::InvalidArgument(inner) => Error::InvalidArgument(inner),
            crate::operation::list_response_headers_policies::ListResponseHeadersPoliciesError::NoSuchResponseHeadersPolicy(inner) => Error::NoSuchResponseHeadersPolicy(inner),
            crate::operation::list_response_headers_policies::ListResponseHeadersPoliciesError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::list_streaming_distributions::ListStreamingDistributionsError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::list_streaming_distributions::ListStreamingDistributionsError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::list_streaming_distributions::ListStreamingDistributionsError> for Error {
    fn from(err: crate::operation::list_streaming_distributions::ListStreamingDistributionsError) -> Self {
        match err {
            crate::operation::list_streaming_distributions::ListStreamingDistributionsError::InvalidArgument(inner) => Error::InvalidArgument(inner),
            crate::operation::list_streaming_distributions::ListStreamingDistributionsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::list_tags_for_resource::ListTagsForResourceError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::list_tags_for_resource::ListTagsForResourceError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::list_tags_for_resource::ListTagsForResourceError> for Error {
    fn from(err: crate::operation::list_tags_for_resource::ListTagsForResourceError) -> Self {
        match err {
            crate::operation::list_tags_for_resource::ListTagsForResourceError::AccessDenied(inner) => Error::AccessDenied(inner),
            crate::operation::list_tags_for_resource::ListTagsForResourceError::InvalidArgument(inner) => Error::InvalidArgument(inner),
            crate::operation::list_tags_for_resource::ListTagsForResourceError::InvalidTagging(inner) => Error::InvalidTagging(inner),
            crate::operation::list_tags_for_resource::ListTagsForResourceError::NoSuchResource(inner) => Error::NoSuchResource(inner),
            crate::operation::list_tags_for_resource::ListTagsForResourceError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::publish_function::PublishFunctionError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::publish_function::PublishFunctionError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::publish_function::PublishFunctionError> for Error {
    fn from(err: crate::operation::publish_function::PublishFunctionError) -> Self {
        match err {
            crate::operation::publish_function::PublishFunctionError::InvalidArgument(inner) => Error::InvalidArgument(inner),
            crate::operation::publish_function::PublishFunctionError::InvalidIfMatchVersion(inner) => Error::InvalidIfMatchVersion(inner),
            crate::operation::publish_function::PublishFunctionError::NoSuchFunctionExists(inner) => Error::NoSuchFunctionExists(inner),
            crate::operation::publish_function::PublishFunctionError::PreconditionFailed(inner) => Error::PreconditionFailed(inner),
            crate::operation::publish_function::PublishFunctionError::UnsupportedOperation(inner) => Error::UnsupportedOperation(inner),
            crate::operation::publish_function::PublishFunctionError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::tag_resource::TagResourceError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::tag_resource::TagResourceError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::tag_resource::TagResourceError> for Error {
    fn from(err: crate::operation::tag_resource::TagResourceError) -> Self {
        match err {
            crate::operation::tag_resource::TagResourceError::AccessDenied(inner) => Error::AccessDenied(inner),
            crate::operation::tag_resource::TagResourceError::InvalidArgument(inner) => Error::InvalidArgument(inner),
            crate::operation::tag_resource::TagResourceError::InvalidTagging(inner) => Error::InvalidTagging(inner),
            crate::operation::tag_resource::TagResourceError::NoSuchResource(inner) => Error::NoSuchResource(inner),
            crate::operation::tag_resource::TagResourceError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::test_function::TestFunctionError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::test_function::TestFunctionError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::test_function::TestFunctionError> for Error {
    fn from(err: crate::operation::test_function::TestFunctionError) -> Self {
        match err {
            crate::operation::test_function::TestFunctionError::InvalidArgument(inner) => Error::InvalidArgument(inner),
            crate::operation::test_function::TestFunctionError::InvalidIfMatchVersion(inner) => Error::InvalidIfMatchVersion(inner),
            crate::operation::test_function::TestFunctionError::NoSuchFunctionExists(inner) => Error::NoSuchFunctionExists(inner),
            crate::operation::test_function::TestFunctionError::TestFunctionFailed(inner) => Error::TestFunctionFailed(inner),
            crate::operation::test_function::TestFunctionError::UnsupportedOperation(inner) => Error::UnsupportedOperation(inner),
            crate::operation::test_function::TestFunctionError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::untag_resource::UntagResourceError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::untag_resource::UntagResourceError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::untag_resource::UntagResourceError> for Error {
    fn from(err: crate::operation::untag_resource::UntagResourceError) -> Self {
        match err {
            crate::operation::untag_resource::UntagResourceError::AccessDenied(inner) => Error::AccessDenied(inner),
            crate::operation::untag_resource::UntagResourceError::InvalidArgument(inner) => Error::InvalidArgument(inner),
            crate::operation::untag_resource::UntagResourceError::InvalidTagging(inner) => Error::InvalidTagging(inner),
            crate::operation::untag_resource::UntagResourceError::NoSuchResource(inner) => Error::NoSuchResource(inner),
            crate::operation::untag_resource::UntagResourceError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::update_cache_policy::UpdateCachePolicyError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::update_cache_policy::UpdateCachePolicyError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::update_cache_policy::UpdateCachePolicyError> for Error {
    fn from(err: crate::operation::update_cache_policy::UpdateCachePolicyError) -> Self {
        match err {
            crate::operation::update_cache_policy::UpdateCachePolicyError::AccessDenied(inner) => Error::AccessDenied(inner),
            crate::operation::update_cache_policy::UpdateCachePolicyError::CachePolicyAlreadyExists(inner) => Error::CachePolicyAlreadyExists(inner),
            crate::operation::update_cache_policy::UpdateCachePolicyError::IllegalUpdate(inner) => Error::IllegalUpdate(inner),
            crate::operation::update_cache_policy::UpdateCachePolicyError::InconsistentQuantities(inner) => Error::InconsistentQuantities(inner),
            crate::operation::update_cache_policy::UpdateCachePolicyError::InvalidArgument(inner) => Error::InvalidArgument(inner),
            crate::operation::update_cache_policy::UpdateCachePolicyError::InvalidIfMatchVersion(inner) => Error::InvalidIfMatchVersion(inner),
            crate::operation::update_cache_policy::UpdateCachePolicyError::NoSuchCachePolicy(inner) => Error::NoSuchCachePolicy(inner),
            crate::operation::update_cache_policy::UpdateCachePolicyError::PreconditionFailed(inner) => Error::PreconditionFailed(inner),
            crate::operation::update_cache_policy::UpdateCachePolicyError::TooManyCookiesInCachePolicy(inner) => Error::TooManyCookiesInCachePolicy(inner),
            crate::operation::update_cache_policy::UpdateCachePolicyError::TooManyHeadersInCachePolicy(inner) => Error::TooManyHeadersInCachePolicy(inner),
            crate::operation::update_cache_policy::UpdateCachePolicyError::TooManyQueryStringsInCachePolicy(inner) => Error::TooManyQueryStringsInCachePolicy(inner),
            crate::operation::update_cache_policy::UpdateCachePolicyError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::update_cloud_front_origin_access_identity::UpdateCloudFrontOriginAccessIdentityError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::update_cloud_front_origin_access_identity::UpdateCloudFrontOriginAccessIdentityError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::update_cloud_front_origin_access_identity::UpdateCloudFrontOriginAccessIdentityError> for Error {
    fn from(err: crate::operation::update_cloud_front_origin_access_identity::UpdateCloudFrontOriginAccessIdentityError) -> Self {
        match err {
            crate::operation::update_cloud_front_origin_access_identity::UpdateCloudFrontOriginAccessIdentityError::AccessDenied(inner) => Error::AccessDenied(inner),
            crate::operation::update_cloud_front_origin_access_identity::UpdateCloudFrontOriginAccessIdentityError::IllegalUpdate(inner) => Error::IllegalUpdate(inner),
            crate::operation::update_cloud_front_origin_access_identity::UpdateCloudFrontOriginAccessIdentityError::InconsistentQuantities(inner) => Error::InconsistentQuantities(inner),
            crate::operation::update_cloud_front_origin_access_identity::UpdateCloudFrontOriginAccessIdentityError::InvalidArgument(inner) => Error::InvalidArgument(inner),
            crate::operation::update_cloud_front_origin_access_identity::UpdateCloudFrontOriginAccessIdentityError::InvalidIfMatchVersion(inner) => Error::InvalidIfMatchVersion(inner),
            crate::operation::update_cloud_front_origin_access_identity::UpdateCloudFrontOriginAccessIdentityError::MissingBody(inner) => Error::MissingBody(inner),
            crate::operation::update_cloud_front_origin_access_identity::UpdateCloudFrontOriginAccessIdentityError::NoSuchCloudFrontOriginAccessIdentity(inner) => Error::NoSuchCloudFrontOriginAccessIdentity(inner),
            crate::operation::update_cloud_front_origin_access_identity::UpdateCloudFrontOriginAccessIdentityError::PreconditionFailed(inner) => Error::PreconditionFailed(inner),
            crate::operation::update_cloud_front_origin_access_identity::UpdateCloudFrontOriginAccessIdentityError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::update_continuous_deployment_policy::UpdateContinuousDeploymentPolicyError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::update_continuous_deployment_policy::UpdateContinuousDeploymentPolicyError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::update_continuous_deployment_policy::UpdateContinuousDeploymentPolicyError> for Error {
    fn from(err: crate::operation::update_continuous_deployment_policy::UpdateContinuousDeploymentPolicyError) -> Self {
        match err {
            crate::operation::update_continuous_deployment_policy::UpdateContinuousDeploymentPolicyError::AccessDenied(inner) => Error::AccessDenied(inner),
            crate::operation::update_continuous_deployment_policy::UpdateContinuousDeploymentPolicyError::InconsistentQuantities(inner) => Error::InconsistentQuantities(inner),
            crate::operation::update_continuous_deployment_policy::UpdateContinuousDeploymentPolicyError::InvalidArgument(inner) => Error::InvalidArgument(inner),
            crate::operation::update_continuous_deployment_policy::UpdateContinuousDeploymentPolicyError::InvalidIfMatchVersion(inner) => Error::InvalidIfMatchVersion(inner),
            crate::operation::update_continuous_deployment_policy::UpdateContinuousDeploymentPolicyError::NoSuchContinuousDeploymentPolicy(inner) => Error::NoSuchContinuousDeploymentPolicy(inner),
            crate::operation::update_continuous_deployment_policy::UpdateContinuousDeploymentPolicyError::PreconditionFailed(inner) => Error::PreconditionFailed(inner),
            crate::operation::update_continuous_deployment_policy::UpdateContinuousDeploymentPolicyError::StagingDistributionInUse(inner) => Error::StagingDistributionInUse(inner),
            crate::operation::update_continuous_deployment_policy::UpdateContinuousDeploymentPolicyError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::update_distribution::UpdateDistributionError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::update_distribution::UpdateDistributionError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::update_distribution::UpdateDistributionError> for Error {
    fn from(err: crate::operation::update_distribution::UpdateDistributionError) -> Self {
        match err {
            crate::operation::update_distribution::UpdateDistributionError::AccessDenied(inner) => Error::AccessDenied(inner),
            crate::operation::update_distribution::UpdateDistributionError::CnameAlreadyExists(inner) => Error::CnameAlreadyExists(inner),
            crate::operation::update_distribution::UpdateDistributionError::ContinuousDeploymentPolicyInUse(inner) => Error::ContinuousDeploymentPolicyInUse(inner),
            crate::operation::update_distribution::UpdateDistributionError::IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior(inner) => Error::IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior(inner),
            crate::operation::update_distribution::UpdateDistributionError::IllegalOriginAccessConfiguration(inner) => Error::IllegalOriginAccessConfiguration(inner),
            crate::operation::update_distribution::UpdateDistributionError::IllegalUpdate(inner) => Error::IllegalUpdate(inner),
            crate::operation::update_distribution::UpdateDistributionError::InconsistentQuantities(inner) => Error::InconsistentQuantities(inner),
            crate::operation::update_distribution::UpdateDistributionError::InvalidArgument(inner) => Error::InvalidArgument(inner),
            crate::operation::update_distribution::UpdateDistributionError::InvalidDefaultRootObject(inner) => Error::InvalidDefaultRootObject(inner),
            crate::operation::update_distribution::UpdateDistributionError::InvalidDomainNameForOriginAccessControl(inner) => Error::InvalidDomainNameForOriginAccessControl(inner),
            crate::operation::update_distribution::UpdateDistributionError::InvalidErrorCode(inner) => Error::InvalidErrorCode(inner),
            crate::operation::update_distribution::UpdateDistributionError::InvalidForwardCookies(inner) => Error::InvalidForwardCookies(inner),
            crate::operation::update_distribution::UpdateDistributionError::InvalidFunctionAssociation(inner) => Error::InvalidFunctionAssociation(inner),
            crate::operation::update_distribution::UpdateDistributionError::InvalidGeoRestrictionParameter(inner) => Error::InvalidGeoRestrictionParameter(inner),
            crate::operation::update_distribution::UpdateDistributionError::InvalidHeadersForS3Origin(inner) => Error::InvalidHeadersForS3Origin(inner),
            crate::operation::update_distribution::UpdateDistributionError::InvalidIfMatchVersion(inner) => Error::InvalidIfMatchVersion(inner),
            crate::operation::update_distribution::UpdateDistributionError::InvalidLambdaFunctionAssociation(inner) => Error::InvalidLambdaFunctionAssociation(inner),
            crate::operation::update_distribution::UpdateDistributionError::InvalidLocationCode(inner) => Error::InvalidLocationCode(inner),
            crate::operation::update_distribution::UpdateDistributionError::InvalidMinimumProtocolVersion(inner) => Error::InvalidMinimumProtocolVersion(inner),
            crate::operation::update_distribution::UpdateDistributionError::InvalidOriginAccessControl(inner) => Error::InvalidOriginAccessControl(inner),
            crate::operation::update_distribution::UpdateDistributionError::InvalidOriginAccessIdentity(inner) => Error::InvalidOriginAccessIdentity(inner),
            crate::operation::update_distribution::UpdateDistributionError::InvalidOriginKeepaliveTimeout(inner) => Error::InvalidOriginKeepaliveTimeout(inner),
            crate::operation::update_distribution::UpdateDistributionError::InvalidOriginReadTimeout(inner) => Error::InvalidOriginReadTimeout(inner),
            crate::operation::update_distribution::UpdateDistributionError::InvalidQueryStringParameters(inner) => Error::InvalidQueryStringParameters(inner),
            crate::operation::update_distribution::UpdateDistributionError::InvalidRelativePath(inner) => Error::InvalidRelativePath(inner),
            crate::operation::update_distribution::UpdateDistributionError::InvalidRequiredProtocol(inner) => Error::InvalidRequiredProtocol(inner),
            crate::operation::update_distribution::UpdateDistributionError::InvalidResponseCode(inner) => Error::InvalidResponseCode(inner),
            crate::operation::update_distribution::UpdateDistributionError::InvalidTtlOrder(inner) => Error::InvalidTtlOrder(inner),
            crate::operation::update_distribution::UpdateDistributionError::InvalidViewerCertificate(inner) => Error::InvalidViewerCertificate(inner),
            crate::operation::update_distribution::UpdateDistributionError::InvalidWebAclId(inner) => Error::InvalidWebAclId(inner),
            crate::operation::update_distribution::UpdateDistributionError::MissingBody(inner) => Error::MissingBody(inner),
            crate::operation::update_distribution::UpdateDistributionError::NoSuchCachePolicy(inner) => Error::NoSuchCachePolicy(inner),
            crate::operation::update_distribution::UpdateDistributionError::NoSuchContinuousDeploymentPolicy(inner) => Error::NoSuchContinuousDeploymentPolicy(inner),
            crate::operation::update_distribution::UpdateDistributionError::NoSuchDistribution(inner) => Error::NoSuchDistribution(inner),
            crate::operation::update_distribution::UpdateDistributionError::NoSuchFieldLevelEncryptionConfig(inner) => Error::NoSuchFieldLevelEncryptionConfig(inner),
            crate::operation::update_distribution::UpdateDistributionError::NoSuchOrigin(inner) => Error::NoSuchOrigin(inner),
            crate::operation::update_distribution::UpdateDistributionError::NoSuchOriginRequestPolicy(inner) => Error::NoSuchOriginRequestPolicy(inner),
            crate::operation::update_distribution::UpdateDistributionError::NoSuchRealtimeLogConfig(inner) => Error::NoSuchRealtimeLogConfig(inner),
            crate::operation::update_distribution::UpdateDistributionError::NoSuchResponseHeadersPolicy(inner) => Error::NoSuchResponseHeadersPolicy(inner),
            crate::operation::update_distribution::UpdateDistributionError::PreconditionFailed(inner) => Error::PreconditionFailed(inner),
            crate::operation::update_distribution::UpdateDistributionError::RealtimeLogConfigOwnerMismatch(inner) => Error::RealtimeLogConfigOwnerMismatch(inner),
            crate::operation::update_distribution::UpdateDistributionError::StagingDistributionInUse(inner) => Error::StagingDistributionInUse(inner),
            crate::operation::update_distribution::UpdateDistributionError::TooManyCacheBehaviors(inner) => Error::TooManyCacheBehaviors(inner),
            crate::operation::update_distribution::UpdateDistributionError::TooManyCertificates(inner) => Error::TooManyCertificates(inner),
            crate::operation::update_distribution::UpdateDistributionError::TooManyCookieNamesInWhiteList(inner) => Error::TooManyCookieNamesInWhiteList(inner),
            crate::operation::update_distribution::UpdateDistributionError::TooManyDistributionCnamEs(inner) => Error::TooManyDistributionCnamEs(inner),
            crate::operation::update_distribution::UpdateDistributionError::TooManyDistributionsAssociatedToCachePolicy(inner) => Error::TooManyDistributionsAssociatedToCachePolicy(inner),
            crate::operation::update_distribution::UpdateDistributionError::TooManyDistributionsAssociatedToFieldLevelEncryptionConfig(inner) => Error::TooManyDistributionsAssociatedToFieldLevelEncryptionConfig(inner),
            crate::operation::update_distribution::UpdateDistributionError::TooManyDistributionsAssociatedToKeyGroup(inner) => Error::TooManyDistributionsAssociatedToKeyGroup(inner),
            crate::operation::update_distribution::UpdateDistributionError::TooManyDistributionsAssociatedToOriginRequestPolicy(inner) => Error::TooManyDistributionsAssociatedToOriginRequestPolicy(inner),
            crate::operation::update_distribution::UpdateDistributionError::TooManyDistributionsAssociatedToResponseHeadersPolicy(inner) => Error::TooManyDistributionsAssociatedToResponseHeadersPolicy(inner),
            crate::operation::update_distribution::UpdateDistributionError::TooManyDistributionsWithFunctionAssociations(inner) => Error::TooManyDistributionsWithFunctionAssociations(inner),
            crate::operation::update_distribution::UpdateDistributionError::TooManyDistributionsWithLambdaAssociations(inner) => Error::TooManyDistributionsWithLambdaAssociations(inner),
            crate::operation::update_distribution::UpdateDistributionError::TooManyDistributionsWithSingleFunctionArn(inner) => Error::TooManyDistributionsWithSingleFunctionArn(inner),
            crate::operation::update_distribution::UpdateDistributionError::TooManyFunctionAssociations(inner) => Error::TooManyFunctionAssociations(inner),
            crate::operation::update_distribution::UpdateDistributionError::TooManyHeadersInForwardedValues(inner) => Error::TooManyHeadersInForwardedValues(inner),
            crate::operation::update_distribution::UpdateDistributionError::TooManyKeyGroupsAssociatedToDistribution(inner) => Error::TooManyKeyGroupsAssociatedToDistribution(inner),
            crate::operation::update_distribution::UpdateDistributionError::TooManyLambdaFunctionAssociations(inner) => Error::TooManyLambdaFunctionAssociations(inner),
            crate::operation::update_distribution::UpdateDistributionError::TooManyOriginCustomHeaders(inner) => Error::TooManyOriginCustomHeaders(inner),
            crate::operation::update_distribution::UpdateDistributionError::TooManyOriginGroupsPerDistribution(inner) => Error::TooManyOriginGroupsPerDistribution(inner),
            crate::operation::update_distribution::UpdateDistributionError::TooManyOrigins(inner) => Error::TooManyOrigins(inner),
            crate::operation::update_distribution::UpdateDistributionError::TooManyQueryStringParameters(inner) => Error::TooManyQueryStringParameters(inner),
            crate::operation::update_distribution::UpdateDistributionError::TooManyTrustedSigners(inner) => Error::TooManyTrustedSigners(inner),
            crate::operation::update_distribution::UpdateDistributionError::TrustedKeyGroupDoesNotExist(inner) => Error::TrustedKeyGroupDoesNotExist(inner),
            crate::operation::update_distribution::UpdateDistributionError::TrustedSignerDoesNotExist(inner) => Error::TrustedSignerDoesNotExist(inner),
            crate::operation::update_distribution::UpdateDistributionError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::update_distribution_with_staging_config::UpdateDistributionWithStagingConfigError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::update_distribution_with_staging_config::UpdateDistributionWithStagingConfigError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::update_distribution_with_staging_config::UpdateDistributionWithStagingConfigError> for Error {
    fn from(err: crate::operation::update_distribution_with_staging_config::UpdateDistributionWithStagingConfigError) -> Self {
        match err {
            crate::operation::update_distribution_with_staging_config::UpdateDistributionWithStagingConfigError::AccessDenied(inner) => Error::AccessDenied(inner),
            crate::operation::update_distribution_with_staging_config::UpdateDistributionWithStagingConfigError::CnameAlreadyExists(inner) => Error::CnameAlreadyExists(inner),
            crate::operation::update_distribution_with_staging_config::UpdateDistributionWithStagingConfigError::IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior(inner) => Error::IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior(inner),
            crate::operation::update_distribution_with_staging_config::UpdateDistributionWithStagingConfigError::IllegalUpdate(inner) => Error::IllegalUpdate(inner),
            crate::operation::update_distribution_with_staging_config::UpdateDistributionWithStagingConfigError::InconsistentQuantities(inner) => Error::InconsistentQuantities(inner),
            crate::operation::update_distribution_with_staging_config::UpdateDistributionWithStagingConfigError::InvalidArgument(inner) => Error::InvalidArgument(inner),
            crate::operation::update_distribution_with_staging_config::UpdateDistributionWithStagingConfigError::InvalidDefaultRootObject(inner) => Error::InvalidDefaultRootObject(inner),
            crate::operation::update_distribution_with_staging_config::UpdateDistributionWithStagingConfigError::InvalidErrorCode(inner) => Error::InvalidErrorCode(inner),
            crate::operation::update_distribution_with_staging_config::UpdateDistributionWithStagingConfigError::InvalidForwardCookies(inner) => Error::InvalidForwardCookies(inner),
            crate::operation::update_distribution_with_staging_config::UpdateDistributionWithStagingConfigError::InvalidFunctionAssociation(inner) => Error::InvalidFunctionAssociation(inner),
            crate::operation::update_distribution_with_staging_config::UpdateDistributionWithStagingConfigError::InvalidGeoRestrictionParameter(inner) => Error::InvalidGeoRestrictionParameter(inner),
            crate::operation::update_distribution_with_staging_config::UpdateDistributionWithStagingConfigError::InvalidHeadersForS3Origin(inner) => Error::InvalidHeadersForS3Origin(inner),
            crate::operation::update_distribution_with_staging_config::UpdateDistributionWithStagingConfigError::InvalidIfMatchVersion(inner) => Error::InvalidIfMatchVersion(inner),
            crate::operation::update_distribution_with_staging_config::UpdateDistributionWithStagingConfigError::InvalidLambdaFunctionAssociation(inner) => Error::InvalidLambdaFunctionAssociation(inner),
            crate::operation::update_distribution_with_staging_config::UpdateDistributionWithStagingConfigError::InvalidLocationCode(inner) => Error::InvalidLocationCode(inner),
            crate::operation::update_distribution_with_staging_config::UpdateDistributionWithStagingConfigError::InvalidMinimumProtocolVersion(inner) => Error::InvalidMinimumProtocolVersion(inner),
            crate::operation::update_distribution_with_staging_config::UpdateDistributionWithStagingConfigError::InvalidOriginAccessControl(inner) => Error::InvalidOriginAccessControl(inner),
            crate::operation::update_distribution_with_staging_config::UpdateDistributionWithStagingConfigError::InvalidOriginAccessIdentity(inner) => Error::InvalidOriginAccessIdentity(inner),
            crate::operation::update_distribution_with_staging_config::UpdateDistributionWithStagingConfigError::InvalidOriginKeepaliveTimeout(inner) => Error::InvalidOriginKeepaliveTimeout(inner),
            crate::operation::update_distribution_with_staging_config::UpdateDistributionWithStagingConfigError::InvalidOriginReadTimeout(inner) => Error::InvalidOriginReadTimeout(inner),
            crate::operation::update_distribution_with_staging_config::UpdateDistributionWithStagingConfigError::InvalidQueryStringParameters(inner) => Error::InvalidQueryStringParameters(inner),
            crate::operation::update_distribution_with_staging_config::UpdateDistributionWithStagingConfigError::InvalidRelativePath(inner) => Error::InvalidRelativePath(inner),
            crate::operation::update_distribution_with_staging_config::UpdateDistributionWithStagingConfigError::InvalidRequiredProtocol(inner) => Error::InvalidRequiredProtocol(inner),
            crate::operation::update_distribution_with_staging_config::UpdateDistributionWithStagingConfigError::InvalidResponseCode(inner) => Error::InvalidResponseCode(inner),
            crate::operation::update_distribution_with_staging_config::UpdateDistributionWithStagingConfigError::InvalidTtlOrder(inner) => Error::InvalidTtlOrder(inner),
            crate::operation::update_distribution_with_staging_config::UpdateDistributionWithStagingConfigError::InvalidViewerCertificate(inner) => Error::InvalidViewerCertificate(inner),
            crate::operation::update_distribution_with_staging_config::UpdateDistributionWithStagingConfigError::InvalidWebAclId(inner) => Error::InvalidWebAclId(inner),
            crate::operation::update_distribution_with_staging_config::UpdateDistributionWithStagingConfigError::MissingBody(inner) => Error::MissingBody(inner),
            crate::operation::update_distribution_with_staging_config::UpdateDistributionWithStagingConfigError::NoSuchCachePolicy(inner) => Error::NoSuchCachePolicy(inner),
            crate::operation::update_distribution_with_staging_config::UpdateDistributionWithStagingConfigError::NoSuchDistribution(inner) => Error::NoSuchDistribution(inner),
            crate::operation::update_distribution_with_staging_config::UpdateDistributionWithStagingConfigError::NoSuchFieldLevelEncryptionConfig(inner) => Error::NoSuchFieldLevelEncryptionConfig(inner),
            crate::operation::update_distribution_with_staging_config::UpdateDistributionWithStagingConfigError::NoSuchOrigin(inner) => Error::NoSuchOrigin(inner),
            crate::operation::update_distribution_with_staging_config::UpdateDistributionWithStagingConfigError::NoSuchOriginRequestPolicy(inner) => Error::NoSuchOriginRequestPolicy(inner),
            crate::operation::update_distribution_with_staging_config::UpdateDistributionWithStagingConfigError::NoSuchRealtimeLogConfig(inner) => Error::NoSuchRealtimeLogConfig(inner),
            crate::operation::update_distribution_with_staging_config::UpdateDistributionWithStagingConfigError::NoSuchResponseHeadersPolicy(inner) => Error::NoSuchResponseHeadersPolicy(inner),
            crate::operation::update_distribution_with_staging_config::UpdateDistributionWithStagingConfigError::PreconditionFailed(inner) => Error::PreconditionFailed(inner),
            crate::operation::update_distribution_with_staging_config::UpdateDistributionWithStagingConfigError::RealtimeLogConfigOwnerMismatch(inner) => Error::RealtimeLogConfigOwnerMismatch(inner),
            crate::operation::update_distribution_with_staging_config::UpdateDistributionWithStagingConfigError::TooManyCacheBehaviors(inner) => Error::TooManyCacheBehaviors(inner),
            crate::operation::update_distribution_with_staging_config::UpdateDistributionWithStagingConfigError::TooManyCertificates(inner) => Error::TooManyCertificates(inner),
            crate::operation::update_distribution_with_staging_config::UpdateDistributionWithStagingConfigError::TooManyCookieNamesInWhiteList(inner) => Error::TooManyCookieNamesInWhiteList(inner),
            crate::operation::update_distribution_with_staging_config::UpdateDistributionWithStagingConfigError::TooManyDistributionCnamEs(inner) => Error::TooManyDistributionCnamEs(inner),
            crate::operation::update_distribution_with_staging_config::UpdateDistributionWithStagingConfigError::TooManyDistributionsAssociatedToCachePolicy(inner) => Error::TooManyDistributionsAssociatedToCachePolicy(inner),
            crate::operation::update_distribution_with_staging_config::UpdateDistributionWithStagingConfigError::TooManyDistributionsAssociatedToFieldLevelEncryptionConfig(inner) => Error::TooManyDistributionsAssociatedToFieldLevelEncryptionConfig(inner),
            crate::operation::update_distribution_with_staging_config::UpdateDistributionWithStagingConfigError::TooManyDistributionsAssociatedToKeyGroup(inner) => Error::TooManyDistributionsAssociatedToKeyGroup(inner),
            crate::operation::update_distribution_with_staging_config::UpdateDistributionWithStagingConfigError::TooManyDistributionsAssociatedToOriginRequestPolicy(inner) => Error::TooManyDistributionsAssociatedToOriginRequestPolicy(inner),
            crate::operation::update_distribution_with_staging_config::UpdateDistributionWithStagingConfigError::TooManyDistributionsAssociatedToResponseHeadersPolicy(inner) => Error::TooManyDistributionsAssociatedToResponseHeadersPolicy(inner),
            crate::operation::update_distribution_with_staging_config::UpdateDistributionWithStagingConfigError::TooManyDistributionsWithFunctionAssociations(inner) => Error::TooManyDistributionsWithFunctionAssociations(inner),
            crate::operation::update_distribution_with_staging_config::UpdateDistributionWithStagingConfigError::TooManyDistributionsWithLambdaAssociations(inner) => Error::TooManyDistributionsWithLambdaAssociations(inner),
            crate::operation::update_distribution_with_staging_config::UpdateDistributionWithStagingConfigError::TooManyDistributionsWithSingleFunctionArn(inner) => Error::TooManyDistributionsWithSingleFunctionArn(inner),
            crate::operation::update_distribution_with_staging_config::UpdateDistributionWithStagingConfigError::TooManyFunctionAssociations(inner) => Error::TooManyFunctionAssociations(inner),
            crate::operation::update_distribution_with_staging_config::UpdateDistributionWithStagingConfigError::TooManyHeadersInForwardedValues(inner) => Error::TooManyHeadersInForwardedValues(inner),
            crate::operation::update_distribution_with_staging_config::UpdateDistributionWithStagingConfigError::TooManyKeyGroupsAssociatedToDistribution(inner) => Error::TooManyKeyGroupsAssociatedToDistribution(inner),
            crate::operation::update_distribution_with_staging_config::UpdateDistributionWithStagingConfigError::TooManyLambdaFunctionAssociations(inner) => Error::TooManyLambdaFunctionAssociations(inner),
            crate::operation::update_distribution_with_staging_config::UpdateDistributionWithStagingConfigError::TooManyOriginCustomHeaders(inner) => Error::TooManyOriginCustomHeaders(inner),
            crate::operation::update_distribution_with_staging_config::UpdateDistributionWithStagingConfigError::TooManyOriginGroupsPerDistribution(inner) => Error::TooManyOriginGroupsPerDistribution(inner),
            crate::operation::update_distribution_with_staging_config::UpdateDistributionWithStagingConfigError::TooManyOrigins(inner) => Error::TooManyOrigins(inner),
            crate::operation::update_distribution_with_staging_config::UpdateDistributionWithStagingConfigError::TooManyQueryStringParameters(inner) => Error::TooManyQueryStringParameters(inner),
            crate::operation::update_distribution_with_staging_config::UpdateDistributionWithStagingConfigError::TooManyTrustedSigners(inner) => Error::TooManyTrustedSigners(inner),
            crate::operation::update_distribution_with_staging_config::UpdateDistributionWithStagingConfigError::TrustedKeyGroupDoesNotExist(inner) => Error::TrustedKeyGroupDoesNotExist(inner),
            crate::operation::update_distribution_with_staging_config::UpdateDistributionWithStagingConfigError::TrustedSignerDoesNotExist(inner) => Error::TrustedSignerDoesNotExist(inner),
            crate::operation::update_distribution_with_staging_config::UpdateDistributionWithStagingConfigError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::update_field_level_encryption_config::UpdateFieldLevelEncryptionConfigError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::update_field_level_encryption_config::UpdateFieldLevelEncryptionConfigError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::update_field_level_encryption_config::UpdateFieldLevelEncryptionConfigError> for Error {
    fn from(err: crate::operation::update_field_level_encryption_config::UpdateFieldLevelEncryptionConfigError) -> Self {
        match err {
            crate::operation::update_field_level_encryption_config::UpdateFieldLevelEncryptionConfigError::AccessDenied(inner) => Error::AccessDenied(inner),
            crate::operation::update_field_level_encryption_config::UpdateFieldLevelEncryptionConfigError::IllegalUpdate(inner) => Error::IllegalUpdate(inner),
            crate::operation::update_field_level_encryption_config::UpdateFieldLevelEncryptionConfigError::InconsistentQuantities(inner) => Error::InconsistentQuantities(inner),
            crate::operation::update_field_level_encryption_config::UpdateFieldLevelEncryptionConfigError::InvalidArgument(inner) => Error::InvalidArgument(inner),
            crate::operation::update_field_level_encryption_config::UpdateFieldLevelEncryptionConfigError::InvalidIfMatchVersion(inner) => Error::InvalidIfMatchVersion(inner),
            crate::operation::update_field_level_encryption_config::UpdateFieldLevelEncryptionConfigError::NoSuchFieldLevelEncryptionConfig(inner) => Error::NoSuchFieldLevelEncryptionConfig(inner),
            crate::operation::update_field_level_encryption_config::UpdateFieldLevelEncryptionConfigError::NoSuchFieldLevelEncryptionProfile(inner) => Error::NoSuchFieldLevelEncryptionProfile(inner),
            crate::operation::update_field_level_encryption_config::UpdateFieldLevelEncryptionConfigError::PreconditionFailed(inner) => Error::PreconditionFailed(inner),
            crate::operation::update_field_level_encryption_config::UpdateFieldLevelEncryptionConfigError::QueryArgProfileEmpty(inner) => Error::QueryArgProfileEmpty(inner),
            crate::operation::update_field_level_encryption_config::UpdateFieldLevelEncryptionConfigError::TooManyFieldLevelEncryptionContentTypeProfiles(inner) => Error::TooManyFieldLevelEncryptionContentTypeProfiles(inner),
            crate::operation::update_field_level_encryption_config::UpdateFieldLevelEncryptionConfigError::TooManyFieldLevelEncryptionQueryArgProfiles(inner) => Error::TooManyFieldLevelEncryptionQueryArgProfiles(inner),
            crate::operation::update_field_level_encryption_config::UpdateFieldLevelEncryptionConfigError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::update_field_level_encryption_profile::UpdateFieldLevelEncryptionProfileError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::update_field_level_encryption_profile::UpdateFieldLevelEncryptionProfileError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::update_field_level_encryption_profile::UpdateFieldLevelEncryptionProfileError> for Error {
    fn from(err: crate::operation::update_field_level_encryption_profile::UpdateFieldLevelEncryptionProfileError) -> Self {
        match err {
            crate::operation::update_field_level_encryption_profile::UpdateFieldLevelEncryptionProfileError::AccessDenied(inner) => Error::AccessDenied(inner),
            crate::operation::update_field_level_encryption_profile::UpdateFieldLevelEncryptionProfileError::FieldLevelEncryptionProfileAlreadyExists(inner) => Error::FieldLevelEncryptionProfileAlreadyExists(inner),
            crate::operation::update_field_level_encryption_profile::UpdateFieldLevelEncryptionProfileError::FieldLevelEncryptionProfileSizeExceeded(inner) => Error::FieldLevelEncryptionProfileSizeExceeded(inner),
            crate::operation::update_field_level_encryption_profile::UpdateFieldLevelEncryptionProfileError::IllegalUpdate(inner) => Error::IllegalUpdate(inner),
            crate::operation::update_field_level_encryption_profile::UpdateFieldLevelEncryptionProfileError::InconsistentQuantities(inner) => Error::InconsistentQuantities(inner),
            crate::operation::update_field_level_encryption_profile::UpdateFieldLevelEncryptionProfileError::InvalidArgument(inner) => Error::InvalidArgument(inner),
            crate::operation::update_field_level_encryption_profile::UpdateFieldLevelEncryptionProfileError::InvalidIfMatchVersion(inner) => Error::InvalidIfMatchVersion(inner),
            crate::operation::update_field_level_encryption_profile::UpdateFieldLevelEncryptionProfileError::NoSuchFieldLevelEncryptionProfile(inner) => Error::NoSuchFieldLevelEncryptionProfile(inner),
            crate::operation::update_field_level_encryption_profile::UpdateFieldLevelEncryptionProfileError::NoSuchPublicKey(inner) => Error::NoSuchPublicKey(inner),
            crate::operation::update_field_level_encryption_profile::UpdateFieldLevelEncryptionProfileError::PreconditionFailed(inner) => Error::PreconditionFailed(inner),
            crate::operation::update_field_level_encryption_profile::UpdateFieldLevelEncryptionProfileError::TooManyFieldLevelEncryptionEncryptionEntities(inner) => Error::TooManyFieldLevelEncryptionEncryptionEntities(inner),
            crate::operation::update_field_level_encryption_profile::UpdateFieldLevelEncryptionProfileError::TooManyFieldLevelEncryptionFieldPatterns(inner) => Error::TooManyFieldLevelEncryptionFieldPatterns(inner),
            crate::operation::update_field_level_encryption_profile::UpdateFieldLevelEncryptionProfileError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::update_function::UpdateFunctionError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::update_function::UpdateFunctionError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::update_function::UpdateFunctionError> for Error {
    fn from(err: crate::operation::update_function::UpdateFunctionError) -> Self {
        match err {
            crate::operation::update_function::UpdateFunctionError::FunctionSizeLimitExceeded(inner) => Error::FunctionSizeLimitExceeded(inner),
            crate::operation::update_function::UpdateFunctionError::InvalidArgument(inner) => Error::InvalidArgument(inner),
            crate::operation::update_function::UpdateFunctionError::InvalidIfMatchVersion(inner) => Error::InvalidIfMatchVersion(inner),
            crate::operation::update_function::UpdateFunctionError::NoSuchFunctionExists(inner) => Error::NoSuchFunctionExists(inner),
            crate::operation::update_function::UpdateFunctionError::PreconditionFailed(inner) => Error::PreconditionFailed(inner),
            crate::operation::update_function::UpdateFunctionError::UnsupportedOperation(inner) => Error::UnsupportedOperation(inner),
            crate::operation::update_function::UpdateFunctionError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::update_key_group::UpdateKeyGroupError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::update_key_group::UpdateKeyGroupError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::update_key_group::UpdateKeyGroupError> for Error {
    fn from(err: crate::operation::update_key_group::UpdateKeyGroupError) -> Self {
        match err {
            crate::operation::update_key_group::UpdateKeyGroupError::InvalidArgument(inner) => Error::InvalidArgument(inner),
            crate::operation::update_key_group::UpdateKeyGroupError::InvalidIfMatchVersion(inner) => Error::InvalidIfMatchVersion(inner),
            crate::operation::update_key_group::UpdateKeyGroupError::KeyGroupAlreadyExists(inner) => Error::KeyGroupAlreadyExists(inner),
            crate::operation::update_key_group::UpdateKeyGroupError::NoSuchResource(inner) => Error::NoSuchResource(inner),
            crate::operation::update_key_group::UpdateKeyGroupError::PreconditionFailed(inner) => Error::PreconditionFailed(inner),
            crate::operation::update_key_group::UpdateKeyGroupError::TooManyPublicKeysInKeyGroup(inner) => Error::TooManyPublicKeysInKeyGroup(inner),
            crate::operation::update_key_group::UpdateKeyGroupError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::update_origin_access_control::UpdateOriginAccessControlError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::update_origin_access_control::UpdateOriginAccessControlError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::update_origin_access_control::UpdateOriginAccessControlError> for Error {
    fn from(err: crate::operation::update_origin_access_control::UpdateOriginAccessControlError) -> Self {
        match err {
            crate::operation::update_origin_access_control::UpdateOriginAccessControlError::AccessDenied(inner) => Error::AccessDenied(inner),
            crate::operation::update_origin_access_control::UpdateOriginAccessControlError::IllegalUpdate(inner) => Error::IllegalUpdate(inner),
            crate::operation::update_origin_access_control::UpdateOriginAccessControlError::InvalidArgument(inner) => Error::InvalidArgument(inner),
            crate::operation::update_origin_access_control::UpdateOriginAccessControlError::InvalidIfMatchVersion(inner) => Error::InvalidIfMatchVersion(inner),
            crate::operation::update_origin_access_control::UpdateOriginAccessControlError::NoSuchOriginAccessControl(inner) => Error::NoSuchOriginAccessControl(inner),
            crate::operation::update_origin_access_control::UpdateOriginAccessControlError::OriginAccessControlAlreadyExists(inner) => Error::OriginAccessControlAlreadyExists(inner),
            crate::operation::update_origin_access_control::UpdateOriginAccessControlError::PreconditionFailed(inner) => Error::PreconditionFailed(inner),
            crate::operation::update_origin_access_control::UpdateOriginAccessControlError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::update_origin_request_policy::UpdateOriginRequestPolicyError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::update_origin_request_policy::UpdateOriginRequestPolicyError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::update_origin_request_policy::UpdateOriginRequestPolicyError> for Error {
    fn from(err: crate::operation::update_origin_request_policy::UpdateOriginRequestPolicyError) -> Self {
        match err {
            crate::operation::update_origin_request_policy::UpdateOriginRequestPolicyError::AccessDenied(inner) => Error::AccessDenied(inner),
            crate::operation::update_origin_request_policy::UpdateOriginRequestPolicyError::IllegalUpdate(inner) => Error::IllegalUpdate(inner),
            crate::operation::update_origin_request_policy::UpdateOriginRequestPolicyError::InconsistentQuantities(inner) => Error::InconsistentQuantities(inner),
            crate::operation::update_origin_request_policy::UpdateOriginRequestPolicyError::InvalidArgument(inner) => Error::InvalidArgument(inner),
            crate::operation::update_origin_request_policy::UpdateOriginRequestPolicyError::InvalidIfMatchVersion(inner) => Error::InvalidIfMatchVersion(inner),
            crate::operation::update_origin_request_policy::UpdateOriginRequestPolicyError::NoSuchOriginRequestPolicy(inner) => Error::NoSuchOriginRequestPolicy(inner),
            crate::operation::update_origin_request_policy::UpdateOriginRequestPolicyError::OriginRequestPolicyAlreadyExists(inner) => Error::OriginRequestPolicyAlreadyExists(inner),
            crate::operation::update_origin_request_policy::UpdateOriginRequestPolicyError::PreconditionFailed(inner) => Error::PreconditionFailed(inner),
            crate::operation::update_origin_request_policy::UpdateOriginRequestPolicyError::TooManyCookiesInOriginRequestPolicy(inner) => Error::TooManyCookiesInOriginRequestPolicy(inner),
            crate::operation::update_origin_request_policy::UpdateOriginRequestPolicyError::TooManyHeadersInOriginRequestPolicy(inner) => Error::TooManyHeadersInOriginRequestPolicy(inner),
            crate::operation::update_origin_request_policy::UpdateOriginRequestPolicyError::TooManyQueryStringsInOriginRequestPolicy(inner) => Error::TooManyQueryStringsInOriginRequestPolicy(inner),
            crate::operation::update_origin_request_policy::UpdateOriginRequestPolicyError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::update_public_key::UpdatePublicKeyError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::update_public_key::UpdatePublicKeyError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::update_public_key::UpdatePublicKeyError> for Error {
    fn from(err: crate::operation::update_public_key::UpdatePublicKeyError) -> Self {
        match err {
            crate::operation::update_public_key::UpdatePublicKeyError::AccessDenied(inner) => Error::AccessDenied(inner),
            crate::operation::update_public_key::UpdatePublicKeyError::CannotChangeImmutablePublicKeyFields(inner) => Error::CannotChangeImmutablePublicKeyFields(inner),
            crate::operation::update_public_key::UpdatePublicKeyError::IllegalUpdate(inner) => Error::IllegalUpdate(inner),
            crate::operation::update_public_key::UpdatePublicKeyError::InvalidArgument(inner) => Error::InvalidArgument(inner),
            crate::operation::update_public_key::UpdatePublicKeyError::InvalidIfMatchVersion(inner) => Error::InvalidIfMatchVersion(inner),
            crate::operation::update_public_key::UpdatePublicKeyError::NoSuchPublicKey(inner) => Error::NoSuchPublicKey(inner),
            crate::operation::update_public_key::UpdatePublicKeyError::PreconditionFailed(inner) => Error::PreconditionFailed(inner),
            crate::operation::update_public_key::UpdatePublicKeyError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::update_realtime_log_config::UpdateRealtimeLogConfigError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::update_realtime_log_config::UpdateRealtimeLogConfigError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::update_realtime_log_config::UpdateRealtimeLogConfigError> for Error {
    fn from(err: crate::operation::update_realtime_log_config::UpdateRealtimeLogConfigError) -> Self {
        match err {
            crate::operation::update_realtime_log_config::UpdateRealtimeLogConfigError::AccessDenied(inner) => Error::AccessDenied(inner),
            crate::operation::update_realtime_log_config::UpdateRealtimeLogConfigError::InvalidArgument(inner) => Error::InvalidArgument(inner),
            crate::operation::update_realtime_log_config::UpdateRealtimeLogConfigError::NoSuchRealtimeLogConfig(inner) => Error::NoSuchRealtimeLogConfig(inner),
            crate::operation::update_realtime_log_config::UpdateRealtimeLogConfigError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::update_response_headers_policy::UpdateResponseHeadersPolicyError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::update_response_headers_policy::UpdateResponseHeadersPolicyError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::update_response_headers_policy::UpdateResponseHeadersPolicyError> for Error {
    fn from(err: crate::operation::update_response_headers_policy::UpdateResponseHeadersPolicyError) -> Self {
        match err {
            crate::operation::update_response_headers_policy::UpdateResponseHeadersPolicyError::AccessDenied(inner) => Error::AccessDenied(inner),
            crate::operation::update_response_headers_policy::UpdateResponseHeadersPolicyError::IllegalUpdate(inner) => Error::IllegalUpdate(inner),
            crate::operation::update_response_headers_policy::UpdateResponseHeadersPolicyError::InconsistentQuantities(inner) => Error::InconsistentQuantities(inner),
            crate::operation::update_response_headers_policy::UpdateResponseHeadersPolicyError::InvalidArgument(inner) => Error::InvalidArgument(inner),
            crate::operation::update_response_headers_policy::UpdateResponseHeadersPolicyError::InvalidIfMatchVersion(inner) => Error::InvalidIfMatchVersion(inner),
            crate::operation::update_response_headers_policy::UpdateResponseHeadersPolicyError::NoSuchResponseHeadersPolicy(inner) => Error::NoSuchResponseHeadersPolicy(inner),
            crate::operation::update_response_headers_policy::UpdateResponseHeadersPolicyError::PreconditionFailed(inner) => Error::PreconditionFailed(inner),
            crate::operation::update_response_headers_policy::UpdateResponseHeadersPolicyError::ResponseHeadersPolicyAlreadyExists(inner) => Error::ResponseHeadersPolicyAlreadyExists(inner),
            crate::operation::update_response_headers_policy::UpdateResponseHeadersPolicyError::TooLongCspInResponseHeadersPolicy(inner) => Error::TooLongCspInResponseHeadersPolicy(inner),
            crate::operation::update_response_headers_policy::UpdateResponseHeadersPolicyError::TooManyCustomHeadersInResponseHeadersPolicy(inner) => Error::TooManyCustomHeadersInResponseHeadersPolicy(inner),
            crate::operation::update_response_headers_policy::UpdateResponseHeadersPolicyError::TooManyRemoveHeadersInResponseHeadersPolicy(inner) => Error::TooManyRemoveHeadersInResponseHeadersPolicy(inner),
            crate::operation::update_response_headers_policy::UpdateResponseHeadersPolicyError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::update_streaming_distribution::UpdateStreamingDistributionError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::update_streaming_distribution::UpdateStreamingDistributionError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::update_streaming_distribution::UpdateStreamingDistributionError> for Error {
    fn from(err: crate::operation::update_streaming_distribution::UpdateStreamingDistributionError) -> Self {
        match err {
            crate::operation::update_streaming_distribution::UpdateStreamingDistributionError::AccessDenied(inner) => Error::AccessDenied(inner),
            crate::operation::update_streaming_distribution::UpdateStreamingDistributionError::CnameAlreadyExists(inner) => Error::CnameAlreadyExists(inner),
            crate::operation::update_streaming_distribution::UpdateStreamingDistributionError::IllegalUpdate(inner) => Error::IllegalUpdate(inner),
            crate::operation::update_streaming_distribution::UpdateStreamingDistributionError::InconsistentQuantities(inner) => Error::InconsistentQuantities(inner),
            crate::operation::update_streaming_distribution::UpdateStreamingDistributionError::InvalidArgument(inner) => Error::InvalidArgument(inner),
            crate::operation::update_streaming_distribution::UpdateStreamingDistributionError::InvalidIfMatchVersion(inner) => Error::InvalidIfMatchVersion(inner),
            crate::operation::update_streaming_distribution::UpdateStreamingDistributionError::InvalidOriginAccessControl(inner) => Error::InvalidOriginAccessControl(inner),
            crate::operation::update_streaming_distribution::UpdateStreamingDistributionError::InvalidOriginAccessIdentity(inner) => Error::InvalidOriginAccessIdentity(inner),
            crate::operation::update_streaming_distribution::UpdateStreamingDistributionError::MissingBody(inner) => Error::MissingBody(inner),
            crate::operation::update_streaming_distribution::UpdateStreamingDistributionError::NoSuchStreamingDistribution(inner) => Error::NoSuchStreamingDistribution(inner),
            crate::operation::update_streaming_distribution::UpdateStreamingDistributionError::PreconditionFailed(inner) => Error::PreconditionFailed(inner),
            crate::operation::update_streaming_distribution::UpdateStreamingDistributionError::TooManyStreamingDistributionCnamEs(inner) => Error::TooManyStreamingDistributionCnamEs(inner),
            crate::operation::update_streaming_distribution::UpdateStreamingDistributionError::TooManyTrustedSigners(inner) => Error::TooManyTrustedSigners(inner),
            crate::operation::update_streaming_distribution::UpdateStreamingDistributionError::TrustedSignerDoesNotExist(inner) => Error::TrustedSignerDoesNotExist(inner),
            crate::operation::update_streaming_distribution::UpdateStreamingDistributionError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl std::error::Error for Error {}
impl aws_http::request_id::RequestId for Error {
    fn request_id(&self) -> Option<&str> {
        match self {
            Self::AccessDenied(e) => e.request_id(),
            Self::BatchTooLarge(e) => e.request_id(),
            Self::CnameAlreadyExists(e) => e.request_id(),
            Self::CachePolicyAlreadyExists(e) => e.request_id(),
            Self::CachePolicyInUse(e) => e.request_id(),
            Self::CannotChangeImmutablePublicKeyFields(e) => e.request_id(),
            Self::CloudFrontOriginAccessIdentityAlreadyExists(e) => e.request_id(),
            Self::CloudFrontOriginAccessIdentityInUse(e) => e.request_id(),
            Self::ContinuousDeploymentPolicyAlreadyExists(e) => e.request_id(),
            Self::ContinuousDeploymentPolicyInUse(e) => e.request_id(),
            Self::DistributionAlreadyExists(e) => e.request_id(),
            Self::DistributionNotDisabled(e) => e.request_id(),
            Self::FieldLevelEncryptionConfigAlreadyExists(e) => e.request_id(),
            Self::FieldLevelEncryptionConfigInUse(e) => e.request_id(),
            Self::FieldLevelEncryptionProfileAlreadyExists(e) => e.request_id(),
            Self::FieldLevelEncryptionProfileInUse(e) => e.request_id(),
            Self::FieldLevelEncryptionProfileSizeExceeded(e) => e.request_id(),
            Self::FunctionAlreadyExists(e) => e.request_id(),
            Self::FunctionInUse(e) => e.request_id(),
            Self::FunctionSizeLimitExceeded(e) => e.request_id(),
            Self::IllegalDelete(e) => e.request_id(),
            Self::IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior(e) => e.request_id(),
            Self::IllegalOriginAccessConfiguration(e) => e.request_id(),
            Self::IllegalUpdate(e) => e.request_id(),
            Self::InconsistentQuantities(e) => e.request_id(),
            Self::InvalidArgument(e) => e.request_id(),
            Self::InvalidDefaultRootObject(e) => e.request_id(),
            Self::InvalidDomainNameForOriginAccessControl(e) => e.request_id(),
            Self::InvalidErrorCode(e) => e.request_id(),
            Self::InvalidForwardCookies(e) => e.request_id(),
            Self::InvalidFunctionAssociation(e) => e.request_id(),
            Self::InvalidGeoRestrictionParameter(e) => e.request_id(),
            Self::InvalidHeadersForS3Origin(e) => e.request_id(),
            Self::InvalidIfMatchVersion(e) => e.request_id(),
            Self::InvalidLambdaFunctionAssociation(e) => e.request_id(),
            Self::InvalidLocationCode(e) => e.request_id(),
            Self::InvalidMinimumProtocolVersion(e) => e.request_id(),
            Self::InvalidOrigin(e) => e.request_id(),
            Self::InvalidOriginAccessControl(e) => e.request_id(),
            Self::InvalidOriginAccessIdentity(e) => e.request_id(),
            Self::InvalidOriginKeepaliveTimeout(e) => e.request_id(),
            Self::InvalidOriginReadTimeout(e) => e.request_id(),
            Self::InvalidProtocolSettings(e) => e.request_id(),
            Self::InvalidQueryStringParameters(e) => e.request_id(),
            Self::InvalidRelativePath(e) => e.request_id(),
            Self::InvalidRequiredProtocol(e) => e.request_id(),
            Self::InvalidResponseCode(e) => e.request_id(),
            Self::InvalidTtlOrder(e) => e.request_id(),
            Self::InvalidTagging(e) => e.request_id(),
            Self::InvalidViewerCertificate(e) => e.request_id(),
            Self::InvalidWebAclId(e) => e.request_id(),
            Self::KeyGroupAlreadyExists(e) => e.request_id(),
            Self::MissingBody(e) => e.request_id(),
            Self::MonitoringSubscriptionAlreadyExists(e) => e.request_id(),
            Self::NoSuchCachePolicy(e) => e.request_id(),
            Self::NoSuchCloudFrontOriginAccessIdentity(e) => e.request_id(),
            Self::NoSuchContinuousDeploymentPolicy(e) => e.request_id(),
            Self::NoSuchDistribution(e) => e.request_id(),
            Self::NoSuchFieldLevelEncryptionConfig(e) => e.request_id(),
            Self::NoSuchFieldLevelEncryptionProfile(e) => e.request_id(),
            Self::NoSuchFunctionExists(e) => e.request_id(),
            Self::NoSuchInvalidation(e) => e.request_id(),
            Self::NoSuchMonitoringSubscription(e) => e.request_id(),
            Self::NoSuchOrigin(e) => e.request_id(),
            Self::NoSuchOriginAccessControl(e) => e.request_id(),
            Self::NoSuchOriginRequestPolicy(e) => e.request_id(),
            Self::NoSuchPublicKey(e) => e.request_id(),
            Self::NoSuchRealtimeLogConfig(e) => e.request_id(),
            Self::NoSuchResource(e) => e.request_id(),
            Self::NoSuchResponseHeadersPolicy(e) => e.request_id(),
            Self::NoSuchStreamingDistribution(e) => e.request_id(),
            Self::OriginAccessControlAlreadyExists(e) => e.request_id(),
            Self::OriginAccessControlInUse(e) => e.request_id(),
            Self::OriginRequestPolicyAlreadyExists(e) => e.request_id(),
            Self::OriginRequestPolicyInUse(e) => e.request_id(),
            Self::PreconditionFailed(e) => e.request_id(),
            Self::PublicKeyAlreadyExists(e) => e.request_id(),
            Self::PublicKeyInUse(e) => e.request_id(),
            Self::QueryArgProfileEmpty(e) => e.request_id(),
            Self::RealtimeLogConfigAlreadyExists(e) => e.request_id(),
            Self::RealtimeLogConfigInUse(e) => e.request_id(),
            Self::RealtimeLogConfigOwnerMismatch(e) => e.request_id(),
            Self::ResourceInUse(e) => e.request_id(),
            Self::ResponseHeadersPolicyAlreadyExists(e) => e.request_id(),
            Self::ResponseHeadersPolicyInUse(e) => e.request_id(),
            Self::StagingDistributionInUse(e) => e.request_id(),
            Self::StreamingDistributionAlreadyExists(e) => e.request_id(),
            Self::StreamingDistributionNotDisabled(e) => e.request_id(),
            Self::TestFunctionFailed(e) => e.request_id(),
            Self::TooLongCspInResponseHeadersPolicy(e) => e.request_id(),
            Self::TooManyCacheBehaviors(e) => e.request_id(),
            Self::TooManyCachePolicies(e) => e.request_id(),
            Self::TooManyCertificates(e) => e.request_id(),
            Self::TooManyCloudFrontOriginAccessIdentities(e) => e.request_id(),
            Self::TooManyContinuousDeploymentPolicies(e) => e.request_id(),
            Self::TooManyCookieNamesInWhiteList(e) => e.request_id(),
            Self::TooManyCookiesInCachePolicy(e) => e.request_id(),
            Self::TooManyCookiesInOriginRequestPolicy(e) => e.request_id(),
            Self::TooManyCustomHeadersInResponseHeadersPolicy(e) => e.request_id(),
            Self::TooManyDistributionCnamEs(e) => e.request_id(),
            Self::TooManyDistributions(e) => e.request_id(),
            Self::TooManyDistributionsAssociatedToCachePolicy(e) => e.request_id(),
            Self::TooManyDistributionsAssociatedToFieldLevelEncryptionConfig(e) => e.request_id(),
            Self::TooManyDistributionsAssociatedToKeyGroup(e) => e.request_id(),
            Self::TooManyDistributionsAssociatedToOriginAccessControl(e) => e.request_id(),
            Self::TooManyDistributionsAssociatedToOriginRequestPolicy(e) => e.request_id(),
            Self::TooManyDistributionsAssociatedToResponseHeadersPolicy(e) => e.request_id(),
            Self::TooManyDistributionsWithFunctionAssociations(e) => e.request_id(),
            Self::TooManyDistributionsWithLambdaAssociations(e) => e.request_id(),
            Self::TooManyDistributionsWithSingleFunctionArn(e) => e.request_id(),
            Self::TooManyFieldLevelEncryptionConfigs(e) => e.request_id(),
            Self::TooManyFieldLevelEncryptionContentTypeProfiles(e) => e.request_id(),
            Self::TooManyFieldLevelEncryptionEncryptionEntities(e) => e.request_id(),
            Self::TooManyFieldLevelEncryptionFieldPatterns(e) => e.request_id(),
            Self::TooManyFieldLevelEncryptionProfiles(e) => e.request_id(),
            Self::TooManyFieldLevelEncryptionQueryArgProfiles(e) => e.request_id(),
            Self::TooManyFunctionAssociations(e) => e.request_id(),
            Self::TooManyFunctions(e) => e.request_id(),
            Self::TooManyHeadersInCachePolicy(e) => e.request_id(),
            Self::TooManyHeadersInForwardedValues(e) => e.request_id(),
            Self::TooManyHeadersInOriginRequestPolicy(e) => e.request_id(),
            Self::TooManyInvalidationsInProgress(e) => e.request_id(),
            Self::TooManyKeyGroups(e) => e.request_id(),
            Self::TooManyKeyGroupsAssociatedToDistribution(e) => e.request_id(),
            Self::TooManyLambdaFunctionAssociations(e) => e.request_id(),
            Self::TooManyOriginAccessControls(e) => e.request_id(),
            Self::TooManyOriginCustomHeaders(e) => e.request_id(),
            Self::TooManyOriginGroupsPerDistribution(e) => e.request_id(),
            Self::TooManyOriginRequestPolicies(e) => e.request_id(),
            Self::TooManyOrigins(e) => e.request_id(),
            Self::TooManyPublicKeys(e) => e.request_id(),
            Self::TooManyPublicKeysInKeyGroup(e) => e.request_id(),
            Self::TooManyQueryStringParameters(e) => e.request_id(),
            Self::TooManyQueryStringsInCachePolicy(e) => e.request_id(),
            Self::TooManyQueryStringsInOriginRequestPolicy(e) => e.request_id(),
            Self::TooManyRealtimeLogConfigs(e) => e.request_id(),
            Self::TooManyRemoveHeadersInResponseHeadersPolicy(e) => e.request_id(),
            Self::TooManyResponseHeadersPolicies(e) => e.request_id(),
            Self::TooManyStreamingDistributionCnamEs(e) => e.request_id(),
            Self::TooManyStreamingDistributions(e) => e.request_id(),
            Self::TooManyTrustedSigners(e) => e.request_id(),
            Self::TrustedKeyGroupDoesNotExist(e) => e.request_id(),
            Self::TrustedSignerDoesNotExist(e) => e.request_id(),
            Self::UnsupportedOperation(e) => e.request_id(),
            Self::Unhandled(e) => e.request_id(),
        }
    }
}

