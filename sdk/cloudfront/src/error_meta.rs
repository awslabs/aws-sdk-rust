// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// All possible error types for this service.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum Error {
    /// <p>Access denied.</p>
    AccessDenied(crate::error::AccessDenied),
    /// <p>Invalidation batch specified is too large.</p>
    BatchTooLarge(crate::error::BatchTooLarge),
    /// <p>The CNAME specified is already defined for CloudFront.</p>
    CnameAlreadyExists(crate::error::CnameAlreadyExists),
    /// <p>A cache policy with this name already exists. You must provide a unique name. To modify an existing cache policy, use <code>UpdateCachePolicy</code>.</p>
    CachePolicyAlreadyExists(crate::error::CachePolicyAlreadyExists),
    /// <p>Cannot delete the cache policy because it is attached to one or more cache behaviors.</p>
    CachePolicyInUse(crate::error::CachePolicyInUse),
    /// <p>You can't change the value of a public key.</p>
    CannotChangeImmutablePublicKeyFields(crate::error::CannotChangeImmutablePublicKeyFields),
    /// <p>If the <code>CallerReference</code> is a value you already sent in a previous request to create an identity but the content of the <code>CloudFrontOriginAccessIdentityConfig</code> is different from the original request, CloudFront returns a <code>CloudFrontOriginAccessIdentityAlreadyExists</code> error. </p>
    CloudFrontOriginAccessIdentityAlreadyExists(
        crate::error::CloudFrontOriginAccessIdentityAlreadyExists,
    ),
    /// <p>The Origin Access Identity specified is already in use.</p>
    CloudFrontOriginAccessIdentityInUse(crate::error::CloudFrontOriginAccessIdentityInUse),
    /// <p>A continuous deployment policy with this configuration already exists.</p>
    ContinuousDeploymentPolicyAlreadyExists(crate::error::ContinuousDeploymentPolicyAlreadyExists),
    /// <p>You cannot delete a continuous deployment policy that is associated with a primary distribution.</p>
    ContinuousDeploymentPolicyInUse(crate::error::ContinuousDeploymentPolicyInUse),
    /// <p>The caller reference you attempted to create the distribution with is associated with another distribution.</p>
    DistributionAlreadyExists(crate::error::DistributionAlreadyExists),
    /// <p>The specified CloudFront distribution is not disabled. You must disable the distribution before you can delete it.</p>
    DistributionNotDisabled(crate::error::DistributionNotDisabled),
    /// <p>The specified configuration for field-level encryption already exists.</p>
    FieldLevelEncryptionConfigAlreadyExists(crate::error::FieldLevelEncryptionConfigAlreadyExists),
    /// <p>The specified configuration for field-level encryption is in use.</p>
    FieldLevelEncryptionConfigInUse(crate::error::FieldLevelEncryptionConfigInUse),
    /// <p>The specified profile for field-level encryption already exists.</p>
    FieldLevelEncryptionProfileAlreadyExists(
        crate::error::FieldLevelEncryptionProfileAlreadyExists,
    ),
    /// <p>The specified profile for field-level encryption is in use.</p>
    FieldLevelEncryptionProfileInUse(crate::error::FieldLevelEncryptionProfileInUse),
    /// <p>The maximum size of a profile for field-level encryption was exceeded.</p>
    FieldLevelEncryptionProfileSizeExceeded(crate::error::FieldLevelEncryptionProfileSizeExceeded),
    /// <p>A function with the same name already exists in this Amazon Web Services account. To create a function, you must provide a unique name. To update an existing function, use <code>UpdateFunction</code>.</p>
    FunctionAlreadyExists(crate::error::FunctionAlreadyExists),
    /// <p>Cannot delete the function because it's attached to one or more cache behaviors.</p>
    FunctionInUse(crate::error::FunctionInUse),
    /// <p>The function is too large. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
    FunctionSizeLimitExceeded(crate::error::FunctionSizeLimitExceeded),
    /// <p>You cannot delete a managed policy.</p>
    IllegalDelete(crate::error::IllegalDelete),
    /// <p>The specified configuration for field-level encryption can't be associated with the specified cache behavior.</p>
    IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior(
        crate::error::IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior,
    ),
    /// <p>An origin cannot contain both an origin access control (OAC) and an origin access identity (OAI).</p>
    IllegalOriginAccessConfiguration(crate::error::IllegalOriginAccessConfiguration),
    /// <p>The update contains modifications that are not allowed.</p>
    IllegalUpdate(crate::error::IllegalUpdate),
    /// <p>The value of <code>Quantity</code> and the size of <code>Items</code> don't match.</p>
    InconsistentQuantities(crate::error::InconsistentQuantities),
    /// <p>An argument is invalid.</p>
    InvalidArgument(crate::error::InvalidArgument),
    /// <p>The default root object file name is too big or contains an invalid character.</p>
    InvalidDefaultRootObject(crate::error::InvalidDefaultRootObject),
    /// <p>An origin access control is associated with an origin whose domain name is not supported.</p>
    InvalidDomainNameForOriginAccessControl(crate::error::InvalidDomainNameForOriginAccessControl),
    /// <p>An invalid error code was specified.</p>
    InvalidErrorCode(crate::error::InvalidErrorCode),
    /// <p>Your request contains forward cookies option which doesn't match with the expectation for the <code>whitelisted</code> list of cookie names. Either list of cookie names has been specified when not allowed or list of cookie names is missing when expected.</p>
    InvalidForwardCookies(crate::error::InvalidForwardCookies),
    /// <p>A CloudFront function association is invalid.</p>
    InvalidFunctionAssociation(crate::error::InvalidFunctionAssociation),
    /// <p>The specified geo restriction parameter is not valid.</p>
    InvalidGeoRestrictionParameter(crate::error::InvalidGeoRestrictionParameter),
    /// <p>The headers specified are not valid for an Amazon S3 origin.</p>
    InvalidHeadersForS3Origin(crate::error::InvalidHeadersForS3Origin),
    /// <p>The <code>If-Match</code> version is missing or not valid.</p>
    InvalidIfMatchVersion(crate::error::InvalidIfMatchVersion),
    /// <p>The specified Lambda@Edge function association is invalid.</p>
    InvalidLambdaFunctionAssociation(crate::error::InvalidLambdaFunctionAssociation),
    /// <p>The location code specified is not valid.</p>
    InvalidLocationCode(crate::error::InvalidLocationCode),
    /// <p>The minimum protocol version specified is not valid.</p>
    InvalidMinimumProtocolVersion(crate::error::InvalidMinimumProtocolVersion),
    /// <p>The Amazon S3 origin server specified does not refer to a valid Amazon S3 bucket.</p>
    InvalidOrigin(crate::error::InvalidOrigin),
    /// <p>The origin access control is not valid.</p>
    InvalidOriginAccessControl(crate::error::InvalidOriginAccessControl),
    /// <p>The origin access identity is not valid or doesn't exist.</p>
    InvalidOriginAccessIdentity(crate::error::InvalidOriginAccessIdentity),
    /// <p>The keep alive timeout specified for the origin is not valid.</p>
    InvalidOriginKeepaliveTimeout(crate::error::InvalidOriginKeepaliveTimeout),
    /// <p>The read timeout specified for the origin is not valid.</p>
    InvalidOriginReadTimeout(crate::error::InvalidOriginReadTimeout),
    /// <p>You cannot specify SSLv3 as the minimum protocol version if you only want to support only clients that support Server Name Indication (SNI).</p>
    InvalidProtocolSettings(crate::error::InvalidProtocolSettings),
    /// <p>The query string parameters specified are not valid.</p>
    InvalidQueryStringParameters(crate::error::InvalidQueryStringParameters),
    /// <p>The relative path is too big, is not URL-encoded, or does not begin with a slash (/).</p>
    InvalidRelativePath(crate::error::InvalidRelativePath),
    /// <p>This operation requires the HTTPS protocol. Ensure that you specify the HTTPS protocol in your request, or omit the <code>RequiredProtocols</code> element from your distribution configuration.</p>
    InvalidRequiredProtocol(crate::error::InvalidRequiredProtocol),
    /// <p>A response code is not valid.</p>
    InvalidResponseCode(crate::error::InvalidResponseCode),
    /// <p>The TTL order specified is not valid.</p>
    InvalidTtlOrder(crate::error::InvalidTtlOrder),
    /// <p>The tagging specified is not valid.</p>
    InvalidTagging(crate::error::InvalidTagging),
    /// <p>A viewer certificate specified is not valid.</p>
    InvalidViewerCertificate(crate::error::InvalidViewerCertificate),
    /// <p>A web ACL ID specified is not valid. To specify a web ACL created using the latest version of WAF, use the ACL ARN, for example <code>arn:aws:wafv2:us-east-1:123456789012:global/webacl/ExampleWebACL/473e64fd-f30b-4765-81a0-62ad96dd167a</code>. To specify a web ACL created using WAF Classic, use the ACL ID, for example <code>473e64fd-f30b-4765-81a0-62ad96dd167a</code>.</p>
    InvalidWebAclId(crate::error::InvalidWebAclId),
    /// <p>A key group with this name already exists. You must provide a unique name. To modify an existing key group, use <code>UpdateKeyGroup</code>.</p>
    KeyGroupAlreadyExists(crate::error::KeyGroupAlreadyExists),
    /// <p>This operation requires a body. Ensure that the body is present and the <code>Content-Type</code> header is set.</p>
    MissingBody(crate::error::MissingBody),
    /// <p>A monitoring subscription already exists for the specified distribution.</p>
    MonitoringSubscriptionAlreadyExists(crate::error::MonitoringSubscriptionAlreadyExists),
    /// <p>The cache policy does not exist.</p>
    NoSuchCachePolicy(crate::error::NoSuchCachePolicy),
    /// <p>The specified origin access identity does not exist.</p>
    NoSuchCloudFrontOriginAccessIdentity(crate::error::NoSuchCloudFrontOriginAccessIdentity),
    /// <p>The continuous deployment policy doesn't exist.</p>
    NoSuchContinuousDeploymentPolicy(crate::error::NoSuchContinuousDeploymentPolicy),
    /// <p>The specified distribution does not exist.</p>
    NoSuchDistribution(crate::error::NoSuchDistribution),
    /// <p>The specified configuration for field-level encryption doesn't exist.</p>
    NoSuchFieldLevelEncryptionConfig(crate::error::NoSuchFieldLevelEncryptionConfig),
    /// <p>The specified profile for field-level encryption doesn't exist.</p>
    NoSuchFieldLevelEncryptionProfile(crate::error::NoSuchFieldLevelEncryptionProfile),
    /// <p>The function does not exist.</p>
    NoSuchFunctionExists(crate::error::NoSuchFunctionExists),
    /// <p>The specified invalidation does not exist.</p>
    NoSuchInvalidation(crate::error::NoSuchInvalidation),
    /// <p>A monitoring subscription does not exist for the specified distribution.</p>
    NoSuchMonitoringSubscription(crate::error::NoSuchMonitoringSubscription),
    /// <p>No origin exists with the specified <code>Origin Id</code>.</p>
    NoSuchOrigin(crate::error::NoSuchOrigin),
    /// <p>The origin access control does not exist.</p>
    NoSuchOriginAccessControl(crate::error::NoSuchOriginAccessControl),
    /// <p>The origin request policy does not exist.</p>
    NoSuchOriginRequestPolicy(crate::error::NoSuchOriginRequestPolicy),
    /// <p>The specified public key doesn't exist.</p>
    NoSuchPublicKey(crate::error::NoSuchPublicKey),
    /// <p>The real-time log configuration does not exist.</p>
    NoSuchRealtimeLogConfig(crate::error::NoSuchRealtimeLogConfig),
    /// <p>A resource that was specified is not valid.</p>
    NoSuchResource(crate::error::NoSuchResource),
    /// <p>The response headers policy does not exist.</p>
    NoSuchResponseHeadersPolicy(crate::error::NoSuchResponseHeadersPolicy),
    /// <p>The specified streaming distribution does not exist.</p>
    NoSuchStreamingDistribution(crate::error::NoSuchStreamingDistribution),
    /// <p>An origin access control with the specified parameters already exists.</p>
    OriginAccessControlAlreadyExists(crate::error::OriginAccessControlAlreadyExists),
    /// <p>Cannot delete the origin access control because it's in use by one or more distributions.</p>
    OriginAccessControlInUse(crate::error::OriginAccessControlInUse),
    /// <p>An origin request policy with this name already exists. You must provide a unique name. To modify an existing origin request policy, use <code>UpdateOriginRequestPolicy</code>.</p>
    OriginRequestPolicyAlreadyExists(crate::error::OriginRequestPolicyAlreadyExists),
    /// <p>Cannot delete the origin request policy because it is attached to one or more cache behaviors.</p>
    OriginRequestPolicyInUse(crate::error::OriginRequestPolicyInUse),
    /// <p>The precondition in one or more of the request fields evaluated to <code>false</code>.</p>
    PreconditionFailed(crate::error::PreconditionFailed),
    /// <p>The specified public key already exists.</p>
    PublicKeyAlreadyExists(crate::error::PublicKeyAlreadyExists),
    /// <p>The specified public key is in use.</p>
    PublicKeyInUse(crate::error::PublicKeyInUse),
    /// <p>No profile specified for the field-level encryption query argument.</p>
    QueryArgProfileEmpty(crate::error::QueryArgProfileEmpty),
    /// <p>A real-time log configuration with this name already exists. You must provide a unique name. To modify an existing real-time log configuration, use <code>UpdateRealtimeLogConfig</code>.</p>
    RealtimeLogConfigAlreadyExists(crate::error::RealtimeLogConfigAlreadyExists),
    /// <p>Cannot delete the real-time log configuration because it is attached to one or more cache behaviors.</p>
    RealtimeLogConfigInUse(crate::error::RealtimeLogConfigInUse),
    /// <p>The specified real-time log configuration belongs to a different Amazon Web Services account.</p>
    RealtimeLogConfigOwnerMismatch(crate::error::RealtimeLogConfigOwnerMismatch),
    /// <p>Cannot delete this resource because it is in use.</p>
    ResourceInUse(crate::error::ResourceInUse),
    /// <p>A response headers policy with this name already exists. You must provide a unique name. To modify an existing response headers policy, use <code>UpdateResponseHeadersPolicy</code>.</p>
    ResponseHeadersPolicyAlreadyExists(crate::error::ResponseHeadersPolicyAlreadyExists),
    /// <p>Cannot delete the response headers policy because it is attached to one or more cache behaviors in a CloudFront distribution.</p>
    ResponseHeadersPolicyInUse(crate::error::ResponseHeadersPolicyInUse),
    /// <p>A continuous deployment policy for this staging distribution already exists.</p>
    StagingDistributionInUse(crate::error::StagingDistributionInUse),
    /// <p>The caller reference you attempted to create the streaming distribution with is associated with another distribution</p>
    StreamingDistributionAlreadyExists(crate::error::StreamingDistributionAlreadyExists),
    /// <p>The specified CloudFront distribution is not disabled. You must disable the distribution before you can delete it.</p>
    StreamingDistributionNotDisabled(crate::error::StreamingDistributionNotDisabled),
    /// <p>The CloudFront function failed.</p>
    TestFunctionFailed(crate::error::TestFunctionFailed),
    /// <p>The length of the <code>Content-Security-Policy</code> header value in the response headers policy exceeds the maximum.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
    TooLongCspInResponseHeadersPolicy(crate::error::TooLongCspInResponseHeadersPolicy),
    /// <p>You cannot create more cache behaviors for the distribution.</p>
    TooManyCacheBehaviors(crate::error::TooManyCacheBehaviors),
    /// <p>You have reached the maximum number of cache policies for this Amazon Web Services account. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
    TooManyCachePolicies(crate::error::TooManyCachePolicies),
    /// <p>You cannot create anymore custom SSL/TLS certificates.</p>
    TooManyCertificates(crate::error::TooManyCertificates),
    /// <p>Processing your request would cause you to exceed the maximum number of origin access identities allowed.</p>
    TooManyCloudFrontOriginAccessIdentities(crate::error::TooManyCloudFrontOriginAccessIdentities),
    /// <p>You have reached the maximum number of continuous deployment policies for this Amazon Web Services account.</p>
    TooManyContinuousDeploymentPolicies(crate::error::TooManyContinuousDeploymentPolicies),
    /// <p>Your request contains more cookie names in the whitelist than are allowed per cache behavior.</p>
    TooManyCookieNamesInWhiteList(crate::error::TooManyCookieNamesInWhiteList),
    /// <p>The number of cookies in the cache policy exceeds the maximum. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
    TooManyCookiesInCachePolicy(crate::error::TooManyCookiesInCachePolicy),
    /// <p>The number of cookies in the origin request policy exceeds the maximum. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
    TooManyCookiesInOriginRequestPolicy(crate::error::TooManyCookiesInOriginRequestPolicy),
    /// <p>The number of custom headers in the response headers policy exceeds the maximum.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
    TooManyCustomHeadersInResponseHeadersPolicy(
        crate::error::TooManyCustomHeadersInResponseHeadersPolicy,
    ),
    /// <p>Your request contains more CNAMEs than are allowed per distribution.</p>
    TooManyDistributionCnamEs(crate::error::TooManyDistributionCnamEs),
    /// <p>Processing your request would cause you to exceed the maximum number of distributions allowed.</p>
    TooManyDistributions(crate::error::TooManyDistributions),
    /// <p>The maximum number of distributions have been associated with the specified cache policy. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
    TooManyDistributionsAssociatedToCachePolicy(
        crate::error::TooManyDistributionsAssociatedToCachePolicy,
    ),
    /// <p>The maximum number of distributions have been associated with the specified configuration for field-level encryption.</p>
    TooManyDistributionsAssociatedToFieldLevelEncryptionConfig(
        crate::error::TooManyDistributionsAssociatedToFieldLevelEncryptionConfig,
    ),
    /// <p>The number of distributions that reference this key group is more than the maximum allowed. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
    TooManyDistributionsAssociatedToKeyGroup(
        crate::error::TooManyDistributionsAssociatedToKeyGroup,
    ),
    /// <p>The maximum number of distributions have been associated with the specified origin access control.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
    TooManyDistributionsAssociatedToOriginAccessControl(
        crate::error::TooManyDistributionsAssociatedToOriginAccessControl,
    ),
    /// <p>The maximum number of distributions have been associated with the specified origin request policy. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
    TooManyDistributionsAssociatedToOriginRequestPolicy(
        crate::error::TooManyDistributionsAssociatedToOriginRequestPolicy,
    ),
    /// <p>The maximum number of distributions have been associated with the specified response headers policy.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
    TooManyDistributionsAssociatedToResponseHeadersPolicy(
        crate::error::TooManyDistributionsAssociatedToResponseHeadersPolicy,
    ),
    /// <p>You have reached the maximum number of distributions that are associated with a CloudFront function. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
    TooManyDistributionsWithFunctionAssociations(
        crate::error::TooManyDistributionsWithFunctionAssociations,
    ),
    /// <p>Processing your request would cause the maximum number of distributions with Lambda@Edge function associations per owner to be exceeded.</p>
    TooManyDistributionsWithLambdaAssociations(
        crate::error::TooManyDistributionsWithLambdaAssociations,
    ),
    /// <p>The maximum number of distributions have been associated with the specified Lambda@Edge function.</p>
    TooManyDistributionsWithSingleFunctionArn(
        crate::error::TooManyDistributionsWithSingleFunctionArn,
    ),
    /// <p>The maximum number of configurations for field-level encryption have been created.</p>
    TooManyFieldLevelEncryptionConfigs(crate::error::TooManyFieldLevelEncryptionConfigs),
    /// <p>The maximum number of content type profiles for field-level encryption have been created.</p>
    TooManyFieldLevelEncryptionContentTypeProfiles(
        crate::error::TooManyFieldLevelEncryptionContentTypeProfiles,
    ),
    /// <p>The maximum number of encryption entities for field-level encryption have been created.</p>
    TooManyFieldLevelEncryptionEncryptionEntities(
        crate::error::TooManyFieldLevelEncryptionEncryptionEntities,
    ),
    /// <p>The maximum number of field patterns for field-level encryption have been created.</p>
    TooManyFieldLevelEncryptionFieldPatterns(
        crate::error::TooManyFieldLevelEncryptionFieldPatterns,
    ),
    /// <p>The maximum number of profiles for field-level encryption have been created.</p>
    TooManyFieldLevelEncryptionProfiles(crate::error::TooManyFieldLevelEncryptionProfiles),
    /// <p>The maximum number of query arg profiles for field-level encryption have been created.</p>
    TooManyFieldLevelEncryptionQueryArgProfiles(
        crate::error::TooManyFieldLevelEncryptionQueryArgProfiles,
    ),
    /// <p>You have reached the maximum number of CloudFront function associations for this distribution. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
    TooManyFunctionAssociations(crate::error::TooManyFunctionAssociations),
    /// <p>You have reached the maximum number of CloudFront functions for this Amazon Web Services account. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
    TooManyFunctions(crate::error::TooManyFunctions),
    /// <p>The number of headers in the cache policy exceeds the maximum. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
    TooManyHeadersInCachePolicy(crate::error::TooManyHeadersInCachePolicy),
    /// <p>Your request contains too many headers in forwarded values.</p>
    TooManyHeadersInForwardedValues(crate::error::TooManyHeadersInForwardedValues),
    /// <p>The number of headers in the origin request policy exceeds the maximum. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
    TooManyHeadersInOriginRequestPolicy(crate::error::TooManyHeadersInOriginRequestPolicy),
    /// <p>You have exceeded the maximum number of allowable InProgress invalidation batch requests, or invalidation objects.</p>
    TooManyInvalidationsInProgress(crate::error::TooManyInvalidationsInProgress),
    /// <p>You have reached the maximum number of key groups for this Amazon Web Services account. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
    TooManyKeyGroups(crate::error::TooManyKeyGroups),
    /// <p>The number of key groups referenced by this distribution is more than the maximum allowed. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
    TooManyKeyGroupsAssociatedToDistribution(
        crate::error::TooManyKeyGroupsAssociatedToDistribution,
    ),
    /// <p>Your request contains more Lambda@Edge function associations than are allowed per distribution.</p>
    TooManyLambdaFunctionAssociations(crate::error::TooManyLambdaFunctionAssociations),
    /// <p>The number of origin access controls in your Amazon Web Services account exceeds the maximum allowed.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
    TooManyOriginAccessControls(crate::error::TooManyOriginAccessControls),
    /// <p>Your request contains too many origin custom headers.</p>
    TooManyOriginCustomHeaders(crate::error::TooManyOriginCustomHeaders),
    /// <p>Processing your request would cause you to exceed the maximum number of origin groups allowed.</p>
    TooManyOriginGroupsPerDistribution(crate::error::TooManyOriginGroupsPerDistribution),
    /// <p>You have reached the maximum number of origin request policies for this Amazon Web Services account. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
    TooManyOriginRequestPolicies(crate::error::TooManyOriginRequestPolicies),
    /// <p>You cannot create more origins for the distribution.</p>
    TooManyOrigins(crate::error::TooManyOrigins),
    /// <p>The maximum number of public keys for field-level encryption have been created. To create a new public key, delete one of the existing keys.</p>
    TooManyPublicKeys(crate::error::TooManyPublicKeys),
    /// <p>The number of public keys in this key group is more than the maximum allowed. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
    TooManyPublicKeysInKeyGroup(crate::error::TooManyPublicKeysInKeyGroup),
    /// <p>Your request contains too many query string parameters.</p>
    TooManyQueryStringParameters(crate::error::TooManyQueryStringParameters),
    /// <p>The number of query strings in the cache policy exceeds the maximum. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
    TooManyQueryStringsInCachePolicy(crate::error::TooManyQueryStringsInCachePolicy),
    /// <p>The number of query strings in the origin request policy exceeds the maximum. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
    TooManyQueryStringsInOriginRequestPolicy(
        crate::error::TooManyQueryStringsInOriginRequestPolicy,
    ),
    /// <p>You have reached the maximum number of real-time log configurations for this Amazon Web Services account. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
    TooManyRealtimeLogConfigs(crate::error::TooManyRealtimeLogConfigs),
    /// <p>The number of headers in <code>RemoveHeadersConfig</code> in the response headers policy exceeds the maximum.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
    TooManyRemoveHeadersInResponseHeadersPolicy(
        crate::error::TooManyRemoveHeadersInResponseHeadersPolicy,
    ),
    /// <p>You have reached the maximum number of response headers policies for this Amazon Web Services account.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the <i>Amazon CloudFront Developer Guide</i>.</p>
    TooManyResponseHeadersPolicies(crate::error::TooManyResponseHeadersPolicies),
    /// <p>Your request contains more CNAMEs than are allowed per distribution.</p>
    TooManyStreamingDistributionCnamEs(crate::error::TooManyStreamingDistributionCnamEs),
    /// <p>Processing your request would cause you to exceed the maximum number of streaming distributions allowed.</p>
    TooManyStreamingDistributions(crate::error::TooManyStreamingDistributions),
    /// <p>Your request contains more trusted signers than are allowed per distribution.</p>
    TooManyTrustedSigners(crate::error::TooManyTrustedSigners),
    /// <p>The specified key group does not exist.</p>
    TrustedKeyGroupDoesNotExist(crate::error::TrustedKeyGroupDoesNotExist),
    /// <p>One or more of your trusted signers don't exist.</p>
    TrustedSignerDoesNotExist(crate::error::TrustedSignerDoesNotExist),
    /// <p>This operation is not supported in this region.</p>
    UnsupportedOperation(crate::error::UnsupportedOperation),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl std::fmt::Display for Error {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Error::AccessDenied(inner) => inner.fmt(f),
            Error::BatchTooLarge(inner) => inner.fmt(f),
            Error::CnameAlreadyExists(inner) => inner.fmt(f),
            Error::CachePolicyAlreadyExists(inner) => inner.fmt(f),
            Error::CachePolicyInUse(inner) => inner.fmt(f),
            Error::CannotChangeImmutablePublicKeyFields(inner) => inner.fmt(f),
            Error::CloudFrontOriginAccessIdentityAlreadyExists(inner) => inner.fmt(f),
            Error::CloudFrontOriginAccessIdentityInUse(inner) => inner.fmt(f),
            Error::ContinuousDeploymentPolicyAlreadyExists(inner) => inner.fmt(f),
            Error::ContinuousDeploymentPolicyInUse(inner) => inner.fmt(f),
            Error::DistributionAlreadyExists(inner) => inner.fmt(f),
            Error::DistributionNotDisabled(inner) => inner.fmt(f),
            Error::FieldLevelEncryptionConfigAlreadyExists(inner) => inner.fmt(f),
            Error::FieldLevelEncryptionConfigInUse(inner) => inner.fmt(f),
            Error::FieldLevelEncryptionProfileAlreadyExists(inner) => inner.fmt(f),
            Error::FieldLevelEncryptionProfileInUse(inner) => inner.fmt(f),
            Error::FieldLevelEncryptionProfileSizeExceeded(inner) => inner.fmt(f),
            Error::FunctionAlreadyExists(inner) => inner.fmt(f),
            Error::FunctionInUse(inner) => inner.fmt(f),
            Error::FunctionSizeLimitExceeded(inner) => inner.fmt(f),
            Error::IllegalDelete(inner) => inner.fmt(f),
            Error::IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior(inner) => {
                inner.fmt(f)
            }
            Error::IllegalOriginAccessConfiguration(inner) => inner.fmt(f),
            Error::IllegalUpdate(inner) => inner.fmt(f),
            Error::InconsistentQuantities(inner) => inner.fmt(f),
            Error::InvalidArgument(inner) => inner.fmt(f),
            Error::InvalidDefaultRootObject(inner) => inner.fmt(f),
            Error::InvalidDomainNameForOriginAccessControl(inner) => inner.fmt(f),
            Error::InvalidErrorCode(inner) => inner.fmt(f),
            Error::InvalidForwardCookies(inner) => inner.fmt(f),
            Error::InvalidFunctionAssociation(inner) => inner.fmt(f),
            Error::InvalidGeoRestrictionParameter(inner) => inner.fmt(f),
            Error::InvalidHeadersForS3Origin(inner) => inner.fmt(f),
            Error::InvalidIfMatchVersion(inner) => inner.fmt(f),
            Error::InvalidLambdaFunctionAssociation(inner) => inner.fmt(f),
            Error::InvalidLocationCode(inner) => inner.fmt(f),
            Error::InvalidMinimumProtocolVersion(inner) => inner.fmt(f),
            Error::InvalidOrigin(inner) => inner.fmt(f),
            Error::InvalidOriginAccessControl(inner) => inner.fmt(f),
            Error::InvalidOriginAccessIdentity(inner) => inner.fmt(f),
            Error::InvalidOriginKeepaliveTimeout(inner) => inner.fmt(f),
            Error::InvalidOriginReadTimeout(inner) => inner.fmt(f),
            Error::InvalidProtocolSettings(inner) => inner.fmt(f),
            Error::InvalidQueryStringParameters(inner) => inner.fmt(f),
            Error::InvalidRelativePath(inner) => inner.fmt(f),
            Error::InvalidRequiredProtocol(inner) => inner.fmt(f),
            Error::InvalidResponseCode(inner) => inner.fmt(f),
            Error::InvalidTtlOrder(inner) => inner.fmt(f),
            Error::InvalidTagging(inner) => inner.fmt(f),
            Error::InvalidViewerCertificate(inner) => inner.fmt(f),
            Error::InvalidWebAclId(inner) => inner.fmt(f),
            Error::KeyGroupAlreadyExists(inner) => inner.fmt(f),
            Error::MissingBody(inner) => inner.fmt(f),
            Error::MonitoringSubscriptionAlreadyExists(inner) => inner.fmt(f),
            Error::NoSuchCachePolicy(inner) => inner.fmt(f),
            Error::NoSuchCloudFrontOriginAccessIdentity(inner) => inner.fmt(f),
            Error::NoSuchContinuousDeploymentPolicy(inner) => inner.fmt(f),
            Error::NoSuchDistribution(inner) => inner.fmt(f),
            Error::NoSuchFieldLevelEncryptionConfig(inner) => inner.fmt(f),
            Error::NoSuchFieldLevelEncryptionProfile(inner) => inner.fmt(f),
            Error::NoSuchFunctionExists(inner) => inner.fmt(f),
            Error::NoSuchInvalidation(inner) => inner.fmt(f),
            Error::NoSuchMonitoringSubscription(inner) => inner.fmt(f),
            Error::NoSuchOrigin(inner) => inner.fmt(f),
            Error::NoSuchOriginAccessControl(inner) => inner.fmt(f),
            Error::NoSuchOriginRequestPolicy(inner) => inner.fmt(f),
            Error::NoSuchPublicKey(inner) => inner.fmt(f),
            Error::NoSuchRealtimeLogConfig(inner) => inner.fmt(f),
            Error::NoSuchResource(inner) => inner.fmt(f),
            Error::NoSuchResponseHeadersPolicy(inner) => inner.fmt(f),
            Error::NoSuchStreamingDistribution(inner) => inner.fmt(f),
            Error::OriginAccessControlAlreadyExists(inner) => inner.fmt(f),
            Error::OriginAccessControlInUse(inner) => inner.fmt(f),
            Error::OriginRequestPolicyAlreadyExists(inner) => inner.fmt(f),
            Error::OriginRequestPolicyInUse(inner) => inner.fmt(f),
            Error::PreconditionFailed(inner) => inner.fmt(f),
            Error::PublicKeyAlreadyExists(inner) => inner.fmt(f),
            Error::PublicKeyInUse(inner) => inner.fmt(f),
            Error::QueryArgProfileEmpty(inner) => inner.fmt(f),
            Error::RealtimeLogConfigAlreadyExists(inner) => inner.fmt(f),
            Error::RealtimeLogConfigInUse(inner) => inner.fmt(f),
            Error::RealtimeLogConfigOwnerMismatch(inner) => inner.fmt(f),
            Error::ResourceInUse(inner) => inner.fmt(f),
            Error::ResponseHeadersPolicyAlreadyExists(inner) => inner.fmt(f),
            Error::ResponseHeadersPolicyInUse(inner) => inner.fmt(f),
            Error::StagingDistributionInUse(inner) => inner.fmt(f),
            Error::StreamingDistributionAlreadyExists(inner) => inner.fmt(f),
            Error::StreamingDistributionNotDisabled(inner) => inner.fmt(f),
            Error::TestFunctionFailed(inner) => inner.fmt(f),
            Error::TooLongCspInResponseHeadersPolicy(inner) => inner.fmt(f),
            Error::TooManyCacheBehaviors(inner) => inner.fmt(f),
            Error::TooManyCachePolicies(inner) => inner.fmt(f),
            Error::TooManyCertificates(inner) => inner.fmt(f),
            Error::TooManyCloudFrontOriginAccessIdentities(inner) => inner.fmt(f),
            Error::TooManyContinuousDeploymentPolicies(inner) => inner.fmt(f),
            Error::TooManyCookieNamesInWhiteList(inner) => inner.fmt(f),
            Error::TooManyCookiesInCachePolicy(inner) => inner.fmt(f),
            Error::TooManyCookiesInOriginRequestPolicy(inner) => inner.fmt(f),
            Error::TooManyCustomHeadersInResponseHeadersPolicy(inner) => inner.fmt(f),
            Error::TooManyDistributionCnamEs(inner) => inner.fmt(f),
            Error::TooManyDistributions(inner) => inner.fmt(f),
            Error::TooManyDistributionsAssociatedToCachePolicy(inner) => inner.fmt(f),
            Error::TooManyDistributionsAssociatedToFieldLevelEncryptionConfig(inner) => {
                inner.fmt(f)
            }
            Error::TooManyDistributionsAssociatedToKeyGroup(inner) => inner.fmt(f),
            Error::TooManyDistributionsAssociatedToOriginAccessControl(inner) => inner.fmt(f),
            Error::TooManyDistributionsAssociatedToOriginRequestPolicy(inner) => inner.fmt(f),
            Error::TooManyDistributionsAssociatedToResponseHeadersPolicy(inner) => inner.fmt(f),
            Error::TooManyDistributionsWithFunctionAssociations(inner) => inner.fmt(f),
            Error::TooManyDistributionsWithLambdaAssociations(inner) => inner.fmt(f),
            Error::TooManyDistributionsWithSingleFunctionArn(inner) => inner.fmt(f),
            Error::TooManyFieldLevelEncryptionConfigs(inner) => inner.fmt(f),
            Error::TooManyFieldLevelEncryptionContentTypeProfiles(inner) => inner.fmt(f),
            Error::TooManyFieldLevelEncryptionEncryptionEntities(inner) => inner.fmt(f),
            Error::TooManyFieldLevelEncryptionFieldPatterns(inner) => inner.fmt(f),
            Error::TooManyFieldLevelEncryptionProfiles(inner) => inner.fmt(f),
            Error::TooManyFieldLevelEncryptionQueryArgProfiles(inner) => inner.fmt(f),
            Error::TooManyFunctionAssociations(inner) => inner.fmt(f),
            Error::TooManyFunctions(inner) => inner.fmt(f),
            Error::TooManyHeadersInCachePolicy(inner) => inner.fmt(f),
            Error::TooManyHeadersInForwardedValues(inner) => inner.fmt(f),
            Error::TooManyHeadersInOriginRequestPolicy(inner) => inner.fmt(f),
            Error::TooManyInvalidationsInProgress(inner) => inner.fmt(f),
            Error::TooManyKeyGroups(inner) => inner.fmt(f),
            Error::TooManyKeyGroupsAssociatedToDistribution(inner) => inner.fmt(f),
            Error::TooManyLambdaFunctionAssociations(inner) => inner.fmt(f),
            Error::TooManyOriginAccessControls(inner) => inner.fmt(f),
            Error::TooManyOriginCustomHeaders(inner) => inner.fmt(f),
            Error::TooManyOriginGroupsPerDistribution(inner) => inner.fmt(f),
            Error::TooManyOriginRequestPolicies(inner) => inner.fmt(f),
            Error::TooManyOrigins(inner) => inner.fmt(f),
            Error::TooManyPublicKeys(inner) => inner.fmt(f),
            Error::TooManyPublicKeysInKeyGroup(inner) => inner.fmt(f),
            Error::TooManyQueryStringParameters(inner) => inner.fmt(f),
            Error::TooManyQueryStringsInCachePolicy(inner) => inner.fmt(f),
            Error::TooManyQueryStringsInOriginRequestPolicy(inner) => inner.fmt(f),
            Error::TooManyRealtimeLogConfigs(inner) => inner.fmt(f),
            Error::TooManyRemoveHeadersInResponseHeadersPolicy(inner) => inner.fmt(f),
            Error::TooManyResponseHeadersPolicies(inner) => inner.fmt(f),
            Error::TooManyStreamingDistributionCnamEs(inner) => inner.fmt(f),
            Error::TooManyStreamingDistributions(inner) => inner.fmt(f),
            Error::TooManyTrustedSigners(inner) => inner.fmt(f),
            Error::TrustedKeyGroupDoesNotExist(inner) => inner.fmt(f),
            Error::TrustedSignerDoesNotExist(inner) => inner.fmt(f),
            Error::UnsupportedOperation(inner) => inner.fmt(f),
            Error::Unhandled(inner) => inner.fmt(f),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::AssociateAliasError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::AssociateAliasError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::AssociateAliasError> for Error {
    fn from(err: crate::error::AssociateAliasError) -> Self {
        match err {
            crate::error::AssociateAliasError::AccessDenied(inner) => Error::AccessDenied(inner),
            crate::error::AssociateAliasError::IllegalUpdate(inner) => Error::IllegalUpdate(inner),
            crate::error::AssociateAliasError::InvalidArgument(inner) => {
                Error::InvalidArgument(inner)
            }
            crate::error::AssociateAliasError::NoSuchDistribution(inner) => {
                Error::NoSuchDistribution(inner)
            }
            crate::error::AssociateAliasError::TooManyDistributionCnamEs(inner) => {
                Error::TooManyDistributionCnamEs(inner)
            }
            crate::error::AssociateAliasError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::CopyDistributionError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::CopyDistributionError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::CopyDistributionError> for Error {
    fn from(err: crate::error::CopyDistributionError) -> Self {
        match err {
            crate::error::CopyDistributionError::AccessDenied(inner) => Error::AccessDenied(inner),
            crate::error::CopyDistributionError::CnameAlreadyExists(inner) => Error::CnameAlreadyExists(inner),
            crate::error::CopyDistributionError::DistributionAlreadyExists(inner) => Error::DistributionAlreadyExists(inner),
            crate::error::CopyDistributionError::IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior(inner) => Error::IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior(inner),
            crate::error::CopyDistributionError::InconsistentQuantities(inner) => Error::InconsistentQuantities(inner),
            crate::error::CopyDistributionError::InvalidArgument(inner) => Error::InvalidArgument(inner),
            crate::error::CopyDistributionError::InvalidDefaultRootObject(inner) => Error::InvalidDefaultRootObject(inner),
            crate::error::CopyDistributionError::InvalidErrorCode(inner) => Error::InvalidErrorCode(inner),
            crate::error::CopyDistributionError::InvalidForwardCookies(inner) => Error::InvalidForwardCookies(inner),
            crate::error::CopyDistributionError::InvalidFunctionAssociation(inner) => Error::InvalidFunctionAssociation(inner),
            crate::error::CopyDistributionError::InvalidGeoRestrictionParameter(inner) => Error::InvalidGeoRestrictionParameter(inner),
            crate::error::CopyDistributionError::InvalidHeadersForS3Origin(inner) => Error::InvalidHeadersForS3Origin(inner),
            crate::error::CopyDistributionError::InvalidIfMatchVersion(inner) => Error::InvalidIfMatchVersion(inner),
            crate::error::CopyDistributionError::InvalidLambdaFunctionAssociation(inner) => Error::InvalidLambdaFunctionAssociation(inner),
            crate::error::CopyDistributionError::InvalidLocationCode(inner) => Error::InvalidLocationCode(inner),
            crate::error::CopyDistributionError::InvalidMinimumProtocolVersion(inner) => Error::InvalidMinimumProtocolVersion(inner),
            crate::error::CopyDistributionError::InvalidOrigin(inner) => Error::InvalidOrigin(inner),
            crate::error::CopyDistributionError::InvalidOriginAccessControl(inner) => Error::InvalidOriginAccessControl(inner),
            crate::error::CopyDistributionError::InvalidOriginAccessIdentity(inner) => Error::InvalidOriginAccessIdentity(inner),
            crate::error::CopyDistributionError::InvalidOriginKeepaliveTimeout(inner) => Error::InvalidOriginKeepaliveTimeout(inner),
            crate::error::CopyDistributionError::InvalidOriginReadTimeout(inner) => Error::InvalidOriginReadTimeout(inner),
            crate::error::CopyDistributionError::InvalidProtocolSettings(inner) => Error::InvalidProtocolSettings(inner),
            crate::error::CopyDistributionError::InvalidQueryStringParameters(inner) => Error::InvalidQueryStringParameters(inner),
            crate::error::CopyDistributionError::InvalidRelativePath(inner) => Error::InvalidRelativePath(inner),
            crate::error::CopyDistributionError::InvalidRequiredProtocol(inner) => Error::InvalidRequiredProtocol(inner),
            crate::error::CopyDistributionError::InvalidResponseCode(inner) => Error::InvalidResponseCode(inner),
            crate::error::CopyDistributionError::InvalidTtlOrder(inner) => Error::InvalidTtlOrder(inner),
            crate::error::CopyDistributionError::InvalidViewerCertificate(inner) => Error::InvalidViewerCertificate(inner),
            crate::error::CopyDistributionError::InvalidWebAclId(inner) => Error::InvalidWebAclId(inner),
            crate::error::CopyDistributionError::MissingBody(inner) => Error::MissingBody(inner),
            crate::error::CopyDistributionError::NoSuchCachePolicy(inner) => Error::NoSuchCachePolicy(inner),
            crate::error::CopyDistributionError::NoSuchDistribution(inner) => Error::NoSuchDistribution(inner),
            crate::error::CopyDistributionError::NoSuchFieldLevelEncryptionConfig(inner) => Error::NoSuchFieldLevelEncryptionConfig(inner),
            crate::error::CopyDistributionError::NoSuchOrigin(inner) => Error::NoSuchOrigin(inner),
            crate::error::CopyDistributionError::NoSuchOriginRequestPolicy(inner) => Error::NoSuchOriginRequestPolicy(inner),
            crate::error::CopyDistributionError::NoSuchRealtimeLogConfig(inner) => Error::NoSuchRealtimeLogConfig(inner),
            crate::error::CopyDistributionError::NoSuchResponseHeadersPolicy(inner) => Error::NoSuchResponseHeadersPolicy(inner),
            crate::error::CopyDistributionError::PreconditionFailed(inner) => Error::PreconditionFailed(inner),
            crate::error::CopyDistributionError::RealtimeLogConfigOwnerMismatch(inner) => Error::RealtimeLogConfigOwnerMismatch(inner),
            crate::error::CopyDistributionError::TooManyCacheBehaviors(inner) => Error::TooManyCacheBehaviors(inner),
            crate::error::CopyDistributionError::TooManyCertificates(inner) => Error::TooManyCertificates(inner),
            crate::error::CopyDistributionError::TooManyCookieNamesInWhiteList(inner) => Error::TooManyCookieNamesInWhiteList(inner),
            crate::error::CopyDistributionError::TooManyDistributionCnamEs(inner) => Error::TooManyDistributionCnamEs(inner),
            crate::error::CopyDistributionError::TooManyDistributions(inner) => Error::TooManyDistributions(inner),
            crate::error::CopyDistributionError::TooManyDistributionsAssociatedToCachePolicy(inner) => Error::TooManyDistributionsAssociatedToCachePolicy(inner),
            crate::error::CopyDistributionError::TooManyDistributionsAssociatedToFieldLevelEncryptionConfig(inner) => Error::TooManyDistributionsAssociatedToFieldLevelEncryptionConfig(inner),
            crate::error::CopyDistributionError::TooManyDistributionsAssociatedToKeyGroup(inner) => Error::TooManyDistributionsAssociatedToKeyGroup(inner),
            crate::error::CopyDistributionError::TooManyDistributionsAssociatedToOriginRequestPolicy(inner) => Error::TooManyDistributionsAssociatedToOriginRequestPolicy(inner),
            crate::error::CopyDistributionError::TooManyDistributionsAssociatedToResponseHeadersPolicy(inner) => Error::TooManyDistributionsAssociatedToResponseHeadersPolicy(inner),
            crate::error::CopyDistributionError::TooManyDistributionsWithFunctionAssociations(inner) => Error::TooManyDistributionsWithFunctionAssociations(inner),
            crate::error::CopyDistributionError::TooManyDistributionsWithLambdaAssociations(inner) => Error::TooManyDistributionsWithLambdaAssociations(inner),
            crate::error::CopyDistributionError::TooManyDistributionsWithSingleFunctionArn(inner) => Error::TooManyDistributionsWithSingleFunctionArn(inner),
            crate::error::CopyDistributionError::TooManyFunctionAssociations(inner) => Error::TooManyFunctionAssociations(inner),
            crate::error::CopyDistributionError::TooManyHeadersInForwardedValues(inner) => Error::TooManyHeadersInForwardedValues(inner),
            crate::error::CopyDistributionError::TooManyKeyGroupsAssociatedToDistribution(inner) => Error::TooManyKeyGroupsAssociatedToDistribution(inner),
            crate::error::CopyDistributionError::TooManyLambdaFunctionAssociations(inner) => Error::TooManyLambdaFunctionAssociations(inner),
            crate::error::CopyDistributionError::TooManyOriginCustomHeaders(inner) => Error::TooManyOriginCustomHeaders(inner),
            crate::error::CopyDistributionError::TooManyOriginGroupsPerDistribution(inner) => Error::TooManyOriginGroupsPerDistribution(inner),
            crate::error::CopyDistributionError::TooManyOrigins(inner) => Error::TooManyOrigins(inner),
            crate::error::CopyDistributionError::TooManyQueryStringParameters(inner) => Error::TooManyQueryStringParameters(inner),
            crate::error::CopyDistributionError::TooManyTrustedSigners(inner) => Error::TooManyTrustedSigners(inner),
            crate::error::CopyDistributionError::TrustedKeyGroupDoesNotExist(inner) => Error::TrustedKeyGroupDoesNotExist(inner),
            crate::error::CopyDistributionError::TrustedSignerDoesNotExist(inner) => Error::TrustedSignerDoesNotExist(inner),
            crate::error::CopyDistributionError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::CreateCachePolicyError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::CreateCachePolicyError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::CreateCachePolicyError> for Error {
    fn from(err: crate::error::CreateCachePolicyError) -> Self {
        match err {
            crate::error::CreateCachePolicyError::AccessDenied(inner) => Error::AccessDenied(inner),
            crate::error::CreateCachePolicyError::CachePolicyAlreadyExists(inner) => {
                Error::CachePolicyAlreadyExists(inner)
            }
            crate::error::CreateCachePolicyError::InconsistentQuantities(inner) => {
                Error::InconsistentQuantities(inner)
            }
            crate::error::CreateCachePolicyError::InvalidArgument(inner) => {
                Error::InvalidArgument(inner)
            }
            crate::error::CreateCachePolicyError::TooManyCachePolicies(inner) => {
                Error::TooManyCachePolicies(inner)
            }
            crate::error::CreateCachePolicyError::TooManyCookiesInCachePolicy(inner) => {
                Error::TooManyCookiesInCachePolicy(inner)
            }
            crate::error::CreateCachePolicyError::TooManyHeadersInCachePolicy(inner) => {
                Error::TooManyHeadersInCachePolicy(inner)
            }
            crate::error::CreateCachePolicyError::TooManyQueryStringsInCachePolicy(inner) => {
                Error::TooManyQueryStringsInCachePolicy(inner)
            }
            crate::error::CreateCachePolicyError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::error::CreateCloudFrontOriginAccessIdentityError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::error::CreateCloudFrontOriginAccessIdentityError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::CreateCloudFrontOriginAccessIdentityError> for Error {
    fn from(err: crate::error::CreateCloudFrontOriginAccessIdentityError) -> Self {
        match err {
            crate::error::CreateCloudFrontOriginAccessIdentityError::CloudFrontOriginAccessIdentityAlreadyExists(inner) => Error::CloudFrontOriginAccessIdentityAlreadyExists(inner),
            crate::error::CreateCloudFrontOriginAccessIdentityError::InconsistentQuantities(inner) => Error::InconsistentQuantities(inner),
            crate::error::CreateCloudFrontOriginAccessIdentityError::InvalidArgument(inner) => Error::InvalidArgument(inner),
            crate::error::CreateCloudFrontOriginAccessIdentityError::MissingBody(inner) => Error::MissingBody(inner),
            crate::error::CreateCloudFrontOriginAccessIdentityError::TooManyCloudFrontOriginAccessIdentities(inner) => Error::TooManyCloudFrontOriginAccessIdentities(inner),
            crate::error::CreateCloudFrontOriginAccessIdentityError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<aws_smithy_http::result::SdkError<crate::error::CreateContinuousDeploymentPolicyError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::error::CreateContinuousDeploymentPolicyError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::CreateContinuousDeploymentPolicyError> for Error {
    fn from(err: crate::error::CreateContinuousDeploymentPolicyError) -> Self {
        match err {
            crate::error::CreateContinuousDeploymentPolicyError::AccessDenied(inner) => Error::AccessDenied(inner),
            crate::error::CreateContinuousDeploymentPolicyError::ContinuousDeploymentPolicyAlreadyExists(inner) => Error::ContinuousDeploymentPolicyAlreadyExists(inner),
            crate::error::CreateContinuousDeploymentPolicyError::InconsistentQuantities(inner) => Error::InconsistentQuantities(inner),
            crate::error::CreateContinuousDeploymentPolicyError::InvalidArgument(inner) => Error::InvalidArgument(inner),
            crate::error::CreateContinuousDeploymentPolicyError::StagingDistributionInUse(inner) => Error::StagingDistributionInUse(inner),
            crate::error::CreateContinuousDeploymentPolicyError::TooManyContinuousDeploymentPolicies(inner) => Error::TooManyContinuousDeploymentPolicies(inner),
            crate::error::CreateContinuousDeploymentPolicyError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::CreateDistributionError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::CreateDistributionError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::CreateDistributionError> for Error {
    fn from(err: crate::error::CreateDistributionError) -> Self {
        match err {
            crate::error::CreateDistributionError::AccessDenied(inner) => Error::AccessDenied(inner),
            crate::error::CreateDistributionError::CnameAlreadyExists(inner) => Error::CnameAlreadyExists(inner),
            crate::error::CreateDistributionError::ContinuousDeploymentPolicyInUse(inner) => Error::ContinuousDeploymentPolicyInUse(inner),
            crate::error::CreateDistributionError::DistributionAlreadyExists(inner) => Error::DistributionAlreadyExists(inner),
            crate::error::CreateDistributionError::IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior(inner) => Error::IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior(inner),
            crate::error::CreateDistributionError::IllegalOriginAccessConfiguration(inner) => Error::IllegalOriginAccessConfiguration(inner),
            crate::error::CreateDistributionError::InconsistentQuantities(inner) => Error::InconsistentQuantities(inner),
            crate::error::CreateDistributionError::InvalidArgument(inner) => Error::InvalidArgument(inner),
            crate::error::CreateDistributionError::InvalidDefaultRootObject(inner) => Error::InvalidDefaultRootObject(inner),
            crate::error::CreateDistributionError::InvalidDomainNameForOriginAccessControl(inner) => Error::InvalidDomainNameForOriginAccessControl(inner),
            crate::error::CreateDistributionError::InvalidErrorCode(inner) => Error::InvalidErrorCode(inner),
            crate::error::CreateDistributionError::InvalidForwardCookies(inner) => Error::InvalidForwardCookies(inner),
            crate::error::CreateDistributionError::InvalidFunctionAssociation(inner) => Error::InvalidFunctionAssociation(inner),
            crate::error::CreateDistributionError::InvalidGeoRestrictionParameter(inner) => Error::InvalidGeoRestrictionParameter(inner),
            crate::error::CreateDistributionError::InvalidHeadersForS3Origin(inner) => Error::InvalidHeadersForS3Origin(inner),
            crate::error::CreateDistributionError::InvalidLambdaFunctionAssociation(inner) => Error::InvalidLambdaFunctionAssociation(inner),
            crate::error::CreateDistributionError::InvalidLocationCode(inner) => Error::InvalidLocationCode(inner),
            crate::error::CreateDistributionError::InvalidMinimumProtocolVersion(inner) => Error::InvalidMinimumProtocolVersion(inner),
            crate::error::CreateDistributionError::InvalidOrigin(inner) => Error::InvalidOrigin(inner),
            crate::error::CreateDistributionError::InvalidOriginAccessControl(inner) => Error::InvalidOriginAccessControl(inner),
            crate::error::CreateDistributionError::InvalidOriginAccessIdentity(inner) => Error::InvalidOriginAccessIdentity(inner),
            crate::error::CreateDistributionError::InvalidOriginKeepaliveTimeout(inner) => Error::InvalidOriginKeepaliveTimeout(inner),
            crate::error::CreateDistributionError::InvalidOriginReadTimeout(inner) => Error::InvalidOriginReadTimeout(inner),
            crate::error::CreateDistributionError::InvalidProtocolSettings(inner) => Error::InvalidProtocolSettings(inner),
            crate::error::CreateDistributionError::InvalidQueryStringParameters(inner) => Error::InvalidQueryStringParameters(inner),
            crate::error::CreateDistributionError::InvalidRelativePath(inner) => Error::InvalidRelativePath(inner),
            crate::error::CreateDistributionError::InvalidRequiredProtocol(inner) => Error::InvalidRequiredProtocol(inner),
            crate::error::CreateDistributionError::InvalidResponseCode(inner) => Error::InvalidResponseCode(inner),
            crate::error::CreateDistributionError::InvalidTtlOrder(inner) => Error::InvalidTtlOrder(inner),
            crate::error::CreateDistributionError::InvalidViewerCertificate(inner) => Error::InvalidViewerCertificate(inner),
            crate::error::CreateDistributionError::InvalidWebAclId(inner) => Error::InvalidWebAclId(inner),
            crate::error::CreateDistributionError::MissingBody(inner) => Error::MissingBody(inner),
            crate::error::CreateDistributionError::NoSuchCachePolicy(inner) => Error::NoSuchCachePolicy(inner),
            crate::error::CreateDistributionError::NoSuchContinuousDeploymentPolicy(inner) => Error::NoSuchContinuousDeploymentPolicy(inner),
            crate::error::CreateDistributionError::NoSuchFieldLevelEncryptionConfig(inner) => Error::NoSuchFieldLevelEncryptionConfig(inner),
            crate::error::CreateDistributionError::NoSuchOrigin(inner) => Error::NoSuchOrigin(inner),
            crate::error::CreateDistributionError::NoSuchOriginRequestPolicy(inner) => Error::NoSuchOriginRequestPolicy(inner),
            crate::error::CreateDistributionError::NoSuchRealtimeLogConfig(inner) => Error::NoSuchRealtimeLogConfig(inner),
            crate::error::CreateDistributionError::NoSuchResponseHeadersPolicy(inner) => Error::NoSuchResponseHeadersPolicy(inner),
            crate::error::CreateDistributionError::RealtimeLogConfigOwnerMismatch(inner) => Error::RealtimeLogConfigOwnerMismatch(inner),
            crate::error::CreateDistributionError::TooManyCacheBehaviors(inner) => Error::TooManyCacheBehaviors(inner),
            crate::error::CreateDistributionError::TooManyCertificates(inner) => Error::TooManyCertificates(inner),
            crate::error::CreateDistributionError::TooManyCookieNamesInWhiteList(inner) => Error::TooManyCookieNamesInWhiteList(inner),
            crate::error::CreateDistributionError::TooManyDistributionCnamEs(inner) => Error::TooManyDistributionCnamEs(inner),
            crate::error::CreateDistributionError::TooManyDistributions(inner) => Error::TooManyDistributions(inner),
            crate::error::CreateDistributionError::TooManyDistributionsAssociatedToCachePolicy(inner) => Error::TooManyDistributionsAssociatedToCachePolicy(inner),
            crate::error::CreateDistributionError::TooManyDistributionsAssociatedToFieldLevelEncryptionConfig(inner) => Error::TooManyDistributionsAssociatedToFieldLevelEncryptionConfig(inner),
            crate::error::CreateDistributionError::TooManyDistributionsAssociatedToKeyGroup(inner) => Error::TooManyDistributionsAssociatedToKeyGroup(inner),
            crate::error::CreateDistributionError::TooManyDistributionsAssociatedToOriginAccessControl(inner) => Error::TooManyDistributionsAssociatedToOriginAccessControl(inner),
            crate::error::CreateDistributionError::TooManyDistributionsAssociatedToOriginRequestPolicy(inner) => Error::TooManyDistributionsAssociatedToOriginRequestPolicy(inner),
            crate::error::CreateDistributionError::TooManyDistributionsAssociatedToResponseHeadersPolicy(inner) => Error::TooManyDistributionsAssociatedToResponseHeadersPolicy(inner),
            crate::error::CreateDistributionError::TooManyDistributionsWithFunctionAssociations(inner) => Error::TooManyDistributionsWithFunctionAssociations(inner),
            crate::error::CreateDistributionError::TooManyDistributionsWithLambdaAssociations(inner) => Error::TooManyDistributionsWithLambdaAssociations(inner),
            crate::error::CreateDistributionError::TooManyDistributionsWithSingleFunctionArn(inner) => Error::TooManyDistributionsWithSingleFunctionArn(inner),
            crate::error::CreateDistributionError::TooManyFunctionAssociations(inner) => Error::TooManyFunctionAssociations(inner),
            crate::error::CreateDistributionError::TooManyHeadersInForwardedValues(inner) => Error::TooManyHeadersInForwardedValues(inner),
            crate::error::CreateDistributionError::TooManyKeyGroupsAssociatedToDistribution(inner) => Error::TooManyKeyGroupsAssociatedToDistribution(inner),
            crate::error::CreateDistributionError::TooManyLambdaFunctionAssociations(inner) => Error::TooManyLambdaFunctionAssociations(inner),
            crate::error::CreateDistributionError::TooManyOriginCustomHeaders(inner) => Error::TooManyOriginCustomHeaders(inner),
            crate::error::CreateDistributionError::TooManyOriginGroupsPerDistribution(inner) => Error::TooManyOriginGroupsPerDistribution(inner),
            crate::error::CreateDistributionError::TooManyOrigins(inner) => Error::TooManyOrigins(inner),
            crate::error::CreateDistributionError::TooManyQueryStringParameters(inner) => Error::TooManyQueryStringParameters(inner),
            crate::error::CreateDistributionError::TooManyTrustedSigners(inner) => Error::TooManyTrustedSigners(inner),
            crate::error::CreateDistributionError::TrustedKeyGroupDoesNotExist(inner) => Error::TrustedKeyGroupDoesNotExist(inner),
            crate::error::CreateDistributionError::TrustedSignerDoesNotExist(inner) => Error::TrustedSignerDoesNotExist(inner),
            crate::error::CreateDistributionError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::CreateDistributionWithTagsError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::CreateDistributionWithTagsError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::CreateDistributionWithTagsError> for Error {
    fn from(err: crate::error::CreateDistributionWithTagsError) -> Self {
        match err {
            crate::error::CreateDistributionWithTagsError::AccessDenied(inner) => Error::AccessDenied(inner),
            crate::error::CreateDistributionWithTagsError::CnameAlreadyExists(inner) => Error::CnameAlreadyExists(inner),
            crate::error::CreateDistributionWithTagsError::ContinuousDeploymentPolicyInUse(inner) => Error::ContinuousDeploymentPolicyInUse(inner),
            crate::error::CreateDistributionWithTagsError::DistributionAlreadyExists(inner) => Error::DistributionAlreadyExists(inner),
            crate::error::CreateDistributionWithTagsError::IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior(inner) => Error::IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior(inner),
            crate::error::CreateDistributionWithTagsError::InconsistentQuantities(inner) => Error::InconsistentQuantities(inner),
            crate::error::CreateDistributionWithTagsError::InvalidArgument(inner) => Error::InvalidArgument(inner),
            crate::error::CreateDistributionWithTagsError::InvalidDefaultRootObject(inner) => Error::InvalidDefaultRootObject(inner),
            crate::error::CreateDistributionWithTagsError::InvalidDomainNameForOriginAccessControl(inner) => Error::InvalidDomainNameForOriginAccessControl(inner),
            crate::error::CreateDistributionWithTagsError::InvalidErrorCode(inner) => Error::InvalidErrorCode(inner),
            crate::error::CreateDistributionWithTagsError::InvalidForwardCookies(inner) => Error::InvalidForwardCookies(inner),
            crate::error::CreateDistributionWithTagsError::InvalidFunctionAssociation(inner) => Error::InvalidFunctionAssociation(inner),
            crate::error::CreateDistributionWithTagsError::InvalidGeoRestrictionParameter(inner) => Error::InvalidGeoRestrictionParameter(inner),
            crate::error::CreateDistributionWithTagsError::InvalidHeadersForS3Origin(inner) => Error::InvalidHeadersForS3Origin(inner),
            crate::error::CreateDistributionWithTagsError::InvalidLambdaFunctionAssociation(inner) => Error::InvalidLambdaFunctionAssociation(inner),
            crate::error::CreateDistributionWithTagsError::InvalidLocationCode(inner) => Error::InvalidLocationCode(inner),
            crate::error::CreateDistributionWithTagsError::InvalidMinimumProtocolVersion(inner) => Error::InvalidMinimumProtocolVersion(inner),
            crate::error::CreateDistributionWithTagsError::InvalidOrigin(inner) => Error::InvalidOrigin(inner),
            crate::error::CreateDistributionWithTagsError::InvalidOriginAccessControl(inner) => Error::InvalidOriginAccessControl(inner),
            crate::error::CreateDistributionWithTagsError::InvalidOriginAccessIdentity(inner) => Error::InvalidOriginAccessIdentity(inner),
            crate::error::CreateDistributionWithTagsError::InvalidOriginKeepaliveTimeout(inner) => Error::InvalidOriginKeepaliveTimeout(inner),
            crate::error::CreateDistributionWithTagsError::InvalidOriginReadTimeout(inner) => Error::InvalidOriginReadTimeout(inner),
            crate::error::CreateDistributionWithTagsError::InvalidProtocolSettings(inner) => Error::InvalidProtocolSettings(inner),
            crate::error::CreateDistributionWithTagsError::InvalidQueryStringParameters(inner) => Error::InvalidQueryStringParameters(inner),
            crate::error::CreateDistributionWithTagsError::InvalidRelativePath(inner) => Error::InvalidRelativePath(inner),
            crate::error::CreateDistributionWithTagsError::InvalidRequiredProtocol(inner) => Error::InvalidRequiredProtocol(inner),
            crate::error::CreateDistributionWithTagsError::InvalidResponseCode(inner) => Error::InvalidResponseCode(inner),
            crate::error::CreateDistributionWithTagsError::InvalidTagging(inner) => Error::InvalidTagging(inner),
            crate::error::CreateDistributionWithTagsError::InvalidTtlOrder(inner) => Error::InvalidTtlOrder(inner),
            crate::error::CreateDistributionWithTagsError::InvalidViewerCertificate(inner) => Error::InvalidViewerCertificate(inner),
            crate::error::CreateDistributionWithTagsError::InvalidWebAclId(inner) => Error::InvalidWebAclId(inner),
            crate::error::CreateDistributionWithTagsError::MissingBody(inner) => Error::MissingBody(inner),
            crate::error::CreateDistributionWithTagsError::NoSuchCachePolicy(inner) => Error::NoSuchCachePolicy(inner),
            crate::error::CreateDistributionWithTagsError::NoSuchContinuousDeploymentPolicy(inner) => Error::NoSuchContinuousDeploymentPolicy(inner),
            crate::error::CreateDistributionWithTagsError::NoSuchFieldLevelEncryptionConfig(inner) => Error::NoSuchFieldLevelEncryptionConfig(inner),
            crate::error::CreateDistributionWithTagsError::NoSuchOrigin(inner) => Error::NoSuchOrigin(inner),
            crate::error::CreateDistributionWithTagsError::NoSuchOriginRequestPolicy(inner) => Error::NoSuchOriginRequestPolicy(inner),
            crate::error::CreateDistributionWithTagsError::NoSuchRealtimeLogConfig(inner) => Error::NoSuchRealtimeLogConfig(inner),
            crate::error::CreateDistributionWithTagsError::NoSuchResponseHeadersPolicy(inner) => Error::NoSuchResponseHeadersPolicy(inner),
            crate::error::CreateDistributionWithTagsError::RealtimeLogConfigOwnerMismatch(inner) => Error::RealtimeLogConfigOwnerMismatch(inner),
            crate::error::CreateDistributionWithTagsError::TooManyCacheBehaviors(inner) => Error::TooManyCacheBehaviors(inner),
            crate::error::CreateDistributionWithTagsError::TooManyCertificates(inner) => Error::TooManyCertificates(inner),
            crate::error::CreateDistributionWithTagsError::TooManyCookieNamesInWhiteList(inner) => Error::TooManyCookieNamesInWhiteList(inner),
            crate::error::CreateDistributionWithTagsError::TooManyDistributionCnamEs(inner) => Error::TooManyDistributionCnamEs(inner),
            crate::error::CreateDistributionWithTagsError::TooManyDistributions(inner) => Error::TooManyDistributions(inner),
            crate::error::CreateDistributionWithTagsError::TooManyDistributionsAssociatedToCachePolicy(inner) => Error::TooManyDistributionsAssociatedToCachePolicy(inner),
            crate::error::CreateDistributionWithTagsError::TooManyDistributionsAssociatedToFieldLevelEncryptionConfig(inner) => Error::TooManyDistributionsAssociatedToFieldLevelEncryptionConfig(inner),
            crate::error::CreateDistributionWithTagsError::TooManyDistributionsAssociatedToKeyGroup(inner) => Error::TooManyDistributionsAssociatedToKeyGroup(inner),
            crate::error::CreateDistributionWithTagsError::TooManyDistributionsAssociatedToOriginRequestPolicy(inner) => Error::TooManyDistributionsAssociatedToOriginRequestPolicy(inner),
            crate::error::CreateDistributionWithTagsError::TooManyDistributionsAssociatedToResponseHeadersPolicy(inner) => Error::TooManyDistributionsAssociatedToResponseHeadersPolicy(inner),
            crate::error::CreateDistributionWithTagsError::TooManyDistributionsWithFunctionAssociations(inner) => Error::TooManyDistributionsWithFunctionAssociations(inner),
            crate::error::CreateDistributionWithTagsError::TooManyDistributionsWithLambdaAssociations(inner) => Error::TooManyDistributionsWithLambdaAssociations(inner),
            crate::error::CreateDistributionWithTagsError::TooManyDistributionsWithSingleFunctionArn(inner) => Error::TooManyDistributionsWithSingleFunctionArn(inner),
            crate::error::CreateDistributionWithTagsError::TooManyFunctionAssociations(inner) => Error::TooManyFunctionAssociations(inner),
            crate::error::CreateDistributionWithTagsError::TooManyHeadersInForwardedValues(inner) => Error::TooManyHeadersInForwardedValues(inner),
            crate::error::CreateDistributionWithTagsError::TooManyKeyGroupsAssociatedToDistribution(inner) => Error::TooManyKeyGroupsAssociatedToDistribution(inner),
            crate::error::CreateDistributionWithTagsError::TooManyLambdaFunctionAssociations(inner) => Error::TooManyLambdaFunctionAssociations(inner),
            crate::error::CreateDistributionWithTagsError::TooManyOriginCustomHeaders(inner) => Error::TooManyOriginCustomHeaders(inner),
            crate::error::CreateDistributionWithTagsError::TooManyOriginGroupsPerDistribution(inner) => Error::TooManyOriginGroupsPerDistribution(inner),
            crate::error::CreateDistributionWithTagsError::TooManyOrigins(inner) => Error::TooManyOrigins(inner),
            crate::error::CreateDistributionWithTagsError::TooManyQueryStringParameters(inner) => Error::TooManyQueryStringParameters(inner),
            crate::error::CreateDistributionWithTagsError::TooManyTrustedSigners(inner) => Error::TooManyTrustedSigners(inner),
            crate::error::CreateDistributionWithTagsError::TrustedKeyGroupDoesNotExist(inner) => Error::TrustedKeyGroupDoesNotExist(inner),
            crate::error::CreateDistributionWithTagsError::TrustedSignerDoesNotExist(inner) => Error::TrustedSignerDoesNotExist(inner),
            crate::error::CreateDistributionWithTagsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<aws_smithy_http::result::SdkError<crate::error::CreateFieldLevelEncryptionConfigError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::error::CreateFieldLevelEncryptionConfigError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::CreateFieldLevelEncryptionConfigError> for Error {
    fn from(err: crate::error::CreateFieldLevelEncryptionConfigError) -> Self {
        match err {
            crate::error::CreateFieldLevelEncryptionConfigError::FieldLevelEncryptionConfigAlreadyExists(inner) => Error::FieldLevelEncryptionConfigAlreadyExists(inner),
            crate::error::CreateFieldLevelEncryptionConfigError::InconsistentQuantities(inner) => Error::InconsistentQuantities(inner),
            crate::error::CreateFieldLevelEncryptionConfigError::InvalidArgument(inner) => Error::InvalidArgument(inner),
            crate::error::CreateFieldLevelEncryptionConfigError::NoSuchFieldLevelEncryptionProfile(inner) => Error::NoSuchFieldLevelEncryptionProfile(inner),
            crate::error::CreateFieldLevelEncryptionConfigError::QueryArgProfileEmpty(inner) => Error::QueryArgProfileEmpty(inner),
            crate::error::CreateFieldLevelEncryptionConfigError::TooManyFieldLevelEncryptionConfigs(inner) => Error::TooManyFieldLevelEncryptionConfigs(inner),
            crate::error::CreateFieldLevelEncryptionConfigError::TooManyFieldLevelEncryptionContentTypeProfiles(inner) => Error::TooManyFieldLevelEncryptionContentTypeProfiles(inner),
            crate::error::CreateFieldLevelEncryptionConfigError::TooManyFieldLevelEncryptionQueryArgProfiles(inner) => Error::TooManyFieldLevelEncryptionQueryArgProfiles(inner),
            crate::error::CreateFieldLevelEncryptionConfigError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<aws_smithy_http::result::SdkError<crate::error::CreateFieldLevelEncryptionProfileError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::error::CreateFieldLevelEncryptionProfileError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::CreateFieldLevelEncryptionProfileError> for Error {
    fn from(err: crate::error::CreateFieldLevelEncryptionProfileError) -> Self {
        match err {
            crate::error::CreateFieldLevelEncryptionProfileError::FieldLevelEncryptionProfileAlreadyExists(inner) => Error::FieldLevelEncryptionProfileAlreadyExists(inner),
            crate::error::CreateFieldLevelEncryptionProfileError::FieldLevelEncryptionProfileSizeExceeded(inner) => Error::FieldLevelEncryptionProfileSizeExceeded(inner),
            crate::error::CreateFieldLevelEncryptionProfileError::InconsistentQuantities(inner) => Error::InconsistentQuantities(inner),
            crate::error::CreateFieldLevelEncryptionProfileError::InvalidArgument(inner) => Error::InvalidArgument(inner),
            crate::error::CreateFieldLevelEncryptionProfileError::NoSuchPublicKey(inner) => Error::NoSuchPublicKey(inner),
            crate::error::CreateFieldLevelEncryptionProfileError::TooManyFieldLevelEncryptionEncryptionEntities(inner) => Error::TooManyFieldLevelEncryptionEncryptionEntities(inner),
            crate::error::CreateFieldLevelEncryptionProfileError::TooManyFieldLevelEncryptionFieldPatterns(inner) => Error::TooManyFieldLevelEncryptionFieldPatterns(inner),
            crate::error::CreateFieldLevelEncryptionProfileError::TooManyFieldLevelEncryptionProfiles(inner) => Error::TooManyFieldLevelEncryptionProfiles(inner),
            crate::error::CreateFieldLevelEncryptionProfileError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::CreateFunctionError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::CreateFunctionError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::CreateFunctionError> for Error {
    fn from(err: crate::error::CreateFunctionError) -> Self {
        match err {
            crate::error::CreateFunctionError::FunctionAlreadyExists(inner) => {
                Error::FunctionAlreadyExists(inner)
            }
            crate::error::CreateFunctionError::FunctionSizeLimitExceeded(inner) => {
                Error::FunctionSizeLimitExceeded(inner)
            }
            crate::error::CreateFunctionError::InvalidArgument(inner) => {
                Error::InvalidArgument(inner)
            }
            crate::error::CreateFunctionError::TooManyFunctions(inner) => {
                Error::TooManyFunctions(inner)
            }
            crate::error::CreateFunctionError::UnsupportedOperation(inner) => {
                Error::UnsupportedOperation(inner)
            }
            crate::error::CreateFunctionError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::CreateInvalidationError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::CreateInvalidationError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::CreateInvalidationError> for Error {
    fn from(err: crate::error::CreateInvalidationError) -> Self {
        match err {
            crate::error::CreateInvalidationError::AccessDenied(inner) => {
                Error::AccessDenied(inner)
            }
            crate::error::CreateInvalidationError::BatchTooLarge(inner) => {
                Error::BatchTooLarge(inner)
            }
            crate::error::CreateInvalidationError::InconsistentQuantities(inner) => {
                Error::InconsistentQuantities(inner)
            }
            crate::error::CreateInvalidationError::InvalidArgument(inner) => {
                Error::InvalidArgument(inner)
            }
            crate::error::CreateInvalidationError::MissingBody(inner) => Error::MissingBody(inner),
            crate::error::CreateInvalidationError::NoSuchDistribution(inner) => {
                Error::NoSuchDistribution(inner)
            }
            crate::error::CreateInvalidationError::TooManyInvalidationsInProgress(inner) => {
                Error::TooManyInvalidationsInProgress(inner)
            }
            crate::error::CreateInvalidationError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::CreateKeyGroupError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::CreateKeyGroupError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::CreateKeyGroupError> for Error {
    fn from(err: crate::error::CreateKeyGroupError) -> Self {
        match err {
            crate::error::CreateKeyGroupError::InvalidArgument(inner) => {
                Error::InvalidArgument(inner)
            }
            crate::error::CreateKeyGroupError::KeyGroupAlreadyExists(inner) => {
                Error::KeyGroupAlreadyExists(inner)
            }
            crate::error::CreateKeyGroupError::TooManyKeyGroups(inner) => {
                Error::TooManyKeyGroups(inner)
            }
            crate::error::CreateKeyGroupError::TooManyPublicKeysInKeyGroup(inner) => {
                Error::TooManyPublicKeysInKeyGroup(inner)
            }
            crate::error::CreateKeyGroupError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::CreateMonitoringSubscriptionError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::CreateMonitoringSubscriptionError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::CreateMonitoringSubscriptionError> for Error {
    fn from(err: crate::error::CreateMonitoringSubscriptionError) -> Self {
        match err {
            crate::error::CreateMonitoringSubscriptionError::AccessDenied(inner) => Error::AccessDenied(inner),
            crate::error::CreateMonitoringSubscriptionError::MonitoringSubscriptionAlreadyExists(inner) => Error::MonitoringSubscriptionAlreadyExists(inner),
            crate::error::CreateMonitoringSubscriptionError::NoSuchDistribution(inner) => Error::NoSuchDistribution(inner),
            crate::error::CreateMonitoringSubscriptionError::UnsupportedOperation(inner) => Error::UnsupportedOperation(inner),
            crate::error::CreateMonitoringSubscriptionError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::CreateOriginAccessControlError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::CreateOriginAccessControlError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::CreateOriginAccessControlError> for Error {
    fn from(err: crate::error::CreateOriginAccessControlError) -> Self {
        match err {
            crate::error::CreateOriginAccessControlError::InvalidArgument(inner) => {
                Error::InvalidArgument(inner)
            }
            crate::error::CreateOriginAccessControlError::OriginAccessControlAlreadyExists(
                inner,
            ) => Error::OriginAccessControlAlreadyExists(inner),
            crate::error::CreateOriginAccessControlError::TooManyOriginAccessControls(inner) => {
                Error::TooManyOriginAccessControls(inner)
            }
            crate::error::CreateOriginAccessControlError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::CreateOriginRequestPolicyError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::CreateOriginRequestPolicyError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::CreateOriginRequestPolicyError> for Error {
    fn from(err: crate::error::CreateOriginRequestPolicyError) -> Self {
        match err {
            crate::error::CreateOriginRequestPolicyError::AccessDenied(inner) => Error::AccessDenied(inner),
            crate::error::CreateOriginRequestPolicyError::InconsistentQuantities(inner) => Error::InconsistentQuantities(inner),
            crate::error::CreateOriginRequestPolicyError::InvalidArgument(inner) => Error::InvalidArgument(inner),
            crate::error::CreateOriginRequestPolicyError::OriginRequestPolicyAlreadyExists(inner) => Error::OriginRequestPolicyAlreadyExists(inner),
            crate::error::CreateOriginRequestPolicyError::TooManyCookiesInOriginRequestPolicy(inner) => Error::TooManyCookiesInOriginRequestPolicy(inner),
            crate::error::CreateOriginRequestPolicyError::TooManyHeadersInOriginRequestPolicy(inner) => Error::TooManyHeadersInOriginRequestPolicy(inner),
            crate::error::CreateOriginRequestPolicyError::TooManyOriginRequestPolicies(inner) => Error::TooManyOriginRequestPolicies(inner),
            crate::error::CreateOriginRequestPolicyError::TooManyQueryStringsInOriginRequestPolicy(inner) => Error::TooManyQueryStringsInOriginRequestPolicy(inner),
            crate::error::CreateOriginRequestPolicyError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::CreatePublicKeyError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::CreatePublicKeyError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::CreatePublicKeyError> for Error {
    fn from(err: crate::error::CreatePublicKeyError) -> Self {
        match err {
            crate::error::CreatePublicKeyError::InvalidArgument(inner) => {
                Error::InvalidArgument(inner)
            }
            crate::error::CreatePublicKeyError::PublicKeyAlreadyExists(inner) => {
                Error::PublicKeyAlreadyExists(inner)
            }
            crate::error::CreatePublicKeyError::TooManyPublicKeys(inner) => {
                Error::TooManyPublicKeys(inner)
            }
            crate::error::CreatePublicKeyError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::CreateRealtimeLogConfigError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::CreateRealtimeLogConfigError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::CreateRealtimeLogConfigError> for Error {
    fn from(err: crate::error::CreateRealtimeLogConfigError) -> Self {
        match err {
            crate::error::CreateRealtimeLogConfigError::AccessDenied(inner) => {
                Error::AccessDenied(inner)
            }
            crate::error::CreateRealtimeLogConfigError::InvalidArgument(inner) => {
                Error::InvalidArgument(inner)
            }
            crate::error::CreateRealtimeLogConfigError::RealtimeLogConfigAlreadyExists(inner) => {
                Error::RealtimeLogConfigAlreadyExists(inner)
            }
            crate::error::CreateRealtimeLogConfigError::TooManyRealtimeLogConfigs(inner) => {
                Error::TooManyRealtimeLogConfigs(inner)
            }
            crate::error::CreateRealtimeLogConfigError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::CreateResponseHeadersPolicyError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::CreateResponseHeadersPolicyError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::CreateResponseHeadersPolicyError> for Error {
    fn from(err: crate::error::CreateResponseHeadersPolicyError) -> Self {
        match err {
            crate::error::CreateResponseHeadersPolicyError::AccessDenied(inner) => Error::AccessDenied(inner),
            crate::error::CreateResponseHeadersPolicyError::InconsistentQuantities(inner) => Error::InconsistentQuantities(inner),
            crate::error::CreateResponseHeadersPolicyError::InvalidArgument(inner) => Error::InvalidArgument(inner),
            crate::error::CreateResponseHeadersPolicyError::ResponseHeadersPolicyAlreadyExists(inner) => Error::ResponseHeadersPolicyAlreadyExists(inner),
            crate::error::CreateResponseHeadersPolicyError::TooLongCspInResponseHeadersPolicy(inner) => Error::TooLongCspInResponseHeadersPolicy(inner),
            crate::error::CreateResponseHeadersPolicyError::TooManyCustomHeadersInResponseHeadersPolicy(inner) => Error::TooManyCustomHeadersInResponseHeadersPolicy(inner),
            crate::error::CreateResponseHeadersPolicyError::TooManyRemoveHeadersInResponseHeadersPolicy(inner) => Error::TooManyRemoveHeadersInResponseHeadersPolicy(inner),
            crate::error::CreateResponseHeadersPolicyError::TooManyResponseHeadersPolicies(inner) => Error::TooManyResponseHeadersPolicies(inner),
            crate::error::CreateResponseHeadersPolicyError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::CreateStreamingDistributionError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::CreateStreamingDistributionError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::CreateStreamingDistributionError> for Error {
    fn from(err: crate::error::CreateStreamingDistributionError) -> Self {
        match err {
            crate::error::CreateStreamingDistributionError::AccessDenied(inner) => {
                Error::AccessDenied(inner)
            }
            crate::error::CreateStreamingDistributionError::CnameAlreadyExists(inner) => {
                Error::CnameAlreadyExists(inner)
            }
            crate::error::CreateStreamingDistributionError::InconsistentQuantities(inner) => {
                Error::InconsistentQuantities(inner)
            }
            crate::error::CreateStreamingDistributionError::InvalidArgument(inner) => {
                Error::InvalidArgument(inner)
            }
            crate::error::CreateStreamingDistributionError::InvalidOrigin(inner) => {
                Error::InvalidOrigin(inner)
            }
            crate::error::CreateStreamingDistributionError::InvalidOriginAccessControl(inner) => {
                Error::InvalidOriginAccessControl(inner)
            }
            crate::error::CreateStreamingDistributionError::InvalidOriginAccessIdentity(inner) => {
                Error::InvalidOriginAccessIdentity(inner)
            }
            crate::error::CreateStreamingDistributionError::MissingBody(inner) => {
                Error::MissingBody(inner)
            }
            crate::error::CreateStreamingDistributionError::StreamingDistributionAlreadyExists(
                inner,
            ) => Error::StreamingDistributionAlreadyExists(inner),
            crate::error::CreateStreamingDistributionError::TooManyStreamingDistributionCnamEs(
                inner,
            ) => Error::TooManyStreamingDistributionCnamEs(inner),
            crate::error::CreateStreamingDistributionError::TooManyStreamingDistributions(
                inner,
            ) => Error::TooManyStreamingDistributions(inner),
            crate::error::CreateStreamingDistributionError::TooManyTrustedSigners(inner) => {
                Error::TooManyTrustedSigners(inner)
            }
            crate::error::CreateStreamingDistributionError::TrustedSignerDoesNotExist(inner) => {
                Error::TrustedSignerDoesNotExist(inner)
            }
            crate::error::CreateStreamingDistributionError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::error::CreateStreamingDistributionWithTagsError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::error::CreateStreamingDistributionWithTagsError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::CreateStreamingDistributionWithTagsError> for Error {
    fn from(err: crate::error::CreateStreamingDistributionWithTagsError) -> Self {
        match err {
            crate::error::CreateStreamingDistributionWithTagsError::AccessDenied(inner) => Error::AccessDenied(inner),
            crate::error::CreateStreamingDistributionWithTagsError::CnameAlreadyExists(inner) => Error::CnameAlreadyExists(inner),
            crate::error::CreateStreamingDistributionWithTagsError::InconsistentQuantities(inner) => Error::InconsistentQuantities(inner),
            crate::error::CreateStreamingDistributionWithTagsError::InvalidArgument(inner) => Error::InvalidArgument(inner),
            crate::error::CreateStreamingDistributionWithTagsError::InvalidOrigin(inner) => Error::InvalidOrigin(inner),
            crate::error::CreateStreamingDistributionWithTagsError::InvalidOriginAccessControl(inner) => Error::InvalidOriginAccessControl(inner),
            crate::error::CreateStreamingDistributionWithTagsError::InvalidOriginAccessIdentity(inner) => Error::InvalidOriginAccessIdentity(inner),
            crate::error::CreateStreamingDistributionWithTagsError::InvalidTagging(inner) => Error::InvalidTagging(inner),
            crate::error::CreateStreamingDistributionWithTagsError::MissingBody(inner) => Error::MissingBody(inner),
            crate::error::CreateStreamingDistributionWithTagsError::StreamingDistributionAlreadyExists(inner) => Error::StreamingDistributionAlreadyExists(inner),
            crate::error::CreateStreamingDistributionWithTagsError::TooManyStreamingDistributionCnamEs(inner) => Error::TooManyStreamingDistributionCnamEs(inner),
            crate::error::CreateStreamingDistributionWithTagsError::TooManyStreamingDistributions(inner) => Error::TooManyStreamingDistributions(inner),
            crate::error::CreateStreamingDistributionWithTagsError::TooManyTrustedSigners(inner) => Error::TooManyTrustedSigners(inner),
            crate::error::CreateStreamingDistributionWithTagsError::TrustedSignerDoesNotExist(inner) => Error::TrustedSignerDoesNotExist(inner),
            crate::error::CreateStreamingDistributionWithTagsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DeleteCachePolicyError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::DeleteCachePolicyError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DeleteCachePolicyError> for Error {
    fn from(err: crate::error::DeleteCachePolicyError) -> Self {
        match err {
            crate::error::DeleteCachePolicyError::AccessDenied(inner) => Error::AccessDenied(inner),
            crate::error::DeleteCachePolicyError::CachePolicyInUse(inner) => {
                Error::CachePolicyInUse(inner)
            }
            crate::error::DeleteCachePolicyError::IllegalDelete(inner) => {
                Error::IllegalDelete(inner)
            }
            crate::error::DeleteCachePolicyError::InvalidIfMatchVersion(inner) => {
                Error::InvalidIfMatchVersion(inner)
            }
            crate::error::DeleteCachePolicyError::NoSuchCachePolicy(inner) => {
                Error::NoSuchCachePolicy(inner)
            }
            crate::error::DeleteCachePolicyError::PreconditionFailed(inner) => {
                Error::PreconditionFailed(inner)
            }
            crate::error::DeleteCachePolicyError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::error::DeleteCloudFrontOriginAccessIdentityError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::error::DeleteCloudFrontOriginAccessIdentityError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DeleteCloudFrontOriginAccessIdentityError> for Error {
    fn from(err: crate::error::DeleteCloudFrontOriginAccessIdentityError) -> Self {
        match err {
            crate::error::DeleteCloudFrontOriginAccessIdentityError::AccessDenied(inner) => Error::AccessDenied(inner),
            crate::error::DeleteCloudFrontOriginAccessIdentityError::CloudFrontOriginAccessIdentityInUse(inner) => Error::CloudFrontOriginAccessIdentityInUse(inner),
            crate::error::DeleteCloudFrontOriginAccessIdentityError::InvalidIfMatchVersion(inner) => Error::InvalidIfMatchVersion(inner),
            crate::error::DeleteCloudFrontOriginAccessIdentityError::NoSuchCloudFrontOriginAccessIdentity(inner) => Error::NoSuchCloudFrontOriginAccessIdentity(inner),
            crate::error::DeleteCloudFrontOriginAccessIdentityError::PreconditionFailed(inner) => Error::PreconditionFailed(inner),
            crate::error::DeleteCloudFrontOriginAccessIdentityError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<aws_smithy_http::result::SdkError<crate::error::DeleteContinuousDeploymentPolicyError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::error::DeleteContinuousDeploymentPolicyError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DeleteContinuousDeploymentPolicyError> for Error {
    fn from(err: crate::error::DeleteContinuousDeploymentPolicyError) -> Self {
        match err {
            crate::error::DeleteContinuousDeploymentPolicyError::AccessDenied(inner) => Error::AccessDenied(inner),
            crate::error::DeleteContinuousDeploymentPolicyError::ContinuousDeploymentPolicyInUse(inner) => Error::ContinuousDeploymentPolicyInUse(inner),
            crate::error::DeleteContinuousDeploymentPolicyError::InvalidArgument(inner) => Error::InvalidArgument(inner),
            crate::error::DeleteContinuousDeploymentPolicyError::InvalidIfMatchVersion(inner) => Error::InvalidIfMatchVersion(inner),
            crate::error::DeleteContinuousDeploymentPolicyError::NoSuchContinuousDeploymentPolicy(inner) => Error::NoSuchContinuousDeploymentPolicy(inner),
            crate::error::DeleteContinuousDeploymentPolicyError::PreconditionFailed(inner) => Error::PreconditionFailed(inner),
            crate::error::DeleteContinuousDeploymentPolicyError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DeleteDistributionError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::DeleteDistributionError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DeleteDistributionError> for Error {
    fn from(err: crate::error::DeleteDistributionError) -> Self {
        match err {
            crate::error::DeleteDistributionError::AccessDenied(inner) => {
                Error::AccessDenied(inner)
            }
            crate::error::DeleteDistributionError::DistributionNotDisabled(inner) => {
                Error::DistributionNotDisabled(inner)
            }
            crate::error::DeleteDistributionError::InvalidIfMatchVersion(inner) => {
                Error::InvalidIfMatchVersion(inner)
            }
            crate::error::DeleteDistributionError::NoSuchDistribution(inner) => {
                Error::NoSuchDistribution(inner)
            }
            crate::error::DeleteDistributionError::PreconditionFailed(inner) => {
                Error::PreconditionFailed(inner)
            }
            crate::error::DeleteDistributionError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<aws_smithy_http::result::SdkError<crate::error::DeleteFieldLevelEncryptionConfigError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::error::DeleteFieldLevelEncryptionConfigError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DeleteFieldLevelEncryptionConfigError> for Error {
    fn from(err: crate::error::DeleteFieldLevelEncryptionConfigError) -> Self {
        match err {
            crate::error::DeleteFieldLevelEncryptionConfigError::AccessDenied(inner) => Error::AccessDenied(inner),
            crate::error::DeleteFieldLevelEncryptionConfigError::FieldLevelEncryptionConfigInUse(inner) => Error::FieldLevelEncryptionConfigInUse(inner),
            crate::error::DeleteFieldLevelEncryptionConfigError::InvalidIfMatchVersion(inner) => Error::InvalidIfMatchVersion(inner),
            crate::error::DeleteFieldLevelEncryptionConfigError::NoSuchFieldLevelEncryptionConfig(inner) => Error::NoSuchFieldLevelEncryptionConfig(inner),
            crate::error::DeleteFieldLevelEncryptionConfigError::PreconditionFailed(inner) => Error::PreconditionFailed(inner),
            crate::error::DeleteFieldLevelEncryptionConfigError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<aws_smithy_http::result::SdkError<crate::error::DeleteFieldLevelEncryptionProfileError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::error::DeleteFieldLevelEncryptionProfileError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DeleteFieldLevelEncryptionProfileError> for Error {
    fn from(err: crate::error::DeleteFieldLevelEncryptionProfileError) -> Self {
        match err {
            crate::error::DeleteFieldLevelEncryptionProfileError::AccessDenied(inner) => Error::AccessDenied(inner),
            crate::error::DeleteFieldLevelEncryptionProfileError::FieldLevelEncryptionProfileInUse(inner) => Error::FieldLevelEncryptionProfileInUse(inner),
            crate::error::DeleteFieldLevelEncryptionProfileError::InvalidIfMatchVersion(inner) => Error::InvalidIfMatchVersion(inner),
            crate::error::DeleteFieldLevelEncryptionProfileError::NoSuchFieldLevelEncryptionProfile(inner) => Error::NoSuchFieldLevelEncryptionProfile(inner),
            crate::error::DeleteFieldLevelEncryptionProfileError::PreconditionFailed(inner) => Error::PreconditionFailed(inner),
            crate::error::DeleteFieldLevelEncryptionProfileError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DeleteFunctionError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::DeleteFunctionError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DeleteFunctionError> for Error {
    fn from(err: crate::error::DeleteFunctionError) -> Self {
        match err {
            crate::error::DeleteFunctionError::FunctionInUse(inner) => Error::FunctionInUse(inner),
            crate::error::DeleteFunctionError::InvalidIfMatchVersion(inner) => {
                Error::InvalidIfMatchVersion(inner)
            }
            crate::error::DeleteFunctionError::NoSuchFunctionExists(inner) => {
                Error::NoSuchFunctionExists(inner)
            }
            crate::error::DeleteFunctionError::PreconditionFailed(inner) => {
                Error::PreconditionFailed(inner)
            }
            crate::error::DeleteFunctionError::UnsupportedOperation(inner) => {
                Error::UnsupportedOperation(inner)
            }
            crate::error::DeleteFunctionError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DeleteKeyGroupError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::DeleteKeyGroupError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DeleteKeyGroupError> for Error {
    fn from(err: crate::error::DeleteKeyGroupError) -> Self {
        match err {
            crate::error::DeleteKeyGroupError::InvalidIfMatchVersion(inner) => {
                Error::InvalidIfMatchVersion(inner)
            }
            crate::error::DeleteKeyGroupError::NoSuchResource(inner) => {
                Error::NoSuchResource(inner)
            }
            crate::error::DeleteKeyGroupError::PreconditionFailed(inner) => {
                Error::PreconditionFailed(inner)
            }
            crate::error::DeleteKeyGroupError::ResourceInUse(inner) => Error::ResourceInUse(inner),
            crate::error::DeleteKeyGroupError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DeleteMonitoringSubscriptionError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::DeleteMonitoringSubscriptionError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DeleteMonitoringSubscriptionError> for Error {
    fn from(err: crate::error::DeleteMonitoringSubscriptionError) -> Self {
        match err {
            crate::error::DeleteMonitoringSubscriptionError::AccessDenied(inner) => {
                Error::AccessDenied(inner)
            }
            crate::error::DeleteMonitoringSubscriptionError::NoSuchDistribution(inner) => {
                Error::NoSuchDistribution(inner)
            }
            crate::error::DeleteMonitoringSubscriptionError::NoSuchMonitoringSubscription(
                inner,
            ) => Error::NoSuchMonitoringSubscription(inner),
            crate::error::DeleteMonitoringSubscriptionError::UnsupportedOperation(inner) => {
                Error::UnsupportedOperation(inner)
            }
            crate::error::DeleteMonitoringSubscriptionError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DeleteOriginAccessControlError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::DeleteOriginAccessControlError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DeleteOriginAccessControlError> for Error {
    fn from(err: crate::error::DeleteOriginAccessControlError) -> Self {
        match err {
            crate::error::DeleteOriginAccessControlError::AccessDenied(inner) => {
                Error::AccessDenied(inner)
            }
            crate::error::DeleteOriginAccessControlError::InvalidIfMatchVersion(inner) => {
                Error::InvalidIfMatchVersion(inner)
            }
            crate::error::DeleteOriginAccessControlError::NoSuchOriginAccessControl(inner) => {
                Error::NoSuchOriginAccessControl(inner)
            }
            crate::error::DeleteOriginAccessControlError::OriginAccessControlInUse(inner) => {
                Error::OriginAccessControlInUse(inner)
            }
            crate::error::DeleteOriginAccessControlError::PreconditionFailed(inner) => {
                Error::PreconditionFailed(inner)
            }
            crate::error::DeleteOriginAccessControlError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DeleteOriginRequestPolicyError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::DeleteOriginRequestPolicyError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DeleteOriginRequestPolicyError> for Error {
    fn from(err: crate::error::DeleteOriginRequestPolicyError) -> Self {
        match err {
            crate::error::DeleteOriginRequestPolicyError::AccessDenied(inner) => {
                Error::AccessDenied(inner)
            }
            crate::error::DeleteOriginRequestPolicyError::IllegalDelete(inner) => {
                Error::IllegalDelete(inner)
            }
            crate::error::DeleteOriginRequestPolicyError::InvalidIfMatchVersion(inner) => {
                Error::InvalidIfMatchVersion(inner)
            }
            crate::error::DeleteOriginRequestPolicyError::NoSuchOriginRequestPolicy(inner) => {
                Error::NoSuchOriginRequestPolicy(inner)
            }
            crate::error::DeleteOriginRequestPolicyError::OriginRequestPolicyInUse(inner) => {
                Error::OriginRequestPolicyInUse(inner)
            }
            crate::error::DeleteOriginRequestPolicyError::PreconditionFailed(inner) => {
                Error::PreconditionFailed(inner)
            }
            crate::error::DeleteOriginRequestPolicyError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DeletePublicKeyError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::DeletePublicKeyError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DeletePublicKeyError> for Error {
    fn from(err: crate::error::DeletePublicKeyError) -> Self {
        match err {
            crate::error::DeletePublicKeyError::AccessDenied(inner) => Error::AccessDenied(inner),
            crate::error::DeletePublicKeyError::InvalidIfMatchVersion(inner) => {
                Error::InvalidIfMatchVersion(inner)
            }
            crate::error::DeletePublicKeyError::NoSuchPublicKey(inner) => {
                Error::NoSuchPublicKey(inner)
            }
            crate::error::DeletePublicKeyError::PreconditionFailed(inner) => {
                Error::PreconditionFailed(inner)
            }
            crate::error::DeletePublicKeyError::PublicKeyInUse(inner) => {
                Error::PublicKeyInUse(inner)
            }
            crate::error::DeletePublicKeyError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DeleteRealtimeLogConfigError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::DeleteRealtimeLogConfigError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DeleteRealtimeLogConfigError> for Error {
    fn from(err: crate::error::DeleteRealtimeLogConfigError) -> Self {
        match err {
            crate::error::DeleteRealtimeLogConfigError::AccessDenied(inner) => {
                Error::AccessDenied(inner)
            }
            crate::error::DeleteRealtimeLogConfigError::InvalidArgument(inner) => {
                Error::InvalidArgument(inner)
            }
            crate::error::DeleteRealtimeLogConfigError::NoSuchRealtimeLogConfig(inner) => {
                Error::NoSuchRealtimeLogConfig(inner)
            }
            crate::error::DeleteRealtimeLogConfigError::RealtimeLogConfigInUse(inner) => {
                Error::RealtimeLogConfigInUse(inner)
            }
            crate::error::DeleteRealtimeLogConfigError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DeleteResponseHeadersPolicyError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::DeleteResponseHeadersPolicyError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DeleteResponseHeadersPolicyError> for Error {
    fn from(err: crate::error::DeleteResponseHeadersPolicyError) -> Self {
        match err {
            crate::error::DeleteResponseHeadersPolicyError::AccessDenied(inner) => {
                Error::AccessDenied(inner)
            }
            crate::error::DeleteResponseHeadersPolicyError::IllegalDelete(inner) => {
                Error::IllegalDelete(inner)
            }
            crate::error::DeleteResponseHeadersPolicyError::InvalidIfMatchVersion(inner) => {
                Error::InvalidIfMatchVersion(inner)
            }
            crate::error::DeleteResponseHeadersPolicyError::NoSuchResponseHeadersPolicy(inner) => {
                Error::NoSuchResponseHeadersPolicy(inner)
            }
            crate::error::DeleteResponseHeadersPolicyError::PreconditionFailed(inner) => {
                Error::PreconditionFailed(inner)
            }
            crate::error::DeleteResponseHeadersPolicyError::ResponseHeadersPolicyInUse(inner) => {
                Error::ResponseHeadersPolicyInUse(inner)
            }
            crate::error::DeleteResponseHeadersPolicyError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DeleteStreamingDistributionError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::DeleteStreamingDistributionError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DeleteStreamingDistributionError> for Error {
    fn from(err: crate::error::DeleteStreamingDistributionError) -> Self {
        match err {
            crate::error::DeleteStreamingDistributionError::AccessDenied(inner) => {
                Error::AccessDenied(inner)
            }
            crate::error::DeleteStreamingDistributionError::InvalidIfMatchVersion(inner) => {
                Error::InvalidIfMatchVersion(inner)
            }
            crate::error::DeleteStreamingDistributionError::NoSuchStreamingDistribution(inner) => {
                Error::NoSuchStreamingDistribution(inner)
            }
            crate::error::DeleteStreamingDistributionError::PreconditionFailed(inner) => {
                Error::PreconditionFailed(inner)
            }
            crate::error::DeleteStreamingDistributionError::StreamingDistributionNotDisabled(
                inner,
            ) => Error::StreamingDistributionNotDisabled(inner),
            crate::error::DeleteStreamingDistributionError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DescribeFunctionError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::DescribeFunctionError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DescribeFunctionError> for Error {
    fn from(err: crate::error::DescribeFunctionError) -> Self {
        match err {
            crate::error::DescribeFunctionError::NoSuchFunctionExists(inner) => {
                Error::NoSuchFunctionExists(inner)
            }
            crate::error::DescribeFunctionError::UnsupportedOperation(inner) => {
                Error::UnsupportedOperation(inner)
            }
            crate::error::DescribeFunctionError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetCachePolicyError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::GetCachePolicyError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::GetCachePolicyError> for Error {
    fn from(err: crate::error::GetCachePolicyError) -> Self {
        match err {
            crate::error::GetCachePolicyError::AccessDenied(inner) => Error::AccessDenied(inner),
            crate::error::GetCachePolicyError::NoSuchCachePolicy(inner) => {
                Error::NoSuchCachePolicy(inner)
            }
            crate::error::GetCachePolicyError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetCachePolicyConfigError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::GetCachePolicyConfigError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::GetCachePolicyConfigError> for Error {
    fn from(err: crate::error::GetCachePolicyConfigError) -> Self {
        match err {
            crate::error::GetCachePolicyConfigError::AccessDenied(inner) => {
                Error::AccessDenied(inner)
            }
            crate::error::GetCachePolicyConfigError::NoSuchCachePolicy(inner) => {
                Error::NoSuchCachePolicy(inner)
            }
            crate::error::GetCachePolicyConfigError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<aws_smithy_http::result::SdkError<crate::error::GetCloudFrontOriginAccessIdentityError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::error::GetCloudFrontOriginAccessIdentityError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::GetCloudFrontOriginAccessIdentityError> for Error {
    fn from(err: crate::error::GetCloudFrontOriginAccessIdentityError) -> Self {
        match err {
            crate::error::GetCloudFrontOriginAccessIdentityError::AccessDenied(inner) => Error::AccessDenied(inner),
            crate::error::GetCloudFrontOriginAccessIdentityError::NoSuchCloudFrontOriginAccessIdentity(inner) => Error::NoSuchCloudFrontOriginAccessIdentity(inner),
            crate::error::GetCloudFrontOriginAccessIdentityError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::error::GetCloudFrontOriginAccessIdentityConfigError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::error::GetCloudFrontOriginAccessIdentityConfigError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::GetCloudFrontOriginAccessIdentityConfigError> for Error {
    fn from(err: crate::error::GetCloudFrontOriginAccessIdentityConfigError) -> Self {
        match err {
            crate::error::GetCloudFrontOriginAccessIdentityConfigError::AccessDenied(inner) => Error::AccessDenied(inner),
            crate::error::GetCloudFrontOriginAccessIdentityConfigError::NoSuchCloudFrontOriginAccessIdentity(inner) => Error::NoSuchCloudFrontOriginAccessIdentity(inner),
            crate::error::GetCloudFrontOriginAccessIdentityConfigError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetContinuousDeploymentPolicyError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::GetContinuousDeploymentPolicyError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::GetContinuousDeploymentPolicyError> for Error {
    fn from(err: crate::error::GetContinuousDeploymentPolicyError) -> Self {
        match err {
            crate::error::GetContinuousDeploymentPolicyError::AccessDenied(inner) => {
                Error::AccessDenied(inner)
            }
            crate::error::GetContinuousDeploymentPolicyError::NoSuchContinuousDeploymentPolicy(
                inner,
            ) => Error::NoSuchContinuousDeploymentPolicy(inner),
            crate::error::GetContinuousDeploymentPolicyError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::error::GetContinuousDeploymentPolicyConfigError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::error::GetContinuousDeploymentPolicyConfigError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::GetContinuousDeploymentPolicyConfigError> for Error {
    fn from(err: crate::error::GetContinuousDeploymentPolicyConfigError) -> Self {
        match err {
            crate::error::GetContinuousDeploymentPolicyConfigError::AccessDenied(inner) => Error::AccessDenied(inner),
            crate::error::GetContinuousDeploymentPolicyConfigError::NoSuchContinuousDeploymentPolicy(inner) => Error::NoSuchContinuousDeploymentPolicy(inner),
            crate::error::GetContinuousDeploymentPolicyConfigError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetDistributionError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::GetDistributionError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::GetDistributionError> for Error {
    fn from(err: crate::error::GetDistributionError) -> Self {
        match err {
            crate::error::GetDistributionError::AccessDenied(inner) => Error::AccessDenied(inner),
            crate::error::GetDistributionError::NoSuchDistribution(inner) => {
                Error::NoSuchDistribution(inner)
            }
            crate::error::GetDistributionError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetDistributionConfigError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::GetDistributionConfigError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::GetDistributionConfigError> for Error {
    fn from(err: crate::error::GetDistributionConfigError) -> Self {
        match err {
            crate::error::GetDistributionConfigError::AccessDenied(inner) => {
                Error::AccessDenied(inner)
            }
            crate::error::GetDistributionConfigError::NoSuchDistribution(inner) => {
                Error::NoSuchDistribution(inner)
            }
            crate::error::GetDistributionConfigError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetFieldLevelEncryptionError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::GetFieldLevelEncryptionError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::GetFieldLevelEncryptionError> for Error {
    fn from(err: crate::error::GetFieldLevelEncryptionError) -> Self {
        match err {
            crate::error::GetFieldLevelEncryptionError::AccessDenied(inner) => {
                Error::AccessDenied(inner)
            }
            crate::error::GetFieldLevelEncryptionError::NoSuchFieldLevelEncryptionConfig(inner) => {
                Error::NoSuchFieldLevelEncryptionConfig(inner)
            }
            crate::error::GetFieldLevelEncryptionError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetFieldLevelEncryptionConfigError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::GetFieldLevelEncryptionConfigError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::GetFieldLevelEncryptionConfigError> for Error {
    fn from(err: crate::error::GetFieldLevelEncryptionConfigError) -> Self {
        match err {
            crate::error::GetFieldLevelEncryptionConfigError::AccessDenied(inner) => {
                Error::AccessDenied(inner)
            }
            crate::error::GetFieldLevelEncryptionConfigError::NoSuchFieldLevelEncryptionConfig(
                inner,
            ) => Error::NoSuchFieldLevelEncryptionConfig(inner),
            crate::error::GetFieldLevelEncryptionConfigError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R>
    From<aws_smithy_http::result::SdkError<crate::error::GetFieldLevelEncryptionProfileError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::error::GetFieldLevelEncryptionProfileError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::GetFieldLevelEncryptionProfileError> for Error {
    fn from(err: crate::error::GetFieldLevelEncryptionProfileError) -> Self {
        match err {
            crate::error::GetFieldLevelEncryptionProfileError::AccessDenied(inner) => Error::AccessDenied(inner),
            crate::error::GetFieldLevelEncryptionProfileError::NoSuchFieldLevelEncryptionProfile(inner) => Error::NoSuchFieldLevelEncryptionProfile(inner),
            crate::error::GetFieldLevelEncryptionProfileError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::error::GetFieldLevelEncryptionProfileConfigError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::error::GetFieldLevelEncryptionProfileConfigError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::GetFieldLevelEncryptionProfileConfigError> for Error {
    fn from(err: crate::error::GetFieldLevelEncryptionProfileConfigError) -> Self {
        match err {
            crate::error::GetFieldLevelEncryptionProfileConfigError::AccessDenied(inner) => Error::AccessDenied(inner),
            crate::error::GetFieldLevelEncryptionProfileConfigError::NoSuchFieldLevelEncryptionProfile(inner) => Error::NoSuchFieldLevelEncryptionProfile(inner),
            crate::error::GetFieldLevelEncryptionProfileConfigError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetFunctionError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::GetFunctionError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::GetFunctionError> for Error {
    fn from(err: crate::error::GetFunctionError) -> Self {
        match err {
            crate::error::GetFunctionError::NoSuchFunctionExists(inner) => {
                Error::NoSuchFunctionExists(inner)
            }
            crate::error::GetFunctionError::UnsupportedOperation(inner) => {
                Error::UnsupportedOperation(inner)
            }
            crate::error::GetFunctionError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetInvalidationError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::GetInvalidationError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::GetInvalidationError> for Error {
    fn from(err: crate::error::GetInvalidationError) -> Self {
        match err {
            crate::error::GetInvalidationError::AccessDenied(inner) => Error::AccessDenied(inner),
            crate::error::GetInvalidationError::NoSuchDistribution(inner) => {
                Error::NoSuchDistribution(inner)
            }
            crate::error::GetInvalidationError::NoSuchInvalidation(inner) => {
                Error::NoSuchInvalidation(inner)
            }
            crate::error::GetInvalidationError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetKeyGroupError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::GetKeyGroupError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::GetKeyGroupError> for Error {
    fn from(err: crate::error::GetKeyGroupError) -> Self {
        match err {
            crate::error::GetKeyGroupError::NoSuchResource(inner) => Error::NoSuchResource(inner),
            crate::error::GetKeyGroupError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetKeyGroupConfigError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::GetKeyGroupConfigError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::GetKeyGroupConfigError> for Error {
    fn from(err: crate::error::GetKeyGroupConfigError) -> Self {
        match err {
            crate::error::GetKeyGroupConfigError::NoSuchResource(inner) => {
                Error::NoSuchResource(inner)
            }
            crate::error::GetKeyGroupConfigError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetMonitoringSubscriptionError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::GetMonitoringSubscriptionError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::GetMonitoringSubscriptionError> for Error {
    fn from(err: crate::error::GetMonitoringSubscriptionError) -> Self {
        match err {
            crate::error::GetMonitoringSubscriptionError::AccessDenied(inner) => {
                Error::AccessDenied(inner)
            }
            crate::error::GetMonitoringSubscriptionError::NoSuchDistribution(inner) => {
                Error::NoSuchDistribution(inner)
            }
            crate::error::GetMonitoringSubscriptionError::NoSuchMonitoringSubscription(inner) => {
                Error::NoSuchMonitoringSubscription(inner)
            }
            crate::error::GetMonitoringSubscriptionError::UnsupportedOperation(inner) => {
                Error::UnsupportedOperation(inner)
            }
            crate::error::GetMonitoringSubscriptionError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetOriginAccessControlError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::GetOriginAccessControlError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::GetOriginAccessControlError> for Error {
    fn from(err: crate::error::GetOriginAccessControlError) -> Self {
        match err {
            crate::error::GetOriginAccessControlError::AccessDenied(inner) => {
                Error::AccessDenied(inner)
            }
            crate::error::GetOriginAccessControlError::NoSuchOriginAccessControl(inner) => {
                Error::NoSuchOriginAccessControl(inner)
            }
            crate::error::GetOriginAccessControlError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetOriginAccessControlConfigError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::GetOriginAccessControlConfigError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::GetOriginAccessControlConfigError> for Error {
    fn from(err: crate::error::GetOriginAccessControlConfigError) -> Self {
        match err {
            crate::error::GetOriginAccessControlConfigError::AccessDenied(inner) => {
                Error::AccessDenied(inner)
            }
            crate::error::GetOriginAccessControlConfigError::NoSuchOriginAccessControl(inner) => {
                Error::NoSuchOriginAccessControl(inner)
            }
            crate::error::GetOriginAccessControlConfigError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetOriginRequestPolicyError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::GetOriginRequestPolicyError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::GetOriginRequestPolicyError> for Error {
    fn from(err: crate::error::GetOriginRequestPolicyError) -> Self {
        match err {
            crate::error::GetOriginRequestPolicyError::AccessDenied(inner) => {
                Error::AccessDenied(inner)
            }
            crate::error::GetOriginRequestPolicyError::NoSuchOriginRequestPolicy(inner) => {
                Error::NoSuchOriginRequestPolicy(inner)
            }
            crate::error::GetOriginRequestPolicyError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetOriginRequestPolicyConfigError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::GetOriginRequestPolicyConfigError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::GetOriginRequestPolicyConfigError> for Error {
    fn from(err: crate::error::GetOriginRequestPolicyConfigError) -> Self {
        match err {
            crate::error::GetOriginRequestPolicyConfigError::AccessDenied(inner) => {
                Error::AccessDenied(inner)
            }
            crate::error::GetOriginRequestPolicyConfigError::NoSuchOriginRequestPolicy(inner) => {
                Error::NoSuchOriginRequestPolicy(inner)
            }
            crate::error::GetOriginRequestPolicyConfigError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetPublicKeyError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::GetPublicKeyError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::GetPublicKeyError> for Error {
    fn from(err: crate::error::GetPublicKeyError) -> Self {
        match err {
            crate::error::GetPublicKeyError::AccessDenied(inner) => Error::AccessDenied(inner),
            crate::error::GetPublicKeyError::NoSuchPublicKey(inner) => {
                Error::NoSuchPublicKey(inner)
            }
            crate::error::GetPublicKeyError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetPublicKeyConfigError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::GetPublicKeyConfigError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::GetPublicKeyConfigError> for Error {
    fn from(err: crate::error::GetPublicKeyConfigError) -> Self {
        match err {
            crate::error::GetPublicKeyConfigError::AccessDenied(inner) => {
                Error::AccessDenied(inner)
            }
            crate::error::GetPublicKeyConfigError::NoSuchPublicKey(inner) => {
                Error::NoSuchPublicKey(inner)
            }
            crate::error::GetPublicKeyConfigError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetRealtimeLogConfigError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::GetRealtimeLogConfigError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::GetRealtimeLogConfigError> for Error {
    fn from(err: crate::error::GetRealtimeLogConfigError) -> Self {
        match err {
            crate::error::GetRealtimeLogConfigError::AccessDenied(inner) => {
                Error::AccessDenied(inner)
            }
            crate::error::GetRealtimeLogConfigError::InvalidArgument(inner) => {
                Error::InvalidArgument(inner)
            }
            crate::error::GetRealtimeLogConfigError::NoSuchRealtimeLogConfig(inner) => {
                Error::NoSuchRealtimeLogConfig(inner)
            }
            crate::error::GetRealtimeLogConfigError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetResponseHeadersPolicyError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::GetResponseHeadersPolicyError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::GetResponseHeadersPolicyError> for Error {
    fn from(err: crate::error::GetResponseHeadersPolicyError) -> Self {
        match err {
            crate::error::GetResponseHeadersPolicyError::AccessDenied(inner) => {
                Error::AccessDenied(inner)
            }
            crate::error::GetResponseHeadersPolicyError::NoSuchResponseHeadersPolicy(inner) => {
                Error::NoSuchResponseHeadersPolicy(inner)
            }
            crate::error::GetResponseHeadersPolicyError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R>
    From<aws_smithy_http::result::SdkError<crate::error::GetResponseHeadersPolicyConfigError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::error::GetResponseHeadersPolicyConfigError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::GetResponseHeadersPolicyConfigError> for Error {
    fn from(err: crate::error::GetResponseHeadersPolicyConfigError) -> Self {
        match err {
            crate::error::GetResponseHeadersPolicyConfigError::AccessDenied(inner) => {
                Error::AccessDenied(inner)
            }
            crate::error::GetResponseHeadersPolicyConfigError::NoSuchResponseHeadersPolicy(
                inner,
            ) => Error::NoSuchResponseHeadersPolicy(inner),
            crate::error::GetResponseHeadersPolicyConfigError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetStreamingDistributionError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::GetStreamingDistributionError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::GetStreamingDistributionError> for Error {
    fn from(err: crate::error::GetStreamingDistributionError) -> Self {
        match err {
            crate::error::GetStreamingDistributionError::AccessDenied(inner) => {
                Error::AccessDenied(inner)
            }
            crate::error::GetStreamingDistributionError::NoSuchStreamingDistribution(inner) => {
                Error::NoSuchStreamingDistribution(inner)
            }
            crate::error::GetStreamingDistributionError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R>
    From<aws_smithy_http::result::SdkError<crate::error::GetStreamingDistributionConfigError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::error::GetStreamingDistributionConfigError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::GetStreamingDistributionConfigError> for Error {
    fn from(err: crate::error::GetStreamingDistributionConfigError) -> Self {
        match err {
            crate::error::GetStreamingDistributionConfigError::AccessDenied(inner) => {
                Error::AccessDenied(inner)
            }
            crate::error::GetStreamingDistributionConfigError::NoSuchStreamingDistribution(
                inner,
            ) => Error::NoSuchStreamingDistribution(inner),
            crate::error::GetStreamingDistributionConfigError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ListCachePoliciesError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::ListCachePoliciesError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ListCachePoliciesError> for Error {
    fn from(err: crate::error::ListCachePoliciesError) -> Self {
        match err {
            crate::error::ListCachePoliciesError::AccessDenied(inner) => Error::AccessDenied(inner),
            crate::error::ListCachePoliciesError::InvalidArgument(inner) => {
                Error::InvalidArgument(inner)
            }
            crate::error::ListCachePoliciesError::NoSuchCachePolicy(inner) => {
                Error::NoSuchCachePolicy(inner)
            }
            crate::error::ListCachePoliciesError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::error::ListCloudFrontOriginAccessIdentitiesError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::error::ListCloudFrontOriginAccessIdentitiesError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ListCloudFrontOriginAccessIdentitiesError> for Error {
    fn from(err: crate::error::ListCloudFrontOriginAccessIdentitiesError) -> Self {
        match err {
            crate::error::ListCloudFrontOriginAccessIdentitiesError::InvalidArgument(inner) => {
                Error::InvalidArgument(inner)
            }
            crate::error::ListCloudFrontOriginAccessIdentitiesError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ListConflictingAliasesError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::ListConflictingAliasesError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ListConflictingAliasesError> for Error {
    fn from(err: crate::error::ListConflictingAliasesError) -> Self {
        match err {
            crate::error::ListConflictingAliasesError::InvalidArgument(inner) => {
                Error::InvalidArgument(inner)
            }
            crate::error::ListConflictingAliasesError::NoSuchDistribution(inner) => {
                Error::NoSuchDistribution(inner)
            }
            crate::error::ListConflictingAliasesError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<aws_smithy_http::result::SdkError<crate::error::ListContinuousDeploymentPoliciesError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::error::ListContinuousDeploymentPoliciesError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ListContinuousDeploymentPoliciesError> for Error {
    fn from(err: crate::error::ListContinuousDeploymentPoliciesError) -> Self {
        match err {
            crate::error::ListContinuousDeploymentPoliciesError::AccessDenied(inner) => Error::AccessDenied(inner),
            crate::error::ListContinuousDeploymentPoliciesError::InvalidArgument(inner) => Error::InvalidArgument(inner),
            crate::error::ListContinuousDeploymentPoliciesError::NoSuchContinuousDeploymentPolicy(inner) => Error::NoSuchContinuousDeploymentPolicy(inner),
            crate::error::ListContinuousDeploymentPoliciesError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ListDistributionsError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::ListDistributionsError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ListDistributionsError> for Error {
    fn from(err: crate::error::ListDistributionsError) -> Self {
        match err {
            crate::error::ListDistributionsError::InvalidArgument(inner) => {
                Error::InvalidArgument(inner)
            }
            crate::error::ListDistributionsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<aws_smithy_http::result::SdkError<crate::error::ListDistributionsByCachePolicyIdError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::error::ListDistributionsByCachePolicyIdError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ListDistributionsByCachePolicyIdError> for Error {
    fn from(err: crate::error::ListDistributionsByCachePolicyIdError) -> Self {
        match err {
            crate::error::ListDistributionsByCachePolicyIdError::AccessDenied(inner) => {
                Error::AccessDenied(inner)
            }
            crate::error::ListDistributionsByCachePolicyIdError::InvalidArgument(inner) => {
                Error::InvalidArgument(inner)
            }
            crate::error::ListDistributionsByCachePolicyIdError::NoSuchCachePolicy(inner) => {
                Error::NoSuchCachePolicy(inner)
            }
            crate::error::ListDistributionsByCachePolicyIdError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ListDistributionsByKeyGroupError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::ListDistributionsByKeyGroupError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ListDistributionsByKeyGroupError> for Error {
    fn from(err: crate::error::ListDistributionsByKeyGroupError) -> Self {
        match err {
            crate::error::ListDistributionsByKeyGroupError::InvalidArgument(inner) => {
                Error::InvalidArgument(inner)
            }
            crate::error::ListDistributionsByKeyGroupError::NoSuchResource(inner) => {
                Error::NoSuchResource(inner)
            }
            crate::error::ListDistributionsByKeyGroupError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::error::ListDistributionsByOriginRequestPolicyIdError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::error::ListDistributionsByOriginRequestPolicyIdError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ListDistributionsByOriginRequestPolicyIdError> for Error {
    fn from(err: crate::error::ListDistributionsByOriginRequestPolicyIdError) -> Self {
        match err {
            crate::error::ListDistributionsByOriginRequestPolicyIdError::AccessDenied(inner) => Error::AccessDenied(inner),
            crate::error::ListDistributionsByOriginRequestPolicyIdError::InvalidArgument(inner) => Error::InvalidArgument(inner),
            crate::error::ListDistributionsByOriginRequestPolicyIdError::NoSuchOriginRequestPolicy(inner) => Error::NoSuchOriginRequestPolicy(inner),
            crate::error::ListDistributionsByOriginRequestPolicyIdError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::error::ListDistributionsByRealtimeLogConfigError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::error::ListDistributionsByRealtimeLogConfigError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ListDistributionsByRealtimeLogConfigError> for Error {
    fn from(err: crate::error::ListDistributionsByRealtimeLogConfigError) -> Self {
        match err {
            crate::error::ListDistributionsByRealtimeLogConfigError::InvalidArgument(inner) => {
                Error::InvalidArgument(inner)
            }
            crate::error::ListDistributionsByRealtimeLogConfigError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::error::ListDistributionsByResponseHeadersPolicyIdError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::error::ListDistributionsByResponseHeadersPolicyIdError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ListDistributionsByResponseHeadersPolicyIdError> for Error {
    fn from(err: crate::error::ListDistributionsByResponseHeadersPolicyIdError) -> Self {
        match err {
            crate::error::ListDistributionsByResponseHeadersPolicyIdError::AccessDenied(inner) => Error::AccessDenied(inner),
            crate::error::ListDistributionsByResponseHeadersPolicyIdError::InvalidArgument(inner) => Error::InvalidArgument(inner),
            crate::error::ListDistributionsByResponseHeadersPolicyIdError::NoSuchResponseHeadersPolicy(inner) => Error::NoSuchResponseHeadersPolicy(inner),
            crate::error::ListDistributionsByResponseHeadersPolicyIdError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ListDistributionsByWebACLIdError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::ListDistributionsByWebACLIdError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ListDistributionsByWebACLIdError> for Error {
    fn from(err: crate::error::ListDistributionsByWebACLIdError) -> Self {
        match err {
            crate::error::ListDistributionsByWebACLIdError::InvalidArgument(inner) => {
                Error::InvalidArgument(inner)
            }
            crate::error::ListDistributionsByWebACLIdError::InvalidWebAclId(inner) => {
                Error::InvalidWebAclId(inner)
            }
            crate::error::ListDistributionsByWebACLIdError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R>
    From<aws_smithy_http::result::SdkError<crate::error::ListFieldLevelEncryptionConfigsError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::error::ListFieldLevelEncryptionConfigsError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ListFieldLevelEncryptionConfigsError> for Error {
    fn from(err: crate::error::ListFieldLevelEncryptionConfigsError) -> Self {
        match err {
            crate::error::ListFieldLevelEncryptionConfigsError::InvalidArgument(inner) => {
                Error::InvalidArgument(inner)
            }
            crate::error::ListFieldLevelEncryptionConfigsError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R>
    From<aws_smithy_http::result::SdkError<crate::error::ListFieldLevelEncryptionProfilesError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::error::ListFieldLevelEncryptionProfilesError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ListFieldLevelEncryptionProfilesError> for Error {
    fn from(err: crate::error::ListFieldLevelEncryptionProfilesError) -> Self {
        match err {
            crate::error::ListFieldLevelEncryptionProfilesError::InvalidArgument(inner) => {
                Error::InvalidArgument(inner)
            }
            crate::error::ListFieldLevelEncryptionProfilesError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ListFunctionsError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::ListFunctionsError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ListFunctionsError> for Error {
    fn from(err: crate::error::ListFunctionsError) -> Self {
        match err {
            crate::error::ListFunctionsError::InvalidArgument(inner) => {
                Error::InvalidArgument(inner)
            }
            crate::error::ListFunctionsError::UnsupportedOperation(inner) => {
                Error::UnsupportedOperation(inner)
            }
            crate::error::ListFunctionsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ListInvalidationsError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::ListInvalidationsError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ListInvalidationsError> for Error {
    fn from(err: crate::error::ListInvalidationsError) -> Self {
        match err {
            crate::error::ListInvalidationsError::AccessDenied(inner) => Error::AccessDenied(inner),
            crate::error::ListInvalidationsError::InvalidArgument(inner) => {
                Error::InvalidArgument(inner)
            }
            crate::error::ListInvalidationsError::NoSuchDistribution(inner) => {
                Error::NoSuchDistribution(inner)
            }
            crate::error::ListInvalidationsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ListKeyGroupsError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::ListKeyGroupsError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ListKeyGroupsError> for Error {
    fn from(err: crate::error::ListKeyGroupsError) -> Self {
        match err {
            crate::error::ListKeyGroupsError::InvalidArgument(inner) => {
                Error::InvalidArgument(inner)
            }
            crate::error::ListKeyGroupsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ListOriginAccessControlsError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::ListOriginAccessControlsError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ListOriginAccessControlsError> for Error {
    fn from(err: crate::error::ListOriginAccessControlsError) -> Self {
        match err {
            crate::error::ListOriginAccessControlsError::InvalidArgument(inner) => {
                Error::InvalidArgument(inner)
            }
            crate::error::ListOriginAccessControlsError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ListOriginRequestPoliciesError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::ListOriginRequestPoliciesError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ListOriginRequestPoliciesError> for Error {
    fn from(err: crate::error::ListOriginRequestPoliciesError) -> Self {
        match err {
            crate::error::ListOriginRequestPoliciesError::AccessDenied(inner) => {
                Error::AccessDenied(inner)
            }
            crate::error::ListOriginRequestPoliciesError::InvalidArgument(inner) => {
                Error::InvalidArgument(inner)
            }
            crate::error::ListOriginRequestPoliciesError::NoSuchOriginRequestPolicy(inner) => {
                Error::NoSuchOriginRequestPolicy(inner)
            }
            crate::error::ListOriginRequestPoliciesError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ListPublicKeysError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::ListPublicKeysError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ListPublicKeysError> for Error {
    fn from(err: crate::error::ListPublicKeysError) -> Self {
        match err {
            crate::error::ListPublicKeysError::InvalidArgument(inner) => {
                Error::InvalidArgument(inner)
            }
            crate::error::ListPublicKeysError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ListRealtimeLogConfigsError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::ListRealtimeLogConfigsError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ListRealtimeLogConfigsError> for Error {
    fn from(err: crate::error::ListRealtimeLogConfigsError) -> Self {
        match err {
            crate::error::ListRealtimeLogConfigsError::AccessDenied(inner) => {
                Error::AccessDenied(inner)
            }
            crate::error::ListRealtimeLogConfigsError::InvalidArgument(inner) => {
                Error::InvalidArgument(inner)
            }
            crate::error::ListRealtimeLogConfigsError::NoSuchRealtimeLogConfig(inner) => {
                Error::NoSuchRealtimeLogConfig(inner)
            }
            crate::error::ListRealtimeLogConfigsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ListResponseHeadersPoliciesError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::ListResponseHeadersPoliciesError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ListResponseHeadersPoliciesError> for Error {
    fn from(err: crate::error::ListResponseHeadersPoliciesError) -> Self {
        match err {
            crate::error::ListResponseHeadersPoliciesError::AccessDenied(inner) => {
                Error::AccessDenied(inner)
            }
            crate::error::ListResponseHeadersPoliciesError::InvalidArgument(inner) => {
                Error::InvalidArgument(inner)
            }
            crate::error::ListResponseHeadersPoliciesError::NoSuchResponseHeadersPolicy(inner) => {
                Error::NoSuchResponseHeadersPolicy(inner)
            }
            crate::error::ListResponseHeadersPoliciesError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ListStreamingDistributionsError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::ListStreamingDistributionsError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ListStreamingDistributionsError> for Error {
    fn from(err: crate::error::ListStreamingDistributionsError) -> Self {
        match err {
            crate::error::ListStreamingDistributionsError::InvalidArgument(inner) => {
                Error::InvalidArgument(inner)
            }
            crate::error::ListStreamingDistributionsError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ListTagsForResourceError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::ListTagsForResourceError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ListTagsForResourceError> for Error {
    fn from(err: crate::error::ListTagsForResourceError) -> Self {
        match err {
            crate::error::ListTagsForResourceError::AccessDenied(inner) => {
                Error::AccessDenied(inner)
            }
            crate::error::ListTagsForResourceError::InvalidArgument(inner) => {
                Error::InvalidArgument(inner)
            }
            crate::error::ListTagsForResourceError::InvalidTagging(inner) => {
                Error::InvalidTagging(inner)
            }
            crate::error::ListTagsForResourceError::NoSuchResource(inner) => {
                Error::NoSuchResource(inner)
            }
            crate::error::ListTagsForResourceError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::PublishFunctionError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::PublishFunctionError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::PublishFunctionError> for Error {
    fn from(err: crate::error::PublishFunctionError) -> Self {
        match err {
            crate::error::PublishFunctionError::InvalidArgument(inner) => {
                Error::InvalidArgument(inner)
            }
            crate::error::PublishFunctionError::InvalidIfMatchVersion(inner) => {
                Error::InvalidIfMatchVersion(inner)
            }
            crate::error::PublishFunctionError::NoSuchFunctionExists(inner) => {
                Error::NoSuchFunctionExists(inner)
            }
            crate::error::PublishFunctionError::PreconditionFailed(inner) => {
                Error::PreconditionFailed(inner)
            }
            crate::error::PublishFunctionError::UnsupportedOperation(inner) => {
                Error::UnsupportedOperation(inner)
            }
            crate::error::PublishFunctionError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::TagResourceError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::TagResourceError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::TagResourceError> for Error {
    fn from(err: crate::error::TagResourceError) -> Self {
        match err {
            crate::error::TagResourceError::AccessDenied(inner) => Error::AccessDenied(inner),
            crate::error::TagResourceError::InvalidArgument(inner) => Error::InvalidArgument(inner),
            crate::error::TagResourceError::InvalidTagging(inner) => Error::InvalidTagging(inner),
            crate::error::TagResourceError::NoSuchResource(inner) => Error::NoSuchResource(inner),
            crate::error::TagResourceError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::TestFunctionError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::TestFunctionError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::TestFunctionError> for Error {
    fn from(err: crate::error::TestFunctionError) -> Self {
        match err {
            crate::error::TestFunctionError::InvalidArgument(inner) => {
                Error::InvalidArgument(inner)
            }
            crate::error::TestFunctionError::InvalidIfMatchVersion(inner) => {
                Error::InvalidIfMatchVersion(inner)
            }
            crate::error::TestFunctionError::NoSuchFunctionExists(inner) => {
                Error::NoSuchFunctionExists(inner)
            }
            crate::error::TestFunctionError::TestFunctionFailed(inner) => {
                Error::TestFunctionFailed(inner)
            }
            crate::error::TestFunctionError::UnsupportedOperation(inner) => {
                Error::UnsupportedOperation(inner)
            }
            crate::error::TestFunctionError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::UntagResourceError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::UntagResourceError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::UntagResourceError> for Error {
    fn from(err: crate::error::UntagResourceError) -> Self {
        match err {
            crate::error::UntagResourceError::AccessDenied(inner) => Error::AccessDenied(inner),
            crate::error::UntagResourceError::InvalidArgument(inner) => {
                Error::InvalidArgument(inner)
            }
            crate::error::UntagResourceError::InvalidTagging(inner) => Error::InvalidTagging(inner),
            crate::error::UntagResourceError::NoSuchResource(inner) => Error::NoSuchResource(inner),
            crate::error::UntagResourceError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::UpdateCachePolicyError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::UpdateCachePolicyError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::UpdateCachePolicyError> for Error {
    fn from(err: crate::error::UpdateCachePolicyError) -> Self {
        match err {
            crate::error::UpdateCachePolicyError::AccessDenied(inner) => Error::AccessDenied(inner),
            crate::error::UpdateCachePolicyError::CachePolicyAlreadyExists(inner) => {
                Error::CachePolicyAlreadyExists(inner)
            }
            crate::error::UpdateCachePolicyError::IllegalUpdate(inner) => {
                Error::IllegalUpdate(inner)
            }
            crate::error::UpdateCachePolicyError::InconsistentQuantities(inner) => {
                Error::InconsistentQuantities(inner)
            }
            crate::error::UpdateCachePolicyError::InvalidArgument(inner) => {
                Error::InvalidArgument(inner)
            }
            crate::error::UpdateCachePolicyError::InvalidIfMatchVersion(inner) => {
                Error::InvalidIfMatchVersion(inner)
            }
            crate::error::UpdateCachePolicyError::NoSuchCachePolicy(inner) => {
                Error::NoSuchCachePolicy(inner)
            }
            crate::error::UpdateCachePolicyError::PreconditionFailed(inner) => {
                Error::PreconditionFailed(inner)
            }
            crate::error::UpdateCachePolicyError::TooManyCookiesInCachePolicy(inner) => {
                Error::TooManyCookiesInCachePolicy(inner)
            }
            crate::error::UpdateCachePolicyError::TooManyHeadersInCachePolicy(inner) => {
                Error::TooManyHeadersInCachePolicy(inner)
            }
            crate::error::UpdateCachePolicyError::TooManyQueryStringsInCachePolicy(inner) => {
                Error::TooManyQueryStringsInCachePolicy(inner)
            }
            crate::error::UpdateCachePolicyError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::error::UpdateCloudFrontOriginAccessIdentityError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::error::UpdateCloudFrontOriginAccessIdentityError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::UpdateCloudFrontOriginAccessIdentityError> for Error {
    fn from(err: crate::error::UpdateCloudFrontOriginAccessIdentityError) -> Self {
        match err {
            crate::error::UpdateCloudFrontOriginAccessIdentityError::AccessDenied(inner) => Error::AccessDenied(inner),
            crate::error::UpdateCloudFrontOriginAccessIdentityError::IllegalUpdate(inner) => Error::IllegalUpdate(inner),
            crate::error::UpdateCloudFrontOriginAccessIdentityError::InconsistentQuantities(inner) => Error::InconsistentQuantities(inner),
            crate::error::UpdateCloudFrontOriginAccessIdentityError::InvalidArgument(inner) => Error::InvalidArgument(inner),
            crate::error::UpdateCloudFrontOriginAccessIdentityError::InvalidIfMatchVersion(inner) => Error::InvalidIfMatchVersion(inner),
            crate::error::UpdateCloudFrontOriginAccessIdentityError::MissingBody(inner) => Error::MissingBody(inner),
            crate::error::UpdateCloudFrontOriginAccessIdentityError::NoSuchCloudFrontOriginAccessIdentity(inner) => Error::NoSuchCloudFrontOriginAccessIdentity(inner),
            crate::error::UpdateCloudFrontOriginAccessIdentityError::PreconditionFailed(inner) => Error::PreconditionFailed(inner),
            crate::error::UpdateCloudFrontOriginAccessIdentityError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<aws_smithy_http::result::SdkError<crate::error::UpdateContinuousDeploymentPolicyError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::error::UpdateContinuousDeploymentPolicyError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::UpdateContinuousDeploymentPolicyError> for Error {
    fn from(err: crate::error::UpdateContinuousDeploymentPolicyError) -> Self {
        match err {
            crate::error::UpdateContinuousDeploymentPolicyError::AccessDenied(inner) => Error::AccessDenied(inner),
            crate::error::UpdateContinuousDeploymentPolicyError::InconsistentQuantities(inner) => Error::InconsistentQuantities(inner),
            crate::error::UpdateContinuousDeploymentPolicyError::InvalidArgument(inner) => Error::InvalidArgument(inner),
            crate::error::UpdateContinuousDeploymentPolicyError::InvalidIfMatchVersion(inner) => Error::InvalidIfMatchVersion(inner),
            crate::error::UpdateContinuousDeploymentPolicyError::NoSuchContinuousDeploymentPolicy(inner) => Error::NoSuchContinuousDeploymentPolicy(inner),
            crate::error::UpdateContinuousDeploymentPolicyError::PreconditionFailed(inner) => Error::PreconditionFailed(inner),
            crate::error::UpdateContinuousDeploymentPolicyError::StagingDistributionInUse(inner) => Error::StagingDistributionInUse(inner),
            crate::error::UpdateContinuousDeploymentPolicyError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::UpdateDistributionError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::UpdateDistributionError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::UpdateDistributionError> for Error {
    fn from(err: crate::error::UpdateDistributionError) -> Self {
        match err {
            crate::error::UpdateDistributionError::AccessDenied(inner) => Error::AccessDenied(inner),
            crate::error::UpdateDistributionError::CnameAlreadyExists(inner) => Error::CnameAlreadyExists(inner),
            crate::error::UpdateDistributionError::ContinuousDeploymentPolicyInUse(inner) => Error::ContinuousDeploymentPolicyInUse(inner),
            crate::error::UpdateDistributionError::IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior(inner) => Error::IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior(inner),
            crate::error::UpdateDistributionError::IllegalOriginAccessConfiguration(inner) => Error::IllegalOriginAccessConfiguration(inner),
            crate::error::UpdateDistributionError::IllegalUpdate(inner) => Error::IllegalUpdate(inner),
            crate::error::UpdateDistributionError::InconsistentQuantities(inner) => Error::InconsistentQuantities(inner),
            crate::error::UpdateDistributionError::InvalidArgument(inner) => Error::InvalidArgument(inner),
            crate::error::UpdateDistributionError::InvalidDefaultRootObject(inner) => Error::InvalidDefaultRootObject(inner),
            crate::error::UpdateDistributionError::InvalidDomainNameForOriginAccessControl(inner) => Error::InvalidDomainNameForOriginAccessControl(inner),
            crate::error::UpdateDistributionError::InvalidErrorCode(inner) => Error::InvalidErrorCode(inner),
            crate::error::UpdateDistributionError::InvalidForwardCookies(inner) => Error::InvalidForwardCookies(inner),
            crate::error::UpdateDistributionError::InvalidFunctionAssociation(inner) => Error::InvalidFunctionAssociation(inner),
            crate::error::UpdateDistributionError::InvalidGeoRestrictionParameter(inner) => Error::InvalidGeoRestrictionParameter(inner),
            crate::error::UpdateDistributionError::InvalidHeadersForS3Origin(inner) => Error::InvalidHeadersForS3Origin(inner),
            crate::error::UpdateDistributionError::InvalidIfMatchVersion(inner) => Error::InvalidIfMatchVersion(inner),
            crate::error::UpdateDistributionError::InvalidLambdaFunctionAssociation(inner) => Error::InvalidLambdaFunctionAssociation(inner),
            crate::error::UpdateDistributionError::InvalidLocationCode(inner) => Error::InvalidLocationCode(inner),
            crate::error::UpdateDistributionError::InvalidMinimumProtocolVersion(inner) => Error::InvalidMinimumProtocolVersion(inner),
            crate::error::UpdateDistributionError::InvalidOriginAccessControl(inner) => Error::InvalidOriginAccessControl(inner),
            crate::error::UpdateDistributionError::InvalidOriginAccessIdentity(inner) => Error::InvalidOriginAccessIdentity(inner),
            crate::error::UpdateDistributionError::InvalidOriginKeepaliveTimeout(inner) => Error::InvalidOriginKeepaliveTimeout(inner),
            crate::error::UpdateDistributionError::InvalidOriginReadTimeout(inner) => Error::InvalidOriginReadTimeout(inner),
            crate::error::UpdateDistributionError::InvalidQueryStringParameters(inner) => Error::InvalidQueryStringParameters(inner),
            crate::error::UpdateDistributionError::InvalidRelativePath(inner) => Error::InvalidRelativePath(inner),
            crate::error::UpdateDistributionError::InvalidRequiredProtocol(inner) => Error::InvalidRequiredProtocol(inner),
            crate::error::UpdateDistributionError::InvalidResponseCode(inner) => Error::InvalidResponseCode(inner),
            crate::error::UpdateDistributionError::InvalidTtlOrder(inner) => Error::InvalidTtlOrder(inner),
            crate::error::UpdateDistributionError::InvalidViewerCertificate(inner) => Error::InvalidViewerCertificate(inner),
            crate::error::UpdateDistributionError::InvalidWebAclId(inner) => Error::InvalidWebAclId(inner),
            crate::error::UpdateDistributionError::MissingBody(inner) => Error::MissingBody(inner),
            crate::error::UpdateDistributionError::NoSuchCachePolicy(inner) => Error::NoSuchCachePolicy(inner),
            crate::error::UpdateDistributionError::NoSuchContinuousDeploymentPolicy(inner) => Error::NoSuchContinuousDeploymentPolicy(inner),
            crate::error::UpdateDistributionError::NoSuchDistribution(inner) => Error::NoSuchDistribution(inner),
            crate::error::UpdateDistributionError::NoSuchFieldLevelEncryptionConfig(inner) => Error::NoSuchFieldLevelEncryptionConfig(inner),
            crate::error::UpdateDistributionError::NoSuchOrigin(inner) => Error::NoSuchOrigin(inner),
            crate::error::UpdateDistributionError::NoSuchOriginRequestPolicy(inner) => Error::NoSuchOriginRequestPolicy(inner),
            crate::error::UpdateDistributionError::NoSuchRealtimeLogConfig(inner) => Error::NoSuchRealtimeLogConfig(inner),
            crate::error::UpdateDistributionError::NoSuchResponseHeadersPolicy(inner) => Error::NoSuchResponseHeadersPolicy(inner),
            crate::error::UpdateDistributionError::PreconditionFailed(inner) => Error::PreconditionFailed(inner),
            crate::error::UpdateDistributionError::RealtimeLogConfigOwnerMismatch(inner) => Error::RealtimeLogConfigOwnerMismatch(inner),
            crate::error::UpdateDistributionError::StagingDistributionInUse(inner) => Error::StagingDistributionInUse(inner),
            crate::error::UpdateDistributionError::TooManyCacheBehaviors(inner) => Error::TooManyCacheBehaviors(inner),
            crate::error::UpdateDistributionError::TooManyCertificates(inner) => Error::TooManyCertificates(inner),
            crate::error::UpdateDistributionError::TooManyCookieNamesInWhiteList(inner) => Error::TooManyCookieNamesInWhiteList(inner),
            crate::error::UpdateDistributionError::TooManyDistributionCnamEs(inner) => Error::TooManyDistributionCnamEs(inner),
            crate::error::UpdateDistributionError::TooManyDistributionsAssociatedToCachePolicy(inner) => Error::TooManyDistributionsAssociatedToCachePolicy(inner),
            crate::error::UpdateDistributionError::TooManyDistributionsAssociatedToFieldLevelEncryptionConfig(inner) => Error::TooManyDistributionsAssociatedToFieldLevelEncryptionConfig(inner),
            crate::error::UpdateDistributionError::TooManyDistributionsAssociatedToKeyGroup(inner) => Error::TooManyDistributionsAssociatedToKeyGroup(inner),
            crate::error::UpdateDistributionError::TooManyDistributionsAssociatedToOriginRequestPolicy(inner) => Error::TooManyDistributionsAssociatedToOriginRequestPolicy(inner),
            crate::error::UpdateDistributionError::TooManyDistributionsAssociatedToResponseHeadersPolicy(inner) => Error::TooManyDistributionsAssociatedToResponseHeadersPolicy(inner),
            crate::error::UpdateDistributionError::TooManyDistributionsWithFunctionAssociations(inner) => Error::TooManyDistributionsWithFunctionAssociations(inner),
            crate::error::UpdateDistributionError::TooManyDistributionsWithLambdaAssociations(inner) => Error::TooManyDistributionsWithLambdaAssociations(inner),
            crate::error::UpdateDistributionError::TooManyDistributionsWithSingleFunctionArn(inner) => Error::TooManyDistributionsWithSingleFunctionArn(inner),
            crate::error::UpdateDistributionError::TooManyFunctionAssociations(inner) => Error::TooManyFunctionAssociations(inner),
            crate::error::UpdateDistributionError::TooManyHeadersInForwardedValues(inner) => Error::TooManyHeadersInForwardedValues(inner),
            crate::error::UpdateDistributionError::TooManyKeyGroupsAssociatedToDistribution(inner) => Error::TooManyKeyGroupsAssociatedToDistribution(inner),
            crate::error::UpdateDistributionError::TooManyLambdaFunctionAssociations(inner) => Error::TooManyLambdaFunctionAssociations(inner),
            crate::error::UpdateDistributionError::TooManyOriginCustomHeaders(inner) => Error::TooManyOriginCustomHeaders(inner),
            crate::error::UpdateDistributionError::TooManyOriginGroupsPerDistribution(inner) => Error::TooManyOriginGroupsPerDistribution(inner),
            crate::error::UpdateDistributionError::TooManyOrigins(inner) => Error::TooManyOrigins(inner),
            crate::error::UpdateDistributionError::TooManyQueryStringParameters(inner) => Error::TooManyQueryStringParameters(inner),
            crate::error::UpdateDistributionError::TooManyTrustedSigners(inner) => Error::TooManyTrustedSigners(inner),
            crate::error::UpdateDistributionError::TrustedKeyGroupDoesNotExist(inner) => Error::TrustedKeyGroupDoesNotExist(inner),
            crate::error::UpdateDistributionError::TrustedSignerDoesNotExist(inner) => Error::TrustedSignerDoesNotExist(inner),
            crate::error::UpdateDistributionError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::error::UpdateDistributionWithStagingConfigError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::error::UpdateDistributionWithStagingConfigError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::UpdateDistributionWithStagingConfigError> for Error {
    fn from(err: crate::error::UpdateDistributionWithStagingConfigError) -> Self {
        match err {
            crate::error::UpdateDistributionWithStagingConfigError::AccessDenied(inner) => Error::AccessDenied(inner),
            crate::error::UpdateDistributionWithStagingConfigError::CnameAlreadyExists(inner) => Error::CnameAlreadyExists(inner),
            crate::error::UpdateDistributionWithStagingConfigError::IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior(inner) => Error::IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior(inner),
            crate::error::UpdateDistributionWithStagingConfigError::IllegalUpdate(inner) => Error::IllegalUpdate(inner),
            crate::error::UpdateDistributionWithStagingConfigError::InconsistentQuantities(inner) => Error::InconsistentQuantities(inner),
            crate::error::UpdateDistributionWithStagingConfigError::InvalidArgument(inner) => Error::InvalidArgument(inner),
            crate::error::UpdateDistributionWithStagingConfigError::InvalidDefaultRootObject(inner) => Error::InvalidDefaultRootObject(inner),
            crate::error::UpdateDistributionWithStagingConfigError::InvalidErrorCode(inner) => Error::InvalidErrorCode(inner),
            crate::error::UpdateDistributionWithStagingConfigError::InvalidForwardCookies(inner) => Error::InvalidForwardCookies(inner),
            crate::error::UpdateDistributionWithStagingConfigError::InvalidFunctionAssociation(inner) => Error::InvalidFunctionAssociation(inner),
            crate::error::UpdateDistributionWithStagingConfigError::InvalidGeoRestrictionParameter(inner) => Error::InvalidGeoRestrictionParameter(inner),
            crate::error::UpdateDistributionWithStagingConfigError::InvalidHeadersForS3Origin(inner) => Error::InvalidHeadersForS3Origin(inner),
            crate::error::UpdateDistributionWithStagingConfigError::InvalidIfMatchVersion(inner) => Error::InvalidIfMatchVersion(inner),
            crate::error::UpdateDistributionWithStagingConfigError::InvalidLambdaFunctionAssociation(inner) => Error::InvalidLambdaFunctionAssociation(inner),
            crate::error::UpdateDistributionWithStagingConfigError::InvalidLocationCode(inner) => Error::InvalidLocationCode(inner),
            crate::error::UpdateDistributionWithStagingConfigError::InvalidMinimumProtocolVersion(inner) => Error::InvalidMinimumProtocolVersion(inner),
            crate::error::UpdateDistributionWithStagingConfigError::InvalidOriginAccessControl(inner) => Error::InvalidOriginAccessControl(inner),
            crate::error::UpdateDistributionWithStagingConfigError::InvalidOriginAccessIdentity(inner) => Error::InvalidOriginAccessIdentity(inner),
            crate::error::UpdateDistributionWithStagingConfigError::InvalidOriginKeepaliveTimeout(inner) => Error::InvalidOriginKeepaliveTimeout(inner),
            crate::error::UpdateDistributionWithStagingConfigError::InvalidOriginReadTimeout(inner) => Error::InvalidOriginReadTimeout(inner),
            crate::error::UpdateDistributionWithStagingConfigError::InvalidQueryStringParameters(inner) => Error::InvalidQueryStringParameters(inner),
            crate::error::UpdateDistributionWithStagingConfigError::InvalidRelativePath(inner) => Error::InvalidRelativePath(inner),
            crate::error::UpdateDistributionWithStagingConfigError::InvalidRequiredProtocol(inner) => Error::InvalidRequiredProtocol(inner),
            crate::error::UpdateDistributionWithStagingConfigError::InvalidResponseCode(inner) => Error::InvalidResponseCode(inner),
            crate::error::UpdateDistributionWithStagingConfigError::InvalidTtlOrder(inner) => Error::InvalidTtlOrder(inner),
            crate::error::UpdateDistributionWithStagingConfigError::InvalidViewerCertificate(inner) => Error::InvalidViewerCertificate(inner),
            crate::error::UpdateDistributionWithStagingConfigError::InvalidWebAclId(inner) => Error::InvalidWebAclId(inner),
            crate::error::UpdateDistributionWithStagingConfigError::MissingBody(inner) => Error::MissingBody(inner),
            crate::error::UpdateDistributionWithStagingConfigError::NoSuchCachePolicy(inner) => Error::NoSuchCachePolicy(inner),
            crate::error::UpdateDistributionWithStagingConfigError::NoSuchDistribution(inner) => Error::NoSuchDistribution(inner),
            crate::error::UpdateDistributionWithStagingConfigError::NoSuchFieldLevelEncryptionConfig(inner) => Error::NoSuchFieldLevelEncryptionConfig(inner),
            crate::error::UpdateDistributionWithStagingConfigError::NoSuchOrigin(inner) => Error::NoSuchOrigin(inner),
            crate::error::UpdateDistributionWithStagingConfigError::NoSuchOriginRequestPolicy(inner) => Error::NoSuchOriginRequestPolicy(inner),
            crate::error::UpdateDistributionWithStagingConfigError::NoSuchRealtimeLogConfig(inner) => Error::NoSuchRealtimeLogConfig(inner),
            crate::error::UpdateDistributionWithStagingConfigError::NoSuchResponseHeadersPolicy(inner) => Error::NoSuchResponseHeadersPolicy(inner),
            crate::error::UpdateDistributionWithStagingConfigError::PreconditionFailed(inner) => Error::PreconditionFailed(inner),
            crate::error::UpdateDistributionWithStagingConfigError::RealtimeLogConfigOwnerMismatch(inner) => Error::RealtimeLogConfigOwnerMismatch(inner),
            crate::error::UpdateDistributionWithStagingConfigError::TooManyCacheBehaviors(inner) => Error::TooManyCacheBehaviors(inner),
            crate::error::UpdateDistributionWithStagingConfigError::TooManyCertificates(inner) => Error::TooManyCertificates(inner),
            crate::error::UpdateDistributionWithStagingConfigError::TooManyCookieNamesInWhiteList(inner) => Error::TooManyCookieNamesInWhiteList(inner),
            crate::error::UpdateDistributionWithStagingConfigError::TooManyDistributionCnamEs(inner) => Error::TooManyDistributionCnamEs(inner),
            crate::error::UpdateDistributionWithStagingConfigError::TooManyDistributionsAssociatedToCachePolicy(inner) => Error::TooManyDistributionsAssociatedToCachePolicy(inner),
            crate::error::UpdateDistributionWithStagingConfigError::TooManyDistributionsAssociatedToFieldLevelEncryptionConfig(inner) => Error::TooManyDistributionsAssociatedToFieldLevelEncryptionConfig(inner),
            crate::error::UpdateDistributionWithStagingConfigError::TooManyDistributionsAssociatedToKeyGroup(inner) => Error::TooManyDistributionsAssociatedToKeyGroup(inner),
            crate::error::UpdateDistributionWithStagingConfigError::TooManyDistributionsAssociatedToOriginRequestPolicy(inner) => Error::TooManyDistributionsAssociatedToOriginRequestPolicy(inner),
            crate::error::UpdateDistributionWithStagingConfigError::TooManyDistributionsAssociatedToResponseHeadersPolicy(inner) => Error::TooManyDistributionsAssociatedToResponseHeadersPolicy(inner),
            crate::error::UpdateDistributionWithStagingConfigError::TooManyDistributionsWithFunctionAssociations(inner) => Error::TooManyDistributionsWithFunctionAssociations(inner),
            crate::error::UpdateDistributionWithStagingConfigError::TooManyDistributionsWithLambdaAssociations(inner) => Error::TooManyDistributionsWithLambdaAssociations(inner),
            crate::error::UpdateDistributionWithStagingConfigError::TooManyDistributionsWithSingleFunctionArn(inner) => Error::TooManyDistributionsWithSingleFunctionArn(inner),
            crate::error::UpdateDistributionWithStagingConfigError::TooManyFunctionAssociations(inner) => Error::TooManyFunctionAssociations(inner),
            crate::error::UpdateDistributionWithStagingConfigError::TooManyHeadersInForwardedValues(inner) => Error::TooManyHeadersInForwardedValues(inner),
            crate::error::UpdateDistributionWithStagingConfigError::TooManyKeyGroupsAssociatedToDistribution(inner) => Error::TooManyKeyGroupsAssociatedToDistribution(inner),
            crate::error::UpdateDistributionWithStagingConfigError::TooManyLambdaFunctionAssociations(inner) => Error::TooManyLambdaFunctionAssociations(inner),
            crate::error::UpdateDistributionWithStagingConfigError::TooManyOriginCustomHeaders(inner) => Error::TooManyOriginCustomHeaders(inner),
            crate::error::UpdateDistributionWithStagingConfigError::TooManyOriginGroupsPerDistribution(inner) => Error::TooManyOriginGroupsPerDistribution(inner),
            crate::error::UpdateDistributionWithStagingConfigError::TooManyOrigins(inner) => Error::TooManyOrigins(inner),
            crate::error::UpdateDistributionWithStagingConfigError::TooManyQueryStringParameters(inner) => Error::TooManyQueryStringParameters(inner),
            crate::error::UpdateDistributionWithStagingConfigError::TooManyTrustedSigners(inner) => Error::TooManyTrustedSigners(inner),
            crate::error::UpdateDistributionWithStagingConfigError::TrustedKeyGroupDoesNotExist(inner) => Error::TrustedKeyGroupDoesNotExist(inner),
            crate::error::UpdateDistributionWithStagingConfigError::TrustedSignerDoesNotExist(inner) => Error::TrustedSignerDoesNotExist(inner),
            crate::error::UpdateDistributionWithStagingConfigError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<aws_smithy_http::result::SdkError<crate::error::UpdateFieldLevelEncryptionConfigError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::error::UpdateFieldLevelEncryptionConfigError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::UpdateFieldLevelEncryptionConfigError> for Error {
    fn from(err: crate::error::UpdateFieldLevelEncryptionConfigError) -> Self {
        match err {
            crate::error::UpdateFieldLevelEncryptionConfigError::AccessDenied(inner) => Error::AccessDenied(inner),
            crate::error::UpdateFieldLevelEncryptionConfigError::IllegalUpdate(inner) => Error::IllegalUpdate(inner),
            crate::error::UpdateFieldLevelEncryptionConfigError::InconsistentQuantities(inner) => Error::InconsistentQuantities(inner),
            crate::error::UpdateFieldLevelEncryptionConfigError::InvalidArgument(inner) => Error::InvalidArgument(inner),
            crate::error::UpdateFieldLevelEncryptionConfigError::InvalidIfMatchVersion(inner) => Error::InvalidIfMatchVersion(inner),
            crate::error::UpdateFieldLevelEncryptionConfigError::NoSuchFieldLevelEncryptionConfig(inner) => Error::NoSuchFieldLevelEncryptionConfig(inner),
            crate::error::UpdateFieldLevelEncryptionConfigError::NoSuchFieldLevelEncryptionProfile(inner) => Error::NoSuchFieldLevelEncryptionProfile(inner),
            crate::error::UpdateFieldLevelEncryptionConfigError::PreconditionFailed(inner) => Error::PreconditionFailed(inner),
            crate::error::UpdateFieldLevelEncryptionConfigError::QueryArgProfileEmpty(inner) => Error::QueryArgProfileEmpty(inner),
            crate::error::UpdateFieldLevelEncryptionConfigError::TooManyFieldLevelEncryptionContentTypeProfiles(inner) => Error::TooManyFieldLevelEncryptionContentTypeProfiles(inner),
            crate::error::UpdateFieldLevelEncryptionConfigError::TooManyFieldLevelEncryptionQueryArgProfiles(inner) => Error::TooManyFieldLevelEncryptionQueryArgProfiles(inner),
            crate::error::UpdateFieldLevelEncryptionConfigError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<aws_smithy_http::result::SdkError<crate::error::UpdateFieldLevelEncryptionProfileError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::error::UpdateFieldLevelEncryptionProfileError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::UpdateFieldLevelEncryptionProfileError> for Error {
    fn from(err: crate::error::UpdateFieldLevelEncryptionProfileError) -> Self {
        match err {
            crate::error::UpdateFieldLevelEncryptionProfileError::AccessDenied(inner) => Error::AccessDenied(inner),
            crate::error::UpdateFieldLevelEncryptionProfileError::FieldLevelEncryptionProfileAlreadyExists(inner) => Error::FieldLevelEncryptionProfileAlreadyExists(inner),
            crate::error::UpdateFieldLevelEncryptionProfileError::FieldLevelEncryptionProfileSizeExceeded(inner) => Error::FieldLevelEncryptionProfileSizeExceeded(inner),
            crate::error::UpdateFieldLevelEncryptionProfileError::IllegalUpdate(inner) => Error::IllegalUpdate(inner),
            crate::error::UpdateFieldLevelEncryptionProfileError::InconsistentQuantities(inner) => Error::InconsistentQuantities(inner),
            crate::error::UpdateFieldLevelEncryptionProfileError::InvalidArgument(inner) => Error::InvalidArgument(inner),
            crate::error::UpdateFieldLevelEncryptionProfileError::InvalidIfMatchVersion(inner) => Error::InvalidIfMatchVersion(inner),
            crate::error::UpdateFieldLevelEncryptionProfileError::NoSuchFieldLevelEncryptionProfile(inner) => Error::NoSuchFieldLevelEncryptionProfile(inner),
            crate::error::UpdateFieldLevelEncryptionProfileError::NoSuchPublicKey(inner) => Error::NoSuchPublicKey(inner),
            crate::error::UpdateFieldLevelEncryptionProfileError::PreconditionFailed(inner) => Error::PreconditionFailed(inner),
            crate::error::UpdateFieldLevelEncryptionProfileError::TooManyFieldLevelEncryptionEncryptionEntities(inner) => Error::TooManyFieldLevelEncryptionEncryptionEntities(inner),
            crate::error::UpdateFieldLevelEncryptionProfileError::TooManyFieldLevelEncryptionFieldPatterns(inner) => Error::TooManyFieldLevelEncryptionFieldPatterns(inner),
            crate::error::UpdateFieldLevelEncryptionProfileError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::UpdateFunctionError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::UpdateFunctionError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::UpdateFunctionError> for Error {
    fn from(err: crate::error::UpdateFunctionError) -> Self {
        match err {
            crate::error::UpdateFunctionError::FunctionSizeLimitExceeded(inner) => {
                Error::FunctionSizeLimitExceeded(inner)
            }
            crate::error::UpdateFunctionError::InvalidArgument(inner) => {
                Error::InvalidArgument(inner)
            }
            crate::error::UpdateFunctionError::InvalidIfMatchVersion(inner) => {
                Error::InvalidIfMatchVersion(inner)
            }
            crate::error::UpdateFunctionError::NoSuchFunctionExists(inner) => {
                Error::NoSuchFunctionExists(inner)
            }
            crate::error::UpdateFunctionError::PreconditionFailed(inner) => {
                Error::PreconditionFailed(inner)
            }
            crate::error::UpdateFunctionError::UnsupportedOperation(inner) => {
                Error::UnsupportedOperation(inner)
            }
            crate::error::UpdateFunctionError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::UpdateKeyGroupError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::UpdateKeyGroupError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::UpdateKeyGroupError> for Error {
    fn from(err: crate::error::UpdateKeyGroupError) -> Self {
        match err {
            crate::error::UpdateKeyGroupError::InvalidArgument(inner) => {
                Error::InvalidArgument(inner)
            }
            crate::error::UpdateKeyGroupError::InvalidIfMatchVersion(inner) => {
                Error::InvalidIfMatchVersion(inner)
            }
            crate::error::UpdateKeyGroupError::KeyGroupAlreadyExists(inner) => {
                Error::KeyGroupAlreadyExists(inner)
            }
            crate::error::UpdateKeyGroupError::NoSuchResource(inner) => {
                Error::NoSuchResource(inner)
            }
            crate::error::UpdateKeyGroupError::PreconditionFailed(inner) => {
                Error::PreconditionFailed(inner)
            }
            crate::error::UpdateKeyGroupError::TooManyPublicKeysInKeyGroup(inner) => {
                Error::TooManyPublicKeysInKeyGroup(inner)
            }
            crate::error::UpdateKeyGroupError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::UpdateOriginAccessControlError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::UpdateOriginAccessControlError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::UpdateOriginAccessControlError> for Error {
    fn from(err: crate::error::UpdateOriginAccessControlError) -> Self {
        match err {
            crate::error::UpdateOriginAccessControlError::AccessDenied(inner) => {
                Error::AccessDenied(inner)
            }
            crate::error::UpdateOriginAccessControlError::IllegalUpdate(inner) => {
                Error::IllegalUpdate(inner)
            }
            crate::error::UpdateOriginAccessControlError::InvalidArgument(inner) => {
                Error::InvalidArgument(inner)
            }
            crate::error::UpdateOriginAccessControlError::InvalidIfMatchVersion(inner) => {
                Error::InvalidIfMatchVersion(inner)
            }
            crate::error::UpdateOriginAccessControlError::NoSuchOriginAccessControl(inner) => {
                Error::NoSuchOriginAccessControl(inner)
            }
            crate::error::UpdateOriginAccessControlError::OriginAccessControlAlreadyExists(
                inner,
            ) => Error::OriginAccessControlAlreadyExists(inner),
            crate::error::UpdateOriginAccessControlError::PreconditionFailed(inner) => {
                Error::PreconditionFailed(inner)
            }
            crate::error::UpdateOriginAccessControlError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::UpdateOriginRequestPolicyError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::UpdateOriginRequestPolicyError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::UpdateOriginRequestPolicyError> for Error {
    fn from(err: crate::error::UpdateOriginRequestPolicyError) -> Self {
        match err {
            crate::error::UpdateOriginRequestPolicyError::AccessDenied(inner) => Error::AccessDenied(inner),
            crate::error::UpdateOriginRequestPolicyError::IllegalUpdate(inner) => Error::IllegalUpdate(inner),
            crate::error::UpdateOriginRequestPolicyError::InconsistentQuantities(inner) => Error::InconsistentQuantities(inner),
            crate::error::UpdateOriginRequestPolicyError::InvalidArgument(inner) => Error::InvalidArgument(inner),
            crate::error::UpdateOriginRequestPolicyError::InvalidIfMatchVersion(inner) => Error::InvalidIfMatchVersion(inner),
            crate::error::UpdateOriginRequestPolicyError::NoSuchOriginRequestPolicy(inner) => Error::NoSuchOriginRequestPolicy(inner),
            crate::error::UpdateOriginRequestPolicyError::OriginRequestPolicyAlreadyExists(inner) => Error::OriginRequestPolicyAlreadyExists(inner),
            crate::error::UpdateOriginRequestPolicyError::PreconditionFailed(inner) => Error::PreconditionFailed(inner),
            crate::error::UpdateOriginRequestPolicyError::TooManyCookiesInOriginRequestPolicy(inner) => Error::TooManyCookiesInOriginRequestPolicy(inner),
            crate::error::UpdateOriginRequestPolicyError::TooManyHeadersInOriginRequestPolicy(inner) => Error::TooManyHeadersInOriginRequestPolicy(inner),
            crate::error::UpdateOriginRequestPolicyError::TooManyQueryStringsInOriginRequestPolicy(inner) => Error::TooManyQueryStringsInOriginRequestPolicy(inner),
            crate::error::UpdateOriginRequestPolicyError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::UpdatePublicKeyError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::UpdatePublicKeyError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::UpdatePublicKeyError> for Error {
    fn from(err: crate::error::UpdatePublicKeyError) -> Self {
        match err {
            crate::error::UpdatePublicKeyError::AccessDenied(inner) => Error::AccessDenied(inner),
            crate::error::UpdatePublicKeyError::CannotChangeImmutablePublicKeyFields(inner) => {
                Error::CannotChangeImmutablePublicKeyFields(inner)
            }
            crate::error::UpdatePublicKeyError::IllegalUpdate(inner) => Error::IllegalUpdate(inner),
            crate::error::UpdatePublicKeyError::InvalidArgument(inner) => {
                Error::InvalidArgument(inner)
            }
            crate::error::UpdatePublicKeyError::InvalidIfMatchVersion(inner) => {
                Error::InvalidIfMatchVersion(inner)
            }
            crate::error::UpdatePublicKeyError::NoSuchPublicKey(inner) => {
                Error::NoSuchPublicKey(inner)
            }
            crate::error::UpdatePublicKeyError::PreconditionFailed(inner) => {
                Error::PreconditionFailed(inner)
            }
            crate::error::UpdatePublicKeyError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::UpdateRealtimeLogConfigError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::UpdateRealtimeLogConfigError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::UpdateRealtimeLogConfigError> for Error {
    fn from(err: crate::error::UpdateRealtimeLogConfigError) -> Self {
        match err {
            crate::error::UpdateRealtimeLogConfigError::AccessDenied(inner) => {
                Error::AccessDenied(inner)
            }
            crate::error::UpdateRealtimeLogConfigError::InvalidArgument(inner) => {
                Error::InvalidArgument(inner)
            }
            crate::error::UpdateRealtimeLogConfigError::NoSuchRealtimeLogConfig(inner) => {
                Error::NoSuchRealtimeLogConfig(inner)
            }
            crate::error::UpdateRealtimeLogConfigError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::UpdateResponseHeadersPolicyError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::UpdateResponseHeadersPolicyError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::UpdateResponseHeadersPolicyError> for Error {
    fn from(err: crate::error::UpdateResponseHeadersPolicyError) -> Self {
        match err {
            crate::error::UpdateResponseHeadersPolicyError::AccessDenied(inner) => Error::AccessDenied(inner),
            crate::error::UpdateResponseHeadersPolicyError::IllegalUpdate(inner) => Error::IllegalUpdate(inner),
            crate::error::UpdateResponseHeadersPolicyError::InconsistentQuantities(inner) => Error::InconsistentQuantities(inner),
            crate::error::UpdateResponseHeadersPolicyError::InvalidArgument(inner) => Error::InvalidArgument(inner),
            crate::error::UpdateResponseHeadersPolicyError::InvalidIfMatchVersion(inner) => Error::InvalidIfMatchVersion(inner),
            crate::error::UpdateResponseHeadersPolicyError::NoSuchResponseHeadersPolicy(inner) => Error::NoSuchResponseHeadersPolicy(inner),
            crate::error::UpdateResponseHeadersPolicyError::PreconditionFailed(inner) => Error::PreconditionFailed(inner),
            crate::error::UpdateResponseHeadersPolicyError::ResponseHeadersPolicyAlreadyExists(inner) => Error::ResponseHeadersPolicyAlreadyExists(inner),
            crate::error::UpdateResponseHeadersPolicyError::TooLongCspInResponseHeadersPolicy(inner) => Error::TooLongCspInResponseHeadersPolicy(inner),
            crate::error::UpdateResponseHeadersPolicyError::TooManyCustomHeadersInResponseHeadersPolicy(inner) => Error::TooManyCustomHeadersInResponseHeadersPolicy(inner),
            crate::error::UpdateResponseHeadersPolicyError::TooManyRemoveHeadersInResponseHeadersPolicy(inner) => Error::TooManyRemoveHeadersInResponseHeadersPolicy(inner),
            crate::error::UpdateResponseHeadersPolicyError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::UpdateStreamingDistributionError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::UpdateStreamingDistributionError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::UpdateStreamingDistributionError> for Error {
    fn from(err: crate::error::UpdateStreamingDistributionError) -> Self {
        match err {
            crate::error::UpdateStreamingDistributionError::AccessDenied(inner) => {
                Error::AccessDenied(inner)
            }
            crate::error::UpdateStreamingDistributionError::CnameAlreadyExists(inner) => {
                Error::CnameAlreadyExists(inner)
            }
            crate::error::UpdateStreamingDistributionError::IllegalUpdate(inner) => {
                Error::IllegalUpdate(inner)
            }
            crate::error::UpdateStreamingDistributionError::InconsistentQuantities(inner) => {
                Error::InconsistentQuantities(inner)
            }
            crate::error::UpdateStreamingDistributionError::InvalidArgument(inner) => {
                Error::InvalidArgument(inner)
            }
            crate::error::UpdateStreamingDistributionError::InvalidIfMatchVersion(inner) => {
                Error::InvalidIfMatchVersion(inner)
            }
            crate::error::UpdateStreamingDistributionError::InvalidOriginAccessControl(inner) => {
                Error::InvalidOriginAccessControl(inner)
            }
            crate::error::UpdateStreamingDistributionError::InvalidOriginAccessIdentity(inner) => {
                Error::InvalidOriginAccessIdentity(inner)
            }
            crate::error::UpdateStreamingDistributionError::MissingBody(inner) => {
                Error::MissingBody(inner)
            }
            crate::error::UpdateStreamingDistributionError::NoSuchStreamingDistribution(inner) => {
                Error::NoSuchStreamingDistribution(inner)
            }
            crate::error::UpdateStreamingDistributionError::PreconditionFailed(inner) => {
                Error::PreconditionFailed(inner)
            }
            crate::error::UpdateStreamingDistributionError::TooManyStreamingDistributionCnamEs(
                inner,
            ) => Error::TooManyStreamingDistributionCnamEs(inner),
            crate::error::UpdateStreamingDistributionError::TooManyTrustedSigners(inner) => {
                Error::TooManyTrustedSigners(inner)
            }
            crate::error::UpdateStreamingDistributionError::TrustedSignerDoesNotExist(inner) => {
                Error::TrustedSignerDoesNotExist(inner)
            }
            crate::error::UpdateStreamingDistributionError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl std::error::Error for Error {}
impl aws_http::request_id::RequestId for Error {
    fn request_id(&self) -> Option<&str> {
        match self {
            Self::AccessDenied(e) => e.request_id(),
            Self::BatchTooLarge(e) => e.request_id(),
            Self::CnameAlreadyExists(e) => e.request_id(),
            Self::CachePolicyAlreadyExists(e) => e.request_id(),
            Self::CachePolicyInUse(e) => e.request_id(),
            Self::CannotChangeImmutablePublicKeyFields(e) => e.request_id(),
            Self::CloudFrontOriginAccessIdentityAlreadyExists(e) => e.request_id(),
            Self::CloudFrontOriginAccessIdentityInUse(e) => e.request_id(),
            Self::ContinuousDeploymentPolicyAlreadyExists(e) => e.request_id(),
            Self::ContinuousDeploymentPolicyInUse(e) => e.request_id(),
            Self::DistributionAlreadyExists(e) => e.request_id(),
            Self::DistributionNotDisabled(e) => e.request_id(),
            Self::FieldLevelEncryptionConfigAlreadyExists(e) => e.request_id(),
            Self::FieldLevelEncryptionConfigInUse(e) => e.request_id(),
            Self::FieldLevelEncryptionProfileAlreadyExists(e) => e.request_id(),
            Self::FieldLevelEncryptionProfileInUse(e) => e.request_id(),
            Self::FieldLevelEncryptionProfileSizeExceeded(e) => e.request_id(),
            Self::FunctionAlreadyExists(e) => e.request_id(),
            Self::FunctionInUse(e) => e.request_id(),
            Self::FunctionSizeLimitExceeded(e) => e.request_id(),
            Self::IllegalDelete(e) => e.request_id(),
            Self::IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior(e) => {
                e.request_id()
            }
            Self::IllegalOriginAccessConfiguration(e) => e.request_id(),
            Self::IllegalUpdate(e) => e.request_id(),
            Self::InconsistentQuantities(e) => e.request_id(),
            Self::InvalidArgument(e) => e.request_id(),
            Self::InvalidDefaultRootObject(e) => e.request_id(),
            Self::InvalidDomainNameForOriginAccessControl(e) => e.request_id(),
            Self::InvalidErrorCode(e) => e.request_id(),
            Self::InvalidForwardCookies(e) => e.request_id(),
            Self::InvalidFunctionAssociation(e) => e.request_id(),
            Self::InvalidGeoRestrictionParameter(e) => e.request_id(),
            Self::InvalidHeadersForS3Origin(e) => e.request_id(),
            Self::InvalidIfMatchVersion(e) => e.request_id(),
            Self::InvalidLambdaFunctionAssociation(e) => e.request_id(),
            Self::InvalidLocationCode(e) => e.request_id(),
            Self::InvalidMinimumProtocolVersion(e) => e.request_id(),
            Self::InvalidOrigin(e) => e.request_id(),
            Self::InvalidOriginAccessControl(e) => e.request_id(),
            Self::InvalidOriginAccessIdentity(e) => e.request_id(),
            Self::InvalidOriginKeepaliveTimeout(e) => e.request_id(),
            Self::InvalidOriginReadTimeout(e) => e.request_id(),
            Self::InvalidProtocolSettings(e) => e.request_id(),
            Self::InvalidQueryStringParameters(e) => e.request_id(),
            Self::InvalidRelativePath(e) => e.request_id(),
            Self::InvalidRequiredProtocol(e) => e.request_id(),
            Self::InvalidResponseCode(e) => e.request_id(),
            Self::InvalidTtlOrder(e) => e.request_id(),
            Self::InvalidTagging(e) => e.request_id(),
            Self::InvalidViewerCertificate(e) => e.request_id(),
            Self::InvalidWebAclId(e) => e.request_id(),
            Self::KeyGroupAlreadyExists(e) => e.request_id(),
            Self::MissingBody(e) => e.request_id(),
            Self::MonitoringSubscriptionAlreadyExists(e) => e.request_id(),
            Self::NoSuchCachePolicy(e) => e.request_id(),
            Self::NoSuchCloudFrontOriginAccessIdentity(e) => e.request_id(),
            Self::NoSuchContinuousDeploymentPolicy(e) => e.request_id(),
            Self::NoSuchDistribution(e) => e.request_id(),
            Self::NoSuchFieldLevelEncryptionConfig(e) => e.request_id(),
            Self::NoSuchFieldLevelEncryptionProfile(e) => e.request_id(),
            Self::NoSuchFunctionExists(e) => e.request_id(),
            Self::NoSuchInvalidation(e) => e.request_id(),
            Self::NoSuchMonitoringSubscription(e) => e.request_id(),
            Self::NoSuchOrigin(e) => e.request_id(),
            Self::NoSuchOriginAccessControl(e) => e.request_id(),
            Self::NoSuchOriginRequestPolicy(e) => e.request_id(),
            Self::NoSuchPublicKey(e) => e.request_id(),
            Self::NoSuchRealtimeLogConfig(e) => e.request_id(),
            Self::NoSuchResource(e) => e.request_id(),
            Self::NoSuchResponseHeadersPolicy(e) => e.request_id(),
            Self::NoSuchStreamingDistribution(e) => e.request_id(),
            Self::OriginAccessControlAlreadyExists(e) => e.request_id(),
            Self::OriginAccessControlInUse(e) => e.request_id(),
            Self::OriginRequestPolicyAlreadyExists(e) => e.request_id(),
            Self::OriginRequestPolicyInUse(e) => e.request_id(),
            Self::PreconditionFailed(e) => e.request_id(),
            Self::PublicKeyAlreadyExists(e) => e.request_id(),
            Self::PublicKeyInUse(e) => e.request_id(),
            Self::QueryArgProfileEmpty(e) => e.request_id(),
            Self::RealtimeLogConfigAlreadyExists(e) => e.request_id(),
            Self::RealtimeLogConfigInUse(e) => e.request_id(),
            Self::RealtimeLogConfigOwnerMismatch(e) => e.request_id(),
            Self::ResourceInUse(e) => e.request_id(),
            Self::ResponseHeadersPolicyAlreadyExists(e) => e.request_id(),
            Self::ResponseHeadersPolicyInUse(e) => e.request_id(),
            Self::StagingDistributionInUse(e) => e.request_id(),
            Self::StreamingDistributionAlreadyExists(e) => e.request_id(),
            Self::StreamingDistributionNotDisabled(e) => e.request_id(),
            Self::TestFunctionFailed(e) => e.request_id(),
            Self::TooLongCspInResponseHeadersPolicy(e) => e.request_id(),
            Self::TooManyCacheBehaviors(e) => e.request_id(),
            Self::TooManyCachePolicies(e) => e.request_id(),
            Self::TooManyCertificates(e) => e.request_id(),
            Self::TooManyCloudFrontOriginAccessIdentities(e) => e.request_id(),
            Self::TooManyContinuousDeploymentPolicies(e) => e.request_id(),
            Self::TooManyCookieNamesInWhiteList(e) => e.request_id(),
            Self::TooManyCookiesInCachePolicy(e) => e.request_id(),
            Self::TooManyCookiesInOriginRequestPolicy(e) => e.request_id(),
            Self::TooManyCustomHeadersInResponseHeadersPolicy(e) => e.request_id(),
            Self::TooManyDistributionCnamEs(e) => e.request_id(),
            Self::TooManyDistributions(e) => e.request_id(),
            Self::TooManyDistributionsAssociatedToCachePolicy(e) => e.request_id(),
            Self::TooManyDistributionsAssociatedToFieldLevelEncryptionConfig(e) => e.request_id(),
            Self::TooManyDistributionsAssociatedToKeyGroup(e) => e.request_id(),
            Self::TooManyDistributionsAssociatedToOriginAccessControl(e) => e.request_id(),
            Self::TooManyDistributionsAssociatedToOriginRequestPolicy(e) => e.request_id(),
            Self::TooManyDistributionsAssociatedToResponseHeadersPolicy(e) => e.request_id(),
            Self::TooManyDistributionsWithFunctionAssociations(e) => e.request_id(),
            Self::TooManyDistributionsWithLambdaAssociations(e) => e.request_id(),
            Self::TooManyDistributionsWithSingleFunctionArn(e) => e.request_id(),
            Self::TooManyFieldLevelEncryptionConfigs(e) => e.request_id(),
            Self::TooManyFieldLevelEncryptionContentTypeProfiles(e) => e.request_id(),
            Self::TooManyFieldLevelEncryptionEncryptionEntities(e) => e.request_id(),
            Self::TooManyFieldLevelEncryptionFieldPatterns(e) => e.request_id(),
            Self::TooManyFieldLevelEncryptionProfiles(e) => e.request_id(),
            Self::TooManyFieldLevelEncryptionQueryArgProfiles(e) => e.request_id(),
            Self::TooManyFunctionAssociations(e) => e.request_id(),
            Self::TooManyFunctions(e) => e.request_id(),
            Self::TooManyHeadersInCachePolicy(e) => e.request_id(),
            Self::TooManyHeadersInForwardedValues(e) => e.request_id(),
            Self::TooManyHeadersInOriginRequestPolicy(e) => e.request_id(),
            Self::TooManyInvalidationsInProgress(e) => e.request_id(),
            Self::TooManyKeyGroups(e) => e.request_id(),
            Self::TooManyKeyGroupsAssociatedToDistribution(e) => e.request_id(),
            Self::TooManyLambdaFunctionAssociations(e) => e.request_id(),
            Self::TooManyOriginAccessControls(e) => e.request_id(),
            Self::TooManyOriginCustomHeaders(e) => e.request_id(),
            Self::TooManyOriginGroupsPerDistribution(e) => e.request_id(),
            Self::TooManyOriginRequestPolicies(e) => e.request_id(),
            Self::TooManyOrigins(e) => e.request_id(),
            Self::TooManyPublicKeys(e) => e.request_id(),
            Self::TooManyPublicKeysInKeyGroup(e) => e.request_id(),
            Self::TooManyQueryStringParameters(e) => e.request_id(),
            Self::TooManyQueryStringsInCachePolicy(e) => e.request_id(),
            Self::TooManyQueryStringsInOriginRequestPolicy(e) => e.request_id(),
            Self::TooManyRealtimeLogConfigs(e) => e.request_id(),
            Self::TooManyRemoveHeadersInResponseHeadersPolicy(e) => e.request_id(),
            Self::TooManyResponseHeadersPolicies(e) => e.request_id(),
            Self::TooManyStreamingDistributionCnamEs(e) => e.request_id(),
            Self::TooManyStreamingDistributions(e) => e.request_id(),
            Self::TooManyTrustedSigners(e) => e.request_id(),
            Self::TrustedKeyGroupDoesNotExist(e) => e.request_id(),
            Self::TrustedSignerDoesNotExist(e) => e.request_id(),
            Self::UnsupportedOperation(e) => e.request_id(),
            Self::Unhandled(e) => e.request_id(),
        }
    }
}
