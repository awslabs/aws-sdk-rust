// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct ListConflictingAliasesInput {
    /// <p>The ID of a distribution in your account that has an attached SSL/TLS certificate that includes the provided alias.</p>
    pub distribution_id: ::std::option::Option<::std::string::String>,
    /// <p>The alias (also called a CNAME) to search for conflicting aliases.</p>
    pub alias: ::std::option::Option<::std::string::String>,
    /// <p>Use this field when paginating results to indicate where to begin in the list of conflicting aliases. The response includes conflicting aliases in the list that occur after the marker. To get the next page of the list, set this field's value to the value of <code>NextMarker</code> from the current page's response.</p>
    pub marker: ::std::option::Option<::std::string::String>,
    /// <p>The maximum number of conflicting aliases that you want in the response.</p>
    pub max_items: ::std::option::Option<i32>,
}
impl ListConflictingAliasesInput {
    /// <p>The ID of a distribution in your account that has an attached SSL/TLS certificate that includes the provided alias.</p>
    pub fn distribution_id(&self) -> ::std::option::Option<&str> {
        self.distribution_id.as_deref()
    }
    /// <p>The alias (also called a CNAME) to search for conflicting aliases.</p>
    pub fn alias(&self) -> ::std::option::Option<&str> {
        self.alias.as_deref()
    }
    /// <p>Use this field when paginating results to indicate where to begin in the list of conflicting aliases. The response includes conflicting aliases in the list that occur after the marker. To get the next page of the list, set this field's value to the value of <code>NextMarker</code> from the current page's response.</p>
    pub fn marker(&self) -> ::std::option::Option<&str> {
        self.marker.as_deref()
    }
    /// <p>The maximum number of conflicting aliases that you want in the response.</p>
    pub fn max_items(&self) -> ::std::option::Option<i32> {
        self.max_items
    }
}
impl ListConflictingAliasesInput {
    /// Creates a new builder-style object to manufacture [`ListConflictingAliasesInput`](crate::operation::list_conflicting_aliases::ListConflictingAliasesInput).
    pub fn builder() -> crate::operation::list_conflicting_aliases::builders::ListConflictingAliasesInputBuilder {
        crate::operation::list_conflicting_aliases::builders::ListConflictingAliasesInputBuilder::default()
    }
}

/// A builder for [`ListConflictingAliasesInput`](crate::operation::list_conflicting_aliases::ListConflictingAliasesInput).
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
pub struct ListConflictingAliasesInputBuilder {
    pub(crate) distribution_id: ::std::option::Option<::std::string::String>,
    pub(crate) alias: ::std::option::Option<::std::string::String>,
    pub(crate) marker: ::std::option::Option<::std::string::String>,
    pub(crate) max_items: ::std::option::Option<i32>,
}
impl ListConflictingAliasesInputBuilder {
    /// <p>The ID of a distribution in your account that has an attached SSL/TLS certificate that includes the provided alias.</p>
    /// This field is required.
    pub fn distribution_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.distribution_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The ID of a distribution in your account that has an attached SSL/TLS certificate that includes the provided alias.</p>
    pub fn set_distribution_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.distribution_id = input;
        self
    }
    /// <p>The ID of a distribution in your account that has an attached SSL/TLS certificate that includes the provided alias.</p>
    pub fn get_distribution_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.distribution_id
    }
    /// <p>The alias (also called a CNAME) to search for conflicting aliases.</p>
    /// This field is required.
    pub fn alias(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.alias = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The alias (also called a CNAME) to search for conflicting aliases.</p>
    pub fn set_alias(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.alias = input;
        self
    }
    /// <p>The alias (also called a CNAME) to search for conflicting aliases.</p>
    pub fn get_alias(&self) -> &::std::option::Option<::std::string::String> {
        &self.alias
    }
    /// <p>Use this field when paginating results to indicate where to begin in the list of conflicting aliases. The response includes conflicting aliases in the list that occur after the marker. To get the next page of the list, set this field's value to the value of <code>NextMarker</code> from the current page's response.</p>
    pub fn marker(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.marker = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>Use this field when paginating results to indicate where to begin in the list of conflicting aliases. The response includes conflicting aliases in the list that occur after the marker. To get the next page of the list, set this field's value to the value of <code>NextMarker</code> from the current page's response.</p>
    pub fn set_marker(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.marker = input;
        self
    }
    /// <p>Use this field when paginating results to indicate where to begin in the list of conflicting aliases. The response includes conflicting aliases in the list that occur after the marker. To get the next page of the list, set this field's value to the value of <code>NextMarker</code> from the current page's response.</p>
    pub fn get_marker(&self) -> &::std::option::Option<::std::string::String> {
        &self.marker
    }
    /// <p>The maximum number of conflicting aliases that you want in the response.</p>
    pub fn max_items(mut self, input: i32) -> Self {
        self.max_items = ::std::option::Option::Some(input);
        self
    }
    /// <p>The maximum number of conflicting aliases that you want in the response.</p>
    pub fn set_max_items(mut self, input: ::std::option::Option<i32>) -> Self {
        self.max_items = input;
        self
    }
    /// <p>The maximum number of conflicting aliases that you want in the response.</p>
    pub fn get_max_items(&self) -> &::std::option::Option<i32> {
        &self.max_items
    }
    /// Consumes the builder and constructs a [`ListConflictingAliasesInput`](crate::operation::list_conflicting_aliases::ListConflictingAliasesInput).
    pub fn build(
        self,
    ) -> ::std::result::Result<
        crate::operation::list_conflicting_aliases::ListConflictingAliasesInput,
        ::aws_smithy_types::error::operation::BuildError,
    > {
        ::std::result::Result::Ok(crate::operation::list_conflicting_aliases::ListConflictingAliasesInput {
            distribution_id: self.distribution_id,
            alias: self.alias,
            marker: self.marker,
            max_items: self.max_items,
        })
    }
}
