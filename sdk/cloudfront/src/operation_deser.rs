// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(clippy::unnecessary_wraps)]
pub fn parse_associate_alias_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::AssociateAliasOutput, crate::error::AssociateAliasError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::AssociateAliasError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::AssociateAliasError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AccessDenied" => crate::error::AssociateAliasError::AccessDenied({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::access_denied::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_access_denied_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::AssociateAliasError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "IllegalUpdate" => crate::error::AssociateAliasError::IllegalUpdate({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::illegal_update::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_illegal_update_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::AssociateAliasError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidArgument" => crate::error::AssociateAliasError::InvalidArgument({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_argument::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_invalid_argument_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::AssociateAliasError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NoSuchDistribution" => crate::error::AssociateAliasError::NoSuchDistribution({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_distribution::Builder::default();
                let _ = response;
                output =
                    crate::xml_deser::deser_structure_crate_error_no_such_distribution_xml_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::AssociateAliasError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "TooManyDistributionCNAMEs" => {
            crate::error::AssociateAliasError::TooManyDistributionCnamEs({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::too_many_distribution_cnam_es::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_distribution_cnam_es_xml_err(response.body().as_ref(), output).map_err(crate::error::AssociateAliasError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::AssociateAliasError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_associate_alias_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::AssociateAliasOutput, crate::error::AssociateAliasError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::associate_alias_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_copy_distribution_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CopyDistributionOutput, crate::error::CopyDistributionError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CopyDistributionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CopyDistributionError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AccessDenied" => crate::error::CopyDistributionError::AccessDenied({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::access_denied::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_access_denied_xml_err(response.body().as_ref(), output).map_err(crate::error::CopyDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "CNAMEAlreadyExists" => crate::error::CopyDistributionError::CnameAlreadyExists({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::cname_already_exists::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_cname_already_exists_xml_err(response.body().as_ref(), output).map_err(crate::error::CopyDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "DistributionAlreadyExists" => crate::error::CopyDistributionError::DistributionAlreadyExists({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::distribution_already_exists::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_distribution_already_exists_xml_err(response.body().as_ref(), output).map_err(crate::error::CopyDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior" => crate::error::CopyDistributionError::IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::illegal_field_level_encryption_config_association_with_cache_behavior::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_illegal_field_level_encryption_config_association_with_cache_behavior_xml_err(response.body().as_ref(), output).map_err(crate::error::CopyDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InconsistentQuantities" => crate::error::CopyDistributionError::InconsistentQuantities({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::inconsistent_quantities::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_inconsistent_quantities_xml_err(response.body().as_ref(), output).map_err(crate::error::CopyDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidArgument" => crate::error::CopyDistributionError::InvalidArgument({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_argument::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_argument_xml_err(response.body().as_ref(), output).map_err(crate::error::CopyDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidDefaultRootObject" => crate::error::CopyDistributionError::InvalidDefaultRootObject({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_default_root_object::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_default_root_object_xml_err(response.body().as_ref(), output).map_err(crate::error::CopyDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidErrorCode" => crate::error::CopyDistributionError::InvalidErrorCode({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_error_code::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_error_code_xml_err(response.body().as_ref(), output).map_err(crate::error::CopyDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidForwardCookies" => crate::error::CopyDistributionError::InvalidForwardCookies({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_forward_cookies::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_forward_cookies_xml_err(response.body().as_ref(), output).map_err(crate::error::CopyDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidFunctionAssociation" => crate::error::CopyDistributionError::InvalidFunctionAssociation({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_function_association::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_function_association_xml_err(response.body().as_ref(), output).map_err(crate::error::CopyDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidGeoRestrictionParameter" => crate::error::CopyDistributionError::InvalidGeoRestrictionParameter({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_geo_restriction_parameter::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_geo_restriction_parameter_xml_err(response.body().as_ref(), output).map_err(crate::error::CopyDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidHeadersForS3Origin" => crate::error::CopyDistributionError::InvalidHeadersForS3Origin({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_headers_for_s3_origin::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_headers_for_s3_origin_xml_err(response.body().as_ref(), output).map_err(crate::error::CopyDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidIfMatchVersion" => crate::error::CopyDistributionError::InvalidIfMatchVersion({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_if_match_version::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_if_match_version_xml_err(response.body().as_ref(), output).map_err(crate::error::CopyDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidLambdaFunctionAssociation" => crate::error::CopyDistributionError::InvalidLambdaFunctionAssociation({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_lambda_function_association::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_lambda_function_association_xml_err(response.body().as_ref(), output).map_err(crate::error::CopyDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidLocationCode" => crate::error::CopyDistributionError::InvalidLocationCode({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_location_code::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_location_code_xml_err(response.body().as_ref(), output).map_err(crate::error::CopyDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidMinimumProtocolVersion" => crate::error::CopyDistributionError::InvalidMinimumProtocolVersion({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_minimum_protocol_version::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_minimum_protocol_version_xml_err(response.body().as_ref(), output).map_err(crate::error::CopyDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidOrigin" => crate::error::CopyDistributionError::InvalidOrigin({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_origin::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_origin_xml_err(response.body().as_ref(), output).map_err(crate::error::CopyDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidOriginAccessControl" => crate::error::CopyDistributionError::InvalidOriginAccessControl({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_origin_access_control::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_origin_access_control_xml_err(response.body().as_ref(), output).map_err(crate::error::CopyDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidOriginAccessIdentity" => crate::error::CopyDistributionError::InvalidOriginAccessIdentity({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_origin_access_identity::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_origin_access_identity_xml_err(response.body().as_ref(), output).map_err(crate::error::CopyDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidOriginKeepaliveTimeout" => crate::error::CopyDistributionError::InvalidOriginKeepaliveTimeout({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_origin_keepalive_timeout::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_origin_keepalive_timeout_xml_err(response.body().as_ref(), output).map_err(crate::error::CopyDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidOriginReadTimeout" => crate::error::CopyDistributionError::InvalidOriginReadTimeout({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_origin_read_timeout::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_origin_read_timeout_xml_err(response.body().as_ref(), output).map_err(crate::error::CopyDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidProtocolSettings" => crate::error::CopyDistributionError::InvalidProtocolSettings({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_protocol_settings::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_protocol_settings_xml_err(response.body().as_ref(), output).map_err(crate::error::CopyDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidQueryStringParameters" => crate::error::CopyDistributionError::InvalidQueryStringParameters({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_query_string_parameters::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_query_string_parameters_xml_err(response.body().as_ref(), output).map_err(crate::error::CopyDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidRelativePath" => crate::error::CopyDistributionError::InvalidRelativePath({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_relative_path::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_relative_path_xml_err(response.body().as_ref(), output).map_err(crate::error::CopyDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidRequiredProtocol" => crate::error::CopyDistributionError::InvalidRequiredProtocol({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_required_protocol::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_required_protocol_xml_err(response.body().as_ref(), output).map_err(crate::error::CopyDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidResponseCode" => crate::error::CopyDistributionError::InvalidResponseCode({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_response_code::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_response_code_xml_err(response.body().as_ref(), output).map_err(crate::error::CopyDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidTTLOrder" => crate::error::CopyDistributionError::InvalidTtlOrder({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_ttl_order::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_ttl_order_xml_err(response.body().as_ref(), output).map_err(crate::error::CopyDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidViewerCertificate" => crate::error::CopyDistributionError::InvalidViewerCertificate({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_viewer_certificate::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_viewer_certificate_xml_err(response.body().as_ref(), output).map_err(crate::error::CopyDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidWebACLId" => crate::error::CopyDistributionError::InvalidWebAclId({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_web_acl_id::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_web_acl_id_xml_err(response.body().as_ref(), output).map_err(crate::error::CopyDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "MissingBody" => crate::error::CopyDistributionError::MissingBody({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::missing_body::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_missing_body_xml_err(response.body().as_ref(), output).map_err(crate::error::CopyDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "NoSuchCachePolicy" => crate::error::CopyDistributionError::NoSuchCachePolicy({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_cache_policy::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_cache_policy_xml_err(response.body().as_ref(), output).map_err(crate::error::CopyDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "NoSuchDistribution" => crate::error::CopyDistributionError::NoSuchDistribution({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_distribution::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_distribution_xml_err(response.body().as_ref(), output).map_err(crate::error::CopyDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "NoSuchFieldLevelEncryptionConfig" => crate::error::CopyDistributionError::NoSuchFieldLevelEncryptionConfig({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_field_level_encryption_config::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_field_level_encryption_config_xml_err(response.body().as_ref(), output).map_err(crate::error::CopyDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "NoSuchOrigin" => crate::error::CopyDistributionError::NoSuchOrigin({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_origin::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_origin_xml_err(response.body().as_ref(), output).map_err(crate::error::CopyDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "NoSuchOriginRequestPolicy" => crate::error::CopyDistributionError::NoSuchOriginRequestPolicy({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_origin_request_policy::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_origin_request_policy_xml_err(response.body().as_ref(), output).map_err(crate::error::CopyDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "NoSuchRealtimeLogConfig" => crate::error::CopyDistributionError::NoSuchRealtimeLogConfig({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_realtime_log_config::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_realtime_log_config_xml_err(response.body().as_ref(), output).map_err(crate::error::CopyDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "NoSuchResponseHeadersPolicy" => crate::error::CopyDistributionError::NoSuchResponseHeadersPolicy({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_response_headers_policy::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_response_headers_policy_xml_err(response.body().as_ref(), output).map_err(crate::error::CopyDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "PreconditionFailed" => crate::error::CopyDistributionError::PreconditionFailed({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::precondition_failed::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_precondition_failed_xml_err(response.body().as_ref(), output).map_err(crate::error::CopyDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "RealtimeLogConfigOwnerMismatch" => crate::error::CopyDistributionError::RealtimeLogConfigOwnerMismatch({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::realtime_log_config_owner_mismatch::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_realtime_log_config_owner_mismatch_xml_err(response.body().as_ref(), output).map_err(crate::error::CopyDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyCacheBehaviors" => crate::error::CopyDistributionError::TooManyCacheBehaviors({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_cache_behaviors::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_cache_behaviors_xml_err(response.body().as_ref(), output).map_err(crate::error::CopyDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyCertificates" => crate::error::CopyDistributionError::TooManyCertificates({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_certificates::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_certificates_xml_err(response.body().as_ref(), output).map_err(crate::error::CopyDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyCookieNamesInWhiteList" => crate::error::CopyDistributionError::TooManyCookieNamesInWhiteList({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_cookie_names_in_white_list::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_cookie_names_in_white_list_xml_err(response.body().as_ref(), output).map_err(crate::error::CopyDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyDistributionCNAMEs" => crate::error::CopyDistributionError::TooManyDistributionCnamEs({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_distribution_cnam_es::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_distribution_cnam_es_xml_err(response.body().as_ref(), output).map_err(crate::error::CopyDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyDistributions" => crate::error::CopyDistributionError::TooManyDistributions({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_distributions::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_distributions_xml_err(response.body().as_ref(), output).map_err(crate::error::CopyDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyDistributionsAssociatedToCachePolicy" => crate::error::CopyDistributionError::TooManyDistributionsAssociatedToCachePolicy({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_distributions_associated_to_cache_policy::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_distributions_associated_to_cache_policy_xml_err(response.body().as_ref(), output).map_err(crate::error::CopyDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyDistributionsAssociatedToFieldLevelEncryptionConfig" => crate::error::CopyDistributionError::TooManyDistributionsAssociatedToFieldLevelEncryptionConfig({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_distributions_associated_to_field_level_encryption_config::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_distributions_associated_to_field_level_encryption_config_xml_err(response.body().as_ref(), output).map_err(crate::error::CopyDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyDistributionsAssociatedToKeyGroup" => crate::error::CopyDistributionError::TooManyDistributionsAssociatedToKeyGroup({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_distributions_associated_to_key_group::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_distributions_associated_to_key_group_xml_err(response.body().as_ref(), output).map_err(crate::error::CopyDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyDistributionsAssociatedToOriginRequestPolicy" => crate::error::CopyDistributionError::TooManyDistributionsAssociatedToOriginRequestPolicy({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_distributions_associated_to_origin_request_policy::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_distributions_associated_to_origin_request_policy_xml_err(response.body().as_ref(), output).map_err(crate::error::CopyDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyDistributionsAssociatedToResponseHeadersPolicy" => crate::error::CopyDistributionError::TooManyDistributionsAssociatedToResponseHeadersPolicy({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_distributions_associated_to_response_headers_policy::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_distributions_associated_to_response_headers_policy_xml_err(response.body().as_ref(), output).map_err(crate::error::CopyDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyDistributionsWithFunctionAssociations" => crate::error::CopyDistributionError::TooManyDistributionsWithFunctionAssociations({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_distributions_with_function_associations::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_distributions_with_function_associations_xml_err(response.body().as_ref(), output).map_err(crate::error::CopyDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyDistributionsWithLambdaAssociations" => crate::error::CopyDistributionError::TooManyDistributionsWithLambdaAssociations({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_distributions_with_lambda_associations::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_distributions_with_lambda_associations_xml_err(response.body().as_ref(), output).map_err(crate::error::CopyDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyDistributionsWithSingleFunctionARN" => crate::error::CopyDistributionError::TooManyDistributionsWithSingleFunctionArn({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_distributions_with_single_function_arn::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_distributions_with_single_function_arn_xml_err(response.body().as_ref(), output).map_err(crate::error::CopyDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyFunctionAssociations" => crate::error::CopyDistributionError::TooManyFunctionAssociations({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_function_associations::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_function_associations_xml_err(response.body().as_ref(), output).map_err(crate::error::CopyDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyHeadersInForwardedValues" => crate::error::CopyDistributionError::TooManyHeadersInForwardedValues({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_headers_in_forwarded_values::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_headers_in_forwarded_values_xml_err(response.body().as_ref(), output).map_err(crate::error::CopyDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyKeyGroupsAssociatedToDistribution" => crate::error::CopyDistributionError::TooManyKeyGroupsAssociatedToDistribution({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_key_groups_associated_to_distribution::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_key_groups_associated_to_distribution_xml_err(response.body().as_ref(), output).map_err(crate::error::CopyDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyLambdaFunctionAssociations" => crate::error::CopyDistributionError::TooManyLambdaFunctionAssociations({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_lambda_function_associations::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_lambda_function_associations_xml_err(response.body().as_ref(), output).map_err(crate::error::CopyDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyOriginCustomHeaders" => crate::error::CopyDistributionError::TooManyOriginCustomHeaders({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_origin_custom_headers::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_origin_custom_headers_xml_err(response.body().as_ref(), output).map_err(crate::error::CopyDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyOriginGroupsPerDistribution" => crate::error::CopyDistributionError::TooManyOriginGroupsPerDistribution({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_origin_groups_per_distribution::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_origin_groups_per_distribution_xml_err(response.body().as_ref(), output).map_err(crate::error::CopyDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyOrigins" => crate::error::CopyDistributionError::TooManyOrigins({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_origins::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_origins_xml_err(response.body().as_ref(), output).map_err(crate::error::CopyDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyQueryStringParameters" => crate::error::CopyDistributionError::TooManyQueryStringParameters({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_query_string_parameters::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_query_string_parameters_xml_err(response.body().as_ref(), output).map_err(crate::error::CopyDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyTrustedSigners" => crate::error::CopyDistributionError::TooManyTrustedSigners({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_trusted_signers::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_trusted_signers_xml_err(response.body().as_ref(), output).map_err(crate::error::CopyDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TrustedKeyGroupDoesNotExist" => crate::error::CopyDistributionError::TrustedKeyGroupDoesNotExist({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::trusted_key_group_does_not_exist::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_trusted_key_group_does_not_exist_xml_err(response.body().as_ref(), output).map_err(crate::error::CopyDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TrustedSignerDoesNotExist" => crate::error::CopyDistributionError::TrustedSignerDoesNotExist({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::trusted_signer_does_not_exist::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_trusted_signer_does_not_exist_xml_err(response.body().as_ref(), output).map_err(crate::error::CopyDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::CopyDistributionError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_copy_distribution_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CopyDistributionOutput, crate::error::CopyDistributionError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::copy_distribution_output::Builder::default();
        let _ = response;
        output = output.set_distribution(
            crate::http_serde::deser_payload_copy_distribution_copy_distribution_output_distribution(response.body().as_ref())?
        );
        output = output.set_e_tag(
            crate::http_serde::deser_header_copy_distribution_copy_distribution_output_e_tag(
                response.headers(),
            )
            .map_err(|_| {
                crate::error::CopyDistributionError::unhandled(
                    "Failed to parse ETag from header `ETag",
                )
            })?,
        );
        output = output.set_location(
            crate::http_serde::deser_header_copy_distribution_copy_distribution_output_location(
                response.headers(),
            )
            .map_err(|_| {
                crate::error::CopyDistributionError::unhandled(
                    "Failed to parse Location from header `Location",
                )
            })?,
        );
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_cache_policy_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateCachePolicyOutput, crate::error::CreateCachePolicyError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateCachePolicyError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateCachePolicyError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AccessDenied" => crate::error::CreateCachePolicyError::AccessDenied({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::access_denied::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_access_denied_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateCachePolicyError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "CachePolicyAlreadyExists" => {
            crate::error::CreateCachePolicyError::CachePolicyAlreadyExists({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::cache_policy_already_exists::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_cache_policy_already_exists_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateCachePolicyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InconsistentQuantities" => {
            crate::error::CreateCachePolicyError::InconsistentQuantities({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::inconsistent_quantities::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_inconsistent_quantities_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateCachePolicyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidArgument" => crate::error::CreateCachePolicyError::InvalidArgument({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_argument::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_invalid_argument_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateCachePolicyError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "TooManyCachePolicies" => {
            crate::error::CreateCachePolicyError::TooManyCachePolicies({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_cache_policies::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_cache_policies_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateCachePolicyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "TooManyCookiesInCachePolicy" => {
            crate::error::CreateCachePolicyError::TooManyCookiesInCachePolicy({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::too_many_cookies_in_cache_policy::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_cookies_in_cache_policy_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateCachePolicyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "TooManyHeadersInCachePolicy" => {
            crate::error::CreateCachePolicyError::TooManyHeadersInCachePolicy({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::too_many_headers_in_cache_policy::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_headers_in_cache_policy_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateCachePolicyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "TooManyQueryStringsInCachePolicy" => {
            crate::error::CreateCachePolicyError::TooManyQueryStringsInCachePolicy({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::too_many_query_strings_in_cache_policy::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_query_strings_in_cache_policy_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateCachePolicyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::CreateCachePolicyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_cache_policy_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateCachePolicyOutput, crate::error::CreateCachePolicyError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_cache_policy_output::Builder::default();
        let _ = response;
        output = output.set_cache_policy(
            crate::http_serde::deser_payload_create_cache_policy_create_cache_policy_output_cache_policy(response.body().as_ref())?
        );
        output = output.set_e_tag(
            crate::http_serde::deser_header_create_cache_policy_create_cache_policy_output_e_tag(
                response.headers(),
            )
            .map_err(|_| {
                crate::error::CreateCachePolicyError::unhandled(
                    "Failed to parse ETag from header `ETag",
                )
            })?,
        );
        output = output.set_location(
            crate::http_serde::deser_header_create_cache_policy_create_cache_policy_output_location(response.headers())
                                    .map_err(|_|crate::error::CreateCachePolicyError::unhandled("Failed to parse Location from header `Location"))?
        );
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_cloud_front_origin_access_identity_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateCloudFrontOriginAccessIdentityOutput,
    crate::error::CreateCloudFrontOriginAccessIdentityError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateCloudFrontOriginAccessIdentityError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::CreateCloudFrontOriginAccessIdentityError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "CloudFrontOriginAccessIdentityAlreadyExists" => crate::error::CreateCloudFrontOriginAccessIdentityError::CloudFrontOriginAccessIdentityAlreadyExists({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::cloud_front_origin_access_identity_already_exists::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_cloud_front_origin_access_identity_already_exists_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateCloudFrontOriginAccessIdentityError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InconsistentQuantities" => crate::error::CreateCloudFrontOriginAccessIdentityError::InconsistentQuantities({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::inconsistent_quantities::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_inconsistent_quantities_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateCloudFrontOriginAccessIdentityError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidArgument" => crate::error::CreateCloudFrontOriginAccessIdentityError::InvalidArgument({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_argument::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_argument_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateCloudFrontOriginAccessIdentityError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "MissingBody" => crate::error::CreateCloudFrontOriginAccessIdentityError::MissingBody({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::missing_body::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_missing_body_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateCloudFrontOriginAccessIdentityError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyCloudFrontOriginAccessIdentities" => crate::error::CreateCloudFrontOriginAccessIdentityError::TooManyCloudFrontOriginAccessIdentities({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_cloud_front_origin_access_identities::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_cloud_front_origin_access_identities_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateCloudFrontOriginAccessIdentityError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::CreateCloudFrontOriginAccessIdentityError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_cloud_front_origin_access_identity_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateCloudFrontOriginAccessIdentityOutput,
    crate::error::CreateCloudFrontOriginAccessIdentityError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::create_cloud_front_origin_access_identity_output::Builder::default();
        let _ = response;
        output = output.set_cloud_front_origin_access_identity(
            crate::http_serde::deser_payload_create_cloud_front_origin_access_identity_create_cloud_front_origin_access_identity_output_cloud_front_origin_access_identity(response.body().as_ref())?
        );
        output = output.set_e_tag(
            crate::http_serde::deser_header_create_cloud_front_origin_access_identity_create_cloud_front_origin_access_identity_output_e_tag(response.headers())
                                    .map_err(|_|crate::error::CreateCloudFrontOriginAccessIdentityError::unhandled("Failed to parse ETag from header `ETag"))?
        );
        output = output.set_location(
            crate::http_serde::deser_header_create_cloud_front_origin_access_identity_create_cloud_front_origin_access_identity_output_location(response.headers())
                                    .map_err(|_|crate::error::CreateCloudFrontOriginAccessIdentityError::unhandled("Failed to parse Location from header `Location"))?
        );
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_continuous_deployment_policy_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateContinuousDeploymentPolicyOutput,
    crate::error::CreateContinuousDeploymentPolicyError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateContinuousDeploymentPolicyError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::CreateContinuousDeploymentPolicyError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AccessDenied" => crate::error::CreateContinuousDeploymentPolicyError::AccessDenied({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::access_denied::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_access_denied_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateContinuousDeploymentPolicyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "ContinuousDeploymentPolicyAlreadyExists" => crate::error::CreateContinuousDeploymentPolicyError::ContinuousDeploymentPolicyAlreadyExists({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::continuous_deployment_policy_already_exists::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_continuous_deployment_policy_already_exists_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateContinuousDeploymentPolicyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InconsistentQuantities" => crate::error::CreateContinuousDeploymentPolicyError::InconsistentQuantities({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::inconsistent_quantities::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_inconsistent_quantities_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateContinuousDeploymentPolicyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidArgument" => crate::error::CreateContinuousDeploymentPolicyError::InvalidArgument({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_argument::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_argument_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateContinuousDeploymentPolicyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "StagingDistributionInUse" => crate::error::CreateContinuousDeploymentPolicyError::StagingDistributionInUse({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::staging_distribution_in_use::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_staging_distribution_in_use_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateContinuousDeploymentPolicyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyContinuousDeploymentPolicies" => crate::error::CreateContinuousDeploymentPolicyError::TooManyContinuousDeploymentPolicies({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_continuous_deployment_policies::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_continuous_deployment_policies_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateContinuousDeploymentPolicyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::CreateContinuousDeploymentPolicyError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_continuous_deployment_policy_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateContinuousDeploymentPolicyOutput,
    crate::error::CreateContinuousDeploymentPolicyError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::create_continuous_deployment_policy_output::Builder::default();
        let _ = response;
        output = output.set_continuous_deployment_policy(
            crate::http_serde::deser_payload_create_continuous_deployment_policy_create_continuous_deployment_policy_output_continuous_deployment_policy(response.body().as_ref())?
        );
        output = output.set_e_tag(
            crate::http_serde::deser_header_create_continuous_deployment_policy_create_continuous_deployment_policy_output_e_tag(response.headers())
                                    .map_err(|_|crate::error::CreateContinuousDeploymentPolicyError::unhandled("Failed to parse ETag from header `ETag"))?
        );
        output = output.set_location(
            crate::http_serde::deser_header_create_continuous_deployment_policy_create_continuous_deployment_policy_output_location(response.headers())
                                    .map_err(|_|crate::error::CreateContinuousDeploymentPolicyError::unhandled("Failed to parse Location from header `Location"))?
        );
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_distribution_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateDistributionOutput,
    crate::error::CreateDistributionError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateDistributionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateDistributionError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AccessDenied" => crate::error::CreateDistributionError::AccessDenied({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::access_denied::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_access_denied_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "CNAMEAlreadyExists" => crate::error::CreateDistributionError::CnameAlreadyExists({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::cname_already_exists::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_cname_already_exists_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "ContinuousDeploymentPolicyInUse" => crate::error::CreateDistributionError::ContinuousDeploymentPolicyInUse({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::continuous_deployment_policy_in_use::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_continuous_deployment_policy_in_use_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "DistributionAlreadyExists" => crate::error::CreateDistributionError::DistributionAlreadyExists({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::distribution_already_exists::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_distribution_already_exists_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior" => crate::error::CreateDistributionError::IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::illegal_field_level_encryption_config_association_with_cache_behavior::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_illegal_field_level_encryption_config_association_with_cache_behavior_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "IllegalOriginAccessConfiguration" => crate::error::CreateDistributionError::IllegalOriginAccessConfiguration({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::illegal_origin_access_configuration::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_illegal_origin_access_configuration_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InconsistentQuantities" => crate::error::CreateDistributionError::InconsistentQuantities({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::inconsistent_quantities::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_inconsistent_quantities_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidArgument" => crate::error::CreateDistributionError::InvalidArgument({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_argument::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_argument_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidDefaultRootObject" => crate::error::CreateDistributionError::InvalidDefaultRootObject({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_default_root_object::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_default_root_object_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidDomainNameForOriginAccessControl" => crate::error::CreateDistributionError::InvalidDomainNameForOriginAccessControl({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_domain_name_for_origin_access_control::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_domain_name_for_origin_access_control_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidErrorCode" => crate::error::CreateDistributionError::InvalidErrorCode({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_error_code::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_error_code_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidForwardCookies" => crate::error::CreateDistributionError::InvalidForwardCookies({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_forward_cookies::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_forward_cookies_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidFunctionAssociation" => crate::error::CreateDistributionError::InvalidFunctionAssociation({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_function_association::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_function_association_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidGeoRestrictionParameter" => crate::error::CreateDistributionError::InvalidGeoRestrictionParameter({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_geo_restriction_parameter::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_geo_restriction_parameter_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidHeadersForS3Origin" => crate::error::CreateDistributionError::InvalidHeadersForS3Origin({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_headers_for_s3_origin::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_headers_for_s3_origin_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidLambdaFunctionAssociation" => crate::error::CreateDistributionError::InvalidLambdaFunctionAssociation({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_lambda_function_association::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_lambda_function_association_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidLocationCode" => crate::error::CreateDistributionError::InvalidLocationCode({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_location_code::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_location_code_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidMinimumProtocolVersion" => crate::error::CreateDistributionError::InvalidMinimumProtocolVersion({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_minimum_protocol_version::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_minimum_protocol_version_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidOrigin" => crate::error::CreateDistributionError::InvalidOrigin({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_origin::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_origin_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidOriginAccessControl" => crate::error::CreateDistributionError::InvalidOriginAccessControl({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_origin_access_control::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_origin_access_control_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidOriginAccessIdentity" => crate::error::CreateDistributionError::InvalidOriginAccessIdentity({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_origin_access_identity::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_origin_access_identity_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidOriginKeepaliveTimeout" => crate::error::CreateDistributionError::InvalidOriginKeepaliveTimeout({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_origin_keepalive_timeout::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_origin_keepalive_timeout_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidOriginReadTimeout" => crate::error::CreateDistributionError::InvalidOriginReadTimeout({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_origin_read_timeout::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_origin_read_timeout_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidProtocolSettings" => crate::error::CreateDistributionError::InvalidProtocolSettings({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_protocol_settings::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_protocol_settings_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidQueryStringParameters" => crate::error::CreateDistributionError::InvalidQueryStringParameters({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_query_string_parameters::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_query_string_parameters_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidRelativePath" => crate::error::CreateDistributionError::InvalidRelativePath({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_relative_path::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_relative_path_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidRequiredProtocol" => crate::error::CreateDistributionError::InvalidRequiredProtocol({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_required_protocol::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_required_protocol_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidResponseCode" => crate::error::CreateDistributionError::InvalidResponseCode({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_response_code::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_response_code_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidTTLOrder" => crate::error::CreateDistributionError::InvalidTtlOrder({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_ttl_order::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_ttl_order_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidViewerCertificate" => crate::error::CreateDistributionError::InvalidViewerCertificate({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_viewer_certificate::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_viewer_certificate_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidWebACLId" => crate::error::CreateDistributionError::InvalidWebAclId({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_web_acl_id::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_web_acl_id_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "MissingBody" => crate::error::CreateDistributionError::MissingBody({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::missing_body::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_missing_body_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "NoSuchCachePolicy" => crate::error::CreateDistributionError::NoSuchCachePolicy({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_cache_policy::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_cache_policy_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "NoSuchContinuousDeploymentPolicy" => crate::error::CreateDistributionError::NoSuchContinuousDeploymentPolicy({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_continuous_deployment_policy::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_continuous_deployment_policy_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "NoSuchFieldLevelEncryptionConfig" => crate::error::CreateDistributionError::NoSuchFieldLevelEncryptionConfig({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_field_level_encryption_config::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_field_level_encryption_config_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "NoSuchOrigin" => crate::error::CreateDistributionError::NoSuchOrigin({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_origin::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_origin_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "NoSuchOriginRequestPolicy" => crate::error::CreateDistributionError::NoSuchOriginRequestPolicy({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_origin_request_policy::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_origin_request_policy_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "NoSuchRealtimeLogConfig" => crate::error::CreateDistributionError::NoSuchRealtimeLogConfig({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_realtime_log_config::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_realtime_log_config_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "NoSuchResponseHeadersPolicy" => crate::error::CreateDistributionError::NoSuchResponseHeadersPolicy({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_response_headers_policy::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_response_headers_policy_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "RealtimeLogConfigOwnerMismatch" => crate::error::CreateDistributionError::RealtimeLogConfigOwnerMismatch({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::realtime_log_config_owner_mismatch::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_realtime_log_config_owner_mismatch_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyCacheBehaviors" => crate::error::CreateDistributionError::TooManyCacheBehaviors({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_cache_behaviors::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_cache_behaviors_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyCertificates" => crate::error::CreateDistributionError::TooManyCertificates({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_certificates::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_certificates_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyCookieNamesInWhiteList" => crate::error::CreateDistributionError::TooManyCookieNamesInWhiteList({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_cookie_names_in_white_list::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_cookie_names_in_white_list_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyDistributionCNAMEs" => crate::error::CreateDistributionError::TooManyDistributionCnamEs({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_distribution_cnam_es::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_distribution_cnam_es_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyDistributions" => crate::error::CreateDistributionError::TooManyDistributions({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_distributions::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_distributions_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyDistributionsAssociatedToCachePolicy" => crate::error::CreateDistributionError::TooManyDistributionsAssociatedToCachePolicy({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_distributions_associated_to_cache_policy::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_distributions_associated_to_cache_policy_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyDistributionsAssociatedToFieldLevelEncryptionConfig" => crate::error::CreateDistributionError::TooManyDistributionsAssociatedToFieldLevelEncryptionConfig({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_distributions_associated_to_field_level_encryption_config::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_distributions_associated_to_field_level_encryption_config_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyDistributionsAssociatedToKeyGroup" => crate::error::CreateDistributionError::TooManyDistributionsAssociatedToKeyGroup({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_distributions_associated_to_key_group::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_distributions_associated_to_key_group_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyDistributionsAssociatedToOriginAccessControl" => crate::error::CreateDistributionError::TooManyDistributionsAssociatedToOriginAccessControl({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_distributions_associated_to_origin_access_control::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_distributions_associated_to_origin_access_control_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyDistributionsAssociatedToOriginRequestPolicy" => crate::error::CreateDistributionError::TooManyDistributionsAssociatedToOriginRequestPolicy({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_distributions_associated_to_origin_request_policy::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_distributions_associated_to_origin_request_policy_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyDistributionsAssociatedToResponseHeadersPolicy" => crate::error::CreateDistributionError::TooManyDistributionsAssociatedToResponseHeadersPolicy({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_distributions_associated_to_response_headers_policy::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_distributions_associated_to_response_headers_policy_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyDistributionsWithFunctionAssociations" => crate::error::CreateDistributionError::TooManyDistributionsWithFunctionAssociations({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_distributions_with_function_associations::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_distributions_with_function_associations_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyDistributionsWithLambdaAssociations" => crate::error::CreateDistributionError::TooManyDistributionsWithLambdaAssociations({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_distributions_with_lambda_associations::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_distributions_with_lambda_associations_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyDistributionsWithSingleFunctionARN" => crate::error::CreateDistributionError::TooManyDistributionsWithSingleFunctionArn({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_distributions_with_single_function_arn::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_distributions_with_single_function_arn_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyFunctionAssociations" => crate::error::CreateDistributionError::TooManyFunctionAssociations({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_function_associations::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_function_associations_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyHeadersInForwardedValues" => crate::error::CreateDistributionError::TooManyHeadersInForwardedValues({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_headers_in_forwarded_values::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_headers_in_forwarded_values_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyKeyGroupsAssociatedToDistribution" => crate::error::CreateDistributionError::TooManyKeyGroupsAssociatedToDistribution({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_key_groups_associated_to_distribution::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_key_groups_associated_to_distribution_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyLambdaFunctionAssociations" => crate::error::CreateDistributionError::TooManyLambdaFunctionAssociations({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_lambda_function_associations::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_lambda_function_associations_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyOriginCustomHeaders" => crate::error::CreateDistributionError::TooManyOriginCustomHeaders({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_origin_custom_headers::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_origin_custom_headers_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyOriginGroupsPerDistribution" => crate::error::CreateDistributionError::TooManyOriginGroupsPerDistribution({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_origin_groups_per_distribution::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_origin_groups_per_distribution_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyOrigins" => crate::error::CreateDistributionError::TooManyOrigins({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_origins::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_origins_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyQueryStringParameters" => crate::error::CreateDistributionError::TooManyQueryStringParameters({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_query_string_parameters::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_query_string_parameters_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyTrustedSigners" => crate::error::CreateDistributionError::TooManyTrustedSigners({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_trusted_signers::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_trusted_signers_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TrustedKeyGroupDoesNotExist" => crate::error::CreateDistributionError::TrustedKeyGroupDoesNotExist({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::trusted_key_group_does_not_exist::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_trusted_key_group_does_not_exist_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TrustedSignerDoesNotExist" => crate::error::CreateDistributionError::TrustedSignerDoesNotExist({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::trusted_signer_does_not_exist::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_trusted_signer_does_not_exist_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::CreateDistributionError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_distribution_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateDistributionOutput,
    crate::error::CreateDistributionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_distribution_output::Builder::default();
        let _ = response;
        output = output.set_distribution(
            crate::http_serde::deser_payload_create_distribution_create_distribution_output_distribution(response.body().as_ref())?
        );
        output = output.set_e_tag(
            crate::http_serde::deser_header_create_distribution_create_distribution_output_e_tag(
                response.headers(),
            )
            .map_err(|_| {
                crate::error::CreateDistributionError::unhandled(
                    "Failed to parse ETag from header `ETag",
                )
            })?,
        );
        output = output.set_location(
            crate::http_serde::deser_header_create_distribution_create_distribution_output_location(response.headers())
                                    .map_err(|_|crate::error::CreateDistributionError::unhandled("Failed to parse Location from header `Location"))?
        );
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_distribution_with_tags_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateDistributionWithTagsOutput,
    crate::error::CreateDistributionWithTagsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateDistributionWithTagsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::CreateDistributionWithTagsError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AccessDenied" => crate::error::CreateDistributionWithTagsError::AccessDenied({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::access_denied::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_access_denied_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionWithTagsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "CNAMEAlreadyExists" => crate::error::CreateDistributionWithTagsError::CnameAlreadyExists({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::cname_already_exists::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_cname_already_exists_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionWithTagsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "ContinuousDeploymentPolicyInUse" => crate::error::CreateDistributionWithTagsError::ContinuousDeploymentPolicyInUse({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::continuous_deployment_policy_in_use::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_continuous_deployment_policy_in_use_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionWithTagsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "DistributionAlreadyExists" => crate::error::CreateDistributionWithTagsError::DistributionAlreadyExists({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::distribution_already_exists::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_distribution_already_exists_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionWithTagsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior" => crate::error::CreateDistributionWithTagsError::IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::illegal_field_level_encryption_config_association_with_cache_behavior::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_illegal_field_level_encryption_config_association_with_cache_behavior_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionWithTagsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InconsistentQuantities" => crate::error::CreateDistributionWithTagsError::InconsistentQuantities({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::inconsistent_quantities::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_inconsistent_quantities_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionWithTagsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidArgument" => crate::error::CreateDistributionWithTagsError::InvalidArgument({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_argument::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_argument_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionWithTagsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidDefaultRootObject" => crate::error::CreateDistributionWithTagsError::InvalidDefaultRootObject({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_default_root_object::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_default_root_object_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionWithTagsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidDomainNameForOriginAccessControl" => crate::error::CreateDistributionWithTagsError::InvalidDomainNameForOriginAccessControl({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_domain_name_for_origin_access_control::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_domain_name_for_origin_access_control_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionWithTagsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidErrorCode" => crate::error::CreateDistributionWithTagsError::InvalidErrorCode({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_error_code::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_error_code_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionWithTagsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidForwardCookies" => crate::error::CreateDistributionWithTagsError::InvalidForwardCookies({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_forward_cookies::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_forward_cookies_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionWithTagsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidFunctionAssociation" => crate::error::CreateDistributionWithTagsError::InvalidFunctionAssociation({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_function_association::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_function_association_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionWithTagsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidGeoRestrictionParameter" => crate::error::CreateDistributionWithTagsError::InvalidGeoRestrictionParameter({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_geo_restriction_parameter::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_geo_restriction_parameter_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionWithTagsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidHeadersForS3Origin" => crate::error::CreateDistributionWithTagsError::InvalidHeadersForS3Origin({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_headers_for_s3_origin::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_headers_for_s3_origin_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionWithTagsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidLambdaFunctionAssociation" => crate::error::CreateDistributionWithTagsError::InvalidLambdaFunctionAssociation({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_lambda_function_association::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_lambda_function_association_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionWithTagsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidLocationCode" => crate::error::CreateDistributionWithTagsError::InvalidLocationCode({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_location_code::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_location_code_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionWithTagsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidMinimumProtocolVersion" => crate::error::CreateDistributionWithTagsError::InvalidMinimumProtocolVersion({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_minimum_protocol_version::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_minimum_protocol_version_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionWithTagsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidOrigin" => crate::error::CreateDistributionWithTagsError::InvalidOrigin({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_origin::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_origin_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionWithTagsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidOriginAccessControl" => crate::error::CreateDistributionWithTagsError::InvalidOriginAccessControl({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_origin_access_control::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_origin_access_control_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionWithTagsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidOriginAccessIdentity" => crate::error::CreateDistributionWithTagsError::InvalidOriginAccessIdentity({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_origin_access_identity::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_origin_access_identity_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionWithTagsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidOriginKeepaliveTimeout" => crate::error::CreateDistributionWithTagsError::InvalidOriginKeepaliveTimeout({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_origin_keepalive_timeout::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_origin_keepalive_timeout_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionWithTagsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidOriginReadTimeout" => crate::error::CreateDistributionWithTagsError::InvalidOriginReadTimeout({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_origin_read_timeout::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_origin_read_timeout_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionWithTagsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidProtocolSettings" => crate::error::CreateDistributionWithTagsError::InvalidProtocolSettings({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_protocol_settings::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_protocol_settings_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionWithTagsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidQueryStringParameters" => crate::error::CreateDistributionWithTagsError::InvalidQueryStringParameters({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_query_string_parameters::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_query_string_parameters_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionWithTagsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidRelativePath" => crate::error::CreateDistributionWithTagsError::InvalidRelativePath({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_relative_path::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_relative_path_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionWithTagsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidRequiredProtocol" => crate::error::CreateDistributionWithTagsError::InvalidRequiredProtocol({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_required_protocol::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_required_protocol_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionWithTagsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidResponseCode" => crate::error::CreateDistributionWithTagsError::InvalidResponseCode({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_response_code::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_response_code_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionWithTagsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidTagging" => crate::error::CreateDistributionWithTagsError::InvalidTagging({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_tagging::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_tagging_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionWithTagsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidTTLOrder" => crate::error::CreateDistributionWithTagsError::InvalidTtlOrder({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_ttl_order::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_ttl_order_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionWithTagsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidViewerCertificate" => crate::error::CreateDistributionWithTagsError::InvalidViewerCertificate({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_viewer_certificate::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_viewer_certificate_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionWithTagsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidWebACLId" => crate::error::CreateDistributionWithTagsError::InvalidWebAclId({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_web_acl_id::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_web_acl_id_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionWithTagsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "MissingBody" => crate::error::CreateDistributionWithTagsError::MissingBody({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::missing_body::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_missing_body_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionWithTagsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "NoSuchCachePolicy" => crate::error::CreateDistributionWithTagsError::NoSuchCachePolicy({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_cache_policy::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_cache_policy_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionWithTagsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "NoSuchContinuousDeploymentPolicy" => crate::error::CreateDistributionWithTagsError::NoSuchContinuousDeploymentPolicy({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_continuous_deployment_policy::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_continuous_deployment_policy_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionWithTagsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "NoSuchFieldLevelEncryptionConfig" => crate::error::CreateDistributionWithTagsError::NoSuchFieldLevelEncryptionConfig({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_field_level_encryption_config::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_field_level_encryption_config_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionWithTagsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "NoSuchOrigin" => crate::error::CreateDistributionWithTagsError::NoSuchOrigin({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_origin::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_origin_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionWithTagsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "NoSuchOriginRequestPolicy" => crate::error::CreateDistributionWithTagsError::NoSuchOriginRequestPolicy({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_origin_request_policy::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_origin_request_policy_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionWithTagsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "NoSuchRealtimeLogConfig" => crate::error::CreateDistributionWithTagsError::NoSuchRealtimeLogConfig({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_realtime_log_config::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_realtime_log_config_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionWithTagsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "NoSuchResponseHeadersPolicy" => crate::error::CreateDistributionWithTagsError::NoSuchResponseHeadersPolicy({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_response_headers_policy::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_response_headers_policy_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionWithTagsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "RealtimeLogConfigOwnerMismatch" => crate::error::CreateDistributionWithTagsError::RealtimeLogConfigOwnerMismatch({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::realtime_log_config_owner_mismatch::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_realtime_log_config_owner_mismatch_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionWithTagsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyCacheBehaviors" => crate::error::CreateDistributionWithTagsError::TooManyCacheBehaviors({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_cache_behaviors::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_cache_behaviors_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionWithTagsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyCertificates" => crate::error::CreateDistributionWithTagsError::TooManyCertificates({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_certificates::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_certificates_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionWithTagsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyCookieNamesInWhiteList" => crate::error::CreateDistributionWithTagsError::TooManyCookieNamesInWhiteList({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_cookie_names_in_white_list::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_cookie_names_in_white_list_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionWithTagsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyDistributionCNAMEs" => crate::error::CreateDistributionWithTagsError::TooManyDistributionCnamEs({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_distribution_cnam_es::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_distribution_cnam_es_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionWithTagsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyDistributions" => crate::error::CreateDistributionWithTagsError::TooManyDistributions({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_distributions::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_distributions_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionWithTagsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyDistributionsAssociatedToCachePolicy" => crate::error::CreateDistributionWithTagsError::TooManyDistributionsAssociatedToCachePolicy({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_distributions_associated_to_cache_policy::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_distributions_associated_to_cache_policy_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionWithTagsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyDistributionsAssociatedToFieldLevelEncryptionConfig" => crate::error::CreateDistributionWithTagsError::TooManyDistributionsAssociatedToFieldLevelEncryptionConfig({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_distributions_associated_to_field_level_encryption_config::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_distributions_associated_to_field_level_encryption_config_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionWithTagsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyDistributionsAssociatedToKeyGroup" => crate::error::CreateDistributionWithTagsError::TooManyDistributionsAssociatedToKeyGroup({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_distributions_associated_to_key_group::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_distributions_associated_to_key_group_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionWithTagsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyDistributionsAssociatedToOriginRequestPolicy" => crate::error::CreateDistributionWithTagsError::TooManyDistributionsAssociatedToOriginRequestPolicy({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_distributions_associated_to_origin_request_policy::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_distributions_associated_to_origin_request_policy_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionWithTagsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyDistributionsAssociatedToResponseHeadersPolicy" => crate::error::CreateDistributionWithTagsError::TooManyDistributionsAssociatedToResponseHeadersPolicy({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_distributions_associated_to_response_headers_policy::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_distributions_associated_to_response_headers_policy_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionWithTagsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyDistributionsWithFunctionAssociations" => crate::error::CreateDistributionWithTagsError::TooManyDistributionsWithFunctionAssociations({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_distributions_with_function_associations::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_distributions_with_function_associations_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionWithTagsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyDistributionsWithLambdaAssociations" => crate::error::CreateDistributionWithTagsError::TooManyDistributionsWithLambdaAssociations({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_distributions_with_lambda_associations::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_distributions_with_lambda_associations_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionWithTagsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyDistributionsWithSingleFunctionARN" => crate::error::CreateDistributionWithTagsError::TooManyDistributionsWithSingleFunctionArn({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_distributions_with_single_function_arn::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_distributions_with_single_function_arn_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionWithTagsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyFunctionAssociations" => crate::error::CreateDistributionWithTagsError::TooManyFunctionAssociations({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_function_associations::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_function_associations_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionWithTagsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyHeadersInForwardedValues" => crate::error::CreateDistributionWithTagsError::TooManyHeadersInForwardedValues({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_headers_in_forwarded_values::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_headers_in_forwarded_values_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionWithTagsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyKeyGroupsAssociatedToDistribution" => crate::error::CreateDistributionWithTagsError::TooManyKeyGroupsAssociatedToDistribution({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_key_groups_associated_to_distribution::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_key_groups_associated_to_distribution_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionWithTagsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyLambdaFunctionAssociations" => crate::error::CreateDistributionWithTagsError::TooManyLambdaFunctionAssociations({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_lambda_function_associations::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_lambda_function_associations_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionWithTagsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyOriginCustomHeaders" => crate::error::CreateDistributionWithTagsError::TooManyOriginCustomHeaders({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_origin_custom_headers::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_origin_custom_headers_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionWithTagsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyOriginGroupsPerDistribution" => crate::error::CreateDistributionWithTagsError::TooManyOriginGroupsPerDistribution({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_origin_groups_per_distribution::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_origin_groups_per_distribution_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionWithTagsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyOrigins" => crate::error::CreateDistributionWithTagsError::TooManyOrigins({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_origins::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_origins_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionWithTagsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyQueryStringParameters" => crate::error::CreateDistributionWithTagsError::TooManyQueryStringParameters({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_query_string_parameters::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_query_string_parameters_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionWithTagsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyTrustedSigners" => crate::error::CreateDistributionWithTagsError::TooManyTrustedSigners({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_trusted_signers::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_trusted_signers_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionWithTagsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TrustedKeyGroupDoesNotExist" => crate::error::CreateDistributionWithTagsError::TrustedKeyGroupDoesNotExist({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::trusted_key_group_does_not_exist::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_trusted_key_group_does_not_exist_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionWithTagsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TrustedSignerDoesNotExist" => crate::error::CreateDistributionWithTagsError::TrustedSignerDoesNotExist({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::trusted_signer_does_not_exist::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_trusted_signer_does_not_exist_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDistributionWithTagsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::CreateDistributionWithTagsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_distribution_with_tags_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateDistributionWithTagsOutput,
    crate::error::CreateDistributionWithTagsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_distribution_with_tags_output::Builder::default();
        let _ = response;
        output = output.set_distribution(
            crate::http_serde::deser_payload_create_distribution_with_tags_create_distribution_with_tags_output_distribution(response.body().as_ref())?
        );
        output = output.set_e_tag(
            crate::http_serde::deser_header_create_distribution_with_tags_create_distribution_with_tags_output_e_tag(response.headers())
                                    .map_err(|_|crate::error::CreateDistributionWithTagsError::unhandled("Failed to parse ETag from header `ETag"))?
        );
        output = output.set_location(
            crate::http_serde::deser_header_create_distribution_with_tags_create_distribution_with_tags_output_location(response.headers())
                                    .map_err(|_|crate::error::CreateDistributionWithTagsError::unhandled("Failed to parse Location from header `Location"))?
        );
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_field_level_encryption_config_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateFieldLevelEncryptionConfigOutput,
    crate::error::CreateFieldLevelEncryptionConfigError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateFieldLevelEncryptionConfigError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::CreateFieldLevelEncryptionConfigError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "FieldLevelEncryptionConfigAlreadyExists" => crate::error::CreateFieldLevelEncryptionConfigError::FieldLevelEncryptionConfigAlreadyExists({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::field_level_encryption_config_already_exists::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_field_level_encryption_config_already_exists_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateFieldLevelEncryptionConfigError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InconsistentQuantities" => crate::error::CreateFieldLevelEncryptionConfigError::InconsistentQuantities({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::inconsistent_quantities::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_inconsistent_quantities_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateFieldLevelEncryptionConfigError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidArgument" => crate::error::CreateFieldLevelEncryptionConfigError::InvalidArgument({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_argument::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_argument_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateFieldLevelEncryptionConfigError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "NoSuchFieldLevelEncryptionProfile" => crate::error::CreateFieldLevelEncryptionConfigError::NoSuchFieldLevelEncryptionProfile({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_field_level_encryption_profile::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_field_level_encryption_profile_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateFieldLevelEncryptionConfigError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "QueryArgProfileEmpty" => crate::error::CreateFieldLevelEncryptionConfigError::QueryArgProfileEmpty({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::query_arg_profile_empty::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_query_arg_profile_empty_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateFieldLevelEncryptionConfigError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyFieldLevelEncryptionConfigs" => crate::error::CreateFieldLevelEncryptionConfigError::TooManyFieldLevelEncryptionConfigs({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_field_level_encryption_configs::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_field_level_encryption_configs_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateFieldLevelEncryptionConfigError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyFieldLevelEncryptionContentTypeProfiles" => crate::error::CreateFieldLevelEncryptionConfigError::TooManyFieldLevelEncryptionContentTypeProfiles({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_field_level_encryption_content_type_profiles::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_field_level_encryption_content_type_profiles_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateFieldLevelEncryptionConfigError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyFieldLevelEncryptionQueryArgProfiles" => crate::error::CreateFieldLevelEncryptionConfigError::TooManyFieldLevelEncryptionQueryArgProfiles({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_field_level_encryption_query_arg_profiles::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_field_level_encryption_query_arg_profiles_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateFieldLevelEncryptionConfigError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::CreateFieldLevelEncryptionConfigError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_field_level_encryption_config_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateFieldLevelEncryptionConfigOutput,
    crate::error::CreateFieldLevelEncryptionConfigError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::create_field_level_encryption_config_output::Builder::default();
        let _ = response;
        output = output.set_e_tag(
            crate::http_serde::deser_header_create_field_level_encryption_config_create_field_level_encryption_config_output_e_tag(response.headers())
                                    .map_err(|_|crate::error::CreateFieldLevelEncryptionConfigError::unhandled("Failed to parse ETag from header `ETag"))?
        );
        output = output.set_field_level_encryption(
            crate::http_serde::deser_payload_create_field_level_encryption_config_create_field_level_encryption_config_output_field_level_encryption(response.body().as_ref())?
        );
        output = output.set_location(
            crate::http_serde::deser_header_create_field_level_encryption_config_create_field_level_encryption_config_output_location(response.headers())
                                    .map_err(|_|crate::error::CreateFieldLevelEncryptionConfigError::unhandled("Failed to parse Location from header `Location"))?
        );
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_field_level_encryption_profile_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateFieldLevelEncryptionProfileOutput,
    crate::error::CreateFieldLevelEncryptionProfileError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateFieldLevelEncryptionProfileError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::CreateFieldLevelEncryptionProfileError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "FieldLevelEncryptionProfileAlreadyExists" => crate::error::CreateFieldLevelEncryptionProfileError::FieldLevelEncryptionProfileAlreadyExists({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::field_level_encryption_profile_already_exists::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_field_level_encryption_profile_already_exists_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateFieldLevelEncryptionProfileError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "FieldLevelEncryptionProfileSizeExceeded" => crate::error::CreateFieldLevelEncryptionProfileError::FieldLevelEncryptionProfileSizeExceeded({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::field_level_encryption_profile_size_exceeded::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_field_level_encryption_profile_size_exceeded_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateFieldLevelEncryptionProfileError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InconsistentQuantities" => crate::error::CreateFieldLevelEncryptionProfileError::InconsistentQuantities({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::inconsistent_quantities::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_inconsistent_quantities_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateFieldLevelEncryptionProfileError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidArgument" => crate::error::CreateFieldLevelEncryptionProfileError::InvalidArgument({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_argument::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_argument_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateFieldLevelEncryptionProfileError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "NoSuchPublicKey" => crate::error::CreateFieldLevelEncryptionProfileError::NoSuchPublicKey({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_public_key::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_public_key_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateFieldLevelEncryptionProfileError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyFieldLevelEncryptionEncryptionEntities" => crate::error::CreateFieldLevelEncryptionProfileError::TooManyFieldLevelEncryptionEncryptionEntities({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_field_level_encryption_encryption_entities::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_field_level_encryption_encryption_entities_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateFieldLevelEncryptionProfileError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyFieldLevelEncryptionFieldPatterns" => crate::error::CreateFieldLevelEncryptionProfileError::TooManyFieldLevelEncryptionFieldPatterns({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_field_level_encryption_field_patterns::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_field_level_encryption_field_patterns_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateFieldLevelEncryptionProfileError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyFieldLevelEncryptionProfiles" => crate::error::CreateFieldLevelEncryptionProfileError::TooManyFieldLevelEncryptionProfiles({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_field_level_encryption_profiles::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_field_level_encryption_profiles_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateFieldLevelEncryptionProfileError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::CreateFieldLevelEncryptionProfileError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_field_level_encryption_profile_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateFieldLevelEncryptionProfileOutput,
    crate::error::CreateFieldLevelEncryptionProfileError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::create_field_level_encryption_profile_output::Builder::default();
        let _ = response;
        output = output.set_e_tag(
            crate::http_serde::deser_header_create_field_level_encryption_profile_create_field_level_encryption_profile_output_e_tag(response.headers())
                                    .map_err(|_|crate::error::CreateFieldLevelEncryptionProfileError::unhandled("Failed to parse ETag from header `ETag"))?
        );
        output = output.set_field_level_encryption_profile(
            crate::http_serde::deser_payload_create_field_level_encryption_profile_create_field_level_encryption_profile_output_field_level_encryption_profile(response.body().as_ref())?
        );
        output = output.set_location(
            crate::http_serde::deser_header_create_field_level_encryption_profile_create_field_level_encryption_profile_output_location(response.headers())
                                    .map_err(|_|crate::error::CreateFieldLevelEncryptionProfileError::unhandled("Failed to parse Location from header `Location"))?
        );
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_function_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateFunctionOutput, crate::error::CreateFunctionError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateFunctionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateFunctionError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "FunctionAlreadyExists" => {
            crate::error::CreateFunctionError::FunctionAlreadyExists({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::function_already_exists::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_function_already_exists_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateFunctionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "FunctionSizeLimitExceeded" => {
            crate::error::CreateFunctionError::FunctionSizeLimitExceeded({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::function_size_limit_exceeded::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_function_size_limit_exceeded_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateFunctionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidArgument" => crate::error::CreateFunctionError::InvalidArgument({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_argument::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_invalid_argument_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateFunctionError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "TooManyFunctions" => crate::error::CreateFunctionError::TooManyFunctions({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_functions::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_too_many_functions_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateFunctionError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "UnsupportedOperation" => {
            crate::error::CreateFunctionError::UnsupportedOperation({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unsupported_operation::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_unsupported_operation_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateFunctionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::CreateFunctionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_function_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateFunctionOutput, crate::error::CreateFunctionError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_function_output::Builder::default();
        let _ = response;
        output = output.set_e_tag(
            crate::http_serde::deser_header_create_function_create_function_output_e_tag(
                response.headers(),
            )
            .map_err(|_| {
                crate::error::CreateFunctionError::unhandled(
                    "Failed to parse ETag from header `ETag",
                )
            })?,
        );
        output = output.set_function_summary(
            crate::http_serde::deser_payload_create_function_create_function_output_function_summary(response.body().as_ref())?
        );
        output = output.set_location(
            crate::http_serde::deser_header_create_function_create_function_output_location(
                response.headers(),
            )
            .map_err(|_| {
                crate::error::CreateFunctionError::unhandled(
                    "Failed to parse Location from header `Location",
                )
            })?,
        );
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_invalidation_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateInvalidationOutput,
    crate::error::CreateInvalidationError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateInvalidationError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateInvalidationError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AccessDenied" => crate::error::CreateInvalidationError::AccessDenied({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::access_denied::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_access_denied_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateInvalidationError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "BatchTooLarge" => crate::error::CreateInvalidationError::BatchTooLarge({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::batch_too_large::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_batch_too_large_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateInvalidationError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InconsistentQuantities" => {
            crate::error::CreateInvalidationError::InconsistentQuantities({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::inconsistent_quantities::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_inconsistent_quantities_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateInvalidationError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidArgument" => crate::error::CreateInvalidationError::InvalidArgument({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_argument::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_invalid_argument_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateInvalidationError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "MissingBody" => crate::error::CreateInvalidationError::MissingBody({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::missing_body::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_missing_body_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateInvalidationError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NoSuchDistribution" => crate::error::CreateInvalidationError::NoSuchDistribution({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_distribution::Builder::default();
                let _ = response;
                output =
                    crate::xml_deser::deser_structure_crate_error_no_such_distribution_xml_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreateInvalidationError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "TooManyInvalidationsInProgress" => {
            crate::error::CreateInvalidationError::TooManyInvalidationsInProgress({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::too_many_invalidations_in_progress::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_invalidations_in_progress_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateInvalidationError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::CreateInvalidationError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_invalidation_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateInvalidationOutput,
    crate::error::CreateInvalidationError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_invalidation_output::Builder::default();
        let _ = response;
        output = output.set_invalidation(
            crate::http_serde::deser_payload_create_invalidation_create_invalidation_output_invalidation(response.body().as_ref())?
        );
        output = output.set_location(
            crate::http_serde::deser_header_create_invalidation_create_invalidation_output_location(response.headers())
                                    .map_err(|_|crate::error::CreateInvalidationError::unhandled("Failed to parse Location from header `Location"))?
        );
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_key_group_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateKeyGroupOutput, crate::error::CreateKeyGroupError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateKeyGroupError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateKeyGroupError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidArgument" => crate::error::CreateKeyGroupError::InvalidArgument({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_argument::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_invalid_argument_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateKeyGroupError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "KeyGroupAlreadyExists" => {
            crate::error::CreateKeyGroupError::KeyGroupAlreadyExists({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::key_group_already_exists::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_key_group_already_exists_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateKeyGroupError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "TooManyKeyGroups" => crate::error::CreateKeyGroupError::TooManyKeyGroups({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_key_groups::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_too_many_key_groups_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateKeyGroupError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "TooManyPublicKeysInKeyGroup" => {
            crate::error::CreateKeyGroupError::TooManyPublicKeysInKeyGroup({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::too_many_public_keys_in_key_group::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_public_keys_in_key_group_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateKeyGroupError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::CreateKeyGroupError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_key_group_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateKeyGroupOutput, crate::error::CreateKeyGroupError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_key_group_output::Builder::default();
        let _ = response;
        output = output.set_e_tag(
            crate::http_serde::deser_header_create_key_group_create_key_group_output_e_tag(
                response.headers(),
            )
            .map_err(|_| {
                crate::error::CreateKeyGroupError::unhandled(
                    "Failed to parse ETag from header `ETag",
                )
            })?,
        );
        output = output.set_key_group(
            crate::http_serde::deser_payload_create_key_group_create_key_group_output_key_group(
                response.body().as_ref(),
            )?,
        );
        output = output.set_location(
            crate::http_serde::deser_header_create_key_group_create_key_group_output_location(
                response.headers(),
            )
            .map_err(|_| {
                crate::error::CreateKeyGroupError::unhandled(
                    "Failed to parse Location from header `Location",
                )
            })?,
        );
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_monitoring_subscription_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateMonitoringSubscriptionOutput,
    crate::error::CreateMonitoringSubscriptionError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateMonitoringSubscriptionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::CreateMonitoringSubscriptionError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AccessDenied" => crate::error::CreateMonitoringSubscriptionError::AccessDenied({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::access_denied::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_access_denied_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateMonitoringSubscriptionError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "MonitoringSubscriptionAlreadyExists" => {
            crate::error::CreateMonitoringSubscriptionError::MonitoringSubscriptionAlreadyExists({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::monitoring_subscription_already_exists::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_monitoring_subscription_already_exists_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateMonitoringSubscriptionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "NoSuchDistribution" => {
            crate::error::CreateMonitoringSubscriptionError::NoSuchDistribution({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_distribution::Builder::default();
                    let _ = response;
                    output =
                        crate::xml_deser::deser_structure_crate_error_no_such_distribution_xml_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::CreateMonitoringSubscriptionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "UnsupportedOperation" => {
            crate::error::CreateMonitoringSubscriptionError::UnsupportedOperation({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unsupported_operation::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_unsupported_operation_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateMonitoringSubscriptionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::CreateMonitoringSubscriptionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_monitoring_subscription_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateMonitoringSubscriptionOutput,
    crate::error::CreateMonitoringSubscriptionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_monitoring_subscription_output::Builder::default();
        let _ = response;
        output = output.set_monitoring_subscription(
            crate::http_serde::deser_payload_create_monitoring_subscription_create_monitoring_subscription_output_monitoring_subscription(response.body().as_ref())?
        );
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_origin_access_control_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateOriginAccessControlOutput,
    crate::error::CreateOriginAccessControlError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateOriginAccessControlError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::CreateOriginAccessControlError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidArgument" => crate::error::CreateOriginAccessControlError::InvalidArgument({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_argument::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_invalid_argument_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateOriginAccessControlError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "OriginAccessControlAlreadyExists" => {
            crate::error::CreateOriginAccessControlError::OriginAccessControlAlreadyExists({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::origin_access_control_already_exists::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_origin_access_control_already_exists_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateOriginAccessControlError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "TooManyOriginAccessControls" => {
            crate::error::CreateOriginAccessControlError::TooManyOriginAccessControls({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::too_many_origin_access_controls::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_origin_access_controls_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateOriginAccessControlError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::CreateOriginAccessControlError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_origin_access_control_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateOriginAccessControlOutput,
    crate::error::CreateOriginAccessControlError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_origin_access_control_output::Builder::default();
        let _ = response;
        output = output.set_e_tag(
            crate::http_serde::deser_header_create_origin_access_control_create_origin_access_control_output_e_tag(response.headers())
                                    .map_err(|_|crate::error::CreateOriginAccessControlError::unhandled("Failed to parse ETag from header `ETag"))?
        );
        output = output.set_location(
            crate::http_serde::deser_header_create_origin_access_control_create_origin_access_control_output_location(response.headers())
                                    .map_err(|_|crate::error::CreateOriginAccessControlError::unhandled("Failed to parse Location from header `Location"))?
        );
        output = output.set_origin_access_control(
            crate::http_serde::deser_payload_create_origin_access_control_create_origin_access_control_output_origin_access_control(response.body().as_ref())?
        );
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_origin_request_policy_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateOriginRequestPolicyOutput,
    crate::error::CreateOriginRequestPolicyError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateOriginRequestPolicyError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::CreateOriginRequestPolicyError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AccessDenied" => crate::error::CreateOriginRequestPolicyError::AccessDenied({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::access_denied::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_access_denied_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateOriginRequestPolicyError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InconsistentQuantities" => {
            crate::error::CreateOriginRequestPolicyError::InconsistentQuantities({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::inconsistent_quantities::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_inconsistent_quantities_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateOriginRequestPolicyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidArgument" => crate::error::CreateOriginRequestPolicyError::InvalidArgument({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_argument::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_invalid_argument_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateOriginRequestPolicyError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "OriginRequestPolicyAlreadyExists" => {
            crate::error::CreateOriginRequestPolicyError::OriginRequestPolicyAlreadyExists({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::origin_request_policy_already_exists::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_origin_request_policy_already_exists_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateOriginRequestPolicyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "TooManyCookiesInOriginRequestPolicy" => {
            crate::error::CreateOriginRequestPolicyError::TooManyCookiesInOriginRequestPolicy({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::too_many_cookies_in_origin_request_policy::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_cookies_in_origin_request_policy_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateOriginRequestPolicyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "TooManyHeadersInOriginRequestPolicy" => {
            crate::error::CreateOriginRequestPolicyError::TooManyHeadersInOriginRequestPolicy({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::too_many_headers_in_origin_request_policy::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_headers_in_origin_request_policy_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateOriginRequestPolicyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "TooManyOriginRequestPolicies" => {
            crate::error::CreateOriginRequestPolicyError::TooManyOriginRequestPolicies({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::too_many_origin_request_policies::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_origin_request_policies_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateOriginRequestPolicyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "TooManyQueryStringsInOriginRequestPolicy" => {
            crate::error::CreateOriginRequestPolicyError::TooManyQueryStringsInOriginRequestPolicy(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                    let mut output = crate::error::too_many_query_strings_in_origin_request_policy::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_crate_error_too_many_query_strings_in_origin_request_policy_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateOriginRequestPolicyError::unhandled)?;
                        let output = output.meta(generic);
                        output.build()
                    };
                    if tmp.message.is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            )
        }
        _ => crate::error::CreateOriginRequestPolicyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_origin_request_policy_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateOriginRequestPolicyOutput,
    crate::error::CreateOriginRequestPolicyError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_origin_request_policy_output::Builder::default();
        let _ = response;
        output = output.set_e_tag(
            crate::http_serde::deser_header_create_origin_request_policy_create_origin_request_policy_output_e_tag(response.headers())
                                    .map_err(|_|crate::error::CreateOriginRequestPolicyError::unhandled("Failed to parse ETag from header `ETag"))?
        );
        output = output.set_location(
            crate::http_serde::deser_header_create_origin_request_policy_create_origin_request_policy_output_location(response.headers())
                                    .map_err(|_|crate::error::CreateOriginRequestPolicyError::unhandled("Failed to parse Location from header `Location"))?
        );
        output = output.set_origin_request_policy(
            crate::http_serde::deser_payload_create_origin_request_policy_create_origin_request_policy_output_origin_request_policy(response.body().as_ref())?
        );
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_public_key_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreatePublicKeyOutput, crate::error::CreatePublicKeyError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreatePublicKeyError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreatePublicKeyError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidArgument" => crate::error::CreatePublicKeyError::InvalidArgument({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_argument::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_invalid_argument_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreatePublicKeyError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "PublicKeyAlreadyExists" => crate::error::CreatePublicKeyError::PublicKeyAlreadyExists({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::public_key_already_exists::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_public_key_already_exists_xml_err(response.body().as_ref(), output).map_err(crate::error::CreatePublicKeyError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "TooManyPublicKeys" => crate::error::CreatePublicKeyError::TooManyPublicKeys({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_public_keys::Builder::default();
                let _ = response;
                output =
                    crate::xml_deser::deser_structure_crate_error_too_many_public_keys_xml_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreatePublicKeyError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::CreatePublicKeyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_public_key_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreatePublicKeyOutput, crate::error::CreatePublicKeyError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_public_key_output::Builder::default();
        let _ = response;
        output = output.set_e_tag(
            crate::http_serde::deser_header_create_public_key_create_public_key_output_e_tag(
                response.headers(),
            )
            .map_err(|_| {
                crate::error::CreatePublicKeyError::unhandled(
                    "Failed to parse ETag from header `ETag",
                )
            })?,
        );
        output = output.set_location(
            crate::http_serde::deser_header_create_public_key_create_public_key_output_location(
                response.headers(),
            )
            .map_err(|_| {
                crate::error::CreatePublicKeyError::unhandled(
                    "Failed to parse Location from header `Location",
                )
            })?,
        );
        output = output.set_public_key(
            crate::http_serde::deser_payload_create_public_key_create_public_key_output_public_key(
                response.body().as_ref(),
            )?,
        );
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_realtime_log_config_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateRealtimeLogConfigOutput,
    crate::error::CreateRealtimeLogConfigError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateRealtimeLogConfigError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::CreateRealtimeLogConfigError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AccessDenied" => crate::error::CreateRealtimeLogConfigError::AccessDenied({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::access_denied::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_access_denied_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateRealtimeLogConfigError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidArgument" => crate::error::CreateRealtimeLogConfigError::InvalidArgument({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_argument::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_invalid_argument_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateRealtimeLogConfigError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "RealtimeLogConfigAlreadyExists" => {
            crate::error::CreateRealtimeLogConfigError::RealtimeLogConfigAlreadyExists({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::realtime_log_config_already_exists::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_realtime_log_config_already_exists_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateRealtimeLogConfigError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "TooManyRealtimeLogConfigs" => {
            crate::error::CreateRealtimeLogConfigError::TooManyRealtimeLogConfigs({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::too_many_realtime_log_configs::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_realtime_log_configs_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateRealtimeLogConfigError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::CreateRealtimeLogConfigError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_realtime_log_config_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateRealtimeLogConfigOutput,
    crate::error::CreateRealtimeLogConfigError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_realtime_log_config_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_realtime_log_config(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateRealtimeLogConfigError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_response_headers_policy_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateResponseHeadersPolicyOutput,
    crate::error::CreateResponseHeadersPolicyError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateResponseHeadersPolicyError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::CreateResponseHeadersPolicyError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AccessDenied" => crate::error::CreateResponseHeadersPolicyError::AccessDenied({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::access_denied::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_access_denied_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateResponseHeadersPolicyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InconsistentQuantities" => crate::error::CreateResponseHeadersPolicyError::InconsistentQuantities({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::inconsistent_quantities::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_inconsistent_quantities_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateResponseHeadersPolicyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidArgument" => crate::error::CreateResponseHeadersPolicyError::InvalidArgument({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_argument::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_argument_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateResponseHeadersPolicyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "ResponseHeadersPolicyAlreadyExists" => crate::error::CreateResponseHeadersPolicyError::ResponseHeadersPolicyAlreadyExists({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::response_headers_policy_already_exists::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_response_headers_policy_already_exists_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateResponseHeadersPolicyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooLongCSPInResponseHeadersPolicy" => crate::error::CreateResponseHeadersPolicyError::TooLongCspInResponseHeadersPolicy({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_long_csp_in_response_headers_policy::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_long_csp_in_response_headers_policy_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateResponseHeadersPolicyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyCustomHeadersInResponseHeadersPolicy" => crate::error::CreateResponseHeadersPolicyError::TooManyCustomHeadersInResponseHeadersPolicy({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_custom_headers_in_response_headers_policy::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_custom_headers_in_response_headers_policy_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateResponseHeadersPolicyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyRemoveHeadersInResponseHeadersPolicy" => crate::error::CreateResponseHeadersPolicyError::TooManyRemoveHeadersInResponseHeadersPolicy({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_remove_headers_in_response_headers_policy::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_remove_headers_in_response_headers_policy_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateResponseHeadersPolicyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyResponseHeadersPolicies" => crate::error::CreateResponseHeadersPolicyError::TooManyResponseHeadersPolicies({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_response_headers_policies::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_response_headers_policies_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateResponseHeadersPolicyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::CreateResponseHeadersPolicyError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_response_headers_policy_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateResponseHeadersPolicyOutput,
    crate::error::CreateResponseHeadersPolicyError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_response_headers_policy_output::Builder::default();
        let _ = response;
        output = output.set_e_tag(
            crate::http_serde::deser_header_create_response_headers_policy_create_response_headers_policy_output_e_tag(response.headers())
                                    .map_err(|_|crate::error::CreateResponseHeadersPolicyError::unhandled("Failed to parse ETag from header `ETag"))?
        );
        output = output.set_location(
            crate::http_serde::deser_header_create_response_headers_policy_create_response_headers_policy_output_location(response.headers())
                                    .map_err(|_|crate::error::CreateResponseHeadersPolicyError::unhandled("Failed to parse Location from header `Location"))?
        );
        output = output.set_response_headers_policy(
            crate::http_serde::deser_payload_create_response_headers_policy_create_response_headers_policy_output_response_headers_policy(response.body().as_ref())?
        );
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_streaming_distribution_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateStreamingDistributionOutput,
    crate::error::CreateStreamingDistributionError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateStreamingDistributionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::CreateStreamingDistributionError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AccessDenied" => crate::error::CreateStreamingDistributionError::AccessDenied({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::access_denied::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_access_denied_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateStreamingDistributionError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "CNAMEAlreadyExists" => {
            crate::error::CreateStreamingDistributionError::CnameAlreadyExists({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::cname_already_exists::Builder::default();
                    let _ = response;
                    output =
                        crate::xml_deser::deser_structure_crate_error_cname_already_exists_xml_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::CreateStreamingDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InconsistentQuantities" => {
            crate::error::CreateStreamingDistributionError::InconsistentQuantities({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::inconsistent_quantities::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_inconsistent_quantities_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateStreamingDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidArgument" => crate::error::CreateStreamingDistributionError::InvalidArgument({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_argument::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_invalid_argument_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateStreamingDistributionError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidOrigin" => crate::error::CreateStreamingDistributionError::InvalidOrigin({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_origin::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_invalid_origin_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateStreamingDistributionError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidOriginAccessControl" => {
            crate::error::CreateStreamingDistributionError::InvalidOriginAccessControl({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_origin_access_control::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_origin_access_control_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateStreamingDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidOriginAccessIdentity" => {
            crate::error::CreateStreamingDistributionError::InvalidOriginAccessIdentity({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_origin_access_identity::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_origin_access_identity_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateStreamingDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "MissingBody" => crate::error::CreateStreamingDistributionError::MissingBody({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::missing_body::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_missing_body_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateStreamingDistributionError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "StreamingDistributionAlreadyExists" => {
            crate::error::CreateStreamingDistributionError::StreamingDistributionAlreadyExists({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::streaming_distribution_already_exists::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_streaming_distribution_already_exists_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateStreamingDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "TooManyStreamingDistributionCNAMEs" => {
            crate::error::CreateStreamingDistributionError::TooManyStreamingDistributionCnamEs({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::too_many_streaming_distribution_cnam_es::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_streaming_distribution_cnam_es_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateStreamingDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "TooManyStreamingDistributions" => {
            crate::error::CreateStreamingDistributionError::TooManyStreamingDistributions({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::too_many_streaming_distributions::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_streaming_distributions_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateStreamingDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "TooManyTrustedSigners" => {
            crate::error::CreateStreamingDistributionError::TooManyTrustedSigners({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_trusted_signers::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_trusted_signers_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateStreamingDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "TrustedSignerDoesNotExist" => {
            crate::error::CreateStreamingDistributionError::TrustedSignerDoesNotExist({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::trusted_signer_does_not_exist::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_trusted_signer_does_not_exist_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateStreamingDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::CreateStreamingDistributionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_streaming_distribution_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateStreamingDistributionOutput,
    crate::error::CreateStreamingDistributionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_streaming_distribution_output::Builder::default();
        let _ = response;
        output = output.set_e_tag(
            crate::http_serde::deser_header_create_streaming_distribution_create_streaming_distribution_output_e_tag(response.headers())
                                    .map_err(|_|crate::error::CreateStreamingDistributionError::unhandled("Failed to parse ETag from header `ETag"))?
        );
        output = output.set_location(
            crate::http_serde::deser_header_create_streaming_distribution_create_streaming_distribution_output_location(response.headers())
                                    .map_err(|_|crate::error::CreateStreamingDistributionError::unhandled("Failed to parse Location from header `Location"))?
        );
        output = output.set_streaming_distribution(
            crate::http_serde::deser_payload_create_streaming_distribution_create_streaming_distribution_output_streaming_distribution(response.body().as_ref())?
        );
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_streaming_distribution_with_tags_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateStreamingDistributionWithTagsOutput,
    crate::error::CreateStreamingDistributionWithTagsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateStreamingDistributionWithTagsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::CreateStreamingDistributionWithTagsError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AccessDenied" => crate::error::CreateStreamingDistributionWithTagsError::AccessDenied({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::access_denied::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_access_denied_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateStreamingDistributionWithTagsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "CNAMEAlreadyExists" => crate::error::CreateStreamingDistributionWithTagsError::CnameAlreadyExists({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::cname_already_exists::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_cname_already_exists_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateStreamingDistributionWithTagsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InconsistentQuantities" => crate::error::CreateStreamingDistributionWithTagsError::InconsistentQuantities({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::inconsistent_quantities::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_inconsistent_quantities_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateStreamingDistributionWithTagsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidArgument" => crate::error::CreateStreamingDistributionWithTagsError::InvalidArgument({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_argument::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_argument_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateStreamingDistributionWithTagsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidOrigin" => crate::error::CreateStreamingDistributionWithTagsError::InvalidOrigin({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_origin::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_origin_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateStreamingDistributionWithTagsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidOriginAccessControl" => crate::error::CreateStreamingDistributionWithTagsError::InvalidOriginAccessControl({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_origin_access_control::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_origin_access_control_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateStreamingDistributionWithTagsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidOriginAccessIdentity" => crate::error::CreateStreamingDistributionWithTagsError::InvalidOriginAccessIdentity({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_origin_access_identity::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_origin_access_identity_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateStreamingDistributionWithTagsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidTagging" => crate::error::CreateStreamingDistributionWithTagsError::InvalidTagging({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_tagging::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_tagging_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateStreamingDistributionWithTagsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "MissingBody" => crate::error::CreateStreamingDistributionWithTagsError::MissingBody({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::missing_body::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_missing_body_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateStreamingDistributionWithTagsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "StreamingDistributionAlreadyExists" => crate::error::CreateStreamingDistributionWithTagsError::StreamingDistributionAlreadyExists({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::streaming_distribution_already_exists::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_streaming_distribution_already_exists_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateStreamingDistributionWithTagsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyStreamingDistributionCNAMEs" => crate::error::CreateStreamingDistributionWithTagsError::TooManyStreamingDistributionCnamEs({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_streaming_distribution_cnam_es::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_streaming_distribution_cnam_es_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateStreamingDistributionWithTagsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyStreamingDistributions" => crate::error::CreateStreamingDistributionWithTagsError::TooManyStreamingDistributions({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_streaming_distributions::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_streaming_distributions_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateStreamingDistributionWithTagsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyTrustedSigners" => crate::error::CreateStreamingDistributionWithTagsError::TooManyTrustedSigners({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_trusted_signers::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_trusted_signers_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateStreamingDistributionWithTagsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TrustedSignerDoesNotExist" => crate::error::CreateStreamingDistributionWithTagsError::TrustedSignerDoesNotExist({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::trusted_signer_does_not_exist::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_trusted_signer_does_not_exist_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateStreamingDistributionWithTagsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::CreateStreamingDistributionWithTagsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_streaming_distribution_with_tags_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateStreamingDistributionWithTagsOutput,
    crate::error::CreateStreamingDistributionWithTagsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::create_streaming_distribution_with_tags_output::Builder::default();
        let _ = response;
        output = output.set_e_tag(
            crate::http_serde::deser_header_create_streaming_distribution_with_tags_create_streaming_distribution_with_tags_output_e_tag(response.headers())
                                    .map_err(|_|crate::error::CreateStreamingDistributionWithTagsError::unhandled("Failed to parse ETag from header `ETag"))?
        );
        output = output.set_location(
            crate::http_serde::deser_header_create_streaming_distribution_with_tags_create_streaming_distribution_with_tags_output_location(response.headers())
                                    .map_err(|_|crate::error::CreateStreamingDistributionWithTagsError::unhandled("Failed to parse Location from header `Location"))?
        );
        output = output.set_streaming_distribution(
            crate::http_serde::deser_payload_create_streaming_distribution_with_tags_create_streaming_distribution_with_tags_output_streaming_distribution(response.body().as_ref())?
        );
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_cache_policy_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteCachePolicyOutput, crate::error::DeleteCachePolicyError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteCachePolicyError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteCachePolicyError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AccessDenied" => crate::error::DeleteCachePolicyError::AccessDenied({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::access_denied::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_access_denied_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteCachePolicyError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "CachePolicyInUse" => crate::error::DeleteCachePolicyError::CachePolicyInUse({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::cache_policy_in_use::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_cache_policy_in_use_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteCachePolicyError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "IllegalDelete" => crate::error::DeleteCachePolicyError::IllegalDelete({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::illegal_delete::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_illegal_delete_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteCachePolicyError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidIfMatchVersion" => {
            crate::error::DeleteCachePolicyError::InvalidIfMatchVersion({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_if_match_version::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_if_match_version_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteCachePolicyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "NoSuchCachePolicy" => crate::error::DeleteCachePolicyError::NoSuchCachePolicy({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_cache_policy::Builder::default();
                let _ = response;
                output =
                    crate::xml_deser::deser_structure_crate_error_no_such_cache_policy_xml_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DeleteCachePolicyError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "PreconditionFailed" => crate::error::DeleteCachePolicyError::PreconditionFailed({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::precondition_failed::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_precondition_failed_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteCachePolicyError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::DeleteCachePolicyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_cache_policy_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteCachePolicyOutput, crate::error::DeleteCachePolicyError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_cache_policy_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_cloud_front_origin_access_identity_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteCloudFrontOriginAccessIdentityOutput,
    crate::error::DeleteCloudFrontOriginAccessIdentityError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteCloudFrontOriginAccessIdentityError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DeleteCloudFrontOriginAccessIdentityError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AccessDenied" => crate::error::DeleteCloudFrontOriginAccessIdentityError::AccessDenied({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::access_denied::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_access_denied_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteCloudFrontOriginAccessIdentityError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "CloudFrontOriginAccessIdentityInUse" => crate::error::DeleteCloudFrontOriginAccessIdentityError::CloudFrontOriginAccessIdentityInUse({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::cloud_front_origin_access_identity_in_use::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_cloud_front_origin_access_identity_in_use_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteCloudFrontOriginAccessIdentityError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidIfMatchVersion" => crate::error::DeleteCloudFrontOriginAccessIdentityError::InvalidIfMatchVersion({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_if_match_version::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_if_match_version_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteCloudFrontOriginAccessIdentityError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "NoSuchCloudFrontOriginAccessIdentity" => crate::error::DeleteCloudFrontOriginAccessIdentityError::NoSuchCloudFrontOriginAccessIdentity({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_cloud_front_origin_access_identity::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_cloud_front_origin_access_identity_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteCloudFrontOriginAccessIdentityError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "PreconditionFailed" => crate::error::DeleteCloudFrontOriginAccessIdentityError::PreconditionFailed({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::precondition_failed::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_precondition_failed_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteCloudFrontOriginAccessIdentityError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::DeleteCloudFrontOriginAccessIdentityError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_cloud_front_origin_access_identity_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteCloudFrontOriginAccessIdentityOutput,
    crate::error::DeleteCloudFrontOriginAccessIdentityError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::delete_cloud_front_origin_access_identity_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_continuous_deployment_policy_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteContinuousDeploymentPolicyOutput,
    crate::error::DeleteContinuousDeploymentPolicyError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteContinuousDeploymentPolicyError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DeleteContinuousDeploymentPolicyError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AccessDenied" => crate::error::DeleteContinuousDeploymentPolicyError::AccessDenied({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::access_denied::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_access_denied_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteContinuousDeploymentPolicyError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "ContinuousDeploymentPolicyInUse" => {
            crate::error::DeleteContinuousDeploymentPolicyError::ContinuousDeploymentPolicyInUse({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::continuous_deployment_policy_in_use::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_continuous_deployment_policy_in_use_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteContinuousDeploymentPolicyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidArgument" => {
            crate::error::DeleteContinuousDeploymentPolicyError::InvalidArgument({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_argument::Builder::default();
                    let _ = response;
                    output =
                        crate::xml_deser::deser_structure_crate_error_invalid_argument_xml_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::DeleteContinuousDeploymentPolicyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidIfMatchVersion" => {
            crate::error::DeleteContinuousDeploymentPolicyError::InvalidIfMatchVersion({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_if_match_version::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_if_match_version_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteContinuousDeploymentPolicyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "NoSuchContinuousDeploymentPolicy" => {
            crate::error::DeleteContinuousDeploymentPolicyError::NoSuchContinuousDeploymentPolicy({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::no_such_continuous_deployment_policy::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_continuous_deployment_policy_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteContinuousDeploymentPolicyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "PreconditionFailed" => {
            crate::error::DeleteContinuousDeploymentPolicyError::PreconditionFailed({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::precondition_failed::Builder::default();
                    let _ = response;
                    output =
                        crate::xml_deser::deser_structure_crate_error_precondition_failed_xml_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::DeleteContinuousDeploymentPolicyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::DeleteContinuousDeploymentPolicyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_continuous_deployment_policy_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteContinuousDeploymentPolicyOutput,
    crate::error::DeleteContinuousDeploymentPolicyError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::delete_continuous_deployment_policy_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_distribution_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteDistributionOutput,
    crate::error::DeleteDistributionError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteDistributionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteDistributionError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AccessDenied" => crate::error::DeleteDistributionError::AccessDenied({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::access_denied::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_access_denied_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteDistributionError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "DistributionNotDisabled" => {
            crate::error::DeleteDistributionError::DistributionNotDisabled({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::distribution_not_disabled::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_distribution_not_disabled_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidIfMatchVersion" => {
            crate::error::DeleteDistributionError::InvalidIfMatchVersion({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_if_match_version::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_if_match_version_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "NoSuchDistribution" => crate::error::DeleteDistributionError::NoSuchDistribution({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_distribution::Builder::default();
                let _ = response;
                output =
                    crate::xml_deser::deser_structure_crate_error_no_such_distribution_xml_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DeleteDistributionError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "PreconditionFailed" => crate::error::DeleteDistributionError::PreconditionFailed({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::precondition_failed::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_precondition_failed_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteDistributionError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::DeleteDistributionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_distribution_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteDistributionOutput,
    crate::error::DeleteDistributionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_distribution_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_field_level_encryption_config_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteFieldLevelEncryptionConfigOutput,
    crate::error::DeleteFieldLevelEncryptionConfigError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteFieldLevelEncryptionConfigError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DeleteFieldLevelEncryptionConfigError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AccessDenied" => crate::error::DeleteFieldLevelEncryptionConfigError::AccessDenied({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::access_denied::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_access_denied_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteFieldLevelEncryptionConfigError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "FieldLevelEncryptionConfigInUse" => {
            crate::error::DeleteFieldLevelEncryptionConfigError::FieldLevelEncryptionConfigInUse({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::field_level_encryption_config_in_use::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_field_level_encryption_config_in_use_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteFieldLevelEncryptionConfigError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidIfMatchVersion" => {
            crate::error::DeleteFieldLevelEncryptionConfigError::InvalidIfMatchVersion({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_if_match_version::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_if_match_version_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteFieldLevelEncryptionConfigError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "NoSuchFieldLevelEncryptionConfig" => {
            crate::error::DeleteFieldLevelEncryptionConfigError::NoSuchFieldLevelEncryptionConfig({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::no_such_field_level_encryption_config::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_field_level_encryption_config_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteFieldLevelEncryptionConfigError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "PreconditionFailed" => {
            crate::error::DeleteFieldLevelEncryptionConfigError::PreconditionFailed({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::precondition_failed::Builder::default();
                    let _ = response;
                    output =
                        crate::xml_deser::deser_structure_crate_error_precondition_failed_xml_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::DeleteFieldLevelEncryptionConfigError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::DeleteFieldLevelEncryptionConfigError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_field_level_encryption_config_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteFieldLevelEncryptionConfigOutput,
    crate::error::DeleteFieldLevelEncryptionConfigError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::delete_field_level_encryption_config_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_field_level_encryption_profile_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteFieldLevelEncryptionProfileOutput,
    crate::error::DeleteFieldLevelEncryptionProfileError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteFieldLevelEncryptionProfileError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DeleteFieldLevelEncryptionProfileError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AccessDenied" => crate::error::DeleteFieldLevelEncryptionProfileError::AccessDenied({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::access_denied::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_access_denied_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteFieldLevelEncryptionProfileError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "FieldLevelEncryptionProfileInUse" => {
            crate::error::DeleteFieldLevelEncryptionProfileError::FieldLevelEncryptionProfileInUse(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::field_level_encryption_profile_in_use::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_crate_error_field_level_encryption_profile_in_use_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteFieldLevelEncryptionProfileError::unhandled)?;
                        let output = output.meta(generic);
                        output.build()
                    };
                    if tmp.message.is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            )
        }
        "InvalidIfMatchVersion" => {
            crate::error::DeleteFieldLevelEncryptionProfileError::InvalidIfMatchVersion({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_if_match_version::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_if_match_version_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteFieldLevelEncryptionProfileError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "NoSuchFieldLevelEncryptionProfile" => {
            crate::error::DeleteFieldLevelEncryptionProfileError::NoSuchFieldLevelEncryptionProfile(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::no_such_field_level_encryption_profile::Builder::default(
                            );
                        let _ = response;
                        output = crate::xml_deser::deser_structure_crate_error_no_such_field_level_encryption_profile_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteFieldLevelEncryptionProfileError::unhandled)?;
                        let output = output.meta(generic);
                        output.build()
                    };
                    if tmp.message.is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            )
        }
        "PreconditionFailed" => {
            crate::error::DeleteFieldLevelEncryptionProfileError::PreconditionFailed({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::precondition_failed::Builder::default();
                    let _ = response;
                    output =
                        crate::xml_deser::deser_structure_crate_error_precondition_failed_xml_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::DeleteFieldLevelEncryptionProfileError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::DeleteFieldLevelEncryptionProfileError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_field_level_encryption_profile_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteFieldLevelEncryptionProfileOutput,
    crate::error::DeleteFieldLevelEncryptionProfileError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::delete_field_level_encryption_profile_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_function_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteFunctionOutput, crate::error::DeleteFunctionError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteFunctionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteFunctionError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "FunctionInUse" => crate::error::DeleteFunctionError::FunctionInUse({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::function_in_use::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_function_in_use_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteFunctionError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidIfMatchVersion" => {
            crate::error::DeleteFunctionError::InvalidIfMatchVersion({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_if_match_version::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_if_match_version_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteFunctionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "NoSuchFunctionExists" => {
            crate::error::DeleteFunctionError::NoSuchFunctionExists({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_function_exists::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_function_exists_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteFunctionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "PreconditionFailed" => crate::error::DeleteFunctionError::PreconditionFailed({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::precondition_failed::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_precondition_failed_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteFunctionError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "UnsupportedOperation" => {
            crate::error::DeleteFunctionError::UnsupportedOperation({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unsupported_operation::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_unsupported_operation_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteFunctionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::DeleteFunctionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_function_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteFunctionOutput, crate::error::DeleteFunctionError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_function_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_key_group_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteKeyGroupOutput, crate::error::DeleteKeyGroupError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteKeyGroupError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteKeyGroupError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidIfMatchVersion" => {
            crate::error::DeleteKeyGroupError::InvalidIfMatchVersion({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_if_match_version::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_if_match_version_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteKeyGroupError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "NoSuchResource" => crate::error::DeleteKeyGroupError::NoSuchResource({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_resource::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_no_such_resource_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteKeyGroupError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "PreconditionFailed" => crate::error::DeleteKeyGroupError::PreconditionFailed({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::precondition_failed::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_precondition_failed_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteKeyGroupError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "ResourceInUse" => crate::error::DeleteKeyGroupError::ResourceInUse({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_in_use::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_resource_in_use_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteKeyGroupError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::DeleteKeyGroupError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_key_group_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteKeyGroupOutput, crate::error::DeleteKeyGroupError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_key_group_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_monitoring_subscription_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteMonitoringSubscriptionOutput,
    crate::error::DeleteMonitoringSubscriptionError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteMonitoringSubscriptionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DeleteMonitoringSubscriptionError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AccessDenied" => crate::error::DeleteMonitoringSubscriptionError::AccessDenied({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::access_denied::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_access_denied_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteMonitoringSubscriptionError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NoSuchDistribution" => {
            crate::error::DeleteMonitoringSubscriptionError::NoSuchDistribution({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_distribution::Builder::default();
                    let _ = response;
                    output =
                        crate::xml_deser::deser_structure_crate_error_no_such_distribution_xml_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::DeleteMonitoringSubscriptionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "NoSuchMonitoringSubscription" => {
            crate::error::DeleteMonitoringSubscriptionError::NoSuchMonitoringSubscription({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::no_such_monitoring_subscription::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_monitoring_subscription_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteMonitoringSubscriptionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "UnsupportedOperation" => {
            crate::error::DeleteMonitoringSubscriptionError::UnsupportedOperation({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unsupported_operation::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_unsupported_operation_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteMonitoringSubscriptionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::DeleteMonitoringSubscriptionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_monitoring_subscription_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteMonitoringSubscriptionOutput,
    crate::error::DeleteMonitoringSubscriptionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_monitoring_subscription_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_origin_access_control_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteOriginAccessControlOutput,
    crate::error::DeleteOriginAccessControlError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteOriginAccessControlError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DeleteOriginAccessControlError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AccessDenied" => crate::error::DeleteOriginAccessControlError::AccessDenied({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::access_denied::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_access_denied_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteOriginAccessControlError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidIfMatchVersion" => {
            crate::error::DeleteOriginAccessControlError::InvalidIfMatchVersion({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_if_match_version::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_if_match_version_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteOriginAccessControlError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "NoSuchOriginAccessControl" => {
            crate::error::DeleteOriginAccessControlError::NoSuchOriginAccessControl({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::no_such_origin_access_control::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_origin_access_control_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteOriginAccessControlError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "OriginAccessControlInUse" => {
            crate::error::DeleteOriginAccessControlError::OriginAccessControlInUse({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::origin_access_control_in_use::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_origin_access_control_in_use_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteOriginAccessControlError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "PreconditionFailed" => crate::error::DeleteOriginAccessControlError::PreconditionFailed({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::precondition_failed::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_precondition_failed_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteOriginAccessControlError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::DeleteOriginAccessControlError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_origin_access_control_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteOriginAccessControlOutput,
    crate::error::DeleteOriginAccessControlError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_origin_access_control_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_origin_request_policy_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteOriginRequestPolicyOutput,
    crate::error::DeleteOriginRequestPolicyError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteOriginRequestPolicyError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DeleteOriginRequestPolicyError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AccessDenied" => crate::error::DeleteOriginRequestPolicyError::AccessDenied({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::access_denied::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_access_denied_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteOriginRequestPolicyError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "IllegalDelete" => crate::error::DeleteOriginRequestPolicyError::IllegalDelete({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::illegal_delete::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_illegal_delete_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteOriginRequestPolicyError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidIfMatchVersion" => {
            crate::error::DeleteOriginRequestPolicyError::InvalidIfMatchVersion({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_if_match_version::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_if_match_version_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteOriginRequestPolicyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "NoSuchOriginRequestPolicy" => {
            crate::error::DeleteOriginRequestPolicyError::NoSuchOriginRequestPolicy({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::no_such_origin_request_policy::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_origin_request_policy_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteOriginRequestPolicyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "OriginRequestPolicyInUse" => {
            crate::error::DeleteOriginRequestPolicyError::OriginRequestPolicyInUse({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::origin_request_policy_in_use::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_origin_request_policy_in_use_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteOriginRequestPolicyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "PreconditionFailed" => crate::error::DeleteOriginRequestPolicyError::PreconditionFailed({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::precondition_failed::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_precondition_failed_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteOriginRequestPolicyError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::DeleteOriginRequestPolicyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_origin_request_policy_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteOriginRequestPolicyOutput,
    crate::error::DeleteOriginRequestPolicyError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_origin_request_policy_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_public_key_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeletePublicKeyOutput, crate::error::DeletePublicKeyError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeletePublicKeyError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeletePublicKeyError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AccessDenied" => crate::error::DeletePublicKeyError::AccessDenied({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::access_denied::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_access_denied_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeletePublicKeyError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidIfMatchVersion" => {
            crate::error::DeletePublicKeyError::InvalidIfMatchVersion({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_if_match_version::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_if_match_version_xml_err(response.body().as_ref(), output).map_err(crate::error::DeletePublicKeyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "NoSuchPublicKey" => crate::error::DeletePublicKeyError::NoSuchPublicKey({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_public_key::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_no_such_public_key_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeletePublicKeyError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "PreconditionFailed" => crate::error::DeletePublicKeyError::PreconditionFailed({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::precondition_failed::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_precondition_failed_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeletePublicKeyError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "PublicKeyInUse" => crate::error::DeletePublicKeyError::PublicKeyInUse({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::public_key_in_use::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_public_key_in_use_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeletePublicKeyError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::DeletePublicKeyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_public_key_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeletePublicKeyOutput, crate::error::DeletePublicKeyError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_public_key_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_realtime_log_config_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteRealtimeLogConfigOutput,
    crate::error::DeleteRealtimeLogConfigError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteRealtimeLogConfigError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DeleteRealtimeLogConfigError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AccessDenied" => crate::error::DeleteRealtimeLogConfigError::AccessDenied({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::access_denied::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_access_denied_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteRealtimeLogConfigError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidArgument" => crate::error::DeleteRealtimeLogConfigError::InvalidArgument({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_argument::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_invalid_argument_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteRealtimeLogConfigError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NoSuchRealtimeLogConfig" => {
            crate::error::DeleteRealtimeLogConfigError::NoSuchRealtimeLogConfig({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_realtime_log_config::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_realtime_log_config_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteRealtimeLogConfigError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "RealtimeLogConfigInUse" => {
            crate::error::DeleteRealtimeLogConfigError::RealtimeLogConfigInUse({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::realtime_log_config_in_use::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_realtime_log_config_in_use_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteRealtimeLogConfigError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::DeleteRealtimeLogConfigError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_realtime_log_config_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteRealtimeLogConfigOutput,
    crate::error::DeleteRealtimeLogConfigError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_realtime_log_config_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_response_headers_policy_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteResponseHeadersPolicyOutput,
    crate::error::DeleteResponseHeadersPolicyError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteResponseHeadersPolicyError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DeleteResponseHeadersPolicyError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AccessDenied" => crate::error::DeleteResponseHeadersPolicyError::AccessDenied({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::access_denied::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_access_denied_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteResponseHeadersPolicyError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "IllegalDelete" => crate::error::DeleteResponseHeadersPolicyError::IllegalDelete({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::illegal_delete::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_illegal_delete_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteResponseHeadersPolicyError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidIfMatchVersion" => {
            crate::error::DeleteResponseHeadersPolicyError::InvalidIfMatchVersion({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_if_match_version::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_if_match_version_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteResponseHeadersPolicyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "NoSuchResponseHeadersPolicy" => {
            crate::error::DeleteResponseHeadersPolicyError::NoSuchResponseHeadersPolicy({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::no_such_response_headers_policy::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_response_headers_policy_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteResponseHeadersPolicyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "PreconditionFailed" => {
            crate::error::DeleteResponseHeadersPolicyError::PreconditionFailed({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::precondition_failed::Builder::default();
                    let _ = response;
                    output =
                        crate::xml_deser::deser_structure_crate_error_precondition_failed_xml_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::DeleteResponseHeadersPolicyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ResponseHeadersPolicyInUse" => {
            crate::error::DeleteResponseHeadersPolicyError::ResponseHeadersPolicyInUse({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::response_headers_policy_in_use::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_response_headers_policy_in_use_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteResponseHeadersPolicyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::DeleteResponseHeadersPolicyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_response_headers_policy_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteResponseHeadersPolicyOutput,
    crate::error::DeleteResponseHeadersPolicyError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_response_headers_policy_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_streaming_distribution_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteStreamingDistributionOutput,
    crate::error::DeleteStreamingDistributionError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteStreamingDistributionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DeleteStreamingDistributionError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AccessDenied" => crate::error::DeleteStreamingDistributionError::AccessDenied({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::access_denied::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_access_denied_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteStreamingDistributionError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidIfMatchVersion" => {
            crate::error::DeleteStreamingDistributionError::InvalidIfMatchVersion({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_if_match_version::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_if_match_version_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteStreamingDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "NoSuchStreamingDistribution" => {
            crate::error::DeleteStreamingDistributionError::NoSuchStreamingDistribution({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::no_such_streaming_distribution::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_streaming_distribution_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteStreamingDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "PreconditionFailed" => {
            crate::error::DeleteStreamingDistributionError::PreconditionFailed({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::precondition_failed::Builder::default();
                    let _ = response;
                    output =
                        crate::xml_deser::deser_structure_crate_error_precondition_failed_xml_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::DeleteStreamingDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "StreamingDistributionNotDisabled" => {
            crate::error::DeleteStreamingDistributionError::StreamingDistributionNotDisabled({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::streaming_distribution_not_disabled::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_streaming_distribution_not_disabled_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteStreamingDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::DeleteStreamingDistributionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_streaming_distribution_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteStreamingDistributionOutput,
    crate::error::DeleteStreamingDistributionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_streaming_distribution_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_function_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeFunctionOutput, crate::error::DescribeFunctionError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeFunctionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DescribeFunctionError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "NoSuchFunctionExists" => {
            crate::error::DescribeFunctionError::NoSuchFunctionExists({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_function_exists::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_function_exists_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeFunctionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "UnsupportedOperation" => {
            crate::error::DescribeFunctionError::UnsupportedOperation({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unsupported_operation::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_unsupported_operation_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeFunctionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::DescribeFunctionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_function_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeFunctionOutput, crate::error::DescribeFunctionError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_function_output::Builder::default();
        let _ = response;
        output = output.set_e_tag(
            crate::http_serde::deser_header_describe_function_describe_function_output_e_tag(
                response.headers(),
            )
            .map_err(|_| {
                crate::error::DescribeFunctionError::unhandled(
                    "Failed to parse ETag from header `ETag",
                )
            })?,
        );
        output = output.set_function_summary(
            crate::http_serde::deser_payload_describe_function_describe_function_output_function_summary(response.body().as_ref())?
        );
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_cache_policy_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetCachePolicyOutput, crate::error::GetCachePolicyError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetCachePolicyError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetCachePolicyError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AccessDenied" => crate::error::GetCachePolicyError::AccessDenied({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::access_denied::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_access_denied_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetCachePolicyError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NoSuchCachePolicy" => crate::error::GetCachePolicyError::NoSuchCachePolicy({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_cache_policy::Builder::default();
                let _ = response;
                output =
                    crate::xml_deser::deser_structure_crate_error_no_such_cache_policy_xml_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetCachePolicyError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::GetCachePolicyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_cache_policy_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetCachePolicyOutput, crate::error::GetCachePolicyError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_cache_policy_output::Builder::default();
        let _ = response;
        output = output.set_cache_policy(
            crate::http_serde::deser_payload_get_cache_policy_get_cache_policy_output_cache_policy(
                response.body().as_ref(),
            )?,
        );
        output = output.set_e_tag(
            crate::http_serde::deser_header_get_cache_policy_get_cache_policy_output_e_tag(
                response.headers(),
            )
            .map_err(|_| {
                crate::error::GetCachePolicyError::unhandled(
                    "Failed to parse ETag from header `ETag",
                )
            })?,
        );
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_cache_policy_config_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetCachePolicyConfigOutput,
    crate::error::GetCachePolicyConfigError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetCachePolicyConfigError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetCachePolicyConfigError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AccessDenied" => crate::error::GetCachePolicyConfigError::AccessDenied({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::access_denied::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_access_denied_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetCachePolicyConfigError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NoSuchCachePolicy" => crate::error::GetCachePolicyConfigError::NoSuchCachePolicy({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_cache_policy::Builder::default();
                let _ = response;
                output =
                    crate::xml_deser::deser_structure_crate_error_no_such_cache_policy_xml_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetCachePolicyConfigError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::GetCachePolicyConfigError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_cache_policy_config_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetCachePolicyConfigOutput,
    crate::error::GetCachePolicyConfigError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_cache_policy_config_output::Builder::default();
        let _ = response;
        output = output.set_cache_policy_config(
            crate::http_serde::deser_payload_get_cache_policy_config_get_cache_policy_config_output_cache_policy_config(response.body().as_ref())?
        );
        output = output.set_e_tag(
            crate::http_serde::deser_header_get_cache_policy_config_get_cache_policy_config_output_e_tag(response.headers())
                                    .map_err(|_|crate::error::GetCachePolicyConfigError::unhandled("Failed to parse ETag from header `ETag"))?
        );
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_cloud_front_origin_access_identity_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetCloudFrontOriginAccessIdentityOutput,
    crate::error::GetCloudFrontOriginAccessIdentityError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetCloudFrontOriginAccessIdentityError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::GetCloudFrontOriginAccessIdentityError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AccessDenied" => crate::error::GetCloudFrontOriginAccessIdentityError::AccessDenied({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::access_denied::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_access_denied_xml_err(response.body().as_ref(), output).map_err(crate::error::GetCloudFrontOriginAccessIdentityError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "NoSuchCloudFrontOriginAccessIdentity" => crate::error::GetCloudFrontOriginAccessIdentityError::NoSuchCloudFrontOriginAccessIdentity({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_cloud_front_origin_access_identity::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_cloud_front_origin_access_identity_xml_err(response.body().as_ref(), output).map_err(crate::error::GetCloudFrontOriginAccessIdentityError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::GetCloudFrontOriginAccessIdentityError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_cloud_front_origin_access_identity_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetCloudFrontOriginAccessIdentityOutput,
    crate::error::GetCloudFrontOriginAccessIdentityError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::get_cloud_front_origin_access_identity_output::Builder::default();
        let _ = response;
        output = output.set_cloud_front_origin_access_identity(
            crate::http_serde::deser_payload_get_cloud_front_origin_access_identity_get_cloud_front_origin_access_identity_output_cloud_front_origin_access_identity(response.body().as_ref())?
        );
        output = output.set_e_tag(
            crate::http_serde::deser_header_get_cloud_front_origin_access_identity_get_cloud_front_origin_access_identity_output_e_tag(response.headers())
                                    .map_err(|_|crate::error::GetCloudFrontOriginAccessIdentityError::unhandled("Failed to parse ETag from header `ETag"))?
        );
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_cloud_front_origin_access_identity_config_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetCloudFrontOriginAccessIdentityConfigOutput,
    crate::error::GetCloudFrontOriginAccessIdentityConfigError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetCloudFrontOriginAccessIdentityConfigError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(
                crate::error::GetCloudFrontOriginAccessIdentityConfigError::unhandled(generic),
            )
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AccessDenied" => crate::error::GetCloudFrontOriginAccessIdentityConfigError::AccessDenied({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::access_denied::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_access_denied_xml_err(response.body().as_ref(), output).map_err(crate::error::GetCloudFrontOriginAccessIdentityConfigError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "NoSuchCloudFrontOriginAccessIdentity" => crate::error::GetCloudFrontOriginAccessIdentityConfigError::NoSuchCloudFrontOriginAccessIdentity({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_cloud_front_origin_access_identity::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_cloud_front_origin_access_identity_xml_err(response.body().as_ref(), output).map_err(crate::error::GetCloudFrontOriginAccessIdentityConfigError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::GetCloudFrontOriginAccessIdentityConfigError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_cloud_front_origin_access_identity_config_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetCloudFrontOriginAccessIdentityConfigOutput,
    crate::error::GetCloudFrontOriginAccessIdentityConfigError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::get_cloud_front_origin_access_identity_config_output::Builder::default();
        let _ = response;
        output = output.set_cloud_front_origin_access_identity_config(
            crate::http_serde::deser_payload_get_cloud_front_origin_access_identity_config_get_cloud_front_origin_access_identity_config_output_cloud_front_origin_access_identity_config(response.body().as_ref())?
        );
        output = output.set_e_tag(
            crate::http_serde::deser_header_get_cloud_front_origin_access_identity_config_get_cloud_front_origin_access_identity_config_output_e_tag(response.headers())
                                    .map_err(|_|crate::error::GetCloudFrontOriginAccessIdentityConfigError::unhandled("Failed to parse ETag from header `ETag"))?
        );
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_continuous_deployment_policy_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetContinuousDeploymentPolicyOutput,
    crate::error::GetContinuousDeploymentPolicyError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetContinuousDeploymentPolicyError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::GetContinuousDeploymentPolicyError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AccessDenied" => crate::error::GetContinuousDeploymentPolicyError::AccessDenied({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::access_denied::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_access_denied_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetContinuousDeploymentPolicyError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NoSuchContinuousDeploymentPolicy" => {
            crate::error::GetContinuousDeploymentPolicyError::NoSuchContinuousDeploymentPolicy({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::no_such_continuous_deployment_policy::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_continuous_deployment_policy_xml_err(response.body().as_ref(), output).map_err(crate::error::GetContinuousDeploymentPolicyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::GetContinuousDeploymentPolicyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_continuous_deployment_policy_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetContinuousDeploymentPolicyOutput,
    crate::error::GetContinuousDeploymentPolicyError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_continuous_deployment_policy_output::Builder::default();
        let _ = response;
        output = output.set_continuous_deployment_policy(
            crate::http_serde::deser_payload_get_continuous_deployment_policy_get_continuous_deployment_policy_output_continuous_deployment_policy(response.body().as_ref())?
        );
        output = output.set_e_tag(
            crate::http_serde::deser_header_get_continuous_deployment_policy_get_continuous_deployment_policy_output_e_tag(response.headers())
                                    .map_err(|_|crate::error::GetContinuousDeploymentPolicyError::unhandled("Failed to parse ETag from header `ETag"))?
        );
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_continuous_deployment_policy_config_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetContinuousDeploymentPolicyConfigOutput,
    crate::error::GetContinuousDeploymentPolicyConfigError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetContinuousDeploymentPolicyConfigError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::GetContinuousDeploymentPolicyConfigError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AccessDenied" => crate::error::GetContinuousDeploymentPolicyConfigError::AccessDenied({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::access_denied::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_access_denied_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetContinuousDeploymentPolicyConfigError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NoSuchContinuousDeploymentPolicy" => {
            crate::error::GetContinuousDeploymentPolicyConfigError::NoSuchContinuousDeploymentPolicy(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::no_such_continuous_deployment_policy::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_crate_error_no_such_continuous_deployment_policy_xml_err(response.body().as_ref(), output).map_err(crate::error::GetContinuousDeploymentPolicyConfigError::unhandled)?;
                        let output = output.meta(generic);
                        output.build()
                    };
                    if tmp.message.is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            )
        }
        _ => crate::error::GetContinuousDeploymentPolicyConfigError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_continuous_deployment_policy_config_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetContinuousDeploymentPolicyConfigOutput,
    crate::error::GetContinuousDeploymentPolicyConfigError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::get_continuous_deployment_policy_config_output::Builder::default();
        let _ = response;
        output = output.set_continuous_deployment_policy_config(
            crate::http_serde::deser_payload_get_continuous_deployment_policy_config_get_continuous_deployment_policy_config_output_continuous_deployment_policy_config(response.body().as_ref())?
        );
        output = output.set_e_tag(
            crate::http_serde::deser_header_get_continuous_deployment_policy_config_get_continuous_deployment_policy_config_output_e_tag(response.headers())
                                    .map_err(|_|crate::error::GetContinuousDeploymentPolicyConfigError::unhandled("Failed to parse ETag from header `ETag"))?
        );
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_distribution_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetDistributionOutput, crate::error::GetDistributionError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetDistributionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetDistributionError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AccessDenied" => crate::error::GetDistributionError::AccessDenied({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::access_denied::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_access_denied_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetDistributionError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NoSuchDistribution" => crate::error::GetDistributionError::NoSuchDistribution({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_distribution::Builder::default();
                let _ = response;
                output =
                    crate::xml_deser::deser_structure_crate_error_no_such_distribution_xml_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetDistributionError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::GetDistributionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_distribution_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetDistributionOutput, crate::error::GetDistributionError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_distribution_output::Builder::default();
        let _ = response;
        output = output.set_distribution(
            crate::http_serde::deser_payload_get_distribution_get_distribution_output_distribution(
                response.body().as_ref(),
            )?,
        );
        output = output.set_e_tag(
            crate::http_serde::deser_header_get_distribution_get_distribution_output_e_tag(
                response.headers(),
            )
            .map_err(|_| {
                crate::error::GetDistributionError::unhandled(
                    "Failed to parse ETag from header `ETag",
                )
            })?,
        );
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_distribution_config_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetDistributionConfigOutput,
    crate::error::GetDistributionConfigError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetDistributionConfigError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetDistributionConfigError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AccessDenied" => crate::error::GetDistributionConfigError::AccessDenied({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::access_denied::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_access_denied_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetDistributionConfigError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NoSuchDistribution" => crate::error::GetDistributionConfigError::NoSuchDistribution({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_distribution::Builder::default();
                let _ = response;
                output =
                    crate::xml_deser::deser_structure_crate_error_no_such_distribution_xml_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetDistributionConfigError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::GetDistributionConfigError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_distribution_config_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetDistributionConfigOutput,
    crate::error::GetDistributionConfigError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_distribution_config_output::Builder::default();
        let _ = response;
        output = output.set_distribution_config(
            crate::http_serde::deser_payload_get_distribution_config_get_distribution_config_output_distribution_config(response.body().as_ref())?
        );
        output = output.set_e_tag(
            crate::http_serde::deser_header_get_distribution_config_get_distribution_config_output_e_tag(response.headers())
                                    .map_err(|_|crate::error::GetDistributionConfigError::unhandled("Failed to parse ETag from header `ETag"))?
        );
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_field_level_encryption_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetFieldLevelEncryptionOutput,
    crate::error::GetFieldLevelEncryptionError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetFieldLevelEncryptionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::GetFieldLevelEncryptionError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AccessDenied" => crate::error::GetFieldLevelEncryptionError::AccessDenied({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::access_denied::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_access_denied_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetFieldLevelEncryptionError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NoSuchFieldLevelEncryptionConfig" => {
            crate::error::GetFieldLevelEncryptionError::NoSuchFieldLevelEncryptionConfig({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::no_such_field_level_encryption_config::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_field_level_encryption_config_xml_err(response.body().as_ref(), output).map_err(crate::error::GetFieldLevelEncryptionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::GetFieldLevelEncryptionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_field_level_encryption_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetFieldLevelEncryptionOutput,
    crate::error::GetFieldLevelEncryptionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_field_level_encryption_output::Builder::default();
        let _ = response;
        output = output.set_e_tag(
            crate::http_serde::deser_header_get_field_level_encryption_get_field_level_encryption_output_e_tag(response.headers())
                                    .map_err(|_|crate::error::GetFieldLevelEncryptionError::unhandled("Failed to parse ETag from header `ETag"))?
        );
        output = output.set_field_level_encryption(
            crate::http_serde::deser_payload_get_field_level_encryption_get_field_level_encryption_output_field_level_encryption(response.body().as_ref())?
        );
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_field_level_encryption_config_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetFieldLevelEncryptionConfigOutput,
    crate::error::GetFieldLevelEncryptionConfigError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetFieldLevelEncryptionConfigError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::GetFieldLevelEncryptionConfigError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AccessDenied" => crate::error::GetFieldLevelEncryptionConfigError::AccessDenied({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::access_denied::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_access_denied_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetFieldLevelEncryptionConfigError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NoSuchFieldLevelEncryptionConfig" => {
            crate::error::GetFieldLevelEncryptionConfigError::NoSuchFieldLevelEncryptionConfig({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::no_such_field_level_encryption_config::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_field_level_encryption_config_xml_err(response.body().as_ref(), output).map_err(crate::error::GetFieldLevelEncryptionConfigError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::GetFieldLevelEncryptionConfigError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_field_level_encryption_config_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetFieldLevelEncryptionConfigOutput,
    crate::error::GetFieldLevelEncryptionConfigError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::get_field_level_encryption_config_output::Builder::default();
        let _ = response;
        output = output.set_e_tag(
            crate::http_serde::deser_header_get_field_level_encryption_config_get_field_level_encryption_config_output_e_tag(response.headers())
                                    .map_err(|_|crate::error::GetFieldLevelEncryptionConfigError::unhandled("Failed to parse ETag from header `ETag"))?
        );
        output = output.set_field_level_encryption_config(
            crate::http_serde::deser_payload_get_field_level_encryption_config_get_field_level_encryption_config_output_field_level_encryption_config(response.body().as_ref())?
        );
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_field_level_encryption_profile_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetFieldLevelEncryptionProfileOutput,
    crate::error::GetFieldLevelEncryptionProfileError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetFieldLevelEncryptionProfileError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetFieldLevelEncryptionProfileError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AccessDenied" => crate::error::GetFieldLevelEncryptionProfileError::AccessDenied({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::access_denied::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_access_denied_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetFieldLevelEncryptionProfileError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NoSuchFieldLevelEncryptionProfile" => {
            crate::error::GetFieldLevelEncryptionProfileError::NoSuchFieldLevelEncryptionProfile({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::no_such_field_level_encryption_profile::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_field_level_encryption_profile_xml_err(response.body().as_ref(), output).map_err(crate::error::GetFieldLevelEncryptionProfileError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::GetFieldLevelEncryptionProfileError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_field_level_encryption_profile_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetFieldLevelEncryptionProfileOutput,
    crate::error::GetFieldLevelEncryptionProfileError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::get_field_level_encryption_profile_output::Builder::default();
        let _ = response;
        output = output.set_e_tag(
            crate::http_serde::deser_header_get_field_level_encryption_profile_get_field_level_encryption_profile_output_e_tag(response.headers())
                                    .map_err(|_|crate::error::GetFieldLevelEncryptionProfileError::unhandled("Failed to parse ETag from header `ETag"))?
        );
        output = output.set_field_level_encryption_profile(
            crate::http_serde::deser_payload_get_field_level_encryption_profile_get_field_level_encryption_profile_output_field_level_encryption_profile(response.body().as_ref())?
        );
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_field_level_encryption_profile_config_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetFieldLevelEncryptionProfileConfigOutput,
    crate::error::GetFieldLevelEncryptionProfileConfigError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetFieldLevelEncryptionProfileConfigError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::GetFieldLevelEncryptionProfileConfigError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AccessDenied" => crate::error::GetFieldLevelEncryptionProfileConfigError::AccessDenied({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::access_denied::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_access_denied_xml_err(response.body().as_ref(), output).map_err(crate::error::GetFieldLevelEncryptionProfileConfigError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "NoSuchFieldLevelEncryptionProfile" => crate::error::GetFieldLevelEncryptionProfileConfigError::NoSuchFieldLevelEncryptionProfile({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_field_level_encryption_profile::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_field_level_encryption_profile_xml_err(response.body().as_ref(), output).map_err(crate::error::GetFieldLevelEncryptionProfileConfigError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::GetFieldLevelEncryptionProfileConfigError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_field_level_encryption_profile_config_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetFieldLevelEncryptionProfileConfigOutput,
    crate::error::GetFieldLevelEncryptionProfileConfigError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::get_field_level_encryption_profile_config_output::Builder::default();
        let _ = response;
        output = output.set_e_tag(
            crate::http_serde::deser_header_get_field_level_encryption_profile_config_get_field_level_encryption_profile_config_output_e_tag(response.headers())
                                    .map_err(|_|crate::error::GetFieldLevelEncryptionProfileConfigError::unhandled("Failed to parse ETag from header `ETag"))?
        );
        output = output.set_field_level_encryption_profile_config(
            crate::http_serde::deser_payload_get_field_level_encryption_profile_config_get_field_level_encryption_profile_config_output_field_level_encryption_profile_config(response.body().as_ref())?
        );
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_function_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetFunctionOutput, crate::error::GetFunctionError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetFunctionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetFunctionError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "NoSuchFunctionExists" => {
            crate::error::GetFunctionError::NoSuchFunctionExists({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_function_exists::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_function_exists_xml_err(response.body().as_ref(), output).map_err(crate::error::GetFunctionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "UnsupportedOperation" => {
            crate::error::GetFunctionError::UnsupportedOperation({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unsupported_operation::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_unsupported_operation_xml_err(response.body().as_ref(), output).map_err(crate::error::GetFunctionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::GetFunctionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_function_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetFunctionOutput, crate::error::GetFunctionError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_function_output::Builder::default();
        let _ = response;
        output = output.set_content_type(
            crate::http_serde::deser_header_get_function_get_function_output_content_type(
                response.headers(),
            )
            .map_err(|_| {
                crate::error::GetFunctionError::unhandled(
                    "Failed to parse ContentType from header `Content-Type",
                )
            })?,
        );
        output = output.set_e_tag(
            crate::http_serde::deser_header_get_function_get_function_output_e_tag(
                response.headers(),
            )
            .map_err(|_| {
                crate::error::GetFunctionError::unhandled("Failed to parse ETag from header `ETag")
            })?,
        );
        output = output.set_function_code(
            crate::http_serde::deser_payload_get_function_get_function_output_function_code(
                response.body().as_ref(),
            )?,
        );
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_invalidation_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetInvalidationOutput, crate::error::GetInvalidationError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetInvalidationError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetInvalidationError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AccessDenied" => crate::error::GetInvalidationError::AccessDenied({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::access_denied::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_access_denied_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetInvalidationError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NoSuchDistribution" => crate::error::GetInvalidationError::NoSuchDistribution({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_distribution::Builder::default();
                let _ = response;
                output =
                    crate::xml_deser::deser_structure_crate_error_no_such_distribution_xml_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetInvalidationError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NoSuchInvalidation" => crate::error::GetInvalidationError::NoSuchInvalidation({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_invalidation::Builder::default();
                let _ = response;
                output =
                    crate::xml_deser::deser_structure_crate_error_no_such_invalidation_xml_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetInvalidationError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::GetInvalidationError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_invalidation_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetInvalidationOutput, crate::error::GetInvalidationError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_invalidation_output::Builder::default();
        let _ = response;
        output = output.set_invalidation(
            crate::http_serde::deser_payload_get_invalidation_get_invalidation_output_invalidation(
                response.body().as_ref(),
            )?,
        );
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_key_group_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetKeyGroupOutput, crate::error::GetKeyGroupError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetKeyGroupError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetKeyGroupError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "NoSuchResource" => crate::error::GetKeyGroupError::NoSuchResource({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_resource::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_no_such_resource_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetKeyGroupError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::GetKeyGroupError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_key_group_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetKeyGroupOutput, crate::error::GetKeyGroupError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_key_group_output::Builder::default();
        let _ = response;
        output = output.set_e_tag(
            crate::http_serde::deser_header_get_key_group_get_key_group_output_e_tag(
                response.headers(),
            )
            .map_err(|_| {
                crate::error::GetKeyGroupError::unhandled("Failed to parse ETag from header `ETag")
            })?,
        );
        output = output.set_key_group(
            crate::http_serde::deser_payload_get_key_group_get_key_group_output_key_group(
                response.body().as_ref(),
            )?,
        );
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_key_group_config_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetKeyGroupConfigOutput, crate::error::GetKeyGroupConfigError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetKeyGroupConfigError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetKeyGroupConfigError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "NoSuchResource" => crate::error::GetKeyGroupConfigError::NoSuchResource({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_resource::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_no_such_resource_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetKeyGroupConfigError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::GetKeyGroupConfigError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_key_group_config_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetKeyGroupConfigOutput, crate::error::GetKeyGroupConfigError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_key_group_config_output::Builder::default();
        let _ = response;
        output = output.set_e_tag(
            crate::http_serde::deser_header_get_key_group_config_get_key_group_config_output_e_tag(
                response.headers(),
            )
            .map_err(|_| {
                crate::error::GetKeyGroupConfigError::unhandled(
                    "Failed to parse ETag from header `ETag",
                )
            })?,
        );
        output = output.set_key_group_config(
            crate::http_serde::deser_payload_get_key_group_config_get_key_group_config_output_key_group_config(response.body().as_ref())?
        );
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_monitoring_subscription_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetMonitoringSubscriptionOutput,
    crate::error::GetMonitoringSubscriptionError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetMonitoringSubscriptionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::GetMonitoringSubscriptionError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AccessDenied" => crate::error::GetMonitoringSubscriptionError::AccessDenied({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::access_denied::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_access_denied_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetMonitoringSubscriptionError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NoSuchDistribution" => crate::error::GetMonitoringSubscriptionError::NoSuchDistribution({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_distribution::Builder::default();
                let _ = response;
                output =
                    crate::xml_deser::deser_structure_crate_error_no_such_distribution_xml_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetMonitoringSubscriptionError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NoSuchMonitoringSubscription" => {
            crate::error::GetMonitoringSubscriptionError::NoSuchMonitoringSubscription({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::no_such_monitoring_subscription::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_monitoring_subscription_xml_err(response.body().as_ref(), output).map_err(crate::error::GetMonitoringSubscriptionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "UnsupportedOperation" => {
            crate::error::GetMonitoringSubscriptionError::UnsupportedOperation({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unsupported_operation::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_unsupported_operation_xml_err(response.body().as_ref(), output).map_err(crate::error::GetMonitoringSubscriptionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::GetMonitoringSubscriptionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_monitoring_subscription_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetMonitoringSubscriptionOutput,
    crate::error::GetMonitoringSubscriptionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_monitoring_subscription_output::Builder::default();
        let _ = response;
        output = output.set_monitoring_subscription(
            crate::http_serde::deser_payload_get_monitoring_subscription_get_monitoring_subscription_output_monitoring_subscription(response.body().as_ref())?
        );
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_origin_access_control_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetOriginAccessControlOutput,
    crate::error::GetOriginAccessControlError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetOriginAccessControlError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::GetOriginAccessControlError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AccessDenied" => crate::error::GetOriginAccessControlError::AccessDenied({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::access_denied::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_access_denied_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetOriginAccessControlError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NoSuchOriginAccessControl" => {
            crate::error::GetOriginAccessControlError::NoSuchOriginAccessControl({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::no_such_origin_access_control::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_origin_access_control_xml_err(response.body().as_ref(), output).map_err(crate::error::GetOriginAccessControlError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::GetOriginAccessControlError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_origin_access_control_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetOriginAccessControlOutput,
    crate::error::GetOriginAccessControlError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_origin_access_control_output::Builder::default();
        let _ = response;
        output = output.set_e_tag(
            crate::http_serde::deser_header_get_origin_access_control_get_origin_access_control_output_e_tag(response.headers())
                                    .map_err(|_|crate::error::GetOriginAccessControlError::unhandled("Failed to parse ETag from header `ETag"))?
        );
        output = output.set_origin_access_control(
            crate::http_serde::deser_payload_get_origin_access_control_get_origin_access_control_output_origin_access_control(response.body().as_ref())?
        );
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_origin_access_control_config_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetOriginAccessControlConfigOutput,
    crate::error::GetOriginAccessControlConfigError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetOriginAccessControlConfigError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::GetOriginAccessControlConfigError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AccessDenied" => crate::error::GetOriginAccessControlConfigError::AccessDenied({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::access_denied::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_access_denied_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetOriginAccessControlConfigError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NoSuchOriginAccessControl" => {
            crate::error::GetOriginAccessControlConfigError::NoSuchOriginAccessControl({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::no_such_origin_access_control::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_origin_access_control_xml_err(response.body().as_ref(), output).map_err(crate::error::GetOriginAccessControlConfigError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::GetOriginAccessControlConfigError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_origin_access_control_config_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetOriginAccessControlConfigOutput,
    crate::error::GetOriginAccessControlConfigError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_origin_access_control_config_output::Builder::default();
        let _ = response;
        output = output.set_e_tag(
            crate::http_serde::deser_header_get_origin_access_control_config_get_origin_access_control_config_output_e_tag(response.headers())
                                    .map_err(|_|crate::error::GetOriginAccessControlConfigError::unhandled("Failed to parse ETag from header `ETag"))?
        );
        output = output.set_origin_access_control_config(
            crate::http_serde::deser_payload_get_origin_access_control_config_get_origin_access_control_config_output_origin_access_control_config(response.body().as_ref())?
        );
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_origin_request_policy_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetOriginRequestPolicyOutput,
    crate::error::GetOriginRequestPolicyError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetOriginRequestPolicyError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::GetOriginRequestPolicyError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AccessDenied" => crate::error::GetOriginRequestPolicyError::AccessDenied({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::access_denied::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_access_denied_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetOriginRequestPolicyError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NoSuchOriginRequestPolicy" => {
            crate::error::GetOriginRequestPolicyError::NoSuchOriginRequestPolicy({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::no_such_origin_request_policy::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_origin_request_policy_xml_err(response.body().as_ref(), output).map_err(crate::error::GetOriginRequestPolicyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::GetOriginRequestPolicyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_origin_request_policy_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetOriginRequestPolicyOutput,
    crate::error::GetOriginRequestPolicyError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_origin_request_policy_output::Builder::default();
        let _ = response;
        output = output.set_e_tag(
            crate::http_serde::deser_header_get_origin_request_policy_get_origin_request_policy_output_e_tag(response.headers())
                                    .map_err(|_|crate::error::GetOriginRequestPolicyError::unhandled("Failed to parse ETag from header `ETag"))?
        );
        output = output.set_origin_request_policy(
            crate::http_serde::deser_payload_get_origin_request_policy_get_origin_request_policy_output_origin_request_policy(response.body().as_ref())?
        );
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_origin_request_policy_config_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetOriginRequestPolicyConfigOutput,
    crate::error::GetOriginRequestPolicyConfigError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetOriginRequestPolicyConfigError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::GetOriginRequestPolicyConfigError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AccessDenied" => crate::error::GetOriginRequestPolicyConfigError::AccessDenied({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::access_denied::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_access_denied_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetOriginRequestPolicyConfigError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NoSuchOriginRequestPolicy" => {
            crate::error::GetOriginRequestPolicyConfigError::NoSuchOriginRequestPolicy({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::no_such_origin_request_policy::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_origin_request_policy_xml_err(response.body().as_ref(), output).map_err(crate::error::GetOriginRequestPolicyConfigError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::GetOriginRequestPolicyConfigError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_origin_request_policy_config_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetOriginRequestPolicyConfigOutput,
    crate::error::GetOriginRequestPolicyConfigError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_origin_request_policy_config_output::Builder::default();
        let _ = response;
        output = output.set_e_tag(
            crate::http_serde::deser_header_get_origin_request_policy_config_get_origin_request_policy_config_output_e_tag(response.headers())
                                    .map_err(|_|crate::error::GetOriginRequestPolicyConfigError::unhandled("Failed to parse ETag from header `ETag"))?
        );
        output = output.set_origin_request_policy_config(
            crate::http_serde::deser_payload_get_origin_request_policy_config_get_origin_request_policy_config_output_origin_request_policy_config(response.body().as_ref())?
        );
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_public_key_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetPublicKeyOutput, crate::error::GetPublicKeyError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetPublicKeyError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetPublicKeyError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AccessDenied" => crate::error::GetPublicKeyError::AccessDenied({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::access_denied::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_access_denied_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetPublicKeyError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NoSuchPublicKey" => crate::error::GetPublicKeyError::NoSuchPublicKey({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_public_key::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_no_such_public_key_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetPublicKeyError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::GetPublicKeyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_public_key_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetPublicKeyOutput, crate::error::GetPublicKeyError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_public_key_output::Builder::default();
        let _ = response;
        output = output.set_e_tag(
            crate::http_serde::deser_header_get_public_key_get_public_key_output_e_tag(
                response.headers(),
            )
            .map_err(|_| {
                crate::error::GetPublicKeyError::unhandled("Failed to parse ETag from header `ETag")
            })?,
        );
        output = output.set_public_key(
            crate::http_serde::deser_payload_get_public_key_get_public_key_output_public_key(
                response.body().as_ref(),
            )?,
        );
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_public_key_config_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetPublicKeyConfigOutput,
    crate::error::GetPublicKeyConfigError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetPublicKeyConfigError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetPublicKeyConfigError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AccessDenied" => crate::error::GetPublicKeyConfigError::AccessDenied({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::access_denied::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_access_denied_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetPublicKeyConfigError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NoSuchPublicKey" => crate::error::GetPublicKeyConfigError::NoSuchPublicKey({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_public_key::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_no_such_public_key_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetPublicKeyConfigError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::GetPublicKeyConfigError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_public_key_config_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetPublicKeyConfigOutput,
    crate::error::GetPublicKeyConfigError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_public_key_config_output::Builder::default();
        let _ = response;
        output = output.set_e_tag(
            crate::http_serde::deser_header_get_public_key_config_get_public_key_config_output_e_tag(response.headers())
                                    .map_err(|_|crate::error::GetPublicKeyConfigError::unhandled("Failed to parse ETag from header `ETag"))?
        );
        output = output.set_public_key_config(
            crate::http_serde::deser_payload_get_public_key_config_get_public_key_config_output_public_key_config(response.body().as_ref())?
        );
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_realtime_log_config_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetRealtimeLogConfigOutput,
    crate::error::GetRealtimeLogConfigError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetRealtimeLogConfigError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetRealtimeLogConfigError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AccessDenied" => crate::error::GetRealtimeLogConfigError::AccessDenied({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::access_denied::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_access_denied_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetRealtimeLogConfigError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidArgument" => crate::error::GetRealtimeLogConfigError::InvalidArgument({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_argument::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_invalid_argument_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetRealtimeLogConfigError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NoSuchRealtimeLogConfig" => {
            crate::error::GetRealtimeLogConfigError::NoSuchRealtimeLogConfig({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_realtime_log_config::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_realtime_log_config_xml_err(response.body().as_ref(), output).map_err(crate::error::GetRealtimeLogConfigError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::GetRealtimeLogConfigError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_realtime_log_config_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetRealtimeLogConfigOutput,
    crate::error::GetRealtimeLogConfigError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_realtime_log_config_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_get_realtime_log_config(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetRealtimeLogConfigError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_response_headers_policy_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetResponseHeadersPolicyOutput,
    crate::error::GetResponseHeadersPolicyError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetResponseHeadersPolicyError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::GetResponseHeadersPolicyError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AccessDenied" => crate::error::GetResponseHeadersPolicyError::AccessDenied({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::access_denied::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_access_denied_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetResponseHeadersPolicyError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NoSuchResponseHeadersPolicy" => {
            crate::error::GetResponseHeadersPolicyError::NoSuchResponseHeadersPolicy({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::no_such_response_headers_policy::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_response_headers_policy_xml_err(response.body().as_ref(), output).map_err(crate::error::GetResponseHeadersPolicyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::GetResponseHeadersPolicyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_response_headers_policy_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetResponseHeadersPolicyOutput,
    crate::error::GetResponseHeadersPolicyError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_response_headers_policy_output::Builder::default();
        let _ = response;
        output = output.set_e_tag(
            crate::http_serde::deser_header_get_response_headers_policy_get_response_headers_policy_output_e_tag(response.headers())
                                    .map_err(|_|crate::error::GetResponseHeadersPolicyError::unhandled("Failed to parse ETag from header `ETag"))?
        );
        output = output.set_response_headers_policy(
            crate::http_serde::deser_payload_get_response_headers_policy_get_response_headers_policy_output_response_headers_policy(response.body().as_ref())?
        );
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_response_headers_policy_config_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetResponseHeadersPolicyConfigOutput,
    crate::error::GetResponseHeadersPolicyConfigError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetResponseHeadersPolicyConfigError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetResponseHeadersPolicyConfigError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AccessDenied" => crate::error::GetResponseHeadersPolicyConfigError::AccessDenied({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::access_denied::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_access_denied_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetResponseHeadersPolicyConfigError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NoSuchResponseHeadersPolicy" => {
            crate::error::GetResponseHeadersPolicyConfigError::NoSuchResponseHeadersPolicy({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::no_such_response_headers_policy::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_response_headers_policy_xml_err(response.body().as_ref(), output).map_err(crate::error::GetResponseHeadersPolicyConfigError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::GetResponseHeadersPolicyConfigError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_response_headers_policy_config_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetResponseHeadersPolicyConfigOutput,
    crate::error::GetResponseHeadersPolicyConfigError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::get_response_headers_policy_config_output::Builder::default();
        let _ = response;
        output = output.set_e_tag(
            crate::http_serde::deser_header_get_response_headers_policy_config_get_response_headers_policy_config_output_e_tag(response.headers())
                                    .map_err(|_|crate::error::GetResponseHeadersPolicyConfigError::unhandled("Failed to parse ETag from header `ETag"))?
        );
        output = output.set_response_headers_policy_config(
            crate::http_serde::deser_payload_get_response_headers_policy_config_get_response_headers_policy_config_output_response_headers_policy_config(response.body().as_ref())?
        );
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_streaming_distribution_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetStreamingDistributionOutput,
    crate::error::GetStreamingDistributionError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetStreamingDistributionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::GetStreamingDistributionError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AccessDenied" => crate::error::GetStreamingDistributionError::AccessDenied({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::access_denied::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_access_denied_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetStreamingDistributionError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NoSuchStreamingDistribution" => {
            crate::error::GetStreamingDistributionError::NoSuchStreamingDistribution({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::no_such_streaming_distribution::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_streaming_distribution_xml_err(response.body().as_ref(), output).map_err(crate::error::GetStreamingDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::GetStreamingDistributionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_streaming_distribution_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetStreamingDistributionOutput,
    crate::error::GetStreamingDistributionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_streaming_distribution_output::Builder::default();
        let _ = response;
        output = output.set_e_tag(
            crate::http_serde::deser_header_get_streaming_distribution_get_streaming_distribution_output_e_tag(response.headers())
                                    .map_err(|_|crate::error::GetStreamingDistributionError::unhandled("Failed to parse ETag from header `ETag"))?
        );
        output = output.set_streaming_distribution(
            crate::http_serde::deser_payload_get_streaming_distribution_get_streaming_distribution_output_streaming_distribution(response.body().as_ref())?
        );
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_streaming_distribution_config_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetStreamingDistributionConfigOutput,
    crate::error::GetStreamingDistributionConfigError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetStreamingDistributionConfigError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetStreamingDistributionConfigError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AccessDenied" => crate::error::GetStreamingDistributionConfigError::AccessDenied({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::access_denied::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_access_denied_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetStreamingDistributionConfigError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NoSuchStreamingDistribution" => {
            crate::error::GetStreamingDistributionConfigError::NoSuchStreamingDistribution({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::no_such_streaming_distribution::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_streaming_distribution_xml_err(response.body().as_ref(), output).map_err(crate::error::GetStreamingDistributionConfigError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::GetStreamingDistributionConfigError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_streaming_distribution_config_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetStreamingDistributionConfigOutput,
    crate::error::GetStreamingDistributionConfigError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::get_streaming_distribution_config_output::Builder::default();
        let _ = response;
        output = output.set_e_tag(
            crate::http_serde::deser_header_get_streaming_distribution_config_get_streaming_distribution_config_output_e_tag(response.headers())
                                    .map_err(|_|crate::error::GetStreamingDistributionConfigError::unhandled("Failed to parse ETag from header `ETag"))?
        );
        output = output.set_streaming_distribution_config(
            crate::http_serde::deser_payload_get_streaming_distribution_config_get_streaming_distribution_config_output_streaming_distribution_config(response.body().as_ref())?
        );
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_cache_policies_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListCachePoliciesOutput, crate::error::ListCachePoliciesError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListCachePoliciesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListCachePoliciesError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AccessDenied" => crate::error::ListCachePoliciesError::AccessDenied({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::access_denied::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_access_denied_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListCachePoliciesError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidArgument" => crate::error::ListCachePoliciesError::InvalidArgument({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_argument::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_invalid_argument_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListCachePoliciesError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NoSuchCachePolicy" => crate::error::ListCachePoliciesError::NoSuchCachePolicy({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_cache_policy::Builder::default();
                let _ = response;
                output =
                    crate::xml_deser::deser_structure_crate_error_no_such_cache_policy_xml_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListCachePoliciesError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::ListCachePoliciesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_cache_policies_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListCachePoliciesOutput, crate::error::ListCachePoliciesError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_cache_policies_output::Builder::default();
        let _ = response;
        output = output.set_cache_policy_list(
            crate::http_serde::deser_payload_list_cache_policies_list_cache_policies_output_cache_policy_list(response.body().as_ref())?
        );
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_cloud_front_origin_access_identities_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListCloudFrontOriginAccessIdentitiesOutput,
    crate::error::ListCloudFrontOriginAccessIdentitiesError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListCloudFrontOriginAccessIdentitiesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ListCloudFrontOriginAccessIdentitiesError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidArgument" => {
            crate::error::ListCloudFrontOriginAccessIdentitiesError::InvalidArgument({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_argument::Builder::default();
                    let _ = response;
                    output =
                        crate::xml_deser::deser_structure_crate_error_invalid_argument_xml_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(
                            crate::error::ListCloudFrontOriginAccessIdentitiesError::unhandled,
                        )?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::ListCloudFrontOriginAccessIdentitiesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_cloud_front_origin_access_identities_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListCloudFrontOriginAccessIdentitiesOutput,
    crate::error::ListCloudFrontOriginAccessIdentitiesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::list_cloud_front_origin_access_identities_output::Builder::default();
        let _ = response;
        output = output.set_cloud_front_origin_access_identity_list(
            crate::http_serde::deser_payload_list_cloud_front_origin_access_identities_list_cloud_front_origin_access_identities_output_cloud_front_origin_access_identity_list(response.body().as_ref())?
        );
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_conflicting_aliases_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListConflictingAliasesOutput,
    crate::error::ListConflictingAliasesError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListConflictingAliasesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ListConflictingAliasesError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidArgument" => crate::error::ListConflictingAliasesError::InvalidArgument({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_argument::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_invalid_argument_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListConflictingAliasesError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NoSuchDistribution" => crate::error::ListConflictingAliasesError::NoSuchDistribution({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_distribution::Builder::default();
                let _ = response;
                output =
                    crate::xml_deser::deser_structure_crate_error_no_such_distribution_xml_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListConflictingAliasesError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::ListConflictingAliasesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_conflicting_aliases_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListConflictingAliasesOutput,
    crate::error::ListConflictingAliasesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_conflicting_aliases_output::Builder::default();
        let _ = response;
        output = output.set_conflicting_aliases_list(
            crate::http_serde::deser_payload_list_conflicting_aliases_list_conflicting_aliases_output_conflicting_aliases_list(response.body().as_ref())?
        );
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_continuous_deployment_policies_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListContinuousDeploymentPoliciesOutput,
    crate::error::ListContinuousDeploymentPoliciesError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListContinuousDeploymentPoliciesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ListContinuousDeploymentPoliciesError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AccessDenied" => crate::error::ListContinuousDeploymentPoliciesError::AccessDenied({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::access_denied::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_access_denied_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListContinuousDeploymentPoliciesError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidArgument" => {
            crate::error::ListContinuousDeploymentPoliciesError::InvalidArgument({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_argument::Builder::default();
                    let _ = response;
                    output =
                        crate::xml_deser::deser_structure_crate_error_invalid_argument_xml_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::ListContinuousDeploymentPoliciesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "NoSuchContinuousDeploymentPolicy" => {
            crate::error::ListContinuousDeploymentPoliciesError::NoSuchContinuousDeploymentPolicy({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::no_such_continuous_deployment_policy::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_continuous_deployment_policy_xml_err(response.body().as_ref(), output).map_err(crate::error::ListContinuousDeploymentPoliciesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::ListContinuousDeploymentPoliciesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_continuous_deployment_policies_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListContinuousDeploymentPoliciesOutput,
    crate::error::ListContinuousDeploymentPoliciesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::list_continuous_deployment_policies_output::Builder::default();
        let _ = response;
        output = output.set_continuous_deployment_policy_list(
            crate::http_serde::deser_payload_list_continuous_deployment_policies_list_continuous_deployment_policies_output_continuous_deployment_policy_list(response.body().as_ref())?
        );
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_distributions_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListDistributionsOutput, crate::error::ListDistributionsError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListDistributionsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListDistributionsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidArgument" => crate::error::ListDistributionsError::InvalidArgument({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_argument::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_invalid_argument_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListDistributionsError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::ListDistributionsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_distributions_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListDistributionsOutput, crate::error::ListDistributionsError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_distributions_output::Builder::default();
        let _ = response;
        output = output.set_distribution_list(
            crate::http_serde::deser_payload_list_distributions_list_distributions_output_distribution_list(response.body().as_ref())?
        );
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_distributions_by_cache_policy_id_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListDistributionsByCachePolicyIdOutput,
    crate::error::ListDistributionsByCachePolicyIdError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListDistributionsByCachePolicyIdError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ListDistributionsByCachePolicyIdError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AccessDenied" => crate::error::ListDistributionsByCachePolicyIdError::AccessDenied({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::access_denied::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_access_denied_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListDistributionsByCachePolicyIdError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidArgument" => {
            crate::error::ListDistributionsByCachePolicyIdError::InvalidArgument({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_argument::Builder::default();
                    let _ = response;
                    output =
                        crate::xml_deser::deser_structure_crate_error_invalid_argument_xml_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::ListDistributionsByCachePolicyIdError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "NoSuchCachePolicy" => {
            crate::error::ListDistributionsByCachePolicyIdError::NoSuchCachePolicy({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_cache_policy::Builder::default();
                    let _ = response;
                    output =
                        crate::xml_deser::deser_structure_crate_error_no_such_cache_policy_xml_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::ListDistributionsByCachePolicyIdError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::ListDistributionsByCachePolicyIdError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_distributions_by_cache_policy_id_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListDistributionsByCachePolicyIdOutput,
    crate::error::ListDistributionsByCachePolicyIdError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::list_distributions_by_cache_policy_id_output::Builder::default();
        let _ = response;
        output = output.set_distribution_id_list(
            crate::http_serde::deser_payload_list_distributions_by_cache_policy_id_list_distributions_by_cache_policy_id_output_distribution_id_list(response.body().as_ref())?
        );
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_distributions_by_key_group_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListDistributionsByKeyGroupOutput,
    crate::error::ListDistributionsByKeyGroupError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListDistributionsByKeyGroupError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ListDistributionsByKeyGroupError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidArgument" => crate::error::ListDistributionsByKeyGroupError::InvalidArgument({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_argument::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_invalid_argument_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListDistributionsByKeyGroupError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NoSuchResource" => crate::error::ListDistributionsByKeyGroupError::NoSuchResource({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_resource::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_no_such_resource_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListDistributionsByKeyGroupError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::ListDistributionsByKeyGroupError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_distributions_by_key_group_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListDistributionsByKeyGroupOutput,
    crate::error::ListDistributionsByKeyGroupError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_distributions_by_key_group_output::Builder::default();
        let _ = response;
        output = output.set_distribution_id_list(
            crate::http_serde::deser_payload_list_distributions_by_key_group_list_distributions_by_key_group_output_distribution_id_list(response.body().as_ref())?
        );
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_distributions_by_origin_request_policy_id_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListDistributionsByOriginRequestPolicyIdOutput,
    crate::error::ListDistributionsByOriginRequestPolicyIdError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListDistributionsByOriginRequestPolicyIdError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(
                crate::error::ListDistributionsByOriginRequestPolicyIdError::unhandled(generic),
            )
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AccessDenied" => {
            crate::error::ListDistributionsByOriginRequestPolicyIdError::AccessDenied({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::access_denied::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_access_denied_xml_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(
                        crate::error::ListDistributionsByOriginRequestPolicyIdError::unhandled,
                    )?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidArgument" => {
            crate::error::ListDistributionsByOriginRequestPolicyIdError::InvalidArgument({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_argument::Builder::default();
                    let _ = response;
                    output =
                        crate::xml_deser::deser_structure_crate_error_invalid_argument_xml_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(
                            crate::error::ListDistributionsByOriginRequestPolicyIdError::unhandled,
                        )?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "NoSuchOriginRequestPolicy" => {
            crate::error::ListDistributionsByOriginRequestPolicyIdError::NoSuchOriginRequestPolicy(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::no_such_origin_request_policy::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_crate_error_no_such_origin_request_policy_xml_err(response.body().as_ref(), output).map_err(crate::error::ListDistributionsByOriginRequestPolicyIdError::unhandled)?;
                        let output = output.meta(generic);
                        output.build()
                    };
                    if tmp.message.is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            )
        }
        _ => crate::error::ListDistributionsByOriginRequestPolicyIdError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_distributions_by_origin_request_policy_id_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListDistributionsByOriginRequestPolicyIdOutput,
    crate::error::ListDistributionsByOriginRequestPolicyIdError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::list_distributions_by_origin_request_policy_id_output::Builder::default(
            );
        let _ = response;
        output = output.set_distribution_id_list(
            crate::http_serde::deser_payload_list_distributions_by_origin_request_policy_id_list_distributions_by_origin_request_policy_id_output_distribution_id_list(response.body().as_ref())?
        );
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_distributions_by_realtime_log_config_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListDistributionsByRealtimeLogConfigOutput,
    crate::error::ListDistributionsByRealtimeLogConfigError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListDistributionsByRealtimeLogConfigError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ListDistributionsByRealtimeLogConfigError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidArgument" => {
            crate::error::ListDistributionsByRealtimeLogConfigError::InvalidArgument({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_argument::Builder::default();
                    let _ = response;
                    output =
                        crate::xml_deser::deser_structure_crate_error_invalid_argument_xml_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(
                            crate::error::ListDistributionsByRealtimeLogConfigError::unhandled,
                        )?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::ListDistributionsByRealtimeLogConfigError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_distributions_by_realtime_log_config_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListDistributionsByRealtimeLogConfigOutput,
    crate::error::ListDistributionsByRealtimeLogConfigError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::list_distributions_by_realtime_log_config_output::Builder::default();
        let _ = response;
        output = output.set_distribution_list(
            crate::http_serde::deser_payload_list_distributions_by_realtime_log_config_list_distributions_by_realtime_log_config_output_distribution_list(response.body().as_ref())?
        );
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_distributions_by_response_headers_policy_id_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListDistributionsByResponseHeadersPolicyIdOutput,
    crate::error::ListDistributionsByResponseHeadersPolicyIdError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListDistributionsByResponseHeadersPolicyIdError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(
                crate::error::ListDistributionsByResponseHeadersPolicyIdError::unhandled(generic),
            )
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AccessDenied" => crate::error::ListDistributionsByResponseHeadersPolicyIdError::AccessDenied({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::access_denied::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_access_denied_xml_err(response.body().as_ref(), output).map_err(crate::error::ListDistributionsByResponseHeadersPolicyIdError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidArgument" => crate::error::ListDistributionsByResponseHeadersPolicyIdError::InvalidArgument({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_argument::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_argument_xml_err(response.body().as_ref(), output).map_err(crate::error::ListDistributionsByResponseHeadersPolicyIdError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "NoSuchResponseHeadersPolicy" => crate::error::ListDistributionsByResponseHeadersPolicyIdError::NoSuchResponseHeadersPolicy({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_response_headers_policy::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_response_headers_policy_xml_err(response.body().as_ref(), output).map_err(crate::error::ListDistributionsByResponseHeadersPolicyIdError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::ListDistributionsByResponseHeadersPolicyIdError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_distributions_by_response_headers_policy_id_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListDistributionsByResponseHeadersPolicyIdOutput,
    crate::error::ListDistributionsByResponseHeadersPolicyIdError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_distributions_by_response_headers_policy_id_output::Builder::default();
        let _ = response;
        output = output.set_distribution_id_list(
            crate::http_serde::deser_payload_list_distributions_by_response_headers_policy_id_list_distributions_by_response_headers_policy_id_output_distribution_id_list(response.body().as_ref())?
        );
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_distributions_by_web_acl_id_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListDistributionsByWebAclIdOutput,
    crate::error::ListDistributionsByWebACLIdError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListDistributionsByWebACLIdError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ListDistributionsByWebACLIdError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidArgument" => crate::error::ListDistributionsByWebACLIdError::InvalidArgument({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_argument::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_invalid_argument_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListDistributionsByWebACLIdError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidWebACLId" => crate::error::ListDistributionsByWebACLIdError::InvalidWebAclId({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_web_acl_id::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_invalid_web_acl_id_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListDistributionsByWebACLIdError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::ListDistributionsByWebACLIdError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_distributions_by_web_acl_id_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListDistributionsByWebAclIdOutput,
    crate::error::ListDistributionsByWebACLIdError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_distributions_by_web_acl_id_output::Builder::default();
        let _ = response;
        output = output.set_distribution_list(
            crate::http_serde::deser_payload_list_distributions_by_web_acl_id_list_distributions_by_web_acl_id_output_distribution_list(response.body().as_ref())?
        );
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_field_level_encryption_configs_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListFieldLevelEncryptionConfigsOutput,
    crate::error::ListFieldLevelEncryptionConfigsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListFieldLevelEncryptionConfigsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListFieldLevelEncryptionConfigsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidArgument" => crate::error::ListFieldLevelEncryptionConfigsError::InvalidArgument({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_argument::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_invalid_argument_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListFieldLevelEncryptionConfigsError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::ListFieldLevelEncryptionConfigsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_field_level_encryption_configs_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListFieldLevelEncryptionConfigsOutput,
    crate::error::ListFieldLevelEncryptionConfigsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::list_field_level_encryption_configs_output::Builder::default();
        let _ = response;
        output = output.set_field_level_encryption_list(
            crate::http_serde::deser_payload_list_field_level_encryption_configs_list_field_level_encryption_configs_output_field_level_encryption_list(response.body().as_ref())?
        );
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_field_level_encryption_profiles_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListFieldLevelEncryptionProfilesOutput,
    crate::error::ListFieldLevelEncryptionProfilesError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListFieldLevelEncryptionProfilesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ListFieldLevelEncryptionProfilesError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidArgument" => {
            crate::error::ListFieldLevelEncryptionProfilesError::InvalidArgument({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_argument::Builder::default();
                    let _ = response;
                    output =
                        crate::xml_deser::deser_structure_crate_error_invalid_argument_xml_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::ListFieldLevelEncryptionProfilesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::ListFieldLevelEncryptionProfilesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_field_level_encryption_profiles_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListFieldLevelEncryptionProfilesOutput,
    crate::error::ListFieldLevelEncryptionProfilesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::list_field_level_encryption_profiles_output::Builder::default();
        let _ = response;
        output = output.set_field_level_encryption_profile_list(
            crate::http_serde::deser_payload_list_field_level_encryption_profiles_list_field_level_encryption_profiles_output_field_level_encryption_profile_list(response.body().as_ref())?
        );
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_functions_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListFunctionsOutput, crate::error::ListFunctionsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListFunctionsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListFunctionsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidArgument" => crate::error::ListFunctionsError::InvalidArgument({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_argument::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_invalid_argument_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListFunctionsError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "UnsupportedOperation" => {
            crate::error::ListFunctionsError::UnsupportedOperation({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unsupported_operation::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_unsupported_operation_xml_err(response.body().as_ref(), output).map_err(crate::error::ListFunctionsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::ListFunctionsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_functions_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListFunctionsOutput, crate::error::ListFunctionsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_functions_output::Builder::default();
        let _ = response;
        output = output.set_function_list(
            crate::http_serde::deser_payload_list_functions_list_functions_output_function_list(
                response.body().as_ref(),
            )?,
        );
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_invalidations_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListInvalidationsOutput, crate::error::ListInvalidationsError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListInvalidationsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListInvalidationsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AccessDenied" => crate::error::ListInvalidationsError::AccessDenied({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::access_denied::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_access_denied_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListInvalidationsError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidArgument" => crate::error::ListInvalidationsError::InvalidArgument({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_argument::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_invalid_argument_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListInvalidationsError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NoSuchDistribution" => crate::error::ListInvalidationsError::NoSuchDistribution({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_distribution::Builder::default();
                let _ = response;
                output =
                    crate::xml_deser::deser_structure_crate_error_no_such_distribution_xml_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListInvalidationsError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::ListInvalidationsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_invalidations_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListInvalidationsOutput, crate::error::ListInvalidationsError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_invalidations_output::Builder::default();
        let _ = response;
        output = output.set_invalidation_list(
            crate::http_serde::deser_payload_list_invalidations_list_invalidations_output_invalidation_list(response.body().as_ref())?
        );
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_key_groups_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListKeyGroupsOutput, crate::error::ListKeyGroupsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListKeyGroupsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListKeyGroupsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidArgument" => crate::error::ListKeyGroupsError::InvalidArgument({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_argument::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_invalid_argument_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListKeyGroupsError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::ListKeyGroupsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_key_groups_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListKeyGroupsOutput, crate::error::ListKeyGroupsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_key_groups_output::Builder::default();
        let _ = response;
        output = output.set_key_group_list(
            crate::http_serde::deser_payload_list_key_groups_list_key_groups_output_key_group_list(
                response.body().as_ref(),
            )?,
        );
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_origin_access_controls_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListOriginAccessControlsOutput,
    crate::error::ListOriginAccessControlsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListOriginAccessControlsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ListOriginAccessControlsError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidArgument" => crate::error::ListOriginAccessControlsError::InvalidArgument({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_argument::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_invalid_argument_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListOriginAccessControlsError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::ListOriginAccessControlsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_origin_access_controls_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListOriginAccessControlsOutput,
    crate::error::ListOriginAccessControlsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_origin_access_controls_output::Builder::default();
        let _ = response;
        output = output.set_origin_access_control_list(
            crate::http_serde::deser_payload_list_origin_access_controls_list_origin_access_controls_output_origin_access_control_list(response.body().as_ref())?
        );
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_origin_request_policies_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListOriginRequestPoliciesOutput,
    crate::error::ListOriginRequestPoliciesError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListOriginRequestPoliciesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ListOriginRequestPoliciesError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AccessDenied" => crate::error::ListOriginRequestPoliciesError::AccessDenied({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::access_denied::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_access_denied_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListOriginRequestPoliciesError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidArgument" => crate::error::ListOriginRequestPoliciesError::InvalidArgument({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_argument::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_invalid_argument_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListOriginRequestPoliciesError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NoSuchOriginRequestPolicy" => {
            crate::error::ListOriginRequestPoliciesError::NoSuchOriginRequestPolicy({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::no_such_origin_request_policy::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_origin_request_policy_xml_err(response.body().as_ref(), output).map_err(crate::error::ListOriginRequestPoliciesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::ListOriginRequestPoliciesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_origin_request_policies_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListOriginRequestPoliciesOutput,
    crate::error::ListOriginRequestPoliciesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_origin_request_policies_output::Builder::default();
        let _ = response;
        output = output.set_origin_request_policy_list(
            crate::http_serde::deser_payload_list_origin_request_policies_list_origin_request_policies_output_origin_request_policy_list(response.body().as_ref())?
        );
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_public_keys_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListPublicKeysOutput, crate::error::ListPublicKeysError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListPublicKeysError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListPublicKeysError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidArgument" => crate::error::ListPublicKeysError::InvalidArgument({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_argument::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_invalid_argument_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListPublicKeysError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::ListPublicKeysError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_public_keys_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListPublicKeysOutput, crate::error::ListPublicKeysError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_public_keys_output::Builder::default();
        let _ = response;
        output = output.set_public_key_list(
            crate::http_serde::deser_payload_list_public_keys_list_public_keys_output_public_key_list(response.body().as_ref())?
        );
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_realtime_log_configs_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListRealtimeLogConfigsOutput,
    crate::error::ListRealtimeLogConfigsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListRealtimeLogConfigsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ListRealtimeLogConfigsError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AccessDenied" => crate::error::ListRealtimeLogConfigsError::AccessDenied({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::access_denied::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_access_denied_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListRealtimeLogConfigsError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidArgument" => crate::error::ListRealtimeLogConfigsError::InvalidArgument({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_argument::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_invalid_argument_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListRealtimeLogConfigsError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NoSuchRealtimeLogConfig" => {
            crate::error::ListRealtimeLogConfigsError::NoSuchRealtimeLogConfig({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_realtime_log_config::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_realtime_log_config_xml_err(response.body().as_ref(), output).map_err(crate::error::ListRealtimeLogConfigsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::ListRealtimeLogConfigsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_realtime_log_configs_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListRealtimeLogConfigsOutput,
    crate::error::ListRealtimeLogConfigsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_realtime_log_configs_output::Builder::default();
        let _ = response;
        output = output.set_realtime_log_configs(
            crate::http_serde::deser_payload_list_realtime_log_configs_list_realtime_log_configs_output_realtime_log_configs(response.body().as_ref())?
        );
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_response_headers_policies_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListResponseHeadersPoliciesOutput,
    crate::error::ListResponseHeadersPoliciesError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListResponseHeadersPoliciesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ListResponseHeadersPoliciesError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AccessDenied" => crate::error::ListResponseHeadersPoliciesError::AccessDenied({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::access_denied::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_access_denied_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListResponseHeadersPoliciesError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidArgument" => crate::error::ListResponseHeadersPoliciesError::InvalidArgument({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_argument::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_invalid_argument_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListResponseHeadersPoliciesError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NoSuchResponseHeadersPolicy" => {
            crate::error::ListResponseHeadersPoliciesError::NoSuchResponseHeadersPolicy({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::no_such_response_headers_policy::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_response_headers_policy_xml_err(response.body().as_ref(), output).map_err(crate::error::ListResponseHeadersPoliciesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::ListResponseHeadersPoliciesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_response_headers_policies_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListResponseHeadersPoliciesOutput,
    crate::error::ListResponseHeadersPoliciesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_response_headers_policies_output::Builder::default();
        let _ = response;
        output = output.set_response_headers_policy_list(
            crate::http_serde::deser_payload_list_response_headers_policies_list_response_headers_policies_output_response_headers_policy_list(response.body().as_ref())?
        );
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_streaming_distributions_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListStreamingDistributionsOutput,
    crate::error::ListStreamingDistributionsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListStreamingDistributionsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ListStreamingDistributionsError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidArgument" => crate::error::ListStreamingDistributionsError::InvalidArgument({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_argument::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_invalid_argument_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListStreamingDistributionsError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::ListStreamingDistributionsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_streaming_distributions_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListStreamingDistributionsOutput,
    crate::error::ListStreamingDistributionsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_streaming_distributions_output::Builder::default();
        let _ = response;
        output = output.set_streaming_distribution_list(
            crate::http_serde::deser_payload_list_streaming_distributions_list_streaming_distributions_output_streaming_distribution_list(response.body().as_ref())?
        );
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_tags_for_resource_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListTagsForResourceOutput,
    crate::error::ListTagsForResourceError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListTagsForResourceError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListTagsForResourceError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AccessDenied" => crate::error::ListTagsForResourceError::AccessDenied({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::access_denied::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_access_denied_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListTagsForResourceError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidArgument" => crate::error::ListTagsForResourceError::InvalidArgument({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_argument::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_invalid_argument_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListTagsForResourceError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidTagging" => crate::error::ListTagsForResourceError::InvalidTagging({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_tagging::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_invalid_tagging_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListTagsForResourceError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NoSuchResource" => crate::error::ListTagsForResourceError::NoSuchResource({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_resource::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_no_such_resource_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListTagsForResourceError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::ListTagsForResourceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_tags_for_resource_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListTagsForResourceOutput,
    crate::error::ListTagsForResourceError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_tags_for_resource_output::Builder::default();
        let _ = response;
        output = output.set_tags(
            crate::http_serde::deser_payload_list_tags_for_resource_list_tags_for_resource_output_tags(response.body().as_ref())?
        );
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_publish_function_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::PublishFunctionOutput, crate::error::PublishFunctionError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::PublishFunctionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::PublishFunctionError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidArgument" => crate::error::PublishFunctionError::InvalidArgument({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_argument::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_invalid_argument_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::PublishFunctionError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidIfMatchVersion" => {
            crate::error::PublishFunctionError::InvalidIfMatchVersion({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_if_match_version::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_if_match_version_xml_err(response.body().as_ref(), output).map_err(crate::error::PublishFunctionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "NoSuchFunctionExists" => {
            crate::error::PublishFunctionError::NoSuchFunctionExists({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_function_exists::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_function_exists_xml_err(response.body().as_ref(), output).map_err(crate::error::PublishFunctionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "PreconditionFailed" => crate::error::PublishFunctionError::PreconditionFailed({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::precondition_failed::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_precondition_failed_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::PublishFunctionError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "UnsupportedOperation" => {
            crate::error::PublishFunctionError::UnsupportedOperation({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unsupported_operation::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_unsupported_operation_xml_err(response.body().as_ref(), output).map_err(crate::error::PublishFunctionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::PublishFunctionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_publish_function_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::PublishFunctionOutput, crate::error::PublishFunctionError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::publish_function_output::Builder::default();
        let _ = response;
        output = output.set_function_summary(
            crate::http_serde::deser_payload_publish_function_publish_function_output_function_summary(response.body().as_ref())?
        );
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_tag_resource_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::TagResourceOutput, crate::error::TagResourceError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::TagResourceError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::TagResourceError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AccessDenied" => crate::error::TagResourceError::AccessDenied({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::access_denied::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_access_denied_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::TagResourceError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidArgument" => crate::error::TagResourceError::InvalidArgument({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_argument::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_invalid_argument_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::TagResourceError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidTagging" => crate::error::TagResourceError::InvalidTagging({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_tagging::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_invalid_tagging_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::TagResourceError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NoSuchResource" => crate::error::TagResourceError::NoSuchResource({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_resource::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_no_such_resource_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::TagResourceError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::TagResourceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_tag_resource_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::TagResourceOutput, crate::error::TagResourceError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::tag_resource_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_test_function_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::TestFunctionOutput, crate::error::TestFunctionError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::TestFunctionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::TestFunctionError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidArgument" => crate::error::TestFunctionError::InvalidArgument({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_argument::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_invalid_argument_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::TestFunctionError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidIfMatchVersion" => {
            crate::error::TestFunctionError::InvalidIfMatchVersion({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_if_match_version::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_if_match_version_xml_err(response.body().as_ref(), output).map_err(crate::error::TestFunctionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "NoSuchFunctionExists" => {
            crate::error::TestFunctionError::NoSuchFunctionExists({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_function_exists::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_function_exists_xml_err(response.body().as_ref(), output).map_err(crate::error::TestFunctionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "TestFunctionFailed" => crate::error::TestFunctionError::TestFunctionFailed({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::test_function_failed::Builder::default();
                let _ = response;
                output =
                    crate::xml_deser::deser_structure_crate_error_test_function_failed_xml_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::TestFunctionError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "UnsupportedOperation" => {
            crate::error::TestFunctionError::UnsupportedOperation({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unsupported_operation::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_unsupported_operation_xml_err(response.body().as_ref(), output).map_err(crate::error::TestFunctionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::TestFunctionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_test_function_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::TestFunctionOutput, crate::error::TestFunctionError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::test_function_output::Builder::default();
        let _ = response;
        output = output.set_test_result(
            crate::http_serde::deser_payload_test_function_test_function_output_test_result(
                response.body().as_ref(),
            )?,
        );
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_untag_resource_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UntagResourceOutput, crate::error::UntagResourceError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::UntagResourceError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UntagResourceError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AccessDenied" => crate::error::UntagResourceError::AccessDenied({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::access_denied::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_access_denied_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UntagResourceError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidArgument" => crate::error::UntagResourceError::InvalidArgument({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_argument::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_invalid_argument_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UntagResourceError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidTagging" => crate::error::UntagResourceError::InvalidTagging({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_tagging::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_invalid_tagging_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UntagResourceError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NoSuchResource" => crate::error::UntagResourceError::NoSuchResource({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_resource::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_no_such_resource_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UntagResourceError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::UntagResourceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_untag_resource_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UntagResourceOutput, crate::error::UntagResourceError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::untag_resource_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_cache_policy_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateCachePolicyOutput, crate::error::UpdateCachePolicyError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::UpdateCachePolicyError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdateCachePolicyError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AccessDenied" => crate::error::UpdateCachePolicyError::AccessDenied({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::access_denied::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_access_denied_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateCachePolicyError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "CachePolicyAlreadyExists" => {
            crate::error::UpdateCachePolicyError::CachePolicyAlreadyExists({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::cache_policy_already_exists::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_cache_policy_already_exists_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateCachePolicyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "IllegalUpdate" => crate::error::UpdateCachePolicyError::IllegalUpdate({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::illegal_update::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_illegal_update_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateCachePolicyError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InconsistentQuantities" => {
            crate::error::UpdateCachePolicyError::InconsistentQuantities({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::inconsistent_quantities::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_inconsistent_quantities_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateCachePolicyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidArgument" => crate::error::UpdateCachePolicyError::InvalidArgument({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_argument::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_invalid_argument_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateCachePolicyError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidIfMatchVersion" => {
            crate::error::UpdateCachePolicyError::InvalidIfMatchVersion({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_if_match_version::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_if_match_version_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateCachePolicyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "NoSuchCachePolicy" => crate::error::UpdateCachePolicyError::NoSuchCachePolicy({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_cache_policy::Builder::default();
                let _ = response;
                output =
                    crate::xml_deser::deser_structure_crate_error_no_such_cache_policy_xml_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::UpdateCachePolicyError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "PreconditionFailed" => crate::error::UpdateCachePolicyError::PreconditionFailed({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::precondition_failed::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_precondition_failed_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateCachePolicyError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "TooManyCookiesInCachePolicy" => {
            crate::error::UpdateCachePolicyError::TooManyCookiesInCachePolicy({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::too_many_cookies_in_cache_policy::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_cookies_in_cache_policy_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateCachePolicyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "TooManyHeadersInCachePolicy" => {
            crate::error::UpdateCachePolicyError::TooManyHeadersInCachePolicy({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::too_many_headers_in_cache_policy::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_headers_in_cache_policy_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateCachePolicyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "TooManyQueryStringsInCachePolicy" => {
            crate::error::UpdateCachePolicyError::TooManyQueryStringsInCachePolicy({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::too_many_query_strings_in_cache_policy::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_query_strings_in_cache_policy_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateCachePolicyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::UpdateCachePolicyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_cache_policy_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateCachePolicyOutput, crate::error::UpdateCachePolicyError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_cache_policy_output::Builder::default();
        let _ = response;
        output = output.set_cache_policy(
            crate::http_serde::deser_payload_update_cache_policy_update_cache_policy_output_cache_policy(response.body().as_ref())?
        );
        output = output.set_e_tag(
            crate::http_serde::deser_header_update_cache_policy_update_cache_policy_output_e_tag(
                response.headers(),
            )
            .map_err(|_| {
                crate::error::UpdateCachePolicyError::unhandled(
                    "Failed to parse ETag from header `ETag",
                )
            })?,
        );
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_cloud_front_origin_access_identity_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateCloudFrontOriginAccessIdentityOutput,
    crate::error::UpdateCloudFrontOriginAccessIdentityError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::UpdateCloudFrontOriginAccessIdentityError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::UpdateCloudFrontOriginAccessIdentityError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AccessDenied" => crate::error::UpdateCloudFrontOriginAccessIdentityError::AccessDenied({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::access_denied::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_access_denied_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateCloudFrontOriginAccessIdentityError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "IllegalUpdate" => crate::error::UpdateCloudFrontOriginAccessIdentityError::IllegalUpdate({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::illegal_update::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_illegal_update_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateCloudFrontOriginAccessIdentityError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InconsistentQuantities" => crate::error::UpdateCloudFrontOriginAccessIdentityError::InconsistentQuantities({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::inconsistent_quantities::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_inconsistent_quantities_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateCloudFrontOriginAccessIdentityError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidArgument" => crate::error::UpdateCloudFrontOriginAccessIdentityError::InvalidArgument({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_argument::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_argument_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateCloudFrontOriginAccessIdentityError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidIfMatchVersion" => crate::error::UpdateCloudFrontOriginAccessIdentityError::InvalidIfMatchVersion({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_if_match_version::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_if_match_version_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateCloudFrontOriginAccessIdentityError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "MissingBody" => crate::error::UpdateCloudFrontOriginAccessIdentityError::MissingBody({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::missing_body::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_missing_body_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateCloudFrontOriginAccessIdentityError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "NoSuchCloudFrontOriginAccessIdentity" => crate::error::UpdateCloudFrontOriginAccessIdentityError::NoSuchCloudFrontOriginAccessIdentity({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_cloud_front_origin_access_identity::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_cloud_front_origin_access_identity_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateCloudFrontOriginAccessIdentityError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "PreconditionFailed" => crate::error::UpdateCloudFrontOriginAccessIdentityError::PreconditionFailed({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::precondition_failed::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_precondition_failed_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateCloudFrontOriginAccessIdentityError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::UpdateCloudFrontOriginAccessIdentityError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_cloud_front_origin_access_identity_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateCloudFrontOriginAccessIdentityOutput,
    crate::error::UpdateCloudFrontOriginAccessIdentityError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::update_cloud_front_origin_access_identity_output::Builder::default();
        let _ = response;
        output = output.set_cloud_front_origin_access_identity(
            crate::http_serde::deser_payload_update_cloud_front_origin_access_identity_update_cloud_front_origin_access_identity_output_cloud_front_origin_access_identity(response.body().as_ref())?
        );
        output = output.set_e_tag(
            crate::http_serde::deser_header_update_cloud_front_origin_access_identity_update_cloud_front_origin_access_identity_output_e_tag(response.headers())
                                    .map_err(|_|crate::error::UpdateCloudFrontOriginAccessIdentityError::unhandled("Failed to parse ETag from header `ETag"))?
        );
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_continuous_deployment_policy_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateContinuousDeploymentPolicyOutput,
    crate::error::UpdateContinuousDeploymentPolicyError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::UpdateContinuousDeploymentPolicyError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::UpdateContinuousDeploymentPolicyError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AccessDenied" => crate::error::UpdateContinuousDeploymentPolicyError::AccessDenied({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::access_denied::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_access_denied_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateContinuousDeploymentPolicyError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InconsistentQuantities" => {
            crate::error::UpdateContinuousDeploymentPolicyError::InconsistentQuantities({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::inconsistent_quantities::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_inconsistent_quantities_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateContinuousDeploymentPolicyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidArgument" => {
            crate::error::UpdateContinuousDeploymentPolicyError::InvalidArgument({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_argument::Builder::default();
                    let _ = response;
                    output =
                        crate::xml_deser::deser_structure_crate_error_invalid_argument_xml_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::UpdateContinuousDeploymentPolicyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidIfMatchVersion" => {
            crate::error::UpdateContinuousDeploymentPolicyError::InvalidIfMatchVersion({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_if_match_version::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_if_match_version_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateContinuousDeploymentPolicyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "NoSuchContinuousDeploymentPolicy" => {
            crate::error::UpdateContinuousDeploymentPolicyError::NoSuchContinuousDeploymentPolicy({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::no_such_continuous_deployment_policy::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_continuous_deployment_policy_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateContinuousDeploymentPolicyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "PreconditionFailed" => {
            crate::error::UpdateContinuousDeploymentPolicyError::PreconditionFailed({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::precondition_failed::Builder::default();
                    let _ = response;
                    output =
                        crate::xml_deser::deser_structure_crate_error_precondition_failed_xml_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::UpdateContinuousDeploymentPolicyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "StagingDistributionInUse" => {
            crate::error::UpdateContinuousDeploymentPolicyError::StagingDistributionInUse({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::staging_distribution_in_use::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_staging_distribution_in_use_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateContinuousDeploymentPolicyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::UpdateContinuousDeploymentPolicyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_continuous_deployment_policy_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateContinuousDeploymentPolicyOutput,
    crate::error::UpdateContinuousDeploymentPolicyError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::update_continuous_deployment_policy_output::Builder::default();
        let _ = response;
        output = output.set_continuous_deployment_policy(
            crate::http_serde::deser_payload_update_continuous_deployment_policy_update_continuous_deployment_policy_output_continuous_deployment_policy(response.body().as_ref())?
        );
        output = output.set_e_tag(
            crate::http_serde::deser_header_update_continuous_deployment_policy_update_continuous_deployment_policy_output_e_tag(response.headers())
                                    .map_err(|_|crate::error::UpdateContinuousDeploymentPolicyError::unhandled("Failed to parse ETag from header `ETag"))?
        );
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_distribution_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateDistributionOutput,
    crate::error::UpdateDistributionError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::UpdateDistributionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdateDistributionError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AccessDenied" => crate::error::UpdateDistributionError::AccessDenied({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::access_denied::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_access_denied_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "CNAMEAlreadyExists" => crate::error::UpdateDistributionError::CnameAlreadyExists({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::cname_already_exists::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_cname_already_exists_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "ContinuousDeploymentPolicyInUse" => crate::error::UpdateDistributionError::ContinuousDeploymentPolicyInUse({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::continuous_deployment_policy_in_use::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_continuous_deployment_policy_in_use_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior" => crate::error::UpdateDistributionError::IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::illegal_field_level_encryption_config_association_with_cache_behavior::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_illegal_field_level_encryption_config_association_with_cache_behavior_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "IllegalOriginAccessConfiguration" => crate::error::UpdateDistributionError::IllegalOriginAccessConfiguration({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::illegal_origin_access_configuration::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_illegal_origin_access_configuration_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "IllegalUpdate" => crate::error::UpdateDistributionError::IllegalUpdate({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::illegal_update::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_illegal_update_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InconsistentQuantities" => crate::error::UpdateDistributionError::InconsistentQuantities({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::inconsistent_quantities::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_inconsistent_quantities_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidArgument" => crate::error::UpdateDistributionError::InvalidArgument({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_argument::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_argument_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidDefaultRootObject" => crate::error::UpdateDistributionError::InvalidDefaultRootObject({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_default_root_object::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_default_root_object_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidDomainNameForOriginAccessControl" => crate::error::UpdateDistributionError::InvalidDomainNameForOriginAccessControl({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_domain_name_for_origin_access_control::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_domain_name_for_origin_access_control_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidErrorCode" => crate::error::UpdateDistributionError::InvalidErrorCode({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_error_code::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_error_code_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidForwardCookies" => crate::error::UpdateDistributionError::InvalidForwardCookies({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_forward_cookies::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_forward_cookies_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidFunctionAssociation" => crate::error::UpdateDistributionError::InvalidFunctionAssociation({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_function_association::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_function_association_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidGeoRestrictionParameter" => crate::error::UpdateDistributionError::InvalidGeoRestrictionParameter({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_geo_restriction_parameter::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_geo_restriction_parameter_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidHeadersForS3Origin" => crate::error::UpdateDistributionError::InvalidHeadersForS3Origin({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_headers_for_s3_origin::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_headers_for_s3_origin_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidIfMatchVersion" => crate::error::UpdateDistributionError::InvalidIfMatchVersion({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_if_match_version::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_if_match_version_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidLambdaFunctionAssociation" => crate::error::UpdateDistributionError::InvalidLambdaFunctionAssociation({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_lambda_function_association::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_lambda_function_association_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidLocationCode" => crate::error::UpdateDistributionError::InvalidLocationCode({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_location_code::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_location_code_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidMinimumProtocolVersion" => crate::error::UpdateDistributionError::InvalidMinimumProtocolVersion({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_minimum_protocol_version::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_minimum_protocol_version_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidOriginAccessControl" => crate::error::UpdateDistributionError::InvalidOriginAccessControl({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_origin_access_control::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_origin_access_control_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidOriginAccessIdentity" => crate::error::UpdateDistributionError::InvalidOriginAccessIdentity({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_origin_access_identity::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_origin_access_identity_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidOriginKeepaliveTimeout" => crate::error::UpdateDistributionError::InvalidOriginKeepaliveTimeout({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_origin_keepalive_timeout::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_origin_keepalive_timeout_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidOriginReadTimeout" => crate::error::UpdateDistributionError::InvalidOriginReadTimeout({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_origin_read_timeout::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_origin_read_timeout_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidQueryStringParameters" => crate::error::UpdateDistributionError::InvalidQueryStringParameters({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_query_string_parameters::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_query_string_parameters_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidRelativePath" => crate::error::UpdateDistributionError::InvalidRelativePath({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_relative_path::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_relative_path_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidRequiredProtocol" => crate::error::UpdateDistributionError::InvalidRequiredProtocol({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_required_protocol::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_required_protocol_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidResponseCode" => crate::error::UpdateDistributionError::InvalidResponseCode({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_response_code::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_response_code_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidTTLOrder" => crate::error::UpdateDistributionError::InvalidTtlOrder({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_ttl_order::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_ttl_order_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidViewerCertificate" => crate::error::UpdateDistributionError::InvalidViewerCertificate({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_viewer_certificate::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_viewer_certificate_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidWebACLId" => crate::error::UpdateDistributionError::InvalidWebAclId({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_web_acl_id::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_web_acl_id_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "MissingBody" => crate::error::UpdateDistributionError::MissingBody({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::missing_body::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_missing_body_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "NoSuchCachePolicy" => crate::error::UpdateDistributionError::NoSuchCachePolicy({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_cache_policy::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_cache_policy_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "NoSuchContinuousDeploymentPolicy" => crate::error::UpdateDistributionError::NoSuchContinuousDeploymentPolicy({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_continuous_deployment_policy::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_continuous_deployment_policy_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "NoSuchDistribution" => crate::error::UpdateDistributionError::NoSuchDistribution({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_distribution::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_distribution_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "NoSuchFieldLevelEncryptionConfig" => crate::error::UpdateDistributionError::NoSuchFieldLevelEncryptionConfig({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_field_level_encryption_config::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_field_level_encryption_config_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "NoSuchOrigin" => crate::error::UpdateDistributionError::NoSuchOrigin({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_origin::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_origin_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "NoSuchOriginRequestPolicy" => crate::error::UpdateDistributionError::NoSuchOriginRequestPolicy({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_origin_request_policy::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_origin_request_policy_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "NoSuchRealtimeLogConfig" => crate::error::UpdateDistributionError::NoSuchRealtimeLogConfig({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_realtime_log_config::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_realtime_log_config_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "NoSuchResponseHeadersPolicy" => crate::error::UpdateDistributionError::NoSuchResponseHeadersPolicy({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_response_headers_policy::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_response_headers_policy_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "PreconditionFailed" => crate::error::UpdateDistributionError::PreconditionFailed({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::precondition_failed::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_precondition_failed_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "RealtimeLogConfigOwnerMismatch" => crate::error::UpdateDistributionError::RealtimeLogConfigOwnerMismatch({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::realtime_log_config_owner_mismatch::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_realtime_log_config_owner_mismatch_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "StagingDistributionInUse" => crate::error::UpdateDistributionError::StagingDistributionInUse({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::staging_distribution_in_use::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_staging_distribution_in_use_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyCacheBehaviors" => crate::error::UpdateDistributionError::TooManyCacheBehaviors({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_cache_behaviors::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_cache_behaviors_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyCertificates" => crate::error::UpdateDistributionError::TooManyCertificates({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_certificates::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_certificates_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyCookieNamesInWhiteList" => crate::error::UpdateDistributionError::TooManyCookieNamesInWhiteList({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_cookie_names_in_white_list::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_cookie_names_in_white_list_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyDistributionCNAMEs" => crate::error::UpdateDistributionError::TooManyDistributionCnamEs({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_distribution_cnam_es::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_distribution_cnam_es_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyDistributionsAssociatedToCachePolicy" => crate::error::UpdateDistributionError::TooManyDistributionsAssociatedToCachePolicy({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_distributions_associated_to_cache_policy::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_distributions_associated_to_cache_policy_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyDistributionsAssociatedToFieldLevelEncryptionConfig" => crate::error::UpdateDistributionError::TooManyDistributionsAssociatedToFieldLevelEncryptionConfig({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_distributions_associated_to_field_level_encryption_config::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_distributions_associated_to_field_level_encryption_config_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyDistributionsAssociatedToKeyGroup" => crate::error::UpdateDistributionError::TooManyDistributionsAssociatedToKeyGroup({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_distributions_associated_to_key_group::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_distributions_associated_to_key_group_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyDistributionsAssociatedToOriginRequestPolicy" => crate::error::UpdateDistributionError::TooManyDistributionsAssociatedToOriginRequestPolicy({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_distributions_associated_to_origin_request_policy::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_distributions_associated_to_origin_request_policy_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyDistributionsAssociatedToResponseHeadersPolicy" => crate::error::UpdateDistributionError::TooManyDistributionsAssociatedToResponseHeadersPolicy({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_distributions_associated_to_response_headers_policy::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_distributions_associated_to_response_headers_policy_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyDistributionsWithFunctionAssociations" => crate::error::UpdateDistributionError::TooManyDistributionsWithFunctionAssociations({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_distributions_with_function_associations::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_distributions_with_function_associations_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyDistributionsWithLambdaAssociations" => crate::error::UpdateDistributionError::TooManyDistributionsWithLambdaAssociations({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_distributions_with_lambda_associations::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_distributions_with_lambda_associations_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyDistributionsWithSingleFunctionARN" => crate::error::UpdateDistributionError::TooManyDistributionsWithSingleFunctionArn({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_distributions_with_single_function_arn::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_distributions_with_single_function_arn_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyFunctionAssociations" => crate::error::UpdateDistributionError::TooManyFunctionAssociations({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_function_associations::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_function_associations_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyHeadersInForwardedValues" => crate::error::UpdateDistributionError::TooManyHeadersInForwardedValues({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_headers_in_forwarded_values::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_headers_in_forwarded_values_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyKeyGroupsAssociatedToDistribution" => crate::error::UpdateDistributionError::TooManyKeyGroupsAssociatedToDistribution({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_key_groups_associated_to_distribution::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_key_groups_associated_to_distribution_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyLambdaFunctionAssociations" => crate::error::UpdateDistributionError::TooManyLambdaFunctionAssociations({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_lambda_function_associations::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_lambda_function_associations_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyOriginCustomHeaders" => crate::error::UpdateDistributionError::TooManyOriginCustomHeaders({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_origin_custom_headers::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_origin_custom_headers_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyOriginGroupsPerDistribution" => crate::error::UpdateDistributionError::TooManyOriginGroupsPerDistribution({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_origin_groups_per_distribution::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_origin_groups_per_distribution_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyOrigins" => crate::error::UpdateDistributionError::TooManyOrigins({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_origins::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_origins_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyQueryStringParameters" => crate::error::UpdateDistributionError::TooManyQueryStringParameters({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_query_string_parameters::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_query_string_parameters_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyTrustedSigners" => crate::error::UpdateDistributionError::TooManyTrustedSigners({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_trusted_signers::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_trusted_signers_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TrustedKeyGroupDoesNotExist" => crate::error::UpdateDistributionError::TrustedKeyGroupDoesNotExist({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::trusted_key_group_does_not_exist::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_trusted_key_group_does_not_exist_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TrustedSignerDoesNotExist" => crate::error::UpdateDistributionError::TrustedSignerDoesNotExist({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::trusted_signer_does_not_exist::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_trusted_signer_does_not_exist_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::UpdateDistributionError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_distribution_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateDistributionOutput,
    crate::error::UpdateDistributionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_distribution_output::Builder::default();
        let _ = response;
        output = output.set_distribution(
            crate::http_serde::deser_payload_update_distribution_update_distribution_output_distribution(response.body().as_ref())?
        );
        output = output.set_e_tag(
            crate::http_serde::deser_header_update_distribution_update_distribution_output_e_tag(
                response.headers(),
            )
            .map_err(|_| {
                crate::error::UpdateDistributionError::unhandled(
                    "Failed to parse ETag from header `ETag",
                )
            })?,
        );
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_distribution_with_staging_config_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateDistributionWithStagingConfigOutput,
    crate::error::UpdateDistributionWithStagingConfigError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::UpdateDistributionWithStagingConfigError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::UpdateDistributionWithStagingConfigError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AccessDenied" => crate::error::UpdateDistributionWithStagingConfigError::AccessDenied({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::access_denied::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_access_denied_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionWithStagingConfigError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "CNAMEAlreadyExists" => crate::error::UpdateDistributionWithStagingConfigError::CnameAlreadyExists({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::cname_already_exists::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_cname_already_exists_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionWithStagingConfigError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior" => crate::error::UpdateDistributionWithStagingConfigError::IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::illegal_field_level_encryption_config_association_with_cache_behavior::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_illegal_field_level_encryption_config_association_with_cache_behavior_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionWithStagingConfigError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "IllegalUpdate" => crate::error::UpdateDistributionWithStagingConfigError::IllegalUpdate({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::illegal_update::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_illegal_update_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionWithStagingConfigError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InconsistentQuantities" => crate::error::UpdateDistributionWithStagingConfigError::InconsistentQuantities({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::inconsistent_quantities::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_inconsistent_quantities_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionWithStagingConfigError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidArgument" => crate::error::UpdateDistributionWithStagingConfigError::InvalidArgument({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_argument::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_argument_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionWithStagingConfigError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidDefaultRootObject" => crate::error::UpdateDistributionWithStagingConfigError::InvalidDefaultRootObject({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_default_root_object::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_default_root_object_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionWithStagingConfigError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidErrorCode" => crate::error::UpdateDistributionWithStagingConfigError::InvalidErrorCode({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_error_code::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_error_code_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionWithStagingConfigError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidForwardCookies" => crate::error::UpdateDistributionWithStagingConfigError::InvalidForwardCookies({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_forward_cookies::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_forward_cookies_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionWithStagingConfigError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidFunctionAssociation" => crate::error::UpdateDistributionWithStagingConfigError::InvalidFunctionAssociation({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_function_association::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_function_association_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionWithStagingConfigError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidGeoRestrictionParameter" => crate::error::UpdateDistributionWithStagingConfigError::InvalidGeoRestrictionParameter({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_geo_restriction_parameter::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_geo_restriction_parameter_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionWithStagingConfigError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidHeadersForS3Origin" => crate::error::UpdateDistributionWithStagingConfigError::InvalidHeadersForS3Origin({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_headers_for_s3_origin::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_headers_for_s3_origin_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionWithStagingConfigError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidIfMatchVersion" => crate::error::UpdateDistributionWithStagingConfigError::InvalidIfMatchVersion({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_if_match_version::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_if_match_version_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionWithStagingConfigError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidLambdaFunctionAssociation" => crate::error::UpdateDistributionWithStagingConfigError::InvalidLambdaFunctionAssociation({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_lambda_function_association::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_lambda_function_association_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionWithStagingConfigError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidLocationCode" => crate::error::UpdateDistributionWithStagingConfigError::InvalidLocationCode({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_location_code::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_location_code_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionWithStagingConfigError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidMinimumProtocolVersion" => crate::error::UpdateDistributionWithStagingConfigError::InvalidMinimumProtocolVersion({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_minimum_protocol_version::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_minimum_protocol_version_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionWithStagingConfigError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidOriginAccessControl" => crate::error::UpdateDistributionWithStagingConfigError::InvalidOriginAccessControl({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_origin_access_control::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_origin_access_control_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionWithStagingConfigError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidOriginAccessIdentity" => crate::error::UpdateDistributionWithStagingConfigError::InvalidOriginAccessIdentity({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_origin_access_identity::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_origin_access_identity_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionWithStagingConfigError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidOriginKeepaliveTimeout" => crate::error::UpdateDistributionWithStagingConfigError::InvalidOriginKeepaliveTimeout({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_origin_keepalive_timeout::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_origin_keepalive_timeout_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionWithStagingConfigError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidOriginReadTimeout" => crate::error::UpdateDistributionWithStagingConfigError::InvalidOriginReadTimeout({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_origin_read_timeout::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_origin_read_timeout_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionWithStagingConfigError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidQueryStringParameters" => crate::error::UpdateDistributionWithStagingConfigError::InvalidQueryStringParameters({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_query_string_parameters::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_query_string_parameters_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionWithStagingConfigError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidRelativePath" => crate::error::UpdateDistributionWithStagingConfigError::InvalidRelativePath({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_relative_path::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_relative_path_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionWithStagingConfigError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidRequiredProtocol" => crate::error::UpdateDistributionWithStagingConfigError::InvalidRequiredProtocol({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_required_protocol::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_required_protocol_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionWithStagingConfigError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidResponseCode" => crate::error::UpdateDistributionWithStagingConfigError::InvalidResponseCode({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_response_code::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_response_code_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionWithStagingConfigError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidTTLOrder" => crate::error::UpdateDistributionWithStagingConfigError::InvalidTtlOrder({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_ttl_order::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_ttl_order_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionWithStagingConfigError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidViewerCertificate" => crate::error::UpdateDistributionWithStagingConfigError::InvalidViewerCertificate({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_viewer_certificate::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_viewer_certificate_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionWithStagingConfigError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidWebACLId" => crate::error::UpdateDistributionWithStagingConfigError::InvalidWebAclId({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_web_acl_id::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_web_acl_id_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionWithStagingConfigError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "MissingBody" => crate::error::UpdateDistributionWithStagingConfigError::MissingBody({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::missing_body::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_missing_body_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionWithStagingConfigError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "NoSuchCachePolicy" => crate::error::UpdateDistributionWithStagingConfigError::NoSuchCachePolicy({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_cache_policy::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_cache_policy_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionWithStagingConfigError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "NoSuchDistribution" => crate::error::UpdateDistributionWithStagingConfigError::NoSuchDistribution({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_distribution::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_distribution_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionWithStagingConfigError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "NoSuchFieldLevelEncryptionConfig" => crate::error::UpdateDistributionWithStagingConfigError::NoSuchFieldLevelEncryptionConfig({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_field_level_encryption_config::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_field_level_encryption_config_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionWithStagingConfigError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "NoSuchOrigin" => crate::error::UpdateDistributionWithStagingConfigError::NoSuchOrigin({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_origin::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_origin_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionWithStagingConfigError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "NoSuchOriginRequestPolicy" => crate::error::UpdateDistributionWithStagingConfigError::NoSuchOriginRequestPolicy({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_origin_request_policy::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_origin_request_policy_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionWithStagingConfigError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "NoSuchRealtimeLogConfig" => crate::error::UpdateDistributionWithStagingConfigError::NoSuchRealtimeLogConfig({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_realtime_log_config::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_realtime_log_config_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionWithStagingConfigError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "NoSuchResponseHeadersPolicy" => crate::error::UpdateDistributionWithStagingConfigError::NoSuchResponseHeadersPolicy({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_response_headers_policy::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_response_headers_policy_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionWithStagingConfigError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "PreconditionFailed" => crate::error::UpdateDistributionWithStagingConfigError::PreconditionFailed({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::precondition_failed::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_precondition_failed_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionWithStagingConfigError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "RealtimeLogConfigOwnerMismatch" => crate::error::UpdateDistributionWithStagingConfigError::RealtimeLogConfigOwnerMismatch({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::realtime_log_config_owner_mismatch::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_realtime_log_config_owner_mismatch_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionWithStagingConfigError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyCacheBehaviors" => crate::error::UpdateDistributionWithStagingConfigError::TooManyCacheBehaviors({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_cache_behaviors::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_cache_behaviors_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionWithStagingConfigError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyCertificates" => crate::error::UpdateDistributionWithStagingConfigError::TooManyCertificates({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_certificates::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_certificates_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionWithStagingConfigError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyCookieNamesInWhiteList" => crate::error::UpdateDistributionWithStagingConfigError::TooManyCookieNamesInWhiteList({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_cookie_names_in_white_list::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_cookie_names_in_white_list_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionWithStagingConfigError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyDistributionCNAMEs" => crate::error::UpdateDistributionWithStagingConfigError::TooManyDistributionCnamEs({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_distribution_cnam_es::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_distribution_cnam_es_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionWithStagingConfigError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyDistributionsAssociatedToCachePolicy" => crate::error::UpdateDistributionWithStagingConfigError::TooManyDistributionsAssociatedToCachePolicy({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_distributions_associated_to_cache_policy::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_distributions_associated_to_cache_policy_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionWithStagingConfigError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyDistributionsAssociatedToFieldLevelEncryptionConfig" => crate::error::UpdateDistributionWithStagingConfigError::TooManyDistributionsAssociatedToFieldLevelEncryptionConfig({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_distributions_associated_to_field_level_encryption_config::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_distributions_associated_to_field_level_encryption_config_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionWithStagingConfigError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyDistributionsAssociatedToKeyGroup" => crate::error::UpdateDistributionWithStagingConfigError::TooManyDistributionsAssociatedToKeyGroup({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_distributions_associated_to_key_group::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_distributions_associated_to_key_group_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionWithStagingConfigError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyDistributionsAssociatedToOriginRequestPolicy" => crate::error::UpdateDistributionWithStagingConfigError::TooManyDistributionsAssociatedToOriginRequestPolicy({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_distributions_associated_to_origin_request_policy::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_distributions_associated_to_origin_request_policy_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionWithStagingConfigError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyDistributionsAssociatedToResponseHeadersPolicy" => crate::error::UpdateDistributionWithStagingConfigError::TooManyDistributionsAssociatedToResponseHeadersPolicy({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_distributions_associated_to_response_headers_policy::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_distributions_associated_to_response_headers_policy_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionWithStagingConfigError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyDistributionsWithFunctionAssociations" => crate::error::UpdateDistributionWithStagingConfigError::TooManyDistributionsWithFunctionAssociations({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_distributions_with_function_associations::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_distributions_with_function_associations_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionWithStagingConfigError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyDistributionsWithLambdaAssociations" => crate::error::UpdateDistributionWithStagingConfigError::TooManyDistributionsWithLambdaAssociations({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_distributions_with_lambda_associations::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_distributions_with_lambda_associations_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionWithStagingConfigError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyDistributionsWithSingleFunctionARN" => crate::error::UpdateDistributionWithStagingConfigError::TooManyDistributionsWithSingleFunctionArn({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_distributions_with_single_function_arn::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_distributions_with_single_function_arn_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionWithStagingConfigError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyFunctionAssociations" => crate::error::UpdateDistributionWithStagingConfigError::TooManyFunctionAssociations({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_function_associations::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_function_associations_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionWithStagingConfigError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyHeadersInForwardedValues" => crate::error::UpdateDistributionWithStagingConfigError::TooManyHeadersInForwardedValues({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_headers_in_forwarded_values::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_headers_in_forwarded_values_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionWithStagingConfigError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyKeyGroupsAssociatedToDistribution" => crate::error::UpdateDistributionWithStagingConfigError::TooManyKeyGroupsAssociatedToDistribution({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_key_groups_associated_to_distribution::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_key_groups_associated_to_distribution_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionWithStagingConfigError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyLambdaFunctionAssociations" => crate::error::UpdateDistributionWithStagingConfigError::TooManyLambdaFunctionAssociations({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_lambda_function_associations::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_lambda_function_associations_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionWithStagingConfigError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyOriginCustomHeaders" => crate::error::UpdateDistributionWithStagingConfigError::TooManyOriginCustomHeaders({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_origin_custom_headers::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_origin_custom_headers_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionWithStagingConfigError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyOriginGroupsPerDistribution" => crate::error::UpdateDistributionWithStagingConfigError::TooManyOriginGroupsPerDistribution({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_origin_groups_per_distribution::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_origin_groups_per_distribution_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionWithStagingConfigError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyOrigins" => crate::error::UpdateDistributionWithStagingConfigError::TooManyOrigins({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_origins::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_origins_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionWithStagingConfigError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyQueryStringParameters" => crate::error::UpdateDistributionWithStagingConfigError::TooManyQueryStringParameters({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_query_string_parameters::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_query_string_parameters_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionWithStagingConfigError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyTrustedSigners" => crate::error::UpdateDistributionWithStagingConfigError::TooManyTrustedSigners({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_trusted_signers::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_trusted_signers_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionWithStagingConfigError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TrustedKeyGroupDoesNotExist" => crate::error::UpdateDistributionWithStagingConfigError::TrustedKeyGroupDoesNotExist({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::trusted_key_group_does_not_exist::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_trusted_key_group_does_not_exist_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionWithStagingConfigError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TrustedSignerDoesNotExist" => crate::error::UpdateDistributionWithStagingConfigError::TrustedSignerDoesNotExist({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::trusted_signer_does_not_exist::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_trusted_signer_does_not_exist_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateDistributionWithStagingConfigError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::UpdateDistributionWithStagingConfigError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_distribution_with_staging_config_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateDistributionWithStagingConfigOutput,
    crate::error::UpdateDistributionWithStagingConfigError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::update_distribution_with_staging_config_output::Builder::default();
        let _ = response;
        output = output.set_distribution(
            crate::http_serde::deser_payload_update_distribution_with_staging_config_update_distribution_with_staging_config_output_distribution(response.body().as_ref())?
        );
        output = output.set_e_tag(
            crate::http_serde::deser_header_update_distribution_with_staging_config_update_distribution_with_staging_config_output_e_tag(response.headers())
                                    .map_err(|_|crate::error::UpdateDistributionWithStagingConfigError::unhandled("Failed to parse ETag from header `ETag"))?
        );
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_field_level_encryption_config_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateFieldLevelEncryptionConfigOutput,
    crate::error::UpdateFieldLevelEncryptionConfigError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::UpdateFieldLevelEncryptionConfigError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::UpdateFieldLevelEncryptionConfigError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AccessDenied" => crate::error::UpdateFieldLevelEncryptionConfigError::AccessDenied({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::access_denied::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_access_denied_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateFieldLevelEncryptionConfigError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "IllegalUpdate" => crate::error::UpdateFieldLevelEncryptionConfigError::IllegalUpdate({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::illegal_update::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_illegal_update_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateFieldLevelEncryptionConfigError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InconsistentQuantities" => crate::error::UpdateFieldLevelEncryptionConfigError::InconsistentQuantities({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::inconsistent_quantities::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_inconsistent_quantities_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateFieldLevelEncryptionConfigError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidArgument" => crate::error::UpdateFieldLevelEncryptionConfigError::InvalidArgument({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_argument::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_argument_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateFieldLevelEncryptionConfigError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidIfMatchVersion" => crate::error::UpdateFieldLevelEncryptionConfigError::InvalidIfMatchVersion({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_if_match_version::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_if_match_version_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateFieldLevelEncryptionConfigError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "NoSuchFieldLevelEncryptionConfig" => crate::error::UpdateFieldLevelEncryptionConfigError::NoSuchFieldLevelEncryptionConfig({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_field_level_encryption_config::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_field_level_encryption_config_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateFieldLevelEncryptionConfigError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "NoSuchFieldLevelEncryptionProfile" => crate::error::UpdateFieldLevelEncryptionConfigError::NoSuchFieldLevelEncryptionProfile({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_field_level_encryption_profile::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_field_level_encryption_profile_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateFieldLevelEncryptionConfigError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "PreconditionFailed" => crate::error::UpdateFieldLevelEncryptionConfigError::PreconditionFailed({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::precondition_failed::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_precondition_failed_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateFieldLevelEncryptionConfigError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "QueryArgProfileEmpty" => crate::error::UpdateFieldLevelEncryptionConfigError::QueryArgProfileEmpty({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::query_arg_profile_empty::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_query_arg_profile_empty_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateFieldLevelEncryptionConfigError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyFieldLevelEncryptionContentTypeProfiles" => crate::error::UpdateFieldLevelEncryptionConfigError::TooManyFieldLevelEncryptionContentTypeProfiles({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_field_level_encryption_content_type_profiles::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_field_level_encryption_content_type_profiles_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateFieldLevelEncryptionConfigError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyFieldLevelEncryptionQueryArgProfiles" => crate::error::UpdateFieldLevelEncryptionConfigError::TooManyFieldLevelEncryptionQueryArgProfiles({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_field_level_encryption_query_arg_profiles::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_field_level_encryption_query_arg_profiles_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateFieldLevelEncryptionConfigError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::UpdateFieldLevelEncryptionConfigError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_field_level_encryption_config_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateFieldLevelEncryptionConfigOutput,
    crate::error::UpdateFieldLevelEncryptionConfigError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::update_field_level_encryption_config_output::Builder::default();
        let _ = response;
        output = output.set_e_tag(
            crate::http_serde::deser_header_update_field_level_encryption_config_update_field_level_encryption_config_output_e_tag(response.headers())
                                    .map_err(|_|crate::error::UpdateFieldLevelEncryptionConfigError::unhandled("Failed to parse ETag from header `ETag"))?
        );
        output = output.set_field_level_encryption(
            crate::http_serde::deser_payload_update_field_level_encryption_config_update_field_level_encryption_config_output_field_level_encryption(response.body().as_ref())?
        );
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_field_level_encryption_profile_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateFieldLevelEncryptionProfileOutput,
    crate::error::UpdateFieldLevelEncryptionProfileError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::UpdateFieldLevelEncryptionProfileError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::UpdateFieldLevelEncryptionProfileError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AccessDenied" => crate::error::UpdateFieldLevelEncryptionProfileError::AccessDenied({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::access_denied::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_access_denied_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateFieldLevelEncryptionProfileError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "FieldLevelEncryptionProfileAlreadyExists" => crate::error::UpdateFieldLevelEncryptionProfileError::FieldLevelEncryptionProfileAlreadyExists({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::field_level_encryption_profile_already_exists::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_field_level_encryption_profile_already_exists_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateFieldLevelEncryptionProfileError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "FieldLevelEncryptionProfileSizeExceeded" => crate::error::UpdateFieldLevelEncryptionProfileError::FieldLevelEncryptionProfileSizeExceeded({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::field_level_encryption_profile_size_exceeded::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_field_level_encryption_profile_size_exceeded_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateFieldLevelEncryptionProfileError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "IllegalUpdate" => crate::error::UpdateFieldLevelEncryptionProfileError::IllegalUpdate({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::illegal_update::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_illegal_update_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateFieldLevelEncryptionProfileError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InconsistentQuantities" => crate::error::UpdateFieldLevelEncryptionProfileError::InconsistentQuantities({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::inconsistent_quantities::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_inconsistent_quantities_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateFieldLevelEncryptionProfileError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidArgument" => crate::error::UpdateFieldLevelEncryptionProfileError::InvalidArgument({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_argument::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_argument_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateFieldLevelEncryptionProfileError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidIfMatchVersion" => crate::error::UpdateFieldLevelEncryptionProfileError::InvalidIfMatchVersion({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_if_match_version::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_if_match_version_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateFieldLevelEncryptionProfileError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "NoSuchFieldLevelEncryptionProfile" => crate::error::UpdateFieldLevelEncryptionProfileError::NoSuchFieldLevelEncryptionProfile({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_field_level_encryption_profile::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_field_level_encryption_profile_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateFieldLevelEncryptionProfileError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "NoSuchPublicKey" => crate::error::UpdateFieldLevelEncryptionProfileError::NoSuchPublicKey({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_public_key::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_public_key_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateFieldLevelEncryptionProfileError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "PreconditionFailed" => crate::error::UpdateFieldLevelEncryptionProfileError::PreconditionFailed({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::precondition_failed::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_precondition_failed_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateFieldLevelEncryptionProfileError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyFieldLevelEncryptionEncryptionEntities" => crate::error::UpdateFieldLevelEncryptionProfileError::TooManyFieldLevelEncryptionEncryptionEntities({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_field_level_encryption_encryption_entities::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_field_level_encryption_encryption_entities_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateFieldLevelEncryptionProfileError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyFieldLevelEncryptionFieldPatterns" => crate::error::UpdateFieldLevelEncryptionProfileError::TooManyFieldLevelEncryptionFieldPatterns({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_field_level_encryption_field_patterns::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_field_level_encryption_field_patterns_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateFieldLevelEncryptionProfileError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::UpdateFieldLevelEncryptionProfileError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_field_level_encryption_profile_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateFieldLevelEncryptionProfileOutput,
    crate::error::UpdateFieldLevelEncryptionProfileError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::update_field_level_encryption_profile_output::Builder::default();
        let _ = response;
        output = output.set_e_tag(
            crate::http_serde::deser_header_update_field_level_encryption_profile_update_field_level_encryption_profile_output_e_tag(response.headers())
                                    .map_err(|_|crate::error::UpdateFieldLevelEncryptionProfileError::unhandled("Failed to parse ETag from header `ETag"))?
        );
        output = output.set_field_level_encryption_profile(
            crate::http_serde::deser_payload_update_field_level_encryption_profile_update_field_level_encryption_profile_output_field_level_encryption_profile(response.body().as_ref())?
        );
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_function_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateFunctionOutput, crate::error::UpdateFunctionError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::UpdateFunctionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdateFunctionError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "FunctionSizeLimitExceeded" => {
            crate::error::UpdateFunctionError::FunctionSizeLimitExceeded({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::function_size_limit_exceeded::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_function_size_limit_exceeded_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateFunctionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidArgument" => crate::error::UpdateFunctionError::InvalidArgument({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_argument::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_invalid_argument_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateFunctionError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidIfMatchVersion" => {
            crate::error::UpdateFunctionError::InvalidIfMatchVersion({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_if_match_version::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_if_match_version_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateFunctionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "NoSuchFunctionExists" => {
            crate::error::UpdateFunctionError::NoSuchFunctionExists({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_function_exists::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_function_exists_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateFunctionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "PreconditionFailed" => crate::error::UpdateFunctionError::PreconditionFailed({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::precondition_failed::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_precondition_failed_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateFunctionError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "UnsupportedOperation" => {
            crate::error::UpdateFunctionError::UnsupportedOperation({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unsupported_operation::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_unsupported_operation_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateFunctionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::UpdateFunctionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_function_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateFunctionOutput, crate::error::UpdateFunctionError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_function_output::Builder::default();
        let _ = response;
        output = output.set_e_tag(
            crate::http_serde::deser_header_update_function_update_function_output_e_tag(
                response.headers(),
            )
            .map_err(|_| {
                crate::error::UpdateFunctionError::unhandled(
                    "Failed to parse ETag from header `ETtag",
                )
            })?,
        );
        output = output.set_function_summary(
            crate::http_serde::deser_payload_update_function_update_function_output_function_summary(response.body().as_ref())?
        );
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_key_group_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateKeyGroupOutput, crate::error::UpdateKeyGroupError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::UpdateKeyGroupError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdateKeyGroupError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidArgument" => crate::error::UpdateKeyGroupError::InvalidArgument({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_argument::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_invalid_argument_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateKeyGroupError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidIfMatchVersion" => {
            crate::error::UpdateKeyGroupError::InvalidIfMatchVersion({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_if_match_version::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_if_match_version_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateKeyGroupError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "KeyGroupAlreadyExists" => {
            crate::error::UpdateKeyGroupError::KeyGroupAlreadyExists({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::key_group_already_exists::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_key_group_already_exists_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateKeyGroupError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "NoSuchResource" => crate::error::UpdateKeyGroupError::NoSuchResource({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_resource::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_no_such_resource_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateKeyGroupError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "PreconditionFailed" => crate::error::UpdateKeyGroupError::PreconditionFailed({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::precondition_failed::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_precondition_failed_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateKeyGroupError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "TooManyPublicKeysInKeyGroup" => {
            crate::error::UpdateKeyGroupError::TooManyPublicKeysInKeyGroup({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::too_many_public_keys_in_key_group::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_public_keys_in_key_group_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateKeyGroupError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::UpdateKeyGroupError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_key_group_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateKeyGroupOutput, crate::error::UpdateKeyGroupError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_key_group_output::Builder::default();
        let _ = response;
        output = output.set_e_tag(
            crate::http_serde::deser_header_update_key_group_update_key_group_output_e_tag(
                response.headers(),
            )
            .map_err(|_| {
                crate::error::UpdateKeyGroupError::unhandled(
                    "Failed to parse ETag from header `ETag",
                )
            })?,
        );
        output = output.set_key_group(
            crate::http_serde::deser_payload_update_key_group_update_key_group_output_key_group(
                response.body().as_ref(),
            )?,
        );
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_origin_access_control_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateOriginAccessControlOutput,
    crate::error::UpdateOriginAccessControlError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::UpdateOriginAccessControlError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::UpdateOriginAccessControlError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AccessDenied" => crate::error::UpdateOriginAccessControlError::AccessDenied({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::access_denied::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_access_denied_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateOriginAccessControlError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "IllegalUpdate" => crate::error::UpdateOriginAccessControlError::IllegalUpdate({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::illegal_update::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_illegal_update_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateOriginAccessControlError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidArgument" => crate::error::UpdateOriginAccessControlError::InvalidArgument({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_argument::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_invalid_argument_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateOriginAccessControlError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidIfMatchVersion" => {
            crate::error::UpdateOriginAccessControlError::InvalidIfMatchVersion({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_if_match_version::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_if_match_version_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateOriginAccessControlError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "NoSuchOriginAccessControl" => {
            crate::error::UpdateOriginAccessControlError::NoSuchOriginAccessControl({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::no_such_origin_access_control::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_origin_access_control_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateOriginAccessControlError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "OriginAccessControlAlreadyExists" => {
            crate::error::UpdateOriginAccessControlError::OriginAccessControlAlreadyExists({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::origin_access_control_already_exists::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_origin_access_control_already_exists_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateOriginAccessControlError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "PreconditionFailed" => crate::error::UpdateOriginAccessControlError::PreconditionFailed({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::precondition_failed::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_precondition_failed_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateOriginAccessControlError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::UpdateOriginAccessControlError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_origin_access_control_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateOriginAccessControlOutput,
    crate::error::UpdateOriginAccessControlError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_origin_access_control_output::Builder::default();
        let _ = response;
        output = output.set_e_tag(
            crate::http_serde::deser_header_update_origin_access_control_update_origin_access_control_output_e_tag(response.headers())
                                    .map_err(|_|crate::error::UpdateOriginAccessControlError::unhandled("Failed to parse ETag from header `ETag"))?
        );
        output = output.set_origin_access_control(
            crate::http_serde::deser_payload_update_origin_access_control_update_origin_access_control_output_origin_access_control(response.body().as_ref())?
        );
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_origin_request_policy_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateOriginRequestPolicyOutput,
    crate::error::UpdateOriginRequestPolicyError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::UpdateOriginRequestPolicyError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::UpdateOriginRequestPolicyError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AccessDenied" => crate::error::UpdateOriginRequestPolicyError::AccessDenied({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::access_denied::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_access_denied_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateOriginRequestPolicyError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "IllegalUpdate" => crate::error::UpdateOriginRequestPolicyError::IllegalUpdate({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::illegal_update::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_illegal_update_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateOriginRequestPolicyError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InconsistentQuantities" => {
            crate::error::UpdateOriginRequestPolicyError::InconsistentQuantities({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::inconsistent_quantities::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_inconsistent_quantities_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateOriginRequestPolicyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidArgument" => crate::error::UpdateOriginRequestPolicyError::InvalidArgument({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_argument::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_invalid_argument_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateOriginRequestPolicyError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidIfMatchVersion" => {
            crate::error::UpdateOriginRequestPolicyError::InvalidIfMatchVersion({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_if_match_version::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_if_match_version_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateOriginRequestPolicyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "NoSuchOriginRequestPolicy" => {
            crate::error::UpdateOriginRequestPolicyError::NoSuchOriginRequestPolicy({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::no_such_origin_request_policy::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_origin_request_policy_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateOriginRequestPolicyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "OriginRequestPolicyAlreadyExists" => {
            crate::error::UpdateOriginRequestPolicyError::OriginRequestPolicyAlreadyExists({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::origin_request_policy_already_exists::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_origin_request_policy_already_exists_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateOriginRequestPolicyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "PreconditionFailed" => crate::error::UpdateOriginRequestPolicyError::PreconditionFailed({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::precondition_failed::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_precondition_failed_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateOriginRequestPolicyError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "TooManyCookiesInOriginRequestPolicy" => {
            crate::error::UpdateOriginRequestPolicyError::TooManyCookiesInOriginRequestPolicy({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::too_many_cookies_in_origin_request_policy::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_cookies_in_origin_request_policy_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateOriginRequestPolicyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "TooManyHeadersInOriginRequestPolicy" => {
            crate::error::UpdateOriginRequestPolicyError::TooManyHeadersInOriginRequestPolicy({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::too_many_headers_in_origin_request_policy::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_headers_in_origin_request_policy_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateOriginRequestPolicyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "TooManyQueryStringsInOriginRequestPolicy" => {
            crate::error::UpdateOriginRequestPolicyError::TooManyQueryStringsInOriginRequestPolicy(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                    let mut output = crate::error::too_many_query_strings_in_origin_request_policy::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_crate_error_too_many_query_strings_in_origin_request_policy_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateOriginRequestPolicyError::unhandled)?;
                        let output = output.meta(generic);
                        output.build()
                    };
                    if tmp.message.is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            )
        }
        _ => crate::error::UpdateOriginRequestPolicyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_origin_request_policy_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateOriginRequestPolicyOutput,
    crate::error::UpdateOriginRequestPolicyError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_origin_request_policy_output::Builder::default();
        let _ = response;
        output = output.set_e_tag(
            crate::http_serde::deser_header_update_origin_request_policy_update_origin_request_policy_output_e_tag(response.headers())
                                    .map_err(|_|crate::error::UpdateOriginRequestPolicyError::unhandled("Failed to parse ETag from header `ETag"))?
        );
        output = output.set_origin_request_policy(
            crate::http_serde::deser_payload_update_origin_request_policy_update_origin_request_policy_output_origin_request_policy(response.body().as_ref())?
        );
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_public_key_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdatePublicKeyOutput, crate::error::UpdatePublicKeyError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::UpdatePublicKeyError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdatePublicKeyError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AccessDenied" => crate::error::UpdatePublicKeyError::AccessDenied({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::access_denied::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_access_denied_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdatePublicKeyError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "CannotChangeImmutablePublicKeyFields" => {
            crate::error::UpdatePublicKeyError::CannotChangeImmutablePublicKeyFields({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::cannot_change_immutable_public_key_fields::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_cannot_change_immutable_public_key_fields_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdatePublicKeyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "IllegalUpdate" => crate::error::UpdatePublicKeyError::IllegalUpdate({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::illegal_update::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_illegal_update_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdatePublicKeyError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidArgument" => crate::error::UpdatePublicKeyError::InvalidArgument({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_argument::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_invalid_argument_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdatePublicKeyError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidIfMatchVersion" => {
            crate::error::UpdatePublicKeyError::InvalidIfMatchVersion({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_if_match_version::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_if_match_version_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdatePublicKeyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "NoSuchPublicKey" => crate::error::UpdatePublicKeyError::NoSuchPublicKey({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_public_key::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_no_such_public_key_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdatePublicKeyError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "PreconditionFailed" => crate::error::UpdatePublicKeyError::PreconditionFailed({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::precondition_failed::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_precondition_failed_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdatePublicKeyError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::UpdatePublicKeyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_public_key_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdatePublicKeyOutput, crate::error::UpdatePublicKeyError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_public_key_output::Builder::default();
        let _ = response;
        output = output.set_e_tag(
            crate::http_serde::deser_header_update_public_key_update_public_key_output_e_tag(
                response.headers(),
            )
            .map_err(|_| {
                crate::error::UpdatePublicKeyError::unhandled(
                    "Failed to parse ETag from header `ETag",
                )
            })?,
        );
        output = output.set_public_key(
            crate::http_serde::deser_payload_update_public_key_update_public_key_output_public_key(
                response.body().as_ref(),
            )?,
        );
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_realtime_log_config_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateRealtimeLogConfigOutput,
    crate::error::UpdateRealtimeLogConfigError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::UpdateRealtimeLogConfigError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::UpdateRealtimeLogConfigError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AccessDenied" => crate::error::UpdateRealtimeLogConfigError::AccessDenied({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::access_denied::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_access_denied_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateRealtimeLogConfigError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidArgument" => crate::error::UpdateRealtimeLogConfigError::InvalidArgument({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_argument::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_invalid_argument_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateRealtimeLogConfigError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NoSuchRealtimeLogConfig" => {
            crate::error::UpdateRealtimeLogConfigError::NoSuchRealtimeLogConfig({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_realtime_log_config::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_realtime_log_config_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateRealtimeLogConfigError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::UpdateRealtimeLogConfigError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_realtime_log_config_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateRealtimeLogConfigOutput,
    crate::error::UpdateRealtimeLogConfigError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_realtime_log_config_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_update_realtime_log_config(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::UpdateRealtimeLogConfigError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_response_headers_policy_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateResponseHeadersPolicyOutput,
    crate::error::UpdateResponseHeadersPolicyError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::UpdateResponseHeadersPolicyError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::UpdateResponseHeadersPolicyError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AccessDenied" => crate::error::UpdateResponseHeadersPolicyError::AccessDenied({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::access_denied::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_access_denied_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateResponseHeadersPolicyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "IllegalUpdate" => crate::error::UpdateResponseHeadersPolicyError::IllegalUpdate({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::illegal_update::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_illegal_update_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateResponseHeadersPolicyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InconsistentQuantities" => crate::error::UpdateResponseHeadersPolicyError::InconsistentQuantities({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::inconsistent_quantities::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_inconsistent_quantities_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateResponseHeadersPolicyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidArgument" => crate::error::UpdateResponseHeadersPolicyError::InvalidArgument({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_argument::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_argument_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateResponseHeadersPolicyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidIfMatchVersion" => crate::error::UpdateResponseHeadersPolicyError::InvalidIfMatchVersion({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_if_match_version::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_if_match_version_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateResponseHeadersPolicyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "NoSuchResponseHeadersPolicy" => crate::error::UpdateResponseHeadersPolicyError::NoSuchResponseHeadersPolicy({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_response_headers_policy::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_response_headers_policy_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateResponseHeadersPolicyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "PreconditionFailed" => crate::error::UpdateResponseHeadersPolicyError::PreconditionFailed({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::precondition_failed::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_precondition_failed_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateResponseHeadersPolicyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "ResponseHeadersPolicyAlreadyExists" => crate::error::UpdateResponseHeadersPolicyError::ResponseHeadersPolicyAlreadyExists({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::response_headers_policy_already_exists::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_response_headers_policy_already_exists_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateResponseHeadersPolicyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooLongCSPInResponseHeadersPolicy" => crate::error::UpdateResponseHeadersPolicyError::TooLongCspInResponseHeadersPolicy({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_long_csp_in_response_headers_policy::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_long_csp_in_response_headers_policy_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateResponseHeadersPolicyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyCustomHeadersInResponseHeadersPolicy" => crate::error::UpdateResponseHeadersPolicyError::TooManyCustomHeadersInResponseHeadersPolicy({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_custom_headers_in_response_headers_policy::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_custom_headers_in_response_headers_policy_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateResponseHeadersPolicyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyRemoveHeadersInResponseHeadersPolicy" => crate::error::UpdateResponseHeadersPolicyError::TooManyRemoveHeadersInResponseHeadersPolicy({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_remove_headers_in_response_headers_policy::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_remove_headers_in_response_headers_policy_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateResponseHeadersPolicyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::UpdateResponseHeadersPolicyError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_response_headers_policy_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateResponseHeadersPolicyOutput,
    crate::error::UpdateResponseHeadersPolicyError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_response_headers_policy_output::Builder::default();
        let _ = response;
        output = output.set_e_tag(
            crate::http_serde::deser_header_update_response_headers_policy_update_response_headers_policy_output_e_tag(response.headers())
                                    .map_err(|_|crate::error::UpdateResponseHeadersPolicyError::unhandled("Failed to parse ETag from header `ETag"))?
        );
        output = output.set_response_headers_policy(
            crate::http_serde::deser_payload_update_response_headers_policy_update_response_headers_policy_output_response_headers_policy(response.body().as_ref())?
        );
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_streaming_distribution_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateStreamingDistributionOutput,
    crate::error::UpdateStreamingDistributionError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::UpdateStreamingDistributionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::UpdateStreamingDistributionError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AccessDenied" => crate::error::UpdateStreamingDistributionError::AccessDenied({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::access_denied::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_access_denied_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateStreamingDistributionError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "CNAMEAlreadyExists" => {
            crate::error::UpdateStreamingDistributionError::CnameAlreadyExists({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::cname_already_exists::Builder::default();
                    let _ = response;
                    output =
                        crate::xml_deser::deser_structure_crate_error_cname_already_exists_xml_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::UpdateStreamingDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "IllegalUpdate" => crate::error::UpdateStreamingDistributionError::IllegalUpdate({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::illegal_update::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_illegal_update_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateStreamingDistributionError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InconsistentQuantities" => {
            crate::error::UpdateStreamingDistributionError::InconsistentQuantities({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::inconsistent_quantities::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_inconsistent_quantities_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateStreamingDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidArgument" => crate::error::UpdateStreamingDistributionError::InvalidArgument({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_argument::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_invalid_argument_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateStreamingDistributionError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidIfMatchVersion" => {
            crate::error::UpdateStreamingDistributionError::InvalidIfMatchVersion({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_if_match_version::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_if_match_version_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateStreamingDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidOriginAccessControl" => {
            crate::error::UpdateStreamingDistributionError::InvalidOriginAccessControl({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_origin_access_control::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_origin_access_control_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateStreamingDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidOriginAccessIdentity" => {
            crate::error::UpdateStreamingDistributionError::InvalidOriginAccessIdentity({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_origin_access_identity::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_origin_access_identity_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateStreamingDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "MissingBody" => crate::error::UpdateStreamingDistributionError::MissingBody({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::missing_body::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_missing_body_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateStreamingDistributionError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NoSuchStreamingDistribution" => {
            crate::error::UpdateStreamingDistributionError::NoSuchStreamingDistribution({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::no_such_streaming_distribution::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_streaming_distribution_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateStreamingDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "PreconditionFailed" => {
            crate::error::UpdateStreamingDistributionError::PreconditionFailed({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::precondition_failed::Builder::default();
                    let _ = response;
                    output =
                        crate::xml_deser::deser_structure_crate_error_precondition_failed_xml_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::UpdateStreamingDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "TooManyStreamingDistributionCNAMEs" => {
            crate::error::UpdateStreamingDistributionError::TooManyStreamingDistributionCnamEs({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::too_many_streaming_distribution_cnam_es::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_streaming_distribution_cnam_es_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateStreamingDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "TooManyTrustedSigners" => {
            crate::error::UpdateStreamingDistributionError::TooManyTrustedSigners({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_trusted_signers::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_trusted_signers_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateStreamingDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "TrustedSignerDoesNotExist" => {
            crate::error::UpdateStreamingDistributionError::TrustedSignerDoesNotExist({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::trusted_signer_does_not_exist::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_trusted_signer_does_not_exist_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateStreamingDistributionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::UpdateStreamingDistributionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_streaming_distribution_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateStreamingDistributionOutput,
    crate::error::UpdateStreamingDistributionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_streaming_distribution_output::Builder::default();
        let _ = response;
        output = output.set_e_tag(
            crate::http_serde::deser_header_update_streaming_distribution_update_streaming_distribution_output_e_tag(response.headers())
                                    .map_err(|_|crate::error::UpdateStreamingDistributionError::unhandled("Failed to parse ETag from header `ETag"))?
        );
        output = output.set_streaming_distribution(
            crate::http_serde::deser_payload_update_streaming_distribution_update_streaming_distribution_output_streaming_distribution(response.body().as_ref())?
        );
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}
