// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[derive(Debug)]
pub(crate) struct Handle<
    C = smithy_client::erase::DynConnector,
    M = aws_hyper::AwsMiddleware,
    R = smithy_client::retry::Standard,
> {
    client: smithy_client::Client<C, M, R>,
    conf: crate::Config,
}

/// An ergonomic service client for `Cloudfront2020_05_31`.
///
/// This client allows ergonomic access to a `Cloudfront2020_05_31`-shaped service.
/// Each method corresponds to an endpoint defined in the service's Smithy model,
/// and the request and response shapes are auto-generated from that same model.
///
/// # Using a Client
///
/// Once you have a client set up, you can access the service's endpoints
/// by calling the appropriate method on [`Client`]. Each such method
/// returns a request builder for that endpoint, with methods for setting
/// the various fields of the request. Once your request is complete, use
/// the `send` method to send the request. `send` returns a future, which
/// you then have to `.await` to get the service's response.
///
/// [builder pattern]: https://rust-lang.github.io/api-guidelines/type-safety.html#c-builder
/// [SigV4-signed requests]: https://docs.aws.amazon.com/general/latest/gr/signature-version-4.html
#[derive(std::fmt::Debug)]
pub struct Client<
    C = smithy_client::erase::DynConnector,
    M = aws_hyper::AwsMiddleware,
    R = smithy_client::retry::Standard,
> {
    handle: std::sync::Arc<Handle<C, M, R>>,
}

impl<C, M, R> std::clone::Clone for Client<C, M, R> {
    fn clone(&self) -> Self {
        Self {
            handle: self.handle.clone(),
        }
    }
}

#[doc(inline)]
pub use smithy_client::Builder;

impl<C, M, R> From<smithy_client::Client<C, M, R>> for Client<C, M, R> {
    fn from(client: smithy_client::Client<C, M, R>) -> Self {
        Self::with_config(client, crate::Config::builder().build())
    }
}

impl<C, M, R> Client<C, M, R> {
    pub fn with_config(client: smithy_client::Client<C, M, R>, conf: crate::Config) -> Self {
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }

    pub fn conf(&self) -> &crate::Config {
        &self.handle.conf
    }
}
impl<C, M, R> Client<C, M, R>
where
    C: smithy_client::bounds::SmithyConnector,
    M: smithy_client::bounds::SmithyMiddleware<C>,
    R: smithy_client::retry::NewRequestPolicy,
{
    pub fn associate_alias(&self) -> fluent_builders::AssociateAlias<C, M, R> {
        fluent_builders::AssociateAlias::new(self.handle.clone())
    }
    pub fn create_cache_policy(&self) -> fluent_builders::CreateCachePolicy<C, M, R> {
        fluent_builders::CreateCachePolicy::new(self.handle.clone())
    }
    pub fn create_cloud_front_origin_access_identity(
        &self,
    ) -> fluent_builders::CreateCloudFrontOriginAccessIdentity<C, M, R> {
        fluent_builders::CreateCloudFrontOriginAccessIdentity::new(self.handle.clone())
    }
    pub fn create_distribution(&self) -> fluent_builders::CreateDistribution<C, M, R> {
        fluent_builders::CreateDistribution::new(self.handle.clone())
    }
    pub fn create_distribution_with_tags(
        &self,
    ) -> fluent_builders::CreateDistributionWithTags<C, M, R> {
        fluent_builders::CreateDistributionWithTags::new(self.handle.clone())
    }
    pub fn create_field_level_encryption_config(
        &self,
    ) -> fluent_builders::CreateFieldLevelEncryptionConfig<C, M, R> {
        fluent_builders::CreateFieldLevelEncryptionConfig::new(self.handle.clone())
    }
    pub fn create_field_level_encryption_profile(
        &self,
    ) -> fluent_builders::CreateFieldLevelEncryptionProfile<C, M, R> {
        fluent_builders::CreateFieldLevelEncryptionProfile::new(self.handle.clone())
    }
    pub fn create_function(&self) -> fluent_builders::CreateFunction<C, M, R> {
        fluent_builders::CreateFunction::new(self.handle.clone())
    }
    pub fn create_invalidation(&self) -> fluent_builders::CreateInvalidation<C, M, R> {
        fluent_builders::CreateInvalidation::new(self.handle.clone())
    }
    pub fn create_key_group(&self) -> fluent_builders::CreateKeyGroup<C, M, R> {
        fluent_builders::CreateKeyGroup::new(self.handle.clone())
    }
    pub fn create_monitoring_subscription(
        &self,
    ) -> fluent_builders::CreateMonitoringSubscription<C, M, R> {
        fluent_builders::CreateMonitoringSubscription::new(self.handle.clone())
    }
    pub fn create_origin_request_policy(
        &self,
    ) -> fluent_builders::CreateOriginRequestPolicy<C, M, R> {
        fluent_builders::CreateOriginRequestPolicy::new(self.handle.clone())
    }
    pub fn create_public_key(&self) -> fluent_builders::CreatePublicKey<C, M, R> {
        fluent_builders::CreatePublicKey::new(self.handle.clone())
    }
    pub fn create_realtime_log_config(&self) -> fluent_builders::CreateRealtimeLogConfig<C, M, R> {
        fluent_builders::CreateRealtimeLogConfig::new(self.handle.clone())
    }
    pub fn create_streaming_distribution(
        &self,
    ) -> fluent_builders::CreateStreamingDistribution<C, M, R> {
        fluent_builders::CreateStreamingDistribution::new(self.handle.clone())
    }
    pub fn create_streaming_distribution_with_tags(
        &self,
    ) -> fluent_builders::CreateStreamingDistributionWithTags<C, M, R> {
        fluent_builders::CreateStreamingDistributionWithTags::new(self.handle.clone())
    }
    pub fn delete_cache_policy(&self) -> fluent_builders::DeleteCachePolicy<C, M, R> {
        fluent_builders::DeleteCachePolicy::new(self.handle.clone())
    }
    pub fn delete_cloud_front_origin_access_identity(
        &self,
    ) -> fluent_builders::DeleteCloudFrontOriginAccessIdentity<C, M, R> {
        fluent_builders::DeleteCloudFrontOriginAccessIdentity::new(self.handle.clone())
    }
    pub fn delete_distribution(&self) -> fluent_builders::DeleteDistribution<C, M, R> {
        fluent_builders::DeleteDistribution::new(self.handle.clone())
    }
    pub fn delete_field_level_encryption_config(
        &self,
    ) -> fluent_builders::DeleteFieldLevelEncryptionConfig<C, M, R> {
        fluent_builders::DeleteFieldLevelEncryptionConfig::new(self.handle.clone())
    }
    pub fn delete_field_level_encryption_profile(
        &self,
    ) -> fluent_builders::DeleteFieldLevelEncryptionProfile<C, M, R> {
        fluent_builders::DeleteFieldLevelEncryptionProfile::new(self.handle.clone())
    }
    pub fn delete_function(&self) -> fluent_builders::DeleteFunction<C, M, R> {
        fluent_builders::DeleteFunction::new(self.handle.clone())
    }
    pub fn delete_key_group(&self) -> fluent_builders::DeleteKeyGroup<C, M, R> {
        fluent_builders::DeleteKeyGroup::new(self.handle.clone())
    }
    pub fn delete_monitoring_subscription(
        &self,
    ) -> fluent_builders::DeleteMonitoringSubscription<C, M, R> {
        fluent_builders::DeleteMonitoringSubscription::new(self.handle.clone())
    }
    pub fn delete_origin_request_policy(
        &self,
    ) -> fluent_builders::DeleteOriginRequestPolicy<C, M, R> {
        fluent_builders::DeleteOriginRequestPolicy::new(self.handle.clone())
    }
    pub fn delete_public_key(&self) -> fluent_builders::DeletePublicKey<C, M, R> {
        fluent_builders::DeletePublicKey::new(self.handle.clone())
    }
    pub fn delete_realtime_log_config(&self) -> fluent_builders::DeleteRealtimeLogConfig<C, M, R> {
        fluent_builders::DeleteRealtimeLogConfig::new(self.handle.clone())
    }
    pub fn delete_streaming_distribution(
        &self,
    ) -> fluent_builders::DeleteStreamingDistribution<C, M, R> {
        fluent_builders::DeleteStreamingDistribution::new(self.handle.clone())
    }
    pub fn describe_function(&self) -> fluent_builders::DescribeFunction<C, M, R> {
        fluent_builders::DescribeFunction::new(self.handle.clone())
    }
    pub fn get_cache_policy(&self) -> fluent_builders::GetCachePolicy<C, M, R> {
        fluent_builders::GetCachePolicy::new(self.handle.clone())
    }
    pub fn get_cache_policy_config(&self) -> fluent_builders::GetCachePolicyConfig<C, M, R> {
        fluent_builders::GetCachePolicyConfig::new(self.handle.clone())
    }
    pub fn get_cloud_front_origin_access_identity(
        &self,
    ) -> fluent_builders::GetCloudFrontOriginAccessIdentity<C, M, R> {
        fluent_builders::GetCloudFrontOriginAccessIdentity::new(self.handle.clone())
    }
    pub fn get_cloud_front_origin_access_identity_config(
        &self,
    ) -> fluent_builders::GetCloudFrontOriginAccessIdentityConfig<C, M, R> {
        fluent_builders::GetCloudFrontOriginAccessIdentityConfig::new(self.handle.clone())
    }
    pub fn get_distribution(&self) -> fluent_builders::GetDistribution<C, M, R> {
        fluent_builders::GetDistribution::new(self.handle.clone())
    }
    pub fn get_distribution_config(&self) -> fluent_builders::GetDistributionConfig<C, M, R> {
        fluent_builders::GetDistributionConfig::new(self.handle.clone())
    }
    pub fn get_field_level_encryption(&self) -> fluent_builders::GetFieldLevelEncryption<C, M, R> {
        fluent_builders::GetFieldLevelEncryption::new(self.handle.clone())
    }
    pub fn get_field_level_encryption_config(
        &self,
    ) -> fluent_builders::GetFieldLevelEncryptionConfig<C, M, R> {
        fluent_builders::GetFieldLevelEncryptionConfig::new(self.handle.clone())
    }
    pub fn get_field_level_encryption_profile(
        &self,
    ) -> fluent_builders::GetFieldLevelEncryptionProfile<C, M, R> {
        fluent_builders::GetFieldLevelEncryptionProfile::new(self.handle.clone())
    }
    pub fn get_field_level_encryption_profile_config(
        &self,
    ) -> fluent_builders::GetFieldLevelEncryptionProfileConfig<C, M, R> {
        fluent_builders::GetFieldLevelEncryptionProfileConfig::new(self.handle.clone())
    }
    pub fn get_function(&self) -> fluent_builders::GetFunction<C, M, R> {
        fluent_builders::GetFunction::new(self.handle.clone())
    }
    pub fn get_invalidation(&self) -> fluent_builders::GetInvalidation<C, M, R> {
        fluent_builders::GetInvalidation::new(self.handle.clone())
    }
    pub fn get_key_group(&self) -> fluent_builders::GetKeyGroup<C, M, R> {
        fluent_builders::GetKeyGroup::new(self.handle.clone())
    }
    pub fn get_key_group_config(&self) -> fluent_builders::GetKeyGroupConfig<C, M, R> {
        fluent_builders::GetKeyGroupConfig::new(self.handle.clone())
    }
    pub fn get_monitoring_subscription(
        &self,
    ) -> fluent_builders::GetMonitoringSubscription<C, M, R> {
        fluent_builders::GetMonitoringSubscription::new(self.handle.clone())
    }
    pub fn get_origin_request_policy(&self) -> fluent_builders::GetOriginRequestPolicy<C, M, R> {
        fluent_builders::GetOriginRequestPolicy::new(self.handle.clone())
    }
    pub fn get_origin_request_policy_config(
        &self,
    ) -> fluent_builders::GetOriginRequestPolicyConfig<C, M, R> {
        fluent_builders::GetOriginRequestPolicyConfig::new(self.handle.clone())
    }
    pub fn get_public_key(&self) -> fluent_builders::GetPublicKey<C, M, R> {
        fluent_builders::GetPublicKey::new(self.handle.clone())
    }
    pub fn get_public_key_config(&self) -> fluent_builders::GetPublicKeyConfig<C, M, R> {
        fluent_builders::GetPublicKeyConfig::new(self.handle.clone())
    }
    pub fn get_realtime_log_config(&self) -> fluent_builders::GetRealtimeLogConfig<C, M, R> {
        fluent_builders::GetRealtimeLogConfig::new(self.handle.clone())
    }
    pub fn get_streaming_distribution(&self) -> fluent_builders::GetStreamingDistribution<C, M, R> {
        fluent_builders::GetStreamingDistribution::new(self.handle.clone())
    }
    pub fn get_streaming_distribution_config(
        &self,
    ) -> fluent_builders::GetStreamingDistributionConfig<C, M, R> {
        fluent_builders::GetStreamingDistributionConfig::new(self.handle.clone())
    }
    pub fn list_cache_policies(&self) -> fluent_builders::ListCachePolicies<C, M, R> {
        fluent_builders::ListCachePolicies::new(self.handle.clone())
    }
    pub fn list_cloud_front_origin_access_identities(
        &self,
    ) -> fluent_builders::ListCloudFrontOriginAccessIdentities<C, M, R> {
        fluent_builders::ListCloudFrontOriginAccessIdentities::new(self.handle.clone())
    }
    pub fn list_conflicting_aliases(&self) -> fluent_builders::ListConflictingAliases<C, M, R> {
        fluent_builders::ListConflictingAliases::new(self.handle.clone())
    }
    pub fn list_distributions(&self) -> fluent_builders::ListDistributions<C, M, R> {
        fluent_builders::ListDistributions::new(self.handle.clone())
    }
    pub fn list_distributions_by_cache_policy_id(
        &self,
    ) -> fluent_builders::ListDistributionsByCachePolicyId<C, M, R> {
        fluent_builders::ListDistributionsByCachePolicyId::new(self.handle.clone())
    }
    pub fn list_distributions_by_key_group(
        &self,
    ) -> fluent_builders::ListDistributionsByKeyGroup<C, M, R> {
        fluent_builders::ListDistributionsByKeyGroup::new(self.handle.clone())
    }
    pub fn list_distributions_by_origin_request_policy_id(
        &self,
    ) -> fluent_builders::ListDistributionsByOriginRequestPolicyId<C, M, R> {
        fluent_builders::ListDistributionsByOriginRequestPolicyId::new(self.handle.clone())
    }
    pub fn list_distributions_by_realtime_log_config(
        &self,
    ) -> fluent_builders::ListDistributionsByRealtimeLogConfig<C, M, R> {
        fluent_builders::ListDistributionsByRealtimeLogConfig::new(self.handle.clone())
    }
    pub fn list_distributions_by_web_acl_id(
        &self,
    ) -> fluent_builders::ListDistributionsByWebACLId<C, M, R> {
        fluent_builders::ListDistributionsByWebACLId::new(self.handle.clone())
    }
    pub fn list_field_level_encryption_configs(
        &self,
    ) -> fluent_builders::ListFieldLevelEncryptionConfigs<C, M, R> {
        fluent_builders::ListFieldLevelEncryptionConfigs::new(self.handle.clone())
    }
    pub fn list_field_level_encryption_profiles(
        &self,
    ) -> fluent_builders::ListFieldLevelEncryptionProfiles<C, M, R> {
        fluent_builders::ListFieldLevelEncryptionProfiles::new(self.handle.clone())
    }
    pub fn list_functions(&self) -> fluent_builders::ListFunctions<C, M, R> {
        fluent_builders::ListFunctions::new(self.handle.clone())
    }
    pub fn list_invalidations(&self) -> fluent_builders::ListInvalidations<C, M, R> {
        fluent_builders::ListInvalidations::new(self.handle.clone())
    }
    pub fn list_key_groups(&self) -> fluent_builders::ListKeyGroups<C, M, R> {
        fluent_builders::ListKeyGroups::new(self.handle.clone())
    }
    pub fn list_origin_request_policies(
        &self,
    ) -> fluent_builders::ListOriginRequestPolicies<C, M, R> {
        fluent_builders::ListOriginRequestPolicies::new(self.handle.clone())
    }
    pub fn list_public_keys(&self) -> fluent_builders::ListPublicKeys<C, M, R> {
        fluent_builders::ListPublicKeys::new(self.handle.clone())
    }
    pub fn list_realtime_log_configs(&self) -> fluent_builders::ListRealtimeLogConfigs<C, M, R> {
        fluent_builders::ListRealtimeLogConfigs::new(self.handle.clone())
    }
    pub fn list_streaming_distributions(
        &self,
    ) -> fluent_builders::ListStreamingDistributions<C, M, R> {
        fluent_builders::ListStreamingDistributions::new(self.handle.clone())
    }
    pub fn list_tags_for_resource(&self) -> fluent_builders::ListTagsForResource<C, M, R> {
        fluent_builders::ListTagsForResource::new(self.handle.clone())
    }
    pub fn publish_function(&self) -> fluent_builders::PublishFunction<C, M, R> {
        fluent_builders::PublishFunction::new(self.handle.clone())
    }
    pub fn tag_resource(&self) -> fluent_builders::TagResource<C, M, R> {
        fluent_builders::TagResource::new(self.handle.clone())
    }
    pub fn test_function(&self) -> fluent_builders::TestFunction<C, M, R> {
        fluent_builders::TestFunction::new(self.handle.clone())
    }
    pub fn untag_resource(&self) -> fluent_builders::UntagResource<C, M, R> {
        fluent_builders::UntagResource::new(self.handle.clone())
    }
    pub fn update_cache_policy(&self) -> fluent_builders::UpdateCachePolicy<C, M, R> {
        fluent_builders::UpdateCachePolicy::new(self.handle.clone())
    }
    pub fn update_cloud_front_origin_access_identity(
        &self,
    ) -> fluent_builders::UpdateCloudFrontOriginAccessIdentity<C, M, R> {
        fluent_builders::UpdateCloudFrontOriginAccessIdentity::new(self.handle.clone())
    }
    pub fn update_distribution(&self) -> fluent_builders::UpdateDistribution<C, M, R> {
        fluent_builders::UpdateDistribution::new(self.handle.clone())
    }
    pub fn update_field_level_encryption_config(
        &self,
    ) -> fluent_builders::UpdateFieldLevelEncryptionConfig<C, M, R> {
        fluent_builders::UpdateFieldLevelEncryptionConfig::new(self.handle.clone())
    }
    pub fn update_field_level_encryption_profile(
        &self,
    ) -> fluent_builders::UpdateFieldLevelEncryptionProfile<C, M, R> {
        fluent_builders::UpdateFieldLevelEncryptionProfile::new(self.handle.clone())
    }
    pub fn update_function(&self) -> fluent_builders::UpdateFunction<C, M, R> {
        fluent_builders::UpdateFunction::new(self.handle.clone())
    }
    pub fn update_key_group(&self) -> fluent_builders::UpdateKeyGroup<C, M, R> {
        fluent_builders::UpdateKeyGroup::new(self.handle.clone())
    }
    pub fn update_origin_request_policy(
        &self,
    ) -> fluent_builders::UpdateOriginRequestPolicy<C, M, R> {
        fluent_builders::UpdateOriginRequestPolicy::new(self.handle.clone())
    }
    pub fn update_public_key(&self) -> fluent_builders::UpdatePublicKey<C, M, R> {
        fluent_builders::UpdatePublicKey::new(self.handle.clone())
    }
    pub fn update_realtime_log_config(&self) -> fluent_builders::UpdateRealtimeLogConfig<C, M, R> {
        fluent_builders::UpdateRealtimeLogConfig::new(self.handle.clone())
    }
    pub fn update_streaming_distribution(
        &self,
    ) -> fluent_builders::UpdateStreamingDistribution<C, M, R> {
        fluent_builders::UpdateStreamingDistribution::new(self.handle.clone())
    }
}
pub mod fluent_builders {
    #[derive(std::fmt::Debug)]
    pub struct AssociateAlias<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::associate_alias_input::Builder,
    }
    impl<C, M, R> AssociateAlias<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::AssociateAliasOutput,
            smithy_http::result::SdkError<crate::error::AssociateAliasError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::AssociateAliasInputOperationOutputAlias,
                crate::output::AssociateAliasOutput,
                crate::error::AssociateAliasError,
                crate::input::AssociateAliasInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the distribution that you’re associating the alias with.</p>
        pub fn target_distribution_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.target_distribution_id(inp);
            self
        }
        pub fn set_target_distribution_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_target_distribution_id(input);
            self
        }
        /// <p>The alias (also known as a CNAME) to add to the target distribution.</p>
        pub fn alias(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.alias(inp);
            self
        }
        pub fn set_alias(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_alias(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateCachePolicy<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::create_cache_policy_input::Builder,
    }
    impl<C, M, R> CreateCachePolicy<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateCachePolicyOutput,
            smithy_http::result::SdkError<crate::error::CreateCachePolicyError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::CreateCachePolicyInputOperationOutputAlias,
                crate::output::CreateCachePolicyOutput,
                crate::error::CreateCachePolicyError,
                crate::input::CreateCachePolicyInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A cache policy configuration.</p>
        pub fn cache_policy_config(mut self, inp: crate::model::CachePolicyConfig) -> Self {
            self.inner = self.inner.cache_policy_config(inp);
            self
        }
        pub fn set_cache_policy_config(
            mut self,
            input: std::option::Option<crate::model::CachePolicyConfig>,
        ) -> Self {
            self.inner = self.inner.set_cache_policy_config(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateCloudFrontOriginAccessIdentity<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::create_cloud_front_origin_access_identity_input::Builder,
    }
    impl<C, M, R> CreateCloudFrontOriginAccessIdentity<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateCloudFrontOriginAccessIdentityOutput,
            smithy_http::result::SdkError<crate::error::CreateCloudFrontOriginAccessIdentityError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::CreateCloudFrontOriginAccessIdentityInputOperationOutputAlias,
                crate::output::CreateCloudFrontOriginAccessIdentityOutput,
                crate::error::CreateCloudFrontOriginAccessIdentityError,
                crate::input::CreateCloudFrontOriginAccessIdentityInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The current configuration information for the identity.</p>
        pub fn cloud_front_origin_access_identity_config(
            mut self,
            inp: crate::model::CloudFrontOriginAccessIdentityConfig,
        ) -> Self {
            self.inner = self.inner.cloud_front_origin_access_identity_config(inp);
            self
        }
        pub fn set_cloud_front_origin_access_identity_config(
            mut self,
            input: std::option::Option<crate::model::CloudFrontOriginAccessIdentityConfig>,
        ) -> Self {
            self.inner = self
                .inner
                .set_cloud_front_origin_access_identity_config(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateDistribution<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::create_distribution_input::Builder,
    }
    impl<C, M, R> CreateDistribution<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateDistributionOutput,
            smithy_http::result::SdkError<crate::error::CreateDistributionError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::CreateDistributionInputOperationOutputAlias,
                crate::output::CreateDistributionOutput,
                crate::error::CreateDistributionError,
                crate::input::CreateDistributionInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The distribution's configuration information.</p>
        pub fn distribution_config(mut self, inp: crate::model::DistributionConfig) -> Self {
            self.inner = self.inner.distribution_config(inp);
            self
        }
        pub fn set_distribution_config(
            mut self,
            input: std::option::Option<crate::model::DistributionConfig>,
        ) -> Self {
            self.inner = self.inner.set_distribution_config(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateDistributionWithTags<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::create_distribution_with_tags_input::Builder,
    }
    impl<C, M, R> CreateDistributionWithTags<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateDistributionWithTagsOutput,
            smithy_http::result::SdkError<crate::error::CreateDistributionWithTagsError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::CreateDistributionWithTagsInputOperationOutputAlias,
                crate::output::CreateDistributionWithTagsOutput,
                crate::error::CreateDistributionWithTagsError,
                crate::input::CreateDistributionWithTagsInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The distribution's configuration information. </p>
        pub fn distribution_config_with_tags(
            mut self,
            inp: crate::model::DistributionConfigWithTags,
        ) -> Self {
            self.inner = self.inner.distribution_config_with_tags(inp);
            self
        }
        pub fn set_distribution_config_with_tags(
            mut self,
            input: std::option::Option<crate::model::DistributionConfigWithTags>,
        ) -> Self {
            self.inner = self.inner.set_distribution_config_with_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateFieldLevelEncryptionConfig<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::create_field_level_encryption_config_input::Builder,
    }
    impl<C, M, R> CreateFieldLevelEncryptionConfig<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateFieldLevelEncryptionConfigOutput,
            smithy_http::result::SdkError<crate::error::CreateFieldLevelEncryptionConfigError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::CreateFieldLevelEncryptionConfigInputOperationOutputAlias,
                crate::output::CreateFieldLevelEncryptionConfigOutput,
                crate::error::CreateFieldLevelEncryptionConfigError,
                crate::input::CreateFieldLevelEncryptionConfigInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The request to create a new field-level encryption configuration.</p>
        pub fn field_level_encryption_config(
            mut self,
            inp: crate::model::FieldLevelEncryptionConfig,
        ) -> Self {
            self.inner = self.inner.field_level_encryption_config(inp);
            self
        }
        pub fn set_field_level_encryption_config(
            mut self,
            input: std::option::Option<crate::model::FieldLevelEncryptionConfig>,
        ) -> Self {
            self.inner = self.inner.set_field_level_encryption_config(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateFieldLevelEncryptionProfile<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::create_field_level_encryption_profile_input::Builder,
    }
    impl<C, M, R> CreateFieldLevelEncryptionProfile<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateFieldLevelEncryptionProfileOutput,
            smithy_http::result::SdkError<crate::error::CreateFieldLevelEncryptionProfileError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::CreateFieldLevelEncryptionProfileInputOperationOutputAlias,
                crate::output::CreateFieldLevelEncryptionProfileOutput,
                crate::error::CreateFieldLevelEncryptionProfileError,
                crate::input::CreateFieldLevelEncryptionProfileInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The request to create a field-level encryption profile.</p>
        pub fn field_level_encryption_profile_config(
            mut self,
            inp: crate::model::FieldLevelEncryptionProfileConfig,
        ) -> Self {
            self.inner = self.inner.field_level_encryption_profile_config(inp);
            self
        }
        pub fn set_field_level_encryption_profile_config(
            mut self,
            input: std::option::Option<crate::model::FieldLevelEncryptionProfileConfig>,
        ) -> Self {
            self.inner = self.inner.set_field_level_encryption_profile_config(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateFunction<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::create_function_input::Builder,
    }
    impl<C, M, R> CreateFunction<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateFunctionOutput,
            smithy_http::result::SdkError<crate::error::CreateFunctionError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::CreateFunctionInputOperationOutputAlias,
                crate::output::CreateFunctionOutput,
                crate::error::CreateFunctionError,
                crate::input::CreateFunctionInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A name to identify the function.</p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>Configuration information about the function, including an optional comment and the
        /// function’s runtime.</p>
        pub fn function_config(mut self, inp: crate::model::FunctionConfig) -> Self {
            self.inner = self.inner.function_config(inp);
            self
        }
        pub fn set_function_config(
            mut self,
            input: std::option::Option<crate::model::FunctionConfig>,
        ) -> Self {
            self.inner = self.inner.set_function_config(input);
            self
        }
        /// <p>The function code. For more information about writing a CloudFront function, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/writing-function-code.html">Writing function
        /// code for CloudFront Functions</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
        pub fn function_code(mut self, inp: smithy_types::Blob) -> Self {
            self.inner = self.inner.function_code(inp);
            self
        }
        pub fn set_function_code(mut self, input: std::option::Option<smithy_types::Blob>) -> Self {
            self.inner = self.inner.set_function_code(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateInvalidation<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::create_invalidation_input::Builder,
    }
    impl<C, M, R> CreateInvalidation<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateInvalidationOutput,
            smithy_http::result::SdkError<crate::error::CreateInvalidationError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::CreateInvalidationInputOperationOutputAlias,
                crate::output::CreateInvalidationOutput,
                crate::error::CreateInvalidationError,
                crate::input::CreateInvalidationInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The distribution's id.</p>
        pub fn distribution_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.distribution_id(inp);
            self
        }
        pub fn set_distribution_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_distribution_id(input);
            self
        }
        /// <p>The batch information for the invalidation.</p>
        pub fn invalidation_batch(mut self, inp: crate::model::InvalidationBatch) -> Self {
            self.inner = self.inner.invalidation_batch(inp);
            self
        }
        pub fn set_invalidation_batch(
            mut self,
            input: std::option::Option<crate::model::InvalidationBatch>,
        ) -> Self {
            self.inner = self.inner.set_invalidation_batch(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateKeyGroup<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::create_key_group_input::Builder,
    }
    impl<C, M, R> CreateKeyGroup<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateKeyGroupOutput,
            smithy_http::result::SdkError<crate::error::CreateKeyGroupError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::CreateKeyGroupInputOperationOutputAlias,
                crate::output::CreateKeyGroupOutput,
                crate::error::CreateKeyGroupError,
                crate::input::CreateKeyGroupInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A key group configuration.</p>
        pub fn key_group_config(mut self, inp: crate::model::KeyGroupConfig) -> Self {
            self.inner = self.inner.key_group_config(inp);
            self
        }
        pub fn set_key_group_config(
            mut self,
            input: std::option::Option<crate::model::KeyGroupConfig>,
        ) -> Self {
            self.inner = self.inner.set_key_group_config(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateMonitoringSubscription<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::create_monitoring_subscription_input::Builder,
    }
    impl<C, M, R> CreateMonitoringSubscription<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateMonitoringSubscriptionOutput,
            smithy_http::result::SdkError<crate::error::CreateMonitoringSubscriptionError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::CreateMonitoringSubscriptionInputOperationOutputAlias,
                crate::output::CreateMonitoringSubscriptionOutput,
                crate::error::CreateMonitoringSubscriptionError,
                crate::input::CreateMonitoringSubscriptionInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the distribution that you are enabling metrics for.</p>
        pub fn distribution_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.distribution_id(inp);
            self
        }
        pub fn set_distribution_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_distribution_id(input);
            self
        }
        /// <p>A monitoring subscription. This structure contains information about whether additional
        /// CloudWatch metrics are enabled for a given CloudFront distribution.</p>
        pub fn monitoring_subscription(
            mut self,
            inp: crate::model::MonitoringSubscription,
        ) -> Self {
            self.inner = self.inner.monitoring_subscription(inp);
            self
        }
        pub fn set_monitoring_subscription(
            mut self,
            input: std::option::Option<crate::model::MonitoringSubscription>,
        ) -> Self {
            self.inner = self.inner.set_monitoring_subscription(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateOriginRequestPolicy<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::create_origin_request_policy_input::Builder,
    }
    impl<C, M, R> CreateOriginRequestPolicy<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateOriginRequestPolicyOutput,
            smithy_http::result::SdkError<crate::error::CreateOriginRequestPolicyError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::CreateOriginRequestPolicyInputOperationOutputAlias,
                crate::output::CreateOriginRequestPolicyOutput,
                crate::error::CreateOriginRequestPolicyError,
                crate::input::CreateOriginRequestPolicyInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>An origin request policy configuration.</p>
        pub fn origin_request_policy_config(
            mut self,
            inp: crate::model::OriginRequestPolicyConfig,
        ) -> Self {
            self.inner = self.inner.origin_request_policy_config(inp);
            self
        }
        pub fn set_origin_request_policy_config(
            mut self,
            input: std::option::Option<crate::model::OriginRequestPolicyConfig>,
        ) -> Self {
            self.inner = self.inner.set_origin_request_policy_config(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreatePublicKey<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::create_public_key_input::Builder,
    }
    impl<C, M, R> CreatePublicKey<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreatePublicKeyOutput,
            smithy_http::result::SdkError<crate::error::CreatePublicKeyError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::CreatePublicKeyInputOperationOutputAlias,
                crate::output::CreatePublicKeyOutput,
                crate::error::CreatePublicKeyError,
                crate::input::CreatePublicKeyInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A CloudFront public key configuration.</p>
        pub fn public_key_config(mut self, inp: crate::model::PublicKeyConfig) -> Self {
            self.inner = self.inner.public_key_config(inp);
            self
        }
        pub fn set_public_key_config(
            mut self,
            input: std::option::Option<crate::model::PublicKeyConfig>,
        ) -> Self {
            self.inner = self.inner.set_public_key_config(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateRealtimeLogConfig<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::create_realtime_log_config_input::Builder,
    }
    impl<C, M, R> CreateRealtimeLogConfig<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateRealtimeLogConfigOutput,
            smithy_http::result::SdkError<crate::error::CreateRealtimeLogConfigError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::CreateRealtimeLogConfigInputOperationOutputAlias,
                crate::output::CreateRealtimeLogConfigOutput,
                crate::error::CreateRealtimeLogConfigError,
                crate::input::CreateRealtimeLogConfigInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// Appends an item to `EndPoints`.
        ///
        /// To override the contents of this collection use [`set_end_points`](Self::set_end_points).
        /// <p>Contains information about the Amazon Kinesis data stream where you are sending real-time
        /// log data.</p>
        pub fn end_points(mut self, inp: impl Into<crate::model::EndPoint>) -> Self {
            self.inner = self.inner.end_points(inp);
            self
        }
        pub fn set_end_points(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::EndPoint>>,
        ) -> Self {
            self.inner = self.inner.set_end_points(input);
            self
        }
        /// Appends an item to `Fields`.
        ///
        /// To override the contents of this collection use [`set_fields`](Self::set_fields).
        /// <p>A list of fields to include in each real-time log record.</p>
        /// <p>For more information about fields, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/real-time-logs.html#understand-real-time-log-config-fields">Real-time log configuration fields</a> in the
        /// <i>Amazon CloudFront Developer Guide</i>.</p>
        pub fn fields(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.fields(inp);
            self
        }
        pub fn set_fields(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_fields(input);
            self
        }
        /// <p>A unique name to identify this real-time log configuration.</p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>The sampling rate for this real-time log configuration. The sampling rate determines the
        /// percentage of viewer requests that are represented in the real-time log data. You must
        /// provide an integer between 1 and 100, inclusive.</p>
        pub fn sampling_rate(mut self, inp: i64) -> Self {
            self.inner = self.inner.sampling_rate(inp);
            self
        }
        pub fn set_sampling_rate(mut self, input: std::option::Option<i64>) -> Self {
            self.inner = self.inner.set_sampling_rate(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateStreamingDistribution<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::create_streaming_distribution_input::Builder,
    }
    impl<C, M, R> CreateStreamingDistribution<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateStreamingDistributionOutput,
            smithy_http::result::SdkError<crate::error::CreateStreamingDistributionError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::CreateStreamingDistributionInputOperationOutputAlias,
                crate::output::CreateStreamingDistributionOutput,
                crate::error::CreateStreamingDistributionError,
                crate::input::CreateStreamingDistributionInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The streaming distribution's configuration information.</p>
        pub fn streaming_distribution_config(
            mut self,
            inp: crate::model::StreamingDistributionConfig,
        ) -> Self {
            self.inner = self.inner.streaming_distribution_config(inp);
            self
        }
        pub fn set_streaming_distribution_config(
            mut self,
            input: std::option::Option<crate::model::StreamingDistributionConfig>,
        ) -> Self {
            self.inner = self.inner.set_streaming_distribution_config(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateStreamingDistributionWithTags<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::create_streaming_distribution_with_tags_input::Builder,
    }
    impl<C, M, R> CreateStreamingDistributionWithTags<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateStreamingDistributionWithTagsOutput,
            smithy_http::result::SdkError<crate::error::CreateStreamingDistributionWithTagsError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::CreateStreamingDistributionWithTagsInputOperationOutputAlias,
                crate::output::CreateStreamingDistributionWithTagsOutput,
                crate::error::CreateStreamingDistributionWithTagsError,
                crate::input::CreateStreamingDistributionWithTagsInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p> The streaming distribution's configuration information. </p>
        pub fn streaming_distribution_config_with_tags(
            mut self,
            inp: crate::model::StreamingDistributionConfigWithTags,
        ) -> Self {
            self.inner = self.inner.streaming_distribution_config_with_tags(inp);
            self
        }
        pub fn set_streaming_distribution_config_with_tags(
            mut self,
            input: std::option::Option<crate::model::StreamingDistributionConfigWithTags>,
        ) -> Self {
            self.inner = self
                .inner
                .set_streaming_distribution_config_with_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteCachePolicy<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::delete_cache_policy_input::Builder,
    }
    impl<C, M, R> DeleteCachePolicy<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteCachePolicyOutput,
            smithy_http::result::SdkError<crate::error::DeleteCachePolicyError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DeleteCachePolicyInputOperationOutputAlias,
                crate::output::DeleteCachePolicyOutput,
                crate::error::DeleteCachePolicyError,
                crate::input::DeleteCachePolicyInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The unique identifier for the cache policy that you are deleting. To get the
        /// identifier, you can use <code>ListCachePolicies</code>.</p>
        pub fn id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(inp);
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(input);
            self
        }
        /// <p>The version of the cache policy that you are deleting. The version is the cache
        /// policy’s <code>ETag</code> value, which you can get using
        /// <code>ListCachePolicies</code>, <code>GetCachePolicy</code>, or
        /// <code>GetCachePolicyConfig</code>.</p>
        pub fn if_match(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.if_match(inp);
            self
        }
        pub fn set_if_match(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_if_match(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteCloudFrontOriginAccessIdentity<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::delete_cloud_front_origin_access_identity_input::Builder,
    }
    impl<C, M, R> DeleteCloudFrontOriginAccessIdentity<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteCloudFrontOriginAccessIdentityOutput,
            smithy_http::result::SdkError<crate::error::DeleteCloudFrontOriginAccessIdentityError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DeleteCloudFrontOriginAccessIdentityInputOperationOutputAlias,
                crate::output::DeleteCloudFrontOriginAccessIdentityOutput,
                crate::error::DeleteCloudFrontOriginAccessIdentityError,
                crate::input::DeleteCloudFrontOriginAccessIdentityInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The origin access identity's ID.</p>
        pub fn id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(inp);
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(input);
            self
        }
        /// <p>The value of the <code>ETag</code> header you received from a previous <code>GET</code>
        /// or <code>PUT</code> request. For example: <code>E2QWRUHAPOMQZL</code>.</p>
        pub fn if_match(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.if_match(inp);
            self
        }
        pub fn set_if_match(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_if_match(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteDistribution<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::delete_distribution_input::Builder,
    }
    impl<C, M, R> DeleteDistribution<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteDistributionOutput,
            smithy_http::result::SdkError<crate::error::DeleteDistributionError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DeleteDistributionInputOperationOutputAlias,
                crate::output::DeleteDistributionOutput,
                crate::error::DeleteDistributionError,
                crate::input::DeleteDistributionInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The distribution ID. </p>
        pub fn id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(inp);
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(input);
            self
        }
        /// <p>The value of the <code>ETag</code> header that you received when you disabled the
        /// distribution. For example: <code>E2QWRUHAPOMQZL</code>. </p>
        pub fn if_match(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.if_match(inp);
            self
        }
        pub fn set_if_match(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_if_match(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteFieldLevelEncryptionConfig<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::delete_field_level_encryption_config_input::Builder,
    }
    impl<C, M, R> DeleteFieldLevelEncryptionConfig<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteFieldLevelEncryptionConfigOutput,
            smithy_http::result::SdkError<crate::error::DeleteFieldLevelEncryptionConfigError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DeleteFieldLevelEncryptionConfigInputOperationOutputAlias,
                crate::output::DeleteFieldLevelEncryptionConfigOutput,
                crate::error::DeleteFieldLevelEncryptionConfigError,
                crate::input::DeleteFieldLevelEncryptionConfigInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the configuration you want to delete from CloudFront.</p>
        pub fn id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(inp);
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(input);
            self
        }
        /// <p>The value of the <code>ETag</code> header that you received when retrieving the
        /// configuration identity to delete. For example: <code>E2QWRUHAPOMQZL</code>.</p>
        pub fn if_match(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.if_match(inp);
            self
        }
        pub fn set_if_match(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_if_match(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteFieldLevelEncryptionProfile<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::delete_field_level_encryption_profile_input::Builder,
    }
    impl<C, M, R> DeleteFieldLevelEncryptionProfile<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteFieldLevelEncryptionProfileOutput,
            smithy_http::result::SdkError<crate::error::DeleteFieldLevelEncryptionProfileError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DeleteFieldLevelEncryptionProfileInputOperationOutputAlias,
                crate::output::DeleteFieldLevelEncryptionProfileOutput,
                crate::error::DeleteFieldLevelEncryptionProfileError,
                crate::input::DeleteFieldLevelEncryptionProfileInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Request the ID of the profile you want to delete from CloudFront.</p>
        pub fn id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(inp);
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(input);
            self
        }
        /// <p>The value of the <code>ETag</code> header that you received when retrieving the
        /// profile to delete. For example: <code>E2QWRUHAPOMQZL</code>.</p>
        pub fn if_match(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.if_match(inp);
            self
        }
        pub fn set_if_match(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_if_match(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteFunction<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::delete_function_input::Builder,
    }
    impl<C, M, R> DeleteFunction<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteFunctionOutput,
            smithy_http::result::SdkError<crate::error::DeleteFunctionError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DeleteFunctionInputOperationOutputAlias,
                crate::output::DeleteFunctionOutput,
                crate::error::DeleteFunctionError,
                crate::input::DeleteFunctionInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the function that you are deleting.</p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>The current version (<code>ETag</code> value) of the function that you are deleting, which
        /// you can get using <code>DescribeFunction</code>.</p>
        pub fn if_match(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.if_match(inp);
            self
        }
        pub fn set_if_match(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_if_match(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteKeyGroup<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::delete_key_group_input::Builder,
    }
    impl<C, M, R> DeleteKeyGroup<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteKeyGroupOutput,
            smithy_http::result::SdkError<crate::error::DeleteKeyGroupError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DeleteKeyGroupInputOperationOutputAlias,
                crate::output::DeleteKeyGroupOutput,
                crate::error::DeleteKeyGroupError,
                crate::input::DeleteKeyGroupInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identifier of the key group that you are deleting. To get the identifier, use
        /// <code>ListKeyGroups</code>.</p>
        pub fn id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(inp);
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(input);
            self
        }
        /// <p>The version of the key group that you are deleting. The version is the key group’s
        /// <code>ETag</code> value. To get the <code>ETag</code>, use <code>GetKeyGroup</code> or
        /// <code>GetKeyGroupConfig</code>.</p>
        pub fn if_match(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.if_match(inp);
            self
        }
        pub fn set_if_match(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_if_match(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteMonitoringSubscription<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::delete_monitoring_subscription_input::Builder,
    }
    impl<C, M, R> DeleteMonitoringSubscription<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteMonitoringSubscriptionOutput,
            smithy_http::result::SdkError<crate::error::DeleteMonitoringSubscriptionError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DeleteMonitoringSubscriptionInputOperationOutputAlias,
                crate::output::DeleteMonitoringSubscriptionOutput,
                crate::error::DeleteMonitoringSubscriptionError,
                crate::input::DeleteMonitoringSubscriptionInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the distribution that you are disabling metrics for.</p>
        pub fn distribution_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.distribution_id(inp);
            self
        }
        pub fn set_distribution_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_distribution_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteOriginRequestPolicy<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::delete_origin_request_policy_input::Builder,
    }
    impl<C, M, R> DeleteOriginRequestPolicy<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteOriginRequestPolicyOutput,
            smithy_http::result::SdkError<crate::error::DeleteOriginRequestPolicyError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DeleteOriginRequestPolicyInputOperationOutputAlias,
                crate::output::DeleteOriginRequestPolicyOutput,
                crate::error::DeleteOriginRequestPolicyError,
                crate::input::DeleteOriginRequestPolicyInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The unique identifier for the origin request policy that you are deleting. To get the
        /// identifier, you can use <code>ListOriginRequestPolicies</code>.</p>
        pub fn id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(inp);
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(input);
            self
        }
        /// <p>The version of the origin request policy that you are deleting. The version is the origin
        /// request policy’s <code>ETag</code> value, which you can get using
        /// <code>ListOriginRequestPolicies</code>, <code>GetOriginRequestPolicy</code>, or
        /// <code>GetOriginRequestPolicyConfig</code>.</p>
        pub fn if_match(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.if_match(inp);
            self
        }
        pub fn set_if_match(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_if_match(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeletePublicKey<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::delete_public_key_input::Builder,
    }
    impl<C, M, R> DeletePublicKey<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeletePublicKeyOutput,
            smithy_http::result::SdkError<crate::error::DeletePublicKeyError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DeletePublicKeyInputOperationOutputAlias,
                crate::output::DeletePublicKeyOutput,
                crate::error::DeletePublicKeyError,
                crate::input::DeletePublicKeyInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the public key you want to remove from CloudFront.</p>
        pub fn id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(inp);
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(input);
            self
        }
        /// <p>The value of the <code>ETag</code> header that you received when retrieving the
        /// public key identity to delete. For example: <code>E2QWRUHAPOMQZL</code>.</p>
        pub fn if_match(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.if_match(inp);
            self
        }
        pub fn set_if_match(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_if_match(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteRealtimeLogConfig<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::delete_realtime_log_config_input::Builder,
    }
    impl<C, M, R> DeleteRealtimeLogConfig<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteRealtimeLogConfigOutput,
            smithy_http::result::SdkError<crate::error::DeleteRealtimeLogConfigError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DeleteRealtimeLogConfigInputOperationOutputAlias,
                crate::output::DeleteRealtimeLogConfigOutput,
                crate::error::DeleteRealtimeLogConfigError,
                crate::input::DeleteRealtimeLogConfigInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the real-time log configuration to delete.</p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the real-time log configuration to delete.</p>
        pub fn arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.arn(inp);
            self
        }
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteStreamingDistribution<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::delete_streaming_distribution_input::Builder,
    }
    impl<C, M, R> DeleteStreamingDistribution<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteStreamingDistributionOutput,
            smithy_http::result::SdkError<crate::error::DeleteStreamingDistributionError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DeleteStreamingDistributionInputOperationOutputAlias,
                crate::output::DeleteStreamingDistributionOutput,
                crate::error::DeleteStreamingDistributionError,
                crate::input::DeleteStreamingDistributionInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The distribution ID. </p>
        pub fn id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(inp);
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(input);
            self
        }
        /// <p>The value of the <code>ETag</code> header that you received when you disabled the
        /// streaming distribution. For example: <code>E2QWRUHAPOMQZL</code>.</p>
        pub fn if_match(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.if_match(inp);
            self
        }
        pub fn set_if_match(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_if_match(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeFunction<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::describe_function_input::Builder,
    }
    impl<C, M, R> DescribeFunction<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeFunctionOutput,
            smithy_http::result::SdkError<crate::error::DescribeFunctionError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DescribeFunctionInputOperationOutputAlias,
                crate::output::DescribeFunctionOutput,
                crate::error::DescribeFunctionError,
                crate::input::DescribeFunctionInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the function that you are getting information about.</p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>The function’s stage, either <code>DEVELOPMENT</code> or <code>LIVE</code>.</p>
        pub fn stage(mut self, inp: crate::model::FunctionStage) -> Self {
            self.inner = self.inner.stage(inp);
            self
        }
        pub fn set_stage(
            mut self,
            input: std::option::Option<crate::model::FunctionStage>,
        ) -> Self {
            self.inner = self.inner.set_stage(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetCachePolicy<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::get_cache_policy_input::Builder,
    }
    impl<C, M, R> GetCachePolicy<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetCachePolicyOutput,
            smithy_http::result::SdkError<crate::error::GetCachePolicyError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::GetCachePolicyInputOperationOutputAlias,
                crate::output::GetCachePolicyOutput,
                crate::error::GetCachePolicyError,
                crate::input::GetCachePolicyInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The unique identifier for the cache policy. If the cache policy is attached to a
        /// distribution’s cache behavior, you can get the policy’s identifier using
        /// <code>ListDistributions</code> or <code>GetDistribution</code>. If the cache policy is
        /// not attached to a cache behavior, you can get the identifier using
        /// <code>ListCachePolicies</code>.</p>
        pub fn id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(inp);
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetCachePolicyConfig<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::get_cache_policy_config_input::Builder,
    }
    impl<C, M, R> GetCachePolicyConfig<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetCachePolicyConfigOutput,
            smithy_http::result::SdkError<crate::error::GetCachePolicyConfigError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::GetCachePolicyConfigInputOperationOutputAlias,
                crate::output::GetCachePolicyConfigOutput,
                crate::error::GetCachePolicyConfigError,
                crate::input::GetCachePolicyConfigInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The unique identifier for the cache policy. If the cache policy is attached to a
        /// distribution’s cache behavior, you can get the policy’s identifier using
        /// <code>ListDistributions</code> or <code>GetDistribution</code>. If the cache policy is
        /// not attached to a cache behavior, you can get the identifier using
        /// <code>ListCachePolicies</code>.</p>
        pub fn id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(inp);
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetCloudFrontOriginAccessIdentity<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::get_cloud_front_origin_access_identity_input::Builder,
    }
    impl<C, M, R> GetCloudFrontOriginAccessIdentity<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetCloudFrontOriginAccessIdentityOutput,
            smithy_http::result::SdkError<crate::error::GetCloudFrontOriginAccessIdentityError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::GetCloudFrontOriginAccessIdentityInputOperationOutputAlias,
                crate::output::GetCloudFrontOriginAccessIdentityOutput,
                crate::error::GetCloudFrontOriginAccessIdentityError,
                crate::input::GetCloudFrontOriginAccessIdentityInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identity's ID.</p>
        pub fn id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(inp);
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetCloudFrontOriginAccessIdentityConfig<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::get_cloud_front_origin_access_identity_config_input::Builder,
    }
    impl<C, M, R> GetCloudFrontOriginAccessIdentityConfig<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetCloudFrontOriginAccessIdentityConfigOutput,
            smithy_http::result::SdkError<
                crate::error::GetCloudFrontOriginAccessIdentityConfigError,
            >,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::GetCloudFrontOriginAccessIdentityConfigInputOperationOutputAlias,
                crate::output::GetCloudFrontOriginAccessIdentityConfigOutput,
                crate::error::GetCloudFrontOriginAccessIdentityConfigError,
                crate::input::GetCloudFrontOriginAccessIdentityConfigInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identity's ID. </p>
        pub fn id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(inp);
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetDistribution<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::get_distribution_input::Builder,
    }
    impl<C, M, R> GetDistribution<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetDistributionOutput,
            smithy_http::result::SdkError<crate::error::GetDistributionError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::GetDistributionInputOperationOutputAlias,
                crate::output::GetDistributionOutput,
                crate::error::GetDistributionError,
                crate::input::GetDistributionInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The distribution's ID. If the ID is empty, an empty distribution configuration is returned.</p>
        pub fn id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(inp);
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetDistributionConfig<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::get_distribution_config_input::Builder,
    }
    impl<C, M, R> GetDistributionConfig<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetDistributionConfigOutput,
            smithy_http::result::SdkError<crate::error::GetDistributionConfigError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::GetDistributionConfigInputOperationOutputAlias,
                crate::output::GetDistributionConfigOutput,
                crate::error::GetDistributionConfigError,
                crate::input::GetDistributionConfigInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The distribution's ID. If the ID is empty, an empty distribution configuration is returned.</p>
        pub fn id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(inp);
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetFieldLevelEncryption<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::get_field_level_encryption_input::Builder,
    }
    impl<C, M, R> GetFieldLevelEncryption<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetFieldLevelEncryptionOutput,
            smithy_http::result::SdkError<crate::error::GetFieldLevelEncryptionError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::GetFieldLevelEncryptionInputOperationOutputAlias,
                crate::output::GetFieldLevelEncryptionOutput,
                crate::error::GetFieldLevelEncryptionError,
                crate::input::GetFieldLevelEncryptionInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Request the ID for the field-level encryption configuration information.</p>
        pub fn id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(inp);
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetFieldLevelEncryptionConfig<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::get_field_level_encryption_config_input::Builder,
    }
    impl<C, M, R> GetFieldLevelEncryptionConfig<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetFieldLevelEncryptionConfigOutput,
            smithy_http::result::SdkError<crate::error::GetFieldLevelEncryptionConfigError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::GetFieldLevelEncryptionConfigInputOperationOutputAlias,
                crate::output::GetFieldLevelEncryptionConfigOutput,
                crate::error::GetFieldLevelEncryptionConfigError,
                crate::input::GetFieldLevelEncryptionConfigInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Request the ID for the field-level encryption configuration information.</p>
        pub fn id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(inp);
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetFieldLevelEncryptionProfile<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::get_field_level_encryption_profile_input::Builder,
    }
    impl<C, M, R> GetFieldLevelEncryptionProfile<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetFieldLevelEncryptionProfileOutput,
            smithy_http::result::SdkError<crate::error::GetFieldLevelEncryptionProfileError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::GetFieldLevelEncryptionProfileInputOperationOutputAlias,
                crate::output::GetFieldLevelEncryptionProfileOutput,
                crate::error::GetFieldLevelEncryptionProfileError,
                crate::input::GetFieldLevelEncryptionProfileInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Get the ID for the field-level encryption profile information.</p>
        pub fn id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(inp);
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetFieldLevelEncryptionProfileConfig<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::get_field_level_encryption_profile_config_input::Builder,
    }
    impl<C, M, R> GetFieldLevelEncryptionProfileConfig<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetFieldLevelEncryptionProfileConfigOutput,
            smithy_http::result::SdkError<crate::error::GetFieldLevelEncryptionProfileConfigError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::GetFieldLevelEncryptionProfileConfigInputOperationOutputAlias,
                crate::output::GetFieldLevelEncryptionProfileConfigOutput,
                crate::error::GetFieldLevelEncryptionProfileConfigError,
                crate::input::GetFieldLevelEncryptionProfileConfigInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Get the ID for the field-level encryption profile configuration information.</p>
        pub fn id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(inp);
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetFunction<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::get_function_input::Builder,
    }
    impl<C, M, R> GetFunction<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetFunctionOutput,
            smithy_http::result::SdkError<crate::error::GetFunctionError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::GetFunctionInputOperationOutputAlias,
                crate::output::GetFunctionOutput,
                crate::error::GetFunctionError,
                crate::input::GetFunctionInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the function whose code you are getting.</p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>The function’s stage, either <code>DEVELOPMENT</code> or <code>LIVE</code>.</p>
        pub fn stage(mut self, inp: crate::model::FunctionStage) -> Self {
            self.inner = self.inner.stage(inp);
            self
        }
        pub fn set_stage(
            mut self,
            input: std::option::Option<crate::model::FunctionStage>,
        ) -> Self {
            self.inner = self.inner.set_stage(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetInvalidation<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::get_invalidation_input::Builder,
    }
    impl<C, M, R> GetInvalidation<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetInvalidationOutput,
            smithy_http::result::SdkError<crate::error::GetInvalidationError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::GetInvalidationInputOperationOutputAlias,
                crate::output::GetInvalidationOutput,
                crate::error::GetInvalidationError,
                crate::input::GetInvalidationInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The distribution's ID.</p>
        pub fn distribution_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.distribution_id(inp);
            self
        }
        pub fn set_distribution_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_distribution_id(input);
            self
        }
        /// <p>The identifier for the invalidation request, for example,
        /// <code>IDFDVBD632BHDS5</code>.</p>
        pub fn id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(inp);
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetKeyGroup<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::get_key_group_input::Builder,
    }
    impl<C, M, R> GetKeyGroup<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetKeyGroupOutput,
            smithy_http::result::SdkError<crate::error::GetKeyGroupError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::GetKeyGroupInputOperationOutputAlias,
                crate::output::GetKeyGroupOutput,
                crate::error::GetKeyGroupError,
                crate::input::GetKeyGroupInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identifier of the key group that you are getting. To get the identifier, use
        /// <code>ListKeyGroups</code>.</p>
        pub fn id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(inp);
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetKeyGroupConfig<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::get_key_group_config_input::Builder,
    }
    impl<C, M, R> GetKeyGroupConfig<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetKeyGroupConfigOutput,
            smithy_http::result::SdkError<crate::error::GetKeyGroupConfigError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::GetKeyGroupConfigInputOperationOutputAlias,
                crate::output::GetKeyGroupConfigOutput,
                crate::error::GetKeyGroupConfigError,
                crate::input::GetKeyGroupConfigInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identifier of the key group whose configuration you are getting. To get the
        /// identifier, use <code>ListKeyGroups</code>.</p>
        pub fn id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(inp);
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetMonitoringSubscription<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::get_monitoring_subscription_input::Builder,
    }
    impl<C, M, R> GetMonitoringSubscription<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetMonitoringSubscriptionOutput,
            smithy_http::result::SdkError<crate::error::GetMonitoringSubscriptionError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::GetMonitoringSubscriptionInputOperationOutputAlias,
                crate::output::GetMonitoringSubscriptionOutput,
                crate::error::GetMonitoringSubscriptionError,
                crate::input::GetMonitoringSubscriptionInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the distribution that you are getting metrics information for.</p>
        pub fn distribution_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.distribution_id(inp);
            self
        }
        pub fn set_distribution_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_distribution_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetOriginRequestPolicy<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::get_origin_request_policy_input::Builder,
    }
    impl<C, M, R> GetOriginRequestPolicy<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetOriginRequestPolicyOutput,
            smithy_http::result::SdkError<crate::error::GetOriginRequestPolicyError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::GetOriginRequestPolicyInputOperationOutputAlias,
                crate::output::GetOriginRequestPolicyOutput,
                crate::error::GetOriginRequestPolicyError,
                crate::input::GetOriginRequestPolicyInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The unique identifier for the origin request policy. If the origin request policy is
        /// attached to a distribution’s cache behavior, you can get the policy’s identifier using
        /// <code>ListDistributions</code> or <code>GetDistribution</code>. If the origin request
        /// policy is not attached to a cache behavior, you can get the identifier using
        /// <code>ListOriginRequestPolicies</code>.</p>
        pub fn id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(inp);
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetOriginRequestPolicyConfig<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::get_origin_request_policy_config_input::Builder,
    }
    impl<C, M, R> GetOriginRequestPolicyConfig<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetOriginRequestPolicyConfigOutput,
            smithy_http::result::SdkError<crate::error::GetOriginRequestPolicyConfigError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::GetOriginRequestPolicyConfigInputOperationOutputAlias,
                crate::output::GetOriginRequestPolicyConfigOutput,
                crate::error::GetOriginRequestPolicyConfigError,
                crate::input::GetOriginRequestPolicyConfigInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The unique identifier for the origin request policy. If the origin request policy is
        /// attached to a distribution’s cache behavior, you can get the policy’s identifier using
        /// <code>ListDistributions</code> or <code>GetDistribution</code>. If the origin request
        /// policy is not attached to a cache behavior, you can get the identifier using
        /// <code>ListOriginRequestPolicies</code>.</p>
        pub fn id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(inp);
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetPublicKey<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::get_public_key_input::Builder,
    }
    impl<C, M, R> GetPublicKey<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetPublicKeyOutput,
            smithy_http::result::SdkError<crate::error::GetPublicKeyError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::GetPublicKeyInputOperationOutputAlias,
                crate::output::GetPublicKeyOutput,
                crate::error::GetPublicKeyError,
                crate::input::GetPublicKeyInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identifier of the public key you are getting.</p>
        pub fn id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(inp);
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetPublicKeyConfig<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::get_public_key_config_input::Builder,
    }
    impl<C, M, R> GetPublicKeyConfig<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetPublicKeyConfigOutput,
            smithy_http::result::SdkError<crate::error::GetPublicKeyConfigError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::GetPublicKeyConfigInputOperationOutputAlias,
                crate::output::GetPublicKeyConfigOutput,
                crate::error::GetPublicKeyConfigError,
                crate::input::GetPublicKeyConfigInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identifier of the public key whose configuration you are getting.</p>
        pub fn id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(inp);
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetRealtimeLogConfig<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::get_realtime_log_config_input::Builder,
    }
    impl<C, M, R> GetRealtimeLogConfig<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetRealtimeLogConfigOutput,
            smithy_http::result::SdkError<crate::error::GetRealtimeLogConfigError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::GetRealtimeLogConfigInputOperationOutputAlias,
                crate::output::GetRealtimeLogConfigOutput,
                crate::error::GetRealtimeLogConfigError,
                crate::input::GetRealtimeLogConfigInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the real-time log configuration to get.</p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the real-time log configuration to get.</p>
        pub fn arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.arn(inp);
            self
        }
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetStreamingDistribution<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::get_streaming_distribution_input::Builder,
    }
    impl<C, M, R> GetStreamingDistribution<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetStreamingDistributionOutput,
            smithy_http::result::SdkError<crate::error::GetStreamingDistributionError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::GetStreamingDistributionInputOperationOutputAlias,
                crate::output::GetStreamingDistributionOutput,
                crate::error::GetStreamingDistributionError,
                crate::input::GetStreamingDistributionInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The streaming distribution's ID.</p>
        pub fn id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(inp);
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetStreamingDistributionConfig<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::get_streaming_distribution_config_input::Builder,
    }
    impl<C, M, R> GetStreamingDistributionConfig<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetStreamingDistributionConfigOutput,
            smithy_http::result::SdkError<crate::error::GetStreamingDistributionConfigError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::GetStreamingDistributionConfigInputOperationOutputAlias,
                crate::output::GetStreamingDistributionConfigOutput,
                crate::error::GetStreamingDistributionConfigError,
                crate::input::GetStreamingDistributionConfigInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The streaming distribution's ID.</p>
        pub fn id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(inp);
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListCachePolicies<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::list_cache_policies_input::Builder,
    }
    impl<C, M, R> ListCachePolicies<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListCachePoliciesOutput,
            smithy_http::result::SdkError<crate::error::ListCachePoliciesError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ListCachePoliciesInputOperationOutputAlias,
                crate::output::ListCachePoliciesOutput,
                crate::error::ListCachePoliciesError,
                crate::input::ListCachePoliciesInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A filter to return only the specified kinds of cache policies. Valid values
        /// are:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>managed</code> – Returns only the managed policies created by Amazon Web Services.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>custom</code> – Returns only the custom policies created in your account.</p>
        /// </li>
        /// </ul>
        pub fn r#type(mut self, inp: crate::model::CachePolicyType) -> Self {
            self.inner = self.inner.r#type(inp);
            self
        }
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::CachePolicyType>,
        ) -> Self {
            self.inner = self.inner.set_type(input);
            self
        }
        /// <p>Use this field when paginating results to indicate where to begin in your list of
        /// cache policies. The response includes cache policies in the list that occur after the
        /// marker. To get the next page of the list, set this field’s value to the value of
        /// <code>NextMarker</code> from the current page’s response.</p>
        pub fn marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(inp);
            self
        }
        pub fn set_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(input);
            self
        }
        /// <p>The maximum number of cache policies that you want in the response.</p>
        pub fn max_items(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_items(inp);
            self
        }
        pub fn set_max_items(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_items(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListCloudFrontOriginAccessIdentities<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::list_cloud_front_origin_access_identities_input::Builder,
    }
    impl<C, M, R> ListCloudFrontOriginAccessIdentities<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListCloudFrontOriginAccessIdentitiesOutput,
            smithy_http::result::SdkError<crate::error::ListCloudFrontOriginAccessIdentitiesError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ListCloudFrontOriginAccessIdentitiesInputOperationOutputAlias,
                crate::output::ListCloudFrontOriginAccessIdentitiesOutput,
                crate::error::ListCloudFrontOriginAccessIdentitiesError,
                crate::input::ListCloudFrontOriginAccessIdentitiesInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Use this when paginating results to indicate where to begin in your list of origin
        /// access identities. The results include identities in the list that occur after the marker. To
        /// get the next page of results, set the <code>Marker</code> to the value of the
        /// <code>NextMarker</code> from the current page's response (which is also the ID of the last
        /// identity on that page).</p>
        pub fn marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(inp);
            self
        }
        pub fn set_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(input);
            self
        }
        /// <p>The maximum number of origin access identities you want in the response body.
        /// </p>
        pub fn max_items(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_items(inp);
            self
        }
        pub fn set_max_items(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_items(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListConflictingAliases<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::list_conflicting_aliases_input::Builder,
    }
    impl<C, M, R> ListConflictingAliases<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListConflictingAliasesOutput,
            smithy_http::result::SdkError<crate::error::ListConflictingAliasesError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ListConflictingAliasesInputOperationOutputAlias,
                crate::output::ListConflictingAliasesOutput,
                crate::error::ListConflictingAliasesError,
                crate::input::ListConflictingAliasesInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of a distribution in your account that has an attached SSL/TLS certificate that
        /// includes the provided alias.</p>
        pub fn distribution_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.distribution_id(inp);
            self
        }
        pub fn set_distribution_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_distribution_id(input);
            self
        }
        /// <p>The alias (also called a CNAME) to search for conflicting aliases.</p>
        pub fn alias(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.alias(inp);
            self
        }
        pub fn set_alias(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_alias(input);
            self
        }
        /// <p>Use this field when paginating results to indicate where to begin in the list of
        /// conflicting aliases. The response includes conflicting aliases in the list that occur
        /// after the marker. To get the next page of the list, set this field’s value to the value
        /// of <code>NextMarker</code> from the current page’s response.</p>
        pub fn marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(inp);
            self
        }
        pub fn set_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(input);
            self
        }
        /// <p>The maximum number of conflicting aliases that you want in the response.</p>
        pub fn max_items(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_items(inp);
            self
        }
        pub fn set_max_items(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_items(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListDistributions<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::list_distributions_input::Builder,
    }
    impl<C, M, R> ListDistributions<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListDistributionsOutput,
            smithy_http::result::SdkError<crate::error::ListDistributionsError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ListDistributionsInputOperationOutputAlias,
                crate::output::ListDistributionsOutput,
                crate::error::ListDistributionsError,
                crate::input::ListDistributionsInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Use this when paginating results to indicate where to begin in your list of
        /// distributions. The results include distributions in the list that occur after the marker. To
        /// get the next page of results, set the <code>Marker</code> to the value of the
        /// <code>NextMarker</code> from the current page's response (which is also the ID of the last
        /// distribution on that page).</p>
        pub fn marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(inp);
            self
        }
        pub fn set_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(input);
            self
        }
        /// <p>The maximum number of distributions you want in the response body.</p>
        pub fn max_items(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_items(inp);
            self
        }
        pub fn set_max_items(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_items(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListDistributionsByCachePolicyId<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::list_distributions_by_cache_policy_id_input::Builder,
    }
    impl<C, M, R> ListDistributionsByCachePolicyId<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListDistributionsByCachePolicyIdOutput,
            smithy_http::result::SdkError<crate::error::ListDistributionsByCachePolicyIdError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ListDistributionsByCachePolicyIdInputOperationOutputAlias,
                crate::output::ListDistributionsByCachePolicyIdOutput,
                crate::error::ListDistributionsByCachePolicyIdError,
                crate::input::ListDistributionsByCachePolicyIdInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Use this field when paginating results to indicate where to begin in your list of
        /// distribution IDs. The response includes distribution IDs in the list that occur after
        /// the marker. To get the next page of the list, set this field’s value to the value of
        /// <code>NextMarker</code> from the current page’s response.</p>
        pub fn marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(inp);
            self
        }
        pub fn set_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(input);
            self
        }
        /// <p>The maximum number of distribution IDs that you want in the response.</p>
        pub fn max_items(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_items(inp);
            self
        }
        pub fn set_max_items(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_items(input);
            self
        }
        /// <p>The ID of the cache policy whose associated distribution IDs you want to list.</p>
        pub fn cache_policy_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cache_policy_id(inp);
            self
        }
        pub fn set_cache_policy_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_cache_policy_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListDistributionsByKeyGroup<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::list_distributions_by_key_group_input::Builder,
    }
    impl<C, M, R> ListDistributionsByKeyGroup<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListDistributionsByKeyGroupOutput,
            smithy_http::result::SdkError<crate::error::ListDistributionsByKeyGroupError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ListDistributionsByKeyGroupInputOperationOutputAlias,
                crate::output::ListDistributionsByKeyGroupOutput,
                crate::error::ListDistributionsByKeyGroupError,
                crate::input::ListDistributionsByKeyGroupInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Use this field when paginating results to indicate where to begin in your list of
        /// distribution IDs. The response includes distribution IDs in the list that occur after
        /// the marker. To get the next page of the list, set this field’s value to the value of
        /// <code>NextMarker</code> from the current page’s response.</p>
        pub fn marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(inp);
            self
        }
        pub fn set_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(input);
            self
        }
        /// <p>The maximum number of distribution IDs that you want in the response.</p>
        pub fn max_items(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_items(inp);
            self
        }
        pub fn set_max_items(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_items(input);
            self
        }
        /// <p>The ID of the key group whose associated distribution IDs you are listing.</p>
        pub fn key_group_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.key_group_id(inp);
            self
        }
        pub fn set_key_group_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_key_group_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListDistributionsByOriginRequestPolicyId<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::list_distributions_by_origin_request_policy_id_input::Builder,
    }
    impl<C, M, R> ListDistributionsByOriginRequestPolicyId<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListDistributionsByOriginRequestPolicyIdOutput,
            smithy_http::result::SdkError<
                crate::error::ListDistributionsByOriginRequestPolicyIdError,
            >,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ListDistributionsByOriginRequestPolicyIdInputOperationOutputAlias,
                crate::output::ListDistributionsByOriginRequestPolicyIdOutput,
                crate::error::ListDistributionsByOriginRequestPolicyIdError,
                crate::input::ListDistributionsByOriginRequestPolicyIdInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Use this field when paginating results to indicate where to begin in your list of
        /// distribution IDs. The response includes distribution IDs in the list that occur after
        /// the marker. To get the next page of the list, set this field’s value to the value of
        /// <code>NextMarker</code> from the current page’s response.</p>
        pub fn marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(inp);
            self
        }
        pub fn set_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(input);
            self
        }
        /// <p>The maximum number of distribution IDs that you want in the response.</p>
        pub fn max_items(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_items(inp);
            self
        }
        pub fn set_max_items(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_items(input);
            self
        }
        /// <p>The ID of the origin request policy whose associated distribution IDs you want to
        /// list.</p>
        pub fn origin_request_policy_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.origin_request_policy_id(inp);
            self
        }
        pub fn set_origin_request_policy_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_origin_request_policy_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListDistributionsByRealtimeLogConfig<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::list_distributions_by_realtime_log_config_input::Builder,
    }
    impl<C, M, R> ListDistributionsByRealtimeLogConfig<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListDistributionsByRealtimeLogConfigOutput,
            smithy_http::result::SdkError<crate::error::ListDistributionsByRealtimeLogConfigError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ListDistributionsByRealtimeLogConfigInputOperationOutputAlias,
                crate::output::ListDistributionsByRealtimeLogConfigOutput,
                crate::error::ListDistributionsByRealtimeLogConfigError,
                crate::input::ListDistributionsByRealtimeLogConfigInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Use this field when paginating results to indicate where to begin in your list of
        /// distributions. The response includes distributions in the list that occur after the
        /// marker. To get the next page of the list, set this field’s value to the value of
        /// <code>NextMarker</code> from the current page’s response.</p>
        pub fn marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(inp);
            self
        }
        pub fn set_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(input);
            self
        }
        /// <p>The maximum number of distributions that you want in the response.</p>
        pub fn max_items(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_items(inp);
            self
        }
        pub fn set_max_items(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_items(input);
            self
        }
        /// <p>The name of the real-time log configuration whose associated distributions you want to
        /// list.</p>
        pub fn realtime_log_config_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.realtime_log_config_name(inp);
            self
        }
        pub fn set_realtime_log_config_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_realtime_log_config_name(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the real-time log configuration whose associated
        /// distributions you want to list.</p>
        pub fn realtime_log_config_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.realtime_log_config_arn(inp);
            self
        }
        pub fn set_realtime_log_config_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_realtime_log_config_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListDistributionsByWebACLId<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::list_distributions_by_web_acl_id_input::Builder,
    }
    impl<C, M, R> ListDistributionsByWebACLId<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListDistributionsByWebAclIdOutput,
            smithy_http::result::SdkError<crate::error::ListDistributionsByWebACLIdError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ListDistributionsByWebAclIdInputOperationOutputAlias,
                crate::output::ListDistributionsByWebAclIdOutput,
                crate::error::ListDistributionsByWebACLIdError,
                crate::input::ListDistributionsByWebAclIdInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Use <code>Marker</code> and <code>MaxItems</code> to control pagination of results. If
        /// you have more than <code>MaxItems</code> distributions that satisfy the request, the response
        /// includes a <code>NextMarker</code> element. To get the next page of results, submit another
        /// request. For the value of <code>Marker</code>, specify the value of <code>NextMarker</code>
        /// from the last response. (For the first request, omit <code>Marker</code>.) </p>
        pub fn marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(inp);
            self
        }
        pub fn set_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(input);
            self
        }
        /// <p>The maximum number of distributions that you want CloudFront to return in the response body.
        /// The maximum and default values are both 100.</p>
        pub fn max_items(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_items(inp);
            self
        }
        pub fn set_max_items(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_items(input);
            self
        }
        /// <p>The ID of the WAF web ACL that you want to list the associated distributions.
        /// If you specify "null" for the ID, the request returns a list of the distributions that aren't
        /// associated with a web ACL.</p>
        pub fn web_acl_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.web_acl_id(inp);
            self
        }
        pub fn set_web_acl_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_web_acl_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListFieldLevelEncryptionConfigs<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::list_field_level_encryption_configs_input::Builder,
    }
    impl<C, M, R> ListFieldLevelEncryptionConfigs<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListFieldLevelEncryptionConfigsOutput,
            smithy_http::result::SdkError<crate::error::ListFieldLevelEncryptionConfigsError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ListFieldLevelEncryptionConfigsInputOperationOutputAlias,
                crate::output::ListFieldLevelEncryptionConfigsOutput,
                crate::error::ListFieldLevelEncryptionConfigsError,
                crate::input::ListFieldLevelEncryptionConfigsInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Use this when paginating results to indicate where to begin in your list of configurations. The results include configurations in the list that
        /// occur after the marker. To get the next page of results, set the <code>Marker</code> to the value of the
        /// <code>NextMarker</code> from the current page's response (which is also the ID of the last configuration on that page). </p>
        pub fn marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(inp);
            self
        }
        pub fn set_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(input);
            self
        }
        /// <p>The maximum number of field-level encryption configurations you want in the response body. </p>
        pub fn max_items(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_items(inp);
            self
        }
        pub fn set_max_items(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_items(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListFieldLevelEncryptionProfiles<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::list_field_level_encryption_profiles_input::Builder,
    }
    impl<C, M, R> ListFieldLevelEncryptionProfiles<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListFieldLevelEncryptionProfilesOutput,
            smithy_http::result::SdkError<crate::error::ListFieldLevelEncryptionProfilesError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ListFieldLevelEncryptionProfilesInputOperationOutputAlias,
                crate::output::ListFieldLevelEncryptionProfilesOutput,
                crate::error::ListFieldLevelEncryptionProfilesError,
                crate::input::ListFieldLevelEncryptionProfilesInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Use this when paginating results to indicate where to begin in your list of profiles. The results include profiles in the list that
        /// occur after the marker. To get the next page of results, set the <code>Marker</code> to the value of the
        /// <code>NextMarker</code> from the current page's response (which is also the ID of the last profile on that page). </p>
        pub fn marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(inp);
            self
        }
        pub fn set_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(input);
            self
        }
        /// <p>The maximum number of field-level encryption profiles you want in the response body. </p>
        pub fn max_items(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_items(inp);
            self
        }
        pub fn set_max_items(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_items(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListFunctions<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::list_functions_input::Builder,
    }
    impl<C, M, R> ListFunctions<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListFunctionsOutput,
            smithy_http::result::SdkError<crate::error::ListFunctionsError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ListFunctionsInputOperationOutputAlias,
                crate::output::ListFunctionsOutput,
                crate::error::ListFunctionsError,
                crate::input::ListFunctionsInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Use this field when paginating results to indicate where to begin in your list of
        /// functions. The response includes functions in the list that occur after the marker. To
        /// get the next page of the list, set this field’s value to the value of
        /// <code>NextMarker</code> from the current page’s response.</p>
        pub fn marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(inp);
            self
        }
        pub fn set_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(input);
            self
        }
        /// <p>The maximum number of functions that you want in the response.</p>
        pub fn max_items(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_items(inp);
            self
        }
        pub fn set_max_items(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_items(input);
            self
        }
        /// <p>An optional filter to return only the functions that are in the specified stage,
        /// either <code>DEVELOPMENT</code> or <code>LIVE</code>.</p>
        pub fn stage(mut self, inp: crate::model::FunctionStage) -> Self {
            self.inner = self.inner.stage(inp);
            self
        }
        pub fn set_stage(
            mut self,
            input: std::option::Option<crate::model::FunctionStage>,
        ) -> Self {
            self.inner = self.inner.set_stage(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListInvalidations<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::list_invalidations_input::Builder,
    }
    impl<C, M, R> ListInvalidations<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListInvalidationsOutput,
            smithy_http::result::SdkError<crate::error::ListInvalidationsError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ListInvalidationsInputOperationOutputAlias,
                crate::output::ListInvalidationsOutput,
                crate::error::ListInvalidationsError,
                crate::input::ListInvalidationsInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The distribution's ID.</p>
        pub fn distribution_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.distribution_id(inp);
            self
        }
        pub fn set_distribution_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_distribution_id(input);
            self
        }
        /// <p>Use this parameter when paginating results to indicate where to begin in your list of
        /// invalidation batches. Because the results are returned in decreasing order from most recent to
        /// oldest, the most recent results are on the first page, the second page will contain earlier
        /// results, and so on. To get the next page of results, set <code>Marker</code> to the value of
        /// the <code>NextMarker</code> from the current page's response. This value is the same as the ID
        /// of the last invalidation batch on that page. </p>
        pub fn marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(inp);
            self
        }
        pub fn set_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(input);
            self
        }
        /// <p>The maximum number of invalidation batches that you want in the response
        /// body.</p>
        pub fn max_items(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_items(inp);
            self
        }
        pub fn set_max_items(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_items(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListKeyGroups<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::list_key_groups_input::Builder,
    }
    impl<C, M, R> ListKeyGroups<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListKeyGroupsOutput,
            smithy_http::result::SdkError<crate::error::ListKeyGroupsError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ListKeyGroupsInputOperationOutputAlias,
                crate::output::ListKeyGroupsOutput,
                crate::error::ListKeyGroupsError,
                crate::input::ListKeyGroupsInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Use this field when paginating results to indicate where to begin in your list of key
        /// groups. The response includes key groups in the list that occur after the marker. To get
        /// the next page of the list, set this field’s value to the value of
        /// <code>NextMarker</code> from the current page’s response.</p>
        pub fn marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(inp);
            self
        }
        pub fn set_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(input);
            self
        }
        /// <p>The maximum number of key groups that you want in the response.</p>
        pub fn max_items(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_items(inp);
            self
        }
        pub fn set_max_items(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_items(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListOriginRequestPolicies<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::list_origin_request_policies_input::Builder,
    }
    impl<C, M, R> ListOriginRequestPolicies<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListOriginRequestPoliciesOutput,
            smithy_http::result::SdkError<crate::error::ListOriginRequestPoliciesError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ListOriginRequestPoliciesInputOperationOutputAlias,
                crate::output::ListOriginRequestPoliciesOutput,
                crate::error::ListOriginRequestPoliciesError,
                crate::input::ListOriginRequestPoliciesInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A filter to return only the specified kinds of origin request policies. Valid values
        /// are:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>managed</code> – Returns only the managed policies created by Amazon Web Services.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>custom</code> – Returns only the custom policies created in your account.</p>
        /// </li>
        /// </ul>
        pub fn r#type(mut self, inp: crate::model::OriginRequestPolicyType) -> Self {
            self.inner = self.inner.r#type(inp);
            self
        }
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::OriginRequestPolicyType>,
        ) -> Self {
            self.inner = self.inner.set_type(input);
            self
        }
        /// <p>Use this field when paginating results to indicate where to begin in your list of
        /// origin request policies. The response includes origin request policies in the list that
        /// occur after the marker. To get the next page of the list, set this field’s value to the
        /// value of <code>NextMarker</code> from the current page’s response.</p>
        pub fn marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(inp);
            self
        }
        pub fn set_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(input);
            self
        }
        /// <p>The maximum number of origin request policies that you want in the response.</p>
        pub fn max_items(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_items(inp);
            self
        }
        pub fn set_max_items(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_items(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListPublicKeys<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::list_public_keys_input::Builder,
    }
    impl<C, M, R> ListPublicKeys<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListPublicKeysOutput,
            smithy_http::result::SdkError<crate::error::ListPublicKeysError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ListPublicKeysInputOperationOutputAlias,
                crate::output::ListPublicKeysOutput,
                crate::error::ListPublicKeysError,
                crate::input::ListPublicKeysInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Use this when paginating results to indicate where to begin in your list of public keys. The results include public keys in the list that
        /// occur after the marker. To get the next page of results, set the <code>Marker</code> to the value of the
        /// <code>NextMarker</code> from the current page's response (which is also the ID of the last public key on that page). </p>
        pub fn marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(inp);
            self
        }
        pub fn set_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(input);
            self
        }
        /// <p>The maximum number of public keys you want in the response body. </p>
        pub fn max_items(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_items(inp);
            self
        }
        pub fn set_max_items(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_items(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListRealtimeLogConfigs<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::list_realtime_log_configs_input::Builder,
    }
    impl<C, M, R> ListRealtimeLogConfigs<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListRealtimeLogConfigsOutput,
            smithy_http::result::SdkError<crate::error::ListRealtimeLogConfigsError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ListRealtimeLogConfigsInputOperationOutputAlias,
                crate::output::ListRealtimeLogConfigsOutput,
                crate::error::ListRealtimeLogConfigsError,
                crate::input::ListRealtimeLogConfigsInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The maximum number of real-time log configurations that you want in the response.</p>
        pub fn max_items(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_items(inp);
            self
        }
        pub fn set_max_items(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_items(input);
            self
        }
        /// <p>Use this field when paginating results to indicate where to begin in your list of real-time
        /// log configurations. The response includes real-time log configurations in the list that
        /// occur after the marker. To get the next page of the list, set this field’s value to the
        /// value of <code>NextMarker</code> from the current page’s response.</p>
        pub fn marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(inp);
            self
        }
        pub fn set_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListStreamingDistributions<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::list_streaming_distributions_input::Builder,
    }
    impl<C, M, R> ListStreamingDistributions<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListStreamingDistributionsOutput,
            smithy_http::result::SdkError<crate::error::ListStreamingDistributionsError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ListStreamingDistributionsInputOperationOutputAlias,
                crate::output::ListStreamingDistributionsOutput,
                crate::error::ListStreamingDistributionsError,
                crate::input::ListStreamingDistributionsInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The value that you provided for the <code>Marker</code> request parameter.</p>
        pub fn marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(inp);
            self
        }
        pub fn set_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(input);
            self
        }
        /// <p>The value that you provided for the <code>MaxItems</code> request parameter.</p>
        pub fn max_items(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_items(inp);
            self
        }
        pub fn set_max_items(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_items(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListTagsForResource<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::list_tags_for_resource_input::Builder,
    }
    impl<C, M, R> ListTagsForResource<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListTagsForResourceOutput,
            smithy_http::result::SdkError<crate::error::ListTagsForResourceError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ListTagsForResourceInputOperationOutputAlias,
                crate::output::ListTagsForResourceOutput,
                crate::error::ListTagsForResourceError,
                crate::input::ListTagsForResourceInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p> An ARN of a CloudFront resource.</p>
        pub fn resource(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource(inp);
            self
        }
        pub fn set_resource(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PublishFunction<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::publish_function_input::Builder,
    }
    impl<C, M, R> PublishFunction<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PublishFunctionOutput,
            smithy_http::result::SdkError<crate::error::PublishFunctionError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::PublishFunctionInputOperationOutputAlias,
                crate::output::PublishFunctionOutput,
                crate::error::PublishFunctionError,
                crate::input::PublishFunctionInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the function that you are publishing.</p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>The current version (<code>ETag</code> value) of the function that you are publishing, which
        /// you can get using <code>DescribeFunction</code>.</p>
        pub fn if_match(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.if_match(inp);
            self
        }
        pub fn set_if_match(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_if_match(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct TagResource<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::tag_resource_input::Builder,
    }
    impl<C, M, R> TagResource<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::TagResourceOutput,
            smithy_http::result::SdkError<crate::error::TagResourceError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::TagResourceInputOperationOutputAlias,
                crate::output::TagResourceOutput,
                crate::error::TagResourceError,
                crate::input::TagResourceInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p> An ARN of a CloudFront resource.</p>
        pub fn resource(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource(inp);
            self
        }
        pub fn set_resource(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource(input);
            self
        }
        /// <p> A complex type that contains zero or more <code>Tag</code> elements.</p>
        pub fn tags(mut self, inp: crate::model::Tags) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(mut self, input: std::option::Option<crate::model::Tags>) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct TestFunction<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::test_function_input::Builder,
    }
    impl<C, M, R> TestFunction<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::TestFunctionOutput,
            smithy_http::result::SdkError<crate::error::TestFunctionError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::TestFunctionInputOperationOutputAlias,
                crate::output::TestFunctionOutput,
                crate::error::TestFunctionError,
                crate::input::TestFunctionInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the function that you are testing.</p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>The current version (<code>ETag</code> value) of the function that you are testing, which
        /// you can get using <code>DescribeFunction</code>.</p>
        pub fn if_match(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.if_match(inp);
            self
        }
        pub fn set_if_match(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_if_match(input);
            self
        }
        /// <p>The stage of the function that you are testing, either <code>DEVELOPMENT</code> or
        /// <code>LIVE</code>.</p>
        pub fn stage(mut self, inp: crate::model::FunctionStage) -> Self {
            self.inner = self.inner.stage(inp);
            self
        }
        pub fn set_stage(
            mut self,
            input: std::option::Option<crate::model::FunctionStage>,
        ) -> Self {
            self.inner = self.inner.set_stage(input);
            self
        }
        /// <p>The event object to test the function with. For more information about the structure of the
        /// event object, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/managing-functions.html#test-function">Testing functions</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
        pub fn event_object(mut self, inp: smithy_types::Blob) -> Self {
            self.inner = self.inner.event_object(inp);
            self
        }
        pub fn set_event_object(mut self, input: std::option::Option<smithy_types::Blob>) -> Self {
            self.inner = self.inner.set_event_object(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UntagResource<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::untag_resource_input::Builder,
    }
    impl<C, M, R> UntagResource<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UntagResourceOutput,
            smithy_http::result::SdkError<crate::error::UntagResourceError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::UntagResourceInputOperationOutputAlias,
                crate::output::UntagResourceOutput,
                crate::error::UntagResourceError,
                crate::input::UntagResourceInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p> An ARN of a CloudFront resource.</p>
        pub fn resource(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource(inp);
            self
        }
        pub fn set_resource(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource(input);
            self
        }
        /// <p> A complex type that contains zero or more <code>Tag</code> key elements.</p>
        pub fn tag_keys(mut self, inp: crate::model::TagKeys) -> Self {
            self.inner = self.inner.tag_keys(inp);
            self
        }
        pub fn set_tag_keys(mut self, input: std::option::Option<crate::model::TagKeys>) -> Self {
            self.inner = self.inner.set_tag_keys(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateCachePolicy<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::update_cache_policy_input::Builder,
    }
    impl<C, M, R> UpdateCachePolicy<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateCachePolicyOutput,
            smithy_http::result::SdkError<crate::error::UpdateCachePolicyError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::UpdateCachePolicyInputOperationOutputAlias,
                crate::output::UpdateCachePolicyOutput,
                crate::error::UpdateCachePolicyError,
                crate::input::UpdateCachePolicyInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The unique identifier for the cache policy that you are updating. The identifier is returned
        /// in a cache behavior’s <code>CachePolicyId</code> field in the response to
        /// <code>GetDistributionConfig</code>.</p>
        pub fn id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(inp);
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(input);
            self
        }
        /// <p>The version of the cache policy that you are updating. The version is returned in the cache
        /// policy’s <code>ETag</code> field in the response to
        /// <code>GetCachePolicyConfig</code>.</p>
        pub fn if_match(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.if_match(inp);
            self
        }
        pub fn set_if_match(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_if_match(input);
            self
        }
        /// <p>A cache policy configuration.</p>
        pub fn cache_policy_config(mut self, inp: crate::model::CachePolicyConfig) -> Self {
            self.inner = self.inner.cache_policy_config(inp);
            self
        }
        pub fn set_cache_policy_config(
            mut self,
            input: std::option::Option<crate::model::CachePolicyConfig>,
        ) -> Self {
            self.inner = self.inner.set_cache_policy_config(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateCloudFrontOriginAccessIdentity<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::update_cloud_front_origin_access_identity_input::Builder,
    }
    impl<C, M, R> UpdateCloudFrontOriginAccessIdentity<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateCloudFrontOriginAccessIdentityOutput,
            smithy_http::result::SdkError<crate::error::UpdateCloudFrontOriginAccessIdentityError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::UpdateCloudFrontOriginAccessIdentityInputOperationOutputAlias,
                crate::output::UpdateCloudFrontOriginAccessIdentityOutput,
                crate::error::UpdateCloudFrontOriginAccessIdentityError,
                crate::input::UpdateCloudFrontOriginAccessIdentityInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identity's id.</p>
        pub fn id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(inp);
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(input);
            self
        }
        /// <p>The value of the <code>ETag</code> header that you received when retrieving the
        /// identity's configuration. For example: <code>E2QWRUHAPOMQZL</code>.</p>
        pub fn if_match(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.if_match(inp);
            self
        }
        pub fn set_if_match(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_if_match(input);
            self
        }
        /// <p>The identity's configuration information.</p>
        pub fn cloud_front_origin_access_identity_config(
            mut self,
            inp: crate::model::CloudFrontOriginAccessIdentityConfig,
        ) -> Self {
            self.inner = self.inner.cloud_front_origin_access_identity_config(inp);
            self
        }
        pub fn set_cloud_front_origin_access_identity_config(
            mut self,
            input: std::option::Option<crate::model::CloudFrontOriginAccessIdentityConfig>,
        ) -> Self {
            self.inner = self
                .inner
                .set_cloud_front_origin_access_identity_config(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateDistribution<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::update_distribution_input::Builder,
    }
    impl<C, M, R> UpdateDistribution<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateDistributionOutput,
            smithy_http::result::SdkError<crate::error::UpdateDistributionError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::UpdateDistributionInputOperationOutputAlias,
                crate::output::UpdateDistributionOutput,
                crate::error::UpdateDistributionError,
                crate::input::UpdateDistributionInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The distribution's id.</p>
        pub fn id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(inp);
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(input);
            self
        }
        /// <p>The value of the <code>ETag</code> header that you received when retrieving the
        /// distribution's configuration. For example: <code>E2QWRUHAPOMQZL</code>.</p>
        pub fn if_match(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.if_match(inp);
            self
        }
        pub fn set_if_match(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_if_match(input);
            self
        }
        /// <p>The distribution's configuration information.</p>
        pub fn distribution_config(mut self, inp: crate::model::DistributionConfig) -> Self {
            self.inner = self.inner.distribution_config(inp);
            self
        }
        pub fn set_distribution_config(
            mut self,
            input: std::option::Option<crate::model::DistributionConfig>,
        ) -> Self {
            self.inner = self.inner.set_distribution_config(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateFieldLevelEncryptionConfig<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::update_field_level_encryption_config_input::Builder,
    }
    impl<C, M, R> UpdateFieldLevelEncryptionConfig<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateFieldLevelEncryptionConfigOutput,
            smithy_http::result::SdkError<crate::error::UpdateFieldLevelEncryptionConfigError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::UpdateFieldLevelEncryptionConfigInputOperationOutputAlias,
                crate::output::UpdateFieldLevelEncryptionConfigOutput,
                crate::error::UpdateFieldLevelEncryptionConfigError,
                crate::input::UpdateFieldLevelEncryptionConfigInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the configuration you want to update.</p>
        pub fn id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(inp);
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(input);
            self
        }
        /// <p>The value of the <code>ETag</code> header that you received when retrieving the configuration identity to update.
        /// For example: <code>E2QWRUHAPOMQZL</code>.</p>
        pub fn if_match(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.if_match(inp);
            self
        }
        pub fn set_if_match(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_if_match(input);
            self
        }
        /// <p>Request to update a field-level encryption configuration. </p>
        pub fn field_level_encryption_config(
            mut self,
            inp: crate::model::FieldLevelEncryptionConfig,
        ) -> Self {
            self.inner = self.inner.field_level_encryption_config(inp);
            self
        }
        pub fn set_field_level_encryption_config(
            mut self,
            input: std::option::Option<crate::model::FieldLevelEncryptionConfig>,
        ) -> Self {
            self.inner = self.inner.set_field_level_encryption_config(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateFieldLevelEncryptionProfile<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::update_field_level_encryption_profile_input::Builder,
    }
    impl<C, M, R> UpdateFieldLevelEncryptionProfile<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateFieldLevelEncryptionProfileOutput,
            smithy_http::result::SdkError<crate::error::UpdateFieldLevelEncryptionProfileError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::UpdateFieldLevelEncryptionProfileInputOperationOutputAlias,
                crate::output::UpdateFieldLevelEncryptionProfileOutput,
                crate::error::UpdateFieldLevelEncryptionProfileError,
                crate::input::UpdateFieldLevelEncryptionProfileInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the field-level encryption profile request. </p>
        pub fn id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(inp);
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(input);
            self
        }
        /// <p>The value of the <code>ETag</code> header that you received when retrieving the profile identity to update.
        /// For example: <code>E2QWRUHAPOMQZL</code>.</p>
        pub fn if_match(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.if_match(inp);
            self
        }
        pub fn set_if_match(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_if_match(input);
            self
        }
        /// <p>Request to update a field-level encryption profile. </p>
        pub fn field_level_encryption_profile_config(
            mut self,
            inp: crate::model::FieldLevelEncryptionProfileConfig,
        ) -> Self {
            self.inner = self.inner.field_level_encryption_profile_config(inp);
            self
        }
        pub fn set_field_level_encryption_profile_config(
            mut self,
            input: std::option::Option<crate::model::FieldLevelEncryptionProfileConfig>,
        ) -> Self {
            self.inner = self.inner.set_field_level_encryption_profile_config(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateFunction<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::update_function_input::Builder,
    }
    impl<C, M, R> UpdateFunction<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateFunctionOutput,
            smithy_http::result::SdkError<crate::error::UpdateFunctionError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::UpdateFunctionInputOperationOutputAlias,
                crate::output::UpdateFunctionOutput,
                crate::error::UpdateFunctionError,
                crate::input::UpdateFunctionInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the function that you are updating.</p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>The current version (<code>ETag</code> value) of the function that you are updating, which
        /// you can get using <code>DescribeFunction</code>.</p>
        pub fn if_match(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.if_match(inp);
            self
        }
        pub fn set_if_match(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_if_match(input);
            self
        }
        /// <p>Configuration information about the function.</p>
        pub fn function_config(mut self, inp: crate::model::FunctionConfig) -> Self {
            self.inner = self.inner.function_config(inp);
            self
        }
        pub fn set_function_config(
            mut self,
            input: std::option::Option<crate::model::FunctionConfig>,
        ) -> Self {
            self.inner = self.inner.set_function_config(input);
            self
        }
        /// <p>The function code. For more information about writing a CloudFront function, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/writing-function-code.html">Writing function
        /// code for CloudFront Functions</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
        pub fn function_code(mut self, inp: smithy_types::Blob) -> Self {
            self.inner = self.inner.function_code(inp);
            self
        }
        pub fn set_function_code(mut self, input: std::option::Option<smithy_types::Blob>) -> Self {
            self.inner = self.inner.set_function_code(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateKeyGroup<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::update_key_group_input::Builder,
    }
    impl<C, M, R> UpdateKeyGroup<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateKeyGroupOutput,
            smithy_http::result::SdkError<crate::error::UpdateKeyGroupError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::UpdateKeyGroupInputOperationOutputAlias,
                crate::output::UpdateKeyGroupOutput,
                crate::error::UpdateKeyGroupError,
                crate::input::UpdateKeyGroupInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identifier of the key group that you are updating.</p>
        pub fn id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(inp);
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(input);
            self
        }
        /// <p>The version of the key group that you are updating. The version is the key group’s
        /// <code>ETag</code> value.</p>
        pub fn if_match(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.if_match(inp);
            self
        }
        pub fn set_if_match(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_if_match(input);
            self
        }
        /// <p>The key group configuration.</p>
        pub fn key_group_config(mut self, inp: crate::model::KeyGroupConfig) -> Self {
            self.inner = self.inner.key_group_config(inp);
            self
        }
        pub fn set_key_group_config(
            mut self,
            input: std::option::Option<crate::model::KeyGroupConfig>,
        ) -> Self {
            self.inner = self.inner.set_key_group_config(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateOriginRequestPolicy<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::update_origin_request_policy_input::Builder,
    }
    impl<C, M, R> UpdateOriginRequestPolicy<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateOriginRequestPolicyOutput,
            smithy_http::result::SdkError<crate::error::UpdateOriginRequestPolicyError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::UpdateOriginRequestPolicyInputOperationOutputAlias,
                crate::output::UpdateOriginRequestPolicyOutput,
                crate::error::UpdateOriginRequestPolicyError,
                crate::input::UpdateOriginRequestPolicyInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The unique identifier for the origin request policy that you are updating. The identifier is
        /// returned in a cache behavior’s <code>OriginRequestPolicyId</code> field in the response
        /// to <code>GetDistributionConfig</code>.</p>
        pub fn id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(inp);
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(input);
            self
        }
        /// <p>The version of the origin request policy that you are updating. The version is returned in
        /// the origin request policy’s <code>ETag</code> field in the response to
        /// <code>GetOriginRequestPolicyConfig</code>.</p>
        pub fn if_match(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.if_match(inp);
            self
        }
        pub fn set_if_match(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_if_match(input);
            self
        }
        /// <p>An origin request policy configuration.</p>
        pub fn origin_request_policy_config(
            mut self,
            inp: crate::model::OriginRequestPolicyConfig,
        ) -> Self {
            self.inner = self.inner.origin_request_policy_config(inp);
            self
        }
        pub fn set_origin_request_policy_config(
            mut self,
            input: std::option::Option<crate::model::OriginRequestPolicyConfig>,
        ) -> Self {
            self.inner = self.inner.set_origin_request_policy_config(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdatePublicKey<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::update_public_key_input::Builder,
    }
    impl<C, M, R> UpdatePublicKey<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdatePublicKeyOutput,
            smithy_http::result::SdkError<crate::error::UpdatePublicKeyError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::UpdatePublicKeyInputOperationOutputAlias,
                crate::output::UpdatePublicKeyOutput,
                crate::error::UpdatePublicKeyError,
                crate::input::UpdatePublicKeyInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identifier of the public key that you are updating.</p>
        pub fn id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(inp);
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(input);
            self
        }
        /// <p>The value of the <code>ETag</code> header that you received when retrieving the public key to update.
        /// For example: <code>E2QWRUHAPOMQZL</code>.</p>
        pub fn if_match(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.if_match(inp);
            self
        }
        pub fn set_if_match(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_if_match(input);
            self
        }
        /// <p>A public key configuration.</p>
        pub fn public_key_config(mut self, inp: crate::model::PublicKeyConfig) -> Self {
            self.inner = self.inner.public_key_config(inp);
            self
        }
        pub fn set_public_key_config(
            mut self,
            input: std::option::Option<crate::model::PublicKeyConfig>,
        ) -> Self {
            self.inner = self.inner.set_public_key_config(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateRealtimeLogConfig<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::update_realtime_log_config_input::Builder,
    }
    impl<C, M, R> UpdateRealtimeLogConfig<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateRealtimeLogConfigOutput,
            smithy_http::result::SdkError<crate::error::UpdateRealtimeLogConfigError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::UpdateRealtimeLogConfigInputOperationOutputAlias,
                crate::output::UpdateRealtimeLogConfigOutput,
                crate::error::UpdateRealtimeLogConfigError,
                crate::input::UpdateRealtimeLogConfigInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// Appends an item to `EndPoints`.
        ///
        /// To override the contents of this collection use [`set_end_points`](Self::set_end_points).
        /// <p>Contains information about the Amazon Kinesis data stream where you are sending real-time
        /// log data.</p>
        pub fn end_points(mut self, inp: impl Into<crate::model::EndPoint>) -> Self {
            self.inner = self.inner.end_points(inp);
            self
        }
        pub fn set_end_points(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::EndPoint>>,
        ) -> Self {
            self.inner = self.inner.set_end_points(input);
            self
        }
        /// Appends an item to `Fields`.
        ///
        /// To override the contents of this collection use [`set_fields`](Self::set_fields).
        /// <p>A list of fields to include in each real-time log record.</p>
        /// <p>For more information about fields, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/real-time-logs.html#understand-real-time-log-config-fields">Real-time log configuration fields</a> in the
        /// <i>Amazon CloudFront Developer Guide</i>.</p>
        pub fn fields(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.fields(inp);
            self
        }
        pub fn set_fields(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_fields(input);
            self
        }
        /// <p>The name for this real-time log configuration.</p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) for this real-time log configuration.</p>
        pub fn arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.arn(inp);
            self
        }
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_arn(input);
            self
        }
        /// <p>The sampling rate for this real-time log configuration. The sampling rate determines the
        /// percentage of viewer requests that are represented in the real-time log data. You must
        /// provide an integer between 1 and 100, inclusive.</p>
        pub fn sampling_rate(mut self, inp: i64) -> Self {
            self.inner = self.inner.sampling_rate(inp);
            self
        }
        pub fn set_sampling_rate(mut self, input: std::option::Option<i64>) -> Self {
            self.inner = self.inner.set_sampling_rate(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateStreamingDistribution<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::update_streaming_distribution_input::Builder,
    }
    impl<C, M, R> UpdateStreamingDistribution<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateStreamingDistributionOutput,
            smithy_http::result::SdkError<crate::error::UpdateStreamingDistributionError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::UpdateStreamingDistributionInputOperationOutputAlias,
                crate::output::UpdateStreamingDistributionOutput,
                crate::error::UpdateStreamingDistributionError,
                crate::input::UpdateStreamingDistributionInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The streaming distribution's id.</p>
        pub fn id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(inp);
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(input);
            self
        }
        /// <p>The value of the <code>ETag</code> header that you received when retrieving the
        /// streaming distribution's configuration. For example: <code>E2QWRUHAPOMQZL</code>.</p>
        pub fn if_match(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.if_match(inp);
            self
        }
        pub fn set_if_match(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_if_match(input);
            self
        }
        /// <p>The streaming distribution's configuration information.</p>
        pub fn streaming_distribution_config(
            mut self,
            inp: crate::model::StreamingDistributionConfig,
        ) -> Self {
            self.inner = self.inner.streaming_distribution_config(inp);
            self
        }
        pub fn set_streaming_distribution_config(
            mut self,
            input: std::option::Option<crate::model::StreamingDistributionConfig>,
        ) -> Self {
            self.inner = self.inner.set_streaming_distribution_config(input);
            self
        }
    }
}
impl<C> Client<C, aws_hyper::AwsMiddleware, smithy_client::retry::Standard> {
    pub fn from_conf_conn(conf: crate::Config, conn: C) -> Self {
        let client = aws_hyper::Client::new(conn);
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }
}
impl
    Client<
        smithy_client::erase::DynConnector,
        aws_hyper::AwsMiddleware,
        smithy_client::retry::Standard,
    >
{
    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn new(config: &aws_types::config::Config) -> Self {
        Self::from_conf(config.into())
    }

    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_conf(conf: crate::Config) -> Self {
        let client = aws_hyper::Client::https();
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }
}
