// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[derive(std::fmt::Debug)]
pub(crate) struct Handle<C = aws_hyper::DynConnector> {
    client: aws_hyper::Client<C>,
    conf: crate::Config,
}

#[derive(Clone, std::fmt::Debug)]
pub struct Client<C = aws_hyper::DynConnector> {
    handle: std::sync::Arc<Handle<C>>,
}
impl<C> Client<C> {
    pub fn from_conf_conn(conf: crate::Config, conn: C) -> Self {
        let client = aws_hyper::Client::new(conn);
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }

    pub fn conf(&self) -> &crate::Config {
        &self.handle.conf
    }
}
impl Client {
    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_env() -> Self {
        Self::from_conf(crate::Config::builder().build())
    }

    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_conf(conf: crate::Config) -> Self {
        let client = aws_hyper::Client::https();
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }
}
impl<C> Client<C>
where
    C: aws_hyper::SmithyConnector,
{
    pub fn create_cache_policy(&self) -> fluent_builders::CreateCachePolicy<C> {
        fluent_builders::CreateCachePolicy::new(self.handle.clone())
    }
    pub fn create_cloud_front_origin_access_identity(
        &self,
    ) -> fluent_builders::CreateCloudFrontOriginAccessIdentity<C> {
        fluent_builders::CreateCloudFrontOriginAccessIdentity::new(self.handle.clone())
    }
    pub fn create_distribution(&self) -> fluent_builders::CreateDistribution<C> {
        fluent_builders::CreateDistribution::new(self.handle.clone())
    }
    pub fn create_distribution_with_tags(&self) -> fluent_builders::CreateDistributionWithTags<C> {
        fluent_builders::CreateDistributionWithTags::new(self.handle.clone())
    }
    pub fn create_field_level_encryption_config(
        &self,
    ) -> fluent_builders::CreateFieldLevelEncryptionConfig<C> {
        fluent_builders::CreateFieldLevelEncryptionConfig::new(self.handle.clone())
    }
    pub fn create_field_level_encryption_profile(
        &self,
    ) -> fluent_builders::CreateFieldLevelEncryptionProfile<C> {
        fluent_builders::CreateFieldLevelEncryptionProfile::new(self.handle.clone())
    }
    pub fn create_function(&self) -> fluent_builders::CreateFunction<C> {
        fluent_builders::CreateFunction::new(self.handle.clone())
    }
    pub fn create_invalidation(&self) -> fluent_builders::CreateInvalidation<C> {
        fluent_builders::CreateInvalidation::new(self.handle.clone())
    }
    pub fn create_key_group(&self) -> fluent_builders::CreateKeyGroup<C> {
        fluent_builders::CreateKeyGroup::new(self.handle.clone())
    }
    pub fn create_monitoring_subscription(
        &self,
    ) -> fluent_builders::CreateMonitoringSubscription<C> {
        fluent_builders::CreateMonitoringSubscription::new(self.handle.clone())
    }
    pub fn create_origin_request_policy(&self) -> fluent_builders::CreateOriginRequestPolicy<C> {
        fluent_builders::CreateOriginRequestPolicy::new(self.handle.clone())
    }
    pub fn create_public_key(&self) -> fluent_builders::CreatePublicKey<C> {
        fluent_builders::CreatePublicKey::new(self.handle.clone())
    }
    pub fn create_realtime_log_config(&self) -> fluent_builders::CreateRealtimeLogConfig<C> {
        fluent_builders::CreateRealtimeLogConfig::new(self.handle.clone())
    }
    pub fn create_streaming_distribution(&self) -> fluent_builders::CreateStreamingDistribution<C> {
        fluent_builders::CreateStreamingDistribution::new(self.handle.clone())
    }
    pub fn create_streaming_distribution_with_tags(
        &self,
    ) -> fluent_builders::CreateStreamingDistributionWithTags<C> {
        fluent_builders::CreateStreamingDistributionWithTags::new(self.handle.clone())
    }
    pub fn delete_cache_policy(&self) -> fluent_builders::DeleteCachePolicy<C> {
        fluent_builders::DeleteCachePolicy::new(self.handle.clone())
    }
    pub fn delete_cloud_front_origin_access_identity(
        &self,
    ) -> fluent_builders::DeleteCloudFrontOriginAccessIdentity<C> {
        fluent_builders::DeleteCloudFrontOriginAccessIdentity::new(self.handle.clone())
    }
    pub fn delete_distribution(&self) -> fluent_builders::DeleteDistribution<C> {
        fluent_builders::DeleteDistribution::new(self.handle.clone())
    }
    pub fn delete_field_level_encryption_config(
        &self,
    ) -> fluent_builders::DeleteFieldLevelEncryptionConfig<C> {
        fluent_builders::DeleteFieldLevelEncryptionConfig::new(self.handle.clone())
    }
    pub fn delete_field_level_encryption_profile(
        &self,
    ) -> fluent_builders::DeleteFieldLevelEncryptionProfile<C> {
        fluent_builders::DeleteFieldLevelEncryptionProfile::new(self.handle.clone())
    }
    pub fn delete_function(&self) -> fluent_builders::DeleteFunction<C> {
        fluent_builders::DeleteFunction::new(self.handle.clone())
    }
    pub fn delete_key_group(&self) -> fluent_builders::DeleteKeyGroup<C> {
        fluent_builders::DeleteKeyGroup::new(self.handle.clone())
    }
    pub fn delete_monitoring_subscription(
        &self,
    ) -> fluent_builders::DeleteMonitoringSubscription<C> {
        fluent_builders::DeleteMonitoringSubscription::new(self.handle.clone())
    }
    pub fn delete_origin_request_policy(&self) -> fluent_builders::DeleteOriginRequestPolicy<C> {
        fluent_builders::DeleteOriginRequestPolicy::new(self.handle.clone())
    }
    pub fn delete_public_key(&self) -> fluent_builders::DeletePublicKey<C> {
        fluent_builders::DeletePublicKey::new(self.handle.clone())
    }
    pub fn delete_realtime_log_config(&self) -> fluent_builders::DeleteRealtimeLogConfig<C> {
        fluent_builders::DeleteRealtimeLogConfig::new(self.handle.clone())
    }
    pub fn delete_streaming_distribution(&self) -> fluent_builders::DeleteStreamingDistribution<C> {
        fluent_builders::DeleteStreamingDistribution::new(self.handle.clone())
    }
    pub fn describe_function(&self) -> fluent_builders::DescribeFunction<C> {
        fluent_builders::DescribeFunction::new(self.handle.clone())
    }
    pub fn get_cache_policy(&self) -> fluent_builders::GetCachePolicy<C> {
        fluent_builders::GetCachePolicy::new(self.handle.clone())
    }
    pub fn get_cache_policy_config(&self) -> fluent_builders::GetCachePolicyConfig<C> {
        fluent_builders::GetCachePolicyConfig::new(self.handle.clone())
    }
    pub fn get_cloud_front_origin_access_identity(
        &self,
    ) -> fluent_builders::GetCloudFrontOriginAccessIdentity<C> {
        fluent_builders::GetCloudFrontOriginAccessIdentity::new(self.handle.clone())
    }
    pub fn get_cloud_front_origin_access_identity_config(
        &self,
    ) -> fluent_builders::GetCloudFrontOriginAccessIdentityConfig<C> {
        fluent_builders::GetCloudFrontOriginAccessIdentityConfig::new(self.handle.clone())
    }
    pub fn get_distribution(&self) -> fluent_builders::GetDistribution<C> {
        fluent_builders::GetDistribution::new(self.handle.clone())
    }
    pub fn get_distribution_config(&self) -> fluent_builders::GetDistributionConfig<C> {
        fluent_builders::GetDistributionConfig::new(self.handle.clone())
    }
    pub fn get_field_level_encryption(&self) -> fluent_builders::GetFieldLevelEncryption<C> {
        fluent_builders::GetFieldLevelEncryption::new(self.handle.clone())
    }
    pub fn get_field_level_encryption_config(
        &self,
    ) -> fluent_builders::GetFieldLevelEncryptionConfig<C> {
        fluent_builders::GetFieldLevelEncryptionConfig::new(self.handle.clone())
    }
    pub fn get_field_level_encryption_profile(
        &self,
    ) -> fluent_builders::GetFieldLevelEncryptionProfile<C> {
        fluent_builders::GetFieldLevelEncryptionProfile::new(self.handle.clone())
    }
    pub fn get_field_level_encryption_profile_config(
        &self,
    ) -> fluent_builders::GetFieldLevelEncryptionProfileConfig<C> {
        fluent_builders::GetFieldLevelEncryptionProfileConfig::new(self.handle.clone())
    }
    pub fn get_function(&self) -> fluent_builders::GetFunction<C> {
        fluent_builders::GetFunction::new(self.handle.clone())
    }
    pub fn get_invalidation(&self) -> fluent_builders::GetInvalidation<C> {
        fluent_builders::GetInvalidation::new(self.handle.clone())
    }
    pub fn get_key_group(&self) -> fluent_builders::GetKeyGroup<C> {
        fluent_builders::GetKeyGroup::new(self.handle.clone())
    }
    pub fn get_key_group_config(&self) -> fluent_builders::GetKeyGroupConfig<C> {
        fluent_builders::GetKeyGroupConfig::new(self.handle.clone())
    }
    pub fn get_monitoring_subscription(&self) -> fluent_builders::GetMonitoringSubscription<C> {
        fluent_builders::GetMonitoringSubscription::new(self.handle.clone())
    }
    pub fn get_origin_request_policy(&self) -> fluent_builders::GetOriginRequestPolicy<C> {
        fluent_builders::GetOriginRequestPolicy::new(self.handle.clone())
    }
    pub fn get_origin_request_policy_config(
        &self,
    ) -> fluent_builders::GetOriginRequestPolicyConfig<C> {
        fluent_builders::GetOriginRequestPolicyConfig::new(self.handle.clone())
    }
    pub fn get_public_key(&self) -> fluent_builders::GetPublicKey<C> {
        fluent_builders::GetPublicKey::new(self.handle.clone())
    }
    pub fn get_public_key_config(&self) -> fluent_builders::GetPublicKeyConfig<C> {
        fluent_builders::GetPublicKeyConfig::new(self.handle.clone())
    }
    pub fn get_realtime_log_config(&self) -> fluent_builders::GetRealtimeLogConfig<C> {
        fluent_builders::GetRealtimeLogConfig::new(self.handle.clone())
    }
    pub fn get_streaming_distribution(&self) -> fluent_builders::GetStreamingDistribution<C> {
        fluent_builders::GetStreamingDistribution::new(self.handle.clone())
    }
    pub fn get_streaming_distribution_config(
        &self,
    ) -> fluent_builders::GetStreamingDistributionConfig<C> {
        fluent_builders::GetStreamingDistributionConfig::new(self.handle.clone())
    }
    pub fn list_cache_policies(&self) -> fluent_builders::ListCachePolicies<C> {
        fluent_builders::ListCachePolicies::new(self.handle.clone())
    }
    pub fn list_cloud_front_origin_access_identities(
        &self,
    ) -> fluent_builders::ListCloudFrontOriginAccessIdentities<C> {
        fluent_builders::ListCloudFrontOriginAccessIdentities::new(self.handle.clone())
    }
    pub fn list_distributions(&self) -> fluent_builders::ListDistributions<C> {
        fluent_builders::ListDistributions::new(self.handle.clone())
    }
    pub fn list_distributions_by_cache_policy_id(
        &self,
    ) -> fluent_builders::ListDistributionsByCachePolicyId<C> {
        fluent_builders::ListDistributionsByCachePolicyId::new(self.handle.clone())
    }
    pub fn list_distributions_by_key_group(
        &self,
    ) -> fluent_builders::ListDistributionsByKeyGroup<C> {
        fluent_builders::ListDistributionsByKeyGroup::new(self.handle.clone())
    }
    pub fn list_distributions_by_origin_request_policy_id(
        &self,
    ) -> fluent_builders::ListDistributionsByOriginRequestPolicyId<C> {
        fluent_builders::ListDistributionsByOriginRequestPolicyId::new(self.handle.clone())
    }
    pub fn list_distributions_by_realtime_log_config(
        &self,
    ) -> fluent_builders::ListDistributionsByRealtimeLogConfig<C> {
        fluent_builders::ListDistributionsByRealtimeLogConfig::new(self.handle.clone())
    }
    pub fn list_distributions_by_web_acl_id(
        &self,
    ) -> fluent_builders::ListDistributionsByWebACLId<C> {
        fluent_builders::ListDistributionsByWebACLId::new(self.handle.clone())
    }
    pub fn list_field_level_encryption_configs(
        &self,
    ) -> fluent_builders::ListFieldLevelEncryptionConfigs<C> {
        fluent_builders::ListFieldLevelEncryptionConfigs::new(self.handle.clone())
    }
    pub fn list_field_level_encryption_profiles(
        &self,
    ) -> fluent_builders::ListFieldLevelEncryptionProfiles<C> {
        fluent_builders::ListFieldLevelEncryptionProfiles::new(self.handle.clone())
    }
    pub fn list_functions(&self) -> fluent_builders::ListFunctions<C> {
        fluent_builders::ListFunctions::new(self.handle.clone())
    }
    pub fn list_invalidations(&self) -> fluent_builders::ListInvalidations<C> {
        fluent_builders::ListInvalidations::new(self.handle.clone())
    }
    pub fn list_key_groups(&self) -> fluent_builders::ListKeyGroups<C> {
        fluent_builders::ListKeyGroups::new(self.handle.clone())
    }
    pub fn list_origin_request_policies(&self) -> fluent_builders::ListOriginRequestPolicies<C> {
        fluent_builders::ListOriginRequestPolicies::new(self.handle.clone())
    }
    pub fn list_public_keys(&self) -> fluent_builders::ListPublicKeys<C> {
        fluent_builders::ListPublicKeys::new(self.handle.clone())
    }
    pub fn list_realtime_log_configs(&self) -> fluent_builders::ListRealtimeLogConfigs<C> {
        fluent_builders::ListRealtimeLogConfigs::new(self.handle.clone())
    }
    pub fn list_streaming_distributions(&self) -> fluent_builders::ListStreamingDistributions<C> {
        fluent_builders::ListStreamingDistributions::new(self.handle.clone())
    }
    pub fn list_tags_for_resource(&self) -> fluent_builders::ListTagsForResource<C> {
        fluent_builders::ListTagsForResource::new(self.handle.clone())
    }
    pub fn publish_function(&self) -> fluent_builders::PublishFunction<C> {
        fluent_builders::PublishFunction::new(self.handle.clone())
    }
    pub fn tag_resource(&self) -> fluent_builders::TagResource<C> {
        fluent_builders::TagResource::new(self.handle.clone())
    }
    pub fn test_function(&self) -> fluent_builders::TestFunction<C> {
        fluent_builders::TestFunction::new(self.handle.clone())
    }
    pub fn untag_resource(&self) -> fluent_builders::UntagResource<C> {
        fluent_builders::UntagResource::new(self.handle.clone())
    }
    pub fn update_cache_policy(&self) -> fluent_builders::UpdateCachePolicy<C> {
        fluent_builders::UpdateCachePolicy::new(self.handle.clone())
    }
    pub fn update_cloud_front_origin_access_identity(
        &self,
    ) -> fluent_builders::UpdateCloudFrontOriginAccessIdentity<C> {
        fluent_builders::UpdateCloudFrontOriginAccessIdentity::new(self.handle.clone())
    }
    pub fn update_distribution(&self) -> fluent_builders::UpdateDistribution<C> {
        fluent_builders::UpdateDistribution::new(self.handle.clone())
    }
    pub fn update_field_level_encryption_config(
        &self,
    ) -> fluent_builders::UpdateFieldLevelEncryptionConfig<C> {
        fluent_builders::UpdateFieldLevelEncryptionConfig::new(self.handle.clone())
    }
    pub fn update_field_level_encryption_profile(
        &self,
    ) -> fluent_builders::UpdateFieldLevelEncryptionProfile<C> {
        fluent_builders::UpdateFieldLevelEncryptionProfile::new(self.handle.clone())
    }
    pub fn update_function(&self) -> fluent_builders::UpdateFunction<C> {
        fluent_builders::UpdateFunction::new(self.handle.clone())
    }
    pub fn update_key_group(&self) -> fluent_builders::UpdateKeyGroup<C> {
        fluent_builders::UpdateKeyGroup::new(self.handle.clone())
    }
    pub fn update_origin_request_policy(&self) -> fluent_builders::UpdateOriginRequestPolicy<C> {
        fluent_builders::UpdateOriginRequestPolicy::new(self.handle.clone())
    }
    pub fn update_public_key(&self) -> fluent_builders::UpdatePublicKey<C> {
        fluent_builders::UpdatePublicKey::new(self.handle.clone())
    }
    pub fn update_realtime_log_config(&self) -> fluent_builders::UpdateRealtimeLogConfig<C> {
        fluent_builders::UpdateRealtimeLogConfig::new(self.handle.clone())
    }
    pub fn update_streaming_distribution(&self) -> fluent_builders::UpdateStreamingDistribution<C> {
        fluent_builders::UpdateStreamingDistribution::new(self.handle.clone())
    }
}
pub mod fluent_builders {
    #[derive(std::fmt::Debug)]
    pub struct CreateCachePolicy<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_cache_policy_input::Builder,
    }
    impl<C> CreateCachePolicy<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateCachePolicyOutput,
            smithy_http::result::SdkError<crate::error::CreateCachePolicyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A cache policy configuration.</p>
        pub fn cache_policy_config(mut self, input: crate::model::CachePolicyConfig) -> Self {
            self.inner = self.inner.cache_policy_config(input);
            self
        }
        pub fn set_cache_policy_config(
            mut self,
            input: std::option::Option<crate::model::CachePolicyConfig>,
        ) -> Self {
            self.inner = self.inner.set_cache_policy_config(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateCloudFrontOriginAccessIdentity<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_cloud_front_origin_access_identity_input::Builder,
    }
    impl<C> CreateCloudFrontOriginAccessIdentity<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateCloudFrontOriginAccessIdentityOutput,
            smithy_http::result::SdkError<crate::error::CreateCloudFrontOriginAccessIdentityError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The current configuration information for the identity.</p>
        pub fn cloud_front_origin_access_identity_config(
            mut self,
            input: crate::model::CloudFrontOriginAccessIdentityConfig,
        ) -> Self {
            self.inner = self.inner.cloud_front_origin_access_identity_config(input);
            self
        }
        pub fn set_cloud_front_origin_access_identity_config(
            mut self,
            input: std::option::Option<crate::model::CloudFrontOriginAccessIdentityConfig>,
        ) -> Self {
            self.inner = self
                .inner
                .set_cloud_front_origin_access_identity_config(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateDistribution<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_distribution_input::Builder,
    }
    impl<C> CreateDistribution<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateDistributionOutput,
            smithy_http::result::SdkError<crate::error::CreateDistributionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The distribution's configuration information.</p>
        pub fn distribution_config(mut self, input: crate::model::DistributionConfig) -> Self {
            self.inner = self.inner.distribution_config(input);
            self
        }
        pub fn set_distribution_config(
            mut self,
            input: std::option::Option<crate::model::DistributionConfig>,
        ) -> Self {
            self.inner = self.inner.set_distribution_config(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateDistributionWithTags<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_distribution_with_tags_input::Builder,
    }
    impl<C> CreateDistributionWithTags<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateDistributionWithTagsOutput,
            smithy_http::result::SdkError<crate::error::CreateDistributionWithTagsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The distribution's configuration information. </p>
        pub fn distribution_config_with_tags(
            mut self,
            input: crate::model::DistributionConfigWithTags,
        ) -> Self {
            self.inner = self.inner.distribution_config_with_tags(input);
            self
        }
        pub fn set_distribution_config_with_tags(
            mut self,
            input: std::option::Option<crate::model::DistributionConfigWithTags>,
        ) -> Self {
            self.inner = self.inner.set_distribution_config_with_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateFieldLevelEncryptionConfig<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_field_level_encryption_config_input::Builder,
    }
    impl<C> CreateFieldLevelEncryptionConfig<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateFieldLevelEncryptionConfigOutput,
            smithy_http::result::SdkError<crate::error::CreateFieldLevelEncryptionConfigError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The request to create a new field-level encryption configuration.</p>
        pub fn field_level_encryption_config(
            mut self,
            input: crate::model::FieldLevelEncryptionConfig,
        ) -> Self {
            self.inner = self.inner.field_level_encryption_config(input);
            self
        }
        pub fn set_field_level_encryption_config(
            mut self,
            input: std::option::Option<crate::model::FieldLevelEncryptionConfig>,
        ) -> Self {
            self.inner = self.inner.set_field_level_encryption_config(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateFieldLevelEncryptionProfile<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_field_level_encryption_profile_input::Builder,
    }
    impl<C> CreateFieldLevelEncryptionProfile<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateFieldLevelEncryptionProfileOutput,
            smithy_http::result::SdkError<crate::error::CreateFieldLevelEncryptionProfileError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The request to create a field-level encryption profile.</p>
        pub fn field_level_encryption_profile_config(
            mut self,
            input: crate::model::FieldLevelEncryptionProfileConfig,
        ) -> Self {
            self.inner = self.inner.field_level_encryption_profile_config(input);
            self
        }
        pub fn set_field_level_encryption_profile_config(
            mut self,
            input: std::option::Option<crate::model::FieldLevelEncryptionProfileConfig>,
        ) -> Self {
            self.inner = self.inner.set_field_level_encryption_profile_config(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateFunction<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_function_input::Builder,
    }
    impl<C> CreateFunction<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateFunctionOutput,
            smithy_http::result::SdkError<crate::error::CreateFunctionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A name to identify the function.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>Configuration information about the function, including an optional comment and the
        /// function’s runtime.</p>
        pub fn function_config(mut self, input: crate::model::FunctionConfig) -> Self {
            self.inner = self.inner.function_config(input);
            self
        }
        pub fn set_function_config(
            mut self,
            input: std::option::Option<crate::model::FunctionConfig>,
        ) -> Self {
            self.inner = self.inner.set_function_config(input);
            self
        }
        /// <p>The function code. For more information about writing a CloudFront function, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/writing-function-code.html">Writing function
        /// code for CloudFront Functions</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
        pub fn function_code(mut self, input: smithy_types::Blob) -> Self {
            self.inner = self.inner.function_code(input);
            self
        }
        pub fn set_function_code(mut self, input: std::option::Option<smithy_types::Blob>) -> Self {
            self.inner = self.inner.set_function_code(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateInvalidation<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_invalidation_input::Builder,
    }
    impl<C> CreateInvalidation<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateInvalidationOutput,
            smithy_http::result::SdkError<crate::error::CreateInvalidationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The distribution's id.</p>
        pub fn distribution_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.distribution_id(input);
            self
        }
        pub fn set_distribution_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_distribution_id(input);
            self
        }
        /// <p>The batch information for the invalidation.</p>
        pub fn invalidation_batch(mut self, input: crate::model::InvalidationBatch) -> Self {
            self.inner = self.inner.invalidation_batch(input);
            self
        }
        pub fn set_invalidation_batch(
            mut self,
            input: std::option::Option<crate::model::InvalidationBatch>,
        ) -> Self {
            self.inner = self.inner.set_invalidation_batch(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateKeyGroup<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_key_group_input::Builder,
    }
    impl<C> CreateKeyGroup<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateKeyGroupOutput,
            smithy_http::result::SdkError<crate::error::CreateKeyGroupError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A key group configuration.</p>
        pub fn key_group_config(mut self, input: crate::model::KeyGroupConfig) -> Self {
            self.inner = self.inner.key_group_config(input);
            self
        }
        pub fn set_key_group_config(
            mut self,
            input: std::option::Option<crate::model::KeyGroupConfig>,
        ) -> Self {
            self.inner = self.inner.set_key_group_config(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateMonitoringSubscription<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_monitoring_subscription_input::Builder,
    }
    impl<C> CreateMonitoringSubscription<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateMonitoringSubscriptionOutput,
            smithy_http::result::SdkError<crate::error::CreateMonitoringSubscriptionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the distribution that you are enabling metrics for.</p>
        pub fn distribution_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.distribution_id(input);
            self
        }
        pub fn set_distribution_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_distribution_id(input);
            self
        }
        /// <p>A monitoring subscription. This structure contains information about whether additional
        /// CloudWatch metrics are enabled for a given CloudFront distribution.</p>
        pub fn monitoring_subscription(
            mut self,
            input: crate::model::MonitoringSubscription,
        ) -> Self {
            self.inner = self.inner.monitoring_subscription(input);
            self
        }
        pub fn set_monitoring_subscription(
            mut self,
            input: std::option::Option<crate::model::MonitoringSubscription>,
        ) -> Self {
            self.inner = self.inner.set_monitoring_subscription(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateOriginRequestPolicy<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_origin_request_policy_input::Builder,
    }
    impl<C> CreateOriginRequestPolicy<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateOriginRequestPolicyOutput,
            smithy_http::result::SdkError<crate::error::CreateOriginRequestPolicyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>An origin request policy configuration.</p>
        pub fn origin_request_policy_config(
            mut self,
            input: crate::model::OriginRequestPolicyConfig,
        ) -> Self {
            self.inner = self.inner.origin_request_policy_config(input);
            self
        }
        pub fn set_origin_request_policy_config(
            mut self,
            input: std::option::Option<crate::model::OriginRequestPolicyConfig>,
        ) -> Self {
            self.inner = self.inner.set_origin_request_policy_config(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreatePublicKey<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_public_key_input::Builder,
    }
    impl<C> CreatePublicKey<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreatePublicKeyOutput,
            smithy_http::result::SdkError<crate::error::CreatePublicKeyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A CloudFront public key configuration.</p>
        pub fn public_key_config(mut self, input: crate::model::PublicKeyConfig) -> Self {
            self.inner = self.inner.public_key_config(input);
            self
        }
        pub fn set_public_key_config(
            mut self,
            input: std::option::Option<crate::model::PublicKeyConfig>,
        ) -> Self {
            self.inner = self.inner.set_public_key_config(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateRealtimeLogConfig<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_realtime_log_config_input::Builder,
    }
    impl<C> CreateRealtimeLogConfig<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateRealtimeLogConfigOutput,
            smithy_http::result::SdkError<crate::error::CreateRealtimeLogConfigError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Contains information about the Amazon Kinesis data stream where you are sending real-time
        /// log data.</p>
        pub fn end_points(mut self, inp: impl Into<crate::model::EndPoint>) -> Self {
            self.inner = self.inner.end_points(inp);
            self
        }
        pub fn set_end_points(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::EndPoint>>,
        ) -> Self {
            self.inner = self.inner.set_end_points(input);
            self
        }
        /// <p>A list of fields to include in each real-time log record.</p>
        /// <p>For more information about fields, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/real-time-logs.html#understand-real-time-log-config-fields">Real-time log configuration fields</a> in the
        /// <i>Amazon CloudFront Developer Guide</i>.</p>
        pub fn fields(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.fields(inp);
            self
        }
        pub fn set_fields(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_fields(input);
            self
        }
        /// <p>A unique name to identify this real-time log configuration.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>The sampling rate for this real-time log configuration. The sampling rate determines the
        /// percentage of viewer requests that are represented in the real-time log data. You must
        /// provide an integer between 1 and 100, inclusive.</p>
        pub fn sampling_rate(mut self, input: i64) -> Self {
            self.inner = self.inner.sampling_rate(input);
            self
        }
        pub fn set_sampling_rate(mut self, input: std::option::Option<i64>) -> Self {
            self.inner = self.inner.set_sampling_rate(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateStreamingDistribution<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_streaming_distribution_input::Builder,
    }
    impl<C> CreateStreamingDistribution<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateStreamingDistributionOutput,
            smithy_http::result::SdkError<crate::error::CreateStreamingDistributionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The streaming distribution's configuration information.</p>
        pub fn streaming_distribution_config(
            mut self,
            input: crate::model::StreamingDistributionConfig,
        ) -> Self {
            self.inner = self.inner.streaming_distribution_config(input);
            self
        }
        pub fn set_streaming_distribution_config(
            mut self,
            input: std::option::Option<crate::model::StreamingDistributionConfig>,
        ) -> Self {
            self.inner = self.inner.set_streaming_distribution_config(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateStreamingDistributionWithTags<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_streaming_distribution_with_tags_input::Builder,
    }
    impl<C> CreateStreamingDistributionWithTags<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateStreamingDistributionWithTagsOutput,
            smithy_http::result::SdkError<crate::error::CreateStreamingDistributionWithTagsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p> The streaming distribution's configuration information. </p>
        pub fn streaming_distribution_config_with_tags(
            mut self,
            input: crate::model::StreamingDistributionConfigWithTags,
        ) -> Self {
            self.inner = self.inner.streaming_distribution_config_with_tags(input);
            self
        }
        pub fn set_streaming_distribution_config_with_tags(
            mut self,
            input: std::option::Option<crate::model::StreamingDistributionConfigWithTags>,
        ) -> Self {
            self.inner = self
                .inner
                .set_streaming_distribution_config_with_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteCachePolicy<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_cache_policy_input::Builder,
    }
    impl<C> DeleteCachePolicy<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteCachePolicyOutput,
            smithy_http::result::SdkError<crate::error::DeleteCachePolicyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The unique identifier for the cache policy that you are deleting. To get the
        /// identifier, you can use <code>ListCachePolicies</code>.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(input);
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(input);
            self
        }
        /// <p>The version of the cache policy that you are deleting. The version is the cache
        /// policy’s <code>ETag</code> value, which you can get using
        /// <code>ListCachePolicies</code>, <code>GetCachePolicy</code>, or
        /// <code>GetCachePolicyConfig</code>.</p>
        pub fn if_match(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.if_match(input);
            self
        }
        pub fn set_if_match(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_if_match(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteCloudFrontOriginAccessIdentity<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_cloud_front_origin_access_identity_input::Builder,
    }
    impl<C> DeleteCloudFrontOriginAccessIdentity<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteCloudFrontOriginAccessIdentityOutput,
            smithy_http::result::SdkError<crate::error::DeleteCloudFrontOriginAccessIdentityError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The origin access identity's ID.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(input);
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(input);
            self
        }
        /// <p>The value of the <code>ETag</code> header you received from a previous <code>GET</code>
        /// or <code>PUT</code> request. For example: <code>E2QWRUHAPOMQZL</code>.</p>
        pub fn if_match(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.if_match(input);
            self
        }
        pub fn set_if_match(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_if_match(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteDistribution<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_distribution_input::Builder,
    }
    impl<C> DeleteDistribution<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteDistributionOutput,
            smithy_http::result::SdkError<crate::error::DeleteDistributionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The distribution ID. </p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(input);
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(input);
            self
        }
        /// <p>The value of the <code>ETag</code> header that you received when you disabled the
        /// distribution. For example: <code>E2QWRUHAPOMQZL</code>. </p>
        pub fn if_match(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.if_match(input);
            self
        }
        pub fn set_if_match(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_if_match(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteFieldLevelEncryptionConfig<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_field_level_encryption_config_input::Builder,
    }
    impl<C> DeleteFieldLevelEncryptionConfig<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteFieldLevelEncryptionConfigOutput,
            smithy_http::result::SdkError<crate::error::DeleteFieldLevelEncryptionConfigError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the configuration you want to delete from CloudFront.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(input);
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(input);
            self
        }
        /// <p>The value of the <code>ETag</code> header that you received when retrieving the
        /// configuration identity to delete. For example: <code>E2QWRUHAPOMQZL</code>.</p>
        pub fn if_match(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.if_match(input);
            self
        }
        pub fn set_if_match(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_if_match(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteFieldLevelEncryptionProfile<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_field_level_encryption_profile_input::Builder,
    }
    impl<C> DeleteFieldLevelEncryptionProfile<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteFieldLevelEncryptionProfileOutput,
            smithy_http::result::SdkError<crate::error::DeleteFieldLevelEncryptionProfileError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Request the ID of the profile you want to delete from CloudFront.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(input);
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(input);
            self
        }
        /// <p>The value of the <code>ETag</code> header that you received when retrieving the
        /// profile to delete. For example: <code>E2QWRUHAPOMQZL</code>.</p>
        pub fn if_match(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.if_match(input);
            self
        }
        pub fn set_if_match(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_if_match(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteFunction<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_function_input::Builder,
    }
    impl<C> DeleteFunction<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteFunctionOutput,
            smithy_http::result::SdkError<crate::error::DeleteFunctionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the function that you are deleting.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>The current version (<code>ETag</code> value) of the function that you are deleting, which
        /// you can get using <code>DescribeFunction</code>.</p>
        pub fn if_match(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.if_match(input);
            self
        }
        pub fn set_if_match(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_if_match(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteKeyGroup<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_key_group_input::Builder,
    }
    impl<C> DeleteKeyGroup<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteKeyGroupOutput,
            smithy_http::result::SdkError<crate::error::DeleteKeyGroupError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identifier of the key group that you are deleting. To get the identifier, use
        /// <code>ListKeyGroups</code>.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(input);
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(input);
            self
        }
        /// <p>The version of the key group that you are deleting. The version is the key group’s
        /// <code>ETag</code> value. To get the <code>ETag</code>, use <code>GetKeyGroup</code> or
        /// <code>GetKeyGroupConfig</code>.</p>
        pub fn if_match(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.if_match(input);
            self
        }
        pub fn set_if_match(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_if_match(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteMonitoringSubscription<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_monitoring_subscription_input::Builder,
    }
    impl<C> DeleteMonitoringSubscription<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteMonitoringSubscriptionOutput,
            smithy_http::result::SdkError<crate::error::DeleteMonitoringSubscriptionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the distribution that you are disabling metrics for.</p>
        pub fn distribution_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.distribution_id(input);
            self
        }
        pub fn set_distribution_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_distribution_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteOriginRequestPolicy<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_origin_request_policy_input::Builder,
    }
    impl<C> DeleteOriginRequestPolicy<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteOriginRequestPolicyOutput,
            smithy_http::result::SdkError<crate::error::DeleteOriginRequestPolicyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The unique identifier for the origin request policy that you are deleting. To get the
        /// identifier, you can use <code>ListOriginRequestPolicies</code>.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(input);
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(input);
            self
        }
        /// <p>The version of the origin request policy that you are deleting. The version is the origin
        /// request policy’s <code>ETag</code> value, which you can get using
        /// <code>ListOriginRequestPolicies</code>, <code>GetOriginRequestPolicy</code>, or
        /// <code>GetOriginRequestPolicyConfig</code>.</p>
        pub fn if_match(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.if_match(input);
            self
        }
        pub fn set_if_match(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_if_match(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeletePublicKey<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_public_key_input::Builder,
    }
    impl<C> DeletePublicKey<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeletePublicKeyOutput,
            smithy_http::result::SdkError<crate::error::DeletePublicKeyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the public key you want to remove from CloudFront.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(input);
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(input);
            self
        }
        /// <p>The value of the <code>ETag</code> header that you received when retrieving the
        /// public key identity to delete. For example: <code>E2QWRUHAPOMQZL</code>.</p>
        pub fn if_match(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.if_match(input);
            self
        }
        pub fn set_if_match(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_if_match(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteRealtimeLogConfig<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_realtime_log_config_input::Builder,
    }
    impl<C> DeleteRealtimeLogConfig<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteRealtimeLogConfigOutput,
            smithy_http::result::SdkError<crate::error::DeleteRealtimeLogConfigError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the real-time log configuration to delete.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the real-time log configuration to delete.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.arn(input);
            self
        }
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteStreamingDistribution<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_streaming_distribution_input::Builder,
    }
    impl<C> DeleteStreamingDistribution<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteStreamingDistributionOutput,
            smithy_http::result::SdkError<crate::error::DeleteStreamingDistributionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The distribution ID. </p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(input);
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(input);
            self
        }
        /// <p>The value of the <code>ETag</code> header that you received when you disabled the
        /// streaming distribution. For example: <code>E2QWRUHAPOMQZL</code>.</p>
        pub fn if_match(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.if_match(input);
            self
        }
        pub fn set_if_match(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_if_match(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeFunction<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_function_input::Builder,
    }
    impl<C> DescribeFunction<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeFunctionOutput,
            smithy_http::result::SdkError<crate::error::DescribeFunctionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the function that you are getting information about.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>The function’s stage, either <code>DEVELOPMENT</code> or <code>LIVE</code>.</p>
        pub fn stage(mut self, input: crate::model::FunctionStage) -> Self {
            self.inner = self.inner.stage(input);
            self
        }
        pub fn set_stage(
            mut self,
            input: std::option::Option<crate::model::FunctionStage>,
        ) -> Self {
            self.inner = self.inner.set_stage(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetCachePolicy<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_cache_policy_input::Builder,
    }
    impl<C> GetCachePolicy<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetCachePolicyOutput,
            smithy_http::result::SdkError<crate::error::GetCachePolicyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The unique identifier for the cache policy. If the cache policy is attached to a
        /// distribution’s cache behavior, you can get the policy’s identifier using
        /// <code>ListDistributions</code> or <code>GetDistribution</code>. If the cache policy is
        /// not attached to a cache behavior, you can get the identifier using
        /// <code>ListCachePolicies</code>.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(input);
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetCachePolicyConfig<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_cache_policy_config_input::Builder,
    }
    impl<C> GetCachePolicyConfig<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetCachePolicyConfigOutput,
            smithy_http::result::SdkError<crate::error::GetCachePolicyConfigError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The unique identifier for the cache policy. If the cache policy is attached to a
        /// distribution’s cache behavior, you can get the policy’s identifier using
        /// <code>ListDistributions</code> or <code>GetDistribution</code>. If the cache policy is
        /// not attached to a cache behavior, you can get the identifier using
        /// <code>ListCachePolicies</code>.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(input);
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetCloudFrontOriginAccessIdentity<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_cloud_front_origin_access_identity_input::Builder,
    }
    impl<C> GetCloudFrontOriginAccessIdentity<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetCloudFrontOriginAccessIdentityOutput,
            smithy_http::result::SdkError<crate::error::GetCloudFrontOriginAccessIdentityError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identity's ID.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(input);
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetCloudFrontOriginAccessIdentityConfig<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_cloud_front_origin_access_identity_config_input::Builder,
    }
    impl<C> GetCloudFrontOriginAccessIdentityConfig<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetCloudFrontOriginAccessIdentityConfigOutput,
            smithy_http::result::SdkError<
                crate::error::GetCloudFrontOriginAccessIdentityConfigError,
            >,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identity's ID. </p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(input);
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetDistribution<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_distribution_input::Builder,
    }
    impl<C> GetDistribution<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetDistributionOutput,
            smithy_http::result::SdkError<crate::error::GetDistributionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The distribution's ID. If the ID is empty, an empty distribution configuration is returned.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(input);
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetDistributionConfig<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_distribution_config_input::Builder,
    }
    impl<C> GetDistributionConfig<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetDistributionConfigOutput,
            smithy_http::result::SdkError<crate::error::GetDistributionConfigError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The distribution's ID. If the ID is empty, an empty distribution configuration is returned.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(input);
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetFieldLevelEncryption<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_field_level_encryption_input::Builder,
    }
    impl<C> GetFieldLevelEncryption<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetFieldLevelEncryptionOutput,
            smithy_http::result::SdkError<crate::error::GetFieldLevelEncryptionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Request the ID for the field-level encryption configuration information.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(input);
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetFieldLevelEncryptionConfig<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_field_level_encryption_config_input::Builder,
    }
    impl<C> GetFieldLevelEncryptionConfig<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetFieldLevelEncryptionConfigOutput,
            smithy_http::result::SdkError<crate::error::GetFieldLevelEncryptionConfigError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Request the ID for the field-level encryption configuration information.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(input);
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetFieldLevelEncryptionProfile<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_field_level_encryption_profile_input::Builder,
    }
    impl<C> GetFieldLevelEncryptionProfile<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetFieldLevelEncryptionProfileOutput,
            smithy_http::result::SdkError<crate::error::GetFieldLevelEncryptionProfileError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Get the ID for the field-level encryption profile information.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(input);
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetFieldLevelEncryptionProfileConfig<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_field_level_encryption_profile_config_input::Builder,
    }
    impl<C> GetFieldLevelEncryptionProfileConfig<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetFieldLevelEncryptionProfileConfigOutput,
            smithy_http::result::SdkError<crate::error::GetFieldLevelEncryptionProfileConfigError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Get the ID for the field-level encryption profile configuration information.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(input);
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetFunction<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_function_input::Builder,
    }
    impl<C> GetFunction<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetFunctionOutput,
            smithy_http::result::SdkError<crate::error::GetFunctionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the function whose code you are getting.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>The function’s stage, either <code>DEVELOPMENT</code> or <code>LIVE</code>.</p>
        pub fn stage(mut self, input: crate::model::FunctionStage) -> Self {
            self.inner = self.inner.stage(input);
            self
        }
        pub fn set_stage(
            mut self,
            input: std::option::Option<crate::model::FunctionStage>,
        ) -> Self {
            self.inner = self.inner.set_stage(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetInvalidation<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_invalidation_input::Builder,
    }
    impl<C> GetInvalidation<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetInvalidationOutput,
            smithy_http::result::SdkError<crate::error::GetInvalidationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The distribution's ID.</p>
        pub fn distribution_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.distribution_id(input);
            self
        }
        pub fn set_distribution_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_distribution_id(input);
            self
        }
        /// <p>The identifier for the invalidation request, for example,
        /// <code>IDFDVBD632BHDS5</code>.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(input);
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetKeyGroup<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_key_group_input::Builder,
    }
    impl<C> GetKeyGroup<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetKeyGroupOutput,
            smithy_http::result::SdkError<crate::error::GetKeyGroupError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identifier of the key group that you are getting. To get the identifier, use
        /// <code>ListKeyGroups</code>.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(input);
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetKeyGroupConfig<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_key_group_config_input::Builder,
    }
    impl<C> GetKeyGroupConfig<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetKeyGroupConfigOutput,
            smithy_http::result::SdkError<crate::error::GetKeyGroupConfigError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identifier of the key group whose configuration you are getting. To get the
        /// identifier, use <code>ListKeyGroups</code>.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(input);
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetMonitoringSubscription<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_monitoring_subscription_input::Builder,
    }
    impl<C> GetMonitoringSubscription<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetMonitoringSubscriptionOutput,
            smithy_http::result::SdkError<crate::error::GetMonitoringSubscriptionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the distribution that you are getting metrics information for.</p>
        pub fn distribution_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.distribution_id(input);
            self
        }
        pub fn set_distribution_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_distribution_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetOriginRequestPolicy<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_origin_request_policy_input::Builder,
    }
    impl<C> GetOriginRequestPolicy<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetOriginRequestPolicyOutput,
            smithy_http::result::SdkError<crate::error::GetOriginRequestPolicyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The unique identifier for the origin request policy. If the origin request policy is
        /// attached to a distribution’s cache behavior, you can get the policy’s identifier using
        /// <code>ListDistributions</code> or <code>GetDistribution</code>. If the origin request
        /// policy is not attached to a cache behavior, you can get the identifier using
        /// <code>ListOriginRequestPolicies</code>.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(input);
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetOriginRequestPolicyConfig<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_origin_request_policy_config_input::Builder,
    }
    impl<C> GetOriginRequestPolicyConfig<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetOriginRequestPolicyConfigOutput,
            smithy_http::result::SdkError<crate::error::GetOriginRequestPolicyConfigError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The unique identifier for the origin request policy. If the origin request policy is
        /// attached to a distribution’s cache behavior, you can get the policy’s identifier using
        /// <code>ListDistributions</code> or <code>GetDistribution</code>. If the origin request
        /// policy is not attached to a cache behavior, you can get the identifier using
        /// <code>ListOriginRequestPolicies</code>.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(input);
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetPublicKey<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_public_key_input::Builder,
    }
    impl<C> GetPublicKey<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetPublicKeyOutput,
            smithy_http::result::SdkError<crate::error::GetPublicKeyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identifier of the public key you are getting.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(input);
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetPublicKeyConfig<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_public_key_config_input::Builder,
    }
    impl<C> GetPublicKeyConfig<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetPublicKeyConfigOutput,
            smithy_http::result::SdkError<crate::error::GetPublicKeyConfigError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identifier of the public key whose configuration you are getting.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(input);
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetRealtimeLogConfig<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_realtime_log_config_input::Builder,
    }
    impl<C> GetRealtimeLogConfig<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetRealtimeLogConfigOutput,
            smithy_http::result::SdkError<crate::error::GetRealtimeLogConfigError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the real-time log configuration to get.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the real-time log configuration to get.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.arn(input);
            self
        }
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetStreamingDistribution<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_streaming_distribution_input::Builder,
    }
    impl<C> GetStreamingDistribution<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetStreamingDistributionOutput,
            smithy_http::result::SdkError<crate::error::GetStreamingDistributionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The streaming distribution's ID.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(input);
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetStreamingDistributionConfig<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_streaming_distribution_config_input::Builder,
    }
    impl<C> GetStreamingDistributionConfig<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetStreamingDistributionConfigOutput,
            smithy_http::result::SdkError<crate::error::GetStreamingDistributionConfigError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The streaming distribution's ID.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(input);
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListCachePolicies<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_cache_policies_input::Builder,
    }
    impl<C> ListCachePolicies<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListCachePoliciesOutput,
            smithy_http::result::SdkError<crate::error::ListCachePoliciesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A filter to return only the specified kinds of cache policies. Valid values
        /// are:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>managed</code> – Returns only the managed policies created by AWS.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>custom</code> – Returns only the custom policies created in your AWS
        /// account.</p>
        /// </li>
        /// </ul>
        pub fn r#type(mut self, input: crate::model::CachePolicyType) -> Self {
            self.inner = self.inner.r#type(input);
            self
        }
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::CachePolicyType>,
        ) -> Self {
            self.inner = self.inner.set_type(input);
            self
        }
        /// <p>Use this field when paginating results to indicate where to begin in your list of
        /// cache policies. The response includes cache policies in the list that occur after the
        /// marker. To get the next page of the list, set this field’s value to the value of
        /// <code>NextMarker</code> from the current page’s response.</p>
        pub fn marker(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(input);
            self
        }
        pub fn set_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(input);
            self
        }
        /// <p>The maximum number of cache policies that you want in the response.</p>
        pub fn max_items(mut self, input: i32) -> Self {
            self.inner = self.inner.max_items(input);
            self
        }
        pub fn set_max_items(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_items(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListCloudFrontOriginAccessIdentities<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_cloud_front_origin_access_identities_input::Builder,
    }
    impl<C> ListCloudFrontOriginAccessIdentities<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListCloudFrontOriginAccessIdentitiesOutput,
            smithy_http::result::SdkError<crate::error::ListCloudFrontOriginAccessIdentitiesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Use this when paginating results to indicate where to begin in your list of origin
        /// access identities. The results include identities in the list that occur after the marker. To
        /// get the next page of results, set the <code>Marker</code> to the value of the
        /// <code>NextMarker</code> from the current page's response (which is also the ID of the last
        /// identity on that page).</p>
        pub fn marker(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(input);
            self
        }
        pub fn set_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(input);
            self
        }
        /// <p>The maximum number of origin access identities you want in the response body.
        /// </p>
        pub fn max_items(mut self, input: i32) -> Self {
            self.inner = self.inner.max_items(input);
            self
        }
        pub fn set_max_items(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_items(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListDistributions<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_distributions_input::Builder,
    }
    impl<C> ListDistributions<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListDistributionsOutput,
            smithy_http::result::SdkError<crate::error::ListDistributionsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Use this when paginating results to indicate where to begin in your list of
        /// distributions. The results include distributions in the list that occur after the marker. To
        /// get the next page of results, set the <code>Marker</code> to the value of the
        /// <code>NextMarker</code> from the current page's response (which is also the ID of the last
        /// distribution on that page).</p>
        pub fn marker(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(input);
            self
        }
        pub fn set_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(input);
            self
        }
        /// <p>The maximum number of distributions you want in the response body.</p>
        pub fn max_items(mut self, input: i32) -> Self {
            self.inner = self.inner.max_items(input);
            self
        }
        pub fn set_max_items(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_items(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListDistributionsByCachePolicyId<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_distributions_by_cache_policy_id_input::Builder,
    }
    impl<C> ListDistributionsByCachePolicyId<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListDistributionsByCachePolicyIdOutput,
            smithy_http::result::SdkError<crate::error::ListDistributionsByCachePolicyIdError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Use this field when paginating results to indicate where to begin in your list of
        /// distribution IDs. The response includes distribution IDs in the list that occur after
        /// the marker. To get the next page of the list, set this field’s value to the value of
        /// <code>NextMarker</code> from the current page’s response.</p>
        pub fn marker(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(input);
            self
        }
        pub fn set_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(input);
            self
        }
        /// <p>The maximum number of distribution IDs that you want in the response.</p>
        pub fn max_items(mut self, input: i32) -> Self {
            self.inner = self.inner.max_items(input);
            self
        }
        pub fn set_max_items(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_items(input);
            self
        }
        /// <p>The ID of the cache policy whose associated distribution IDs you want to list.</p>
        pub fn cache_policy_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cache_policy_id(input);
            self
        }
        pub fn set_cache_policy_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_cache_policy_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListDistributionsByKeyGroup<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_distributions_by_key_group_input::Builder,
    }
    impl<C> ListDistributionsByKeyGroup<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListDistributionsByKeyGroupOutput,
            smithy_http::result::SdkError<crate::error::ListDistributionsByKeyGroupError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Use this field when paginating results to indicate where to begin in your list of
        /// distribution IDs. The response includes distribution IDs in the list that occur after
        /// the marker. To get the next page of the list, set this field’s value to the value of
        /// <code>NextMarker</code> from the current page’s response.</p>
        pub fn marker(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(input);
            self
        }
        pub fn set_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(input);
            self
        }
        /// <p>The maximum number of distribution IDs that you want in the response.</p>
        pub fn max_items(mut self, input: i32) -> Self {
            self.inner = self.inner.max_items(input);
            self
        }
        pub fn set_max_items(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_items(input);
            self
        }
        /// <p>The ID of the key group whose associated distribution IDs you are listing.</p>
        pub fn key_group_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.key_group_id(input);
            self
        }
        pub fn set_key_group_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_key_group_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListDistributionsByOriginRequestPolicyId<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_distributions_by_origin_request_policy_id_input::Builder,
    }
    impl<C> ListDistributionsByOriginRequestPolicyId<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListDistributionsByOriginRequestPolicyIdOutput,
            smithy_http::result::SdkError<
                crate::error::ListDistributionsByOriginRequestPolicyIdError,
            >,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Use this field when paginating results to indicate where to begin in your list of
        /// distribution IDs. The response includes distribution IDs in the list that occur after
        /// the marker. To get the next page of the list, set this field’s value to the value of
        /// <code>NextMarker</code> from the current page’s response.</p>
        pub fn marker(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(input);
            self
        }
        pub fn set_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(input);
            self
        }
        /// <p>The maximum number of distribution IDs that you want in the response.</p>
        pub fn max_items(mut self, input: i32) -> Self {
            self.inner = self.inner.max_items(input);
            self
        }
        pub fn set_max_items(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_items(input);
            self
        }
        /// <p>The ID of the origin request policy whose associated distribution IDs you want to
        /// list.</p>
        pub fn origin_request_policy_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.origin_request_policy_id(input);
            self
        }
        pub fn set_origin_request_policy_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_origin_request_policy_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListDistributionsByRealtimeLogConfig<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_distributions_by_realtime_log_config_input::Builder,
    }
    impl<C> ListDistributionsByRealtimeLogConfig<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListDistributionsByRealtimeLogConfigOutput,
            smithy_http::result::SdkError<crate::error::ListDistributionsByRealtimeLogConfigError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Use this field when paginating results to indicate where to begin in your list of
        /// distributions. The response includes distributions in the list that occur after the
        /// marker. To get the next page of the list, set this field’s value to the value of
        /// <code>NextMarker</code> from the current page’s response.</p>
        pub fn marker(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(input);
            self
        }
        pub fn set_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(input);
            self
        }
        /// <p>The maximum number of distributions that you want in the response.</p>
        pub fn max_items(mut self, input: i32) -> Self {
            self.inner = self.inner.max_items(input);
            self
        }
        pub fn set_max_items(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_items(input);
            self
        }
        /// <p>The name of the real-time log configuration whose associated distributions you want to
        /// list.</p>
        pub fn realtime_log_config_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.realtime_log_config_name(input);
            self
        }
        pub fn set_realtime_log_config_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_realtime_log_config_name(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the real-time log configuration whose associated
        /// distributions you want to list.</p>
        pub fn realtime_log_config_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.realtime_log_config_arn(input);
            self
        }
        pub fn set_realtime_log_config_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_realtime_log_config_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListDistributionsByWebACLId<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_distributions_by_web_acl_id_input::Builder,
    }
    impl<C> ListDistributionsByWebACLId<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListDistributionsByWebAclIdOutput,
            smithy_http::result::SdkError<crate::error::ListDistributionsByWebACLIdError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Use <code>Marker</code> and <code>MaxItems</code> to control pagination of results. If
        /// you have more than <code>MaxItems</code> distributions that satisfy the request, the response
        /// includes a <code>NextMarker</code> element. To get the next page of results, submit another
        /// request. For the value of <code>Marker</code>, specify the value of <code>NextMarker</code>
        /// from the last response. (For the first request, omit <code>Marker</code>.) </p>
        pub fn marker(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(input);
            self
        }
        pub fn set_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(input);
            self
        }
        /// <p>The maximum number of distributions that you want CloudFront to return in the response body.
        /// The maximum and default values are both 100.</p>
        pub fn max_items(mut self, input: i32) -> Self {
            self.inner = self.inner.max_items(input);
            self
        }
        pub fn set_max_items(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_items(input);
            self
        }
        /// <p>The ID of the AWS WAF web ACL that you want to list the associated distributions.
        /// If you specify "null" for the ID, the request returns a list of the distributions that aren't
        /// associated with a web ACL. </p>
        pub fn web_acl_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.web_acl_id(input);
            self
        }
        pub fn set_web_acl_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_web_acl_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListFieldLevelEncryptionConfigs<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_field_level_encryption_configs_input::Builder,
    }
    impl<C> ListFieldLevelEncryptionConfigs<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListFieldLevelEncryptionConfigsOutput,
            smithy_http::result::SdkError<crate::error::ListFieldLevelEncryptionConfigsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Use this when paginating results to indicate where to begin in your list of configurations. The results include configurations in the list that
        /// occur after the marker. To get the next page of results, set the <code>Marker</code> to the value of the
        /// <code>NextMarker</code> from the current page's response (which is also the ID of the last configuration on that page). </p>
        pub fn marker(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(input);
            self
        }
        pub fn set_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(input);
            self
        }
        /// <p>The maximum number of field-level encryption configurations you want in the response body. </p>
        pub fn max_items(mut self, input: i32) -> Self {
            self.inner = self.inner.max_items(input);
            self
        }
        pub fn set_max_items(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_items(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListFieldLevelEncryptionProfiles<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_field_level_encryption_profiles_input::Builder,
    }
    impl<C> ListFieldLevelEncryptionProfiles<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListFieldLevelEncryptionProfilesOutput,
            smithy_http::result::SdkError<crate::error::ListFieldLevelEncryptionProfilesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Use this when paginating results to indicate where to begin in your list of profiles. The results include profiles in the list that
        /// occur after the marker. To get the next page of results, set the <code>Marker</code> to the value of the
        /// <code>NextMarker</code> from the current page's response (which is also the ID of the last profile on that page). </p>
        pub fn marker(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(input);
            self
        }
        pub fn set_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(input);
            self
        }
        /// <p>The maximum number of field-level encryption profiles you want in the response body. </p>
        pub fn max_items(mut self, input: i32) -> Self {
            self.inner = self.inner.max_items(input);
            self
        }
        pub fn set_max_items(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_items(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListFunctions<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_functions_input::Builder,
    }
    impl<C> ListFunctions<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListFunctionsOutput,
            smithy_http::result::SdkError<crate::error::ListFunctionsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Use this field when paginating results to indicate where to begin in your list of
        /// functions. The response includes functions in the list that occur after the marker. To
        /// get the next page of the list, set this field’s value to the value of
        /// <code>NextMarker</code> from the current page’s response.</p>
        pub fn marker(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(input);
            self
        }
        pub fn set_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(input);
            self
        }
        /// <p>The maximum number of functions that you want in the response.</p>
        pub fn max_items(mut self, input: i32) -> Self {
            self.inner = self.inner.max_items(input);
            self
        }
        pub fn set_max_items(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_items(input);
            self
        }
        /// <p>An optional filter to return only the functions that are in the specified stage,
        /// either <code>DEVELOPMENT</code> or <code>LIVE</code>.</p>
        pub fn stage(mut self, input: crate::model::FunctionStage) -> Self {
            self.inner = self.inner.stage(input);
            self
        }
        pub fn set_stage(
            mut self,
            input: std::option::Option<crate::model::FunctionStage>,
        ) -> Self {
            self.inner = self.inner.set_stage(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListInvalidations<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_invalidations_input::Builder,
    }
    impl<C> ListInvalidations<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListInvalidationsOutput,
            smithy_http::result::SdkError<crate::error::ListInvalidationsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The distribution's ID.</p>
        pub fn distribution_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.distribution_id(input);
            self
        }
        pub fn set_distribution_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_distribution_id(input);
            self
        }
        /// <p>Use this parameter when paginating results to indicate where to begin in your list of
        /// invalidation batches. Because the results are returned in decreasing order from most recent to
        /// oldest, the most recent results are on the first page, the second page will contain earlier
        /// results, and so on. To get the next page of results, set <code>Marker</code> to the value of
        /// the <code>NextMarker</code> from the current page's response. This value is the same as the ID
        /// of the last invalidation batch on that page. </p>
        pub fn marker(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(input);
            self
        }
        pub fn set_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(input);
            self
        }
        /// <p>The maximum number of invalidation batches that you want in the response
        /// body.</p>
        pub fn max_items(mut self, input: i32) -> Self {
            self.inner = self.inner.max_items(input);
            self
        }
        pub fn set_max_items(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_items(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListKeyGroups<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_key_groups_input::Builder,
    }
    impl<C> ListKeyGroups<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListKeyGroupsOutput,
            smithy_http::result::SdkError<crate::error::ListKeyGroupsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Use this field when paginating results to indicate where to begin in your list of key
        /// groups. The response includes key groups in the list that occur after the marker. To get
        /// the next page of the list, set this field’s value to the value of
        /// <code>NextMarker</code> from the current page’s response.</p>
        pub fn marker(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(input);
            self
        }
        pub fn set_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(input);
            self
        }
        /// <p>The maximum number of key groups that you want in the response.</p>
        pub fn max_items(mut self, input: i32) -> Self {
            self.inner = self.inner.max_items(input);
            self
        }
        pub fn set_max_items(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_items(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListOriginRequestPolicies<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_origin_request_policies_input::Builder,
    }
    impl<C> ListOriginRequestPolicies<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListOriginRequestPoliciesOutput,
            smithy_http::result::SdkError<crate::error::ListOriginRequestPoliciesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A filter to return only the specified kinds of origin request policies. Valid values
        /// are:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>managed</code> – Returns only the managed policies created by AWS.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>custom</code> – Returns only the custom policies created in your AWS
        /// account.</p>
        /// </li>
        /// </ul>
        pub fn r#type(mut self, input: crate::model::OriginRequestPolicyType) -> Self {
            self.inner = self.inner.r#type(input);
            self
        }
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::OriginRequestPolicyType>,
        ) -> Self {
            self.inner = self.inner.set_type(input);
            self
        }
        /// <p>Use this field when paginating results to indicate where to begin in your list of
        /// origin request policies. The response includes origin request policies in the list that
        /// occur after the marker. To get the next page of the list, set this field’s value to the
        /// value of <code>NextMarker</code> from the current page’s response.</p>
        pub fn marker(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(input);
            self
        }
        pub fn set_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(input);
            self
        }
        /// <p>The maximum number of origin request policies that you want in the response.</p>
        pub fn max_items(mut self, input: i32) -> Self {
            self.inner = self.inner.max_items(input);
            self
        }
        pub fn set_max_items(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_items(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListPublicKeys<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_public_keys_input::Builder,
    }
    impl<C> ListPublicKeys<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListPublicKeysOutput,
            smithy_http::result::SdkError<crate::error::ListPublicKeysError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Use this when paginating results to indicate where to begin in your list of public keys. The results include public keys in the list that
        /// occur after the marker. To get the next page of results, set the <code>Marker</code> to the value of the
        /// <code>NextMarker</code> from the current page's response (which is also the ID of the last public key on that page). </p>
        pub fn marker(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(input);
            self
        }
        pub fn set_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(input);
            self
        }
        /// <p>The maximum number of public keys you want in the response body. </p>
        pub fn max_items(mut self, input: i32) -> Self {
            self.inner = self.inner.max_items(input);
            self
        }
        pub fn set_max_items(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_items(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListRealtimeLogConfigs<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_realtime_log_configs_input::Builder,
    }
    impl<C> ListRealtimeLogConfigs<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListRealtimeLogConfigsOutput,
            smithy_http::result::SdkError<crate::error::ListRealtimeLogConfigsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The maximum number of real-time log configurations that you want in the response.</p>
        pub fn max_items(mut self, input: i32) -> Self {
            self.inner = self.inner.max_items(input);
            self
        }
        pub fn set_max_items(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_items(input);
            self
        }
        /// <p>Use this field when paginating results to indicate where to begin in your list of real-time
        /// log configurations. The response includes real-time log configurations in the list that
        /// occur after the marker. To get the next page of the list, set this field’s value to the
        /// value of <code>NextMarker</code> from the current page’s response.</p>
        pub fn marker(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(input);
            self
        }
        pub fn set_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListStreamingDistributions<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_streaming_distributions_input::Builder,
    }
    impl<C> ListStreamingDistributions<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListStreamingDistributionsOutput,
            smithy_http::result::SdkError<crate::error::ListStreamingDistributionsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The value that you provided for the <code>Marker</code> request parameter.</p>
        pub fn marker(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(input);
            self
        }
        pub fn set_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(input);
            self
        }
        /// <p>The value that you provided for the <code>MaxItems</code> request parameter.</p>
        pub fn max_items(mut self, input: i32) -> Self {
            self.inner = self.inner.max_items(input);
            self
        }
        pub fn set_max_items(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_items(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListTagsForResource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_tags_for_resource_input::Builder,
    }
    impl<C> ListTagsForResource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListTagsForResourceOutput,
            smithy_http::result::SdkError<crate::error::ListTagsForResourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p> An ARN of a CloudFront resource.</p>
        pub fn resource(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource(input);
            self
        }
        pub fn set_resource(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PublishFunction<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::publish_function_input::Builder,
    }
    impl<C> PublishFunction<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PublishFunctionOutput,
            smithy_http::result::SdkError<crate::error::PublishFunctionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the function that you are publishing.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>The current version (<code>ETag</code> value) of the function that you are publishing, which
        /// you can get using <code>DescribeFunction</code>.</p>
        pub fn if_match(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.if_match(input);
            self
        }
        pub fn set_if_match(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_if_match(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct TagResource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::tag_resource_input::Builder,
    }
    impl<C> TagResource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::TagResourceOutput,
            smithy_http::result::SdkError<crate::error::TagResourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p> An ARN of a CloudFront resource.</p>
        pub fn resource(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource(input);
            self
        }
        pub fn set_resource(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource(input);
            self
        }
        /// <p> A complex type that contains zero or more <code>Tag</code> elements.</p>
        pub fn tags(mut self, input: crate::model::Tags) -> Self {
            self.inner = self.inner.tags(input);
            self
        }
        pub fn set_tags(mut self, input: std::option::Option<crate::model::Tags>) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct TestFunction<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::test_function_input::Builder,
    }
    impl<C> TestFunction<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::TestFunctionOutput,
            smithy_http::result::SdkError<crate::error::TestFunctionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the function that you are testing.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>The current version (<code>ETag</code> value) of the function that you are testing, which
        /// you can get using <code>DescribeFunction</code>.</p>
        pub fn if_match(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.if_match(input);
            self
        }
        pub fn set_if_match(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_if_match(input);
            self
        }
        /// <p>The stage of the function that you are testing, either <code>DEVELOPMENT</code> or
        /// <code>LIVE</code>.</p>
        pub fn stage(mut self, input: crate::model::FunctionStage) -> Self {
            self.inner = self.inner.stage(input);
            self
        }
        pub fn set_stage(
            mut self,
            input: std::option::Option<crate::model::FunctionStage>,
        ) -> Self {
            self.inner = self.inner.set_stage(input);
            self
        }
        /// <p>The event object to test the function with. For more information about the structure of the
        /// event object, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/managing-functions.html#test-function">Testing functions</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
        pub fn event_object(mut self, input: smithy_types::Blob) -> Self {
            self.inner = self.inner.event_object(input);
            self
        }
        pub fn set_event_object(mut self, input: std::option::Option<smithy_types::Blob>) -> Self {
            self.inner = self.inner.set_event_object(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UntagResource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::untag_resource_input::Builder,
    }
    impl<C> UntagResource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UntagResourceOutput,
            smithy_http::result::SdkError<crate::error::UntagResourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p> An ARN of a CloudFront resource.</p>
        pub fn resource(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource(input);
            self
        }
        pub fn set_resource(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource(input);
            self
        }
        /// <p> A complex type that contains zero or more <code>Tag</code> key elements.</p>
        pub fn tag_keys(mut self, input: crate::model::TagKeys) -> Self {
            self.inner = self.inner.tag_keys(input);
            self
        }
        pub fn set_tag_keys(mut self, input: std::option::Option<crate::model::TagKeys>) -> Self {
            self.inner = self.inner.set_tag_keys(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateCachePolicy<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_cache_policy_input::Builder,
    }
    impl<C> UpdateCachePolicy<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateCachePolicyOutput,
            smithy_http::result::SdkError<crate::error::UpdateCachePolicyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The unique identifier for the cache policy that you are updating. The identifier is returned
        /// in a cache behavior’s <code>CachePolicyId</code> field in the response to
        /// <code>GetDistributionConfig</code>.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(input);
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(input);
            self
        }
        /// <p>The version of the cache policy that you are updating. The version is returned in the cache
        /// policy’s <code>ETag</code> field in the response to
        /// <code>GetCachePolicyConfig</code>.</p>
        pub fn if_match(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.if_match(input);
            self
        }
        pub fn set_if_match(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_if_match(input);
            self
        }
        /// <p>A cache policy configuration.</p>
        pub fn cache_policy_config(mut self, input: crate::model::CachePolicyConfig) -> Self {
            self.inner = self.inner.cache_policy_config(input);
            self
        }
        pub fn set_cache_policy_config(
            mut self,
            input: std::option::Option<crate::model::CachePolicyConfig>,
        ) -> Self {
            self.inner = self.inner.set_cache_policy_config(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateCloudFrontOriginAccessIdentity<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_cloud_front_origin_access_identity_input::Builder,
    }
    impl<C> UpdateCloudFrontOriginAccessIdentity<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateCloudFrontOriginAccessIdentityOutput,
            smithy_http::result::SdkError<crate::error::UpdateCloudFrontOriginAccessIdentityError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identity's id.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(input);
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(input);
            self
        }
        /// <p>The value of the <code>ETag</code> header that you received when retrieving the
        /// identity's configuration. For example: <code>E2QWRUHAPOMQZL</code>.</p>
        pub fn if_match(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.if_match(input);
            self
        }
        pub fn set_if_match(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_if_match(input);
            self
        }
        /// <p>The identity's configuration information.</p>
        pub fn cloud_front_origin_access_identity_config(
            mut self,
            input: crate::model::CloudFrontOriginAccessIdentityConfig,
        ) -> Self {
            self.inner = self.inner.cloud_front_origin_access_identity_config(input);
            self
        }
        pub fn set_cloud_front_origin_access_identity_config(
            mut self,
            input: std::option::Option<crate::model::CloudFrontOriginAccessIdentityConfig>,
        ) -> Self {
            self.inner = self
                .inner
                .set_cloud_front_origin_access_identity_config(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateDistribution<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_distribution_input::Builder,
    }
    impl<C> UpdateDistribution<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateDistributionOutput,
            smithy_http::result::SdkError<crate::error::UpdateDistributionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The distribution's id.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(input);
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(input);
            self
        }
        /// <p>The value of the <code>ETag</code> header that you received when retrieving the
        /// distribution's configuration. For example: <code>E2QWRUHAPOMQZL</code>.</p>
        pub fn if_match(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.if_match(input);
            self
        }
        pub fn set_if_match(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_if_match(input);
            self
        }
        /// <p>The distribution's configuration information.</p>
        pub fn distribution_config(mut self, input: crate::model::DistributionConfig) -> Self {
            self.inner = self.inner.distribution_config(input);
            self
        }
        pub fn set_distribution_config(
            mut self,
            input: std::option::Option<crate::model::DistributionConfig>,
        ) -> Self {
            self.inner = self.inner.set_distribution_config(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateFieldLevelEncryptionConfig<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_field_level_encryption_config_input::Builder,
    }
    impl<C> UpdateFieldLevelEncryptionConfig<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateFieldLevelEncryptionConfigOutput,
            smithy_http::result::SdkError<crate::error::UpdateFieldLevelEncryptionConfigError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the configuration you want to update.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(input);
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(input);
            self
        }
        /// <p>The value of the <code>ETag</code> header that you received when retrieving the configuration identity to update.
        /// For example: <code>E2QWRUHAPOMQZL</code>.</p>
        pub fn if_match(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.if_match(input);
            self
        }
        pub fn set_if_match(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_if_match(input);
            self
        }
        /// <p>Request to update a field-level encryption configuration. </p>
        pub fn field_level_encryption_config(
            mut self,
            input: crate::model::FieldLevelEncryptionConfig,
        ) -> Self {
            self.inner = self.inner.field_level_encryption_config(input);
            self
        }
        pub fn set_field_level_encryption_config(
            mut self,
            input: std::option::Option<crate::model::FieldLevelEncryptionConfig>,
        ) -> Self {
            self.inner = self.inner.set_field_level_encryption_config(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateFieldLevelEncryptionProfile<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_field_level_encryption_profile_input::Builder,
    }
    impl<C> UpdateFieldLevelEncryptionProfile<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateFieldLevelEncryptionProfileOutput,
            smithy_http::result::SdkError<crate::error::UpdateFieldLevelEncryptionProfileError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the field-level encryption profile request. </p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(input);
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(input);
            self
        }
        /// <p>The value of the <code>ETag</code> header that you received when retrieving the profile identity to update.
        /// For example: <code>E2QWRUHAPOMQZL</code>.</p>
        pub fn if_match(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.if_match(input);
            self
        }
        pub fn set_if_match(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_if_match(input);
            self
        }
        /// <p>Request to update a field-level encryption profile. </p>
        pub fn field_level_encryption_profile_config(
            mut self,
            input: crate::model::FieldLevelEncryptionProfileConfig,
        ) -> Self {
            self.inner = self.inner.field_level_encryption_profile_config(input);
            self
        }
        pub fn set_field_level_encryption_profile_config(
            mut self,
            input: std::option::Option<crate::model::FieldLevelEncryptionProfileConfig>,
        ) -> Self {
            self.inner = self.inner.set_field_level_encryption_profile_config(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateFunction<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_function_input::Builder,
    }
    impl<C> UpdateFunction<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateFunctionOutput,
            smithy_http::result::SdkError<crate::error::UpdateFunctionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the function that you are updating.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>The current version (<code>ETag</code> value) of the function that you are updating, which
        /// you can get using <code>DescribeFunction</code>.</p>
        pub fn if_match(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.if_match(input);
            self
        }
        pub fn set_if_match(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_if_match(input);
            self
        }
        /// <p>Configuration information about the function.</p>
        pub fn function_config(mut self, input: crate::model::FunctionConfig) -> Self {
            self.inner = self.inner.function_config(input);
            self
        }
        pub fn set_function_config(
            mut self,
            input: std::option::Option<crate::model::FunctionConfig>,
        ) -> Self {
            self.inner = self.inner.set_function_config(input);
            self
        }
        /// <p>The function code. For more information about writing a CloudFront function, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/writing-function-code.html">Writing function
        /// code for CloudFront Functions</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
        pub fn function_code(mut self, input: smithy_types::Blob) -> Self {
            self.inner = self.inner.function_code(input);
            self
        }
        pub fn set_function_code(mut self, input: std::option::Option<smithy_types::Blob>) -> Self {
            self.inner = self.inner.set_function_code(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateKeyGroup<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_key_group_input::Builder,
    }
    impl<C> UpdateKeyGroup<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateKeyGroupOutput,
            smithy_http::result::SdkError<crate::error::UpdateKeyGroupError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identifier of the key group that you are updating.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(input);
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(input);
            self
        }
        /// <p>The version of the key group that you are updating. The version is the key group’s
        /// <code>ETag</code> value.</p>
        pub fn if_match(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.if_match(input);
            self
        }
        pub fn set_if_match(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_if_match(input);
            self
        }
        /// <p>The key group configuration.</p>
        pub fn key_group_config(mut self, input: crate::model::KeyGroupConfig) -> Self {
            self.inner = self.inner.key_group_config(input);
            self
        }
        pub fn set_key_group_config(
            mut self,
            input: std::option::Option<crate::model::KeyGroupConfig>,
        ) -> Self {
            self.inner = self.inner.set_key_group_config(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateOriginRequestPolicy<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_origin_request_policy_input::Builder,
    }
    impl<C> UpdateOriginRequestPolicy<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateOriginRequestPolicyOutput,
            smithy_http::result::SdkError<crate::error::UpdateOriginRequestPolicyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The unique identifier for the origin request policy that you are updating. The identifier is
        /// returned in a cache behavior’s <code>OriginRequestPolicyId</code> field in the response
        /// to <code>GetDistributionConfig</code>.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(input);
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(input);
            self
        }
        /// <p>The version of the origin request policy that you are updating. The version is returned in
        /// the origin request policy’s <code>ETag</code> field in the response to
        /// <code>GetOriginRequestPolicyConfig</code>.</p>
        pub fn if_match(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.if_match(input);
            self
        }
        pub fn set_if_match(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_if_match(input);
            self
        }
        /// <p>An origin request policy configuration.</p>
        pub fn origin_request_policy_config(
            mut self,
            input: crate::model::OriginRequestPolicyConfig,
        ) -> Self {
            self.inner = self.inner.origin_request_policy_config(input);
            self
        }
        pub fn set_origin_request_policy_config(
            mut self,
            input: std::option::Option<crate::model::OriginRequestPolicyConfig>,
        ) -> Self {
            self.inner = self.inner.set_origin_request_policy_config(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdatePublicKey<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_public_key_input::Builder,
    }
    impl<C> UpdatePublicKey<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdatePublicKeyOutput,
            smithy_http::result::SdkError<crate::error::UpdatePublicKeyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identifier of the public key that you are updating.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(input);
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(input);
            self
        }
        /// <p>The value of the <code>ETag</code> header that you received when retrieving the public key to update.
        /// For example: <code>E2QWRUHAPOMQZL</code>.</p>
        pub fn if_match(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.if_match(input);
            self
        }
        pub fn set_if_match(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_if_match(input);
            self
        }
        /// <p>A public key configuration.</p>
        pub fn public_key_config(mut self, input: crate::model::PublicKeyConfig) -> Self {
            self.inner = self.inner.public_key_config(input);
            self
        }
        pub fn set_public_key_config(
            mut self,
            input: std::option::Option<crate::model::PublicKeyConfig>,
        ) -> Self {
            self.inner = self.inner.set_public_key_config(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateRealtimeLogConfig<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_realtime_log_config_input::Builder,
    }
    impl<C> UpdateRealtimeLogConfig<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateRealtimeLogConfigOutput,
            smithy_http::result::SdkError<crate::error::UpdateRealtimeLogConfigError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Contains information about the Amazon Kinesis data stream where you are sending real-time
        /// log data.</p>
        pub fn end_points(mut self, inp: impl Into<crate::model::EndPoint>) -> Self {
            self.inner = self.inner.end_points(inp);
            self
        }
        pub fn set_end_points(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::EndPoint>>,
        ) -> Self {
            self.inner = self.inner.set_end_points(input);
            self
        }
        /// <p>A list of fields to include in each real-time log record.</p>
        /// <p>For more information about fields, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/real-time-logs.html#understand-real-time-log-config-fields">Real-time log configuration fields</a> in the
        /// <i>Amazon CloudFront Developer Guide</i>.</p>
        pub fn fields(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.fields(inp);
            self
        }
        pub fn set_fields(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_fields(input);
            self
        }
        /// <p>The name for this real-time log configuration.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) for this real-time log configuration.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.arn(input);
            self
        }
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_arn(input);
            self
        }
        /// <p>The sampling rate for this real-time log configuration. The sampling rate determines the
        /// percentage of viewer requests that are represented in the real-time log data. You must
        /// provide an integer between 1 and 100, inclusive.</p>
        pub fn sampling_rate(mut self, input: i64) -> Self {
            self.inner = self.inner.sampling_rate(input);
            self
        }
        pub fn set_sampling_rate(mut self, input: std::option::Option<i64>) -> Self {
            self.inner = self.inner.set_sampling_rate(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateStreamingDistribution<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_streaming_distribution_input::Builder,
    }
    impl<C> UpdateStreamingDistribution<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateStreamingDistributionOutput,
            smithy_http::result::SdkError<crate::error::UpdateStreamingDistributionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The streaming distribution's id.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(input);
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(input);
            self
        }
        /// <p>The value of the <code>ETag</code> header that you received when retrieving the
        /// streaming distribution's configuration. For example: <code>E2QWRUHAPOMQZL</code>.</p>
        pub fn if_match(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.if_match(input);
            self
        }
        pub fn set_if_match(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_if_match(input);
            self
        }
        /// <p>The streaming distribution's configuration information.</p>
        pub fn streaming_distribution_config(
            mut self,
            input: crate::model::StreamingDistributionConfig,
        ) -> Self {
            self.inner = self.inner.streaming_distribution_config(input);
            self
        }
        pub fn set_streaming_distribution_config(
            mut self,
            input: std::option::Option<crate::model::StreamingDistributionConfig>,
        ) -> Self {
            self.inner = self.inner.set_streaming_distribution_config(input);
            self
        }
    }
}
