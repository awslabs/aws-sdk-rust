// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
pub fn add_headers_copy_distribution(
                    input: &crate::input::CopyDistributionInput,
                    mut builder: http::request::Builder
                ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
    if let Some(inner_1) = &input.staging {
        let mut encoder = aws_smithy_types::primitive::Encoder::from(*inner_1);
        let formatted_2 = encoder.encode();
                        if !formatted_2.is_empty() {
                            let header_value = formatted_2;
                            let header_value = http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                                aws_smithy_http::operation::error::BuildError::invalid_field("staging", format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value,
                                err
                            ))
                            })?;
                            builder = builder.header("Staging", header_value);
                        }
    }
    if let Some(inner_3) = &input.if_match {
        let formatted_4 = inner_3.as_str();
                        if !formatted_4.is_empty() {
                            let header_value = formatted_4;
                            let header_value = http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                                aws_smithy_http::operation::error::BuildError::invalid_field("if_match", format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value,
                                err
                            ))
                            })?;
                            builder = builder.header("If-Match", header_value);
                        }
    }
    Ok(builder)
}

pub fn add_headers_delete_cache_policy(
                    input: &crate::input::DeleteCachePolicyInput,
                    mut builder: http::request::Builder
                ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
    if let Some(inner_5) = &input.if_match {
        let formatted_6 = inner_5.as_str();
                        if !formatted_6.is_empty() {
                            let header_value = formatted_6;
                            let header_value = http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                                aws_smithy_http::operation::error::BuildError::invalid_field("if_match", format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value,
                                err
                            ))
                            })?;
                            builder = builder.header("If-Match", header_value);
                        }
    }
    Ok(builder)
}

pub fn add_headers_delete_cloud_front_origin_access_identity(
                    input: &crate::input::DeleteCloudFrontOriginAccessIdentityInput,
                    mut builder: http::request::Builder
                ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
    if let Some(inner_7) = &input.if_match {
        let formatted_8 = inner_7.as_str();
                        if !formatted_8.is_empty() {
                            let header_value = formatted_8;
                            let header_value = http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                                aws_smithy_http::operation::error::BuildError::invalid_field("if_match", format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value,
                                err
                            ))
                            })?;
                            builder = builder.header("If-Match", header_value);
                        }
    }
    Ok(builder)
}

pub fn add_headers_delete_continuous_deployment_policy(
                    input: &crate::input::DeleteContinuousDeploymentPolicyInput,
                    mut builder: http::request::Builder
                ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
    if let Some(inner_9) = &input.if_match {
        let formatted_10 = inner_9.as_str();
                        if !formatted_10.is_empty() {
                            let header_value = formatted_10;
                            let header_value = http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                                aws_smithy_http::operation::error::BuildError::invalid_field("if_match", format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value,
                                err
                            ))
                            })?;
                            builder = builder.header("If-Match", header_value);
                        }
    }
    Ok(builder)
}

pub fn add_headers_delete_distribution(
                    input: &crate::input::DeleteDistributionInput,
                    mut builder: http::request::Builder
                ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
    if let Some(inner_11) = &input.if_match {
        let formatted_12 = inner_11.as_str();
                        if !formatted_12.is_empty() {
                            let header_value = formatted_12;
                            let header_value = http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                                aws_smithy_http::operation::error::BuildError::invalid_field("if_match", format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value,
                                err
                            ))
                            })?;
                            builder = builder.header("If-Match", header_value);
                        }
    }
    Ok(builder)
}

pub fn add_headers_delete_field_level_encryption_config(
                    input: &crate::input::DeleteFieldLevelEncryptionConfigInput,
                    mut builder: http::request::Builder
                ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
    if let Some(inner_13) = &input.if_match {
        let formatted_14 = inner_13.as_str();
                        if !formatted_14.is_empty() {
                            let header_value = formatted_14;
                            let header_value = http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                                aws_smithy_http::operation::error::BuildError::invalid_field("if_match", format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value,
                                err
                            ))
                            })?;
                            builder = builder.header("If-Match", header_value);
                        }
    }
    Ok(builder)
}

pub fn add_headers_delete_field_level_encryption_profile(
                    input: &crate::input::DeleteFieldLevelEncryptionProfileInput,
                    mut builder: http::request::Builder
                ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
    if let Some(inner_15) = &input.if_match {
        let formatted_16 = inner_15.as_str();
                        if !formatted_16.is_empty() {
                            let header_value = formatted_16;
                            let header_value = http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                                aws_smithy_http::operation::error::BuildError::invalid_field("if_match", format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value,
                                err
                            ))
                            })?;
                            builder = builder.header("If-Match", header_value);
                        }
    }
    Ok(builder)
}

pub fn add_headers_delete_function(
                    input: &crate::input::DeleteFunctionInput,
                    mut builder: http::request::Builder
                ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
    if let Some(inner_17) = &input.if_match {
        let formatted_18 = inner_17.as_str();
                        if !formatted_18.is_empty() {
                            let header_value = formatted_18;
                            let header_value = http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                                aws_smithy_http::operation::error::BuildError::invalid_field("if_match", format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value,
                                err
                            ))
                            })?;
                            builder = builder.header("If-Match", header_value);
                        }
    }
    Ok(builder)
}

pub fn add_headers_delete_key_group(
                    input: &crate::input::DeleteKeyGroupInput,
                    mut builder: http::request::Builder
                ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
    if let Some(inner_19) = &input.if_match {
        let formatted_20 = inner_19.as_str();
                        if !formatted_20.is_empty() {
                            let header_value = formatted_20;
                            let header_value = http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                                aws_smithy_http::operation::error::BuildError::invalid_field("if_match", format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value,
                                err
                            ))
                            })?;
                            builder = builder.header("If-Match", header_value);
                        }
    }
    Ok(builder)
}

pub fn add_headers_delete_origin_access_control(
                    input: &crate::input::DeleteOriginAccessControlInput,
                    mut builder: http::request::Builder
                ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
    if let Some(inner_21) = &input.if_match {
        let formatted_22 = inner_21.as_str();
                        if !formatted_22.is_empty() {
                            let header_value = formatted_22;
                            let header_value = http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                                aws_smithy_http::operation::error::BuildError::invalid_field("if_match", format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value,
                                err
                            ))
                            })?;
                            builder = builder.header("If-Match", header_value);
                        }
    }
    Ok(builder)
}

pub fn add_headers_delete_origin_request_policy(
                    input: &crate::input::DeleteOriginRequestPolicyInput,
                    mut builder: http::request::Builder
                ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
    if let Some(inner_23) = &input.if_match {
        let formatted_24 = inner_23.as_str();
                        if !formatted_24.is_empty() {
                            let header_value = formatted_24;
                            let header_value = http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                                aws_smithy_http::operation::error::BuildError::invalid_field("if_match", format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value,
                                err
                            ))
                            })?;
                            builder = builder.header("If-Match", header_value);
                        }
    }
    Ok(builder)
}

pub fn add_headers_delete_public_key(
                    input: &crate::input::DeletePublicKeyInput,
                    mut builder: http::request::Builder
                ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
    if let Some(inner_25) = &input.if_match {
        let formatted_26 = inner_25.as_str();
                        if !formatted_26.is_empty() {
                            let header_value = formatted_26;
                            let header_value = http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                                aws_smithy_http::operation::error::BuildError::invalid_field("if_match", format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value,
                                err
                            ))
                            })?;
                            builder = builder.header("If-Match", header_value);
                        }
    }
    Ok(builder)
}

pub fn add_headers_delete_response_headers_policy(
                    input: &crate::input::DeleteResponseHeadersPolicyInput,
                    mut builder: http::request::Builder
                ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
    if let Some(inner_27) = &input.if_match {
        let formatted_28 = inner_27.as_str();
                        if !formatted_28.is_empty() {
                            let header_value = formatted_28;
                            let header_value = http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                                aws_smithy_http::operation::error::BuildError::invalid_field("if_match", format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value,
                                err
                            ))
                            })?;
                            builder = builder.header("If-Match", header_value);
                        }
    }
    Ok(builder)
}

pub fn add_headers_delete_streaming_distribution(
                    input: &crate::input::DeleteStreamingDistributionInput,
                    mut builder: http::request::Builder
                ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
    if let Some(inner_29) = &input.if_match {
        let formatted_30 = inner_29.as_str();
                        if !formatted_30.is_empty() {
                            let header_value = formatted_30;
                            let header_value = http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                                aws_smithy_http::operation::error::BuildError::invalid_field("if_match", format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value,
                                err
                            ))
                            })?;
                            builder = builder.header("If-Match", header_value);
                        }
    }
    Ok(builder)
}

pub fn add_headers_publish_function(
                    input: &crate::input::PublishFunctionInput,
                    mut builder: http::request::Builder
                ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
    if let Some(inner_31) = &input.if_match {
        let formatted_32 = inner_31.as_str();
                        if !formatted_32.is_empty() {
                            let header_value = formatted_32;
                            let header_value = http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                                aws_smithy_http::operation::error::BuildError::invalid_field("if_match", format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value,
                                err
                            ))
                            })?;
                            builder = builder.header("If-Match", header_value);
                        }
    }
    Ok(builder)
}

pub fn add_headers_test_function(
                    input: &crate::input::TestFunctionInput,
                    mut builder: http::request::Builder
                ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
    if let Some(inner_33) = &input.if_match {
        let formatted_34 = inner_33.as_str();
                        if !formatted_34.is_empty() {
                            let header_value = formatted_34;
                            let header_value = http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                                aws_smithy_http::operation::error::BuildError::invalid_field("if_match", format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value,
                                err
                            ))
                            })?;
                            builder = builder.header("If-Match", header_value);
                        }
    }
    Ok(builder)
}

pub fn add_headers_update_cache_policy(
                    input: &crate::input::UpdateCachePolicyInput,
                    mut builder: http::request::Builder
                ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
    if let Some(inner_35) = &input.if_match {
        let formatted_36 = inner_35.as_str();
                        if !formatted_36.is_empty() {
                            let header_value = formatted_36;
                            let header_value = http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                                aws_smithy_http::operation::error::BuildError::invalid_field("if_match", format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value,
                                err
                            ))
                            })?;
                            builder = builder.header("If-Match", header_value);
                        }
    }
    Ok(builder)
}

pub fn add_headers_update_cloud_front_origin_access_identity(
                    input: &crate::input::UpdateCloudFrontOriginAccessIdentityInput,
                    mut builder: http::request::Builder
                ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
    if let Some(inner_37) = &input.if_match {
        let formatted_38 = inner_37.as_str();
                        if !formatted_38.is_empty() {
                            let header_value = formatted_38;
                            let header_value = http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                                aws_smithy_http::operation::error::BuildError::invalid_field("if_match", format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value,
                                err
                            ))
                            })?;
                            builder = builder.header("If-Match", header_value);
                        }
    }
    Ok(builder)
}

pub fn add_headers_update_continuous_deployment_policy(
                    input: &crate::input::UpdateContinuousDeploymentPolicyInput,
                    mut builder: http::request::Builder
                ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
    if let Some(inner_39) = &input.if_match {
        let formatted_40 = inner_39.as_str();
                        if !formatted_40.is_empty() {
                            let header_value = formatted_40;
                            let header_value = http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                                aws_smithy_http::operation::error::BuildError::invalid_field("if_match", format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value,
                                err
                            ))
                            })?;
                            builder = builder.header("If-Match", header_value);
                        }
    }
    Ok(builder)
}

pub fn add_headers_update_distribution(
                    input: &crate::input::UpdateDistributionInput,
                    mut builder: http::request::Builder
                ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
    if let Some(inner_41) = &input.if_match {
        let formatted_42 = inner_41.as_str();
                        if !formatted_42.is_empty() {
                            let header_value = formatted_42;
                            let header_value = http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                                aws_smithy_http::operation::error::BuildError::invalid_field("if_match", format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value,
                                err
                            ))
                            })?;
                            builder = builder.header("If-Match", header_value);
                        }
    }
    Ok(builder)
}

pub fn add_headers_update_distribution_with_staging_config(
                    input: &crate::input::UpdateDistributionWithStagingConfigInput,
                    mut builder: http::request::Builder
                ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
    if let Some(inner_43) = &input.if_match {
        let formatted_44 = inner_43.as_str();
                        if !formatted_44.is_empty() {
                            let header_value = formatted_44;
                            let header_value = http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                                aws_smithy_http::operation::error::BuildError::invalid_field("if_match", format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value,
                                err
                            ))
                            })?;
                            builder = builder.header("If-Match", header_value);
                        }
    }
    Ok(builder)
}

pub fn add_headers_update_field_level_encryption_config(
                    input: &crate::input::UpdateFieldLevelEncryptionConfigInput,
                    mut builder: http::request::Builder
                ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
    if let Some(inner_45) = &input.if_match {
        let formatted_46 = inner_45.as_str();
                        if !formatted_46.is_empty() {
                            let header_value = formatted_46;
                            let header_value = http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                                aws_smithy_http::operation::error::BuildError::invalid_field("if_match", format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value,
                                err
                            ))
                            })?;
                            builder = builder.header("If-Match", header_value);
                        }
    }
    Ok(builder)
}

pub fn add_headers_update_field_level_encryption_profile(
                    input: &crate::input::UpdateFieldLevelEncryptionProfileInput,
                    mut builder: http::request::Builder
                ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
    if let Some(inner_47) = &input.if_match {
        let formatted_48 = inner_47.as_str();
                        if !formatted_48.is_empty() {
                            let header_value = formatted_48;
                            let header_value = http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                                aws_smithy_http::operation::error::BuildError::invalid_field("if_match", format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value,
                                err
                            ))
                            })?;
                            builder = builder.header("If-Match", header_value);
                        }
    }
    Ok(builder)
}

pub fn add_headers_update_function(
                    input: &crate::input::UpdateFunctionInput,
                    mut builder: http::request::Builder
                ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
    if let Some(inner_49) = &input.if_match {
        let formatted_50 = inner_49.as_str();
                        if !formatted_50.is_empty() {
                            let header_value = formatted_50;
                            let header_value = http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                                aws_smithy_http::operation::error::BuildError::invalid_field("if_match", format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value,
                                err
                            ))
                            })?;
                            builder = builder.header("If-Match", header_value);
                        }
    }
    Ok(builder)
}

pub fn add_headers_update_key_group(
                    input: &crate::input::UpdateKeyGroupInput,
                    mut builder: http::request::Builder
                ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
    if let Some(inner_51) = &input.if_match {
        let formatted_52 = inner_51.as_str();
                        if !formatted_52.is_empty() {
                            let header_value = formatted_52;
                            let header_value = http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                                aws_smithy_http::operation::error::BuildError::invalid_field("if_match", format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value,
                                err
                            ))
                            })?;
                            builder = builder.header("If-Match", header_value);
                        }
    }
    Ok(builder)
}

pub fn add_headers_update_origin_access_control(
                    input: &crate::input::UpdateOriginAccessControlInput,
                    mut builder: http::request::Builder
                ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
    if let Some(inner_53) = &input.if_match {
        let formatted_54 = inner_53.as_str();
                        if !formatted_54.is_empty() {
                            let header_value = formatted_54;
                            let header_value = http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                                aws_smithy_http::operation::error::BuildError::invalid_field("if_match", format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value,
                                err
                            ))
                            })?;
                            builder = builder.header("If-Match", header_value);
                        }
    }
    Ok(builder)
}

pub fn add_headers_update_origin_request_policy(
                    input: &crate::input::UpdateOriginRequestPolicyInput,
                    mut builder: http::request::Builder
                ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
    if let Some(inner_55) = &input.if_match {
        let formatted_56 = inner_55.as_str();
                        if !formatted_56.is_empty() {
                            let header_value = formatted_56;
                            let header_value = http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                                aws_smithy_http::operation::error::BuildError::invalid_field("if_match", format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value,
                                err
                            ))
                            })?;
                            builder = builder.header("If-Match", header_value);
                        }
    }
    Ok(builder)
}

pub fn add_headers_update_public_key(
                    input: &crate::input::UpdatePublicKeyInput,
                    mut builder: http::request::Builder
                ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
    if let Some(inner_57) = &input.if_match {
        let formatted_58 = inner_57.as_str();
                        if !formatted_58.is_empty() {
                            let header_value = formatted_58;
                            let header_value = http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                                aws_smithy_http::operation::error::BuildError::invalid_field("if_match", format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value,
                                err
                            ))
                            })?;
                            builder = builder.header("If-Match", header_value);
                        }
    }
    Ok(builder)
}

pub fn add_headers_update_response_headers_policy(
                    input: &crate::input::UpdateResponseHeadersPolicyInput,
                    mut builder: http::request::Builder
                ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
    if let Some(inner_59) = &input.if_match {
        let formatted_60 = inner_59.as_str();
                        if !formatted_60.is_empty() {
                            let header_value = formatted_60;
                            let header_value = http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                                aws_smithy_http::operation::error::BuildError::invalid_field("if_match", format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value,
                                err
                            ))
                            })?;
                            builder = builder.header("If-Match", header_value);
                        }
    }
    Ok(builder)
}

pub fn add_headers_update_streaming_distribution(
                    input: &crate::input::UpdateStreamingDistributionInput,
                    mut builder: http::request::Builder
                ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
    if let Some(inner_61) = &input.if_match {
        let formatted_62 = inner_61.as_str();
                        if !formatted_62.is_empty() {
                            let header_value = formatted_62;
                            let header_value = http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                                aws_smithy_http::operation::error::BuildError::invalid_field("if_match", format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value,
                                err
                            ))
                            })?;
                            builder = builder.header("If-Match", header_value);
                        }
    }
    Ok(builder)
}

pub fn deser_payload_copy_distribution_copy_distribution_output_distribution(body: &[u8]) -> std::result::Result<std::option::Option<crate::model::Distribution>, crate::error::CopyDistributionError> {
    (!body.is_empty()).then(||{
        crate::xml_deser::deser_member_com_amazonaws_cloudfront_synthetic_copy_distribution_output_distribution(body).map_err(crate::error::CopyDistributionError::unhandled)
    }).transpose()
}

pub(crate) fn deser_header_copy_distribution_copy_distribution_output_e_tag(header_map: &http::HeaderMap) -> std::result::Result<std::option::Option<std::string::String>, aws_smithy_http::header::ParseError> {
    let headers = header_map.get_all("ETag").iter();
    aws_smithy_http::header::one_or_none(headers)
}

pub(crate) fn deser_header_copy_distribution_copy_distribution_output_location(header_map: &http::HeaderMap) -> std::result::Result<std::option::Option<std::string::String>, aws_smithy_http::header::ParseError> {
    let headers = header_map.get_all("Location").iter();
    aws_smithy_http::header::one_or_none(headers)
}

pub fn deser_payload_create_cache_policy_create_cache_policy_output_cache_policy(body: &[u8]) -> std::result::Result<std::option::Option<crate::model::CachePolicy>, crate::error::CreateCachePolicyError> {
    (!body.is_empty()).then(||{
        crate::xml_deser::deser_member_com_amazonaws_cloudfront_synthetic_create_cache_policy_output_cache_policy(body).map_err(crate::error::CreateCachePolicyError::unhandled)
    }).transpose()
}

pub(crate) fn deser_header_create_cache_policy_create_cache_policy_output_e_tag(header_map: &http::HeaderMap) -> std::result::Result<std::option::Option<std::string::String>, aws_smithy_http::header::ParseError> {
    let headers = header_map.get_all("ETag").iter();
    aws_smithy_http::header::one_or_none(headers)
}

pub(crate) fn deser_header_create_cache_policy_create_cache_policy_output_location(header_map: &http::HeaderMap) -> std::result::Result<std::option::Option<std::string::String>, aws_smithy_http::header::ParseError> {
    let headers = header_map.get_all("Location").iter();
    aws_smithy_http::header::one_or_none(headers)
}

pub fn deser_payload_create_cloud_front_origin_access_identity_create_cloud_front_origin_access_identity_output_cloud_front_origin_access_identity(body: &[u8]) -> std::result::Result<std::option::Option<crate::model::CloudFrontOriginAccessIdentity>, crate::error::CreateCloudFrontOriginAccessIdentityError> {
    (!body.is_empty()).then(||{
        crate::xml_deser::deser_member_com_amazonaws_cloudfront_synthetic_create_cloud_front_origin_access_identity_output_cloud_front_origin_access_identity(body).map_err(crate::error::CreateCloudFrontOriginAccessIdentityError::unhandled)
    }).transpose()
}

pub(crate) fn deser_header_create_cloud_front_origin_access_identity_create_cloud_front_origin_access_identity_output_e_tag(header_map: &http::HeaderMap) -> std::result::Result<std::option::Option<std::string::String>, aws_smithy_http::header::ParseError> {
    let headers = header_map.get_all("ETag").iter();
    aws_smithy_http::header::one_or_none(headers)
}

pub(crate) fn deser_header_create_cloud_front_origin_access_identity_create_cloud_front_origin_access_identity_output_location(header_map: &http::HeaderMap) -> std::result::Result<std::option::Option<std::string::String>, aws_smithy_http::header::ParseError> {
    let headers = header_map.get_all("Location").iter();
    aws_smithy_http::header::one_or_none(headers)
}

pub fn deser_payload_create_continuous_deployment_policy_create_continuous_deployment_policy_output_continuous_deployment_policy(body: &[u8]) -> std::result::Result<std::option::Option<crate::model::ContinuousDeploymentPolicy>, crate::error::CreateContinuousDeploymentPolicyError> {
    (!body.is_empty()).then(||{
        crate::xml_deser::deser_member_com_amazonaws_cloudfront_synthetic_create_continuous_deployment_policy_output_continuous_deployment_policy(body).map_err(crate::error::CreateContinuousDeploymentPolicyError::unhandled)
    }).transpose()
}

pub(crate) fn deser_header_create_continuous_deployment_policy_create_continuous_deployment_policy_output_e_tag(header_map: &http::HeaderMap) -> std::result::Result<std::option::Option<std::string::String>, aws_smithy_http::header::ParseError> {
    let headers = header_map.get_all("ETag").iter();
    aws_smithy_http::header::one_or_none(headers)
}

pub(crate) fn deser_header_create_continuous_deployment_policy_create_continuous_deployment_policy_output_location(header_map: &http::HeaderMap) -> std::result::Result<std::option::Option<std::string::String>, aws_smithy_http::header::ParseError> {
    let headers = header_map.get_all("Location").iter();
    aws_smithy_http::header::one_or_none(headers)
}

pub fn deser_payload_create_distribution_create_distribution_output_distribution(body: &[u8]) -> std::result::Result<std::option::Option<crate::model::Distribution>, crate::error::CreateDistributionError> {
    (!body.is_empty()).then(||{
        crate::xml_deser::deser_member_com_amazonaws_cloudfront_synthetic_create_distribution_output_distribution(body).map_err(crate::error::CreateDistributionError::unhandled)
    }).transpose()
}

pub(crate) fn deser_header_create_distribution_create_distribution_output_e_tag(header_map: &http::HeaderMap) -> std::result::Result<std::option::Option<std::string::String>, aws_smithy_http::header::ParseError> {
    let headers = header_map.get_all("ETag").iter();
    aws_smithy_http::header::one_or_none(headers)
}

pub(crate) fn deser_header_create_distribution_create_distribution_output_location(header_map: &http::HeaderMap) -> std::result::Result<std::option::Option<std::string::String>, aws_smithy_http::header::ParseError> {
    let headers = header_map.get_all("Location").iter();
    aws_smithy_http::header::one_or_none(headers)
}

pub fn deser_payload_create_distribution_with_tags_create_distribution_with_tags_output_distribution(body: &[u8]) -> std::result::Result<std::option::Option<crate::model::Distribution>, crate::error::CreateDistributionWithTagsError> {
    (!body.is_empty()).then(||{
        crate::xml_deser::deser_member_com_amazonaws_cloudfront_synthetic_create_distribution_with_tags_output_distribution(body).map_err(crate::error::CreateDistributionWithTagsError::unhandled)
    }).transpose()
}

pub(crate) fn deser_header_create_distribution_with_tags_create_distribution_with_tags_output_e_tag(header_map: &http::HeaderMap) -> std::result::Result<std::option::Option<std::string::String>, aws_smithy_http::header::ParseError> {
    let headers = header_map.get_all("ETag").iter();
    aws_smithy_http::header::one_or_none(headers)
}

pub(crate) fn deser_header_create_distribution_with_tags_create_distribution_with_tags_output_location(header_map: &http::HeaderMap) -> std::result::Result<std::option::Option<std::string::String>, aws_smithy_http::header::ParseError> {
    let headers = header_map.get_all("Location").iter();
    aws_smithy_http::header::one_or_none(headers)
}

pub(crate) fn deser_header_create_field_level_encryption_config_create_field_level_encryption_config_output_e_tag(header_map: &http::HeaderMap) -> std::result::Result<std::option::Option<std::string::String>, aws_smithy_http::header::ParseError> {
    let headers = header_map.get_all("ETag").iter();
    aws_smithy_http::header::one_or_none(headers)
}

pub fn deser_payload_create_field_level_encryption_config_create_field_level_encryption_config_output_field_level_encryption(body: &[u8]) -> std::result::Result<std::option::Option<crate::model::FieldLevelEncryption>, crate::error::CreateFieldLevelEncryptionConfigError> {
    (!body.is_empty()).then(||{
        crate::xml_deser::deser_member_com_amazonaws_cloudfront_synthetic_create_field_level_encryption_config_output_field_level_encryption(body).map_err(crate::error::CreateFieldLevelEncryptionConfigError::unhandled)
    }).transpose()
}

pub(crate) fn deser_header_create_field_level_encryption_config_create_field_level_encryption_config_output_location(header_map: &http::HeaderMap) -> std::result::Result<std::option::Option<std::string::String>, aws_smithy_http::header::ParseError> {
    let headers = header_map.get_all("Location").iter();
    aws_smithy_http::header::one_or_none(headers)
}

pub(crate) fn deser_header_create_field_level_encryption_profile_create_field_level_encryption_profile_output_e_tag(header_map: &http::HeaderMap) -> std::result::Result<std::option::Option<std::string::String>, aws_smithy_http::header::ParseError> {
    let headers = header_map.get_all("ETag").iter();
    aws_smithy_http::header::one_or_none(headers)
}

pub fn deser_payload_create_field_level_encryption_profile_create_field_level_encryption_profile_output_field_level_encryption_profile(body: &[u8]) -> std::result::Result<std::option::Option<crate::model::FieldLevelEncryptionProfile>, crate::error::CreateFieldLevelEncryptionProfileError> {
    (!body.is_empty()).then(||{
        crate::xml_deser::deser_member_com_amazonaws_cloudfront_synthetic_create_field_level_encryption_profile_output_field_level_encryption_profile(body).map_err(crate::error::CreateFieldLevelEncryptionProfileError::unhandled)
    }).transpose()
}

pub(crate) fn deser_header_create_field_level_encryption_profile_create_field_level_encryption_profile_output_location(header_map: &http::HeaderMap) -> std::result::Result<std::option::Option<std::string::String>, aws_smithy_http::header::ParseError> {
    let headers = header_map.get_all("Location").iter();
    aws_smithy_http::header::one_or_none(headers)
}

pub(crate) fn deser_header_create_function_create_function_output_e_tag(header_map: &http::HeaderMap) -> std::result::Result<std::option::Option<std::string::String>, aws_smithy_http::header::ParseError> {
    let headers = header_map.get_all("ETag").iter();
    aws_smithy_http::header::one_or_none(headers)
}

pub fn deser_payload_create_function_create_function_output_function_summary(body: &[u8]) -> std::result::Result<std::option::Option<crate::model::FunctionSummary>, crate::error::CreateFunctionError> {
    (!body.is_empty()).then(||{
        crate::xml_deser::deser_member_com_amazonaws_cloudfront_synthetic_create_function_output_function_summary(body).map_err(crate::error::CreateFunctionError::unhandled)
    }).transpose()
}

pub(crate) fn deser_header_create_function_create_function_output_location(header_map: &http::HeaderMap) -> std::result::Result<std::option::Option<std::string::String>, aws_smithy_http::header::ParseError> {
    let headers = header_map.get_all("Location").iter();
    aws_smithy_http::header::one_or_none(headers)
}

pub fn deser_payload_create_invalidation_create_invalidation_output_invalidation(body: &[u8]) -> std::result::Result<std::option::Option<crate::model::Invalidation>, crate::error::CreateInvalidationError> {
    (!body.is_empty()).then(||{
        crate::xml_deser::deser_member_com_amazonaws_cloudfront_synthetic_create_invalidation_output_invalidation(body).map_err(crate::error::CreateInvalidationError::unhandled)
    }).transpose()
}

pub(crate) fn deser_header_create_invalidation_create_invalidation_output_location(header_map: &http::HeaderMap) -> std::result::Result<std::option::Option<std::string::String>, aws_smithy_http::header::ParseError> {
    let headers = header_map.get_all("Location").iter();
    aws_smithy_http::header::one_or_none(headers)
}

pub(crate) fn deser_header_create_key_group_create_key_group_output_e_tag(header_map: &http::HeaderMap) -> std::result::Result<std::option::Option<std::string::String>, aws_smithy_http::header::ParseError> {
    let headers = header_map.get_all("ETag").iter();
    aws_smithy_http::header::one_or_none(headers)
}

pub fn deser_payload_create_key_group_create_key_group_output_key_group(body: &[u8]) -> std::result::Result<std::option::Option<crate::model::KeyGroup>, crate::error::CreateKeyGroupError> {
    (!body.is_empty()).then(||{
        crate::xml_deser::deser_member_com_amazonaws_cloudfront_synthetic_create_key_group_output_key_group(body).map_err(crate::error::CreateKeyGroupError::unhandled)
    }).transpose()
}

pub(crate) fn deser_header_create_key_group_create_key_group_output_location(header_map: &http::HeaderMap) -> std::result::Result<std::option::Option<std::string::String>, aws_smithy_http::header::ParseError> {
    let headers = header_map.get_all("Location").iter();
    aws_smithy_http::header::one_or_none(headers)
}

pub fn deser_payload_create_monitoring_subscription_create_monitoring_subscription_output_monitoring_subscription(body: &[u8]) -> std::result::Result<std::option::Option<crate::model::MonitoringSubscription>, crate::error::CreateMonitoringSubscriptionError> {
    (!body.is_empty()).then(||{
        crate::xml_deser::deser_member_com_amazonaws_cloudfront_synthetic_create_monitoring_subscription_output_monitoring_subscription(body).map_err(crate::error::CreateMonitoringSubscriptionError::unhandled)
    }).transpose()
}

pub(crate) fn deser_header_create_origin_access_control_create_origin_access_control_output_e_tag(header_map: &http::HeaderMap) -> std::result::Result<std::option::Option<std::string::String>, aws_smithy_http::header::ParseError> {
    let headers = header_map.get_all("ETag").iter();
    aws_smithy_http::header::one_or_none(headers)
}

pub(crate) fn deser_header_create_origin_access_control_create_origin_access_control_output_location(header_map: &http::HeaderMap) -> std::result::Result<std::option::Option<std::string::String>, aws_smithy_http::header::ParseError> {
    let headers = header_map.get_all("Location").iter();
    aws_smithy_http::header::one_or_none(headers)
}

pub fn deser_payload_create_origin_access_control_create_origin_access_control_output_origin_access_control(body: &[u8]) -> std::result::Result<std::option::Option<crate::model::OriginAccessControl>, crate::error::CreateOriginAccessControlError> {
    (!body.is_empty()).then(||{
        crate::xml_deser::deser_member_com_amazonaws_cloudfront_synthetic_create_origin_access_control_output_origin_access_control(body).map_err(crate::error::CreateOriginAccessControlError::unhandled)
    }).transpose()
}

pub(crate) fn deser_header_create_origin_request_policy_create_origin_request_policy_output_e_tag(header_map: &http::HeaderMap) -> std::result::Result<std::option::Option<std::string::String>, aws_smithy_http::header::ParseError> {
    let headers = header_map.get_all("ETag").iter();
    aws_smithy_http::header::one_or_none(headers)
}

pub(crate) fn deser_header_create_origin_request_policy_create_origin_request_policy_output_location(header_map: &http::HeaderMap) -> std::result::Result<std::option::Option<std::string::String>, aws_smithy_http::header::ParseError> {
    let headers = header_map.get_all("Location").iter();
    aws_smithy_http::header::one_or_none(headers)
}

pub fn deser_payload_create_origin_request_policy_create_origin_request_policy_output_origin_request_policy(body: &[u8]) -> std::result::Result<std::option::Option<crate::model::OriginRequestPolicy>, crate::error::CreateOriginRequestPolicyError> {
    (!body.is_empty()).then(||{
        crate::xml_deser::deser_member_com_amazonaws_cloudfront_synthetic_create_origin_request_policy_output_origin_request_policy(body).map_err(crate::error::CreateOriginRequestPolicyError::unhandled)
    }).transpose()
}

pub(crate) fn deser_header_create_public_key_create_public_key_output_e_tag(header_map: &http::HeaderMap) -> std::result::Result<std::option::Option<std::string::String>, aws_smithy_http::header::ParseError> {
    let headers = header_map.get_all("ETag").iter();
    aws_smithy_http::header::one_or_none(headers)
}

pub(crate) fn deser_header_create_public_key_create_public_key_output_location(header_map: &http::HeaderMap) -> std::result::Result<std::option::Option<std::string::String>, aws_smithy_http::header::ParseError> {
    let headers = header_map.get_all("Location").iter();
    aws_smithy_http::header::one_or_none(headers)
}

pub fn deser_payload_create_public_key_create_public_key_output_public_key(body: &[u8]) -> std::result::Result<std::option::Option<crate::model::PublicKey>, crate::error::CreatePublicKeyError> {
    (!body.is_empty()).then(||{
        crate::xml_deser::deser_member_com_amazonaws_cloudfront_synthetic_create_public_key_output_public_key(body).map_err(crate::error::CreatePublicKeyError::unhandled)
    }).transpose()
}

pub(crate) fn deser_header_create_response_headers_policy_create_response_headers_policy_output_e_tag(header_map: &http::HeaderMap) -> std::result::Result<std::option::Option<std::string::String>, aws_smithy_http::header::ParseError> {
    let headers = header_map.get_all("ETag").iter();
    aws_smithy_http::header::one_or_none(headers)
}

pub(crate) fn deser_header_create_response_headers_policy_create_response_headers_policy_output_location(header_map: &http::HeaderMap) -> std::result::Result<std::option::Option<std::string::String>, aws_smithy_http::header::ParseError> {
    let headers = header_map.get_all("Location").iter();
    aws_smithy_http::header::one_or_none(headers)
}

pub fn deser_payload_create_response_headers_policy_create_response_headers_policy_output_response_headers_policy(body: &[u8]) -> std::result::Result<std::option::Option<crate::model::ResponseHeadersPolicy>, crate::error::CreateResponseHeadersPolicyError> {
    (!body.is_empty()).then(||{
        crate::xml_deser::deser_member_com_amazonaws_cloudfront_synthetic_create_response_headers_policy_output_response_headers_policy(body).map_err(crate::error::CreateResponseHeadersPolicyError::unhandled)
    }).transpose()
}

pub(crate) fn deser_header_create_streaming_distribution_create_streaming_distribution_output_e_tag(header_map: &http::HeaderMap) -> std::result::Result<std::option::Option<std::string::String>, aws_smithy_http::header::ParseError> {
    let headers = header_map.get_all("ETag").iter();
    aws_smithy_http::header::one_or_none(headers)
}

pub(crate) fn deser_header_create_streaming_distribution_create_streaming_distribution_output_location(header_map: &http::HeaderMap) -> std::result::Result<std::option::Option<std::string::String>, aws_smithy_http::header::ParseError> {
    let headers = header_map.get_all("Location").iter();
    aws_smithy_http::header::one_or_none(headers)
}

pub fn deser_payload_create_streaming_distribution_create_streaming_distribution_output_streaming_distribution(body: &[u8]) -> std::result::Result<std::option::Option<crate::model::StreamingDistribution>, crate::error::CreateStreamingDistributionError> {
    (!body.is_empty()).then(||{
        crate::xml_deser::deser_member_com_amazonaws_cloudfront_synthetic_create_streaming_distribution_output_streaming_distribution(body).map_err(crate::error::CreateStreamingDistributionError::unhandled)
    }).transpose()
}

pub(crate) fn deser_header_create_streaming_distribution_with_tags_create_streaming_distribution_with_tags_output_e_tag(header_map: &http::HeaderMap) -> std::result::Result<std::option::Option<std::string::String>, aws_smithy_http::header::ParseError> {
    let headers = header_map.get_all("ETag").iter();
    aws_smithy_http::header::one_or_none(headers)
}

pub(crate) fn deser_header_create_streaming_distribution_with_tags_create_streaming_distribution_with_tags_output_location(header_map: &http::HeaderMap) -> std::result::Result<std::option::Option<std::string::String>, aws_smithy_http::header::ParseError> {
    let headers = header_map.get_all("Location").iter();
    aws_smithy_http::header::one_or_none(headers)
}

pub fn deser_payload_create_streaming_distribution_with_tags_create_streaming_distribution_with_tags_output_streaming_distribution(body: &[u8]) -> std::result::Result<std::option::Option<crate::model::StreamingDistribution>, crate::error::CreateStreamingDistributionWithTagsError> {
    (!body.is_empty()).then(||{
        crate::xml_deser::deser_member_com_amazonaws_cloudfront_synthetic_create_streaming_distribution_with_tags_output_streaming_distribution(body).map_err(crate::error::CreateStreamingDistributionWithTagsError::unhandled)
    }).transpose()
}

pub(crate) fn deser_header_describe_function_describe_function_output_e_tag(header_map: &http::HeaderMap) -> std::result::Result<std::option::Option<std::string::String>, aws_smithy_http::header::ParseError> {
    let headers = header_map.get_all("ETag").iter();
    aws_smithy_http::header::one_or_none(headers)
}

pub fn deser_payload_describe_function_describe_function_output_function_summary(body: &[u8]) -> std::result::Result<std::option::Option<crate::model::FunctionSummary>, crate::error::DescribeFunctionError> {
    (!body.is_empty()).then(||{
        crate::xml_deser::deser_member_com_amazonaws_cloudfront_synthetic_describe_function_output_function_summary(body).map_err(crate::error::DescribeFunctionError::unhandled)
    }).transpose()
}

pub fn deser_payload_get_cache_policy_get_cache_policy_output_cache_policy(body: &[u8]) -> std::result::Result<std::option::Option<crate::model::CachePolicy>, crate::error::GetCachePolicyError> {
    (!body.is_empty()).then(||{
        crate::xml_deser::deser_member_com_amazonaws_cloudfront_synthetic_get_cache_policy_output_cache_policy(body).map_err(crate::error::GetCachePolicyError::unhandled)
    }).transpose()
}

pub(crate) fn deser_header_get_cache_policy_get_cache_policy_output_e_tag(header_map: &http::HeaderMap) -> std::result::Result<std::option::Option<std::string::String>, aws_smithy_http::header::ParseError> {
    let headers = header_map.get_all("ETag").iter();
    aws_smithy_http::header::one_or_none(headers)
}

pub fn deser_payload_get_cache_policy_config_get_cache_policy_config_output_cache_policy_config(body: &[u8]) -> std::result::Result<std::option::Option<crate::model::CachePolicyConfig>, crate::error::GetCachePolicyConfigError> {
    (!body.is_empty()).then(||{
        crate::xml_deser::deser_member_com_amazonaws_cloudfront_synthetic_get_cache_policy_config_output_cache_policy_config(body).map_err(crate::error::GetCachePolicyConfigError::unhandled)
    }).transpose()
}

pub(crate) fn deser_header_get_cache_policy_config_get_cache_policy_config_output_e_tag(header_map: &http::HeaderMap) -> std::result::Result<std::option::Option<std::string::String>, aws_smithy_http::header::ParseError> {
    let headers = header_map.get_all("ETag").iter();
    aws_smithy_http::header::one_or_none(headers)
}

pub fn deser_payload_get_cloud_front_origin_access_identity_get_cloud_front_origin_access_identity_output_cloud_front_origin_access_identity(body: &[u8]) -> std::result::Result<std::option::Option<crate::model::CloudFrontOriginAccessIdentity>, crate::error::GetCloudFrontOriginAccessIdentityError> {
    (!body.is_empty()).then(||{
        crate::xml_deser::deser_member_com_amazonaws_cloudfront_synthetic_get_cloud_front_origin_access_identity_output_cloud_front_origin_access_identity(body).map_err(crate::error::GetCloudFrontOriginAccessIdentityError::unhandled)
    }).transpose()
}

pub(crate) fn deser_header_get_cloud_front_origin_access_identity_get_cloud_front_origin_access_identity_output_e_tag(header_map: &http::HeaderMap) -> std::result::Result<std::option::Option<std::string::String>, aws_smithy_http::header::ParseError> {
    let headers = header_map.get_all("ETag").iter();
    aws_smithy_http::header::one_or_none(headers)
}

pub fn deser_payload_get_cloud_front_origin_access_identity_config_get_cloud_front_origin_access_identity_config_output_cloud_front_origin_access_identity_config(body: &[u8]) -> std::result::Result<std::option::Option<crate::model::CloudFrontOriginAccessIdentityConfig>, crate::error::GetCloudFrontOriginAccessIdentityConfigError> {
    (!body.is_empty()).then(||{
        crate::xml_deser::deser_member_com_amazonaws_cloudfront_synthetic_get_cloud_front_origin_access_identity_config_output_cloud_front_origin_access_identity_config(body).map_err(crate::error::GetCloudFrontOriginAccessIdentityConfigError::unhandled)
    }).transpose()
}

pub(crate) fn deser_header_get_cloud_front_origin_access_identity_config_get_cloud_front_origin_access_identity_config_output_e_tag(header_map: &http::HeaderMap) -> std::result::Result<std::option::Option<std::string::String>, aws_smithy_http::header::ParseError> {
    let headers = header_map.get_all("ETag").iter();
    aws_smithy_http::header::one_or_none(headers)
}

pub fn deser_payload_get_continuous_deployment_policy_get_continuous_deployment_policy_output_continuous_deployment_policy(body: &[u8]) -> std::result::Result<std::option::Option<crate::model::ContinuousDeploymentPolicy>, crate::error::GetContinuousDeploymentPolicyError> {
    (!body.is_empty()).then(||{
        crate::xml_deser::deser_member_com_amazonaws_cloudfront_synthetic_get_continuous_deployment_policy_output_continuous_deployment_policy(body).map_err(crate::error::GetContinuousDeploymentPolicyError::unhandled)
    }).transpose()
}

pub(crate) fn deser_header_get_continuous_deployment_policy_get_continuous_deployment_policy_output_e_tag(header_map: &http::HeaderMap) -> std::result::Result<std::option::Option<std::string::String>, aws_smithy_http::header::ParseError> {
    let headers = header_map.get_all("ETag").iter();
    aws_smithy_http::header::one_or_none(headers)
}

pub fn deser_payload_get_continuous_deployment_policy_config_get_continuous_deployment_policy_config_output_continuous_deployment_policy_config(body: &[u8]) -> std::result::Result<std::option::Option<crate::model::ContinuousDeploymentPolicyConfig>, crate::error::GetContinuousDeploymentPolicyConfigError> {
    (!body.is_empty()).then(||{
        crate::xml_deser::deser_member_com_amazonaws_cloudfront_synthetic_get_continuous_deployment_policy_config_output_continuous_deployment_policy_config(body).map_err(crate::error::GetContinuousDeploymentPolicyConfigError::unhandled)
    }).transpose()
}

pub(crate) fn deser_header_get_continuous_deployment_policy_config_get_continuous_deployment_policy_config_output_e_tag(header_map: &http::HeaderMap) -> std::result::Result<std::option::Option<std::string::String>, aws_smithy_http::header::ParseError> {
    let headers = header_map.get_all("ETag").iter();
    aws_smithy_http::header::one_or_none(headers)
}

pub fn deser_payload_get_distribution_get_distribution_output_distribution(body: &[u8]) -> std::result::Result<std::option::Option<crate::model::Distribution>, crate::error::GetDistributionError> {
    (!body.is_empty()).then(||{
        crate::xml_deser::deser_member_com_amazonaws_cloudfront_synthetic_get_distribution_output_distribution(body).map_err(crate::error::GetDistributionError::unhandled)
    }).transpose()
}

pub(crate) fn deser_header_get_distribution_get_distribution_output_e_tag(header_map: &http::HeaderMap) -> std::result::Result<std::option::Option<std::string::String>, aws_smithy_http::header::ParseError> {
    let headers = header_map.get_all("ETag").iter();
    aws_smithy_http::header::one_or_none(headers)
}

pub fn deser_payload_get_distribution_config_get_distribution_config_output_distribution_config(body: &[u8]) -> std::result::Result<std::option::Option<crate::model::DistributionConfig>, crate::error::GetDistributionConfigError> {
    (!body.is_empty()).then(||{
        crate::xml_deser::deser_member_com_amazonaws_cloudfront_synthetic_get_distribution_config_output_distribution_config(body).map_err(crate::error::GetDistributionConfigError::unhandled)
    }).transpose()
}

pub(crate) fn deser_header_get_distribution_config_get_distribution_config_output_e_tag(header_map: &http::HeaderMap) -> std::result::Result<std::option::Option<std::string::String>, aws_smithy_http::header::ParseError> {
    let headers = header_map.get_all("ETag").iter();
    aws_smithy_http::header::one_or_none(headers)
}

pub(crate) fn deser_header_get_field_level_encryption_get_field_level_encryption_output_e_tag(header_map: &http::HeaderMap) -> std::result::Result<std::option::Option<std::string::String>, aws_smithy_http::header::ParseError> {
    let headers = header_map.get_all("ETag").iter();
    aws_smithy_http::header::one_or_none(headers)
}

pub fn deser_payload_get_field_level_encryption_get_field_level_encryption_output_field_level_encryption(body: &[u8]) -> std::result::Result<std::option::Option<crate::model::FieldLevelEncryption>, crate::error::GetFieldLevelEncryptionError> {
    (!body.is_empty()).then(||{
        crate::xml_deser::deser_member_com_amazonaws_cloudfront_synthetic_get_field_level_encryption_output_field_level_encryption(body).map_err(crate::error::GetFieldLevelEncryptionError::unhandled)
    }).transpose()
}

pub(crate) fn deser_header_get_field_level_encryption_config_get_field_level_encryption_config_output_e_tag(header_map: &http::HeaderMap) -> std::result::Result<std::option::Option<std::string::String>, aws_smithy_http::header::ParseError> {
    let headers = header_map.get_all("ETag").iter();
    aws_smithy_http::header::one_or_none(headers)
}

pub fn deser_payload_get_field_level_encryption_config_get_field_level_encryption_config_output_field_level_encryption_config(body: &[u8]) -> std::result::Result<std::option::Option<crate::model::FieldLevelEncryptionConfig>, crate::error::GetFieldLevelEncryptionConfigError> {
    (!body.is_empty()).then(||{
        crate::xml_deser::deser_member_com_amazonaws_cloudfront_synthetic_get_field_level_encryption_config_output_field_level_encryption_config(body).map_err(crate::error::GetFieldLevelEncryptionConfigError::unhandled)
    }).transpose()
}

pub(crate) fn deser_header_get_field_level_encryption_profile_get_field_level_encryption_profile_output_e_tag(header_map: &http::HeaderMap) -> std::result::Result<std::option::Option<std::string::String>, aws_smithy_http::header::ParseError> {
    let headers = header_map.get_all("ETag").iter();
    aws_smithy_http::header::one_or_none(headers)
}

pub fn deser_payload_get_field_level_encryption_profile_get_field_level_encryption_profile_output_field_level_encryption_profile(body: &[u8]) -> std::result::Result<std::option::Option<crate::model::FieldLevelEncryptionProfile>, crate::error::GetFieldLevelEncryptionProfileError> {
    (!body.is_empty()).then(||{
        crate::xml_deser::deser_member_com_amazonaws_cloudfront_synthetic_get_field_level_encryption_profile_output_field_level_encryption_profile(body).map_err(crate::error::GetFieldLevelEncryptionProfileError::unhandled)
    }).transpose()
}

pub(crate) fn deser_header_get_field_level_encryption_profile_config_get_field_level_encryption_profile_config_output_e_tag(header_map: &http::HeaderMap) -> std::result::Result<std::option::Option<std::string::String>, aws_smithy_http::header::ParseError> {
    let headers = header_map.get_all("ETag").iter();
    aws_smithy_http::header::one_or_none(headers)
}

pub fn deser_payload_get_field_level_encryption_profile_config_get_field_level_encryption_profile_config_output_field_level_encryption_profile_config(body: &[u8]) -> std::result::Result<std::option::Option<crate::model::FieldLevelEncryptionProfileConfig>, crate::error::GetFieldLevelEncryptionProfileConfigError> {
    (!body.is_empty()).then(||{
        crate::xml_deser::deser_member_com_amazonaws_cloudfront_synthetic_get_field_level_encryption_profile_config_output_field_level_encryption_profile_config(body).map_err(crate::error::GetFieldLevelEncryptionProfileConfigError::unhandled)
    }).transpose()
}

pub(crate) fn deser_header_get_function_get_function_output_content_type(header_map: &http::HeaderMap) -> std::result::Result<std::option::Option<std::string::String>, aws_smithy_http::header::ParseError> {
    let headers = header_map.get_all("Content-Type").iter();
    aws_smithy_http::header::one_or_none(headers)
}

pub(crate) fn deser_header_get_function_get_function_output_e_tag(header_map: &http::HeaderMap) -> std::result::Result<std::option::Option<std::string::String>, aws_smithy_http::header::ParseError> {
    let headers = header_map.get_all("ETag").iter();
    aws_smithy_http::header::one_or_none(headers)
}

pub fn deser_payload_get_function_get_function_output_function_code(body: &[u8]) -> std::result::Result<std::option::Option<aws_smithy_types::Blob>, crate::error::GetFunctionError> {
    (!body.is_empty()).then(||{
        Ok(aws_smithy_types::Blob::new(body))
    }).transpose()
}

pub fn deser_payload_get_invalidation_get_invalidation_output_invalidation(body: &[u8]) -> std::result::Result<std::option::Option<crate::model::Invalidation>, crate::error::GetInvalidationError> {
    (!body.is_empty()).then(||{
        crate::xml_deser::deser_member_com_amazonaws_cloudfront_synthetic_get_invalidation_output_invalidation(body).map_err(crate::error::GetInvalidationError::unhandled)
    }).transpose()
}

pub(crate) fn deser_header_get_key_group_get_key_group_output_e_tag(header_map: &http::HeaderMap) -> std::result::Result<std::option::Option<std::string::String>, aws_smithy_http::header::ParseError> {
    let headers = header_map.get_all("ETag").iter();
    aws_smithy_http::header::one_or_none(headers)
}

pub fn deser_payload_get_key_group_get_key_group_output_key_group(body: &[u8]) -> std::result::Result<std::option::Option<crate::model::KeyGroup>, crate::error::GetKeyGroupError> {
    (!body.is_empty()).then(||{
        crate::xml_deser::deser_member_com_amazonaws_cloudfront_synthetic_get_key_group_output_key_group(body).map_err(crate::error::GetKeyGroupError::unhandled)
    }).transpose()
}

pub(crate) fn deser_header_get_key_group_config_get_key_group_config_output_e_tag(header_map: &http::HeaderMap) -> std::result::Result<std::option::Option<std::string::String>, aws_smithy_http::header::ParseError> {
    let headers = header_map.get_all("ETag").iter();
    aws_smithy_http::header::one_or_none(headers)
}

pub fn deser_payload_get_key_group_config_get_key_group_config_output_key_group_config(body: &[u8]) -> std::result::Result<std::option::Option<crate::model::KeyGroupConfig>, crate::error::GetKeyGroupConfigError> {
    (!body.is_empty()).then(||{
        crate::xml_deser::deser_member_com_amazonaws_cloudfront_synthetic_get_key_group_config_output_key_group_config(body).map_err(crate::error::GetKeyGroupConfigError::unhandled)
    }).transpose()
}

pub fn deser_payload_get_monitoring_subscription_get_monitoring_subscription_output_monitoring_subscription(body: &[u8]) -> std::result::Result<std::option::Option<crate::model::MonitoringSubscription>, crate::error::GetMonitoringSubscriptionError> {
    (!body.is_empty()).then(||{
        crate::xml_deser::deser_member_com_amazonaws_cloudfront_synthetic_get_monitoring_subscription_output_monitoring_subscription(body).map_err(crate::error::GetMonitoringSubscriptionError::unhandled)
    }).transpose()
}

pub(crate) fn deser_header_get_origin_access_control_get_origin_access_control_output_e_tag(header_map: &http::HeaderMap) -> std::result::Result<std::option::Option<std::string::String>, aws_smithy_http::header::ParseError> {
    let headers = header_map.get_all("ETag").iter();
    aws_smithy_http::header::one_or_none(headers)
}

pub fn deser_payload_get_origin_access_control_get_origin_access_control_output_origin_access_control(body: &[u8]) -> std::result::Result<std::option::Option<crate::model::OriginAccessControl>, crate::error::GetOriginAccessControlError> {
    (!body.is_empty()).then(||{
        crate::xml_deser::deser_member_com_amazonaws_cloudfront_synthetic_get_origin_access_control_output_origin_access_control(body).map_err(crate::error::GetOriginAccessControlError::unhandled)
    }).transpose()
}

pub(crate) fn deser_header_get_origin_access_control_config_get_origin_access_control_config_output_e_tag(header_map: &http::HeaderMap) -> std::result::Result<std::option::Option<std::string::String>, aws_smithy_http::header::ParseError> {
    let headers = header_map.get_all("ETag").iter();
    aws_smithy_http::header::one_or_none(headers)
}

pub fn deser_payload_get_origin_access_control_config_get_origin_access_control_config_output_origin_access_control_config(body: &[u8]) -> std::result::Result<std::option::Option<crate::model::OriginAccessControlConfig>, crate::error::GetOriginAccessControlConfigError> {
    (!body.is_empty()).then(||{
        crate::xml_deser::deser_member_com_amazonaws_cloudfront_synthetic_get_origin_access_control_config_output_origin_access_control_config(body).map_err(crate::error::GetOriginAccessControlConfigError::unhandled)
    }).transpose()
}

pub(crate) fn deser_header_get_origin_request_policy_get_origin_request_policy_output_e_tag(header_map: &http::HeaderMap) -> std::result::Result<std::option::Option<std::string::String>, aws_smithy_http::header::ParseError> {
    let headers = header_map.get_all("ETag").iter();
    aws_smithy_http::header::one_or_none(headers)
}

pub fn deser_payload_get_origin_request_policy_get_origin_request_policy_output_origin_request_policy(body: &[u8]) -> std::result::Result<std::option::Option<crate::model::OriginRequestPolicy>, crate::error::GetOriginRequestPolicyError> {
    (!body.is_empty()).then(||{
        crate::xml_deser::deser_member_com_amazonaws_cloudfront_synthetic_get_origin_request_policy_output_origin_request_policy(body).map_err(crate::error::GetOriginRequestPolicyError::unhandled)
    }).transpose()
}

pub(crate) fn deser_header_get_origin_request_policy_config_get_origin_request_policy_config_output_e_tag(header_map: &http::HeaderMap) -> std::result::Result<std::option::Option<std::string::String>, aws_smithy_http::header::ParseError> {
    let headers = header_map.get_all("ETag").iter();
    aws_smithy_http::header::one_or_none(headers)
}

pub fn deser_payload_get_origin_request_policy_config_get_origin_request_policy_config_output_origin_request_policy_config(body: &[u8]) -> std::result::Result<std::option::Option<crate::model::OriginRequestPolicyConfig>, crate::error::GetOriginRequestPolicyConfigError> {
    (!body.is_empty()).then(||{
        crate::xml_deser::deser_member_com_amazonaws_cloudfront_synthetic_get_origin_request_policy_config_output_origin_request_policy_config(body).map_err(crate::error::GetOriginRequestPolicyConfigError::unhandled)
    }).transpose()
}

pub(crate) fn deser_header_get_public_key_get_public_key_output_e_tag(header_map: &http::HeaderMap) -> std::result::Result<std::option::Option<std::string::String>, aws_smithy_http::header::ParseError> {
    let headers = header_map.get_all("ETag").iter();
    aws_smithy_http::header::one_or_none(headers)
}

pub fn deser_payload_get_public_key_get_public_key_output_public_key(body: &[u8]) -> std::result::Result<std::option::Option<crate::model::PublicKey>, crate::error::GetPublicKeyError> {
    (!body.is_empty()).then(||{
        crate::xml_deser::deser_member_com_amazonaws_cloudfront_synthetic_get_public_key_output_public_key(body).map_err(crate::error::GetPublicKeyError::unhandled)
    }).transpose()
}

pub(crate) fn deser_header_get_public_key_config_get_public_key_config_output_e_tag(header_map: &http::HeaderMap) -> std::result::Result<std::option::Option<std::string::String>, aws_smithy_http::header::ParseError> {
    let headers = header_map.get_all("ETag").iter();
    aws_smithy_http::header::one_or_none(headers)
}

pub fn deser_payload_get_public_key_config_get_public_key_config_output_public_key_config(body: &[u8]) -> std::result::Result<std::option::Option<crate::model::PublicKeyConfig>, crate::error::GetPublicKeyConfigError> {
    (!body.is_empty()).then(||{
        crate::xml_deser::deser_member_com_amazonaws_cloudfront_synthetic_get_public_key_config_output_public_key_config(body).map_err(crate::error::GetPublicKeyConfigError::unhandled)
    }).transpose()
}

pub(crate) fn deser_header_get_response_headers_policy_get_response_headers_policy_output_e_tag(header_map: &http::HeaderMap) -> std::result::Result<std::option::Option<std::string::String>, aws_smithy_http::header::ParseError> {
    let headers = header_map.get_all("ETag").iter();
    aws_smithy_http::header::one_or_none(headers)
}

pub fn deser_payload_get_response_headers_policy_get_response_headers_policy_output_response_headers_policy(body: &[u8]) -> std::result::Result<std::option::Option<crate::model::ResponseHeadersPolicy>, crate::error::GetResponseHeadersPolicyError> {
    (!body.is_empty()).then(||{
        crate::xml_deser::deser_member_com_amazonaws_cloudfront_synthetic_get_response_headers_policy_output_response_headers_policy(body).map_err(crate::error::GetResponseHeadersPolicyError::unhandled)
    }).transpose()
}

pub(crate) fn deser_header_get_response_headers_policy_config_get_response_headers_policy_config_output_e_tag(header_map: &http::HeaderMap) -> std::result::Result<std::option::Option<std::string::String>, aws_smithy_http::header::ParseError> {
    let headers = header_map.get_all("ETag").iter();
    aws_smithy_http::header::one_or_none(headers)
}

pub fn deser_payload_get_response_headers_policy_config_get_response_headers_policy_config_output_response_headers_policy_config(body: &[u8]) -> std::result::Result<std::option::Option<crate::model::ResponseHeadersPolicyConfig>, crate::error::GetResponseHeadersPolicyConfigError> {
    (!body.is_empty()).then(||{
        crate::xml_deser::deser_member_com_amazonaws_cloudfront_synthetic_get_response_headers_policy_config_output_response_headers_policy_config(body).map_err(crate::error::GetResponseHeadersPolicyConfigError::unhandled)
    }).transpose()
}

pub(crate) fn deser_header_get_streaming_distribution_get_streaming_distribution_output_e_tag(header_map: &http::HeaderMap) -> std::result::Result<std::option::Option<std::string::String>, aws_smithy_http::header::ParseError> {
    let headers = header_map.get_all("ETag").iter();
    aws_smithy_http::header::one_or_none(headers)
}

pub fn deser_payload_get_streaming_distribution_get_streaming_distribution_output_streaming_distribution(body: &[u8]) -> std::result::Result<std::option::Option<crate::model::StreamingDistribution>, crate::error::GetStreamingDistributionError> {
    (!body.is_empty()).then(||{
        crate::xml_deser::deser_member_com_amazonaws_cloudfront_synthetic_get_streaming_distribution_output_streaming_distribution(body).map_err(crate::error::GetStreamingDistributionError::unhandled)
    }).transpose()
}

pub(crate) fn deser_header_get_streaming_distribution_config_get_streaming_distribution_config_output_e_tag(header_map: &http::HeaderMap) -> std::result::Result<std::option::Option<std::string::String>, aws_smithy_http::header::ParseError> {
    let headers = header_map.get_all("ETag").iter();
    aws_smithy_http::header::one_or_none(headers)
}

pub fn deser_payload_get_streaming_distribution_config_get_streaming_distribution_config_output_streaming_distribution_config(body: &[u8]) -> std::result::Result<std::option::Option<crate::model::StreamingDistributionConfig>, crate::error::GetStreamingDistributionConfigError> {
    (!body.is_empty()).then(||{
        crate::xml_deser::deser_member_com_amazonaws_cloudfront_synthetic_get_streaming_distribution_config_output_streaming_distribution_config(body).map_err(crate::error::GetStreamingDistributionConfigError::unhandled)
    }).transpose()
}

pub fn deser_payload_list_cache_policies_list_cache_policies_output_cache_policy_list(body: &[u8]) -> std::result::Result<std::option::Option<crate::model::CachePolicyList>, crate::error::ListCachePoliciesError> {
    (!body.is_empty()).then(||{
        crate::xml_deser::deser_member_com_amazonaws_cloudfront_synthetic_list_cache_policies_output_cache_policy_list(body).map_err(crate::error::ListCachePoliciesError::unhandled)
    }).transpose()
}

pub fn deser_payload_list_cloud_front_origin_access_identities_list_cloud_front_origin_access_identities_output_cloud_front_origin_access_identity_list(body: &[u8]) -> std::result::Result<std::option::Option<crate::model::CloudFrontOriginAccessIdentityList>, crate::error::ListCloudFrontOriginAccessIdentitiesError> {
    (!body.is_empty()).then(||{
        crate::xml_deser::deser_member_com_amazonaws_cloudfront_synthetic_list_cloud_front_origin_access_identities_output_cloud_front_origin_access_identity_list(body).map_err(crate::error::ListCloudFrontOriginAccessIdentitiesError::unhandled)
    }).transpose()
}

pub fn deser_payload_list_conflicting_aliases_list_conflicting_aliases_output_conflicting_aliases_list(body: &[u8]) -> std::result::Result<std::option::Option<crate::model::ConflictingAliasesList>, crate::error::ListConflictingAliasesError> {
    (!body.is_empty()).then(||{
        crate::xml_deser::deser_member_com_amazonaws_cloudfront_synthetic_list_conflicting_aliases_output_conflicting_aliases_list(body).map_err(crate::error::ListConflictingAliasesError::unhandled)
    }).transpose()
}

pub fn deser_payload_list_continuous_deployment_policies_list_continuous_deployment_policies_output_continuous_deployment_policy_list(body: &[u8]) -> std::result::Result<std::option::Option<crate::model::ContinuousDeploymentPolicyList>, crate::error::ListContinuousDeploymentPoliciesError> {
    (!body.is_empty()).then(||{
        crate::xml_deser::deser_member_com_amazonaws_cloudfront_synthetic_list_continuous_deployment_policies_output_continuous_deployment_policy_list(body).map_err(crate::error::ListContinuousDeploymentPoliciesError::unhandled)
    }).transpose()
}

pub fn deser_payload_list_distributions_list_distributions_output_distribution_list(body: &[u8]) -> std::result::Result<std::option::Option<crate::model::DistributionList>, crate::error::ListDistributionsError> {
    (!body.is_empty()).then(||{
        crate::xml_deser::deser_member_com_amazonaws_cloudfront_synthetic_list_distributions_output_distribution_list(body).map_err(crate::error::ListDistributionsError::unhandled)
    }).transpose()
}

pub fn deser_payload_list_distributions_by_cache_policy_id_list_distributions_by_cache_policy_id_output_distribution_id_list(body: &[u8]) -> std::result::Result<std::option::Option<crate::model::DistributionIdList>, crate::error::ListDistributionsByCachePolicyIdError> {
    (!body.is_empty()).then(||{
        crate::xml_deser::deser_member_com_amazonaws_cloudfront_synthetic_list_distributions_by_cache_policy_id_output_distribution_id_list(body).map_err(crate::error::ListDistributionsByCachePolicyIdError::unhandled)
    }).transpose()
}

pub fn deser_payload_list_distributions_by_key_group_list_distributions_by_key_group_output_distribution_id_list(body: &[u8]) -> std::result::Result<std::option::Option<crate::model::DistributionIdList>, crate::error::ListDistributionsByKeyGroupError> {
    (!body.is_empty()).then(||{
        crate::xml_deser::deser_member_com_amazonaws_cloudfront_synthetic_list_distributions_by_key_group_output_distribution_id_list(body).map_err(crate::error::ListDistributionsByKeyGroupError::unhandled)
    }).transpose()
}

pub fn deser_payload_list_distributions_by_origin_request_policy_id_list_distributions_by_origin_request_policy_id_output_distribution_id_list(body: &[u8]) -> std::result::Result<std::option::Option<crate::model::DistributionIdList>, crate::error::ListDistributionsByOriginRequestPolicyIdError> {
    (!body.is_empty()).then(||{
        crate::xml_deser::deser_member_com_amazonaws_cloudfront_synthetic_list_distributions_by_origin_request_policy_id_output_distribution_id_list(body).map_err(crate::error::ListDistributionsByOriginRequestPolicyIdError::unhandled)
    }).transpose()
}

pub fn deser_payload_list_distributions_by_realtime_log_config_list_distributions_by_realtime_log_config_output_distribution_list(body: &[u8]) -> std::result::Result<std::option::Option<crate::model::DistributionList>, crate::error::ListDistributionsByRealtimeLogConfigError> {
    (!body.is_empty()).then(||{
        crate::xml_deser::deser_member_com_amazonaws_cloudfront_synthetic_list_distributions_by_realtime_log_config_output_distribution_list(body).map_err(crate::error::ListDistributionsByRealtimeLogConfigError::unhandled)
    }).transpose()
}

pub fn deser_payload_list_distributions_by_response_headers_policy_id_list_distributions_by_response_headers_policy_id_output_distribution_id_list(body: &[u8]) -> std::result::Result<std::option::Option<crate::model::DistributionIdList>, crate::error::ListDistributionsByResponseHeadersPolicyIdError> {
    (!body.is_empty()).then(||{
        crate::xml_deser::deser_member_com_amazonaws_cloudfront_synthetic_list_distributions_by_response_headers_policy_id_output_distribution_id_list(body).map_err(crate::error::ListDistributionsByResponseHeadersPolicyIdError::unhandled)
    }).transpose()
}

pub fn deser_payload_list_distributions_by_web_acl_id_list_distributions_by_web_acl_id_output_distribution_list(body: &[u8]) -> std::result::Result<std::option::Option<crate::model::DistributionList>, crate::error::ListDistributionsByWebACLIdError> {
    (!body.is_empty()).then(||{
        crate::xml_deser::deser_member_com_amazonaws_cloudfront_synthetic_list_distributions_by_web_acl_id_output_distribution_list(body).map_err(crate::error::ListDistributionsByWebACLIdError::unhandled)
    }).transpose()
}

pub fn deser_payload_list_field_level_encryption_configs_list_field_level_encryption_configs_output_field_level_encryption_list(body: &[u8]) -> std::result::Result<std::option::Option<crate::model::FieldLevelEncryptionList>, crate::error::ListFieldLevelEncryptionConfigsError> {
    (!body.is_empty()).then(||{
        crate::xml_deser::deser_member_com_amazonaws_cloudfront_synthetic_list_field_level_encryption_configs_output_field_level_encryption_list(body).map_err(crate::error::ListFieldLevelEncryptionConfigsError::unhandled)
    }).transpose()
}

pub fn deser_payload_list_field_level_encryption_profiles_list_field_level_encryption_profiles_output_field_level_encryption_profile_list(body: &[u8]) -> std::result::Result<std::option::Option<crate::model::FieldLevelEncryptionProfileList>, crate::error::ListFieldLevelEncryptionProfilesError> {
    (!body.is_empty()).then(||{
        crate::xml_deser::deser_member_com_amazonaws_cloudfront_synthetic_list_field_level_encryption_profiles_output_field_level_encryption_profile_list(body).map_err(crate::error::ListFieldLevelEncryptionProfilesError::unhandled)
    }).transpose()
}

pub fn deser_payload_list_functions_list_functions_output_function_list(body: &[u8]) -> std::result::Result<std::option::Option<crate::model::FunctionList>, crate::error::ListFunctionsError> {
    (!body.is_empty()).then(||{
        crate::xml_deser::deser_member_com_amazonaws_cloudfront_synthetic_list_functions_output_function_list(body).map_err(crate::error::ListFunctionsError::unhandled)
    }).transpose()
}

pub fn deser_payload_list_invalidations_list_invalidations_output_invalidation_list(body: &[u8]) -> std::result::Result<std::option::Option<crate::model::InvalidationList>, crate::error::ListInvalidationsError> {
    (!body.is_empty()).then(||{
        crate::xml_deser::deser_member_com_amazonaws_cloudfront_synthetic_list_invalidations_output_invalidation_list(body).map_err(crate::error::ListInvalidationsError::unhandled)
    }).transpose()
}

pub fn deser_payload_list_key_groups_list_key_groups_output_key_group_list(body: &[u8]) -> std::result::Result<std::option::Option<crate::model::KeyGroupList>, crate::error::ListKeyGroupsError> {
    (!body.is_empty()).then(||{
        crate::xml_deser::deser_member_com_amazonaws_cloudfront_synthetic_list_key_groups_output_key_group_list(body).map_err(crate::error::ListKeyGroupsError::unhandled)
    }).transpose()
}

pub fn deser_payload_list_origin_access_controls_list_origin_access_controls_output_origin_access_control_list(body: &[u8]) -> std::result::Result<std::option::Option<crate::model::OriginAccessControlList>, crate::error::ListOriginAccessControlsError> {
    (!body.is_empty()).then(||{
        crate::xml_deser::deser_member_com_amazonaws_cloudfront_synthetic_list_origin_access_controls_output_origin_access_control_list(body).map_err(crate::error::ListOriginAccessControlsError::unhandled)
    }).transpose()
}

pub fn deser_payload_list_origin_request_policies_list_origin_request_policies_output_origin_request_policy_list(body: &[u8]) -> std::result::Result<std::option::Option<crate::model::OriginRequestPolicyList>, crate::error::ListOriginRequestPoliciesError> {
    (!body.is_empty()).then(||{
        crate::xml_deser::deser_member_com_amazonaws_cloudfront_synthetic_list_origin_request_policies_output_origin_request_policy_list(body).map_err(crate::error::ListOriginRequestPoliciesError::unhandled)
    }).transpose()
}

pub fn deser_payload_list_public_keys_list_public_keys_output_public_key_list(body: &[u8]) -> std::result::Result<std::option::Option<crate::model::PublicKeyList>, crate::error::ListPublicKeysError> {
    (!body.is_empty()).then(||{
        crate::xml_deser::deser_member_com_amazonaws_cloudfront_synthetic_list_public_keys_output_public_key_list(body).map_err(crate::error::ListPublicKeysError::unhandled)
    }).transpose()
}

pub fn deser_payload_list_realtime_log_configs_list_realtime_log_configs_output_realtime_log_configs(body: &[u8]) -> std::result::Result<std::option::Option<crate::model::RealtimeLogConfigs>, crate::error::ListRealtimeLogConfigsError> {
    (!body.is_empty()).then(||{
        crate::xml_deser::deser_member_com_amazonaws_cloudfront_synthetic_list_realtime_log_configs_output_realtime_log_configs(body).map_err(crate::error::ListRealtimeLogConfigsError::unhandled)
    }).transpose()
}

pub fn deser_payload_list_response_headers_policies_list_response_headers_policies_output_response_headers_policy_list(body: &[u8]) -> std::result::Result<std::option::Option<crate::model::ResponseHeadersPolicyList>, crate::error::ListResponseHeadersPoliciesError> {
    (!body.is_empty()).then(||{
        crate::xml_deser::deser_member_com_amazonaws_cloudfront_synthetic_list_response_headers_policies_output_response_headers_policy_list(body).map_err(crate::error::ListResponseHeadersPoliciesError::unhandled)
    }).transpose()
}

pub fn deser_payload_list_streaming_distributions_list_streaming_distributions_output_streaming_distribution_list(body: &[u8]) -> std::result::Result<std::option::Option<crate::model::StreamingDistributionList>, crate::error::ListStreamingDistributionsError> {
    (!body.is_empty()).then(||{
        crate::xml_deser::deser_member_com_amazonaws_cloudfront_synthetic_list_streaming_distributions_output_streaming_distribution_list(body).map_err(crate::error::ListStreamingDistributionsError::unhandled)
    }).transpose()
}

pub fn deser_payload_list_tags_for_resource_list_tags_for_resource_output_tags(body: &[u8]) -> std::result::Result<std::option::Option<crate::model::Tags>, crate::error::ListTagsForResourceError> {
    (!body.is_empty()).then(||{
        crate::xml_deser::deser_member_com_amazonaws_cloudfront_synthetic_list_tags_for_resource_output_tags(body).map_err(crate::error::ListTagsForResourceError::unhandled)
    }).transpose()
}

pub fn deser_payload_publish_function_publish_function_output_function_summary(body: &[u8]) -> std::result::Result<std::option::Option<crate::model::FunctionSummary>, crate::error::PublishFunctionError> {
    (!body.is_empty()).then(||{
        crate::xml_deser::deser_member_com_amazonaws_cloudfront_synthetic_publish_function_output_function_summary(body).map_err(crate::error::PublishFunctionError::unhandled)
    }).transpose()
}

pub fn deser_payload_test_function_test_function_output_test_result(body: &[u8]) -> std::result::Result<std::option::Option<crate::model::TestResult>, crate::error::TestFunctionError> {
    (!body.is_empty()).then(||{
        crate::xml_deser::deser_member_com_amazonaws_cloudfront_synthetic_test_function_output_test_result(body).map_err(crate::error::TestFunctionError::unhandled)
    }).transpose()
}

pub fn deser_payload_update_cache_policy_update_cache_policy_output_cache_policy(body: &[u8]) -> std::result::Result<std::option::Option<crate::model::CachePolicy>, crate::error::UpdateCachePolicyError> {
    (!body.is_empty()).then(||{
        crate::xml_deser::deser_member_com_amazonaws_cloudfront_synthetic_update_cache_policy_output_cache_policy(body).map_err(crate::error::UpdateCachePolicyError::unhandled)
    }).transpose()
}

pub(crate) fn deser_header_update_cache_policy_update_cache_policy_output_e_tag(header_map: &http::HeaderMap) -> std::result::Result<std::option::Option<std::string::String>, aws_smithy_http::header::ParseError> {
    let headers = header_map.get_all("ETag").iter();
    aws_smithy_http::header::one_or_none(headers)
}

pub fn deser_payload_update_cloud_front_origin_access_identity_update_cloud_front_origin_access_identity_output_cloud_front_origin_access_identity(body: &[u8]) -> std::result::Result<std::option::Option<crate::model::CloudFrontOriginAccessIdentity>, crate::error::UpdateCloudFrontOriginAccessIdentityError> {
    (!body.is_empty()).then(||{
        crate::xml_deser::deser_member_com_amazonaws_cloudfront_synthetic_update_cloud_front_origin_access_identity_output_cloud_front_origin_access_identity(body).map_err(crate::error::UpdateCloudFrontOriginAccessIdentityError::unhandled)
    }).transpose()
}

pub(crate) fn deser_header_update_cloud_front_origin_access_identity_update_cloud_front_origin_access_identity_output_e_tag(header_map: &http::HeaderMap) -> std::result::Result<std::option::Option<std::string::String>, aws_smithy_http::header::ParseError> {
    let headers = header_map.get_all("ETag").iter();
    aws_smithy_http::header::one_or_none(headers)
}

pub fn deser_payload_update_continuous_deployment_policy_update_continuous_deployment_policy_output_continuous_deployment_policy(body: &[u8]) -> std::result::Result<std::option::Option<crate::model::ContinuousDeploymentPolicy>, crate::error::UpdateContinuousDeploymentPolicyError> {
    (!body.is_empty()).then(||{
        crate::xml_deser::deser_member_com_amazonaws_cloudfront_synthetic_update_continuous_deployment_policy_output_continuous_deployment_policy(body).map_err(crate::error::UpdateContinuousDeploymentPolicyError::unhandled)
    }).transpose()
}

pub(crate) fn deser_header_update_continuous_deployment_policy_update_continuous_deployment_policy_output_e_tag(header_map: &http::HeaderMap) -> std::result::Result<std::option::Option<std::string::String>, aws_smithy_http::header::ParseError> {
    let headers = header_map.get_all("ETag").iter();
    aws_smithy_http::header::one_or_none(headers)
}

pub fn deser_payload_update_distribution_update_distribution_output_distribution(body: &[u8]) -> std::result::Result<std::option::Option<crate::model::Distribution>, crate::error::UpdateDistributionError> {
    (!body.is_empty()).then(||{
        crate::xml_deser::deser_member_com_amazonaws_cloudfront_synthetic_update_distribution_output_distribution(body).map_err(crate::error::UpdateDistributionError::unhandled)
    }).transpose()
}

pub(crate) fn deser_header_update_distribution_update_distribution_output_e_tag(header_map: &http::HeaderMap) -> std::result::Result<std::option::Option<std::string::String>, aws_smithy_http::header::ParseError> {
    let headers = header_map.get_all("ETag").iter();
    aws_smithy_http::header::one_or_none(headers)
}

pub fn deser_payload_update_distribution_with_staging_config_update_distribution_with_staging_config_output_distribution(body: &[u8]) -> std::result::Result<std::option::Option<crate::model::Distribution>, crate::error::UpdateDistributionWithStagingConfigError> {
    (!body.is_empty()).then(||{
        crate::xml_deser::deser_member_com_amazonaws_cloudfront_synthetic_update_distribution_with_staging_config_output_distribution(body).map_err(crate::error::UpdateDistributionWithStagingConfigError::unhandled)
    }).transpose()
}

pub(crate) fn deser_header_update_distribution_with_staging_config_update_distribution_with_staging_config_output_e_tag(header_map: &http::HeaderMap) -> std::result::Result<std::option::Option<std::string::String>, aws_smithy_http::header::ParseError> {
    let headers = header_map.get_all("ETag").iter();
    aws_smithy_http::header::one_or_none(headers)
}

pub(crate) fn deser_header_update_field_level_encryption_config_update_field_level_encryption_config_output_e_tag(header_map: &http::HeaderMap) -> std::result::Result<std::option::Option<std::string::String>, aws_smithy_http::header::ParseError> {
    let headers = header_map.get_all("ETag").iter();
    aws_smithy_http::header::one_or_none(headers)
}

pub fn deser_payload_update_field_level_encryption_config_update_field_level_encryption_config_output_field_level_encryption(body: &[u8]) -> std::result::Result<std::option::Option<crate::model::FieldLevelEncryption>, crate::error::UpdateFieldLevelEncryptionConfigError> {
    (!body.is_empty()).then(||{
        crate::xml_deser::deser_member_com_amazonaws_cloudfront_synthetic_update_field_level_encryption_config_output_field_level_encryption(body).map_err(crate::error::UpdateFieldLevelEncryptionConfigError::unhandled)
    }).transpose()
}

pub(crate) fn deser_header_update_field_level_encryption_profile_update_field_level_encryption_profile_output_e_tag(header_map: &http::HeaderMap) -> std::result::Result<std::option::Option<std::string::String>, aws_smithy_http::header::ParseError> {
    let headers = header_map.get_all("ETag").iter();
    aws_smithy_http::header::one_or_none(headers)
}

pub fn deser_payload_update_field_level_encryption_profile_update_field_level_encryption_profile_output_field_level_encryption_profile(body: &[u8]) -> std::result::Result<std::option::Option<crate::model::FieldLevelEncryptionProfile>, crate::error::UpdateFieldLevelEncryptionProfileError> {
    (!body.is_empty()).then(||{
        crate::xml_deser::deser_member_com_amazonaws_cloudfront_synthetic_update_field_level_encryption_profile_output_field_level_encryption_profile(body).map_err(crate::error::UpdateFieldLevelEncryptionProfileError::unhandled)
    }).transpose()
}

pub(crate) fn deser_header_update_function_update_function_output_e_tag(header_map: &http::HeaderMap) -> std::result::Result<std::option::Option<std::string::String>, aws_smithy_http::header::ParseError> {
    let headers = header_map.get_all("ETtag").iter();
    aws_smithy_http::header::one_or_none(headers)
}

pub fn deser_payload_update_function_update_function_output_function_summary(body: &[u8]) -> std::result::Result<std::option::Option<crate::model::FunctionSummary>, crate::error::UpdateFunctionError> {
    (!body.is_empty()).then(||{
        crate::xml_deser::deser_member_com_amazonaws_cloudfront_synthetic_update_function_output_function_summary(body).map_err(crate::error::UpdateFunctionError::unhandled)
    }).transpose()
}

pub(crate) fn deser_header_update_key_group_update_key_group_output_e_tag(header_map: &http::HeaderMap) -> std::result::Result<std::option::Option<std::string::String>, aws_smithy_http::header::ParseError> {
    let headers = header_map.get_all("ETag").iter();
    aws_smithy_http::header::one_or_none(headers)
}

pub fn deser_payload_update_key_group_update_key_group_output_key_group(body: &[u8]) -> std::result::Result<std::option::Option<crate::model::KeyGroup>, crate::error::UpdateKeyGroupError> {
    (!body.is_empty()).then(||{
        crate::xml_deser::deser_member_com_amazonaws_cloudfront_synthetic_update_key_group_output_key_group(body).map_err(crate::error::UpdateKeyGroupError::unhandled)
    }).transpose()
}

pub(crate) fn deser_header_update_origin_access_control_update_origin_access_control_output_e_tag(header_map: &http::HeaderMap) -> std::result::Result<std::option::Option<std::string::String>, aws_smithy_http::header::ParseError> {
    let headers = header_map.get_all("ETag").iter();
    aws_smithy_http::header::one_or_none(headers)
}

pub fn deser_payload_update_origin_access_control_update_origin_access_control_output_origin_access_control(body: &[u8]) -> std::result::Result<std::option::Option<crate::model::OriginAccessControl>, crate::error::UpdateOriginAccessControlError> {
    (!body.is_empty()).then(||{
        crate::xml_deser::deser_member_com_amazonaws_cloudfront_synthetic_update_origin_access_control_output_origin_access_control(body).map_err(crate::error::UpdateOriginAccessControlError::unhandled)
    }).transpose()
}

pub(crate) fn deser_header_update_origin_request_policy_update_origin_request_policy_output_e_tag(header_map: &http::HeaderMap) -> std::result::Result<std::option::Option<std::string::String>, aws_smithy_http::header::ParseError> {
    let headers = header_map.get_all("ETag").iter();
    aws_smithy_http::header::one_or_none(headers)
}

pub fn deser_payload_update_origin_request_policy_update_origin_request_policy_output_origin_request_policy(body: &[u8]) -> std::result::Result<std::option::Option<crate::model::OriginRequestPolicy>, crate::error::UpdateOriginRequestPolicyError> {
    (!body.is_empty()).then(||{
        crate::xml_deser::deser_member_com_amazonaws_cloudfront_synthetic_update_origin_request_policy_output_origin_request_policy(body).map_err(crate::error::UpdateOriginRequestPolicyError::unhandled)
    }).transpose()
}

pub(crate) fn deser_header_update_public_key_update_public_key_output_e_tag(header_map: &http::HeaderMap) -> std::result::Result<std::option::Option<std::string::String>, aws_smithy_http::header::ParseError> {
    let headers = header_map.get_all("ETag").iter();
    aws_smithy_http::header::one_or_none(headers)
}

pub fn deser_payload_update_public_key_update_public_key_output_public_key(body: &[u8]) -> std::result::Result<std::option::Option<crate::model::PublicKey>, crate::error::UpdatePublicKeyError> {
    (!body.is_empty()).then(||{
        crate::xml_deser::deser_member_com_amazonaws_cloudfront_synthetic_update_public_key_output_public_key(body).map_err(crate::error::UpdatePublicKeyError::unhandled)
    }).transpose()
}

pub(crate) fn deser_header_update_response_headers_policy_update_response_headers_policy_output_e_tag(header_map: &http::HeaderMap) -> std::result::Result<std::option::Option<std::string::String>, aws_smithy_http::header::ParseError> {
    let headers = header_map.get_all("ETag").iter();
    aws_smithy_http::header::one_or_none(headers)
}

pub fn deser_payload_update_response_headers_policy_update_response_headers_policy_output_response_headers_policy(body: &[u8]) -> std::result::Result<std::option::Option<crate::model::ResponseHeadersPolicy>, crate::error::UpdateResponseHeadersPolicyError> {
    (!body.is_empty()).then(||{
        crate::xml_deser::deser_member_com_amazonaws_cloudfront_synthetic_update_response_headers_policy_output_response_headers_policy(body).map_err(crate::error::UpdateResponseHeadersPolicyError::unhandled)
    }).transpose()
}

pub(crate) fn deser_header_update_streaming_distribution_update_streaming_distribution_output_e_tag(header_map: &http::HeaderMap) -> std::result::Result<std::option::Option<std::string::String>, aws_smithy_http::header::ParseError> {
    let headers = header_map.get_all("ETag").iter();
    aws_smithy_http::header::one_or_none(headers)
}

pub fn deser_payload_update_streaming_distribution_update_streaming_distribution_output_streaming_distribution(body: &[u8]) -> std::result::Result<std::option::Option<crate::model::StreamingDistribution>, crate::error::UpdateStreamingDistributionError> {
    (!body.is_empty()).then(||{
        crate::xml_deser::deser_member_com_amazonaws_cloudfront_synthetic_update_streaming_distribution_output_streaming_distribution(body).map_err(crate::error::UpdateStreamingDistributionError::unhandled)
    }).transpose()
}

