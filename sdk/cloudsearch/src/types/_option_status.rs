// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>The status of domain configuration option.</p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct OptionStatus {
    /// <p>A timestamp for when this option was created.</p>
    pub creation_date: ::aws_smithy_types::DateTime,
    /// <p>A timestamp for when this option was last updated.</p>
    pub update_date: ::aws_smithy_types::DateTime,
    /// <p>A unique integer that indicates when this option was last updated.</p>
    pub update_version: i32,
    /// <p>The state of processing a change to an option. Possible values:</p>
    /// <ul>
    /// <li><code>RequiresIndexDocuments</code>: the option's latest value will not be deployed until <code>IndexDocuments</code> has been called and indexing is complete.</li>
    /// <li><code>Processing</code>: the option's latest value is in the process of being activated. </li>
    /// <li><code>Active</code>: the option's latest value is completely deployed.</li>
    /// <li><code>FailedToValidate</code>: the option value is not compatible with the domain's data and cannot be used to index the data. You must either modify the option value or update or remove the incompatible documents.</li>
    /// </ul>
    pub state: crate::types::OptionState,
    /// <p>Indicates that the option will be deleted once processing is complete.</p>
    pub pending_deletion: ::std::option::Option<bool>,
}
impl OptionStatus {
    /// <p>A timestamp for when this option was created.</p>
    pub fn creation_date(&self) -> &::aws_smithy_types::DateTime {
        &self.creation_date
    }
    /// <p>A timestamp for when this option was last updated.</p>
    pub fn update_date(&self) -> &::aws_smithy_types::DateTime {
        &self.update_date
    }
    /// <p>A unique integer that indicates when this option was last updated.</p>
    pub fn update_version(&self) -> i32 {
        self.update_version
    }
    /// <p>The state of processing a change to an option. Possible values:</p>
    /// <ul>
    /// <li><code>RequiresIndexDocuments</code>: the option's latest value will not be deployed until <code>IndexDocuments</code> has been called and indexing is complete.</li>
    /// <li><code>Processing</code>: the option's latest value is in the process of being activated. </li>
    /// <li><code>Active</code>: the option's latest value is completely deployed.</li>
    /// <li><code>FailedToValidate</code>: the option value is not compatible with the domain's data and cannot be used to index the data. You must either modify the option value or update or remove the incompatible documents.</li>
    /// </ul>
    pub fn state(&self) -> &crate::types::OptionState {
        &self.state
    }
    /// <p>Indicates that the option will be deleted once processing is complete.</p>
    pub fn pending_deletion(&self) -> ::std::option::Option<bool> {
        self.pending_deletion
    }
}
impl OptionStatus {
    /// Creates a new builder-style object to manufacture [`OptionStatus`](crate::types::OptionStatus).
    pub fn builder() -> crate::types::builders::OptionStatusBuilder {
        crate::types::builders::OptionStatusBuilder::default()
    }
}

/// A builder for [`OptionStatus`](crate::types::OptionStatus).
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
pub struct OptionStatusBuilder {
    pub(crate) creation_date: ::std::option::Option<::aws_smithy_types::DateTime>,
    pub(crate) update_date: ::std::option::Option<::aws_smithy_types::DateTime>,
    pub(crate) update_version: ::std::option::Option<i32>,
    pub(crate) state: ::std::option::Option<crate::types::OptionState>,
    pub(crate) pending_deletion: ::std::option::Option<bool>,
}
impl OptionStatusBuilder {
    /// <p>A timestamp for when this option was created.</p>
    /// This field is required.
    pub fn creation_date(mut self, input: ::aws_smithy_types::DateTime) -> Self {
        self.creation_date = ::std::option::Option::Some(input);
        self
    }
    /// <p>A timestamp for when this option was created.</p>
    pub fn set_creation_date(mut self, input: ::std::option::Option<::aws_smithy_types::DateTime>) -> Self {
        self.creation_date = input;
        self
    }
    /// <p>A timestamp for when this option was created.</p>
    pub fn get_creation_date(&self) -> &::std::option::Option<::aws_smithy_types::DateTime> {
        &self.creation_date
    }
    /// <p>A timestamp for when this option was last updated.</p>
    /// This field is required.
    pub fn update_date(mut self, input: ::aws_smithy_types::DateTime) -> Self {
        self.update_date = ::std::option::Option::Some(input);
        self
    }
    /// <p>A timestamp for when this option was last updated.</p>
    pub fn set_update_date(mut self, input: ::std::option::Option<::aws_smithy_types::DateTime>) -> Self {
        self.update_date = input;
        self
    }
    /// <p>A timestamp for when this option was last updated.</p>
    pub fn get_update_date(&self) -> &::std::option::Option<::aws_smithy_types::DateTime> {
        &self.update_date
    }
    /// <p>A unique integer that indicates when this option was last updated.</p>
    pub fn update_version(mut self, input: i32) -> Self {
        self.update_version = ::std::option::Option::Some(input);
        self
    }
    /// <p>A unique integer that indicates when this option was last updated.</p>
    pub fn set_update_version(mut self, input: ::std::option::Option<i32>) -> Self {
        self.update_version = input;
        self
    }
    /// <p>A unique integer that indicates when this option was last updated.</p>
    pub fn get_update_version(&self) -> &::std::option::Option<i32> {
        &self.update_version
    }
    /// <p>The state of processing a change to an option. Possible values:</p>
    /// <ul>
    /// <li><code>RequiresIndexDocuments</code>: the option's latest value will not be deployed until <code>IndexDocuments</code> has been called and indexing is complete.</li>
    /// <li><code>Processing</code>: the option's latest value is in the process of being activated. </li>
    /// <li><code>Active</code>: the option's latest value is completely deployed.</li>
    /// <li><code>FailedToValidate</code>: the option value is not compatible with the domain's data and cannot be used to index the data. You must either modify the option value or update or remove the incompatible documents.</li>
    /// </ul>
    /// This field is required.
    pub fn state(mut self, input: crate::types::OptionState) -> Self {
        self.state = ::std::option::Option::Some(input);
        self
    }
    /// <p>The state of processing a change to an option. Possible values:</p>
    /// <ul>
    /// <li><code>RequiresIndexDocuments</code>: the option's latest value will not be deployed until <code>IndexDocuments</code> has been called and indexing is complete.</li>
    /// <li><code>Processing</code>: the option's latest value is in the process of being activated. </li>
    /// <li><code>Active</code>: the option's latest value is completely deployed.</li>
    /// <li><code>FailedToValidate</code>: the option value is not compatible with the domain's data and cannot be used to index the data. You must either modify the option value or update or remove the incompatible documents.</li>
    /// </ul>
    pub fn set_state(mut self, input: ::std::option::Option<crate::types::OptionState>) -> Self {
        self.state = input;
        self
    }
    /// <p>The state of processing a change to an option. Possible values:</p>
    /// <ul>
    /// <li><code>RequiresIndexDocuments</code>: the option's latest value will not be deployed until <code>IndexDocuments</code> has been called and indexing is complete.</li>
    /// <li><code>Processing</code>: the option's latest value is in the process of being activated. </li>
    /// <li><code>Active</code>: the option's latest value is completely deployed.</li>
    /// <li><code>FailedToValidate</code>: the option value is not compatible with the domain's data and cannot be used to index the data. You must either modify the option value or update or remove the incompatible documents.</li>
    /// </ul>
    pub fn get_state(&self) -> &::std::option::Option<crate::types::OptionState> {
        &self.state
    }
    /// <p>Indicates that the option will be deleted once processing is complete.</p>
    pub fn pending_deletion(mut self, input: bool) -> Self {
        self.pending_deletion = ::std::option::Option::Some(input);
        self
    }
    /// <p>Indicates that the option will be deleted once processing is complete.</p>
    pub fn set_pending_deletion(mut self, input: ::std::option::Option<bool>) -> Self {
        self.pending_deletion = input;
        self
    }
    /// <p>Indicates that the option will be deleted once processing is complete.</p>
    pub fn get_pending_deletion(&self) -> &::std::option::Option<bool> {
        &self.pending_deletion
    }
    /// Consumes the builder and constructs a [`OptionStatus`](crate::types::OptionStatus).
    /// This method will fail if any of the following fields are not set:
    /// - [`creation_date`](crate::types::builders::OptionStatusBuilder::creation_date)
    /// - [`update_date`](crate::types::builders::OptionStatusBuilder::update_date)
    /// - [`state`](crate::types::builders::OptionStatusBuilder::state)
    pub fn build(self) -> ::std::result::Result<crate::types::OptionStatus, ::aws_smithy_types::error::operation::BuildError> {
        ::std::result::Result::Ok(crate::types::OptionStatus {
            creation_date: self.creation_date.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "creation_date",
                    "creation_date was not specified but it is required when building OptionStatus",
                )
            })?,
            update_date: self.update_date.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "update_date",
                    "update_date was not specified but it is required when building OptionStatus",
                )
            })?,
            update_version: self.update_version.unwrap_or_default(),
            state: self.state.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "state",
                    "state was not specified but it is required when building OptionStatus",
                )
            })?,
            pending_deletion: self.pending_deletion,
        })
    }
}
