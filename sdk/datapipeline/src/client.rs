// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[derive(std::fmt::Debug)]
pub(crate) struct Handle<C = aws_hyper::DynConnector> {
    client: aws_hyper::Client<C>,
    conf: crate::Config,
}

#[derive(Clone, std::fmt::Debug)]
pub struct Client<C = aws_hyper::DynConnector> {
    handle: std::sync::Arc<Handle<C>>,
}
impl<C> Client<C> {
    pub fn from_conf_conn(conf: crate::Config, conn: C) -> Self {
        let client = aws_hyper::Client::new(conn);
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }

    pub fn conf(&self) -> &crate::Config {
        &self.handle.conf
    }
}
impl Client {
    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_env() -> Self {
        Self::from_conf(crate::Config::builder().build())
    }

    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_conf(conf: crate::Config) -> Self {
        let client = aws_hyper::Client::https();
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }
}
impl<C> Client<C>
where
    C: aws_hyper::SmithyConnector,
{
    pub fn activate_pipeline(&self) -> fluent_builders::ActivatePipeline<C> {
        fluent_builders::ActivatePipeline::new(self.handle.clone())
    }
    pub fn add_tags(&self) -> fluent_builders::AddTags<C> {
        fluent_builders::AddTags::new(self.handle.clone())
    }
    pub fn create_pipeline(&self) -> fluent_builders::CreatePipeline<C> {
        fluent_builders::CreatePipeline::new(self.handle.clone())
    }
    pub fn deactivate_pipeline(&self) -> fluent_builders::DeactivatePipeline<C> {
        fluent_builders::DeactivatePipeline::new(self.handle.clone())
    }
    pub fn delete_pipeline(&self) -> fluent_builders::DeletePipeline<C> {
        fluent_builders::DeletePipeline::new(self.handle.clone())
    }
    pub fn describe_objects(&self) -> fluent_builders::DescribeObjects<C> {
        fluent_builders::DescribeObjects::new(self.handle.clone())
    }
    pub fn describe_pipelines(&self) -> fluent_builders::DescribePipelines<C> {
        fluent_builders::DescribePipelines::new(self.handle.clone())
    }
    pub fn evaluate_expression(&self) -> fluent_builders::EvaluateExpression<C> {
        fluent_builders::EvaluateExpression::new(self.handle.clone())
    }
    pub fn get_pipeline_definition(&self) -> fluent_builders::GetPipelineDefinition<C> {
        fluent_builders::GetPipelineDefinition::new(self.handle.clone())
    }
    pub fn list_pipelines(&self) -> fluent_builders::ListPipelines<C> {
        fluent_builders::ListPipelines::new(self.handle.clone())
    }
    pub fn poll_for_task(&self) -> fluent_builders::PollForTask<C> {
        fluent_builders::PollForTask::new(self.handle.clone())
    }
    pub fn put_pipeline_definition(&self) -> fluent_builders::PutPipelineDefinition<C> {
        fluent_builders::PutPipelineDefinition::new(self.handle.clone())
    }
    pub fn query_objects(&self) -> fluent_builders::QueryObjects<C> {
        fluent_builders::QueryObjects::new(self.handle.clone())
    }
    pub fn remove_tags(&self) -> fluent_builders::RemoveTags<C> {
        fluent_builders::RemoveTags::new(self.handle.clone())
    }
    pub fn report_task_progress(&self) -> fluent_builders::ReportTaskProgress<C> {
        fluent_builders::ReportTaskProgress::new(self.handle.clone())
    }
    pub fn report_task_runner_heartbeat(&self) -> fluent_builders::ReportTaskRunnerHeartbeat<C> {
        fluent_builders::ReportTaskRunnerHeartbeat::new(self.handle.clone())
    }
    pub fn set_status(&self) -> fluent_builders::SetStatus<C> {
        fluent_builders::SetStatus::new(self.handle.clone())
    }
    pub fn set_task_status(&self) -> fluent_builders::SetTaskStatus<C> {
        fluent_builders::SetTaskStatus::new(self.handle.clone())
    }
    pub fn validate_pipeline_definition(&self) -> fluent_builders::ValidatePipelineDefinition<C> {
        fluent_builders::ValidatePipelineDefinition::new(self.handle.clone())
    }
}
pub mod fluent_builders {
    #[derive(std::fmt::Debug)]
    pub struct ActivatePipeline<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::activate_pipeline_input::Builder,
    }
    impl<C> ActivatePipeline<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ActivatePipelineOutput,
            smithy_http::result::SdkError<crate::error::ActivatePipelineError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the pipeline.</p>
        pub fn pipeline_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.pipeline_id(input);
            self
        }
        pub fn set_pipeline_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_pipeline_id(input);
            self
        }
        /// <p>A list of parameter values to pass to the pipeline at activation.</p>
        pub fn parameter_values(mut self, inp: impl Into<crate::model::ParameterValue>) -> Self {
            self.inner = self.inner.parameter_values(inp);
            self
        }
        pub fn set_parameter_values(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ParameterValue>>,
        ) -> Self {
            self.inner = self.inner.set_parameter_values(input);
            self
        }
        /// <p>The date and time to resume the pipeline. By default, the pipeline resumes from the last completed execution.</p>
        pub fn start_timestamp(mut self, input: smithy_types::Instant) -> Self {
            self.inner = self.inner.start_timestamp(input);
            self
        }
        pub fn set_start_timestamp(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.inner = self.inner.set_start_timestamp(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct AddTags<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::add_tags_input::Builder,
    }
    impl<C> AddTags<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::AddTagsOutput,
            smithy_http::result::SdkError<crate::error::AddTagsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the pipeline.</p>
        pub fn pipeline_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.pipeline_id(input);
            self
        }
        pub fn set_pipeline_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_pipeline_id(input);
            self
        }
        /// <p>The tags to add, as key/value pairs.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreatePipeline<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_pipeline_input::Builder,
    }
    impl<C> CreatePipeline<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreatePipelineOutput,
            smithy_http::result::SdkError<crate::error::CreatePipelineError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name for the pipeline. You can use the same name for multiple pipelines associated with your AWS account,
        /// because AWS Data Pipeline assigns each pipeline a unique pipeline identifier.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>A unique identifier. This identifier is not the same as the pipeline identifier assigned by AWS Data Pipeline.
        /// You are responsible for defining the format and ensuring the uniqueness of this identifier. You use this
        /// parameter to ensure idempotency during repeated calls to <code>CreatePipeline</code>. For example, if the
        /// first call to <code>CreatePipeline</code> does not succeed, you can pass in the same unique identifier and
        /// pipeline name combination on a subsequent call to <code>CreatePipeline</code>. <code>CreatePipeline</code>
        /// ensures that if a pipeline already exists with the same name and unique identifier, a new pipeline is not
        /// created. Instead, you'll receive the pipeline identifier from the previous attempt. The uniqueness of the
        /// name and unique identifier combination is scoped to the AWS account or IAM user credentials.</p>
        pub fn unique_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.unique_id(input);
            self
        }
        pub fn set_unique_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_unique_id(input);
            self
        }
        /// <p>The description for the pipeline.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>A list of tags to associate with the pipeline at creation. Tags let you control access to pipelines.
        /// For more information, see <a href="http://docs.aws.amazon.com/datapipeline/latest/DeveloperGuide/dp-control-access.html">Controlling User Access to Pipelines</a>
        /// in the <i>AWS Data Pipeline Developer Guide</i>.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeactivatePipeline<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::deactivate_pipeline_input::Builder,
    }
    impl<C> DeactivatePipeline<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeactivatePipelineOutput,
            smithy_http::result::SdkError<crate::error::DeactivatePipelineError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the pipeline.</p>
        pub fn pipeline_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.pipeline_id(input);
            self
        }
        pub fn set_pipeline_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_pipeline_id(input);
            self
        }
        /// <p>Indicates whether to cancel any running objects. The default is true,
        /// which sets the state of any running objects to <code>CANCELED</code>.
        /// If this value is false, the pipeline is deactivated after all
        /// running objects finish.</p>
        pub fn cancel_active(mut self, input: bool) -> Self {
            self.inner = self.inner.cancel_active(input);
            self
        }
        pub fn set_cancel_active(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_cancel_active(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeletePipeline<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_pipeline_input::Builder,
    }
    impl<C> DeletePipeline<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeletePipelineOutput,
            smithy_http::result::SdkError<crate::error::DeletePipelineError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the pipeline.</p>
        pub fn pipeline_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.pipeline_id(input);
            self
        }
        pub fn set_pipeline_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_pipeline_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeObjects<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_objects_input::Builder,
    }
    impl<C> DescribeObjects<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeObjectsOutput,
            smithy_http::result::SdkError<crate::error::DescribeObjectsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the pipeline that contains the object definitions.</p>
        pub fn pipeline_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.pipeline_id(input);
            self
        }
        pub fn set_pipeline_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_pipeline_id(input);
            self
        }
        /// <p>The IDs of the pipeline objects that contain the definitions to be described. You can pass as many as 25 identifiers in a single call to <code>DescribeObjects</code>.</p>
        pub fn object_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.object_ids(inp);
            self
        }
        pub fn set_object_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_object_ids(input);
            self
        }
        /// <p>Indicates whether any expressions in the object should be evaluated when the object descriptions are returned.</p>
        pub fn evaluate_expressions(mut self, input: bool) -> Self {
            self.inner = self.inner.evaluate_expressions(input);
            self
        }
        pub fn set_evaluate_expressions(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_evaluate_expressions(input);
            self
        }
        /// <p>The starting point for the results to be returned. For the first call, this value should be empty.
        /// As long as there are more results, continue to call <code>DescribeObjects</code> with
        /// the marker value from the previous call to retrieve the next set of results.</p>
        pub fn marker(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(input);
            self
        }
        pub fn set_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribePipelines<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_pipelines_input::Builder,
    }
    impl<C> DescribePipelines<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribePipelinesOutput,
            smithy_http::result::SdkError<crate::error::DescribePipelinesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The IDs of the pipelines to describe. You can pass as many as 25 identifiers in a single call.
        /// To obtain pipeline IDs, call <a>ListPipelines</a>.</p>
        pub fn pipeline_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.pipeline_ids(inp);
            self
        }
        pub fn set_pipeline_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_pipeline_ids(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct EvaluateExpression<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::evaluate_expression_input::Builder,
    }
    impl<C> EvaluateExpression<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::EvaluateExpressionOutput,
            smithy_http::result::SdkError<crate::error::EvaluateExpressionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the pipeline.</p>
        pub fn pipeline_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.pipeline_id(input);
            self
        }
        pub fn set_pipeline_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_pipeline_id(input);
            self
        }
        /// <p>The ID of the object.</p>
        pub fn object_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.object_id(input);
            self
        }
        pub fn set_object_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_object_id(input);
            self
        }
        /// <p>The expression to evaluate.</p>
        pub fn expression(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.expression(input);
            self
        }
        pub fn set_expression(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_expression(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetPipelineDefinition<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_pipeline_definition_input::Builder,
    }
    impl<C> GetPipelineDefinition<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetPipelineDefinitionOutput,
            smithy_http::result::SdkError<crate::error::GetPipelineDefinitionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the pipeline.</p>
        pub fn pipeline_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.pipeline_id(input);
            self
        }
        pub fn set_pipeline_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_pipeline_id(input);
            self
        }
        /// <p>The version of the pipeline definition to retrieve. Set this parameter to <code>latest</code> (default)
        /// to use the last definition saved to the pipeline or <code>active</code> to use the last definition  
        /// that was activated.</p>
        pub fn version(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.version(input);
            self
        }
        pub fn set_version(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_version(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListPipelines<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_pipelines_input::Builder,
    }
    impl<C> ListPipelines<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListPipelinesOutput,
            smithy_http::result::SdkError<crate::error::ListPipelinesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The starting point for the results to be returned. For the first call, this value should be empty.
        /// As long as there are more results, continue to call <code>ListPipelines</code> with
        /// the marker value from the previous call to retrieve the next set of results.</p>
        pub fn marker(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(input);
            self
        }
        pub fn set_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PollForTask<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::poll_for_task_input::Builder,
    }
    impl<C> PollForTask<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PollForTaskOutput,
            smithy_http::result::SdkError<crate::error::PollForTaskError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The type of task the task runner is configured to accept and process. The worker group is set as a field on objects in the pipeline when they are created.
        /// You can only specify a single value for <code>workerGroup</code> in the call to <code>PollForTask</code>. There are no wildcard values permitted in
        /// <code>workerGroup</code>; the string must be an exact, case-sensitive, match.</p>
        pub fn worker_group(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.worker_group(input);
            self
        }
        pub fn set_worker_group(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_worker_group(input);
            self
        }
        /// <p>The public DNS name of the calling task runner.</p>
        pub fn hostname(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.hostname(input);
            self
        }
        pub fn set_hostname(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_hostname(input);
            self
        }
        /// <p>Identity information for the EC2 instance that is hosting the task runner. You can get this value from the instance using <code>http://169.254.169.254/latest/meta-data/instance-id</code>. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/AESDG-chapter-instancedata.html">Instance Metadata</a> in the <i>Amazon Elastic Compute Cloud User Guide.</i> Passing in this value proves that your task runner is running on an EC2 instance, and ensures the proper AWS Data Pipeline service charges are applied to your pipeline.</p>
        pub fn instance_identity(mut self, input: crate::model::InstanceIdentity) -> Self {
            self.inner = self.inner.instance_identity(input);
            self
        }
        pub fn set_instance_identity(
            mut self,
            input: std::option::Option<crate::model::InstanceIdentity>,
        ) -> Self {
            self.inner = self.inner.set_instance_identity(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutPipelineDefinition<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::put_pipeline_definition_input::Builder,
    }
    impl<C> PutPipelineDefinition<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PutPipelineDefinitionOutput,
            smithy_http::result::SdkError<crate::error::PutPipelineDefinitionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the pipeline.</p>
        pub fn pipeline_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.pipeline_id(input);
            self
        }
        pub fn set_pipeline_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_pipeline_id(input);
            self
        }
        /// <p>The objects that define the pipeline. These objects overwrite the existing pipeline definition.</p>
        pub fn pipeline_objects(mut self, inp: impl Into<crate::model::PipelineObject>) -> Self {
            self.inner = self.inner.pipeline_objects(inp);
            self
        }
        pub fn set_pipeline_objects(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::PipelineObject>>,
        ) -> Self {
            self.inner = self.inner.set_pipeline_objects(input);
            self
        }
        /// <p>The parameter objects used with the pipeline.</p>
        pub fn parameter_objects(mut self, inp: impl Into<crate::model::ParameterObject>) -> Self {
            self.inner = self.inner.parameter_objects(inp);
            self
        }
        pub fn set_parameter_objects(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ParameterObject>>,
        ) -> Self {
            self.inner = self.inner.set_parameter_objects(input);
            self
        }
        /// <p>The parameter values used with the pipeline.</p>
        pub fn parameter_values(mut self, inp: impl Into<crate::model::ParameterValue>) -> Self {
            self.inner = self.inner.parameter_values(inp);
            self
        }
        pub fn set_parameter_values(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ParameterValue>>,
        ) -> Self {
            self.inner = self.inner.set_parameter_values(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct QueryObjects<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::query_objects_input::Builder,
    }
    impl<C> QueryObjects<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::QueryObjectsOutput,
            smithy_http::result::SdkError<crate::error::QueryObjectsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the pipeline.</p>
        pub fn pipeline_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.pipeline_id(input);
            self
        }
        pub fn set_pipeline_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_pipeline_id(input);
            self
        }
        /// <p>The query that defines the objects to be returned. The <code>Query</code> object can contain a maximum of ten selectors.
        /// The conditions in the query are limited to top-level String fields in the object.
        /// These filters can be applied to components, instances, and attempts.</p>
        pub fn query(mut self, input: crate::model::Query) -> Self {
            self.inner = self.inner.query(input);
            self
        }
        pub fn set_query(mut self, input: std::option::Option<crate::model::Query>) -> Self {
            self.inner = self.inner.set_query(input);
            self
        }
        /// <p>Indicates whether the query applies to components or instances. The possible values are:  
        /// <code>COMPONENT</code>, <code>INSTANCE</code>, and <code>ATTEMPT</code>.</p>
        pub fn sphere(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.sphere(input);
            self
        }
        pub fn set_sphere(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_sphere(input);
            self
        }
        /// <p>The starting point for the results to be returned. For the first call, this value should be empty.
        /// As long as there are more results, continue to call <code>QueryObjects</code> with
        /// the marker value from the previous call to retrieve the next set of results.</p>
        pub fn marker(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(input);
            self
        }
        pub fn set_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(input);
            self
        }
        /// <p>The maximum number of object names that <code>QueryObjects</code> will return in a single call. The default value is 100. </p>
        pub fn limit(mut self, input: i32) -> Self {
            self.inner = self.inner.limit(input);
            self
        }
        pub fn set_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_limit(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RemoveTags<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::remove_tags_input::Builder,
    }
    impl<C> RemoveTags<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::RemoveTagsOutput,
            smithy_http::result::SdkError<crate::error::RemoveTagsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the pipeline.</p>
        pub fn pipeline_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.pipeline_id(input);
            self
        }
        pub fn set_pipeline_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_pipeline_id(input);
            self
        }
        /// <p>The keys of the tags to remove.</p>
        pub fn tag_keys(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.tag_keys(inp);
            self
        }
        pub fn set_tag_keys(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_tag_keys(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ReportTaskProgress<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::report_task_progress_input::Builder,
    }
    impl<C> ReportTaskProgress<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ReportTaskProgressOutput,
            smithy_http::result::SdkError<crate::error::ReportTaskProgressError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the task assigned to the task runner. This value is provided in the response for <a>PollForTask</a>.</p>
        pub fn task_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.task_id(input);
            self
        }
        pub fn set_task_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_task_id(input);
            self
        }
        /// <p>Key-value pairs that define the properties of the ReportTaskProgressInput object.</p>
        pub fn fields(mut self, inp: impl Into<crate::model::Field>) -> Self {
            self.inner = self.inner.fields(inp);
            self
        }
        pub fn set_fields(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Field>>,
        ) -> Self {
            self.inner = self.inner.set_fields(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ReportTaskRunnerHeartbeat<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::report_task_runner_heartbeat_input::Builder,
    }
    impl<C> ReportTaskRunnerHeartbeat<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ReportTaskRunnerHeartbeatOutput,
            smithy_http::result::SdkError<crate::error::ReportTaskRunnerHeartbeatError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the task runner. This value should be unique across your AWS account. In the case of AWS Data Pipeline Task Runner
        /// launched on a resource managed by AWS Data Pipeline, the web service provides a unique identifier when it launches the application.
        /// If you have written a custom task runner, you should assign a unique identifier for the task runner.</p>
        pub fn taskrunner_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.taskrunner_id(input);
            self
        }
        pub fn set_taskrunner_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_taskrunner_id(input);
            self
        }
        /// <p>The type of task the task runner is configured to accept and process. The worker group is set as a field on objects in the pipeline when they are created.
        /// You can only specify a single value for <code>workerGroup</code>. There are no wildcard values permitted in <code>workerGroup</code>; the string
        /// must be an exact, case-sensitive, match.</p>
        pub fn worker_group(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.worker_group(input);
            self
        }
        pub fn set_worker_group(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_worker_group(input);
            self
        }
        /// <p>The public DNS name of the task runner.</p>
        pub fn hostname(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.hostname(input);
            self
        }
        pub fn set_hostname(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_hostname(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct SetStatus<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::set_status_input::Builder,
    }
    impl<C> SetStatus<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::SetStatusOutput,
            smithy_http::result::SdkError<crate::error::SetStatusError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the pipeline that contains the objects.</p>
        pub fn pipeline_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.pipeline_id(input);
            self
        }
        pub fn set_pipeline_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_pipeline_id(input);
            self
        }
        /// <p>The IDs of the objects. The corresponding objects can be either physical or components, but not a mix of both types.</p>
        pub fn object_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.object_ids(inp);
            self
        }
        pub fn set_object_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_object_ids(input);
            self
        }
        /// <p>The status to be set on all the objects specified in <code>objectIds</code>. For components, use <code>PAUSE</code> or <code>RESUME</code>.
        /// For instances, use <code>TRY_CANCEL</code>, <code>RERUN</code>, or <code>MARK_FINISHED</code>.</p>
        pub fn status(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.status(input);
            self
        }
        pub fn set_status(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_status(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct SetTaskStatus<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::set_task_status_input::Builder,
    }
    impl<C> SetTaskStatus<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::SetTaskStatusOutput,
            smithy_http::result::SdkError<crate::error::SetTaskStatusError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the task assigned to the task runner. This value is provided in the response for <a>PollForTask</a>.</p>
        pub fn task_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.task_id(input);
            self
        }
        pub fn set_task_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_task_id(input);
            self
        }
        /// <p>If <code>FINISHED</code>, the task successfully completed. If <code>FAILED</code>, the task ended unsuccessfully. Preconditions use false.</p>
        pub fn task_status(mut self, input: crate::model::TaskStatus) -> Self {
            self.inner = self.inner.task_status(input);
            self
        }
        pub fn set_task_status(
            mut self,
            input: std::option::Option<crate::model::TaskStatus>,
        ) -> Self {
            self.inner = self.inner.set_task_status(input);
            self
        }
        /// <p>If an error occurred during the task, this value specifies the error code. This value is set on the physical attempt object.
        /// It is used to display error information to the user. It should not start with string "Service_" which is reserved by the system.</p>
        pub fn error_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.error_id(input);
            self
        }
        pub fn set_error_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_error_id(input);
            self
        }
        /// <p>If an error occurred during the task, this value specifies a text description of the error. This value is set on the physical attempt object.
        /// It is used to display error information to the user. The web service does not parse this value.</p>
        pub fn error_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.error_message(input);
            self
        }
        pub fn set_error_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_error_message(input);
            self
        }
        /// <p>If an error occurred during the task, this value specifies the stack trace associated with the error. This value is set on the physical attempt object.
        /// It is used to display error information to the user. The web service does not parse this value.</p>
        pub fn error_stack_trace(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.error_stack_trace(input);
            self
        }
        pub fn set_error_stack_trace(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_error_stack_trace(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ValidatePipelineDefinition<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::validate_pipeline_definition_input::Builder,
    }
    impl<C> ValidatePipelineDefinition<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ValidatePipelineDefinitionOutput,
            smithy_http::result::SdkError<crate::error::ValidatePipelineDefinitionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the pipeline.</p>
        pub fn pipeline_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.pipeline_id(input);
            self
        }
        pub fn set_pipeline_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_pipeline_id(input);
            self
        }
        /// <p>The objects that define the pipeline changes to validate against the pipeline.</p>
        pub fn pipeline_objects(mut self, inp: impl Into<crate::model::PipelineObject>) -> Self {
            self.inner = self.inner.pipeline_objects(inp);
            self
        }
        pub fn set_pipeline_objects(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::PipelineObject>>,
        ) -> Self {
            self.inner = self.inner.set_pipeline_objects(input);
            self
        }
        /// <p>The parameter objects used with the pipeline.</p>
        pub fn parameter_objects(mut self, inp: impl Into<crate::model::ParameterObject>) -> Self {
            self.inner = self.inner.parameter_objects(inp);
            self
        }
        pub fn set_parameter_objects(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ParameterObject>>,
        ) -> Self {
            self.inner = self.inner.set_parameter_objects(input);
            self
        }
        /// <p>The parameter values used with the pipeline.</p>
        pub fn parameter_values(mut self, inp: impl Into<crate::model::ParameterValue>) -> Self {
            self.inner = self.inner.parameter_values(inp);
            self
        }
        pub fn set_parameter_values(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ParameterValue>>,
        ) -> Self {
            self.inner = self.inner.set_parameter_values(input);
            self
        }
    }
}
