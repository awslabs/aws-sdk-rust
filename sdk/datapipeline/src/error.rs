// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ActivatePipelineError {
    pub kind: ActivatePipelineErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ActivatePipelineErrorKind {
    InternalServiceError(crate::error::InternalServiceError),
    InvalidRequestException(crate::error::InvalidRequestException),
    PipelineDeletedException(crate::error::PipelineDeletedException),
    PipelineNotFoundException(crate::error::PipelineNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ActivatePipelineError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ActivatePipelineErrorKind::InternalServiceError(_inner) => _inner.fmt(f),
            ActivatePipelineErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ActivatePipelineErrorKind::PipelineDeletedException(_inner) => _inner.fmt(f),
            ActivatePipelineErrorKind::PipelineNotFoundException(_inner) => _inner.fmt(f),
            ActivatePipelineErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ActivatePipelineError {
    fn code(&self) -> Option<&str> {
        ActivatePipelineError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ActivatePipelineError {
    pub fn new(kind: ActivatePipelineErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ActivatePipelineErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ActivatePipelineErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_error(&self) -> bool {
        matches!(
            &self.kind,
            ActivatePipelineErrorKind::InternalServiceError(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ActivatePipelineErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_pipeline_deleted_exception(&self) -> bool {
        matches!(
            &self.kind,
            ActivatePipelineErrorKind::PipelineDeletedException(_)
        )
    }
    pub fn is_pipeline_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ActivatePipelineErrorKind::PipelineNotFoundException(_)
        )
    }
}
impl std::error::Error for ActivatePipelineError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ActivatePipelineErrorKind::InternalServiceError(_inner) => Some(_inner),
            ActivatePipelineErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ActivatePipelineErrorKind::PipelineDeletedException(_inner) => Some(_inner),
            ActivatePipelineErrorKind::PipelineNotFoundException(_inner) => Some(_inner),
            ActivatePipelineErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AddTagsError {
    pub kind: AddTagsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AddTagsErrorKind {
    InternalServiceError(crate::error::InternalServiceError),
    InvalidRequestException(crate::error::InvalidRequestException),
    PipelineDeletedException(crate::error::PipelineDeletedException),
    PipelineNotFoundException(crate::error::PipelineNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AddTagsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AddTagsErrorKind::InternalServiceError(_inner) => _inner.fmt(f),
            AddTagsErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            AddTagsErrorKind::PipelineDeletedException(_inner) => _inner.fmt(f),
            AddTagsErrorKind::PipelineNotFoundException(_inner) => _inner.fmt(f),
            AddTagsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AddTagsError {
    fn code(&self) -> Option<&str> {
        AddTagsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AddTagsError {
    pub fn new(kind: AddTagsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AddTagsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AddTagsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_error(&self) -> bool {
        matches!(&self.kind, AddTagsErrorKind::InternalServiceError(_))
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(&self.kind, AddTagsErrorKind::InvalidRequestException(_))
    }
    pub fn is_pipeline_deleted_exception(&self) -> bool {
        matches!(&self.kind, AddTagsErrorKind::PipelineDeletedException(_))
    }
    pub fn is_pipeline_not_found_exception(&self) -> bool {
        matches!(&self.kind, AddTagsErrorKind::PipelineNotFoundException(_))
    }
}
impl std::error::Error for AddTagsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AddTagsErrorKind::InternalServiceError(_inner) => Some(_inner),
            AddTagsErrorKind::InvalidRequestException(_inner) => Some(_inner),
            AddTagsErrorKind::PipelineDeletedException(_inner) => Some(_inner),
            AddTagsErrorKind::PipelineNotFoundException(_inner) => Some(_inner),
            AddTagsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreatePipelineError {
    pub kind: CreatePipelineErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreatePipelineErrorKind {
    InternalServiceError(crate::error::InternalServiceError),
    InvalidRequestException(crate::error::InvalidRequestException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreatePipelineError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreatePipelineErrorKind::InternalServiceError(_inner) => _inner.fmt(f),
            CreatePipelineErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            CreatePipelineErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreatePipelineError {
    fn code(&self) -> Option<&str> {
        CreatePipelineError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreatePipelineError {
    pub fn new(kind: CreatePipelineErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreatePipelineErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreatePipelineErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_error(&self) -> bool {
        matches!(&self.kind, CreatePipelineErrorKind::InternalServiceError(_))
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePipelineErrorKind::InvalidRequestException(_)
        )
    }
}
impl std::error::Error for CreatePipelineError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreatePipelineErrorKind::InternalServiceError(_inner) => Some(_inner),
            CreatePipelineErrorKind::InvalidRequestException(_inner) => Some(_inner),
            CreatePipelineErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeactivatePipelineError {
    pub kind: DeactivatePipelineErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeactivatePipelineErrorKind {
    InternalServiceError(crate::error::InternalServiceError),
    InvalidRequestException(crate::error::InvalidRequestException),
    PipelineDeletedException(crate::error::PipelineDeletedException),
    PipelineNotFoundException(crate::error::PipelineNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeactivatePipelineError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeactivatePipelineErrorKind::InternalServiceError(_inner) => _inner.fmt(f),
            DeactivatePipelineErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DeactivatePipelineErrorKind::PipelineDeletedException(_inner) => _inner.fmt(f),
            DeactivatePipelineErrorKind::PipelineNotFoundException(_inner) => _inner.fmt(f),
            DeactivatePipelineErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeactivatePipelineError {
    fn code(&self) -> Option<&str> {
        DeactivatePipelineError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeactivatePipelineError {
    pub fn new(kind: DeactivatePipelineErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeactivatePipelineErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeactivatePipelineErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_error(&self) -> bool {
        matches!(
            &self.kind,
            DeactivatePipelineErrorKind::InternalServiceError(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeactivatePipelineErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_pipeline_deleted_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeactivatePipelineErrorKind::PipelineDeletedException(_)
        )
    }
    pub fn is_pipeline_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeactivatePipelineErrorKind::PipelineNotFoundException(_)
        )
    }
}
impl std::error::Error for DeactivatePipelineError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeactivatePipelineErrorKind::InternalServiceError(_inner) => Some(_inner),
            DeactivatePipelineErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DeactivatePipelineErrorKind::PipelineDeletedException(_inner) => Some(_inner),
            DeactivatePipelineErrorKind::PipelineNotFoundException(_inner) => Some(_inner),
            DeactivatePipelineErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeletePipelineError {
    pub kind: DeletePipelineErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeletePipelineErrorKind {
    InternalServiceError(crate::error::InternalServiceError),
    InvalidRequestException(crate::error::InvalidRequestException),
    PipelineNotFoundException(crate::error::PipelineNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeletePipelineError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeletePipelineErrorKind::InternalServiceError(_inner) => _inner.fmt(f),
            DeletePipelineErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DeletePipelineErrorKind::PipelineNotFoundException(_inner) => _inner.fmt(f),
            DeletePipelineErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeletePipelineError {
    fn code(&self) -> Option<&str> {
        DeletePipelineError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeletePipelineError {
    pub fn new(kind: DeletePipelineErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeletePipelineErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeletePipelineErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_error(&self) -> bool {
        matches!(&self.kind, DeletePipelineErrorKind::InternalServiceError(_))
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeletePipelineErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_pipeline_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeletePipelineErrorKind::PipelineNotFoundException(_)
        )
    }
}
impl std::error::Error for DeletePipelineError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeletePipelineErrorKind::InternalServiceError(_inner) => Some(_inner),
            DeletePipelineErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DeletePipelineErrorKind::PipelineNotFoundException(_inner) => Some(_inner),
            DeletePipelineErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeObjectsError {
    pub kind: DescribeObjectsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeObjectsErrorKind {
    InternalServiceError(crate::error::InternalServiceError),
    InvalidRequestException(crate::error::InvalidRequestException),
    PipelineDeletedException(crate::error::PipelineDeletedException),
    PipelineNotFoundException(crate::error::PipelineNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeObjectsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeObjectsErrorKind::InternalServiceError(_inner) => _inner.fmt(f),
            DescribeObjectsErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DescribeObjectsErrorKind::PipelineDeletedException(_inner) => _inner.fmt(f),
            DescribeObjectsErrorKind::PipelineNotFoundException(_inner) => _inner.fmt(f),
            DescribeObjectsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeObjectsError {
    fn code(&self) -> Option<&str> {
        DescribeObjectsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeObjectsError {
    pub fn new(kind: DescribeObjectsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeObjectsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeObjectsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeObjectsErrorKind::InternalServiceError(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeObjectsErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_pipeline_deleted_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeObjectsErrorKind::PipelineDeletedException(_)
        )
    }
    pub fn is_pipeline_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeObjectsErrorKind::PipelineNotFoundException(_)
        )
    }
}
impl std::error::Error for DescribeObjectsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeObjectsErrorKind::InternalServiceError(_inner) => Some(_inner),
            DescribeObjectsErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DescribeObjectsErrorKind::PipelineDeletedException(_inner) => Some(_inner),
            DescribeObjectsErrorKind::PipelineNotFoundException(_inner) => Some(_inner),
            DescribeObjectsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribePipelinesError {
    pub kind: DescribePipelinesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribePipelinesErrorKind {
    InternalServiceError(crate::error::InternalServiceError),
    InvalidRequestException(crate::error::InvalidRequestException),
    PipelineDeletedException(crate::error::PipelineDeletedException),
    PipelineNotFoundException(crate::error::PipelineNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribePipelinesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribePipelinesErrorKind::InternalServiceError(_inner) => _inner.fmt(f),
            DescribePipelinesErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DescribePipelinesErrorKind::PipelineDeletedException(_inner) => _inner.fmt(f),
            DescribePipelinesErrorKind::PipelineNotFoundException(_inner) => _inner.fmt(f),
            DescribePipelinesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribePipelinesError {
    fn code(&self) -> Option<&str> {
        DescribePipelinesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribePipelinesError {
    pub fn new(kind: DescribePipelinesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribePipelinesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribePipelinesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribePipelinesErrorKind::InternalServiceError(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribePipelinesErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_pipeline_deleted_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribePipelinesErrorKind::PipelineDeletedException(_)
        )
    }
    pub fn is_pipeline_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribePipelinesErrorKind::PipelineNotFoundException(_)
        )
    }
}
impl std::error::Error for DescribePipelinesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribePipelinesErrorKind::InternalServiceError(_inner) => Some(_inner),
            DescribePipelinesErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DescribePipelinesErrorKind::PipelineDeletedException(_inner) => Some(_inner),
            DescribePipelinesErrorKind::PipelineNotFoundException(_inner) => Some(_inner),
            DescribePipelinesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct EvaluateExpressionError {
    pub kind: EvaluateExpressionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum EvaluateExpressionErrorKind {
    InternalServiceError(crate::error::InternalServiceError),
    InvalidRequestException(crate::error::InvalidRequestException),
    PipelineDeletedException(crate::error::PipelineDeletedException),
    PipelineNotFoundException(crate::error::PipelineNotFoundException),
    TaskNotFoundException(crate::error::TaskNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for EvaluateExpressionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            EvaluateExpressionErrorKind::InternalServiceError(_inner) => _inner.fmt(f),
            EvaluateExpressionErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            EvaluateExpressionErrorKind::PipelineDeletedException(_inner) => _inner.fmt(f),
            EvaluateExpressionErrorKind::PipelineNotFoundException(_inner) => _inner.fmt(f),
            EvaluateExpressionErrorKind::TaskNotFoundException(_inner) => _inner.fmt(f),
            EvaluateExpressionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for EvaluateExpressionError {
    fn code(&self) -> Option<&str> {
        EvaluateExpressionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl EvaluateExpressionError {
    pub fn new(kind: EvaluateExpressionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: EvaluateExpressionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: EvaluateExpressionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_error(&self) -> bool {
        matches!(
            &self.kind,
            EvaluateExpressionErrorKind::InternalServiceError(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            EvaluateExpressionErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_pipeline_deleted_exception(&self) -> bool {
        matches!(
            &self.kind,
            EvaluateExpressionErrorKind::PipelineDeletedException(_)
        )
    }
    pub fn is_pipeline_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            EvaluateExpressionErrorKind::PipelineNotFoundException(_)
        )
    }
    pub fn is_task_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            EvaluateExpressionErrorKind::TaskNotFoundException(_)
        )
    }
}
impl std::error::Error for EvaluateExpressionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            EvaluateExpressionErrorKind::InternalServiceError(_inner) => Some(_inner),
            EvaluateExpressionErrorKind::InvalidRequestException(_inner) => Some(_inner),
            EvaluateExpressionErrorKind::PipelineDeletedException(_inner) => Some(_inner),
            EvaluateExpressionErrorKind::PipelineNotFoundException(_inner) => Some(_inner),
            EvaluateExpressionErrorKind::TaskNotFoundException(_inner) => Some(_inner),
            EvaluateExpressionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetPipelineDefinitionError {
    pub kind: GetPipelineDefinitionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetPipelineDefinitionErrorKind {
    InternalServiceError(crate::error::InternalServiceError),
    InvalidRequestException(crate::error::InvalidRequestException),
    PipelineDeletedException(crate::error::PipelineDeletedException),
    PipelineNotFoundException(crate::error::PipelineNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetPipelineDefinitionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetPipelineDefinitionErrorKind::InternalServiceError(_inner) => _inner.fmt(f),
            GetPipelineDefinitionErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            GetPipelineDefinitionErrorKind::PipelineDeletedException(_inner) => _inner.fmt(f),
            GetPipelineDefinitionErrorKind::PipelineNotFoundException(_inner) => _inner.fmt(f),
            GetPipelineDefinitionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetPipelineDefinitionError {
    fn code(&self) -> Option<&str> {
        GetPipelineDefinitionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetPipelineDefinitionError {
    pub fn new(kind: GetPipelineDefinitionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetPipelineDefinitionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetPipelineDefinitionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_error(&self) -> bool {
        matches!(
            &self.kind,
            GetPipelineDefinitionErrorKind::InternalServiceError(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPipelineDefinitionErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_pipeline_deleted_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPipelineDefinitionErrorKind::PipelineDeletedException(_)
        )
    }
    pub fn is_pipeline_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPipelineDefinitionErrorKind::PipelineNotFoundException(_)
        )
    }
}
impl std::error::Error for GetPipelineDefinitionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetPipelineDefinitionErrorKind::InternalServiceError(_inner) => Some(_inner),
            GetPipelineDefinitionErrorKind::InvalidRequestException(_inner) => Some(_inner),
            GetPipelineDefinitionErrorKind::PipelineDeletedException(_inner) => Some(_inner),
            GetPipelineDefinitionErrorKind::PipelineNotFoundException(_inner) => Some(_inner),
            GetPipelineDefinitionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListPipelinesError {
    pub kind: ListPipelinesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListPipelinesErrorKind {
    InternalServiceError(crate::error::InternalServiceError),
    InvalidRequestException(crate::error::InvalidRequestException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListPipelinesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListPipelinesErrorKind::InternalServiceError(_inner) => _inner.fmt(f),
            ListPipelinesErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListPipelinesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListPipelinesError {
    fn code(&self) -> Option<&str> {
        ListPipelinesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListPipelinesError {
    pub fn new(kind: ListPipelinesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListPipelinesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListPipelinesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_error(&self) -> bool {
        matches!(&self.kind, ListPipelinesErrorKind::InternalServiceError(_))
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPipelinesErrorKind::InvalidRequestException(_)
        )
    }
}
impl std::error::Error for ListPipelinesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListPipelinesErrorKind::InternalServiceError(_inner) => Some(_inner),
            ListPipelinesErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListPipelinesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PollForTaskError {
    pub kind: PollForTaskErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PollForTaskErrorKind {
    InternalServiceError(crate::error::InternalServiceError),
    InvalidRequestException(crate::error::InvalidRequestException),
    TaskNotFoundException(crate::error::TaskNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PollForTaskError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PollForTaskErrorKind::InternalServiceError(_inner) => _inner.fmt(f),
            PollForTaskErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            PollForTaskErrorKind::TaskNotFoundException(_inner) => _inner.fmt(f),
            PollForTaskErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PollForTaskError {
    fn code(&self) -> Option<&str> {
        PollForTaskError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PollForTaskError {
    pub fn new(kind: PollForTaskErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PollForTaskErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PollForTaskErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_error(&self) -> bool {
        matches!(&self.kind, PollForTaskErrorKind::InternalServiceError(_))
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(&self.kind, PollForTaskErrorKind::InvalidRequestException(_))
    }
    pub fn is_task_not_found_exception(&self) -> bool {
        matches!(&self.kind, PollForTaskErrorKind::TaskNotFoundException(_))
    }
}
impl std::error::Error for PollForTaskError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PollForTaskErrorKind::InternalServiceError(_inner) => Some(_inner),
            PollForTaskErrorKind::InvalidRequestException(_inner) => Some(_inner),
            PollForTaskErrorKind::TaskNotFoundException(_inner) => Some(_inner),
            PollForTaskErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutPipelineDefinitionError {
    pub kind: PutPipelineDefinitionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutPipelineDefinitionErrorKind {
    InternalServiceError(crate::error::InternalServiceError),
    InvalidRequestException(crate::error::InvalidRequestException),
    PipelineDeletedException(crate::error::PipelineDeletedException),
    PipelineNotFoundException(crate::error::PipelineNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutPipelineDefinitionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutPipelineDefinitionErrorKind::InternalServiceError(_inner) => _inner.fmt(f),
            PutPipelineDefinitionErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            PutPipelineDefinitionErrorKind::PipelineDeletedException(_inner) => _inner.fmt(f),
            PutPipelineDefinitionErrorKind::PipelineNotFoundException(_inner) => _inner.fmt(f),
            PutPipelineDefinitionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutPipelineDefinitionError {
    fn code(&self) -> Option<&str> {
        PutPipelineDefinitionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutPipelineDefinitionError {
    pub fn new(kind: PutPipelineDefinitionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutPipelineDefinitionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutPipelineDefinitionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_error(&self) -> bool {
        matches!(
            &self.kind,
            PutPipelineDefinitionErrorKind::InternalServiceError(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutPipelineDefinitionErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_pipeline_deleted_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutPipelineDefinitionErrorKind::PipelineDeletedException(_)
        )
    }
    pub fn is_pipeline_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutPipelineDefinitionErrorKind::PipelineNotFoundException(_)
        )
    }
}
impl std::error::Error for PutPipelineDefinitionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutPipelineDefinitionErrorKind::InternalServiceError(_inner) => Some(_inner),
            PutPipelineDefinitionErrorKind::InvalidRequestException(_inner) => Some(_inner),
            PutPipelineDefinitionErrorKind::PipelineDeletedException(_inner) => Some(_inner),
            PutPipelineDefinitionErrorKind::PipelineNotFoundException(_inner) => Some(_inner),
            PutPipelineDefinitionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct QueryObjectsError {
    pub kind: QueryObjectsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum QueryObjectsErrorKind {
    InternalServiceError(crate::error::InternalServiceError),
    InvalidRequestException(crate::error::InvalidRequestException),
    PipelineDeletedException(crate::error::PipelineDeletedException),
    PipelineNotFoundException(crate::error::PipelineNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for QueryObjectsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            QueryObjectsErrorKind::InternalServiceError(_inner) => _inner.fmt(f),
            QueryObjectsErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            QueryObjectsErrorKind::PipelineDeletedException(_inner) => _inner.fmt(f),
            QueryObjectsErrorKind::PipelineNotFoundException(_inner) => _inner.fmt(f),
            QueryObjectsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for QueryObjectsError {
    fn code(&self) -> Option<&str> {
        QueryObjectsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl QueryObjectsError {
    pub fn new(kind: QueryObjectsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: QueryObjectsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: QueryObjectsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_error(&self) -> bool {
        matches!(&self.kind, QueryObjectsErrorKind::InternalServiceError(_))
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            QueryObjectsErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_pipeline_deleted_exception(&self) -> bool {
        matches!(
            &self.kind,
            QueryObjectsErrorKind::PipelineDeletedException(_)
        )
    }
    pub fn is_pipeline_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            QueryObjectsErrorKind::PipelineNotFoundException(_)
        )
    }
}
impl std::error::Error for QueryObjectsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            QueryObjectsErrorKind::InternalServiceError(_inner) => Some(_inner),
            QueryObjectsErrorKind::InvalidRequestException(_inner) => Some(_inner),
            QueryObjectsErrorKind::PipelineDeletedException(_inner) => Some(_inner),
            QueryObjectsErrorKind::PipelineNotFoundException(_inner) => Some(_inner),
            QueryObjectsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RemoveTagsError {
    pub kind: RemoveTagsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RemoveTagsErrorKind {
    InternalServiceError(crate::error::InternalServiceError),
    InvalidRequestException(crate::error::InvalidRequestException),
    PipelineDeletedException(crate::error::PipelineDeletedException),
    PipelineNotFoundException(crate::error::PipelineNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RemoveTagsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RemoveTagsErrorKind::InternalServiceError(_inner) => _inner.fmt(f),
            RemoveTagsErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            RemoveTagsErrorKind::PipelineDeletedException(_inner) => _inner.fmt(f),
            RemoveTagsErrorKind::PipelineNotFoundException(_inner) => _inner.fmt(f),
            RemoveTagsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RemoveTagsError {
    fn code(&self) -> Option<&str> {
        RemoveTagsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RemoveTagsError {
    pub fn new(kind: RemoveTagsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RemoveTagsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RemoveTagsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_error(&self) -> bool {
        matches!(&self.kind, RemoveTagsErrorKind::InternalServiceError(_))
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(&self.kind, RemoveTagsErrorKind::InvalidRequestException(_))
    }
    pub fn is_pipeline_deleted_exception(&self) -> bool {
        matches!(&self.kind, RemoveTagsErrorKind::PipelineDeletedException(_))
    }
    pub fn is_pipeline_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            RemoveTagsErrorKind::PipelineNotFoundException(_)
        )
    }
}
impl std::error::Error for RemoveTagsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RemoveTagsErrorKind::InternalServiceError(_inner) => Some(_inner),
            RemoveTagsErrorKind::InvalidRequestException(_inner) => Some(_inner),
            RemoveTagsErrorKind::PipelineDeletedException(_inner) => Some(_inner),
            RemoveTagsErrorKind::PipelineNotFoundException(_inner) => Some(_inner),
            RemoveTagsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ReportTaskProgressError {
    pub kind: ReportTaskProgressErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ReportTaskProgressErrorKind {
    InternalServiceError(crate::error::InternalServiceError),
    InvalidRequestException(crate::error::InvalidRequestException),
    PipelineDeletedException(crate::error::PipelineDeletedException),
    PipelineNotFoundException(crate::error::PipelineNotFoundException),
    TaskNotFoundException(crate::error::TaskNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ReportTaskProgressError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ReportTaskProgressErrorKind::InternalServiceError(_inner) => _inner.fmt(f),
            ReportTaskProgressErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ReportTaskProgressErrorKind::PipelineDeletedException(_inner) => _inner.fmt(f),
            ReportTaskProgressErrorKind::PipelineNotFoundException(_inner) => _inner.fmt(f),
            ReportTaskProgressErrorKind::TaskNotFoundException(_inner) => _inner.fmt(f),
            ReportTaskProgressErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ReportTaskProgressError {
    fn code(&self) -> Option<&str> {
        ReportTaskProgressError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ReportTaskProgressError {
    pub fn new(kind: ReportTaskProgressErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ReportTaskProgressErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ReportTaskProgressErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_error(&self) -> bool {
        matches!(
            &self.kind,
            ReportTaskProgressErrorKind::InternalServiceError(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ReportTaskProgressErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_pipeline_deleted_exception(&self) -> bool {
        matches!(
            &self.kind,
            ReportTaskProgressErrorKind::PipelineDeletedException(_)
        )
    }
    pub fn is_pipeline_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ReportTaskProgressErrorKind::PipelineNotFoundException(_)
        )
    }
    pub fn is_task_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ReportTaskProgressErrorKind::TaskNotFoundException(_)
        )
    }
}
impl std::error::Error for ReportTaskProgressError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ReportTaskProgressErrorKind::InternalServiceError(_inner) => Some(_inner),
            ReportTaskProgressErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ReportTaskProgressErrorKind::PipelineDeletedException(_inner) => Some(_inner),
            ReportTaskProgressErrorKind::PipelineNotFoundException(_inner) => Some(_inner),
            ReportTaskProgressErrorKind::TaskNotFoundException(_inner) => Some(_inner),
            ReportTaskProgressErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ReportTaskRunnerHeartbeatError {
    pub kind: ReportTaskRunnerHeartbeatErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ReportTaskRunnerHeartbeatErrorKind {
    InternalServiceError(crate::error::InternalServiceError),
    InvalidRequestException(crate::error::InvalidRequestException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ReportTaskRunnerHeartbeatError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ReportTaskRunnerHeartbeatErrorKind::InternalServiceError(_inner) => _inner.fmt(f),
            ReportTaskRunnerHeartbeatErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ReportTaskRunnerHeartbeatErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ReportTaskRunnerHeartbeatError {
    fn code(&self) -> Option<&str> {
        ReportTaskRunnerHeartbeatError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ReportTaskRunnerHeartbeatError {
    pub fn new(kind: ReportTaskRunnerHeartbeatErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ReportTaskRunnerHeartbeatErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ReportTaskRunnerHeartbeatErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_error(&self) -> bool {
        matches!(
            &self.kind,
            ReportTaskRunnerHeartbeatErrorKind::InternalServiceError(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ReportTaskRunnerHeartbeatErrorKind::InvalidRequestException(_)
        )
    }
}
impl std::error::Error for ReportTaskRunnerHeartbeatError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ReportTaskRunnerHeartbeatErrorKind::InternalServiceError(_inner) => Some(_inner),
            ReportTaskRunnerHeartbeatErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ReportTaskRunnerHeartbeatErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct SetStatusError {
    pub kind: SetStatusErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum SetStatusErrorKind {
    InternalServiceError(crate::error::InternalServiceError),
    InvalidRequestException(crate::error::InvalidRequestException),
    PipelineDeletedException(crate::error::PipelineDeletedException),
    PipelineNotFoundException(crate::error::PipelineNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for SetStatusError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            SetStatusErrorKind::InternalServiceError(_inner) => _inner.fmt(f),
            SetStatusErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            SetStatusErrorKind::PipelineDeletedException(_inner) => _inner.fmt(f),
            SetStatusErrorKind::PipelineNotFoundException(_inner) => _inner.fmt(f),
            SetStatusErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for SetStatusError {
    fn code(&self) -> Option<&str> {
        SetStatusError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl SetStatusError {
    pub fn new(kind: SetStatusErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: SetStatusErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: SetStatusErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_error(&self) -> bool {
        matches!(&self.kind, SetStatusErrorKind::InternalServiceError(_))
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(&self.kind, SetStatusErrorKind::InvalidRequestException(_))
    }
    pub fn is_pipeline_deleted_exception(&self) -> bool {
        matches!(&self.kind, SetStatusErrorKind::PipelineDeletedException(_))
    }
    pub fn is_pipeline_not_found_exception(&self) -> bool {
        matches!(&self.kind, SetStatusErrorKind::PipelineNotFoundException(_))
    }
}
impl std::error::Error for SetStatusError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            SetStatusErrorKind::InternalServiceError(_inner) => Some(_inner),
            SetStatusErrorKind::InvalidRequestException(_inner) => Some(_inner),
            SetStatusErrorKind::PipelineDeletedException(_inner) => Some(_inner),
            SetStatusErrorKind::PipelineNotFoundException(_inner) => Some(_inner),
            SetStatusErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct SetTaskStatusError {
    pub kind: SetTaskStatusErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum SetTaskStatusErrorKind {
    InternalServiceError(crate::error::InternalServiceError),
    InvalidRequestException(crate::error::InvalidRequestException),
    PipelineDeletedException(crate::error::PipelineDeletedException),
    PipelineNotFoundException(crate::error::PipelineNotFoundException),
    TaskNotFoundException(crate::error::TaskNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for SetTaskStatusError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            SetTaskStatusErrorKind::InternalServiceError(_inner) => _inner.fmt(f),
            SetTaskStatusErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            SetTaskStatusErrorKind::PipelineDeletedException(_inner) => _inner.fmt(f),
            SetTaskStatusErrorKind::PipelineNotFoundException(_inner) => _inner.fmt(f),
            SetTaskStatusErrorKind::TaskNotFoundException(_inner) => _inner.fmt(f),
            SetTaskStatusErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for SetTaskStatusError {
    fn code(&self) -> Option<&str> {
        SetTaskStatusError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl SetTaskStatusError {
    pub fn new(kind: SetTaskStatusErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: SetTaskStatusErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: SetTaskStatusErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_error(&self) -> bool {
        matches!(&self.kind, SetTaskStatusErrorKind::InternalServiceError(_))
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            SetTaskStatusErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_pipeline_deleted_exception(&self) -> bool {
        matches!(
            &self.kind,
            SetTaskStatusErrorKind::PipelineDeletedException(_)
        )
    }
    pub fn is_pipeline_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            SetTaskStatusErrorKind::PipelineNotFoundException(_)
        )
    }
    pub fn is_task_not_found_exception(&self) -> bool {
        matches!(&self.kind, SetTaskStatusErrorKind::TaskNotFoundException(_))
    }
}
impl std::error::Error for SetTaskStatusError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            SetTaskStatusErrorKind::InternalServiceError(_inner) => Some(_inner),
            SetTaskStatusErrorKind::InvalidRequestException(_inner) => Some(_inner),
            SetTaskStatusErrorKind::PipelineDeletedException(_inner) => Some(_inner),
            SetTaskStatusErrorKind::PipelineNotFoundException(_inner) => Some(_inner),
            SetTaskStatusErrorKind::TaskNotFoundException(_inner) => Some(_inner),
            SetTaskStatusErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ValidatePipelineDefinitionError {
    pub kind: ValidatePipelineDefinitionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ValidatePipelineDefinitionErrorKind {
    InternalServiceError(crate::error::InternalServiceError),
    InvalidRequestException(crate::error::InvalidRequestException),
    PipelineDeletedException(crate::error::PipelineDeletedException),
    PipelineNotFoundException(crate::error::PipelineNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ValidatePipelineDefinitionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ValidatePipelineDefinitionErrorKind::InternalServiceError(_inner) => _inner.fmt(f),
            ValidatePipelineDefinitionErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ValidatePipelineDefinitionErrorKind::PipelineDeletedException(_inner) => _inner.fmt(f),
            ValidatePipelineDefinitionErrorKind::PipelineNotFoundException(_inner) => _inner.fmt(f),
            ValidatePipelineDefinitionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ValidatePipelineDefinitionError {
    fn code(&self) -> Option<&str> {
        ValidatePipelineDefinitionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ValidatePipelineDefinitionError {
    pub fn new(kind: ValidatePipelineDefinitionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ValidatePipelineDefinitionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ValidatePipelineDefinitionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_error(&self) -> bool {
        matches!(
            &self.kind,
            ValidatePipelineDefinitionErrorKind::InternalServiceError(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ValidatePipelineDefinitionErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_pipeline_deleted_exception(&self) -> bool {
        matches!(
            &self.kind,
            ValidatePipelineDefinitionErrorKind::PipelineDeletedException(_)
        )
    }
    pub fn is_pipeline_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ValidatePipelineDefinitionErrorKind::PipelineNotFoundException(_)
        )
    }
}
impl std::error::Error for ValidatePipelineDefinitionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ValidatePipelineDefinitionErrorKind::InternalServiceError(_inner) => Some(_inner),
            ValidatePipelineDefinitionErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ValidatePipelineDefinitionErrorKind::PipelineDeletedException(_inner) => Some(_inner),
            ValidatePipelineDefinitionErrorKind::PipelineNotFoundException(_inner) => Some(_inner),
            ValidatePipelineDefinitionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// <p>The specified pipeline was not found. Verify that you used the correct user and account identifiers.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PipelineNotFoundException {
    /// <p>Description of the error message.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PipelineNotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PipelineNotFoundException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl PipelineNotFoundException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for PipelineNotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "PipelineNotFoundException")?;
        if let Some(inner_1) = &self.message {
            write!(f, ": {}", inner_1)?;
        }
        Ok(())
    }
}
impl std::error::Error for PipelineNotFoundException {}
/// See [`PipelineNotFoundException`](crate::error::PipelineNotFoundException)
pub mod pipeline_not_found_exception {
    /// A builder for [`PipelineNotFoundException`](crate::error::PipelineNotFoundException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Description of the error message.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`PipelineNotFoundException`](crate::error::PipelineNotFoundException)
        pub fn build(self) -> crate::error::PipelineNotFoundException {
            crate::error::PipelineNotFoundException {
                message: self.message,
            }
        }
    }
}
impl PipelineNotFoundException {
    /// Creates a new builder-style object to manufacture [`PipelineNotFoundException`](crate::error::PipelineNotFoundException)
    pub fn builder() -> crate::error::pipeline_not_found_exception::Builder {
        crate::error::pipeline_not_found_exception::Builder::default()
    }
}

/// <p>The specified pipeline has been deleted.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PipelineDeletedException {
    /// <p>Description of the error message.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PipelineDeletedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PipelineDeletedException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl PipelineDeletedException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for PipelineDeletedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "PipelineDeletedException")?;
        if let Some(inner_2) = &self.message {
            write!(f, ": {}", inner_2)?;
        }
        Ok(())
    }
}
impl std::error::Error for PipelineDeletedException {}
/// See [`PipelineDeletedException`](crate::error::PipelineDeletedException)
pub mod pipeline_deleted_exception {
    /// A builder for [`PipelineDeletedException`](crate::error::PipelineDeletedException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Description of the error message.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`PipelineDeletedException`](crate::error::PipelineDeletedException)
        pub fn build(self) -> crate::error::PipelineDeletedException {
            crate::error::PipelineDeletedException {
                message: self.message,
            }
        }
    }
}
impl PipelineDeletedException {
    /// Creates a new builder-style object to manufacture [`PipelineDeletedException`](crate::error::PipelineDeletedException)
    pub fn builder() -> crate::error::pipeline_deleted_exception::Builder {
        crate::error::pipeline_deleted_exception::Builder::default()
    }
}

/// <p>The request was not valid. Verify that your request was properly formatted, that the signature was generated with the correct credentials, and that you haven't exceeded any of the service limits for your account.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidRequestException {
    /// <p>Description of the error message.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidRequestException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidRequestException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidRequestException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidRequestException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidRequestException")?;
        if let Some(inner_3) = &self.message {
            write!(f, ": {}", inner_3)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidRequestException {}
/// See [`InvalidRequestException`](crate::error::InvalidRequestException)
pub mod invalid_request_exception {
    /// A builder for [`InvalidRequestException`](crate::error::InvalidRequestException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Description of the error message.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidRequestException`](crate::error::InvalidRequestException)
        pub fn build(self) -> crate::error::InvalidRequestException {
            crate::error::InvalidRequestException {
                message: self.message,
            }
        }
    }
}
impl InvalidRequestException {
    /// Creates a new builder-style object to manufacture [`InvalidRequestException`](crate::error::InvalidRequestException)
    pub fn builder() -> crate::error::invalid_request_exception::Builder {
        crate::error::invalid_request_exception::Builder::default()
    }
}

/// <p>An internal service error occurred.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InternalServiceError {
    /// <p>Description of the error message.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InternalServiceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InternalServiceError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InternalServiceError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InternalServiceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InternalServiceError")?;
        if let Some(inner_4) = &self.message {
            write!(f, ": {}", inner_4)?;
        }
        Ok(())
    }
}
impl std::error::Error for InternalServiceError {}
/// See [`InternalServiceError`](crate::error::InternalServiceError)
pub mod internal_service_error {
    /// A builder for [`InternalServiceError`](crate::error::InternalServiceError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Description of the error message.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InternalServiceError`](crate::error::InternalServiceError)
        pub fn build(self) -> crate::error::InternalServiceError {
            crate::error::InternalServiceError {
                message: self.message,
            }
        }
    }
}
impl InternalServiceError {
    /// Creates a new builder-style object to manufacture [`InternalServiceError`](crate::error::InternalServiceError)
    pub fn builder() -> crate::error::internal_service_error::Builder {
        crate::error::internal_service_error::Builder::default()
    }
}

/// <p>The specified task was not found. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TaskNotFoundException {
    /// <p>Description of the error message.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for TaskNotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TaskNotFoundException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl TaskNotFoundException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TaskNotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TaskNotFoundException")?;
        if let Some(inner_5) = &self.message {
            write!(f, ": {}", inner_5)?;
        }
        Ok(())
    }
}
impl std::error::Error for TaskNotFoundException {}
/// See [`TaskNotFoundException`](crate::error::TaskNotFoundException)
pub mod task_not_found_exception {
    /// A builder for [`TaskNotFoundException`](crate::error::TaskNotFoundException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Description of the error message.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`TaskNotFoundException`](crate::error::TaskNotFoundException)
        pub fn build(self) -> crate::error::TaskNotFoundException {
            crate::error::TaskNotFoundException {
                message: self.message,
            }
        }
    }
}
impl TaskNotFoundException {
    /// Creates a new builder-style object to manufacture [`TaskNotFoundException`](crate::error::TaskNotFoundException)
    pub fn builder() -> crate::error::task_not_found_exception::Builder {
        crate::error::task_not_found_exception::Builder::default()
    }
}
