// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type UpdateUserErrorKind = UpdateUserError;
/// Error type for the `UpdateUserError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateUserError {
    /// <p></p>
    InvalidParameterCombinationException(crate::error::InvalidParameterCombinationException),
    /// <p></p>
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    /// <p></p>
    InvalidUserStateFault(crate::error::InvalidUserStateFault),
    /// <p></p>
    UserNotFoundFault(crate::error::UserNotFoundFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for UpdateUserError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for UpdateUserError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::InvalidParameterCombinationException(_inner) => _inner.fmt(f),
            Self::InvalidParameterValueException(_inner) => _inner.fmt(f),
            Self::InvalidUserStateFault(_inner) => _inner.fmt(f),
            Self::UserNotFoundFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for UpdateUserError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::InvalidParameterCombinationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidParameterValueException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidUserStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UserNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::UpdateUserError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateUserError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateUserError {
    /// Creates the `UpdateUserError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `UpdateUserError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::InvalidParameterCombinationException(e) => e.meta(),
            Self::InvalidParameterValueException(e) => e.meta(),
            Self::InvalidUserStateFault(e) => e.meta(),
            Self::UserNotFoundFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `UpdateUserError::InvalidParameterCombinationException`.
    pub fn is_invalid_parameter_combination_exception(&self) -> bool {
        matches!(self, Self::InvalidParameterCombinationException(_))
    }
    /// Returns `true` if the error kind is `UpdateUserError::InvalidParameterValueException`.
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(self, Self::InvalidParameterValueException(_))
    }
    /// Returns `true` if the error kind is `UpdateUserError::InvalidUserStateFault`.
    pub fn is_invalid_user_state_fault(&self) -> bool {
        matches!(self, Self::InvalidUserStateFault(_))
    }
    /// Returns `true` if the error kind is `UpdateUserError::UserNotFoundFault`.
    pub fn is_user_not_found_fault(&self) -> bool {
        matches!(self, Self::UserNotFoundFault(_))
    }
}
impl std::error::Error for UpdateUserError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::InvalidParameterCombinationException(_inner) => Some(_inner),
            Self::InvalidParameterValueException(_inner) => Some(_inner),
            Self::InvalidUserStateFault(_inner) => Some(_inner),
            Self::UserNotFoundFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UserNotFoundFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl UserNotFoundFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for UserNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "UserNotFoundFault")?;
        if let Some(inner_1) = &self.message {
            {
                write!(f, ": {}", inner_1)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for UserNotFoundFault {}
impl aws_http::request_id::RequestId for crate::error::UserNotFoundFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for UserNotFoundFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl UserNotFoundFault {
    /// Creates a new builder-style object to manufacture [`UserNotFoundFault`](crate::error::UserNotFoundFault).
    pub fn builder() -> crate::error::user_not_found_fault::Builder {
        crate::error::user_not_found_fault::Builder::default()
    }
}

/// See [`UserNotFoundFault`](crate::error::UserNotFoundFault).
pub mod user_not_found_fault {

    /// A builder for [`UserNotFoundFault`](crate::error::UserNotFoundFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`UserNotFoundFault`](crate::error::UserNotFoundFault).
        pub fn build(self) -> crate::error::UserNotFoundFault {
            crate::error::UserNotFoundFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidUserStateFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidUserStateFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidUserStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidUserStateFault")?;
        if let Some(inner_2) = &self.message {
            {
                write!(f, ": {}", inner_2)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidUserStateFault {}
impl aws_http::request_id::RequestId for crate::error::InvalidUserStateFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidUserStateFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InvalidUserStateFault {
    /// Creates a new builder-style object to manufacture [`InvalidUserStateFault`](crate::error::InvalidUserStateFault).
    pub fn builder() -> crate::error::invalid_user_state_fault::Builder {
        crate::error::invalid_user_state_fault::Builder::default()
    }
}

/// See [`InvalidUserStateFault`](crate::error::InvalidUserStateFault).
pub mod invalid_user_state_fault {

    /// A builder for [`InvalidUserStateFault`](crate::error::InvalidUserStateFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidUserStateFault`](crate::error::InvalidUserStateFault).
        pub fn build(self) -> crate::error::InvalidUserStateFault {
            crate::error::InvalidUserStateFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidParameterValueException {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidParameterValueException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidParameterValueException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidParameterValueException")?;
        if let Some(inner_3) = &self.message {
            {
                write!(f, ": {}", inner_3)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidParameterValueException {}
impl aws_http::request_id::RequestId for crate::error::InvalidParameterValueException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidParameterValueException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InvalidParameterValueException {
    /// Creates a new builder-style object to manufacture [`InvalidParameterValueException`](crate::error::InvalidParameterValueException).
    pub fn builder() -> crate::error::invalid_parameter_value_exception::Builder {
        crate::error::invalid_parameter_value_exception::Builder::default()
    }
}

/// See [`InvalidParameterValueException`](crate::error::InvalidParameterValueException).
pub mod invalid_parameter_value_exception {

    /// A builder for [`InvalidParameterValueException`](crate::error::InvalidParameterValueException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidParameterValueException`](crate::error::InvalidParameterValueException).
        pub fn build(self) -> crate::error::InvalidParameterValueException {
            crate::error::InvalidParameterValueException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidParameterCombinationException {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidParameterCombinationException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidParameterCombinationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidParameterCombinationException")?;
        if let Some(inner_4) = &self.message {
            {
                write!(f, ": {}", inner_4)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidParameterCombinationException {}
impl aws_http::request_id::RequestId for crate::error::InvalidParameterCombinationException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for InvalidParameterCombinationException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InvalidParameterCombinationException {
    /// Creates a new builder-style object to manufacture [`InvalidParameterCombinationException`](crate::error::InvalidParameterCombinationException).
    pub fn builder() -> crate::error::invalid_parameter_combination_exception::Builder {
        crate::error::invalid_parameter_combination_exception::Builder::default()
    }
}

/// See [`InvalidParameterCombinationException`](crate::error::InvalidParameterCombinationException).
pub mod invalid_parameter_combination_exception {

    /// A builder for [`InvalidParameterCombinationException`](crate::error::InvalidParameterCombinationException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidParameterCombinationException`](crate::error::InvalidParameterCombinationException).
        pub fn build(self) -> crate::error::InvalidParameterCombinationException {
            crate::error::InvalidParameterCombinationException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type UpdateSubnetGroupErrorKind = UpdateSubnetGroupError;
/// Error type for the `UpdateSubnetGroupError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateSubnetGroupError {
    /// <p></p>
    InvalidSubnet(crate::error::InvalidSubnet),
    /// <p></p>
    ServiceLinkedRoleNotFoundFault(crate::error::ServiceLinkedRoleNotFoundFault),
    /// <p></p>
    SubnetGroupNotFoundFault(crate::error::SubnetGroupNotFoundFault),
    /// <p></p>
    SubnetInUse(crate::error::SubnetInUse),
    /// <p></p>
    SubnetNotAllowedFault(crate::error::SubnetNotAllowedFault),
    /// <p></p>
    SubnetQuotaExceededFault(crate::error::SubnetQuotaExceededFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for UpdateSubnetGroupError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for UpdateSubnetGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::InvalidSubnet(_inner) => _inner.fmt(f),
            Self::ServiceLinkedRoleNotFoundFault(_inner) => _inner.fmt(f),
            Self::SubnetGroupNotFoundFault(_inner) => _inner.fmt(f),
            Self::SubnetInUse(_inner) => _inner.fmt(f),
            Self::SubnetNotAllowedFault(_inner) => _inner.fmt(f),
            Self::SubnetQuotaExceededFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for UpdateSubnetGroupError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::InvalidSubnet(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceLinkedRoleNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::SubnetGroupNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::SubnetInUse(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::SubnetNotAllowedFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::SubnetQuotaExceededFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::UpdateSubnetGroupError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateSubnetGroupError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateSubnetGroupError {
    /// Creates the `UpdateSubnetGroupError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `UpdateSubnetGroupError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::InvalidSubnet(e) => e.meta(),
            Self::ServiceLinkedRoleNotFoundFault(e) => e.meta(),
            Self::SubnetGroupNotFoundFault(e) => e.meta(),
            Self::SubnetInUse(e) => e.meta(),
            Self::SubnetNotAllowedFault(e) => e.meta(),
            Self::SubnetQuotaExceededFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `UpdateSubnetGroupError::InvalidSubnet`.
    pub fn is_invalid_subnet(&self) -> bool {
        matches!(self, Self::InvalidSubnet(_))
    }
    /// Returns `true` if the error kind is `UpdateSubnetGroupError::ServiceLinkedRoleNotFoundFault`.
    pub fn is_service_linked_role_not_found_fault(&self) -> bool {
        matches!(self, Self::ServiceLinkedRoleNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `UpdateSubnetGroupError::SubnetGroupNotFoundFault`.
    pub fn is_subnet_group_not_found_fault(&self) -> bool {
        matches!(self, Self::SubnetGroupNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `UpdateSubnetGroupError::SubnetInUse`.
    pub fn is_subnet_in_use(&self) -> bool {
        matches!(self, Self::SubnetInUse(_))
    }
    /// Returns `true` if the error kind is `UpdateSubnetGroupError::SubnetNotAllowedFault`.
    pub fn is_subnet_not_allowed_fault(&self) -> bool {
        matches!(self, Self::SubnetNotAllowedFault(_))
    }
    /// Returns `true` if the error kind is `UpdateSubnetGroupError::SubnetQuotaExceededFault`.
    pub fn is_subnet_quota_exceeded_fault(&self) -> bool {
        matches!(self, Self::SubnetQuotaExceededFault(_))
    }
}
impl std::error::Error for UpdateSubnetGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::InvalidSubnet(_inner) => Some(_inner),
            Self::ServiceLinkedRoleNotFoundFault(_inner) => Some(_inner),
            Self::SubnetGroupNotFoundFault(_inner) => Some(_inner),
            Self::SubnetInUse(_inner) => Some(_inner),
            Self::SubnetNotAllowedFault(_inner) => Some(_inner),
            Self::SubnetQuotaExceededFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SubnetQuotaExceededFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl SubnetQuotaExceededFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for SubnetQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SubnetQuotaExceededFault")?;
        if let Some(inner_5) = &self.message {
            {
                write!(f, ": {}", inner_5)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for SubnetQuotaExceededFault {}
impl aws_http::request_id::RequestId for crate::error::SubnetQuotaExceededFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for SubnetQuotaExceededFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl SubnetQuotaExceededFault {
    /// Creates a new builder-style object to manufacture [`SubnetQuotaExceededFault`](crate::error::SubnetQuotaExceededFault).
    pub fn builder() -> crate::error::subnet_quota_exceeded_fault::Builder {
        crate::error::subnet_quota_exceeded_fault::Builder::default()
    }
}

/// See [`SubnetQuotaExceededFault`](crate::error::SubnetQuotaExceededFault).
pub mod subnet_quota_exceeded_fault {

    /// A builder for [`SubnetQuotaExceededFault`](crate::error::SubnetQuotaExceededFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`SubnetQuotaExceededFault`](crate::error::SubnetQuotaExceededFault).
        pub fn build(self) -> crate::error::SubnetQuotaExceededFault {
            crate::error::SubnetQuotaExceededFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SubnetNotAllowedFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl SubnetNotAllowedFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for SubnetNotAllowedFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SubnetNotAllowedFault")?;
        if let Some(inner_6) = &self.message {
            {
                write!(f, ": {}", inner_6)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for SubnetNotAllowedFault {}
impl aws_http::request_id::RequestId for crate::error::SubnetNotAllowedFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for SubnetNotAllowedFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl SubnetNotAllowedFault {
    /// Creates a new builder-style object to manufacture [`SubnetNotAllowedFault`](crate::error::SubnetNotAllowedFault).
    pub fn builder() -> crate::error::subnet_not_allowed_fault::Builder {
        crate::error::subnet_not_allowed_fault::Builder::default()
    }
}

/// See [`SubnetNotAllowedFault`](crate::error::SubnetNotAllowedFault).
pub mod subnet_not_allowed_fault {

    /// A builder for [`SubnetNotAllowedFault`](crate::error::SubnetNotAllowedFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`SubnetNotAllowedFault`](crate::error::SubnetNotAllowedFault).
        pub fn build(self) -> crate::error::SubnetNotAllowedFault {
            crate::error::SubnetNotAllowedFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SubnetInUse {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl SubnetInUse {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for SubnetInUse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SubnetInUse")?;
        if let Some(inner_7) = &self.message {
            {
                write!(f, ": {}", inner_7)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for SubnetInUse {}
impl aws_http::request_id::RequestId for crate::error::SubnetInUse {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for SubnetInUse {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl SubnetInUse {
    /// Creates a new builder-style object to manufacture [`SubnetInUse`](crate::error::SubnetInUse).
    pub fn builder() -> crate::error::subnet_in_use::Builder {
        crate::error::subnet_in_use::Builder::default()
    }
}

/// See [`SubnetInUse`](crate::error::SubnetInUse).
pub mod subnet_in_use {

    /// A builder for [`SubnetInUse`](crate::error::SubnetInUse).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`SubnetInUse`](crate::error::SubnetInUse).
        pub fn build(self) -> crate::error::SubnetInUse {
            crate::error::SubnetInUse {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SubnetGroupNotFoundFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl SubnetGroupNotFoundFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for SubnetGroupNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SubnetGroupNotFoundFault")?;
        if let Some(inner_8) = &self.message {
            {
                write!(f, ": {}", inner_8)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for SubnetGroupNotFoundFault {}
impl aws_http::request_id::RequestId for crate::error::SubnetGroupNotFoundFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for SubnetGroupNotFoundFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl SubnetGroupNotFoundFault {
    /// Creates a new builder-style object to manufacture [`SubnetGroupNotFoundFault`](crate::error::SubnetGroupNotFoundFault).
    pub fn builder() -> crate::error::subnet_group_not_found_fault::Builder {
        crate::error::subnet_group_not_found_fault::Builder::default()
    }
}

/// See [`SubnetGroupNotFoundFault`](crate::error::SubnetGroupNotFoundFault).
pub mod subnet_group_not_found_fault {

    /// A builder for [`SubnetGroupNotFoundFault`](crate::error::SubnetGroupNotFoundFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`SubnetGroupNotFoundFault`](crate::error::SubnetGroupNotFoundFault).
        pub fn build(self) -> crate::error::SubnetGroupNotFoundFault {
            crate::error::SubnetGroupNotFoundFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ServiceLinkedRoleNotFoundFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl ServiceLinkedRoleNotFoundFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ServiceLinkedRoleNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ServiceLinkedRoleNotFoundFault")?;
        if let Some(inner_9) = &self.message {
            {
                write!(f, ": {}", inner_9)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ServiceLinkedRoleNotFoundFault {}
impl aws_http::request_id::RequestId for crate::error::ServiceLinkedRoleNotFoundFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ServiceLinkedRoleNotFoundFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl ServiceLinkedRoleNotFoundFault {
    /// Creates a new builder-style object to manufacture [`ServiceLinkedRoleNotFoundFault`](crate::error::ServiceLinkedRoleNotFoundFault).
    pub fn builder() -> crate::error::service_linked_role_not_found_fault::Builder {
        crate::error::service_linked_role_not_found_fault::Builder::default()
    }
}

/// See [`ServiceLinkedRoleNotFoundFault`](crate::error::ServiceLinkedRoleNotFoundFault).
pub mod service_linked_role_not_found_fault {

    /// A builder for [`ServiceLinkedRoleNotFoundFault`](crate::error::ServiceLinkedRoleNotFoundFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`ServiceLinkedRoleNotFoundFault`](crate::error::ServiceLinkedRoleNotFoundFault).
        pub fn build(self) -> crate::error::ServiceLinkedRoleNotFoundFault {
            crate::error::ServiceLinkedRoleNotFoundFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidSubnet {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidSubnet {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidSubnet {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidSubnet")?;
        if let Some(inner_10) = &self.message {
            {
                write!(f, ": {}", inner_10)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidSubnet {}
impl aws_http::request_id::RequestId for crate::error::InvalidSubnet {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidSubnet {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InvalidSubnet {
    /// Creates a new builder-style object to manufacture [`InvalidSubnet`](crate::error::InvalidSubnet).
    pub fn builder() -> crate::error::invalid_subnet::Builder {
        crate::error::invalid_subnet::Builder::default()
    }
}

/// See [`InvalidSubnet`](crate::error::InvalidSubnet).
pub mod invalid_subnet {

    /// A builder for [`InvalidSubnet`](crate::error::InvalidSubnet).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidSubnet`](crate::error::InvalidSubnet).
        pub fn build(self) -> crate::error::InvalidSubnet {
            crate::error::InvalidSubnet {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type UpdateParameterGroupErrorKind = UpdateParameterGroupError;
/// Error type for the `UpdateParameterGroupError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateParameterGroupError {
    /// <p></p>
    InvalidParameterCombinationException(crate::error::InvalidParameterCombinationException),
    /// <p></p>
    InvalidParameterGroupStateFault(crate::error::InvalidParameterGroupStateFault),
    /// <p></p>
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    /// <p></p>
    ParameterGroupNotFoundFault(crate::error::ParameterGroupNotFoundFault),
    /// <p></p>
    ServiceLinkedRoleNotFoundFault(crate::error::ServiceLinkedRoleNotFoundFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for UpdateParameterGroupError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for UpdateParameterGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::InvalidParameterCombinationException(_inner) => _inner.fmt(f),
            Self::InvalidParameterGroupStateFault(_inner) => _inner.fmt(f),
            Self::InvalidParameterValueException(_inner) => _inner.fmt(f),
            Self::ParameterGroupNotFoundFault(_inner) => _inner.fmt(f),
            Self::ServiceLinkedRoleNotFoundFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for UpdateParameterGroupError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::InvalidParameterCombinationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidParameterGroupStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidParameterValueException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ParameterGroupNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceLinkedRoleNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::UpdateParameterGroupError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateParameterGroupError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateParameterGroupError {
    /// Creates the `UpdateParameterGroupError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `UpdateParameterGroupError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::InvalidParameterCombinationException(e) => e.meta(),
            Self::InvalidParameterGroupStateFault(e) => e.meta(),
            Self::InvalidParameterValueException(e) => e.meta(),
            Self::ParameterGroupNotFoundFault(e) => e.meta(),
            Self::ServiceLinkedRoleNotFoundFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `UpdateParameterGroupError::InvalidParameterCombinationException`.
    pub fn is_invalid_parameter_combination_exception(&self) -> bool {
        matches!(self, Self::InvalidParameterCombinationException(_))
    }
    /// Returns `true` if the error kind is `UpdateParameterGroupError::InvalidParameterGroupStateFault`.
    pub fn is_invalid_parameter_group_state_fault(&self) -> bool {
        matches!(self, Self::InvalidParameterGroupStateFault(_))
    }
    /// Returns `true` if the error kind is `UpdateParameterGroupError::InvalidParameterValueException`.
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(self, Self::InvalidParameterValueException(_))
    }
    /// Returns `true` if the error kind is `UpdateParameterGroupError::ParameterGroupNotFoundFault`.
    pub fn is_parameter_group_not_found_fault(&self) -> bool {
        matches!(self, Self::ParameterGroupNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `UpdateParameterGroupError::ServiceLinkedRoleNotFoundFault`.
    pub fn is_service_linked_role_not_found_fault(&self) -> bool {
        matches!(self, Self::ServiceLinkedRoleNotFoundFault(_))
    }
}
impl std::error::Error for UpdateParameterGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::InvalidParameterCombinationException(_inner) => Some(_inner),
            Self::InvalidParameterGroupStateFault(_inner) => Some(_inner),
            Self::InvalidParameterValueException(_inner) => Some(_inner),
            Self::ParameterGroupNotFoundFault(_inner) => Some(_inner),
            Self::ServiceLinkedRoleNotFoundFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ParameterGroupNotFoundFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl ParameterGroupNotFoundFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ParameterGroupNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ParameterGroupNotFoundFault")?;
        if let Some(inner_11) = &self.message {
            {
                write!(f, ": {}", inner_11)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ParameterGroupNotFoundFault {}
impl aws_http::request_id::RequestId for crate::error::ParameterGroupNotFoundFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ParameterGroupNotFoundFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl ParameterGroupNotFoundFault {
    /// Creates a new builder-style object to manufacture [`ParameterGroupNotFoundFault`](crate::error::ParameterGroupNotFoundFault).
    pub fn builder() -> crate::error::parameter_group_not_found_fault::Builder {
        crate::error::parameter_group_not_found_fault::Builder::default()
    }
}

/// See [`ParameterGroupNotFoundFault`](crate::error::ParameterGroupNotFoundFault).
pub mod parameter_group_not_found_fault {

    /// A builder for [`ParameterGroupNotFoundFault`](crate::error::ParameterGroupNotFoundFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`ParameterGroupNotFoundFault`](crate::error::ParameterGroupNotFoundFault).
        pub fn build(self) -> crate::error::ParameterGroupNotFoundFault {
            crate::error::ParameterGroupNotFoundFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidParameterGroupStateFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidParameterGroupStateFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidParameterGroupStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidParameterGroupStateFault")?;
        if let Some(inner_12) = &self.message {
            {
                write!(f, ": {}", inner_12)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidParameterGroupStateFault {}
impl aws_http::request_id::RequestId for crate::error::InvalidParameterGroupStateFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidParameterGroupStateFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InvalidParameterGroupStateFault {
    /// Creates a new builder-style object to manufacture [`InvalidParameterGroupStateFault`](crate::error::InvalidParameterGroupStateFault).
    pub fn builder() -> crate::error::invalid_parameter_group_state_fault::Builder {
        crate::error::invalid_parameter_group_state_fault::Builder::default()
    }
}

/// See [`InvalidParameterGroupStateFault`](crate::error::InvalidParameterGroupStateFault).
pub mod invalid_parameter_group_state_fault {

    /// A builder for [`InvalidParameterGroupStateFault`](crate::error::InvalidParameterGroupStateFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidParameterGroupStateFault`](crate::error::InvalidParameterGroupStateFault).
        pub fn build(self) -> crate::error::InvalidParameterGroupStateFault {
            crate::error::InvalidParameterGroupStateFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type UpdateClusterErrorKind = UpdateClusterError;
/// Error type for the `UpdateClusterError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateClusterError {
    /// <p></p>
    AclNotFoundFault(crate::error::AclNotFoundFault),
    /// <p></p>
    ClusterNotFoundFault(crate::error::ClusterNotFoundFault),
    /// <p></p>
    ClusterQuotaForCustomerExceededFault(crate::error::ClusterQuotaForCustomerExceededFault),
    /// <p></p>
    InvalidAclStateFault(crate::error::InvalidAclStateFault),
    /// <p></p>
    InvalidClusterStateFault(crate::error::InvalidClusterStateFault),
    /// <p></p>
    InvalidKmsKeyFault(crate::error::InvalidKmsKeyFault),
    /// <p></p>
    InvalidNodeStateFault(crate::error::InvalidNodeStateFault),
    /// <p></p>
    InvalidParameterCombinationException(crate::error::InvalidParameterCombinationException),
    /// <p></p>
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    /// <p></p>
    InvalidVpcNetworkStateFault(crate::error::InvalidVpcNetworkStateFault),
    /// <p></p>
    NodeQuotaForClusterExceededFault(crate::error::NodeQuotaForClusterExceededFault),
    /// <p></p>
    NodeQuotaForCustomerExceededFault(crate::error::NodeQuotaForCustomerExceededFault),
    /// <p></p>
    NoOperationFault(crate::error::NoOperationFault),
    /// <p></p>
    ParameterGroupNotFoundFault(crate::error::ParameterGroupNotFoundFault),
    /// <p></p>
    ServiceLinkedRoleNotFoundFault(crate::error::ServiceLinkedRoleNotFoundFault),
    /// <p></p>
    ShardsPerClusterQuotaExceededFault(crate::error::ShardsPerClusterQuotaExceededFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for UpdateClusterError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for UpdateClusterError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AclNotFoundFault(_inner) => _inner.fmt(f),
            Self::ClusterNotFoundFault(_inner) => _inner.fmt(f),
            Self::ClusterQuotaForCustomerExceededFault(_inner) => _inner.fmt(f),
            Self::InvalidAclStateFault(_inner) => _inner.fmt(f),
            Self::InvalidClusterStateFault(_inner) => _inner.fmt(f),
            Self::InvalidKmsKeyFault(_inner) => _inner.fmt(f),
            Self::InvalidNodeStateFault(_inner) => _inner.fmt(f),
            Self::InvalidParameterCombinationException(_inner) => _inner.fmt(f),
            Self::InvalidParameterValueException(_inner) => _inner.fmt(f),
            Self::InvalidVpcNetworkStateFault(_inner) => _inner.fmt(f),
            Self::NodeQuotaForClusterExceededFault(_inner) => _inner.fmt(f),
            Self::NodeQuotaForCustomerExceededFault(_inner) => _inner.fmt(f),
            Self::NoOperationFault(_inner) => _inner.fmt(f),
            Self::ParameterGroupNotFoundFault(_inner) => _inner.fmt(f),
            Self::ServiceLinkedRoleNotFoundFault(_inner) => _inner.fmt(f),
            Self::ShardsPerClusterQuotaExceededFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for UpdateClusterError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AclNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ClusterNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ClusterQuotaForCustomerExceededFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidAclStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidClusterStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidKmsKeyFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidNodeStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidParameterCombinationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidParameterValueException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidVpcNetworkStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NodeQuotaForClusterExceededFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NodeQuotaForCustomerExceededFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NoOperationFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ParameterGroupNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceLinkedRoleNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ShardsPerClusterQuotaExceededFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::UpdateClusterError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateClusterError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateClusterError {
    /// Creates the `UpdateClusterError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `UpdateClusterError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AclNotFoundFault(e) => e.meta(),
            Self::ClusterNotFoundFault(e) => e.meta(),
            Self::ClusterQuotaForCustomerExceededFault(e) => e.meta(),
            Self::InvalidAclStateFault(e) => e.meta(),
            Self::InvalidClusterStateFault(e) => e.meta(),
            Self::InvalidKmsKeyFault(e) => e.meta(),
            Self::InvalidNodeStateFault(e) => e.meta(),
            Self::InvalidParameterCombinationException(e) => e.meta(),
            Self::InvalidParameterValueException(e) => e.meta(),
            Self::InvalidVpcNetworkStateFault(e) => e.meta(),
            Self::NodeQuotaForClusterExceededFault(e) => e.meta(),
            Self::NodeQuotaForCustomerExceededFault(e) => e.meta(),
            Self::NoOperationFault(e) => e.meta(),
            Self::ParameterGroupNotFoundFault(e) => e.meta(),
            Self::ServiceLinkedRoleNotFoundFault(e) => e.meta(),
            Self::ShardsPerClusterQuotaExceededFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `UpdateClusterError::AclNotFoundFault`.
    pub fn is_acl_not_found_fault(&self) -> bool {
        matches!(self, Self::AclNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `UpdateClusterError::ClusterNotFoundFault`.
    pub fn is_cluster_not_found_fault(&self) -> bool {
        matches!(self, Self::ClusterNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `UpdateClusterError::ClusterQuotaForCustomerExceededFault`.
    pub fn is_cluster_quota_for_customer_exceeded_fault(&self) -> bool {
        matches!(self, Self::ClusterQuotaForCustomerExceededFault(_))
    }
    /// Returns `true` if the error kind is `UpdateClusterError::InvalidAclStateFault`.
    pub fn is_invalid_acl_state_fault(&self) -> bool {
        matches!(self, Self::InvalidAclStateFault(_))
    }
    /// Returns `true` if the error kind is `UpdateClusterError::InvalidClusterStateFault`.
    pub fn is_invalid_cluster_state_fault(&self) -> bool {
        matches!(self, Self::InvalidClusterStateFault(_))
    }
    /// Returns `true` if the error kind is `UpdateClusterError::InvalidKmsKeyFault`.
    pub fn is_invalid_kms_key_fault(&self) -> bool {
        matches!(self, Self::InvalidKmsKeyFault(_))
    }
    /// Returns `true` if the error kind is `UpdateClusterError::InvalidNodeStateFault`.
    pub fn is_invalid_node_state_fault(&self) -> bool {
        matches!(self, Self::InvalidNodeStateFault(_))
    }
    /// Returns `true` if the error kind is `UpdateClusterError::InvalidParameterCombinationException`.
    pub fn is_invalid_parameter_combination_exception(&self) -> bool {
        matches!(self, Self::InvalidParameterCombinationException(_))
    }
    /// Returns `true` if the error kind is `UpdateClusterError::InvalidParameterValueException`.
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(self, Self::InvalidParameterValueException(_))
    }
    /// Returns `true` if the error kind is `UpdateClusterError::InvalidVpcNetworkStateFault`.
    pub fn is_invalid_vpc_network_state_fault(&self) -> bool {
        matches!(self, Self::InvalidVpcNetworkStateFault(_))
    }
    /// Returns `true` if the error kind is `UpdateClusterError::NodeQuotaForClusterExceededFault`.
    pub fn is_node_quota_for_cluster_exceeded_fault(&self) -> bool {
        matches!(self, Self::NodeQuotaForClusterExceededFault(_))
    }
    /// Returns `true` if the error kind is `UpdateClusterError::NodeQuotaForCustomerExceededFault`.
    pub fn is_node_quota_for_customer_exceeded_fault(&self) -> bool {
        matches!(self, Self::NodeQuotaForCustomerExceededFault(_))
    }
    /// Returns `true` if the error kind is `UpdateClusterError::NoOperationFault`.
    pub fn is_no_operation_fault(&self) -> bool {
        matches!(self, Self::NoOperationFault(_))
    }
    /// Returns `true` if the error kind is `UpdateClusterError::ParameterGroupNotFoundFault`.
    pub fn is_parameter_group_not_found_fault(&self) -> bool {
        matches!(self, Self::ParameterGroupNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `UpdateClusterError::ServiceLinkedRoleNotFoundFault`.
    pub fn is_service_linked_role_not_found_fault(&self) -> bool {
        matches!(self, Self::ServiceLinkedRoleNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `UpdateClusterError::ShardsPerClusterQuotaExceededFault`.
    pub fn is_shards_per_cluster_quota_exceeded_fault(&self) -> bool {
        matches!(self, Self::ShardsPerClusterQuotaExceededFault(_))
    }
}
impl std::error::Error for UpdateClusterError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AclNotFoundFault(_inner) => Some(_inner),
            Self::ClusterNotFoundFault(_inner) => Some(_inner),
            Self::ClusterQuotaForCustomerExceededFault(_inner) => Some(_inner),
            Self::InvalidAclStateFault(_inner) => Some(_inner),
            Self::InvalidClusterStateFault(_inner) => Some(_inner),
            Self::InvalidKmsKeyFault(_inner) => Some(_inner),
            Self::InvalidNodeStateFault(_inner) => Some(_inner),
            Self::InvalidParameterCombinationException(_inner) => Some(_inner),
            Self::InvalidParameterValueException(_inner) => Some(_inner),
            Self::InvalidVpcNetworkStateFault(_inner) => Some(_inner),
            Self::NodeQuotaForClusterExceededFault(_inner) => Some(_inner),
            Self::NodeQuotaForCustomerExceededFault(_inner) => Some(_inner),
            Self::NoOperationFault(_inner) => Some(_inner),
            Self::ParameterGroupNotFoundFault(_inner) => Some(_inner),
            Self::ServiceLinkedRoleNotFoundFault(_inner) => Some(_inner),
            Self::ShardsPerClusterQuotaExceededFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ShardsPerClusterQuotaExceededFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl ShardsPerClusterQuotaExceededFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ShardsPerClusterQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ShardsPerClusterQuotaExceededFault")?;
        if let Some(inner_13) = &self.message {
            {
                write!(f, ": {}", inner_13)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ShardsPerClusterQuotaExceededFault {}
impl aws_http::request_id::RequestId for crate::error::ShardsPerClusterQuotaExceededFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for ShardsPerClusterQuotaExceededFault
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl ShardsPerClusterQuotaExceededFault {
    /// Creates a new builder-style object to manufacture [`ShardsPerClusterQuotaExceededFault`](crate::error::ShardsPerClusterQuotaExceededFault).
    pub fn builder() -> crate::error::shards_per_cluster_quota_exceeded_fault::Builder {
        crate::error::shards_per_cluster_quota_exceeded_fault::Builder::default()
    }
}

/// See [`ShardsPerClusterQuotaExceededFault`](crate::error::ShardsPerClusterQuotaExceededFault).
pub mod shards_per_cluster_quota_exceeded_fault {

    /// A builder for [`ShardsPerClusterQuotaExceededFault`](crate::error::ShardsPerClusterQuotaExceededFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`ShardsPerClusterQuotaExceededFault`](crate::error::ShardsPerClusterQuotaExceededFault).
        pub fn build(self) -> crate::error::ShardsPerClusterQuotaExceededFault {
            crate::error::ShardsPerClusterQuotaExceededFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct NoOperationFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl NoOperationFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for NoOperationFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "NoOperationFault")?;
        if let Some(inner_14) = &self.message {
            {
                write!(f, ": {}", inner_14)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for NoOperationFault {}
impl aws_http::request_id::RequestId for crate::error::NoOperationFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for NoOperationFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl NoOperationFault {
    /// Creates a new builder-style object to manufacture [`NoOperationFault`](crate::error::NoOperationFault).
    pub fn builder() -> crate::error::no_operation_fault::Builder {
        crate::error::no_operation_fault::Builder::default()
    }
}

/// See [`NoOperationFault`](crate::error::NoOperationFault).
pub mod no_operation_fault {

    /// A builder for [`NoOperationFault`](crate::error::NoOperationFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`NoOperationFault`](crate::error::NoOperationFault).
        pub fn build(self) -> crate::error::NoOperationFault {
            crate::error::NoOperationFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct NodeQuotaForCustomerExceededFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl NodeQuotaForCustomerExceededFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for NodeQuotaForCustomerExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "NodeQuotaForCustomerExceededFault")?;
        if let Some(inner_15) = &self.message {
            {
                write!(f, ": {}", inner_15)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for NodeQuotaForCustomerExceededFault {}
impl aws_http::request_id::RequestId for crate::error::NodeQuotaForCustomerExceededFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for NodeQuotaForCustomerExceededFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl NodeQuotaForCustomerExceededFault {
    /// Creates a new builder-style object to manufacture [`NodeQuotaForCustomerExceededFault`](crate::error::NodeQuotaForCustomerExceededFault).
    pub fn builder() -> crate::error::node_quota_for_customer_exceeded_fault::Builder {
        crate::error::node_quota_for_customer_exceeded_fault::Builder::default()
    }
}

/// See [`NodeQuotaForCustomerExceededFault`](crate::error::NodeQuotaForCustomerExceededFault).
pub mod node_quota_for_customer_exceeded_fault {

    /// A builder for [`NodeQuotaForCustomerExceededFault`](crate::error::NodeQuotaForCustomerExceededFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`NodeQuotaForCustomerExceededFault`](crate::error::NodeQuotaForCustomerExceededFault).
        pub fn build(self) -> crate::error::NodeQuotaForCustomerExceededFault {
            crate::error::NodeQuotaForCustomerExceededFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct NodeQuotaForClusterExceededFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl NodeQuotaForClusterExceededFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for NodeQuotaForClusterExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "NodeQuotaForClusterExceededFault")?;
        if let Some(inner_16) = &self.message {
            {
                write!(f, ": {}", inner_16)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for NodeQuotaForClusterExceededFault {}
impl aws_http::request_id::RequestId for crate::error::NodeQuotaForClusterExceededFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for NodeQuotaForClusterExceededFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl NodeQuotaForClusterExceededFault {
    /// Creates a new builder-style object to manufacture [`NodeQuotaForClusterExceededFault`](crate::error::NodeQuotaForClusterExceededFault).
    pub fn builder() -> crate::error::node_quota_for_cluster_exceeded_fault::Builder {
        crate::error::node_quota_for_cluster_exceeded_fault::Builder::default()
    }
}

/// See [`NodeQuotaForClusterExceededFault`](crate::error::NodeQuotaForClusterExceededFault).
pub mod node_quota_for_cluster_exceeded_fault {

    /// A builder for [`NodeQuotaForClusterExceededFault`](crate::error::NodeQuotaForClusterExceededFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`NodeQuotaForClusterExceededFault`](crate::error::NodeQuotaForClusterExceededFault).
        pub fn build(self) -> crate::error::NodeQuotaForClusterExceededFault {
            crate::error::NodeQuotaForClusterExceededFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidVpcNetworkStateFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidVpcNetworkStateFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidVpcNetworkStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "InvalidVpcNetworkStateFault [InvalidVPCNetworkStateFault]"
        )?;
        if let Some(inner_17) = &self.message {
            {
                write!(f, ": {}", inner_17)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidVpcNetworkStateFault {}
impl aws_http::request_id::RequestId for crate::error::InvalidVpcNetworkStateFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidVpcNetworkStateFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InvalidVpcNetworkStateFault {
    /// Creates a new builder-style object to manufacture [`InvalidVpcNetworkStateFault`](crate::error::InvalidVpcNetworkStateFault).
    pub fn builder() -> crate::error::invalid_vpc_network_state_fault::Builder {
        crate::error::invalid_vpc_network_state_fault::Builder::default()
    }
}

/// See [`InvalidVpcNetworkStateFault`](crate::error::InvalidVpcNetworkStateFault).
pub mod invalid_vpc_network_state_fault {

    /// A builder for [`InvalidVpcNetworkStateFault`](crate::error::InvalidVpcNetworkStateFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidVpcNetworkStateFault`](crate::error::InvalidVpcNetworkStateFault).
        pub fn build(self) -> crate::error::InvalidVpcNetworkStateFault {
            crate::error::InvalidVpcNetworkStateFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidNodeStateFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidNodeStateFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidNodeStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidNodeStateFault")?;
        if let Some(inner_18) = &self.message {
            {
                write!(f, ": {}", inner_18)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidNodeStateFault {}
impl aws_http::request_id::RequestId for crate::error::InvalidNodeStateFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidNodeStateFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InvalidNodeStateFault {
    /// Creates a new builder-style object to manufacture [`InvalidNodeStateFault`](crate::error::InvalidNodeStateFault).
    pub fn builder() -> crate::error::invalid_node_state_fault::Builder {
        crate::error::invalid_node_state_fault::Builder::default()
    }
}

/// See [`InvalidNodeStateFault`](crate::error::InvalidNodeStateFault).
pub mod invalid_node_state_fault {

    /// A builder for [`InvalidNodeStateFault`](crate::error::InvalidNodeStateFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidNodeStateFault`](crate::error::InvalidNodeStateFault).
        pub fn build(self) -> crate::error::InvalidNodeStateFault {
            crate::error::InvalidNodeStateFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidKmsKeyFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidKmsKeyFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidKmsKeyFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidKmsKeyFault [InvalidKMSKeyFault]")?;
        if let Some(inner_19) = &self.message {
            {
                write!(f, ": {}", inner_19)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidKmsKeyFault {}
impl aws_http::request_id::RequestId for crate::error::InvalidKmsKeyFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidKmsKeyFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InvalidKmsKeyFault {
    /// Creates a new builder-style object to manufacture [`InvalidKmsKeyFault`](crate::error::InvalidKmsKeyFault).
    pub fn builder() -> crate::error::invalid_kms_key_fault::Builder {
        crate::error::invalid_kms_key_fault::Builder::default()
    }
}

/// See [`InvalidKmsKeyFault`](crate::error::InvalidKmsKeyFault).
pub mod invalid_kms_key_fault {

    /// A builder for [`InvalidKmsKeyFault`](crate::error::InvalidKmsKeyFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidKmsKeyFault`](crate::error::InvalidKmsKeyFault).
        pub fn build(self) -> crate::error::InvalidKmsKeyFault {
            crate::error::InvalidKmsKeyFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidClusterStateFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidClusterStateFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidClusterStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidClusterStateFault")?;
        if let Some(inner_20) = &self.message {
            {
                write!(f, ": {}", inner_20)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidClusterStateFault {}
impl aws_http::request_id::RequestId for crate::error::InvalidClusterStateFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidClusterStateFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InvalidClusterStateFault {
    /// Creates a new builder-style object to manufacture [`InvalidClusterStateFault`](crate::error::InvalidClusterStateFault).
    pub fn builder() -> crate::error::invalid_cluster_state_fault::Builder {
        crate::error::invalid_cluster_state_fault::Builder::default()
    }
}

/// See [`InvalidClusterStateFault`](crate::error::InvalidClusterStateFault).
pub mod invalid_cluster_state_fault {

    /// A builder for [`InvalidClusterStateFault`](crate::error::InvalidClusterStateFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidClusterStateFault`](crate::error::InvalidClusterStateFault).
        pub fn build(self) -> crate::error::InvalidClusterStateFault {
            crate::error::InvalidClusterStateFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidAclStateFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidAclStateFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidAclStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidAclStateFault [InvalidACLStateFault]")?;
        if let Some(inner_21) = &self.message {
            {
                write!(f, ": {}", inner_21)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidAclStateFault {}
impl aws_http::request_id::RequestId for crate::error::InvalidAclStateFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidAclStateFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InvalidAclStateFault {
    /// Creates a new builder-style object to manufacture [`InvalidAclStateFault`](crate::error::InvalidAclStateFault).
    pub fn builder() -> crate::error::invalid_acl_state_fault::Builder {
        crate::error::invalid_acl_state_fault::Builder::default()
    }
}

/// See [`InvalidAclStateFault`](crate::error::InvalidAclStateFault).
pub mod invalid_acl_state_fault {

    /// A builder for [`InvalidAclStateFault`](crate::error::InvalidAclStateFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidAclStateFault`](crate::error::InvalidAclStateFault).
        pub fn build(self) -> crate::error::InvalidAclStateFault {
            crate::error::InvalidAclStateFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ClusterQuotaForCustomerExceededFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl ClusterQuotaForCustomerExceededFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ClusterQuotaForCustomerExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ClusterQuotaForCustomerExceededFault")?;
        if let Some(inner_22) = &self.message {
            {
                write!(f, ": {}", inner_22)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ClusterQuotaForCustomerExceededFault {}
impl aws_http::request_id::RequestId for crate::error::ClusterQuotaForCustomerExceededFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for ClusterQuotaForCustomerExceededFault
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl ClusterQuotaForCustomerExceededFault {
    /// Creates a new builder-style object to manufacture [`ClusterQuotaForCustomerExceededFault`](crate::error::ClusterQuotaForCustomerExceededFault).
    pub fn builder() -> crate::error::cluster_quota_for_customer_exceeded_fault::Builder {
        crate::error::cluster_quota_for_customer_exceeded_fault::Builder::default()
    }
}

/// See [`ClusterQuotaForCustomerExceededFault`](crate::error::ClusterQuotaForCustomerExceededFault).
pub mod cluster_quota_for_customer_exceeded_fault {

    /// A builder for [`ClusterQuotaForCustomerExceededFault`](crate::error::ClusterQuotaForCustomerExceededFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`ClusterQuotaForCustomerExceededFault`](crate::error::ClusterQuotaForCustomerExceededFault).
        pub fn build(self) -> crate::error::ClusterQuotaForCustomerExceededFault {
            crate::error::ClusterQuotaForCustomerExceededFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ClusterNotFoundFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl ClusterNotFoundFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ClusterNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ClusterNotFoundFault")?;
        if let Some(inner_23) = &self.message {
            {
                write!(f, ": {}", inner_23)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ClusterNotFoundFault {}
impl aws_http::request_id::RequestId for crate::error::ClusterNotFoundFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ClusterNotFoundFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl ClusterNotFoundFault {
    /// Creates a new builder-style object to manufacture [`ClusterNotFoundFault`](crate::error::ClusterNotFoundFault).
    pub fn builder() -> crate::error::cluster_not_found_fault::Builder {
        crate::error::cluster_not_found_fault::Builder::default()
    }
}

/// See [`ClusterNotFoundFault`](crate::error::ClusterNotFoundFault).
pub mod cluster_not_found_fault {

    /// A builder for [`ClusterNotFoundFault`](crate::error::ClusterNotFoundFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`ClusterNotFoundFault`](crate::error::ClusterNotFoundFault).
        pub fn build(self) -> crate::error::ClusterNotFoundFault {
            crate::error::ClusterNotFoundFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AclNotFoundFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl AclNotFoundFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for AclNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "AclNotFoundFault [ACLNotFoundFault]")?;
        if let Some(inner_24) = &self.message {
            {
                write!(f, ": {}", inner_24)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for AclNotFoundFault {}
impl aws_http::request_id::RequestId for crate::error::AclNotFoundFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for AclNotFoundFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl AclNotFoundFault {
    /// Creates a new builder-style object to manufacture [`AclNotFoundFault`](crate::error::AclNotFoundFault).
    pub fn builder() -> crate::error::acl_not_found_fault::Builder {
        crate::error::acl_not_found_fault::Builder::default()
    }
}

/// See [`AclNotFoundFault`](crate::error::AclNotFoundFault).
pub mod acl_not_found_fault {

    /// A builder for [`AclNotFoundFault`](crate::error::AclNotFoundFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`AclNotFoundFault`](crate::error::AclNotFoundFault).
        pub fn build(self) -> crate::error::AclNotFoundFault {
            crate::error::AclNotFoundFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type UpdateACLErrorKind = UpdateACLError;
/// Error type for the `UpdateACLError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateACLError {
    /// <p></p>
    AclNotFoundFault(crate::error::AclNotFoundFault),
    /// <p></p>
    DefaultUserRequired(crate::error::DefaultUserRequired),
    /// <p></p>
    DuplicateUserNameFault(crate::error::DuplicateUserNameFault),
    /// <p></p>
    InvalidAclStateFault(crate::error::InvalidAclStateFault),
    /// <p></p>
    InvalidParameterCombinationException(crate::error::InvalidParameterCombinationException),
    /// <p></p>
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    /// <p></p>
    UserNotFoundFault(crate::error::UserNotFoundFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for UpdateACLError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for UpdateACLError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AclNotFoundFault(_inner) => _inner.fmt(f),
            Self::DefaultUserRequired(_inner) => _inner.fmt(f),
            Self::DuplicateUserNameFault(_inner) => _inner.fmt(f),
            Self::InvalidAclStateFault(_inner) => _inner.fmt(f),
            Self::InvalidParameterCombinationException(_inner) => _inner.fmt(f),
            Self::InvalidParameterValueException(_inner) => _inner.fmt(f),
            Self::UserNotFoundFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for UpdateACLError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AclNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DefaultUserRequired(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DuplicateUserNameFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidAclStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidParameterCombinationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidParameterValueException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UserNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::UpdateACLError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateACLError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateACLError {
    /// Creates the `UpdateACLError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `UpdateACLError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AclNotFoundFault(e) => e.meta(),
            Self::DefaultUserRequired(e) => e.meta(),
            Self::DuplicateUserNameFault(e) => e.meta(),
            Self::InvalidAclStateFault(e) => e.meta(),
            Self::InvalidParameterCombinationException(e) => e.meta(),
            Self::InvalidParameterValueException(e) => e.meta(),
            Self::UserNotFoundFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `UpdateACLError::AclNotFoundFault`.
    pub fn is_acl_not_found_fault(&self) -> bool {
        matches!(self, Self::AclNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `UpdateACLError::DefaultUserRequired`.
    pub fn is_default_user_required(&self) -> bool {
        matches!(self, Self::DefaultUserRequired(_))
    }
    /// Returns `true` if the error kind is `UpdateACLError::DuplicateUserNameFault`.
    pub fn is_duplicate_user_name_fault(&self) -> bool {
        matches!(self, Self::DuplicateUserNameFault(_))
    }
    /// Returns `true` if the error kind is `UpdateACLError::InvalidAclStateFault`.
    pub fn is_invalid_acl_state_fault(&self) -> bool {
        matches!(self, Self::InvalidAclStateFault(_))
    }
    /// Returns `true` if the error kind is `UpdateACLError::InvalidParameterCombinationException`.
    pub fn is_invalid_parameter_combination_exception(&self) -> bool {
        matches!(self, Self::InvalidParameterCombinationException(_))
    }
    /// Returns `true` if the error kind is `UpdateACLError::InvalidParameterValueException`.
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(self, Self::InvalidParameterValueException(_))
    }
    /// Returns `true` if the error kind is `UpdateACLError::UserNotFoundFault`.
    pub fn is_user_not_found_fault(&self) -> bool {
        matches!(self, Self::UserNotFoundFault(_))
    }
}
impl std::error::Error for UpdateACLError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AclNotFoundFault(_inner) => Some(_inner),
            Self::DefaultUserRequired(_inner) => Some(_inner),
            Self::DuplicateUserNameFault(_inner) => Some(_inner),
            Self::InvalidAclStateFault(_inner) => Some(_inner),
            Self::InvalidParameterCombinationException(_inner) => Some(_inner),
            Self::InvalidParameterValueException(_inner) => Some(_inner),
            Self::UserNotFoundFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DuplicateUserNameFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl DuplicateUserNameFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DuplicateUserNameFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DuplicateUserNameFault")?;
        if let Some(inner_25) = &self.message {
            {
                write!(f, ": {}", inner_25)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for DuplicateUserNameFault {}
impl aws_http::request_id::RequestId for crate::error::DuplicateUserNameFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DuplicateUserNameFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl DuplicateUserNameFault {
    /// Creates a new builder-style object to manufacture [`DuplicateUserNameFault`](crate::error::DuplicateUserNameFault).
    pub fn builder() -> crate::error::duplicate_user_name_fault::Builder {
        crate::error::duplicate_user_name_fault::Builder::default()
    }
}

/// See [`DuplicateUserNameFault`](crate::error::DuplicateUserNameFault).
pub mod duplicate_user_name_fault {

    /// A builder for [`DuplicateUserNameFault`](crate::error::DuplicateUserNameFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`DuplicateUserNameFault`](crate::error::DuplicateUserNameFault).
        pub fn build(self) -> crate::error::DuplicateUserNameFault {
            crate::error::DuplicateUserNameFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DefaultUserRequired {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl DefaultUserRequired {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DefaultUserRequired {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DefaultUserRequired")?;
        if let Some(inner_26) = &self.message {
            {
                write!(f, ": {}", inner_26)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for DefaultUserRequired {}
impl aws_http::request_id::RequestId for crate::error::DefaultUserRequired {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DefaultUserRequired {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl DefaultUserRequired {
    /// Creates a new builder-style object to manufacture [`DefaultUserRequired`](crate::error::DefaultUserRequired).
    pub fn builder() -> crate::error::default_user_required::Builder {
        crate::error::default_user_required::Builder::default()
    }
}

/// See [`DefaultUserRequired`](crate::error::DefaultUserRequired).
pub mod default_user_required {

    /// A builder for [`DefaultUserRequired`](crate::error::DefaultUserRequired).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`DefaultUserRequired`](crate::error::DefaultUserRequired).
        pub fn build(self) -> crate::error::DefaultUserRequired {
            crate::error::DefaultUserRequired {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type UntagResourceErrorKind = UntagResourceError;
/// Error type for the `UntagResourceError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UntagResourceError {
    /// <p></p>
    AclNotFoundFault(crate::error::AclNotFoundFault),
    /// <p></p>
    ClusterNotFoundFault(crate::error::ClusterNotFoundFault),
    /// <p></p>
    InvalidArnFault(crate::error::InvalidArnFault),
    /// <p></p>
    InvalidClusterStateFault(crate::error::InvalidClusterStateFault),
    /// <p></p>
    ParameterGroupNotFoundFault(crate::error::ParameterGroupNotFoundFault),
    /// <p></p>
    ServiceLinkedRoleNotFoundFault(crate::error::ServiceLinkedRoleNotFoundFault),
    /// <p></p>
    SnapshotNotFoundFault(crate::error::SnapshotNotFoundFault),
    /// <p></p>
    SubnetGroupNotFoundFault(crate::error::SubnetGroupNotFoundFault),
    /// <p></p>
    TagNotFoundFault(crate::error::TagNotFoundFault),
    /// <p></p>
    UserNotFoundFault(crate::error::UserNotFoundFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for UntagResourceError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for UntagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AclNotFoundFault(_inner) => _inner.fmt(f),
            Self::ClusterNotFoundFault(_inner) => _inner.fmt(f),
            Self::InvalidArnFault(_inner) => _inner.fmt(f),
            Self::InvalidClusterStateFault(_inner) => _inner.fmt(f),
            Self::ParameterGroupNotFoundFault(_inner) => _inner.fmt(f),
            Self::ServiceLinkedRoleNotFoundFault(_inner) => _inner.fmt(f),
            Self::SnapshotNotFoundFault(_inner) => _inner.fmt(f),
            Self::SubnetGroupNotFoundFault(_inner) => _inner.fmt(f),
            Self::TagNotFoundFault(_inner) => _inner.fmt(f),
            Self::UserNotFoundFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for UntagResourceError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AclNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ClusterNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidArnFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidClusterStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ParameterGroupNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceLinkedRoleNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::SnapshotNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::SubnetGroupNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TagNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UserNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::UntagResourceError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UntagResourceError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UntagResourceError {
    /// Creates the `UntagResourceError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `UntagResourceError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AclNotFoundFault(e) => e.meta(),
            Self::ClusterNotFoundFault(e) => e.meta(),
            Self::InvalidArnFault(e) => e.meta(),
            Self::InvalidClusterStateFault(e) => e.meta(),
            Self::ParameterGroupNotFoundFault(e) => e.meta(),
            Self::ServiceLinkedRoleNotFoundFault(e) => e.meta(),
            Self::SnapshotNotFoundFault(e) => e.meta(),
            Self::SubnetGroupNotFoundFault(e) => e.meta(),
            Self::TagNotFoundFault(e) => e.meta(),
            Self::UserNotFoundFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `UntagResourceError::AclNotFoundFault`.
    pub fn is_acl_not_found_fault(&self) -> bool {
        matches!(self, Self::AclNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `UntagResourceError::ClusterNotFoundFault`.
    pub fn is_cluster_not_found_fault(&self) -> bool {
        matches!(self, Self::ClusterNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `UntagResourceError::InvalidArnFault`.
    pub fn is_invalid_arn_fault(&self) -> bool {
        matches!(self, Self::InvalidArnFault(_))
    }
    /// Returns `true` if the error kind is `UntagResourceError::InvalidClusterStateFault`.
    pub fn is_invalid_cluster_state_fault(&self) -> bool {
        matches!(self, Self::InvalidClusterStateFault(_))
    }
    /// Returns `true` if the error kind is `UntagResourceError::ParameterGroupNotFoundFault`.
    pub fn is_parameter_group_not_found_fault(&self) -> bool {
        matches!(self, Self::ParameterGroupNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `UntagResourceError::ServiceLinkedRoleNotFoundFault`.
    pub fn is_service_linked_role_not_found_fault(&self) -> bool {
        matches!(self, Self::ServiceLinkedRoleNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `UntagResourceError::SnapshotNotFoundFault`.
    pub fn is_snapshot_not_found_fault(&self) -> bool {
        matches!(self, Self::SnapshotNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `UntagResourceError::SubnetGroupNotFoundFault`.
    pub fn is_subnet_group_not_found_fault(&self) -> bool {
        matches!(self, Self::SubnetGroupNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `UntagResourceError::TagNotFoundFault`.
    pub fn is_tag_not_found_fault(&self) -> bool {
        matches!(self, Self::TagNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `UntagResourceError::UserNotFoundFault`.
    pub fn is_user_not_found_fault(&self) -> bool {
        matches!(self, Self::UserNotFoundFault(_))
    }
}
impl std::error::Error for UntagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AclNotFoundFault(_inner) => Some(_inner),
            Self::ClusterNotFoundFault(_inner) => Some(_inner),
            Self::InvalidArnFault(_inner) => Some(_inner),
            Self::InvalidClusterStateFault(_inner) => Some(_inner),
            Self::ParameterGroupNotFoundFault(_inner) => Some(_inner),
            Self::ServiceLinkedRoleNotFoundFault(_inner) => Some(_inner),
            Self::SnapshotNotFoundFault(_inner) => Some(_inner),
            Self::SubnetGroupNotFoundFault(_inner) => Some(_inner),
            Self::TagNotFoundFault(_inner) => Some(_inner),
            Self::UserNotFoundFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TagNotFoundFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl TagNotFoundFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TagNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TagNotFoundFault")?;
        if let Some(inner_27) = &self.message {
            {
                write!(f, ": {}", inner_27)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for TagNotFoundFault {}
impl aws_http::request_id::RequestId for crate::error::TagNotFoundFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for TagNotFoundFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl TagNotFoundFault {
    /// Creates a new builder-style object to manufacture [`TagNotFoundFault`](crate::error::TagNotFoundFault).
    pub fn builder() -> crate::error::tag_not_found_fault::Builder {
        crate::error::tag_not_found_fault::Builder::default()
    }
}

/// See [`TagNotFoundFault`](crate::error::TagNotFoundFault).
pub mod tag_not_found_fault {

    /// A builder for [`TagNotFoundFault`](crate::error::TagNotFoundFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`TagNotFoundFault`](crate::error::TagNotFoundFault).
        pub fn build(self) -> crate::error::TagNotFoundFault {
            crate::error::TagNotFoundFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SnapshotNotFoundFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl SnapshotNotFoundFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for SnapshotNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SnapshotNotFoundFault")?;
        if let Some(inner_28) = &self.message {
            {
                write!(f, ": {}", inner_28)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for SnapshotNotFoundFault {}
impl aws_http::request_id::RequestId for crate::error::SnapshotNotFoundFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for SnapshotNotFoundFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl SnapshotNotFoundFault {
    /// Creates a new builder-style object to manufacture [`SnapshotNotFoundFault`](crate::error::SnapshotNotFoundFault).
    pub fn builder() -> crate::error::snapshot_not_found_fault::Builder {
        crate::error::snapshot_not_found_fault::Builder::default()
    }
}

/// See [`SnapshotNotFoundFault`](crate::error::SnapshotNotFoundFault).
pub mod snapshot_not_found_fault {

    /// A builder for [`SnapshotNotFoundFault`](crate::error::SnapshotNotFoundFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`SnapshotNotFoundFault`](crate::error::SnapshotNotFoundFault).
        pub fn build(self) -> crate::error::SnapshotNotFoundFault {
            crate::error::SnapshotNotFoundFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidArnFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidArnFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidArnFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidArnFault [InvalidARNFault]")?;
        if let Some(inner_29) = &self.message {
            {
                write!(f, ": {}", inner_29)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidArnFault {}
impl aws_http::request_id::RequestId for crate::error::InvalidArnFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidArnFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InvalidArnFault {
    /// Creates a new builder-style object to manufacture [`InvalidArnFault`](crate::error::InvalidArnFault).
    pub fn builder() -> crate::error::invalid_arn_fault::Builder {
        crate::error::invalid_arn_fault::Builder::default()
    }
}

/// See [`InvalidArnFault`](crate::error::InvalidArnFault).
pub mod invalid_arn_fault {

    /// A builder for [`InvalidArnFault`](crate::error::InvalidArnFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidArnFault`](crate::error::InvalidArnFault).
        pub fn build(self) -> crate::error::InvalidArnFault {
            crate::error::InvalidArnFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type TagResourceErrorKind = TagResourceError;
/// Error type for the `TagResourceError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum TagResourceError {
    /// <p></p>
    AclNotFoundFault(crate::error::AclNotFoundFault),
    /// <p></p>
    ClusterNotFoundFault(crate::error::ClusterNotFoundFault),
    /// <p></p>
    InvalidArnFault(crate::error::InvalidArnFault),
    /// <p></p>
    InvalidClusterStateFault(crate::error::InvalidClusterStateFault),
    /// <p></p>
    ParameterGroupNotFoundFault(crate::error::ParameterGroupNotFoundFault),
    /// <p></p>
    ServiceLinkedRoleNotFoundFault(crate::error::ServiceLinkedRoleNotFoundFault),
    /// <p></p>
    SnapshotNotFoundFault(crate::error::SnapshotNotFoundFault),
    /// <p></p>
    SubnetGroupNotFoundFault(crate::error::SubnetGroupNotFoundFault),
    /// <p></p>
    TagQuotaPerResourceExceeded(crate::error::TagQuotaPerResourceExceeded),
    /// <p></p>
    UserNotFoundFault(crate::error::UserNotFoundFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for TagResourceError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for TagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AclNotFoundFault(_inner) => _inner.fmt(f),
            Self::ClusterNotFoundFault(_inner) => _inner.fmt(f),
            Self::InvalidArnFault(_inner) => _inner.fmt(f),
            Self::InvalidClusterStateFault(_inner) => _inner.fmt(f),
            Self::ParameterGroupNotFoundFault(_inner) => _inner.fmt(f),
            Self::ServiceLinkedRoleNotFoundFault(_inner) => _inner.fmt(f),
            Self::SnapshotNotFoundFault(_inner) => _inner.fmt(f),
            Self::SubnetGroupNotFoundFault(_inner) => _inner.fmt(f),
            Self::TagQuotaPerResourceExceeded(_inner) => _inner.fmt(f),
            Self::UserNotFoundFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for TagResourceError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AclNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ClusterNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidArnFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidClusterStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ParameterGroupNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceLinkedRoleNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::SnapshotNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::SubnetGroupNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TagQuotaPerResourceExceeded(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UserNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::TagResourceError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for TagResourceError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl TagResourceError {
    /// Creates the `TagResourceError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `TagResourceError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AclNotFoundFault(e) => e.meta(),
            Self::ClusterNotFoundFault(e) => e.meta(),
            Self::InvalidArnFault(e) => e.meta(),
            Self::InvalidClusterStateFault(e) => e.meta(),
            Self::ParameterGroupNotFoundFault(e) => e.meta(),
            Self::ServiceLinkedRoleNotFoundFault(e) => e.meta(),
            Self::SnapshotNotFoundFault(e) => e.meta(),
            Self::SubnetGroupNotFoundFault(e) => e.meta(),
            Self::TagQuotaPerResourceExceeded(e) => e.meta(),
            Self::UserNotFoundFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `TagResourceError::AclNotFoundFault`.
    pub fn is_acl_not_found_fault(&self) -> bool {
        matches!(self, Self::AclNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `TagResourceError::ClusterNotFoundFault`.
    pub fn is_cluster_not_found_fault(&self) -> bool {
        matches!(self, Self::ClusterNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `TagResourceError::InvalidArnFault`.
    pub fn is_invalid_arn_fault(&self) -> bool {
        matches!(self, Self::InvalidArnFault(_))
    }
    /// Returns `true` if the error kind is `TagResourceError::InvalidClusterStateFault`.
    pub fn is_invalid_cluster_state_fault(&self) -> bool {
        matches!(self, Self::InvalidClusterStateFault(_))
    }
    /// Returns `true` if the error kind is `TagResourceError::ParameterGroupNotFoundFault`.
    pub fn is_parameter_group_not_found_fault(&self) -> bool {
        matches!(self, Self::ParameterGroupNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `TagResourceError::ServiceLinkedRoleNotFoundFault`.
    pub fn is_service_linked_role_not_found_fault(&self) -> bool {
        matches!(self, Self::ServiceLinkedRoleNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `TagResourceError::SnapshotNotFoundFault`.
    pub fn is_snapshot_not_found_fault(&self) -> bool {
        matches!(self, Self::SnapshotNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `TagResourceError::SubnetGroupNotFoundFault`.
    pub fn is_subnet_group_not_found_fault(&self) -> bool {
        matches!(self, Self::SubnetGroupNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `TagResourceError::TagQuotaPerResourceExceeded`.
    pub fn is_tag_quota_per_resource_exceeded(&self) -> bool {
        matches!(self, Self::TagQuotaPerResourceExceeded(_))
    }
    /// Returns `true` if the error kind is `TagResourceError::UserNotFoundFault`.
    pub fn is_user_not_found_fault(&self) -> bool {
        matches!(self, Self::UserNotFoundFault(_))
    }
}
impl std::error::Error for TagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AclNotFoundFault(_inner) => Some(_inner),
            Self::ClusterNotFoundFault(_inner) => Some(_inner),
            Self::InvalidArnFault(_inner) => Some(_inner),
            Self::InvalidClusterStateFault(_inner) => Some(_inner),
            Self::ParameterGroupNotFoundFault(_inner) => Some(_inner),
            Self::ServiceLinkedRoleNotFoundFault(_inner) => Some(_inner),
            Self::SnapshotNotFoundFault(_inner) => Some(_inner),
            Self::SubnetGroupNotFoundFault(_inner) => Some(_inner),
            Self::TagQuotaPerResourceExceeded(_inner) => Some(_inner),
            Self::UserNotFoundFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TagQuotaPerResourceExceeded {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl TagQuotaPerResourceExceeded {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TagQuotaPerResourceExceeded {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TagQuotaPerResourceExceeded")?;
        if let Some(inner_30) = &self.message {
            {
                write!(f, ": {}", inner_30)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for TagQuotaPerResourceExceeded {}
impl aws_http::request_id::RequestId for crate::error::TagQuotaPerResourceExceeded {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for TagQuotaPerResourceExceeded {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl TagQuotaPerResourceExceeded {
    /// Creates a new builder-style object to manufacture [`TagQuotaPerResourceExceeded`](crate::error::TagQuotaPerResourceExceeded).
    pub fn builder() -> crate::error::tag_quota_per_resource_exceeded::Builder {
        crate::error::tag_quota_per_resource_exceeded::Builder::default()
    }
}

/// See [`TagQuotaPerResourceExceeded`](crate::error::TagQuotaPerResourceExceeded).
pub mod tag_quota_per_resource_exceeded {

    /// A builder for [`TagQuotaPerResourceExceeded`](crate::error::TagQuotaPerResourceExceeded).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`TagQuotaPerResourceExceeded`](crate::error::TagQuotaPerResourceExceeded).
        pub fn build(self) -> crate::error::TagQuotaPerResourceExceeded {
            crate::error::TagQuotaPerResourceExceeded {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type ResetParameterGroupErrorKind = ResetParameterGroupError;
/// Error type for the `ResetParameterGroupError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ResetParameterGroupError {
    /// <p></p>
    InvalidParameterCombinationException(crate::error::InvalidParameterCombinationException),
    /// <p></p>
    InvalidParameterGroupStateFault(crate::error::InvalidParameterGroupStateFault),
    /// <p></p>
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    /// <p></p>
    ParameterGroupNotFoundFault(crate::error::ParameterGroupNotFoundFault),
    /// <p></p>
    ServiceLinkedRoleNotFoundFault(crate::error::ServiceLinkedRoleNotFoundFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for ResetParameterGroupError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for ResetParameterGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::InvalidParameterCombinationException(_inner) => _inner.fmt(f),
            Self::InvalidParameterGroupStateFault(_inner) => _inner.fmt(f),
            Self::InvalidParameterValueException(_inner) => _inner.fmt(f),
            Self::ParameterGroupNotFoundFault(_inner) => _inner.fmt(f),
            Self::ServiceLinkedRoleNotFoundFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ResetParameterGroupError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::InvalidParameterCombinationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidParameterGroupStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidParameterValueException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ParameterGroupNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceLinkedRoleNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::ResetParameterGroupError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ResetParameterGroupError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ResetParameterGroupError {
    /// Creates the `ResetParameterGroupError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `ResetParameterGroupError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::InvalidParameterCombinationException(e) => e.meta(),
            Self::InvalidParameterGroupStateFault(e) => e.meta(),
            Self::InvalidParameterValueException(e) => e.meta(),
            Self::ParameterGroupNotFoundFault(e) => e.meta(),
            Self::ServiceLinkedRoleNotFoundFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ResetParameterGroupError::InvalidParameterCombinationException`.
    pub fn is_invalid_parameter_combination_exception(&self) -> bool {
        matches!(self, Self::InvalidParameterCombinationException(_))
    }
    /// Returns `true` if the error kind is `ResetParameterGroupError::InvalidParameterGroupStateFault`.
    pub fn is_invalid_parameter_group_state_fault(&self) -> bool {
        matches!(self, Self::InvalidParameterGroupStateFault(_))
    }
    /// Returns `true` if the error kind is `ResetParameterGroupError::InvalidParameterValueException`.
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(self, Self::InvalidParameterValueException(_))
    }
    /// Returns `true` if the error kind is `ResetParameterGroupError::ParameterGroupNotFoundFault`.
    pub fn is_parameter_group_not_found_fault(&self) -> bool {
        matches!(self, Self::ParameterGroupNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `ResetParameterGroupError::ServiceLinkedRoleNotFoundFault`.
    pub fn is_service_linked_role_not_found_fault(&self) -> bool {
        matches!(self, Self::ServiceLinkedRoleNotFoundFault(_))
    }
}
impl std::error::Error for ResetParameterGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::InvalidParameterCombinationException(_inner) => Some(_inner),
            Self::InvalidParameterGroupStateFault(_inner) => Some(_inner),
            Self::InvalidParameterValueException(_inner) => Some(_inner),
            Self::ParameterGroupNotFoundFault(_inner) => Some(_inner),
            Self::ServiceLinkedRoleNotFoundFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type PurchaseReservedNodesOfferingErrorKind = PurchaseReservedNodesOfferingError;
/// Error type for the `PurchaseReservedNodesOfferingError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PurchaseReservedNodesOfferingError {
    /// <p></p>
    InvalidParameterCombinationException(crate::error::InvalidParameterCombinationException),
    /// <p></p>
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    /// <p>You already have a reservation with the given identifier.</p>
    ReservedNodeAlreadyExistsFault(crate::error::ReservedNodeAlreadyExistsFault),
    /// <p>The request cannot be processed because it would exceed the user's node quota.</p>
    ReservedNodeQuotaExceededFault(crate::error::ReservedNodeQuotaExceededFault),
    /// <p>The requested node offering does not exist. </p>
    ReservedNodesOfferingNotFoundFault(crate::error::ReservedNodesOfferingNotFoundFault),
    /// <p></p>
    ServiceLinkedRoleNotFoundFault(crate::error::ServiceLinkedRoleNotFoundFault),
    /// <p></p>
    TagQuotaPerResourceExceeded(crate::error::TagQuotaPerResourceExceeded),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for PurchaseReservedNodesOfferingError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for PurchaseReservedNodesOfferingError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::InvalidParameterCombinationException(_inner) => _inner.fmt(f),
            Self::InvalidParameterValueException(_inner) => _inner.fmt(f),
            Self::ReservedNodeAlreadyExistsFault(_inner) => _inner.fmt(f),
            Self::ReservedNodeQuotaExceededFault(_inner) => _inner.fmt(f),
            Self::ReservedNodesOfferingNotFoundFault(_inner) => _inner.fmt(f),
            Self::ServiceLinkedRoleNotFoundFault(_inner) => _inner.fmt(f),
            Self::TagQuotaPerResourceExceeded(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for PurchaseReservedNodesOfferingError
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::InvalidParameterCombinationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidParameterValueException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ReservedNodeAlreadyExistsFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ReservedNodeQuotaExceededFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ReservedNodesOfferingNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceLinkedRoleNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TagQuotaPerResourceExceeded(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::PurchaseReservedNodesOfferingError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for PurchaseReservedNodesOfferingError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl PurchaseReservedNodesOfferingError {
    /// Creates the `PurchaseReservedNodesOfferingError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `PurchaseReservedNodesOfferingError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::InvalidParameterCombinationException(e) => e.meta(),
            Self::InvalidParameterValueException(e) => e.meta(),
            Self::ReservedNodeAlreadyExistsFault(e) => e.meta(),
            Self::ReservedNodeQuotaExceededFault(e) => e.meta(),
            Self::ReservedNodesOfferingNotFoundFault(e) => e.meta(),
            Self::ServiceLinkedRoleNotFoundFault(e) => e.meta(),
            Self::TagQuotaPerResourceExceeded(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `PurchaseReservedNodesOfferingError::InvalidParameterCombinationException`.
    pub fn is_invalid_parameter_combination_exception(&self) -> bool {
        matches!(self, Self::InvalidParameterCombinationException(_))
    }
    /// Returns `true` if the error kind is `PurchaseReservedNodesOfferingError::InvalidParameterValueException`.
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(self, Self::InvalidParameterValueException(_))
    }
    /// Returns `true` if the error kind is `PurchaseReservedNodesOfferingError::ReservedNodeAlreadyExistsFault`.
    pub fn is_reserved_node_already_exists_fault(&self) -> bool {
        matches!(self, Self::ReservedNodeAlreadyExistsFault(_))
    }
    /// Returns `true` if the error kind is `PurchaseReservedNodesOfferingError::ReservedNodeQuotaExceededFault`.
    pub fn is_reserved_node_quota_exceeded_fault(&self) -> bool {
        matches!(self, Self::ReservedNodeQuotaExceededFault(_))
    }
    /// Returns `true` if the error kind is `PurchaseReservedNodesOfferingError::ReservedNodesOfferingNotFoundFault`.
    pub fn is_reserved_nodes_offering_not_found_fault(&self) -> bool {
        matches!(self, Self::ReservedNodesOfferingNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `PurchaseReservedNodesOfferingError::ServiceLinkedRoleNotFoundFault`.
    pub fn is_service_linked_role_not_found_fault(&self) -> bool {
        matches!(self, Self::ServiceLinkedRoleNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `PurchaseReservedNodesOfferingError::TagQuotaPerResourceExceeded`.
    pub fn is_tag_quota_per_resource_exceeded(&self) -> bool {
        matches!(self, Self::TagQuotaPerResourceExceeded(_))
    }
}
impl std::error::Error for PurchaseReservedNodesOfferingError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::InvalidParameterCombinationException(_inner) => Some(_inner),
            Self::InvalidParameterValueException(_inner) => Some(_inner),
            Self::ReservedNodeAlreadyExistsFault(_inner) => Some(_inner),
            Self::ReservedNodeQuotaExceededFault(_inner) => Some(_inner),
            Self::ReservedNodesOfferingNotFoundFault(_inner) => Some(_inner),
            Self::ServiceLinkedRoleNotFoundFault(_inner) => Some(_inner),
            Self::TagQuotaPerResourceExceeded(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The requested node offering does not exist. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ReservedNodesOfferingNotFoundFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl ReservedNodesOfferingNotFoundFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ReservedNodesOfferingNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ReservedNodesOfferingNotFoundFault")?;
        if let Some(inner_31) = &self.message {
            {
                write!(f, ": {}", inner_31)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ReservedNodesOfferingNotFoundFault {}
impl aws_http::request_id::RequestId for crate::error::ReservedNodesOfferingNotFoundFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for ReservedNodesOfferingNotFoundFault
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl ReservedNodesOfferingNotFoundFault {
    /// Creates a new builder-style object to manufacture [`ReservedNodesOfferingNotFoundFault`](crate::error::ReservedNodesOfferingNotFoundFault).
    pub fn builder() -> crate::error::reserved_nodes_offering_not_found_fault::Builder {
        crate::error::reserved_nodes_offering_not_found_fault::Builder::default()
    }
}

/// See [`ReservedNodesOfferingNotFoundFault`](crate::error::ReservedNodesOfferingNotFoundFault).
pub mod reserved_nodes_offering_not_found_fault {

    /// A builder for [`ReservedNodesOfferingNotFoundFault`](crate::error::ReservedNodesOfferingNotFoundFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`ReservedNodesOfferingNotFoundFault`](crate::error::ReservedNodesOfferingNotFoundFault).
        pub fn build(self) -> crate::error::ReservedNodesOfferingNotFoundFault {
            crate::error::ReservedNodesOfferingNotFoundFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The request cannot be processed because it would exceed the user's node quota.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ReservedNodeQuotaExceededFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl ReservedNodeQuotaExceededFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ReservedNodeQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ReservedNodeQuotaExceededFault")?;
        if let Some(inner_32) = &self.message {
            {
                write!(f, ": {}", inner_32)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ReservedNodeQuotaExceededFault {}
impl aws_http::request_id::RequestId for crate::error::ReservedNodeQuotaExceededFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ReservedNodeQuotaExceededFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl ReservedNodeQuotaExceededFault {
    /// Creates a new builder-style object to manufacture [`ReservedNodeQuotaExceededFault`](crate::error::ReservedNodeQuotaExceededFault).
    pub fn builder() -> crate::error::reserved_node_quota_exceeded_fault::Builder {
        crate::error::reserved_node_quota_exceeded_fault::Builder::default()
    }
}

/// See [`ReservedNodeQuotaExceededFault`](crate::error::ReservedNodeQuotaExceededFault).
pub mod reserved_node_quota_exceeded_fault {

    /// A builder for [`ReservedNodeQuotaExceededFault`](crate::error::ReservedNodeQuotaExceededFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`ReservedNodeQuotaExceededFault`](crate::error::ReservedNodeQuotaExceededFault).
        pub fn build(self) -> crate::error::ReservedNodeQuotaExceededFault {
            crate::error::ReservedNodeQuotaExceededFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>You already have a reservation with the given identifier.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ReservedNodeAlreadyExistsFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl ReservedNodeAlreadyExistsFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ReservedNodeAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ReservedNodeAlreadyExistsFault")?;
        if let Some(inner_33) = &self.message {
            {
                write!(f, ": {}", inner_33)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ReservedNodeAlreadyExistsFault {}
impl aws_http::request_id::RequestId for crate::error::ReservedNodeAlreadyExistsFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ReservedNodeAlreadyExistsFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl ReservedNodeAlreadyExistsFault {
    /// Creates a new builder-style object to manufacture [`ReservedNodeAlreadyExistsFault`](crate::error::ReservedNodeAlreadyExistsFault).
    pub fn builder() -> crate::error::reserved_node_already_exists_fault::Builder {
        crate::error::reserved_node_already_exists_fault::Builder::default()
    }
}

/// See [`ReservedNodeAlreadyExistsFault`](crate::error::ReservedNodeAlreadyExistsFault).
pub mod reserved_node_already_exists_fault {

    /// A builder for [`ReservedNodeAlreadyExistsFault`](crate::error::ReservedNodeAlreadyExistsFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`ReservedNodeAlreadyExistsFault`](crate::error::ReservedNodeAlreadyExistsFault).
        pub fn build(self) -> crate::error::ReservedNodeAlreadyExistsFault {
            crate::error::ReservedNodeAlreadyExistsFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type ListTagsErrorKind = ListTagsError;
/// Error type for the `ListTagsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListTagsError {
    /// <p></p>
    AclNotFoundFault(crate::error::AclNotFoundFault),
    /// <p></p>
    ClusterNotFoundFault(crate::error::ClusterNotFoundFault),
    /// <p></p>
    InvalidArnFault(crate::error::InvalidArnFault),
    /// <p></p>
    InvalidClusterStateFault(crate::error::InvalidClusterStateFault),
    /// <p></p>
    ParameterGroupNotFoundFault(crate::error::ParameterGroupNotFoundFault),
    /// <p></p>
    ServiceLinkedRoleNotFoundFault(crate::error::ServiceLinkedRoleNotFoundFault),
    /// <p></p>
    SnapshotNotFoundFault(crate::error::SnapshotNotFoundFault),
    /// <p></p>
    SubnetGroupNotFoundFault(crate::error::SubnetGroupNotFoundFault),
    /// <p></p>
    UserNotFoundFault(crate::error::UserNotFoundFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for ListTagsError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for ListTagsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AclNotFoundFault(_inner) => _inner.fmt(f),
            Self::ClusterNotFoundFault(_inner) => _inner.fmt(f),
            Self::InvalidArnFault(_inner) => _inner.fmt(f),
            Self::InvalidClusterStateFault(_inner) => _inner.fmt(f),
            Self::ParameterGroupNotFoundFault(_inner) => _inner.fmt(f),
            Self::ServiceLinkedRoleNotFoundFault(_inner) => _inner.fmt(f),
            Self::SnapshotNotFoundFault(_inner) => _inner.fmt(f),
            Self::SubnetGroupNotFoundFault(_inner) => _inner.fmt(f),
            Self::UserNotFoundFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ListTagsError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AclNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ClusterNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidArnFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidClusterStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ParameterGroupNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceLinkedRoleNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::SnapshotNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::SubnetGroupNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UserNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::ListTagsError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListTagsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListTagsError {
    /// Creates the `ListTagsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `ListTagsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AclNotFoundFault(e) => e.meta(),
            Self::ClusterNotFoundFault(e) => e.meta(),
            Self::InvalidArnFault(e) => e.meta(),
            Self::InvalidClusterStateFault(e) => e.meta(),
            Self::ParameterGroupNotFoundFault(e) => e.meta(),
            Self::ServiceLinkedRoleNotFoundFault(e) => e.meta(),
            Self::SnapshotNotFoundFault(e) => e.meta(),
            Self::SubnetGroupNotFoundFault(e) => e.meta(),
            Self::UserNotFoundFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ListTagsError::AclNotFoundFault`.
    pub fn is_acl_not_found_fault(&self) -> bool {
        matches!(self, Self::AclNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `ListTagsError::ClusterNotFoundFault`.
    pub fn is_cluster_not_found_fault(&self) -> bool {
        matches!(self, Self::ClusterNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `ListTagsError::InvalidArnFault`.
    pub fn is_invalid_arn_fault(&self) -> bool {
        matches!(self, Self::InvalidArnFault(_))
    }
    /// Returns `true` if the error kind is `ListTagsError::InvalidClusterStateFault`.
    pub fn is_invalid_cluster_state_fault(&self) -> bool {
        matches!(self, Self::InvalidClusterStateFault(_))
    }
    /// Returns `true` if the error kind is `ListTagsError::ParameterGroupNotFoundFault`.
    pub fn is_parameter_group_not_found_fault(&self) -> bool {
        matches!(self, Self::ParameterGroupNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `ListTagsError::ServiceLinkedRoleNotFoundFault`.
    pub fn is_service_linked_role_not_found_fault(&self) -> bool {
        matches!(self, Self::ServiceLinkedRoleNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `ListTagsError::SnapshotNotFoundFault`.
    pub fn is_snapshot_not_found_fault(&self) -> bool {
        matches!(self, Self::SnapshotNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `ListTagsError::SubnetGroupNotFoundFault`.
    pub fn is_subnet_group_not_found_fault(&self) -> bool {
        matches!(self, Self::SubnetGroupNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `ListTagsError::UserNotFoundFault`.
    pub fn is_user_not_found_fault(&self) -> bool {
        matches!(self, Self::UserNotFoundFault(_))
    }
}
impl std::error::Error for ListTagsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AclNotFoundFault(_inner) => Some(_inner),
            Self::ClusterNotFoundFault(_inner) => Some(_inner),
            Self::InvalidArnFault(_inner) => Some(_inner),
            Self::InvalidClusterStateFault(_inner) => Some(_inner),
            Self::ParameterGroupNotFoundFault(_inner) => Some(_inner),
            Self::ServiceLinkedRoleNotFoundFault(_inner) => Some(_inner),
            Self::SnapshotNotFoundFault(_inner) => Some(_inner),
            Self::SubnetGroupNotFoundFault(_inner) => Some(_inner),
            Self::UserNotFoundFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type ListAllowedNodeTypeUpdatesErrorKind = ListAllowedNodeTypeUpdatesError;
/// Error type for the `ListAllowedNodeTypeUpdatesError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListAllowedNodeTypeUpdatesError {
    /// <p></p>
    ClusterNotFoundFault(crate::error::ClusterNotFoundFault),
    /// <p></p>
    InvalidParameterCombinationException(crate::error::InvalidParameterCombinationException),
    /// <p></p>
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    /// <p></p>
    ServiceLinkedRoleNotFoundFault(crate::error::ServiceLinkedRoleNotFoundFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for ListAllowedNodeTypeUpdatesError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for ListAllowedNodeTypeUpdatesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ClusterNotFoundFault(_inner) => _inner.fmt(f),
            Self::InvalidParameterCombinationException(_inner) => _inner.fmt(f),
            Self::InvalidParameterValueException(_inner) => _inner.fmt(f),
            Self::ServiceLinkedRoleNotFoundFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ListAllowedNodeTypeUpdatesError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ClusterNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidParameterCombinationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidParameterValueException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceLinkedRoleNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::ListAllowedNodeTypeUpdatesError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListAllowedNodeTypeUpdatesError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListAllowedNodeTypeUpdatesError {
    /// Creates the `ListAllowedNodeTypeUpdatesError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `ListAllowedNodeTypeUpdatesError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ClusterNotFoundFault(e) => e.meta(),
            Self::InvalidParameterCombinationException(e) => e.meta(),
            Self::InvalidParameterValueException(e) => e.meta(),
            Self::ServiceLinkedRoleNotFoundFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ListAllowedNodeTypeUpdatesError::ClusterNotFoundFault`.
    pub fn is_cluster_not_found_fault(&self) -> bool {
        matches!(self, Self::ClusterNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `ListAllowedNodeTypeUpdatesError::InvalidParameterCombinationException`.
    pub fn is_invalid_parameter_combination_exception(&self) -> bool {
        matches!(self, Self::InvalidParameterCombinationException(_))
    }
    /// Returns `true` if the error kind is `ListAllowedNodeTypeUpdatesError::InvalidParameterValueException`.
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(self, Self::InvalidParameterValueException(_))
    }
    /// Returns `true` if the error kind is `ListAllowedNodeTypeUpdatesError::ServiceLinkedRoleNotFoundFault`.
    pub fn is_service_linked_role_not_found_fault(&self) -> bool {
        matches!(self, Self::ServiceLinkedRoleNotFoundFault(_))
    }
}
impl std::error::Error for ListAllowedNodeTypeUpdatesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ClusterNotFoundFault(_inner) => Some(_inner),
            Self::InvalidParameterCombinationException(_inner) => Some(_inner),
            Self::InvalidParameterValueException(_inner) => Some(_inner),
            Self::ServiceLinkedRoleNotFoundFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type FailoverShardErrorKind = FailoverShardError;
/// Error type for the `FailoverShardError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum FailoverShardError {
    /// <p></p>
    ApiCallRateForCustomerExceededFault(crate::error::ApiCallRateForCustomerExceededFault),
    /// <p></p>
    ClusterNotFoundFault(crate::error::ClusterNotFoundFault),
    /// <p></p>
    InvalidClusterStateFault(crate::error::InvalidClusterStateFault),
    /// <p></p>
    InvalidKmsKeyFault(crate::error::InvalidKmsKeyFault),
    /// <p></p>
    InvalidParameterCombinationException(crate::error::InvalidParameterCombinationException),
    /// <p></p>
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    /// <p></p>
    ShardNotFoundFault(crate::error::ShardNotFoundFault),
    /// <p></p>
    TestFailoverNotAvailableFault(crate::error::TestFailoverNotAvailableFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for FailoverShardError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for FailoverShardError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ApiCallRateForCustomerExceededFault(_inner) => _inner.fmt(f),
            Self::ClusterNotFoundFault(_inner) => _inner.fmt(f),
            Self::InvalidClusterStateFault(_inner) => _inner.fmt(f),
            Self::InvalidKmsKeyFault(_inner) => _inner.fmt(f),
            Self::InvalidParameterCombinationException(_inner) => _inner.fmt(f),
            Self::InvalidParameterValueException(_inner) => _inner.fmt(f),
            Self::ShardNotFoundFault(_inner) => _inner.fmt(f),
            Self::TestFailoverNotAvailableFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for FailoverShardError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ApiCallRateForCustomerExceededFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ClusterNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidClusterStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidKmsKeyFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidParameterCombinationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidParameterValueException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ShardNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TestFailoverNotAvailableFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::FailoverShardError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for FailoverShardError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl FailoverShardError {
    /// Creates the `FailoverShardError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `FailoverShardError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ApiCallRateForCustomerExceededFault(e) => e.meta(),
            Self::ClusterNotFoundFault(e) => e.meta(),
            Self::InvalidClusterStateFault(e) => e.meta(),
            Self::InvalidKmsKeyFault(e) => e.meta(),
            Self::InvalidParameterCombinationException(e) => e.meta(),
            Self::InvalidParameterValueException(e) => e.meta(),
            Self::ShardNotFoundFault(e) => e.meta(),
            Self::TestFailoverNotAvailableFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `FailoverShardError::ApiCallRateForCustomerExceededFault`.
    pub fn is_api_call_rate_for_customer_exceeded_fault(&self) -> bool {
        matches!(self, Self::ApiCallRateForCustomerExceededFault(_))
    }
    /// Returns `true` if the error kind is `FailoverShardError::ClusterNotFoundFault`.
    pub fn is_cluster_not_found_fault(&self) -> bool {
        matches!(self, Self::ClusterNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `FailoverShardError::InvalidClusterStateFault`.
    pub fn is_invalid_cluster_state_fault(&self) -> bool {
        matches!(self, Self::InvalidClusterStateFault(_))
    }
    /// Returns `true` if the error kind is `FailoverShardError::InvalidKmsKeyFault`.
    pub fn is_invalid_kms_key_fault(&self) -> bool {
        matches!(self, Self::InvalidKmsKeyFault(_))
    }
    /// Returns `true` if the error kind is `FailoverShardError::InvalidParameterCombinationException`.
    pub fn is_invalid_parameter_combination_exception(&self) -> bool {
        matches!(self, Self::InvalidParameterCombinationException(_))
    }
    /// Returns `true` if the error kind is `FailoverShardError::InvalidParameterValueException`.
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(self, Self::InvalidParameterValueException(_))
    }
    /// Returns `true` if the error kind is `FailoverShardError::ShardNotFoundFault`.
    pub fn is_shard_not_found_fault(&self) -> bool {
        matches!(self, Self::ShardNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `FailoverShardError::TestFailoverNotAvailableFault`.
    pub fn is_test_failover_not_available_fault(&self) -> bool {
        matches!(self, Self::TestFailoverNotAvailableFault(_))
    }
}
impl std::error::Error for FailoverShardError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ApiCallRateForCustomerExceededFault(_inner) => Some(_inner),
            Self::ClusterNotFoundFault(_inner) => Some(_inner),
            Self::InvalidClusterStateFault(_inner) => Some(_inner),
            Self::InvalidKmsKeyFault(_inner) => Some(_inner),
            Self::InvalidParameterCombinationException(_inner) => Some(_inner),
            Self::InvalidParameterValueException(_inner) => Some(_inner),
            Self::ShardNotFoundFault(_inner) => Some(_inner),
            Self::TestFailoverNotAvailableFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TestFailoverNotAvailableFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl TestFailoverNotAvailableFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TestFailoverNotAvailableFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TestFailoverNotAvailableFault")?;
        if let Some(inner_34) = &self.message {
            {
                write!(f, ": {}", inner_34)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for TestFailoverNotAvailableFault {}
impl aws_http::request_id::RequestId for crate::error::TestFailoverNotAvailableFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for TestFailoverNotAvailableFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl TestFailoverNotAvailableFault {
    /// Creates a new builder-style object to manufacture [`TestFailoverNotAvailableFault`](crate::error::TestFailoverNotAvailableFault).
    pub fn builder() -> crate::error::test_failover_not_available_fault::Builder {
        crate::error::test_failover_not_available_fault::Builder::default()
    }
}

/// See [`TestFailoverNotAvailableFault`](crate::error::TestFailoverNotAvailableFault).
pub mod test_failover_not_available_fault {

    /// A builder for [`TestFailoverNotAvailableFault`](crate::error::TestFailoverNotAvailableFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`TestFailoverNotAvailableFault`](crate::error::TestFailoverNotAvailableFault).
        pub fn build(self) -> crate::error::TestFailoverNotAvailableFault {
            crate::error::TestFailoverNotAvailableFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ShardNotFoundFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl ShardNotFoundFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ShardNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ShardNotFoundFault")?;
        if let Some(inner_35) = &self.message {
            {
                write!(f, ": {}", inner_35)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ShardNotFoundFault {}
impl aws_http::request_id::RequestId for crate::error::ShardNotFoundFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ShardNotFoundFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl ShardNotFoundFault {
    /// Creates a new builder-style object to manufacture [`ShardNotFoundFault`](crate::error::ShardNotFoundFault).
    pub fn builder() -> crate::error::shard_not_found_fault::Builder {
        crate::error::shard_not_found_fault::Builder::default()
    }
}

/// See [`ShardNotFoundFault`](crate::error::ShardNotFoundFault).
pub mod shard_not_found_fault {

    /// A builder for [`ShardNotFoundFault`](crate::error::ShardNotFoundFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`ShardNotFoundFault`](crate::error::ShardNotFoundFault).
        pub fn build(self) -> crate::error::ShardNotFoundFault {
            crate::error::ShardNotFoundFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ApiCallRateForCustomerExceededFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl ApiCallRateForCustomerExceededFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ApiCallRateForCustomerExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "ApiCallRateForCustomerExceededFault [APICallRateForCustomerExceededFault]"
        )?;
        if let Some(inner_36) = &self.message {
            {
                write!(f, ": {}", inner_36)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ApiCallRateForCustomerExceededFault {}
impl aws_http::request_id::RequestId for crate::error::ApiCallRateForCustomerExceededFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for ApiCallRateForCustomerExceededFault
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl ApiCallRateForCustomerExceededFault {
    /// Creates a new builder-style object to manufacture [`ApiCallRateForCustomerExceededFault`](crate::error::ApiCallRateForCustomerExceededFault).
    pub fn builder() -> crate::error::api_call_rate_for_customer_exceeded_fault::Builder {
        crate::error::api_call_rate_for_customer_exceeded_fault::Builder::default()
    }
}

/// See [`ApiCallRateForCustomerExceededFault`](crate::error::ApiCallRateForCustomerExceededFault).
pub mod api_call_rate_for_customer_exceeded_fault {

    /// A builder for [`ApiCallRateForCustomerExceededFault`](crate::error::ApiCallRateForCustomerExceededFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`ApiCallRateForCustomerExceededFault`](crate::error::ApiCallRateForCustomerExceededFault).
        pub fn build(self) -> crate::error::ApiCallRateForCustomerExceededFault {
            crate::error::ApiCallRateForCustomerExceededFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DescribeUsersErrorKind = DescribeUsersError;
/// Error type for the `DescribeUsersError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeUsersError {
    /// <p></p>
    InvalidParameterCombinationException(crate::error::InvalidParameterCombinationException),
    /// <p></p>
    UserNotFoundFault(crate::error::UserNotFoundFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DescribeUsersError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DescribeUsersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::InvalidParameterCombinationException(_inner) => _inner.fmt(f),
            Self::UserNotFoundFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DescribeUsersError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::InvalidParameterCombinationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UserNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DescribeUsersError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeUsersError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeUsersError {
    /// Creates the `DescribeUsersError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DescribeUsersError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::InvalidParameterCombinationException(e) => e.meta(),
            Self::UserNotFoundFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DescribeUsersError::InvalidParameterCombinationException`.
    pub fn is_invalid_parameter_combination_exception(&self) -> bool {
        matches!(self, Self::InvalidParameterCombinationException(_))
    }
    /// Returns `true` if the error kind is `DescribeUsersError::UserNotFoundFault`.
    pub fn is_user_not_found_fault(&self) -> bool {
        matches!(self, Self::UserNotFoundFault(_))
    }
}
impl std::error::Error for DescribeUsersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::InvalidParameterCombinationException(_inner) => Some(_inner),
            Self::UserNotFoundFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DescribeSubnetGroupsErrorKind = DescribeSubnetGroupsError;
/// Error type for the `DescribeSubnetGroupsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeSubnetGroupsError {
    /// <p></p>
    ServiceLinkedRoleNotFoundFault(crate::error::ServiceLinkedRoleNotFoundFault),
    /// <p></p>
    SubnetGroupNotFoundFault(crate::error::SubnetGroupNotFoundFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DescribeSubnetGroupsError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DescribeSubnetGroupsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ServiceLinkedRoleNotFoundFault(_inner) => _inner.fmt(f),
            Self::SubnetGroupNotFoundFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DescribeSubnetGroupsError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ServiceLinkedRoleNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::SubnetGroupNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DescribeSubnetGroupsError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeSubnetGroupsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeSubnetGroupsError {
    /// Creates the `DescribeSubnetGroupsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DescribeSubnetGroupsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ServiceLinkedRoleNotFoundFault(e) => e.meta(),
            Self::SubnetGroupNotFoundFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DescribeSubnetGroupsError::ServiceLinkedRoleNotFoundFault`.
    pub fn is_service_linked_role_not_found_fault(&self) -> bool {
        matches!(self, Self::ServiceLinkedRoleNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `DescribeSubnetGroupsError::SubnetGroupNotFoundFault`.
    pub fn is_subnet_group_not_found_fault(&self) -> bool {
        matches!(self, Self::SubnetGroupNotFoundFault(_))
    }
}
impl std::error::Error for DescribeSubnetGroupsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ServiceLinkedRoleNotFoundFault(_inner) => Some(_inner),
            Self::SubnetGroupNotFoundFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DescribeSnapshotsErrorKind = DescribeSnapshotsError;
/// Error type for the `DescribeSnapshotsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeSnapshotsError {
    /// <p></p>
    InvalidParameterCombinationException(crate::error::InvalidParameterCombinationException),
    /// <p></p>
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    /// <p></p>
    ServiceLinkedRoleNotFoundFault(crate::error::ServiceLinkedRoleNotFoundFault),
    /// <p></p>
    SnapshotNotFoundFault(crate::error::SnapshotNotFoundFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DescribeSnapshotsError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DescribeSnapshotsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::InvalidParameterCombinationException(_inner) => _inner.fmt(f),
            Self::InvalidParameterValueException(_inner) => _inner.fmt(f),
            Self::ServiceLinkedRoleNotFoundFault(_inner) => _inner.fmt(f),
            Self::SnapshotNotFoundFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DescribeSnapshotsError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::InvalidParameterCombinationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidParameterValueException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceLinkedRoleNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::SnapshotNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DescribeSnapshotsError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeSnapshotsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeSnapshotsError {
    /// Creates the `DescribeSnapshotsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DescribeSnapshotsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::InvalidParameterCombinationException(e) => e.meta(),
            Self::InvalidParameterValueException(e) => e.meta(),
            Self::ServiceLinkedRoleNotFoundFault(e) => e.meta(),
            Self::SnapshotNotFoundFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DescribeSnapshotsError::InvalidParameterCombinationException`.
    pub fn is_invalid_parameter_combination_exception(&self) -> bool {
        matches!(self, Self::InvalidParameterCombinationException(_))
    }
    /// Returns `true` if the error kind is `DescribeSnapshotsError::InvalidParameterValueException`.
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(self, Self::InvalidParameterValueException(_))
    }
    /// Returns `true` if the error kind is `DescribeSnapshotsError::ServiceLinkedRoleNotFoundFault`.
    pub fn is_service_linked_role_not_found_fault(&self) -> bool {
        matches!(self, Self::ServiceLinkedRoleNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `DescribeSnapshotsError::SnapshotNotFoundFault`.
    pub fn is_snapshot_not_found_fault(&self) -> bool {
        matches!(self, Self::SnapshotNotFoundFault(_))
    }
}
impl std::error::Error for DescribeSnapshotsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::InvalidParameterCombinationException(_inner) => Some(_inner),
            Self::InvalidParameterValueException(_inner) => Some(_inner),
            Self::ServiceLinkedRoleNotFoundFault(_inner) => Some(_inner),
            Self::SnapshotNotFoundFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DescribeServiceUpdatesErrorKind = DescribeServiceUpdatesError;
/// Error type for the `DescribeServiceUpdatesError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeServiceUpdatesError {
    /// <p></p>
    InvalidParameterCombinationException(crate::error::InvalidParameterCombinationException),
    /// <p></p>
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DescribeServiceUpdatesError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DescribeServiceUpdatesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::InvalidParameterCombinationException(_inner) => _inner.fmt(f),
            Self::InvalidParameterValueException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DescribeServiceUpdatesError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::InvalidParameterCombinationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidParameterValueException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DescribeServiceUpdatesError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeServiceUpdatesError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeServiceUpdatesError {
    /// Creates the `DescribeServiceUpdatesError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DescribeServiceUpdatesError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::InvalidParameterCombinationException(e) => e.meta(),
            Self::InvalidParameterValueException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DescribeServiceUpdatesError::InvalidParameterCombinationException`.
    pub fn is_invalid_parameter_combination_exception(&self) -> bool {
        matches!(self, Self::InvalidParameterCombinationException(_))
    }
    /// Returns `true` if the error kind is `DescribeServiceUpdatesError::InvalidParameterValueException`.
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(self, Self::InvalidParameterValueException(_))
    }
}
impl std::error::Error for DescribeServiceUpdatesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::InvalidParameterCombinationException(_inner) => Some(_inner),
            Self::InvalidParameterValueException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DescribeReservedNodesOfferingsErrorKind = DescribeReservedNodesOfferingsError;
/// Error type for the `DescribeReservedNodesOfferingsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeReservedNodesOfferingsError {
    /// <p></p>
    InvalidParameterCombinationException(crate::error::InvalidParameterCombinationException),
    /// <p></p>
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    /// <p>The requested node offering does not exist. </p>
    ReservedNodesOfferingNotFoundFault(crate::error::ReservedNodesOfferingNotFoundFault),
    /// <p></p>
    ServiceLinkedRoleNotFoundFault(crate::error::ServiceLinkedRoleNotFoundFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DescribeReservedNodesOfferingsError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DescribeReservedNodesOfferingsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::InvalidParameterCombinationException(_inner) => _inner.fmt(f),
            Self::InvalidParameterValueException(_inner) => _inner.fmt(f),
            Self::ReservedNodesOfferingNotFoundFault(_inner) => _inner.fmt(f),
            Self::ServiceLinkedRoleNotFoundFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for DescribeReservedNodesOfferingsError
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::InvalidParameterCombinationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidParameterValueException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ReservedNodesOfferingNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceLinkedRoleNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DescribeReservedNodesOfferingsError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeReservedNodesOfferingsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeReservedNodesOfferingsError {
    /// Creates the `DescribeReservedNodesOfferingsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DescribeReservedNodesOfferingsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::InvalidParameterCombinationException(e) => e.meta(),
            Self::InvalidParameterValueException(e) => e.meta(),
            Self::ReservedNodesOfferingNotFoundFault(e) => e.meta(),
            Self::ServiceLinkedRoleNotFoundFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DescribeReservedNodesOfferingsError::InvalidParameterCombinationException`.
    pub fn is_invalid_parameter_combination_exception(&self) -> bool {
        matches!(self, Self::InvalidParameterCombinationException(_))
    }
    /// Returns `true` if the error kind is `DescribeReservedNodesOfferingsError::InvalidParameterValueException`.
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(self, Self::InvalidParameterValueException(_))
    }
    /// Returns `true` if the error kind is `DescribeReservedNodesOfferingsError::ReservedNodesOfferingNotFoundFault`.
    pub fn is_reserved_nodes_offering_not_found_fault(&self) -> bool {
        matches!(self, Self::ReservedNodesOfferingNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `DescribeReservedNodesOfferingsError::ServiceLinkedRoleNotFoundFault`.
    pub fn is_service_linked_role_not_found_fault(&self) -> bool {
        matches!(self, Self::ServiceLinkedRoleNotFoundFault(_))
    }
}
impl std::error::Error for DescribeReservedNodesOfferingsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::InvalidParameterCombinationException(_inner) => Some(_inner),
            Self::InvalidParameterValueException(_inner) => Some(_inner),
            Self::ReservedNodesOfferingNotFoundFault(_inner) => Some(_inner),
            Self::ServiceLinkedRoleNotFoundFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DescribeReservedNodesErrorKind = DescribeReservedNodesError;
/// Error type for the `DescribeReservedNodesError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeReservedNodesError {
    /// <p></p>
    InvalidParameterCombinationException(crate::error::InvalidParameterCombinationException),
    /// <p></p>
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    /// <p>The requested node does not exist.</p>
    ReservedNodeNotFoundFault(crate::error::ReservedNodeNotFoundFault),
    /// <p></p>
    ServiceLinkedRoleNotFoundFault(crate::error::ServiceLinkedRoleNotFoundFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DescribeReservedNodesError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DescribeReservedNodesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::InvalidParameterCombinationException(_inner) => _inner.fmt(f),
            Self::InvalidParameterValueException(_inner) => _inner.fmt(f),
            Self::ReservedNodeNotFoundFault(_inner) => _inner.fmt(f),
            Self::ServiceLinkedRoleNotFoundFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DescribeReservedNodesError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::InvalidParameterCombinationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidParameterValueException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ReservedNodeNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceLinkedRoleNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DescribeReservedNodesError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeReservedNodesError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeReservedNodesError {
    /// Creates the `DescribeReservedNodesError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DescribeReservedNodesError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::InvalidParameterCombinationException(e) => e.meta(),
            Self::InvalidParameterValueException(e) => e.meta(),
            Self::ReservedNodeNotFoundFault(e) => e.meta(),
            Self::ServiceLinkedRoleNotFoundFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DescribeReservedNodesError::InvalidParameterCombinationException`.
    pub fn is_invalid_parameter_combination_exception(&self) -> bool {
        matches!(self, Self::InvalidParameterCombinationException(_))
    }
    /// Returns `true` if the error kind is `DescribeReservedNodesError::InvalidParameterValueException`.
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(self, Self::InvalidParameterValueException(_))
    }
    /// Returns `true` if the error kind is `DescribeReservedNodesError::ReservedNodeNotFoundFault`.
    pub fn is_reserved_node_not_found_fault(&self) -> bool {
        matches!(self, Self::ReservedNodeNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `DescribeReservedNodesError::ServiceLinkedRoleNotFoundFault`.
    pub fn is_service_linked_role_not_found_fault(&self) -> bool {
        matches!(self, Self::ServiceLinkedRoleNotFoundFault(_))
    }
}
impl std::error::Error for DescribeReservedNodesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::InvalidParameterCombinationException(_inner) => Some(_inner),
            Self::InvalidParameterValueException(_inner) => Some(_inner),
            Self::ReservedNodeNotFoundFault(_inner) => Some(_inner),
            Self::ServiceLinkedRoleNotFoundFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The requested node does not exist.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ReservedNodeNotFoundFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl ReservedNodeNotFoundFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ReservedNodeNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ReservedNodeNotFoundFault")?;
        if let Some(inner_37) = &self.message {
            {
                write!(f, ": {}", inner_37)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ReservedNodeNotFoundFault {}
impl aws_http::request_id::RequestId for crate::error::ReservedNodeNotFoundFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ReservedNodeNotFoundFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl ReservedNodeNotFoundFault {
    /// Creates a new builder-style object to manufacture [`ReservedNodeNotFoundFault`](crate::error::ReservedNodeNotFoundFault).
    pub fn builder() -> crate::error::reserved_node_not_found_fault::Builder {
        crate::error::reserved_node_not_found_fault::Builder::default()
    }
}

/// See [`ReservedNodeNotFoundFault`](crate::error::ReservedNodeNotFoundFault).
pub mod reserved_node_not_found_fault {

    /// A builder for [`ReservedNodeNotFoundFault`](crate::error::ReservedNodeNotFoundFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`ReservedNodeNotFoundFault`](crate::error::ReservedNodeNotFoundFault).
        pub fn build(self) -> crate::error::ReservedNodeNotFoundFault {
            crate::error::ReservedNodeNotFoundFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DescribeParametersErrorKind = DescribeParametersError;
/// Error type for the `DescribeParametersError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeParametersError {
    /// <p></p>
    InvalidParameterCombinationException(crate::error::InvalidParameterCombinationException),
    /// <p></p>
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    /// <p></p>
    ParameterGroupNotFoundFault(crate::error::ParameterGroupNotFoundFault),
    /// <p></p>
    ServiceLinkedRoleNotFoundFault(crate::error::ServiceLinkedRoleNotFoundFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DescribeParametersError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DescribeParametersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::InvalidParameterCombinationException(_inner) => _inner.fmt(f),
            Self::InvalidParameterValueException(_inner) => _inner.fmt(f),
            Self::ParameterGroupNotFoundFault(_inner) => _inner.fmt(f),
            Self::ServiceLinkedRoleNotFoundFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DescribeParametersError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::InvalidParameterCombinationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidParameterValueException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ParameterGroupNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceLinkedRoleNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DescribeParametersError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeParametersError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeParametersError {
    /// Creates the `DescribeParametersError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DescribeParametersError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::InvalidParameterCombinationException(e) => e.meta(),
            Self::InvalidParameterValueException(e) => e.meta(),
            Self::ParameterGroupNotFoundFault(e) => e.meta(),
            Self::ServiceLinkedRoleNotFoundFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DescribeParametersError::InvalidParameterCombinationException`.
    pub fn is_invalid_parameter_combination_exception(&self) -> bool {
        matches!(self, Self::InvalidParameterCombinationException(_))
    }
    /// Returns `true` if the error kind is `DescribeParametersError::InvalidParameterValueException`.
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(self, Self::InvalidParameterValueException(_))
    }
    /// Returns `true` if the error kind is `DescribeParametersError::ParameterGroupNotFoundFault`.
    pub fn is_parameter_group_not_found_fault(&self) -> bool {
        matches!(self, Self::ParameterGroupNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `DescribeParametersError::ServiceLinkedRoleNotFoundFault`.
    pub fn is_service_linked_role_not_found_fault(&self) -> bool {
        matches!(self, Self::ServiceLinkedRoleNotFoundFault(_))
    }
}
impl std::error::Error for DescribeParametersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::InvalidParameterCombinationException(_inner) => Some(_inner),
            Self::InvalidParameterValueException(_inner) => Some(_inner),
            Self::ParameterGroupNotFoundFault(_inner) => Some(_inner),
            Self::ServiceLinkedRoleNotFoundFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DescribeParameterGroupsErrorKind = DescribeParameterGroupsError;
/// Error type for the `DescribeParameterGroupsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeParameterGroupsError {
    /// <p></p>
    InvalidParameterCombinationException(crate::error::InvalidParameterCombinationException),
    /// <p></p>
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    /// <p></p>
    ParameterGroupNotFoundFault(crate::error::ParameterGroupNotFoundFault),
    /// <p></p>
    ServiceLinkedRoleNotFoundFault(crate::error::ServiceLinkedRoleNotFoundFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DescribeParameterGroupsError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DescribeParameterGroupsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::InvalidParameterCombinationException(_inner) => _inner.fmt(f),
            Self::InvalidParameterValueException(_inner) => _inner.fmt(f),
            Self::ParameterGroupNotFoundFault(_inner) => _inner.fmt(f),
            Self::ServiceLinkedRoleNotFoundFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DescribeParameterGroupsError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::InvalidParameterCombinationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidParameterValueException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ParameterGroupNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceLinkedRoleNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DescribeParameterGroupsError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeParameterGroupsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeParameterGroupsError {
    /// Creates the `DescribeParameterGroupsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DescribeParameterGroupsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::InvalidParameterCombinationException(e) => e.meta(),
            Self::InvalidParameterValueException(e) => e.meta(),
            Self::ParameterGroupNotFoundFault(e) => e.meta(),
            Self::ServiceLinkedRoleNotFoundFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DescribeParameterGroupsError::InvalidParameterCombinationException`.
    pub fn is_invalid_parameter_combination_exception(&self) -> bool {
        matches!(self, Self::InvalidParameterCombinationException(_))
    }
    /// Returns `true` if the error kind is `DescribeParameterGroupsError::InvalidParameterValueException`.
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(self, Self::InvalidParameterValueException(_))
    }
    /// Returns `true` if the error kind is `DescribeParameterGroupsError::ParameterGroupNotFoundFault`.
    pub fn is_parameter_group_not_found_fault(&self) -> bool {
        matches!(self, Self::ParameterGroupNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `DescribeParameterGroupsError::ServiceLinkedRoleNotFoundFault`.
    pub fn is_service_linked_role_not_found_fault(&self) -> bool {
        matches!(self, Self::ServiceLinkedRoleNotFoundFault(_))
    }
}
impl std::error::Error for DescribeParameterGroupsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::InvalidParameterCombinationException(_inner) => Some(_inner),
            Self::InvalidParameterValueException(_inner) => Some(_inner),
            Self::ParameterGroupNotFoundFault(_inner) => Some(_inner),
            Self::ServiceLinkedRoleNotFoundFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DescribeEventsErrorKind = DescribeEventsError;
/// Error type for the `DescribeEventsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeEventsError {
    /// <p></p>
    InvalidParameterCombinationException(crate::error::InvalidParameterCombinationException),
    /// <p></p>
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    /// <p></p>
    ServiceLinkedRoleNotFoundFault(crate::error::ServiceLinkedRoleNotFoundFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DescribeEventsError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DescribeEventsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::InvalidParameterCombinationException(_inner) => _inner.fmt(f),
            Self::InvalidParameterValueException(_inner) => _inner.fmt(f),
            Self::ServiceLinkedRoleNotFoundFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DescribeEventsError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::InvalidParameterCombinationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidParameterValueException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceLinkedRoleNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DescribeEventsError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeEventsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeEventsError {
    /// Creates the `DescribeEventsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DescribeEventsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::InvalidParameterCombinationException(e) => e.meta(),
            Self::InvalidParameterValueException(e) => e.meta(),
            Self::ServiceLinkedRoleNotFoundFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DescribeEventsError::InvalidParameterCombinationException`.
    pub fn is_invalid_parameter_combination_exception(&self) -> bool {
        matches!(self, Self::InvalidParameterCombinationException(_))
    }
    /// Returns `true` if the error kind is `DescribeEventsError::InvalidParameterValueException`.
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(self, Self::InvalidParameterValueException(_))
    }
    /// Returns `true` if the error kind is `DescribeEventsError::ServiceLinkedRoleNotFoundFault`.
    pub fn is_service_linked_role_not_found_fault(&self) -> bool {
        matches!(self, Self::ServiceLinkedRoleNotFoundFault(_))
    }
}
impl std::error::Error for DescribeEventsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::InvalidParameterCombinationException(_inner) => Some(_inner),
            Self::InvalidParameterValueException(_inner) => Some(_inner),
            Self::ServiceLinkedRoleNotFoundFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DescribeEngineVersionsErrorKind = DescribeEngineVersionsError;
/// Error type for the `DescribeEngineVersionsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeEngineVersionsError {
    /// <p></p>
    InvalidParameterCombinationException(crate::error::InvalidParameterCombinationException),
    /// <p></p>
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    /// <p></p>
    ServiceLinkedRoleNotFoundFault(crate::error::ServiceLinkedRoleNotFoundFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DescribeEngineVersionsError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DescribeEngineVersionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::InvalidParameterCombinationException(_inner) => _inner.fmt(f),
            Self::InvalidParameterValueException(_inner) => _inner.fmt(f),
            Self::ServiceLinkedRoleNotFoundFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DescribeEngineVersionsError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::InvalidParameterCombinationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidParameterValueException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceLinkedRoleNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DescribeEngineVersionsError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeEngineVersionsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeEngineVersionsError {
    /// Creates the `DescribeEngineVersionsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DescribeEngineVersionsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::InvalidParameterCombinationException(e) => e.meta(),
            Self::InvalidParameterValueException(e) => e.meta(),
            Self::ServiceLinkedRoleNotFoundFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DescribeEngineVersionsError::InvalidParameterCombinationException`.
    pub fn is_invalid_parameter_combination_exception(&self) -> bool {
        matches!(self, Self::InvalidParameterCombinationException(_))
    }
    /// Returns `true` if the error kind is `DescribeEngineVersionsError::InvalidParameterValueException`.
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(self, Self::InvalidParameterValueException(_))
    }
    /// Returns `true` if the error kind is `DescribeEngineVersionsError::ServiceLinkedRoleNotFoundFault`.
    pub fn is_service_linked_role_not_found_fault(&self) -> bool {
        matches!(self, Self::ServiceLinkedRoleNotFoundFault(_))
    }
}
impl std::error::Error for DescribeEngineVersionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::InvalidParameterCombinationException(_inner) => Some(_inner),
            Self::InvalidParameterValueException(_inner) => Some(_inner),
            Self::ServiceLinkedRoleNotFoundFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DescribeClustersErrorKind = DescribeClustersError;
/// Error type for the `DescribeClustersError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeClustersError {
    /// <p></p>
    ClusterNotFoundFault(crate::error::ClusterNotFoundFault),
    /// <p></p>
    InvalidParameterCombinationException(crate::error::InvalidParameterCombinationException),
    /// <p></p>
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    /// <p></p>
    ServiceLinkedRoleNotFoundFault(crate::error::ServiceLinkedRoleNotFoundFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DescribeClustersError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DescribeClustersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ClusterNotFoundFault(_inner) => _inner.fmt(f),
            Self::InvalidParameterCombinationException(_inner) => _inner.fmt(f),
            Self::InvalidParameterValueException(_inner) => _inner.fmt(f),
            Self::ServiceLinkedRoleNotFoundFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DescribeClustersError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ClusterNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidParameterCombinationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidParameterValueException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceLinkedRoleNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DescribeClustersError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeClustersError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeClustersError {
    /// Creates the `DescribeClustersError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DescribeClustersError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ClusterNotFoundFault(e) => e.meta(),
            Self::InvalidParameterCombinationException(e) => e.meta(),
            Self::InvalidParameterValueException(e) => e.meta(),
            Self::ServiceLinkedRoleNotFoundFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DescribeClustersError::ClusterNotFoundFault`.
    pub fn is_cluster_not_found_fault(&self) -> bool {
        matches!(self, Self::ClusterNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `DescribeClustersError::InvalidParameterCombinationException`.
    pub fn is_invalid_parameter_combination_exception(&self) -> bool {
        matches!(self, Self::InvalidParameterCombinationException(_))
    }
    /// Returns `true` if the error kind is `DescribeClustersError::InvalidParameterValueException`.
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(self, Self::InvalidParameterValueException(_))
    }
    /// Returns `true` if the error kind is `DescribeClustersError::ServiceLinkedRoleNotFoundFault`.
    pub fn is_service_linked_role_not_found_fault(&self) -> bool {
        matches!(self, Self::ServiceLinkedRoleNotFoundFault(_))
    }
}
impl std::error::Error for DescribeClustersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ClusterNotFoundFault(_inner) => Some(_inner),
            Self::InvalidParameterCombinationException(_inner) => Some(_inner),
            Self::InvalidParameterValueException(_inner) => Some(_inner),
            Self::ServiceLinkedRoleNotFoundFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DescribeACLsErrorKind = DescribeACLsError;
/// Error type for the `DescribeACLsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeACLsError {
    /// <p></p>
    AclNotFoundFault(crate::error::AclNotFoundFault),
    /// <p></p>
    InvalidParameterCombinationException(crate::error::InvalidParameterCombinationException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DescribeACLsError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DescribeACLsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AclNotFoundFault(_inner) => _inner.fmt(f),
            Self::InvalidParameterCombinationException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DescribeACLsError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AclNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidParameterCombinationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DescribeACLsError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeACLsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeACLsError {
    /// Creates the `DescribeACLsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DescribeACLsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AclNotFoundFault(e) => e.meta(),
            Self::InvalidParameterCombinationException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DescribeACLsError::AclNotFoundFault`.
    pub fn is_acl_not_found_fault(&self) -> bool {
        matches!(self, Self::AclNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `DescribeACLsError::InvalidParameterCombinationException`.
    pub fn is_invalid_parameter_combination_exception(&self) -> bool {
        matches!(self, Self::InvalidParameterCombinationException(_))
    }
}
impl std::error::Error for DescribeACLsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AclNotFoundFault(_inner) => Some(_inner),
            Self::InvalidParameterCombinationException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DeleteUserErrorKind = DeleteUserError;
/// Error type for the `DeleteUserError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteUserError {
    /// <p></p>
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    /// <p></p>
    InvalidUserStateFault(crate::error::InvalidUserStateFault),
    /// <p></p>
    UserNotFoundFault(crate::error::UserNotFoundFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DeleteUserError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DeleteUserError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::InvalidParameterValueException(_inner) => _inner.fmt(f),
            Self::InvalidUserStateFault(_inner) => _inner.fmt(f),
            Self::UserNotFoundFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DeleteUserError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::InvalidParameterValueException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidUserStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UserNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DeleteUserError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteUserError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteUserError {
    /// Creates the `DeleteUserError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DeleteUserError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::InvalidParameterValueException(e) => e.meta(),
            Self::InvalidUserStateFault(e) => e.meta(),
            Self::UserNotFoundFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DeleteUserError::InvalidParameterValueException`.
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(self, Self::InvalidParameterValueException(_))
    }
    /// Returns `true` if the error kind is `DeleteUserError::InvalidUserStateFault`.
    pub fn is_invalid_user_state_fault(&self) -> bool {
        matches!(self, Self::InvalidUserStateFault(_))
    }
    /// Returns `true` if the error kind is `DeleteUserError::UserNotFoundFault`.
    pub fn is_user_not_found_fault(&self) -> bool {
        matches!(self, Self::UserNotFoundFault(_))
    }
}
impl std::error::Error for DeleteUserError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::InvalidParameterValueException(_inner) => Some(_inner),
            Self::InvalidUserStateFault(_inner) => Some(_inner),
            Self::UserNotFoundFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DeleteSubnetGroupErrorKind = DeleteSubnetGroupError;
/// Error type for the `DeleteSubnetGroupError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteSubnetGroupError {
    /// <p></p>
    ServiceLinkedRoleNotFoundFault(crate::error::ServiceLinkedRoleNotFoundFault),
    /// <p></p>
    SubnetGroupInUseFault(crate::error::SubnetGroupInUseFault),
    /// <p></p>
    SubnetGroupNotFoundFault(crate::error::SubnetGroupNotFoundFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DeleteSubnetGroupError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DeleteSubnetGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ServiceLinkedRoleNotFoundFault(_inner) => _inner.fmt(f),
            Self::SubnetGroupInUseFault(_inner) => _inner.fmt(f),
            Self::SubnetGroupNotFoundFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DeleteSubnetGroupError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ServiceLinkedRoleNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::SubnetGroupInUseFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::SubnetGroupNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DeleteSubnetGroupError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteSubnetGroupError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteSubnetGroupError {
    /// Creates the `DeleteSubnetGroupError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DeleteSubnetGroupError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ServiceLinkedRoleNotFoundFault(e) => e.meta(),
            Self::SubnetGroupInUseFault(e) => e.meta(),
            Self::SubnetGroupNotFoundFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DeleteSubnetGroupError::ServiceLinkedRoleNotFoundFault`.
    pub fn is_service_linked_role_not_found_fault(&self) -> bool {
        matches!(self, Self::ServiceLinkedRoleNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `DeleteSubnetGroupError::SubnetGroupInUseFault`.
    pub fn is_subnet_group_in_use_fault(&self) -> bool {
        matches!(self, Self::SubnetGroupInUseFault(_))
    }
    /// Returns `true` if the error kind is `DeleteSubnetGroupError::SubnetGroupNotFoundFault`.
    pub fn is_subnet_group_not_found_fault(&self) -> bool {
        matches!(self, Self::SubnetGroupNotFoundFault(_))
    }
}
impl std::error::Error for DeleteSubnetGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ServiceLinkedRoleNotFoundFault(_inner) => Some(_inner),
            Self::SubnetGroupInUseFault(_inner) => Some(_inner),
            Self::SubnetGroupNotFoundFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SubnetGroupInUseFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl SubnetGroupInUseFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for SubnetGroupInUseFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SubnetGroupInUseFault")?;
        if let Some(inner_38) = &self.message {
            {
                write!(f, ": {}", inner_38)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for SubnetGroupInUseFault {}
impl aws_http::request_id::RequestId for crate::error::SubnetGroupInUseFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for SubnetGroupInUseFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl SubnetGroupInUseFault {
    /// Creates a new builder-style object to manufacture [`SubnetGroupInUseFault`](crate::error::SubnetGroupInUseFault).
    pub fn builder() -> crate::error::subnet_group_in_use_fault::Builder {
        crate::error::subnet_group_in_use_fault::Builder::default()
    }
}

/// See [`SubnetGroupInUseFault`](crate::error::SubnetGroupInUseFault).
pub mod subnet_group_in_use_fault {

    /// A builder for [`SubnetGroupInUseFault`](crate::error::SubnetGroupInUseFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`SubnetGroupInUseFault`](crate::error::SubnetGroupInUseFault).
        pub fn build(self) -> crate::error::SubnetGroupInUseFault {
            crate::error::SubnetGroupInUseFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DeleteSnapshotErrorKind = DeleteSnapshotError;
/// Error type for the `DeleteSnapshotError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteSnapshotError {
    /// <p></p>
    InvalidParameterCombinationException(crate::error::InvalidParameterCombinationException),
    /// <p></p>
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    /// <p></p>
    InvalidSnapshotStateFault(crate::error::InvalidSnapshotStateFault),
    /// <p></p>
    ServiceLinkedRoleNotFoundFault(crate::error::ServiceLinkedRoleNotFoundFault),
    /// <p></p>
    SnapshotNotFoundFault(crate::error::SnapshotNotFoundFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DeleteSnapshotError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DeleteSnapshotError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::InvalidParameterCombinationException(_inner) => _inner.fmt(f),
            Self::InvalidParameterValueException(_inner) => _inner.fmt(f),
            Self::InvalidSnapshotStateFault(_inner) => _inner.fmt(f),
            Self::ServiceLinkedRoleNotFoundFault(_inner) => _inner.fmt(f),
            Self::SnapshotNotFoundFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DeleteSnapshotError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::InvalidParameterCombinationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidParameterValueException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidSnapshotStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceLinkedRoleNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::SnapshotNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DeleteSnapshotError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteSnapshotError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteSnapshotError {
    /// Creates the `DeleteSnapshotError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DeleteSnapshotError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::InvalidParameterCombinationException(e) => e.meta(),
            Self::InvalidParameterValueException(e) => e.meta(),
            Self::InvalidSnapshotStateFault(e) => e.meta(),
            Self::ServiceLinkedRoleNotFoundFault(e) => e.meta(),
            Self::SnapshotNotFoundFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DeleteSnapshotError::InvalidParameterCombinationException`.
    pub fn is_invalid_parameter_combination_exception(&self) -> bool {
        matches!(self, Self::InvalidParameterCombinationException(_))
    }
    /// Returns `true` if the error kind is `DeleteSnapshotError::InvalidParameterValueException`.
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(self, Self::InvalidParameterValueException(_))
    }
    /// Returns `true` if the error kind is `DeleteSnapshotError::InvalidSnapshotStateFault`.
    pub fn is_invalid_snapshot_state_fault(&self) -> bool {
        matches!(self, Self::InvalidSnapshotStateFault(_))
    }
    /// Returns `true` if the error kind is `DeleteSnapshotError::ServiceLinkedRoleNotFoundFault`.
    pub fn is_service_linked_role_not_found_fault(&self) -> bool {
        matches!(self, Self::ServiceLinkedRoleNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `DeleteSnapshotError::SnapshotNotFoundFault`.
    pub fn is_snapshot_not_found_fault(&self) -> bool {
        matches!(self, Self::SnapshotNotFoundFault(_))
    }
}
impl std::error::Error for DeleteSnapshotError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::InvalidParameterCombinationException(_inner) => Some(_inner),
            Self::InvalidParameterValueException(_inner) => Some(_inner),
            Self::InvalidSnapshotStateFault(_inner) => Some(_inner),
            Self::ServiceLinkedRoleNotFoundFault(_inner) => Some(_inner),
            Self::SnapshotNotFoundFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidSnapshotStateFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidSnapshotStateFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidSnapshotStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidSnapshotStateFault")?;
        if let Some(inner_39) = &self.message {
            {
                write!(f, ": {}", inner_39)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidSnapshotStateFault {}
impl aws_http::request_id::RequestId for crate::error::InvalidSnapshotStateFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidSnapshotStateFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InvalidSnapshotStateFault {
    /// Creates a new builder-style object to manufacture [`InvalidSnapshotStateFault`](crate::error::InvalidSnapshotStateFault).
    pub fn builder() -> crate::error::invalid_snapshot_state_fault::Builder {
        crate::error::invalid_snapshot_state_fault::Builder::default()
    }
}

/// See [`InvalidSnapshotStateFault`](crate::error::InvalidSnapshotStateFault).
pub mod invalid_snapshot_state_fault {

    /// A builder for [`InvalidSnapshotStateFault`](crate::error::InvalidSnapshotStateFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidSnapshotStateFault`](crate::error::InvalidSnapshotStateFault).
        pub fn build(self) -> crate::error::InvalidSnapshotStateFault {
            crate::error::InvalidSnapshotStateFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DeleteParameterGroupErrorKind = DeleteParameterGroupError;
/// Error type for the `DeleteParameterGroupError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteParameterGroupError {
    /// <p></p>
    InvalidParameterCombinationException(crate::error::InvalidParameterCombinationException),
    /// <p></p>
    InvalidParameterGroupStateFault(crate::error::InvalidParameterGroupStateFault),
    /// <p></p>
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    /// <p></p>
    ParameterGroupNotFoundFault(crate::error::ParameterGroupNotFoundFault),
    /// <p></p>
    ServiceLinkedRoleNotFoundFault(crate::error::ServiceLinkedRoleNotFoundFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DeleteParameterGroupError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DeleteParameterGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::InvalidParameterCombinationException(_inner) => _inner.fmt(f),
            Self::InvalidParameterGroupStateFault(_inner) => _inner.fmt(f),
            Self::InvalidParameterValueException(_inner) => _inner.fmt(f),
            Self::ParameterGroupNotFoundFault(_inner) => _inner.fmt(f),
            Self::ServiceLinkedRoleNotFoundFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DeleteParameterGroupError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::InvalidParameterCombinationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidParameterGroupStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidParameterValueException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ParameterGroupNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceLinkedRoleNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DeleteParameterGroupError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteParameterGroupError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteParameterGroupError {
    /// Creates the `DeleteParameterGroupError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DeleteParameterGroupError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::InvalidParameterCombinationException(e) => e.meta(),
            Self::InvalidParameterGroupStateFault(e) => e.meta(),
            Self::InvalidParameterValueException(e) => e.meta(),
            Self::ParameterGroupNotFoundFault(e) => e.meta(),
            Self::ServiceLinkedRoleNotFoundFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DeleteParameterGroupError::InvalidParameterCombinationException`.
    pub fn is_invalid_parameter_combination_exception(&self) -> bool {
        matches!(self, Self::InvalidParameterCombinationException(_))
    }
    /// Returns `true` if the error kind is `DeleteParameterGroupError::InvalidParameterGroupStateFault`.
    pub fn is_invalid_parameter_group_state_fault(&self) -> bool {
        matches!(self, Self::InvalidParameterGroupStateFault(_))
    }
    /// Returns `true` if the error kind is `DeleteParameterGroupError::InvalidParameterValueException`.
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(self, Self::InvalidParameterValueException(_))
    }
    /// Returns `true` if the error kind is `DeleteParameterGroupError::ParameterGroupNotFoundFault`.
    pub fn is_parameter_group_not_found_fault(&self) -> bool {
        matches!(self, Self::ParameterGroupNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `DeleteParameterGroupError::ServiceLinkedRoleNotFoundFault`.
    pub fn is_service_linked_role_not_found_fault(&self) -> bool {
        matches!(self, Self::ServiceLinkedRoleNotFoundFault(_))
    }
}
impl std::error::Error for DeleteParameterGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::InvalidParameterCombinationException(_inner) => Some(_inner),
            Self::InvalidParameterGroupStateFault(_inner) => Some(_inner),
            Self::InvalidParameterValueException(_inner) => Some(_inner),
            Self::ParameterGroupNotFoundFault(_inner) => Some(_inner),
            Self::ServiceLinkedRoleNotFoundFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DeleteClusterErrorKind = DeleteClusterError;
/// Error type for the `DeleteClusterError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteClusterError {
    /// <p></p>
    ClusterNotFoundFault(crate::error::ClusterNotFoundFault),
    /// <p></p>
    InvalidClusterStateFault(crate::error::InvalidClusterStateFault),
    /// <p></p>
    InvalidParameterCombinationException(crate::error::InvalidParameterCombinationException),
    /// <p></p>
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    /// <p></p>
    ServiceLinkedRoleNotFoundFault(crate::error::ServiceLinkedRoleNotFoundFault),
    /// <p></p>
    SnapshotAlreadyExistsFault(crate::error::SnapshotAlreadyExistsFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DeleteClusterError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DeleteClusterError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ClusterNotFoundFault(_inner) => _inner.fmt(f),
            Self::InvalidClusterStateFault(_inner) => _inner.fmt(f),
            Self::InvalidParameterCombinationException(_inner) => _inner.fmt(f),
            Self::InvalidParameterValueException(_inner) => _inner.fmt(f),
            Self::ServiceLinkedRoleNotFoundFault(_inner) => _inner.fmt(f),
            Self::SnapshotAlreadyExistsFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DeleteClusterError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ClusterNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidClusterStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidParameterCombinationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidParameterValueException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceLinkedRoleNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::SnapshotAlreadyExistsFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DeleteClusterError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteClusterError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteClusterError {
    /// Creates the `DeleteClusterError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DeleteClusterError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ClusterNotFoundFault(e) => e.meta(),
            Self::InvalidClusterStateFault(e) => e.meta(),
            Self::InvalidParameterCombinationException(e) => e.meta(),
            Self::InvalidParameterValueException(e) => e.meta(),
            Self::ServiceLinkedRoleNotFoundFault(e) => e.meta(),
            Self::SnapshotAlreadyExistsFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DeleteClusterError::ClusterNotFoundFault`.
    pub fn is_cluster_not_found_fault(&self) -> bool {
        matches!(self, Self::ClusterNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `DeleteClusterError::InvalidClusterStateFault`.
    pub fn is_invalid_cluster_state_fault(&self) -> bool {
        matches!(self, Self::InvalidClusterStateFault(_))
    }
    /// Returns `true` if the error kind is `DeleteClusterError::InvalidParameterCombinationException`.
    pub fn is_invalid_parameter_combination_exception(&self) -> bool {
        matches!(self, Self::InvalidParameterCombinationException(_))
    }
    /// Returns `true` if the error kind is `DeleteClusterError::InvalidParameterValueException`.
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(self, Self::InvalidParameterValueException(_))
    }
    /// Returns `true` if the error kind is `DeleteClusterError::ServiceLinkedRoleNotFoundFault`.
    pub fn is_service_linked_role_not_found_fault(&self) -> bool {
        matches!(self, Self::ServiceLinkedRoleNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `DeleteClusterError::SnapshotAlreadyExistsFault`.
    pub fn is_snapshot_already_exists_fault(&self) -> bool {
        matches!(self, Self::SnapshotAlreadyExistsFault(_))
    }
}
impl std::error::Error for DeleteClusterError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ClusterNotFoundFault(_inner) => Some(_inner),
            Self::InvalidClusterStateFault(_inner) => Some(_inner),
            Self::InvalidParameterCombinationException(_inner) => Some(_inner),
            Self::InvalidParameterValueException(_inner) => Some(_inner),
            Self::ServiceLinkedRoleNotFoundFault(_inner) => Some(_inner),
            Self::SnapshotAlreadyExistsFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SnapshotAlreadyExistsFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl SnapshotAlreadyExistsFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for SnapshotAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SnapshotAlreadyExistsFault")?;
        if let Some(inner_40) = &self.message {
            {
                write!(f, ": {}", inner_40)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for SnapshotAlreadyExistsFault {}
impl aws_http::request_id::RequestId for crate::error::SnapshotAlreadyExistsFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for SnapshotAlreadyExistsFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl SnapshotAlreadyExistsFault {
    /// Creates a new builder-style object to manufacture [`SnapshotAlreadyExistsFault`](crate::error::SnapshotAlreadyExistsFault).
    pub fn builder() -> crate::error::snapshot_already_exists_fault::Builder {
        crate::error::snapshot_already_exists_fault::Builder::default()
    }
}

/// See [`SnapshotAlreadyExistsFault`](crate::error::SnapshotAlreadyExistsFault).
pub mod snapshot_already_exists_fault {

    /// A builder for [`SnapshotAlreadyExistsFault`](crate::error::SnapshotAlreadyExistsFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`SnapshotAlreadyExistsFault`](crate::error::SnapshotAlreadyExistsFault).
        pub fn build(self) -> crate::error::SnapshotAlreadyExistsFault {
            crate::error::SnapshotAlreadyExistsFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DeleteACLErrorKind = DeleteACLError;
/// Error type for the `DeleteACLError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteACLError {
    /// <p></p>
    AclNotFoundFault(crate::error::AclNotFoundFault),
    /// <p></p>
    InvalidAclStateFault(crate::error::InvalidAclStateFault),
    /// <p></p>
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DeleteACLError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DeleteACLError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AclNotFoundFault(_inner) => _inner.fmt(f),
            Self::InvalidAclStateFault(_inner) => _inner.fmt(f),
            Self::InvalidParameterValueException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DeleteACLError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AclNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidAclStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidParameterValueException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DeleteACLError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteACLError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteACLError {
    /// Creates the `DeleteACLError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DeleteACLError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AclNotFoundFault(e) => e.meta(),
            Self::InvalidAclStateFault(e) => e.meta(),
            Self::InvalidParameterValueException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DeleteACLError::AclNotFoundFault`.
    pub fn is_acl_not_found_fault(&self) -> bool {
        matches!(self, Self::AclNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `DeleteACLError::InvalidAclStateFault`.
    pub fn is_invalid_acl_state_fault(&self) -> bool {
        matches!(self, Self::InvalidAclStateFault(_))
    }
    /// Returns `true` if the error kind is `DeleteACLError::InvalidParameterValueException`.
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(self, Self::InvalidParameterValueException(_))
    }
}
impl std::error::Error for DeleteACLError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AclNotFoundFault(_inner) => Some(_inner),
            Self::InvalidAclStateFault(_inner) => Some(_inner),
            Self::InvalidParameterValueException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type CreateUserErrorKind = CreateUserError;
/// Error type for the `CreateUserError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateUserError {
    /// <p></p>
    DuplicateUserNameFault(crate::error::DuplicateUserNameFault),
    /// <p></p>
    InvalidParameterCombinationException(crate::error::InvalidParameterCombinationException),
    /// <p></p>
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    /// <p></p>
    TagQuotaPerResourceExceeded(crate::error::TagQuotaPerResourceExceeded),
    /// <p></p>
    UserAlreadyExistsFault(crate::error::UserAlreadyExistsFault),
    /// <p></p>
    UserQuotaExceededFault(crate::error::UserQuotaExceededFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for CreateUserError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for CreateUserError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::DuplicateUserNameFault(_inner) => _inner.fmt(f),
            Self::InvalidParameterCombinationException(_inner) => _inner.fmt(f),
            Self::InvalidParameterValueException(_inner) => _inner.fmt(f),
            Self::TagQuotaPerResourceExceeded(_inner) => _inner.fmt(f),
            Self::UserAlreadyExistsFault(_inner) => _inner.fmt(f),
            Self::UserQuotaExceededFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CreateUserError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::DuplicateUserNameFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidParameterCombinationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidParameterValueException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TagQuotaPerResourceExceeded(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UserAlreadyExistsFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UserQuotaExceededFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::CreateUserError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateUserError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateUserError {
    /// Creates the `CreateUserError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `CreateUserError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::DuplicateUserNameFault(e) => e.meta(),
            Self::InvalidParameterCombinationException(e) => e.meta(),
            Self::InvalidParameterValueException(e) => e.meta(),
            Self::TagQuotaPerResourceExceeded(e) => e.meta(),
            Self::UserAlreadyExistsFault(e) => e.meta(),
            Self::UserQuotaExceededFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `CreateUserError::DuplicateUserNameFault`.
    pub fn is_duplicate_user_name_fault(&self) -> bool {
        matches!(self, Self::DuplicateUserNameFault(_))
    }
    /// Returns `true` if the error kind is `CreateUserError::InvalidParameterCombinationException`.
    pub fn is_invalid_parameter_combination_exception(&self) -> bool {
        matches!(self, Self::InvalidParameterCombinationException(_))
    }
    /// Returns `true` if the error kind is `CreateUserError::InvalidParameterValueException`.
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(self, Self::InvalidParameterValueException(_))
    }
    /// Returns `true` if the error kind is `CreateUserError::TagQuotaPerResourceExceeded`.
    pub fn is_tag_quota_per_resource_exceeded(&self) -> bool {
        matches!(self, Self::TagQuotaPerResourceExceeded(_))
    }
    /// Returns `true` if the error kind is `CreateUserError::UserAlreadyExistsFault`.
    pub fn is_user_already_exists_fault(&self) -> bool {
        matches!(self, Self::UserAlreadyExistsFault(_))
    }
    /// Returns `true` if the error kind is `CreateUserError::UserQuotaExceededFault`.
    pub fn is_user_quota_exceeded_fault(&self) -> bool {
        matches!(self, Self::UserQuotaExceededFault(_))
    }
}
impl std::error::Error for CreateUserError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::DuplicateUserNameFault(_inner) => Some(_inner),
            Self::InvalidParameterCombinationException(_inner) => Some(_inner),
            Self::InvalidParameterValueException(_inner) => Some(_inner),
            Self::TagQuotaPerResourceExceeded(_inner) => Some(_inner),
            Self::UserAlreadyExistsFault(_inner) => Some(_inner),
            Self::UserQuotaExceededFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UserQuotaExceededFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl UserQuotaExceededFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for UserQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "UserQuotaExceededFault")?;
        if let Some(inner_41) = &self.message {
            {
                write!(f, ": {}", inner_41)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for UserQuotaExceededFault {}
impl aws_http::request_id::RequestId for crate::error::UserQuotaExceededFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for UserQuotaExceededFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl UserQuotaExceededFault {
    /// Creates a new builder-style object to manufacture [`UserQuotaExceededFault`](crate::error::UserQuotaExceededFault).
    pub fn builder() -> crate::error::user_quota_exceeded_fault::Builder {
        crate::error::user_quota_exceeded_fault::Builder::default()
    }
}

/// See [`UserQuotaExceededFault`](crate::error::UserQuotaExceededFault).
pub mod user_quota_exceeded_fault {

    /// A builder for [`UserQuotaExceededFault`](crate::error::UserQuotaExceededFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`UserQuotaExceededFault`](crate::error::UserQuotaExceededFault).
        pub fn build(self) -> crate::error::UserQuotaExceededFault {
            crate::error::UserQuotaExceededFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UserAlreadyExistsFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl UserAlreadyExistsFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for UserAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "UserAlreadyExistsFault")?;
        if let Some(inner_42) = &self.message {
            {
                write!(f, ": {}", inner_42)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for UserAlreadyExistsFault {}
impl aws_http::request_id::RequestId for crate::error::UserAlreadyExistsFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for UserAlreadyExistsFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl UserAlreadyExistsFault {
    /// Creates a new builder-style object to manufacture [`UserAlreadyExistsFault`](crate::error::UserAlreadyExistsFault).
    pub fn builder() -> crate::error::user_already_exists_fault::Builder {
        crate::error::user_already_exists_fault::Builder::default()
    }
}

/// See [`UserAlreadyExistsFault`](crate::error::UserAlreadyExistsFault).
pub mod user_already_exists_fault {

    /// A builder for [`UserAlreadyExistsFault`](crate::error::UserAlreadyExistsFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`UserAlreadyExistsFault`](crate::error::UserAlreadyExistsFault).
        pub fn build(self) -> crate::error::UserAlreadyExistsFault {
            crate::error::UserAlreadyExistsFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type CreateSubnetGroupErrorKind = CreateSubnetGroupError;
/// Error type for the `CreateSubnetGroupError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateSubnetGroupError {
    /// <p></p>
    InvalidSubnet(crate::error::InvalidSubnet),
    /// <p></p>
    ServiceLinkedRoleNotFoundFault(crate::error::ServiceLinkedRoleNotFoundFault),
    /// <p></p>
    SubnetGroupAlreadyExistsFault(crate::error::SubnetGroupAlreadyExistsFault),
    /// <p></p>
    SubnetGroupQuotaExceededFault(crate::error::SubnetGroupQuotaExceededFault),
    /// <p></p>
    SubnetNotAllowedFault(crate::error::SubnetNotAllowedFault),
    /// <p></p>
    SubnetQuotaExceededFault(crate::error::SubnetQuotaExceededFault),
    /// <p></p>
    TagQuotaPerResourceExceeded(crate::error::TagQuotaPerResourceExceeded),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for CreateSubnetGroupError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for CreateSubnetGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::InvalidSubnet(_inner) => _inner.fmt(f),
            Self::ServiceLinkedRoleNotFoundFault(_inner) => _inner.fmt(f),
            Self::SubnetGroupAlreadyExistsFault(_inner) => _inner.fmt(f),
            Self::SubnetGroupQuotaExceededFault(_inner) => _inner.fmt(f),
            Self::SubnetNotAllowedFault(_inner) => _inner.fmt(f),
            Self::SubnetQuotaExceededFault(_inner) => _inner.fmt(f),
            Self::TagQuotaPerResourceExceeded(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CreateSubnetGroupError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::InvalidSubnet(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceLinkedRoleNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::SubnetGroupAlreadyExistsFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::SubnetGroupQuotaExceededFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::SubnetNotAllowedFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::SubnetQuotaExceededFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TagQuotaPerResourceExceeded(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::CreateSubnetGroupError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateSubnetGroupError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateSubnetGroupError {
    /// Creates the `CreateSubnetGroupError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `CreateSubnetGroupError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::InvalidSubnet(e) => e.meta(),
            Self::ServiceLinkedRoleNotFoundFault(e) => e.meta(),
            Self::SubnetGroupAlreadyExistsFault(e) => e.meta(),
            Self::SubnetGroupQuotaExceededFault(e) => e.meta(),
            Self::SubnetNotAllowedFault(e) => e.meta(),
            Self::SubnetQuotaExceededFault(e) => e.meta(),
            Self::TagQuotaPerResourceExceeded(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `CreateSubnetGroupError::InvalidSubnet`.
    pub fn is_invalid_subnet(&self) -> bool {
        matches!(self, Self::InvalidSubnet(_))
    }
    /// Returns `true` if the error kind is `CreateSubnetGroupError::ServiceLinkedRoleNotFoundFault`.
    pub fn is_service_linked_role_not_found_fault(&self) -> bool {
        matches!(self, Self::ServiceLinkedRoleNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `CreateSubnetGroupError::SubnetGroupAlreadyExistsFault`.
    pub fn is_subnet_group_already_exists_fault(&self) -> bool {
        matches!(self, Self::SubnetGroupAlreadyExistsFault(_))
    }
    /// Returns `true` if the error kind is `CreateSubnetGroupError::SubnetGroupQuotaExceededFault`.
    pub fn is_subnet_group_quota_exceeded_fault(&self) -> bool {
        matches!(self, Self::SubnetGroupQuotaExceededFault(_))
    }
    /// Returns `true` if the error kind is `CreateSubnetGroupError::SubnetNotAllowedFault`.
    pub fn is_subnet_not_allowed_fault(&self) -> bool {
        matches!(self, Self::SubnetNotAllowedFault(_))
    }
    /// Returns `true` if the error kind is `CreateSubnetGroupError::SubnetQuotaExceededFault`.
    pub fn is_subnet_quota_exceeded_fault(&self) -> bool {
        matches!(self, Self::SubnetQuotaExceededFault(_))
    }
    /// Returns `true` if the error kind is `CreateSubnetGroupError::TagQuotaPerResourceExceeded`.
    pub fn is_tag_quota_per_resource_exceeded(&self) -> bool {
        matches!(self, Self::TagQuotaPerResourceExceeded(_))
    }
}
impl std::error::Error for CreateSubnetGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::InvalidSubnet(_inner) => Some(_inner),
            Self::ServiceLinkedRoleNotFoundFault(_inner) => Some(_inner),
            Self::SubnetGroupAlreadyExistsFault(_inner) => Some(_inner),
            Self::SubnetGroupQuotaExceededFault(_inner) => Some(_inner),
            Self::SubnetNotAllowedFault(_inner) => Some(_inner),
            Self::SubnetQuotaExceededFault(_inner) => Some(_inner),
            Self::TagQuotaPerResourceExceeded(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SubnetGroupQuotaExceededFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl SubnetGroupQuotaExceededFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for SubnetGroupQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SubnetGroupQuotaExceededFault")?;
        if let Some(inner_43) = &self.message {
            {
                write!(f, ": {}", inner_43)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for SubnetGroupQuotaExceededFault {}
impl aws_http::request_id::RequestId for crate::error::SubnetGroupQuotaExceededFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for SubnetGroupQuotaExceededFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl SubnetGroupQuotaExceededFault {
    /// Creates a new builder-style object to manufacture [`SubnetGroupQuotaExceededFault`](crate::error::SubnetGroupQuotaExceededFault).
    pub fn builder() -> crate::error::subnet_group_quota_exceeded_fault::Builder {
        crate::error::subnet_group_quota_exceeded_fault::Builder::default()
    }
}

/// See [`SubnetGroupQuotaExceededFault`](crate::error::SubnetGroupQuotaExceededFault).
pub mod subnet_group_quota_exceeded_fault {

    /// A builder for [`SubnetGroupQuotaExceededFault`](crate::error::SubnetGroupQuotaExceededFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`SubnetGroupQuotaExceededFault`](crate::error::SubnetGroupQuotaExceededFault).
        pub fn build(self) -> crate::error::SubnetGroupQuotaExceededFault {
            crate::error::SubnetGroupQuotaExceededFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SubnetGroupAlreadyExistsFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl SubnetGroupAlreadyExistsFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for SubnetGroupAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SubnetGroupAlreadyExistsFault")?;
        if let Some(inner_44) = &self.message {
            {
                write!(f, ": {}", inner_44)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for SubnetGroupAlreadyExistsFault {}
impl aws_http::request_id::RequestId for crate::error::SubnetGroupAlreadyExistsFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for SubnetGroupAlreadyExistsFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl SubnetGroupAlreadyExistsFault {
    /// Creates a new builder-style object to manufacture [`SubnetGroupAlreadyExistsFault`](crate::error::SubnetGroupAlreadyExistsFault).
    pub fn builder() -> crate::error::subnet_group_already_exists_fault::Builder {
        crate::error::subnet_group_already_exists_fault::Builder::default()
    }
}

/// See [`SubnetGroupAlreadyExistsFault`](crate::error::SubnetGroupAlreadyExistsFault).
pub mod subnet_group_already_exists_fault {

    /// A builder for [`SubnetGroupAlreadyExistsFault`](crate::error::SubnetGroupAlreadyExistsFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`SubnetGroupAlreadyExistsFault`](crate::error::SubnetGroupAlreadyExistsFault).
        pub fn build(self) -> crate::error::SubnetGroupAlreadyExistsFault {
            crate::error::SubnetGroupAlreadyExistsFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type CreateSnapshotErrorKind = CreateSnapshotError;
/// Error type for the `CreateSnapshotError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateSnapshotError {
    /// <p></p>
    ClusterNotFoundFault(crate::error::ClusterNotFoundFault),
    /// <p></p>
    InvalidClusterStateFault(crate::error::InvalidClusterStateFault),
    /// <p></p>
    InvalidParameterCombinationException(crate::error::InvalidParameterCombinationException),
    /// <p></p>
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    /// <p></p>
    ServiceLinkedRoleNotFoundFault(crate::error::ServiceLinkedRoleNotFoundFault),
    /// <p></p>
    SnapshotAlreadyExistsFault(crate::error::SnapshotAlreadyExistsFault),
    /// <p></p>
    SnapshotQuotaExceededFault(crate::error::SnapshotQuotaExceededFault),
    /// <p></p>
    TagQuotaPerResourceExceeded(crate::error::TagQuotaPerResourceExceeded),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for CreateSnapshotError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for CreateSnapshotError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ClusterNotFoundFault(_inner) => _inner.fmt(f),
            Self::InvalidClusterStateFault(_inner) => _inner.fmt(f),
            Self::InvalidParameterCombinationException(_inner) => _inner.fmt(f),
            Self::InvalidParameterValueException(_inner) => _inner.fmt(f),
            Self::ServiceLinkedRoleNotFoundFault(_inner) => _inner.fmt(f),
            Self::SnapshotAlreadyExistsFault(_inner) => _inner.fmt(f),
            Self::SnapshotQuotaExceededFault(_inner) => _inner.fmt(f),
            Self::TagQuotaPerResourceExceeded(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CreateSnapshotError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ClusterNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidClusterStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidParameterCombinationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidParameterValueException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceLinkedRoleNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::SnapshotAlreadyExistsFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::SnapshotQuotaExceededFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TagQuotaPerResourceExceeded(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::CreateSnapshotError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateSnapshotError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateSnapshotError {
    /// Creates the `CreateSnapshotError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `CreateSnapshotError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ClusterNotFoundFault(e) => e.meta(),
            Self::InvalidClusterStateFault(e) => e.meta(),
            Self::InvalidParameterCombinationException(e) => e.meta(),
            Self::InvalidParameterValueException(e) => e.meta(),
            Self::ServiceLinkedRoleNotFoundFault(e) => e.meta(),
            Self::SnapshotAlreadyExistsFault(e) => e.meta(),
            Self::SnapshotQuotaExceededFault(e) => e.meta(),
            Self::TagQuotaPerResourceExceeded(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `CreateSnapshotError::ClusterNotFoundFault`.
    pub fn is_cluster_not_found_fault(&self) -> bool {
        matches!(self, Self::ClusterNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `CreateSnapshotError::InvalidClusterStateFault`.
    pub fn is_invalid_cluster_state_fault(&self) -> bool {
        matches!(self, Self::InvalidClusterStateFault(_))
    }
    /// Returns `true` if the error kind is `CreateSnapshotError::InvalidParameterCombinationException`.
    pub fn is_invalid_parameter_combination_exception(&self) -> bool {
        matches!(self, Self::InvalidParameterCombinationException(_))
    }
    /// Returns `true` if the error kind is `CreateSnapshotError::InvalidParameterValueException`.
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(self, Self::InvalidParameterValueException(_))
    }
    /// Returns `true` if the error kind is `CreateSnapshotError::ServiceLinkedRoleNotFoundFault`.
    pub fn is_service_linked_role_not_found_fault(&self) -> bool {
        matches!(self, Self::ServiceLinkedRoleNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `CreateSnapshotError::SnapshotAlreadyExistsFault`.
    pub fn is_snapshot_already_exists_fault(&self) -> bool {
        matches!(self, Self::SnapshotAlreadyExistsFault(_))
    }
    /// Returns `true` if the error kind is `CreateSnapshotError::SnapshotQuotaExceededFault`.
    pub fn is_snapshot_quota_exceeded_fault(&self) -> bool {
        matches!(self, Self::SnapshotQuotaExceededFault(_))
    }
    /// Returns `true` if the error kind is `CreateSnapshotError::TagQuotaPerResourceExceeded`.
    pub fn is_tag_quota_per_resource_exceeded(&self) -> bool {
        matches!(self, Self::TagQuotaPerResourceExceeded(_))
    }
}
impl std::error::Error for CreateSnapshotError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ClusterNotFoundFault(_inner) => Some(_inner),
            Self::InvalidClusterStateFault(_inner) => Some(_inner),
            Self::InvalidParameterCombinationException(_inner) => Some(_inner),
            Self::InvalidParameterValueException(_inner) => Some(_inner),
            Self::ServiceLinkedRoleNotFoundFault(_inner) => Some(_inner),
            Self::SnapshotAlreadyExistsFault(_inner) => Some(_inner),
            Self::SnapshotQuotaExceededFault(_inner) => Some(_inner),
            Self::TagQuotaPerResourceExceeded(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SnapshotQuotaExceededFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl SnapshotQuotaExceededFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for SnapshotQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SnapshotQuotaExceededFault")?;
        if let Some(inner_45) = &self.message {
            {
                write!(f, ": {}", inner_45)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for SnapshotQuotaExceededFault {}
impl aws_http::request_id::RequestId for crate::error::SnapshotQuotaExceededFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for SnapshotQuotaExceededFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl SnapshotQuotaExceededFault {
    /// Creates a new builder-style object to manufacture [`SnapshotQuotaExceededFault`](crate::error::SnapshotQuotaExceededFault).
    pub fn builder() -> crate::error::snapshot_quota_exceeded_fault::Builder {
        crate::error::snapshot_quota_exceeded_fault::Builder::default()
    }
}

/// See [`SnapshotQuotaExceededFault`](crate::error::SnapshotQuotaExceededFault).
pub mod snapshot_quota_exceeded_fault {

    /// A builder for [`SnapshotQuotaExceededFault`](crate::error::SnapshotQuotaExceededFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`SnapshotQuotaExceededFault`](crate::error::SnapshotQuotaExceededFault).
        pub fn build(self) -> crate::error::SnapshotQuotaExceededFault {
            crate::error::SnapshotQuotaExceededFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type CreateParameterGroupErrorKind = CreateParameterGroupError;
/// Error type for the `CreateParameterGroupError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateParameterGroupError {
    /// <p></p>
    InvalidParameterCombinationException(crate::error::InvalidParameterCombinationException),
    /// <p></p>
    InvalidParameterGroupStateFault(crate::error::InvalidParameterGroupStateFault),
    /// <p></p>
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    /// <p></p>
    ParameterGroupAlreadyExistsFault(crate::error::ParameterGroupAlreadyExistsFault),
    /// <p></p>
    ParameterGroupQuotaExceededFault(crate::error::ParameterGroupQuotaExceededFault),
    /// <p></p>
    ServiceLinkedRoleNotFoundFault(crate::error::ServiceLinkedRoleNotFoundFault),
    /// <p></p>
    TagQuotaPerResourceExceeded(crate::error::TagQuotaPerResourceExceeded),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for CreateParameterGroupError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for CreateParameterGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::InvalidParameterCombinationException(_inner) => _inner.fmt(f),
            Self::InvalidParameterGroupStateFault(_inner) => _inner.fmt(f),
            Self::InvalidParameterValueException(_inner) => _inner.fmt(f),
            Self::ParameterGroupAlreadyExistsFault(_inner) => _inner.fmt(f),
            Self::ParameterGroupQuotaExceededFault(_inner) => _inner.fmt(f),
            Self::ServiceLinkedRoleNotFoundFault(_inner) => _inner.fmt(f),
            Self::TagQuotaPerResourceExceeded(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CreateParameterGroupError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::InvalidParameterCombinationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidParameterGroupStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidParameterValueException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ParameterGroupAlreadyExistsFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ParameterGroupQuotaExceededFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceLinkedRoleNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TagQuotaPerResourceExceeded(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::CreateParameterGroupError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateParameterGroupError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateParameterGroupError {
    /// Creates the `CreateParameterGroupError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `CreateParameterGroupError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::InvalidParameterCombinationException(e) => e.meta(),
            Self::InvalidParameterGroupStateFault(e) => e.meta(),
            Self::InvalidParameterValueException(e) => e.meta(),
            Self::ParameterGroupAlreadyExistsFault(e) => e.meta(),
            Self::ParameterGroupQuotaExceededFault(e) => e.meta(),
            Self::ServiceLinkedRoleNotFoundFault(e) => e.meta(),
            Self::TagQuotaPerResourceExceeded(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `CreateParameterGroupError::InvalidParameterCombinationException`.
    pub fn is_invalid_parameter_combination_exception(&self) -> bool {
        matches!(self, Self::InvalidParameterCombinationException(_))
    }
    /// Returns `true` if the error kind is `CreateParameterGroupError::InvalidParameterGroupStateFault`.
    pub fn is_invalid_parameter_group_state_fault(&self) -> bool {
        matches!(self, Self::InvalidParameterGroupStateFault(_))
    }
    /// Returns `true` if the error kind is `CreateParameterGroupError::InvalidParameterValueException`.
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(self, Self::InvalidParameterValueException(_))
    }
    /// Returns `true` if the error kind is `CreateParameterGroupError::ParameterGroupAlreadyExistsFault`.
    pub fn is_parameter_group_already_exists_fault(&self) -> bool {
        matches!(self, Self::ParameterGroupAlreadyExistsFault(_))
    }
    /// Returns `true` if the error kind is `CreateParameterGroupError::ParameterGroupQuotaExceededFault`.
    pub fn is_parameter_group_quota_exceeded_fault(&self) -> bool {
        matches!(self, Self::ParameterGroupQuotaExceededFault(_))
    }
    /// Returns `true` if the error kind is `CreateParameterGroupError::ServiceLinkedRoleNotFoundFault`.
    pub fn is_service_linked_role_not_found_fault(&self) -> bool {
        matches!(self, Self::ServiceLinkedRoleNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `CreateParameterGroupError::TagQuotaPerResourceExceeded`.
    pub fn is_tag_quota_per_resource_exceeded(&self) -> bool {
        matches!(self, Self::TagQuotaPerResourceExceeded(_))
    }
}
impl std::error::Error for CreateParameterGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::InvalidParameterCombinationException(_inner) => Some(_inner),
            Self::InvalidParameterGroupStateFault(_inner) => Some(_inner),
            Self::InvalidParameterValueException(_inner) => Some(_inner),
            Self::ParameterGroupAlreadyExistsFault(_inner) => Some(_inner),
            Self::ParameterGroupQuotaExceededFault(_inner) => Some(_inner),
            Self::ServiceLinkedRoleNotFoundFault(_inner) => Some(_inner),
            Self::TagQuotaPerResourceExceeded(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ParameterGroupQuotaExceededFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl ParameterGroupQuotaExceededFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ParameterGroupQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ParameterGroupQuotaExceededFault")?;
        if let Some(inner_46) = &self.message {
            {
                write!(f, ": {}", inner_46)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ParameterGroupQuotaExceededFault {}
impl aws_http::request_id::RequestId for crate::error::ParameterGroupQuotaExceededFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ParameterGroupQuotaExceededFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl ParameterGroupQuotaExceededFault {
    /// Creates a new builder-style object to manufacture [`ParameterGroupQuotaExceededFault`](crate::error::ParameterGroupQuotaExceededFault).
    pub fn builder() -> crate::error::parameter_group_quota_exceeded_fault::Builder {
        crate::error::parameter_group_quota_exceeded_fault::Builder::default()
    }
}

/// See [`ParameterGroupQuotaExceededFault`](crate::error::ParameterGroupQuotaExceededFault).
pub mod parameter_group_quota_exceeded_fault {

    /// A builder for [`ParameterGroupQuotaExceededFault`](crate::error::ParameterGroupQuotaExceededFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`ParameterGroupQuotaExceededFault`](crate::error::ParameterGroupQuotaExceededFault).
        pub fn build(self) -> crate::error::ParameterGroupQuotaExceededFault {
            crate::error::ParameterGroupQuotaExceededFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ParameterGroupAlreadyExistsFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl ParameterGroupAlreadyExistsFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ParameterGroupAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ParameterGroupAlreadyExistsFault")?;
        if let Some(inner_47) = &self.message {
            {
                write!(f, ": {}", inner_47)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ParameterGroupAlreadyExistsFault {}
impl aws_http::request_id::RequestId for crate::error::ParameterGroupAlreadyExistsFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ParameterGroupAlreadyExistsFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl ParameterGroupAlreadyExistsFault {
    /// Creates a new builder-style object to manufacture [`ParameterGroupAlreadyExistsFault`](crate::error::ParameterGroupAlreadyExistsFault).
    pub fn builder() -> crate::error::parameter_group_already_exists_fault::Builder {
        crate::error::parameter_group_already_exists_fault::Builder::default()
    }
}

/// See [`ParameterGroupAlreadyExistsFault`](crate::error::ParameterGroupAlreadyExistsFault).
pub mod parameter_group_already_exists_fault {

    /// A builder for [`ParameterGroupAlreadyExistsFault`](crate::error::ParameterGroupAlreadyExistsFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`ParameterGroupAlreadyExistsFault`](crate::error::ParameterGroupAlreadyExistsFault).
        pub fn build(self) -> crate::error::ParameterGroupAlreadyExistsFault {
            crate::error::ParameterGroupAlreadyExistsFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type CreateClusterErrorKind = CreateClusterError;
/// Error type for the `CreateClusterError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateClusterError {
    /// <p></p>
    AclNotFoundFault(crate::error::AclNotFoundFault),
    /// <p></p>
    ClusterAlreadyExistsFault(crate::error::ClusterAlreadyExistsFault),
    /// <p></p>
    ClusterQuotaForCustomerExceededFault(crate::error::ClusterQuotaForCustomerExceededFault),
    /// <p></p>
    InsufficientClusterCapacityFault(crate::error::InsufficientClusterCapacityFault),
    /// <p></p>
    InvalidAclStateFault(crate::error::InvalidAclStateFault),
    /// <p></p>
    InvalidCredentialsException(crate::error::InvalidCredentialsException),
    /// <p></p>
    InvalidParameterCombinationException(crate::error::InvalidParameterCombinationException),
    /// <p></p>
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    /// <p></p>
    InvalidVpcNetworkStateFault(crate::error::InvalidVpcNetworkStateFault),
    /// <p></p>
    NodeQuotaForClusterExceededFault(crate::error::NodeQuotaForClusterExceededFault),
    /// <p></p>
    NodeQuotaForCustomerExceededFault(crate::error::NodeQuotaForCustomerExceededFault),
    /// <p></p>
    ParameterGroupNotFoundFault(crate::error::ParameterGroupNotFoundFault),
    /// <p></p>
    ServiceLinkedRoleNotFoundFault(crate::error::ServiceLinkedRoleNotFoundFault),
    /// <p></p>
    ShardsPerClusterQuotaExceededFault(crate::error::ShardsPerClusterQuotaExceededFault),
    /// <p></p>
    SubnetGroupNotFoundFault(crate::error::SubnetGroupNotFoundFault),
    /// <p></p>
    TagQuotaPerResourceExceeded(crate::error::TagQuotaPerResourceExceeded),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for CreateClusterError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for CreateClusterError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AclNotFoundFault(_inner) => _inner.fmt(f),
            Self::ClusterAlreadyExistsFault(_inner) => _inner.fmt(f),
            Self::ClusterQuotaForCustomerExceededFault(_inner) => _inner.fmt(f),
            Self::InsufficientClusterCapacityFault(_inner) => _inner.fmt(f),
            Self::InvalidAclStateFault(_inner) => _inner.fmt(f),
            Self::InvalidCredentialsException(_inner) => _inner.fmt(f),
            Self::InvalidParameterCombinationException(_inner) => _inner.fmt(f),
            Self::InvalidParameterValueException(_inner) => _inner.fmt(f),
            Self::InvalidVpcNetworkStateFault(_inner) => _inner.fmt(f),
            Self::NodeQuotaForClusterExceededFault(_inner) => _inner.fmt(f),
            Self::NodeQuotaForCustomerExceededFault(_inner) => _inner.fmt(f),
            Self::ParameterGroupNotFoundFault(_inner) => _inner.fmt(f),
            Self::ServiceLinkedRoleNotFoundFault(_inner) => _inner.fmt(f),
            Self::ShardsPerClusterQuotaExceededFault(_inner) => _inner.fmt(f),
            Self::SubnetGroupNotFoundFault(_inner) => _inner.fmt(f),
            Self::TagQuotaPerResourceExceeded(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CreateClusterError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AclNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ClusterAlreadyExistsFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ClusterQuotaForCustomerExceededFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InsufficientClusterCapacityFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidAclStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidCredentialsException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidParameterCombinationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidParameterValueException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidVpcNetworkStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NodeQuotaForClusterExceededFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NodeQuotaForCustomerExceededFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ParameterGroupNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceLinkedRoleNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ShardsPerClusterQuotaExceededFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::SubnetGroupNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TagQuotaPerResourceExceeded(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::CreateClusterError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateClusterError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateClusterError {
    /// Creates the `CreateClusterError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `CreateClusterError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AclNotFoundFault(e) => e.meta(),
            Self::ClusterAlreadyExistsFault(e) => e.meta(),
            Self::ClusterQuotaForCustomerExceededFault(e) => e.meta(),
            Self::InsufficientClusterCapacityFault(e) => e.meta(),
            Self::InvalidAclStateFault(e) => e.meta(),
            Self::InvalidCredentialsException(e) => e.meta(),
            Self::InvalidParameterCombinationException(e) => e.meta(),
            Self::InvalidParameterValueException(e) => e.meta(),
            Self::InvalidVpcNetworkStateFault(e) => e.meta(),
            Self::NodeQuotaForClusterExceededFault(e) => e.meta(),
            Self::NodeQuotaForCustomerExceededFault(e) => e.meta(),
            Self::ParameterGroupNotFoundFault(e) => e.meta(),
            Self::ServiceLinkedRoleNotFoundFault(e) => e.meta(),
            Self::ShardsPerClusterQuotaExceededFault(e) => e.meta(),
            Self::SubnetGroupNotFoundFault(e) => e.meta(),
            Self::TagQuotaPerResourceExceeded(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `CreateClusterError::AclNotFoundFault`.
    pub fn is_acl_not_found_fault(&self) -> bool {
        matches!(self, Self::AclNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `CreateClusterError::ClusterAlreadyExistsFault`.
    pub fn is_cluster_already_exists_fault(&self) -> bool {
        matches!(self, Self::ClusterAlreadyExistsFault(_))
    }
    /// Returns `true` if the error kind is `CreateClusterError::ClusterQuotaForCustomerExceededFault`.
    pub fn is_cluster_quota_for_customer_exceeded_fault(&self) -> bool {
        matches!(self, Self::ClusterQuotaForCustomerExceededFault(_))
    }
    /// Returns `true` if the error kind is `CreateClusterError::InsufficientClusterCapacityFault`.
    pub fn is_insufficient_cluster_capacity_fault(&self) -> bool {
        matches!(self, Self::InsufficientClusterCapacityFault(_))
    }
    /// Returns `true` if the error kind is `CreateClusterError::InvalidAclStateFault`.
    pub fn is_invalid_acl_state_fault(&self) -> bool {
        matches!(self, Self::InvalidAclStateFault(_))
    }
    /// Returns `true` if the error kind is `CreateClusterError::InvalidCredentialsException`.
    pub fn is_invalid_credentials_exception(&self) -> bool {
        matches!(self, Self::InvalidCredentialsException(_))
    }
    /// Returns `true` if the error kind is `CreateClusterError::InvalidParameterCombinationException`.
    pub fn is_invalid_parameter_combination_exception(&self) -> bool {
        matches!(self, Self::InvalidParameterCombinationException(_))
    }
    /// Returns `true` if the error kind is `CreateClusterError::InvalidParameterValueException`.
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(self, Self::InvalidParameterValueException(_))
    }
    /// Returns `true` if the error kind is `CreateClusterError::InvalidVpcNetworkStateFault`.
    pub fn is_invalid_vpc_network_state_fault(&self) -> bool {
        matches!(self, Self::InvalidVpcNetworkStateFault(_))
    }
    /// Returns `true` if the error kind is `CreateClusterError::NodeQuotaForClusterExceededFault`.
    pub fn is_node_quota_for_cluster_exceeded_fault(&self) -> bool {
        matches!(self, Self::NodeQuotaForClusterExceededFault(_))
    }
    /// Returns `true` if the error kind is `CreateClusterError::NodeQuotaForCustomerExceededFault`.
    pub fn is_node_quota_for_customer_exceeded_fault(&self) -> bool {
        matches!(self, Self::NodeQuotaForCustomerExceededFault(_))
    }
    /// Returns `true` if the error kind is `CreateClusterError::ParameterGroupNotFoundFault`.
    pub fn is_parameter_group_not_found_fault(&self) -> bool {
        matches!(self, Self::ParameterGroupNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `CreateClusterError::ServiceLinkedRoleNotFoundFault`.
    pub fn is_service_linked_role_not_found_fault(&self) -> bool {
        matches!(self, Self::ServiceLinkedRoleNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `CreateClusterError::ShardsPerClusterQuotaExceededFault`.
    pub fn is_shards_per_cluster_quota_exceeded_fault(&self) -> bool {
        matches!(self, Self::ShardsPerClusterQuotaExceededFault(_))
    }
    /// Returns `true` if the error kind is `CreateClusterError::SubnetGroupNotFoundFault`.
    pub fn is_subnet_group_not_found_fault(&self) -> bool {
        matches!(self, Self::SubnetGroupNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `CreateClusterError::TagQuotaPerResourceExceeded`.
    pub fn is_tag_quota_per_resource_exceeded(&self) -> bool {
        matches!(self, Self::TagQuotaPerResourceExceeded(_))
    }
}
impl std::error::Error for CreateClusterError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AclNotFoundFault(_inner) => Some(_inner),
            Self::ClusterAlreadyExistsFault(_inner) => Some(_inner),
            Self::ClusterQuotaForCustomerExceededFault(_inner) => Some(_inner),
            Self::InsufficientClusterCapacityFault(_inner) => Some(_inner),
            Self::InvalidAclStateFault(_inner) => Some(_inner),
            Self::InvalidCredentialsException(_inner) => Some(_inner),
            Self::InvalidParameterCombinationException(_inner) => Some(_inner),
            Self::InvalidParameterValueException(_inner) => Some(_inner),
            Self::InvalidVpcNetworkStateFault(_inner) => Some(_inner),
            Self::NodeQuotaForClusterExceededFault(_inner) => Some(_inner),
            Self::NodeQuotaForCustomerExceededFault(_inner) => Some(_inner),
            Self::ParameterGroupNotFoundFault(_inner) => Some(_inner),
            Self::ServiceLinkedRoleNotFoundFault(_inner) => Some(_inner),
            Self::ShardsPerClusterQuotaExceededFault(_inner) => Some(_inner),
            Self::SubnetGroupNotFoundFault(_inner) => Some(_inner),
            Self::TagQuotaPerResourceExceeded(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidCredentialsException {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidCredentialsException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidCredentialsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidCredentialsException")?;
        if let Some(inner_48) = &self.message {
            {
                write!(f, ": {}", inner_48)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidCredentialsException {}
impl aws_http::request_id::RequestId for crate::error::InvalidCredentialsException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidCredentialsException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InvalidCredentialsException {
    /// Creates a new builder-style object to manufacture [`InvalidCredentialsException`](crate::error::InvalidCredentialsException).
    pub fn builder() -> crate::error::invalid_credentials_exception::Builder {
        crate::error::invalid_credentials_exception::Builder::default()
    }
}

/// See [`InvalidCredentialsException`](crate::error::InvalidCredentialsException).
pub mod invalid_credentials_exception {

    /// A builder for [`InvalidCredentialsException`](crate::error::InvalidCredentialsException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidCredentialsException`](crate::error::InvalidCredentialsException).
        pub fn build(self) -> crate::error::InvalidCredentialsException {
            crate::error::InvalidCredentialsException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InsufficientClusterCapacityFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InsufficientClusterCapacityFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InsufficientClusterCapacityFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InsufficientClusterCapacityFault")?;
        if let Some(inner_49) = &self.message {
            {
                write!(f, ": {}", inner_49)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InsufficientClusterCapacityFault {}
impl aws_http::request_id::RequestId for crate::error::InsufficientClusterCapacityFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InsufficientClusterCapacityFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InsufficientClusterCapacityFault {
    /// Creates a new builder-style object to manufacture [`InsufficientClusterCapacityFault`](crate::error::InsufficientClusterCapacityFault).
    pub fn builder() -> crate::error::insufficient_cluster_capacity_fault::Builder {
        crate::error::insufficient_cluster_capacity_fault::Builder::default()
    }
}

/// See [`InsufficientClusterCapacityFault`](crate::error::InsufficientClusterCapacityFault).
pub mod insufficient_cluster_capacity_fault {

    /// A builder for [`InsufficientClusterCapacityFault`](crate::error::InsufficientClusterCapacityFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InsufficientClusterCapacityFault`](crate::error::InsufficientClusterCapacityFault).
        pub fn build(self) -> crate::error::InsufficientClusterCapacityFault {
            crate::error::InsufficientClusterCapacityFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ClusterAlreadyExistsFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl ClusterAlreadyExistsFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ClusterAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ClusterAlreadyExistsFault")?;
        if let Some(inner_50) = &self.message {
            {
                write!(f, ": {}", inner_50)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ClusterAlreadyExistsFault {}
impl aws_http::request_id::RequestId for crate::error::ClusterAlreadyExistsFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ClusterAlreadyExistsFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl ClusterAlreadyExistsFault {
    /// Creates a new builder-style object to manufacture [`ClusterAlreadyExistsFault`](crate::error::ClusterAlreadyExistsFault).
    pub fn builder() -> crate::error::cluster_already_exists_fault::Builder {
        crate::error::cluster_already_exists_fault::Builder::default()
    }
}

/// See [`ClusterAlreadyExistsFault`](crate::error::ClusterAlreadyExistsFault).
pub mod cluster_already_exists_fault {

    /// A builder for [`ClusterAlreadyExistsFault`](crate::error::ClusterAlreadyExistsFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`ClusterAlreadyExistsFault`](crate::error::ClusterAlreadyExistsFault).
        pub fn build(self) -> crate::error::ClusterAlreadyExistsFault {
            crate::error::ClusterAlreadyExistsFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type CreateACLErrorKind = CreateACLError;
/// Error type for the `CreateACLError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateACLError {
    /// <p></p>
    AclAlreadyExistsFault(crate::error::AclAlreadyExistsFault),
    /// <p></p>
    AclQuotaExceededFault(crate::error::AclQuotaExceededFault),
    /// <p></p>
    DefaultUserRequired(crate::error::DefaultUserRequired),
    /// <p></p>
    DuplicateUserNameFault(crate::error::DuplicateUserNameFault),
    /// <p></p>
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    /// <p></p>
    TagQuotaPerResourceExceeded(crate::error::TagQuotaPerResourceExceeded),
    /// <p></p>
    UserNotFoundFault(crate::error::UserNotFoundFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for CreateACLError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for CreateACLError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AclAlreadyExistsFault(_inner) => _inner.fmt(f),
            Self::AclQuotaExceededFault(_inner) => _inner.fmt(f),
            Self::DefaultUserRequired(_inner) => _inner.fmt(f),
            Self::DuplicateUserNameFault(_inner) => _inner.fmt(f),
            Self::InvalidParameterValueException(_inner) => _inner.fmt(f),
            Self::TagQuotaPerResourceExceeded(_inner) => _inner.fmt(f),
            Self::UserNotFoundFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CreateACLError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AclAlreadyExistsFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::AclQuotaExceededFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DefaultUserRequired(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DuplicateUserNameFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidParameterValueException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TagQuotaPerResourceExceeded(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UserNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::CreateACLError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateACLError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateACLError {
    /// Creates the `CreateACLError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `CreateACLError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AclAlreadyExistsFault(e) => e.meta(),
            Self::AclQuotaExceededFault(e) => e.meta(),
            Self::DefaultUserRequired(e) => e.meta(),
            Self::DuplicateUserNameFault(e) => e.meta(),
            Self::InvalidParameterValueException(e) => e.meta(),
            Self::TagQuotaPerResourceExceeded(e) => e.meta(),
            Self::UserNotFoundFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `CreateACLError::AclAlreadyExistsFault`.
    pub fn is_acl_already_exists_fault(&self) -> bool {
        matches!(self, Self::AclAlreadyExistsFault(_))
    }
    /// Returns `true` if the error kind is `CreateACLError::AclQuotaExceededFault`.
    pub fn is_acl_quota_exceeded_fault(&self) -> bool {
        matches!(self, Self::AclQuotaExceededFault(_))
    }
    /// Returns `true` if the error kind is `CreateACLError::DefaultUserRequired`.
    pub fn is_default_user_required(&self) -> bool {
        matches!(self, Self::DefaultUserRequired(_))
    }
    /// Returns `true` if the error kind is `CreateACLError::DuplicateUserNameFault`.
    pub fn is_duplicate_user_name_fault(&self) -> bool {
        matches!(self, Self::DuplicateUserNameFault(_))
    }
    /// Returns `true` if the error kind is `CreateACLError::InvalidParameterValueException`.
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(self, Self::InvalidParameterValueException(_))
    }
    /// Returns `true` if the error kind is `CreateACLError::TagQuotaPerResourceExceeded`.
    pub fn is_tag_quota_per_resource_exceeded(&self) -> bool {
        matches!(self, Self::TagQuotaPerResourceExceeded(_))
    }
    /// Returns `true` if the error kind is `CreateACLError::UserNotFoundFault`.
    pub fn is_user_not_found_fault(&self) -> bool {
        matches!(self, Self::UserNotFoundFault(_))
    }
}
impl std::error::Error for CreateACLError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AclAlreadyExistsFault(_inner) => Some(_inner),
            Self::AclQuotaExceededFault(_inner) => Some(_inner),
            Self::DefaultUserRequired(_inner) => Some(_inner),
            Self::DuplicateUserNameFault(_inner) => Some(_inner),
            Self::InvalidParameterValueException(_inner) => Some(_inner),
            Self::TagQuotaPerResourceExceeded(_inner) => Some(_inner),
            Self::UserNotFoundFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AclQuotaExceededFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl AclQuotaExceededFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for AclQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "AclQuotaExceededFault [ACLQuotaExceededFault]")?;
        if let Some(inner_51) = &self.message {
            {
                write!(f, ": {}", inner_51)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for AclQuotaExceededFault {}
impl aws_http::request_id::RequestId for crate::error::AclQuotaExceededFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for AclQuotaExceededFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl AclQuotaExceededFault {
    /// Creates a new builder-style object to manufacture [`AclQuotaExceededFault`](crate::error::AclQuotaExceededFault).
    pub fn builder() -> crate::error::acl_quota_exceeded_fault::Builder {
        crate::error::acl_quota_exceeded_fault::Builder::default()
    }
}

/// See [`AclQuotaExceededFault`](crate::error::AclQuotaExceededFault).
pub mod acl_quota_exceeded_fault {

    /// A builder for [`AclQuotaExceededFault`](crate::error::AclQuotaExceededFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`AclQuotaExceededFault`](crate::error::AclQuotaExceededFault).
        pub fn build(self) -> crate::error::AclQuotaExceededFault {
            crate::error::AclQuotaExceededFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AclAlreadyExistsFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl AclAlreadyExistsFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for AclAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "AclAlreadyExistsFault [ACLAlreadyExistsFault]")?;
        if let Some(inner_52) = &self.message {
            {
                write!(f, ": {}", inner_52)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for AclAlreadyExistsFault {}
impl aws_http::request_id::RequestId for crate::error::AclAlreadyExistsFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for AclAlreadyExistsFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl AclAlreadyExistsFault {
    /// Creates a new builder-style object to manufacture [`AclAlreadyExistsFault`](crate::error::AclAlreadyExistsFault).
    pub fn builder() -> crate::error::acl_already_exists_fault::Builder {
        crate::error::acl_already_exists_fault::Builder::default()
    }
}

/// See [`AclAlreadyExistsFault`](crate::error::AclAlreadyExistsFault).
pub mod acl_already_exists_fault {

    /// A builder for [`AclAlreadyExistsFault`](crate::error::AclAlreadyExistsFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`AclAlreadyExistsFault`](crate::error::AclAlreadyExistsFault).
        pub fn build(self) -> crate::error::AclAlreadyExistsFault {
            crate::error::AclAlreadyExistsFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type CopySnapshotErrorKind = CopySnapshotError;
/// Error type for the `CopySnapshotError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CopySnapshotError {
    /// <p></p>
    InvalidParameterCombinationException(crate::error::InvalidParameterCombinationException),
    /// <p></p>
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    /// <p></p>
    InvalidSnapshotStateFault(crate::error::InvalidSnapshotStateFault),
    /// <p></p>
    ServiceLinkedRoleNotFoundFault(crate::error::ServiceLinkedRoleNotFoundFault),
    /// <p></p>
    SnapshotAlreadyExistsFault(crate::error::SnapshotAlreadyExistsFault),
    /// <p></p>
    SnapshotNotFoundFault(crate::error::SnapshotNotFoundFault),
    /// <p></p>
    SnapshotQuotaExceededFault(crate::error::SnapshotQuotaExceededFault),
    /// <p></p>
    TagQuotaPerResourceExceeded(crate::error::TagQuotaPerResourceExceeded),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for CopySnapshotError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for CopySnapshotError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::InvalidParameterCombinationException(_inner) => _inner.fmt(f),
            Self::InvalidParameterValueException(_inner) => _inner.fmt(f),
            Self::InvalidSnapshotStateFault(_inner) => _inner.fmt(f),
            Self::ServiceLinkedRoleNotFoundFault(_inner) => _inner.fmt(f),
            Self::SnapshotAlreadyExistsFault(_inner) => _inner.fmt(f),
            Self::SnapshotNotFoundFault(_inner) => _inner.fmt(f),
            Self::SnapshotQuotaExceededFault(_inner) => _inner.fmt(f),
            Self::TagQuotaPerResourceExceeded(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CopySnapshotError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::InvalidParameterCombinationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidParameterValueException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidSnapshotStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceLinkedRoleNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::SnapshotAlreadyExistsFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::SnapshotNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::SnapshotQuotaExceededFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TagQuotaPerResourceExceeded(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::CopySnapshotError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CopySnapshotError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CopySnapshotError {
    /// Creates the `CopySnapshotError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `CopySnapshotError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::InvalidParameterCombinationException(e) => e.meta(),
            Self::InvalidParameterValueException(e) => e.meta(),
            Self::InvalidSnapshotStateFault(e) => e.meta(),
            Self::ServiceLinkedRoleNotFoundFault(e) => e.meta(),
            Self::SnapshotAlreadyExistsFault(e) => e.meta(),
            Self::SnapshotNotFoundFault(e) => e.meta(),
            Self::SnapshotQuotaExceededFault(e) => e.meta(),
            Self::TagQuotaPerResourceExceeded(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `CopySnapshotError::InvalidParameterCombinationException`.
    pub fn is_invalid_parameter_combination_exception(&self) -> bool {
        matches!(self, Self::InvalidParameterCombinationException(_))
    }
    /// Returns `true` if the error kind is `CopySnapshotError::InvalidParameterValueException`.
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(self, Self::InvalidParameterValueException(_))
    }
    /// Returns `true` if the error kind is `CopySnapshotError::InvalidSnapshotStateFault`.
    pub fn is_invalid_snapshot_state_fault(&self) -> bool {
        matches!(self, Self::InvalidSnapshotStateFault(_))
    }
    /// Returns `true` if the error kind is `CopySnapshotError::ServiceLinkedRoleNotFoundFault`.
    pub fn is_service_linked_role_not_found_fault(&self) -> bool {
        matches!(self, Self::ServiceLinkedRoleNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `CopySnapshotError::SnapshotAlreadyExistsFault`.
    pub fn is_snapshot_already_exists_fault(&self) -> bool {
        matches!(self, Self::SnapshotAlreadyExistsFault(_))
    }
    /// Returns `true` if the error kind is `CopySnapshotError::SnapshotNotFoundFault`.
    pub fn is_snapshot_not_found_fault(&self) -> bool {
        matches!(self, Self::SnapshotNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `CopySnapshotError::SnapshotQuotaExceededFault`.
    pub fn is_snapshot_quota_exceeded_fault(&self) -> bool {
        matches!(self, Self::SnapshotQuotaExceededFault(_))
    }
    /// Returns `true` if the error kind is `CopySnapshotError::TagQuotaPerResourceExceeded`.
    pub fn is_tag_quota_per_resource_exceeded(&self) -> bool {
        matches!(self, Self::TagQuotaPerResourceExceeded(_))
    }
}
impl std::error::Error for CopySnapshotError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::InvalidParameterCombinationException(_inner) => Some(_inner),
            Self::InvalidParameterValueException(_inner) => Some(_inner),
            Self::InvalidSnapshotStateFault(_inner) => Some(_inner),
            Self::ServiceLinkedRoleNotFoundFault(_inner) => Some(_inner),
            Self::SnapshotAlreadyExistsFault(_inner) => Some(_inner),
            Self::SnapshotNotFoundFault(_inner) => Some(_inner),
            Self::SnapshotQuotaExceededFault(_inner) => Some(_inner),
            Self::TagQuotaPerResourceExceeded(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type BatchUpdateClusterErrorKind = BatchUpdateClusterError;
/// Error type for the `BatchUpdateClusterError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum BatchUpdateClusterError {
    /// <p></p>
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    /// <p></p>
    ServiceUpdateNotFoundFault(crate::error::ServiceUpdateNotFoundFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for BatchUpdateClusterError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for BatchUpdateClusterError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::InvalidParameterValueException(_inner) => _inner.fmt(f),
            Self::ServiceUpdateNotFoundFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for BatchUpdateClusterError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::InvalidParameterValueException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceUpdateNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::BatchUpdateClusterError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for BatchUpdateClusterError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl BatchUpdateClusterError {
    /// Creates the `BatchUpdateClusterError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `BatchUpdateClusterError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::InvalidParameterValueException(e) => e.meta(),
            Self::ServiceUpdateNotFoundFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `BatchUpdateClusterError::InvalidParameterValueException`.
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(self, Self::InvalidParameterValueException(_))
    }
    /// Returns `true` if the error kind is `BatchUpdateClusterError::ServiceUpdateNotFoundFault`.
    pub fn is_service_update_not_found_fault(&self) -> bool {
        matches!(self, Self::ServiceUpdateNotFoundFault(_))
    }
}
impl std::error::Error for BatchUpdateClusterError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::InvalidParameterValueException(_inner) => Some(_inner),
            Self::ServiceUpdateNotFoundFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ServiceUpdateNotFoundFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl ServiceUpdateNotFoundFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ServiceUpdateNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ServiceUpdateNotFoundFault")?;
        if let Some(inner_53) = &self.message {
            {
                write!(f, ": {}", inner_53)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ServiceUpdateNotFoundFault {}
impl aws_http::request_id::RequestId for crate::error::ServiceUpdateNotFoundFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ServiceUpdateNotFoundFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl ServiceUpdateNotFoundFault {
    /// Creates a new builder-style object to manufacture [`ServiceUpdateNotFoundFault`](crate::error::ServiceUpdateNotFoundFault).
    pub fn builder() -> crate::error::service_update_not_found_fault::Builder {
        crate::error::service_update_not_found_fault::Builder::default()
    }
}

/// See [`ServiceUpdateNotFoundFault`](crate::error::ServiceUpdateNotFoundFault).
pub mod service_update_not_found_fault {

    /// A builder for [`ServiceUpdateNotFoundFault`](crate::error::ServiceUpdateNotFoundFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`ServiceUpdateNotFoundFault`](crate::error::ServiceUpdateNotFoundFault).
        pub fn build(self) -> crate::error::ServiceUpdateNotFoundFault {
            crate::error::ServiceUpdateNotFoundFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
