// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateClusterInput {
    /// <p>The name of the cluster. This value must be unique as it also serves as the cluster identifier.</p>
    #[doc(hidden)]
    pub cluster_name: std::option::Option<std::string::String>,
    /// <p>The compute and memory capacity of the nodes in the cluster.</p>
    #[doc(hidden)]
    pub node_type: std::option::Option<std::string::String>,
    /// <p>The name of the parameter group associated with the cluster.</p>
    #[doc(hidden)]
    pub parameter_group_name: std::option::Option<std::string::String>,
    /// <p>An optional description of the cluster.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The number of shards the cluster will contain. The default value is 1. </p>
    #[doc(hidden)]
    pub num_shards: std::option::Option<i32>,
    /// <p>The number of replicas to apply to each shard. The default value is 1. The maximum is 5. </p>
    #[doc(hidden)]
    pub num_replicas_per_shard: std::option::Option<i32>,
    /// <p>The name of the subnet group to be used for the cluster.</p>
    #[doc(hidden)]
    pub subnet_group_name: std::option::Option<std::string::String>,
    /// <p>A list of security group names to associate with this cluster.</p>
    #[doc(hidden)]
    pub security_group_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Specifies the weekly time range during which maintenance on the cluster is performed. It is specified as a range in the format ddd:hh24:mi-ddd:hh24:mi (24H Clock UTC). The minimum maintenance window is a 60 minute period.</p>
    /// <p>Valid values for <code>ddd</code> are:</p>
    /// <ul>
    /// <li> <p> <code>sun</code> </p> </li>
    /// <li> <p> <code>mon</code> </p> </li>
    /// <li> <p> <code>tue</code> </p> </li>
    /// <li> <p> <code>wed</code> </p> </li>
    /// <li> <p> <code>thu</code> </p> </li>
    /// <li> <p> <code>fri</code> </p> </li>
    /// <li> <p> <code>sat</code> </p> </li>
    /// </ul>
    /// <p>Example: <code>sun:23:00-mon:01:30</code> </p>
    #[doc(hidden)]
    pub maintenance_window: std::option::Option<std::string::String>,
    /// <p>The port number on which each of the nodes accepts connections.</p>
    #[doc(hidden)]
    pub port: std::option::Option<i32>,
    /// <p>The Amazon Resource Name (ARN) of the Amazon Simple Notification Service (SNS) topic to which notifications are sent.</p>
    #[doc(hidden)]
    pub sns_topic_arn: std::option::Option<std::string::String>,
    /// <p>A flag to enable in-transit encryption on the cluster.</p>
    #[doc(hidden)]
    pub tls_enabled: std::option::Option<bool>,
    /// <p>The ID of the KMS key used to encrypt the cluster.</p>
    #[doc(hidden)]
    pub kms_key_id: std::option::Option<std::string::String>,
    /// <p>A list of Amazon Resource Names (ARN) that uniquely identify the RDB snapshot files stored in Amazon S3. The snapshot files are used to populate the new cluster. The Amazon S3 object name in the ARN cannot contain any commas.</p>
    #[doc(hidden)]
    pub snapshot_arns: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The name of a snapshot from which to restore data into the new cluster. The snapshot status changes to restoring while the new cluster is being created.</p>
    #[doc(hidden)]
    pub snapshot_name: std::option::Option<std::string::String>,
    /// <p>The number of days for which MemoryDB retains automatic snapshots before deleting them. For example, if you set SnapshotRetentionLimit to 5, a snapshot that was taken today is retained for 5 days before being deleted.</p>
    #[doc(hidden)]
    pub snapshot_retention_limit: std::option::Option<i32>,
    /// <p>A list of tags to be added to this resource. Tags are comma-separated key,value pairs (e.g. Key=myKey, Value=myKeyValue. You can include multiple tags as shown following: Key=myKey, Value=myKeyValue Key=mySecondKey, Value=mySecondKeyValue.</p>
    #[doc(hidden)]
    pub tags: std::option::Option<std::vec::Vec<crate::types::Tag>>,
    /// <p>The daily time range (in UTC) during which MemoryDB begins taking a daily snapshot of your shard.</p>
    /// <p> Example: 05:00-09:00</p>
    /// <p> If you do not specify this parameter, MemoryDB automatically chooses an appropriate time range.</p>
    #[doc(hidden)]
    pub snapshot_window: std::option::Option<std::string::String>,
    /// <p>The name of the Access Control List to associate with the cluster.</p>
    #[doc(hidden)]
    pub acl_name: std::option::Option<std::string::String>,
    /// <p>The version number of the Redis engine to be used for the cluster.</p>
    #[doc(hidden)]
    pub engine_version: std::option::Option<std::string::String>,
    /// <p>When set to true, the cluster will automatically receive minor engine version upgrades after launch.</p>
    #[doc(hidden)]
    pub auto_minor_version_upgrade: std::option::Option<bool>,
    /// <p>Enables data tiering. Data tiering is only supported for clusters using the r6gd node type. This parameter must be set when using r6gd nodes. For more information, see <a href="https://docs.aws.amazon.com/memorydb/latest/devguide/data-tiering.html">Data tiering</a>.</p>
    #[doc(hidden)]
    pub data_tiering: std::option::Option<bool>,
}
impl CreateClusterInput {
    /// <p>The name of the cluster. This value must be unique as it also serves as the cluster identifier.</p>
    pub fn cluster_name(&self) -> std::option::Option<&str> {
        self.cluster_name.as_deref()
    }
    /// <p>The compute and memory capacity of the nodes in the cluster.</p>
    pub fn node_type(&self) -> std::option::Option<&str> {
        self.node_type.as_deref()
    }
    /// <p>The name of the parameter group associated with the cluster.</p>
    pub fn parameter_group_name(&self) -> std::option::Option<&str> {
        self.parameter_group_name.as_deref()
    }
    /// <p>An optional description of the cluster.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The number of shards the cluster will contain. The default value is 1. </p>
    pub fn num_shards(&self) -> std::option::Option<i32> {
        self.num_shards
    }
    /// <p>The number of replicas to apply to each shard. The default value is 1. The maximum is 5. </p>
    pub fn num_replicas_per_shard(&self) -> std::option::Option<i32> {
        self.num_replicas_per_shard
    }
    /// <p>The name of the subnet group to be used for the cluster.</p>
    pub fn subnet_group_name(&self) -> std::option::Option<&str> {
        self.subnet_group_name.as_deref()
    }
    /// <p>A list of security group names to associate with this cluster.</p>
    pub fn security_group_ids(&self) -> std::option::Option<&[std::string::String]> {
        self.security_group_ids.as_deref()
    }
    /// <p>Specifies the weekly time range during which maintenance on the cluster is performed. It is specified as a range in the format ddd:hh24:mi-ddd:hh24:mi (24H Clock UTC). The minimum maintenance window is a 60 minute period.</p>
    /// <p>Valid values for <code>ddd</code> are:</p>
    /// <ul>
    /// <li> <p> <code>sun</code> </p> </li>
    /// <li> <p> <code>mon</code> </p> </li>
    /// <li> <p> <code>tue</code> </p> </li>
    /// <li> <p> <code>wed</code> </p> </li>
    /// <li> <p> <code>thu</code> </p> </li>
    /// <li> <p> <code>fri</code> </p> </li>
    /// <li> <p> <code>sat</code> </p> </li>
    /// </ul>
    /// <p>Example: <code>sun:23:00-mon:01:30</code> </p>
    pub fn maintenance_window(&self) -> std::option::Option<&str> {
        self.maintenance_window.as_deref()
    }
    /// <p>The port number on which each of the nodes accepts connections.</p>
    pub fn port(&self) -> std::option::Option<i32> {
        self.port
    }
    /// <p>The Amazon Resource Name (ARN) of the Amazon Simple Notification Service (SNS) topic to which notifications are sent.</p>
    pub fn sns_topic_arn(&self) -> std::option::Option<&str> {
        self.sns_topic_arn.as_deref()
    }
    /// <p>A flag to enable in-transit encryption on the cluster.</p>
    pub fn tls_enabled(&self) -> std::option::Option<bool> {
        self.tls_enabled
    }
    /// <p>The ID of the KMS key used to encrypt the cluster.</p>
    pub fn kms_key_id(&self) -> std::option::Option<&str> {
        self.kms_key_id.as_deref()
    }
    /// <p>A list of Amazon Resource Names (ARN) that uniquely identify the RDB snapshot files stored in Amazon S3. The snapshot files are used to populate the new cluster. The Amazon S3 object name in the ARN cannot contain any commas.</p>
    pub fn snapshot_arns(&self) -> std::option::Option<&[std::string::String]> {
        self.snapshot_arns.as_deref()
    }
    /// <p>The name of a snapshot from which to restore data into the new cluster. The snapshot status changes to restoring while the new cluster is being created.</p>
    pub fn snapshot_name(&self) -> std::option::Option<&str> {
        self.snapshot_name.as_deref()
    }
    /// <p>The number of days for which MemoryDB retains automatic snapshots before deleting them. For example, if you set SnapshotRetentionLimit to 5, a snapshot that was taken today is retained for 5 days before being deleted.</p>
    pub fn snapshot_retention_limit(&self) -> std::option::Option<i32> {
        self.snapshot_retention_limit
    }
    /// <p>A list of tags to be added to this resource. Tags are comma-separated key,value pairs (e.g. Key=myKey, Value=myKeyValue. You can include multiple tags as shown following: Key=myKey, Value=myKeyValue Key=mySecondKey, Value=mySecondKeyValue.</p>
    pub fn tags(&self) -> std::option::Option<&[crate::types::Tag]> {
        self.tags.as_deref()
    }
    /// <p>The daily time range (in UTC) during which MemoryDB begins taking a daily snapshot of your shard.</p>
    /// <p> Example: 05:00-09:00</p>
    /// <p> If you do not specify this parameter, MemoryDB automatically chooses an appropriate time range.</p>
    pub fn snapshot_window(&self) -> std::option::Option<&str> {
        self.snapshot_window.as_deref()
    }
    /// <p>The name of the Access Control List to associate with the cluster.</p>
    pub fn acl_name(&self) -> std::option::Option<&str> {
        self.acl_name.as_deref()
    }
    /// <p>The version number of the Redis engine to be used for the cluster.</p>
    pub fn engine_version(&self) -> std::option::Option<&str> {
        self.engine_version.as_deref()
    }
    /// <p>When set to true, the cluster will automatically receive minor engine version upgrades after launch.</p>
    pub fn auto_minor_version_upgrade(&self) -> std::option::Option<bool> {
        self.auto_minor_version_upgrade
    }
    /// <p>Enables data tiering. Data tiering is only supported for clusters using the r6gd node type. This parameter must be set when using r6gd nodes. For more information, see <a href="https://docs.aws.amazon.com/memorydb/latest/devguide/data-tiering.html">Data tiering</a>.</p>
    pub fn data_tiering(&self) -> std::option::Option<bool> {
        self.data_tiering
    }
}
impl CreateClusterInput {
    /// Creates a new builder-style object to manufacture [`CreateClusterInput`](crate::operation::create_cluster::CreateClusterInput).
    pub fn builder() -> crate::operation::create_cluster::builders::CreateClusterInputBuilder {
        crate::operation::create_cluster::builders::CreateClusterInputBuilder::default()
    }
}

/// A builder for [`CreateClusterInput`](crate::operation::create_cluster::CreateClusterInput).
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
pub struct CreateClusterInputBuilder {
    pub(crate) cluster_name: std::option::Option<std::string::String>,
    pub(crate) node_type: std::option::Option<std::string::String>,
    pub(crate) parameter_group_name: std::option::Option<std::string::String>,
    pub(crate) description: std::option::Option<std::string::String>,
    pub(crate) num_shards: std::option::Option<i32>,
    pub(crate) num_replicas_per_shard: std::option::Option<i32>,
    pub(crate) subnet_group_name: std::option::Option<std::string::String>,
    pub(crate) security_group_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    pub(crate) maintenance_window: std::option::Option<std::string::String>,
    pub(crate) port: std::option::Option<i32>,
    pub(crate) sns_topic_arn: std::option::Option<std::string::String>,
    pub(crate) tls_enabled: std::option::Option<bool>,
    pub(crate) kms_key_id: std::option::Option<std::string::String>,
    pub(crate) snapshot_arns: std::option::Option<std::vec::Vec<std::string::String>>,
    pub(crate) snapshot_name: std::option::Option<std::string::String>,
    pub(crate) snapshot_retention_limit: std::option::Option<i32>,
    pub(crate) tags: std::option::Option<std::vec::Vec<crate::types::Tag>>,
    pub(crate) snapshot_window: std::option::Option<std::string::String>,
    pub(crate) acl_name: std::option::Option<std::string::String>,
    pub(crate) engine_version: std::option::Option<std::string::String>,
    pub(crate) auto_minor_version_upgrade: std::option::Option<bool>,
    pub(crate) data_tiering: std::option::Option<bool>,
}
impl CreateClusterInputBuilder {
    /// <p>The name of the cluster. This value must be unique as it also serves as the cluster identifier.</p>
    pub fn cluster_name(mut self, input: impl Into<std::string::String>) -> Self {
        self.cluster_name = Some(input.into());
        self
    }
    /// <p>The name of the cluster. This value must be unique as it also serves as the cluster identifier.</p>
    pub fn set_cluster_name(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.cluster_name = input;
        self
    }
    /// <p>The compute and memory capacity of the nodes in the cluster.</p>
    pub fn node_type(mut self, input: impl Into<std::string::String>) -> Self {
        self.node_type = Some(input.into());
        self
    }
    /// <p>The compute and memory capacity of the nodes in the cluster.</p>
    pub fn set_node_type(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.node_type = input;
        self
    }
    /// <p>The name of the parameter group associated with the cluster.</p>
    pub fn parameter_group_name(mut self, input: impl Into<std::string::String>) -> Self {
        self.parameter_group_name = Some(input.into());
        self
    }
    /// <p>The name of the parameter group associated with the cluster.</p>
    pub fn set_parameter_group_name(
        mut self,
        input: std::option::Option<std::string::String>,
    ) -> Self {
        self.parameter_group_name = input;
        self
    }
    /// <p>An optional description of the cluster.</p>
    pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
        self.description = Some(input.into());
        self
    }
    /// <p>An optional description of the cluster.</p>
    pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.description = input;
        self
    }
    /// <p>The number of shards the cluster will contain. The default value is 1. </p>
    pub fn num_shards(mut self, input: i32) -> Self {
        self.num_shards = Some(input);
        self
    }
    /// <p>The number of shards the cluster will contain. The default value is 1. </p>
    pub fn set_num_shards(mut self, input: std::option::Option<i32>) -> Self {
        self.num_shards = input;
        self
    }
    /// <p>The number of replicas to apply to each shard. The default value is 1. The maximum is 5. </p>
    pub fn num_replicas_per_shard(mut self, input: i32) -> Self {
        self.num_replicas_per_shard = Some(input);
        self
    }
    /// <p>The number of replicas to apply to each shard. The default value is 1. The maximum is 5. </p>
    pub fn set_num_replicas_per_shard(mut self, input: std::option::Option<i32>) -> Self {
        self.num_replicas_per_shard = input;
        self
    }
    /// <p>The name of the subnet group to be used for the cluster.</p>
    pub fn subnet_group_name(mut self, input: impl Into<std::string::String>) -> Self {
        self.subnet_group_name = Some(input.into());
        self
    }
    /// <p>The name of the subnet group to be used for the cluster.</p>
    pub fn set_subnet_group_name(
        mut self,
        input: std::option::Option<std::string::String>,
    ) -> Self {
        self.subnet_group_name = input;
        self
    }
    /// Appends an item to `security_group_ids`.
    ///
    /// To override the contents of this collection use [`set_security_group_ids`](Self::set_security_group_ids).
    ///
    /// <p>A list of security group names to associate with this cluster.</p>
    pub fn security_group_ids(mut self, input: impl Into<std::string::String>) -> Self {
        let mut v = self.security_group_ids.unwrap_or_default();
        v.push(input.into());
        self.security_group_ids = Some(v);
        self
    }
    /// <p>A list of security group names to associate with this cluster.</p>
    pub fn set_security_group_ids(
        mut self,
        input: std::option::Option<std::vec::Vec<std::string::String>>,
    ) -> Self {
        self.security_group_ids = input;
        self
    }
    /// <p>Specifies the weekly time range during which maintenance on the cluster is performed. It is specified as a range in the format ddd:hh24:mi-ddd:hh24:mi (24H Clock UTC). The minimum maintenance window is a 60 minute period.</p>
    /// <p>Valid values for <code>ddd</code> are:</p>
    /// <ul>
    /// <li> <p> <code>sun</code> </p> </li>
    /// <li> <p> <code>mon</code> </p> </li>
    /// <li> <p> <code>tue</code> </p> </li>
    /// <li> <p> <code>wed</code> </p> </li>
    /// <li> <p> <code>thu</code> </p> </li>
    /// <li> <p> <code>fri</code> </p> </li>
    /// <li> <p> <code>sat</code> </p> </li>
    /// </ul>
    /// <p>Example: <code>sun:23:00-mon:01:30</code> </p>
    pub fn maintenance_window(mut self, input: impl Into<std::string::String>) -> Self {
        self.maintenance_window = Some(input.into());
        self
    }
    /// <p>Specifies the weekly time range during which maintenance on the cluster is performed. It is specified as a range in the format ddd:hh24:mi-ddd:hh24:mi (24H Clock UTC). The minimum maintenance window is a 60 minute period.</p>
    /// <p>Valid values for <code>ddd</code> are:</p>
    /// <ul>
    /// <li> <p> <code>sun</code> </p> </li>
    /// <li> <p> <code>mon</code> </p> </li>
    /// <li> <p> <code>tue</code> </p> </li>
    /// <li> <p> <code>wed</code> </p> </li>
    /// <li> <p> <code>thu</code> </p> </li>
    /// <li> <p> <code>fri</code> </p> </li>
    /// <li> <p> <code>sat</code> </p> </li>
    /// </ul>
    /// <p>Example: <code>sun:23:00-mon:01:30</code> </p>
    pub fn set_maintenance_window(
        mut self,
        input: std::option::Option<std::string::String>,
    ) -> Self {
        self.maintenance_window = input;
        self
    }
    /// <p>The port number on which each of the nodes accepts connections.</p>
    pub fn port(mut self, input: i32) -> Self {
        self.port = Some(input);
        self
    }
    /// <p>The port number on which each of the nodes accepts connections.</p>
    pub fn set_port(mut self, input: std::option::Option<i32>) -> Self {
        self.port = input;
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the Amazon Simple Notification Service (SNS) topic to which notifications are sent.</p>
    pub fn sns_topic_arn(mut self, input: impl Into<std::string::String>) -> Self {
        self.sns_topic_arn = Some(input.into());
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the Amazon Simple Notification Service (SNS) topic to which notifications are sent.</p>
    pub fn set_sns_topic_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.sns_topic_arn = input;
        self
    }
    /// <p>A flag to enable in-transit encryption on the cluster.</p>
    pub fn tls_enabled(mut self, input: bool) -> Self {
        self.tls_enabled = Some(input);
        self
    }
    /// <p>A flag to enable in-transit encryption on the cluster.</p>
    pub fn set_tls_enabled(mut self, input: std::option::Option<bool>) -> Self {
        self.tls_enabled = input;
        self
    }
    /// <p>The ID of the KMS key used to encrypt the cluster.</p>
    pub fn kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
        self.kms_key_id = Some(input.into());
        self
    }
    /// <p>The ID of the KMS key used to encrypt the cluster.</p>
    pub fn set_kms_key_id(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.kms_key_id = input;
        self
    }
    /// Appends an item to `snapshot_arns`.
    ///
    /// To override the contents of this collection use [`set_snapshot_arns`](Self::set_snapshot_arns).
    ///
    /// <p>A list of Amazon Resource Names (ARN) that uniquely identify the RDB snapshot files stored in Amazon S3. The snapshot files are used to populate the new cluster. The Amazon S3 object name in the ARN cannot contain any commas.</p>
    pub fn snapshot_arns(mut self, input: impl Into<std::string::String>) -> Self {
        let mut v = self.snapshot_arns.unwrap_or_default();
        v.push(input.into());
        self.snapshot_arns = Some(v);
        self
    }
    /// <p>A list of Amazon Resource Names (ARN) that uniquely identify the RDB snapshot files stored in Amazon S3. The snapshot files are used to populate the new cluster. The Amazon S3 object name in the ARN cannot contain any commas.</p>
    pub fn set_snapshot_arns(
        mut self,
        input: std::option::Option<std::vec::Vec<std::string::String>>,
    ) -> Self {
        self.snapshot_arns = input;
        self
    }
    /// <p>The name of a snapshot from which to restore data into the new cluster. The snapshot status changes to restoring while the new cluster is being created.</p>
    pub fn snapshot_name(mut self, input: impl Into<std::string::String>) -> Self {
        self.snapshot_name = Some(input.into());
        self
    }
    /// <p>The name of a snapshot from which to restore data into the new cluster. The snapshot status changes to restoring while the new cluster is being created.</p>
    pub fn set_snapshot_name(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.snapshot_name = input;
        self
    }
    /// <p>The number of days for which MemoryDB retains automatic snapshots before deleting them. For example, if you set SnapshotRetentionLimit to 5, a snapshot that was taken today is retained for 5 days before being deleted.</p>
    pub fn snapshot_retention_limit(mut self, input: i32) -> Self {
        self.snapshot_retention_limit = Some(input);
        self
    }
    /// <p>The number of days for which MemoryDB retains automatic snapshots before deleting them. For example, if you set SnapshotRetentionLimit to 5, a snapshot that was taken today is retained for 5 days before being deleted.</p>
    pub fn set_snapshot_retention_limit(mut self, input: std::option::Option<i32>) -> Self {
        self.snapshot_retention_limit = input;
        self
    }
    /// Appends an item to `tags`.
    ///
    /// To override the contents of this collection use [`set_tags`](Self::set_tags).
    ///
    /// <p>A list of tags to be added to this resource. Tags are comma-separated key,value pairs (e.g. Key=myKey, Value=myKeyValue. You can include multiple tags as shown following: Key=myKey, Value=myKeyValue Key=mySecondKey, Value=mySecondKeyValue.</p>
    pub fn tags(mut self, input: crate::types::Tag) -> Self {
        let mut v = self.tags.unwrap_or_default();
        v.push(input);
        self.tags = Some(v);
        self
    }
    /// <p>A list of tags to be added to this resource. Tags are comma-separated key,value pairs (e.g. Key=myKey, Value=myKeyValue. You can include multiple tags as shown following: Key=myKey, Value=myKeyValue Key=mySecondKey, Value=mySecondKeyValue.</p>
    pub fn set_tags(
        mut self,
        input: std::option::Option<std::vec::Vec<crate::types::Tag>>,
    ) -> Self {
        self.tags = input;
        self
    }
    /// <p>The daily time range (in UTC) during which MemoryDB begins taking a daily snapshot of your shard.</p>
    /// <p> Example: 05:00-09:00</p>
    /// <p> If you do not specify this parameter, MemoryDB automatically chooses an appropriate time range.</p>
    pub fn snapshot_window(mut self, input: impl Into<std::string::String>) -> Self {
        self.snapshot_window = Some(input.into());
        self
    }
    /// <p>The daily time range (in UTC) during which MemoryDB begins taking a daily snapshot of your shard.</p>
    /// <p> Example: 05:00-09:00</p>
    /// <p> If you do not specify this parameter, MemoryDB automatically chooses an appropriate time range.</p>
    pub fn set_snapshot_window(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.snapshot_window = input;
        self
    }
    /// <p>The name of the Access Control List to associate with the cluster.</p>
    pub fn acl_name(mut self, input: impl Into<std::string::String>) -> Self {
        self.acl_name = Some(input.into());
        self
    }
    /// <p>The name of the Access Control List to associate with the cluster.</p>
    pub fn set_acl_name(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.acl_name = input;
        self
    }
    /// <p>The version number of the Redis engine to be used for the cluster.</p>
    pub fn engine_version(mut self, input: impl Into<std::string::String>) -> Self {
        self.engine_version = Some(input.into());
        self
    }
    /// <p>The version number of the Redis engine to be used for the cluster.</p>
    pub fn set_engine_version(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.engine_version = input;
        self
    }
    /// <p>When set to true, the cluster will automatically receive minor engine version upgrades after launch.</p>
    pub fn auto_minor_version_upgrade(mut self, input: bool) -> Self {
        self.auto_minor_version_upgrade = Some(input);
        self
    }
    /// <p>When set to true, the cluster will automatically receive minor engine version upgrades after launch.</p>
    pub fn set_auto_minor_version_upgrade(mut self, input: std::option::Option<bool>) -> Self {
        self.auto_minor_version_upgrade = input;
        self
    }
    /// <p>Enables data tiering. Data tiering is only supported for clusters using the r6gd node type. This parameter must be set when using r6gd nodes. For more information, see <a href="https://docs.aws.amazon.com/memorydb/latest/devguide/data-tiering.html">Data tiering</a>.</p>
    pub fn data_tiering(mut self, input: bool) -> Self {
        self.data_tiering = Some(input);
        self
    }
    /// <p>Enables data tiering. Data tiering is only supported for clusters using the r6gd node type. This parameter must be set when using r6gd nodes. For more information, see <a href="https://docs.aws.amazon.com/memorydb/latest/devguide/data-tiering.html">Data tiering</a>.</p>
    pub fn set_data_tiering(mut self, input: std::option::Option<bool>) -> Self {
        self.data_tiering = input;
        self
    }
    /// Consumes the builder and constructs a [`CreateClusterInput`](crate::operation::create_cluster::CreateClusterInput).
    pub fn build(
        self,
    ) -> Result<
        crate::operation::create_cluster::CreateClusterInput,
        aws_smithy_http::operation::error::BuildError,
    > {
        Ok(crate::operation::create_cluster::CreateClusterInput {
            cluster_name: self.cluster_name,
            node_type: self.node_type,
            parameter_group_name: self.parameter_group_name,
            description: self.description,
            num_shards: self.num_shards,
            num_replicas_per_shard: self.num_replicas_per_shard,
            subnet_group_name: self.subnet_group_name,
            security_group_ids: self.security_group_ids,
            maintenance_window: self.maintenance_window,
            port: self.port,
            sns_topic_arn: self.sns_topic_arn,
            tls_enabled: self.tls_enabled,
            kms_key_id: self.kms_key_id,
            snapshot_arns: self.snapshot_arns,
            snapshot_name: self.snapshot_name,
            snapshot_retention_limit: self.snapshot_retention_limit,
            tags: self.tags,
            snapshot_window: self.snapshot_window,
            acl_name: self.acl_name,
            engine_version: self.engine_version,
            auto_minor_version_upgrade: self.auto_minor_version_upgrade,
            data_tiering: self.data_tiering,
        })
    }
}
