// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// <p>An entitlement represents capacity in a product owned by the customer. For example, a
/// customer might own some number of users or seats in an SaaS application or  some amount of
/// data capacity in a multi-tenant database.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Entitlement {
    /// <p>The product code for which the given entitlement applies. Product codes are provided by
    /// AWS Marketplace when the product listing is created.</p>
    pub product_code: std::option::Option<std::string::String>,
    /// <p>The dimension for which the given entitlement applies. Dimensions represent categories of
    /// capacity in a product and are specified when the product is listed in AWS
    /// Marketplace.</p>
    pub dimension: std::option::Option<std::string::String>,
    /// <p>The customer identifier is a handle to each unique customer in an application. Customer
    /// identifiers are obtained through the ResolveCustomer operation in AWS Marketplace Metering
    /// Service.</p>
    pub customer_identifier: std::option::Option<std::string::String>,
    /// <p>The EntitlementValue represents the amount of capacity that the customer is entitled to
    /// for the product.</p>
    pub value: std::option::Option<crate::model::EntitlementValue>,
    /// <p>The expiration date represents the minimum date through which this entitlement is
    /// expected to remain valid. For contractual products listed on AWS Marketplace, the expiration date
    /// is the date at which the customer will renew or cancel their contract. Customers who are opting
    /// to renew their contract will still have entitlements with an expiration date.</p>
    pub expiration_date: std::option::Option<smithy_types::Instant>,
}
impl std::fmt::Debug for Entitlement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Entitlement");
        formatter.field("product_code", &self.product_code);
        formatter.field("dimension", &self.dimension);
        formatter.field("customer_identifier", &self.customer_identifier);
        formatter.field("value", &self.value);
        formatter.field("expiration_date", &self.expiration_date);
        formatter.finish()
    }
}
/// See [`Entitlement`](crate::model::Entitlement)
pub mod entitlement {
    /// A builder for [`Entitlement`](crate::model::Entitlement)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) product_code: std::option::Option<std::string::String>,
        pub(crate) dimension: std::option::Option<std::string::String>,
        pub(crate) customer_identifier: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<crate::model::EntitlementValue>,
        pub(crate) expiration_date: std::option::Option<smithy_types::Instant>,
    }
    impl Builder {
        /// <p>The product code for which the given entitlement applies. Product codes are provided by
        /// AWS Marketplace when the product listing is created.</p>
        pub fn product_code(mut self, input: impl Into<std::string::String>) -> Self {
            self.product_code = Some(input.into());
            self
        }
        pub fn set_product_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.product_code = input;
            self
        }
        /// <p>The dimension for which the given entitlement applies. Dimensions represent categories of
        /// capacity in a product and are specified when the product is listed in AWS
        /// Marketplace.</p>
        pub fn dimension(mut self, input: impl Into<std::string::String>) -> Self {
            self.dimension = Some(input.into());
            self
        }
        pub fn set_dimension(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.dimension = input;
            self
        }
        /// <p>The customer identifier is a handle to each unique customer in an application. Customer
        /// identifiers are obtained through the ResolveCustomer operation in AWS Marketplace Metering
        /// Service.</p>
        pub fn customer_identifier(mut self, input: impl Into<std::string::String>) -> Self {
            self.customer_identifier = Some(input.into());
            self
        }
        pub fn set_customer_identifier(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.customer_identifier = input;
            self
        }
        /// <p>The EntitlementValue represents the amount of capacity that the customer is entitled to
        /// for the product.</p>
        pub fn value(mut self, input: crate::model::EntitlementValue) -> Self {
            self.value = Some(input);
            self
        }
        pub fn set_value(
            mut self,
            input: std::option::Option<crate::model::EntitlementValue>,
        ) -> Self {
            self.value = input;
            self
        }
        /// <p>The expiration date represents the minimum date through which this entitlement is
        /// expected to remain valid. For contractual products listed on AWS Marketplace, the expiration date
        /// is the date at which the customer will renew or cancel their contract. Customers who are opting
        /// to renew their contract will still have entitlements with an expiration date.</p>
        pub fn expiration_date(mut self, input: smithy_types::Instant) -> Self {
            self.expiration_date = Some(input);
            self
        }
        pub fn set_expiration_date(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.expiration_date = input;
            self
        }
        /// Consumes the builder and constructs a [`Entitlement`](crate::model::Entitlement)
        pub fn build(self) -> crate::model::Entitlement {
            crate::model::Entitlement {
                product_code: self.product_code,
                dimension: self.dimension,
                customer_identifier: self.customer_identifier,
                value: self.value,
                expiration_date: self.expiration_date,
            }
        }
    }
}
impl Entitlement {
    /// Creates a new builder-style object to manufacture [`Entitlement`](crate::model::Entitlement)
    pub fn builder() -> crate::model::entitlement::Builder {
        crate::model::entitlement::Builder::default()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub enum EntitlementValue {
    /// <p>The BooleanValue field will be populated with a boolean value when the entitlement is a
    /// boolean type. Otherwise, the field will not be set.</p>
    BooleanValue(bool),
    /// <p>The DoubleValue field will be populated with a double value when the entitlement is a
    /// double type. Otherwise, the field will not be set.</p>
    DoubleValue(f64),
    /// <p>The IntegerValue field will be populated with an integer value when the entitlement is an
    /// integer type. Otherwise, the field will not be set.</p>
    IntegerValue(i32),
    /// <p>The StringValue field will be populated with a string value when the entitlement is a
    /// string type. Otherwise, the field will not be set.</p>
    StringValue(std::string::String),
}
impl EntitlementValue {
    pub fn as_boolean_value(&self) -> Result<&bool, &Self> {
        if let EntitlementValue::BooleanValue(val) = &self {
            Ok(&val)
        } else {
            Err(&self)
        }
    }
    pub fn is_boolean_value(&self) -> bool {
        self.as_boolean_value().is_ok()
    }
    pub fn as_double_value(&self) -> Result<&f64, &Self> {
        if let EntitlementValue::DoubleValue(val) = &self {
            Ok(&val)
        } else {
            Err(&self)
        }
    }
    pub fn is_double_value(&self) -> bool {
        self.as_double_value().is_ok()
    }
    pub fn as_integer_value(&self) -> Result<&i32, &Self> {
        if let EntitlementValue::IntegerValue(val) = &self {
            Ok(&val)
        } else {
            Err(&self)
        }
    }
    pub fn is_integer_value(&self) -> bool {
        self.as_integer_value().is_ok()
    }
    pub fn as_string_value(&self) -> Result<&std::string::String, &Self> {
        if let EntitlementValue::StringValue(val) = &self {
            Ok(&val)
        } else {
            Err(&self)
        }
    }
    pub fn is_string_value(&self) -> bool {
        self.as_string_value().is_ok()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum GetEntitlementFilterName {
    CustomerIdentifier,
    Dimension,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for GetEntitlementFilterName {
    fn from(s: &str) -> Self {
        match s {
            "CUSTOMER_IDENTIFIER" => GetEntitlementFilterName::CustomerIdentifier,
            "DIMENSION" => GetEntitlementFilterName::Dimension,
            other => GetEntitlementFilterName::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for GetEntitlementFilterName {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(GetEntitlementFilterName::from(s))
    }
}
impl GetEntitlementFilterName {
    pub fn as_str(&self) -> &str {
        match self {
            GetEntitlementFilterName::CustomerIdentifier => "CUSTOMER_IDENTIFIER",
            GetEntitlementFilterName::Dimension => "DIMENSION",
            GetEntitlementFilterName::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["CUSTOMER_IDENTIFIER", "DIMENSION"]
    }
}
impl AsRef<str> for GetEntitlementFilterName {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
