// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Specifies change details of the domain configuration change.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ChangeProgressDetails {
    /// <p>The unique change identifier associated with a specific domain configuration change.</p>
    pub change_id: std::option::Option<std::string::String>,
    /// <p>Contains an optional message associated with the domain configuration change.</p>
    pub message: std::option::Option<std::string::String>,
}
impl ChangeProgressDetails {
    /// <p>The unique change identifier associated with a specific domain configuration change.</p>
    pub fn change_id(&self) -> std::option::Option<&str> {
        self.change_id.as_deref()
    }
    /// <p>Contains an optional message associated with the domain configuration change.</p>
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Debug for ChangeProgressDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ChangeProgressDetails");
        formatter.field("change_id", &self.change_id);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
/// See [`ChangeProgressDetails`](crate::model::ChangeProgressDetails)
pub mod change_progress_details {

    /// A builder for [`ChangeProgressDetails`](crate::model::ChangeProgressDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) change_id: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique change identifier associated with a specific domain configuration change.</p>
        pub fn change_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.change_id = Some(input.into());
            self
        }
        /// <p>The unique change identifier associated with a specific domain configuration change.</p>
        pub fn set_change_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.change_id = input;
            self
        }
        /// <p>Contains an optional message associated with the domain configuration change.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Contains an optional message associated with the domain configuration change.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ChangeProgressDetails`](crate::model::ChangeProgressDetails)
        pub fn build(self) -> crate::model::ChangeProgressDetails {
            crate::model::ChangeProgressDetails {
                change_id: self.change_id,
                message: self.message,
            }
        }
    }
}
impl ChangeProgressDetails {
    /// Creates a new builder-style object to manufacture [`ChangeProgressDetails`](crate::model::ChangeProgressDetails)
    pub fn builder() -> crate::model::change_progress_details::Builder {
        crate::model::change_progress_details::Builder::default()
    }
}

/// <p>Basic information about a package.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PackageDetails {
    /// <p>Internal ID of the package.</p>
    pub package_id: std::option::Option<std::string::String>,
    /// <p>User-specified name of the package.</p>
    pub package_name: std::option::Option<std::string::String>,
    /// <p>Currently supports only TXT-DICTIONARY.</p>
    pub package_type: std::option::Option<crate::model::PackageType>,
    /// <p>User-specified description of the package.</p>
    pub package_description: std::option::Option<std::string::String>,
    /// <p>Current state of the package. Values are COPYING, COPY_FAILED, AVAILABLE, DELETING, and DELETE_FAILED.</p>
    pub package_status: std::option::Option<crate::model::PackageStatus>,
    /// <p>The timestamp of when the package was created.</p>
    pub created_at: std::option::Option<aws_smithy_types::DateTime>,
    #[allow(missing_docs)] // documentation missing in model
    pub last_updated_at: std::option::Option<aws_smithy_types::DateTime>,
    #[allow(missing_docs)] // documentation missing in model
    pub available_package_version: std::option::Option<std::string::String>,
    /// <p>Additional information if the package is in an error state. Null otherwise.</p>
    pub error_details: std::option::Option<crate::model::ErrorDetails>,
}
impl PackageDetails {
    /// <p>Internal ID of the package.</p>
    pub fn package_id(&self) -> std::option::Option<&str> {
        self.package_id.as_deref()
    }
    /// <p>User-specified name of the package.</p>
    pub fn package_name(&self) -> std::option::Option<&str> {
        self.package_name.as_deref()
    }
    /// <p>Currently supports only TXT-DICTIONARY.</p>
    pub fn package_type(&self) -> std::option::Option<&crate::model::PackageType> {
        self.package_type.as_ref()
    }
    /// <p>User-specified description of the package.</p>
    pub fn package_description(&self) -> std::option::Option<&str> {
        self.package_description.as_deref()
    }
    /// <p>Current state of the package. Values are COPYING, COPY_FAILED, AVAILABLE, DELETING, and DELETE_FAILED.</p>
    pub fn package_status(&self) -> std::option::Option<&crate::model::PackageStatus> {
        self.package_status.as_ref()
    }
    /// <p>The timestamp of when the package was created.</p>
    pub fn created_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_at.as_ref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn last_updated_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_updated_at.as_ref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn available_package_version(&self) -> std::option::Option<&str> {
        self.available_package_version.as_deref()
    }
    /// <p>Additional information if the package is in an error state. Null otherwise.</p>
    pub fn error_details(&self) -> std::option::Option<&crate::model::ErrorDetails> {
        self.error_details.as_ref()
    }
}
impl std::fmt::Debug for PackageDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PackageDetails");
        formatter.field("package_id", &self.package_id);
        formatter.field("package_name", &self.package_name);
        formatter.field("package_type", &self.package_type);
        formatter.field("package_description", &self.package_description);
        formatter.field("package_status", &self.package_status);
        formatter.field("created_at", &self.created_at);
        formatter.field("last_updated_at", &self.last_updated_at);
        formatter.field("available_package_version", &self.available_package_version);
        formatter.field("error_details", &self.error_details);
        formatter.finish()
    }
}
/// See [`PackageDetails`](crate::model::PackageDetails)
pub mod package_details {

    /// A builder for [`PackageDetails`](crate::model::PackageDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) package_id: std::option::Option<std::string::String>,
        pub(crate) package_name: std::option::Option<std::string::String>,
        pub(crate) package_type: std::option::Option<crate::model::PackageType>,
        pub(crate) package_description: std::option::Option<std::string::String>,
        pub(crate) package_status: std::option::Option<crate::model::PackageStatus>,
        pub(crate) created_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_updated_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) available_package_version: std::option::Option<std::string::String>,
        pub(crate) error_details: std::option::Option<crate::model::ErrorDetails>,
    }
    impl Builder {
        /// <p>Internal ID of the package.</p>
        pub fn package_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.package_id = Some(input.into());
            self
        }
        /// <p>Internal ID of the package.</p>
        pub fn set_package_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.package_id = input;
            self
        }
        /// <p>User-specified name of the package.</p>
        pub fn package_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.package_name = Some(input.into());
            self
        }
        /// <p>User-specified name of the package.</p>
        pub fn set_package_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.package_name = input;
            self
        }
        /// <p>Currently supports only TXT-DICTIONARY.</p>
        pub fn package_type(mut self, input: crate::model::PackageType) -> Self {
            self.package_type = Some(input);
            self
        }
        /// <p>Currently supports only TXT-DICTIONARY.</p>
        pub fn set_package_type(
            mut self,
            input: std::option::Option<crate::model::PackageType>,
        ) -> Self {
            self.package_type = input;
            self
        }
        /// <p>User-specified description of the package.</p>
        pub fn package_description(mut self, input: impl Into<std::string::String>) -> Self {
            self.package_description = Some(input.into());
            self
        }
        /// <p>User-specified description of the package.</p>
        pub fn set_package_description(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.package_description = input;
            self
        }
        /// <p>Current state of the package. Values are COPYING, COPY_FAILED, AVAILABLE, DELETING, and DELETE_FAILED.</p>
        pub fn package_status(mut self, input: crate::model::PackageStatus) -> Self {
            self.package_status = Some(input);
            self
        }
        /// <p>Current state of the package. Values are COPYING, COPY_FAILED, AVAILABLE, DELETING, and DELETE_FAILED.</p>
        pub fn set_package_status(
            mut self,
            input: std::option::Option<crate::model::PackageStatus>,
        ) -> Self {
            self.package_status = input;
            self
        }
        /// <p>The timestamp of when the package was created.</p>
        pub fn created_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_at = Some(input);
            self
        }
        /// <p>The timestamp of when the package was created.</p>
        pub fn set_created_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_at = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn last_updated_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_updated_at = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_last_updated_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_updated_at = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn available_package_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.available_package_version = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_available_package_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.available_package_version = input;
            self
        }
        /// <p>Additional information if the package is in an error state. Null otherwise.</p>
        pub fn error_details(mut self, input: crate::model::ErrorDetails) -> Self {
            self.error_details = Some(input);
            self
        }
        /// <p>Additional information if the package is in an error state. Null otherwise.</p>
        pub fn set_error_details(
            mut self,
            input: std::option::Option<crate::model::ErrorDetails>,
        ) -> Self {
            self.error_details = input;
            self
        }
        /// Consumes the builder and constructs a [`PackageDetails`](crate::model::PackageDetails)
        pub fn build(self) -> crate::model::PackageDetails {
            crate::model::PackageDetails {
                package_id: self.package_id,
                package_name: self.package_name,
                package_type: self.package_type,
                package_description: self.package_description,
                package_status: self.package_status,
                created_at: self.created_at,
                last_updated_at: self.last_updated_at,
                available_package_version: self.available_package_version,
                error_details: self.error_details,
            }
        }
    }
}
impl PackageDetails {
    /// Creates a new builder-style object to manufacture [`PackageDetails`](crate::model::PackageDetails)
    pub fn builder() -> crate::model::package_details::Builder {
        crate::model::package_details::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ErrorDetails {
    #[allow(missing_docs)] // documentation missing in model
    pub error_type: std::option::Option<std::string::String>,
    #[allow(missing_docs)] // documentation missing in model
    pub error_message: std::option::Option<std::string::String>,
}
impl ErrorDetails {
    #[allow(missing_docs)] // documentation missing in model
    pub fn error_type(&self) -> std::option::Option<&str> {
        self.error_type.as_deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn error_message(&self) -> std::option::Option<&str> {
        self.error_message.as_deref()
    }
}
impl std::fmt::Debug for ErrorDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ErrorDetails");
        formatter.field("error_type", &self.error_type);
        formatter.field("error_message", &self.error_message);
        formatter.finish()
    }
}
/// See [`ErrorDetails`](crate::model::ErrorDetails)
pub mod error_details {

    /// A builder for [`ErrorDetails`](crate::model::ErrorDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) error_type: std::option::Option<std::string::String>,
        pub(crate) error_message: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn error_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_type = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_error_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.error_type = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn error_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_error_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.error_message = input;
            self
        }
        /// Consumes the builder and constructs a [`ErrorDetails`](crate::model::ErrorDetails)
        pub fn build(self) -> crate::model::ErrorDetails {
            crate::model::ErrorDetails {
                error_type: self.error_type,
                error_message: self.error_message,
            }
        }
    }
}
impl ErrorDetails {
    /// Creates a new builder-style object to manufacture [`ErrorDetails`](crate::model::ErrorDetails)
    pub fn builder() -> crate::model::error_details::Builder {
        crate::model::error_details::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum PackageStatus {
    #[allow(missing_docs)] // documentation missing in model
    Available,
    #[allow(missing_docs)] // documentation missing in model
    Copying,
    #[allow(missing_docs)] // documentation missing in model
    CopyFailed,
    #[allow(missing_docs)] // documentation missing in model
    Deleted,
    #[allow(missing_docs)] // documentation missing in model
    DeleteFailed,
    #[allow(missing_docs)] // documentation missing in model
    Deleting,
    #[allow(missing_docs)] // documentation missing in model
    Validating,
    #[allow(missing_docs)] // documentation missing in model
    ValidationFailed,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for PackageStatus {
    fn from(s: &str) -> Self {
        match s {
            "AVAILABLE" => PackageStatus::Available,
            "COPYING" => PackageStatus::Copying,
            "COPY_FAILED" => PackageStatus::CopyFailed,
            "DELETED" => PackageStatus::Deleted,
            "DELETE_FAILED" => PackageStatus::DeleteFailed,
            "DELETING" => PackageStatus::Deleting,
            "VALIDATING" => PackageStatus::Validating,
            "VALIDATION_FAILED" => PackageStatus::ValidationFailed,
            other => PackageStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for PackageStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(PackageStatus::from(s))
    }
}
impl PackageStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            PackageStatus::Available => "AVAILABLE",
            PackageStatus::Copying => "COPYING",
            PackageStatus::CopyFailed => "COPY_FAILED",
            PackageStatus::Deleted => "DELETED",
            PackageStatus::DeleteFailed => "DELETE_FAILED",
            PackageStatus::Deleting => "DELETING",
            PackageStatus::Validating => "VALIDATING",
            PackageStatus::ValidationFailed => "VALIDATION_FAILED",
            PackageStatus::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "AVAILABLE",
            "COPYING",
            "COPY_FAILED",
            "DELETED",
            "DELETE_FAILED",
            "DELETING",
            "VALIDATING",
            "VALIDATION_FAILED",
        ]
    }
}
impl AsRef<str> for PackageStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum PackageType {
    #[allow(missing_docs)] // documentation missing in model
    TxtDictionary,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for PackageType {
    fn from(s: &str) -> Self {
        match s {
            "TXT-DICTIONARY" => PackageType::TxtDictionary,
            other => PackageType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for PackageType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(PackageType::from(s))
    }
}
impl PackageType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            PackageType::TxtDictionary => "TXT-DICTIONARY",
            PackageType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["TXT-DICTIONARY"]
    }
}
impl AsRef<str> for PackageType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The Amazon S3 location for importing the package specified as <code>S3BucketName</code> and <code>S3Key</code> </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PackageSource {
    /// <p>The name of the Amazon S3 bucket containing the package.</p>
    pub s3_bucket_name: std::option::Option<std::string::String>,
    /// <p>Key (file name) of the package.</p>
    pub s3_key: std::option::Option<std::string::String>,
}
impl PackageSource {
    /// <p>The name of the Amazon S3 bucket containing the package.</p>
    pub fn s3_bucket_name(&self) -> std::option::Option<&str> {
        self.s3_bucket_name.as_deref()
    }
    /// <p>Key (file name) of the package.</p>
    pub fn s3_key(&self) -> std::option::Option<&str> {
        self.s3_key.as_deref()
    }
}
impl std::fmt::Debug for PackageSource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PackageSource");
        formatter.field("s3_bucket_name", &self.s3_bucket_name);
        formatter.field("s3_key", &self.s3_key);
        formatter.finish()
    }
}
/// See [`PackageSource`](crate::model::PackageSource)
pub mod package_source {

    /// A builder for [`PackageSource`](crate::model::PackageSource)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) s3_bucket_name: std::option::Option<std::string::String>,
        pub(crate) s3_key: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the Amazon S3 bucket containing the package.</p>
        pub fn s3_bucket_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_bucket_name = Some(input.into());
            self
        }
        /// <p>The name of the Amazon S3 bucket containing the package.</p>
        pub fn set_s3_bucket_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.s3_bucket_name = input;
            self
        }
        /// <p>Key (file name) of the package.</p>
        pub fn s3_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_key = Some(input.into());
            self
        }
        /// <p>Key (file name) of the package.</p>
        pub fn set_s3_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.s3_key = input;
            self
        }
        /// Consumes the builder and constructs a [`PackageSource`](crate::model::PackageSource)
        pub fn build(self) -> crate::model::PackageSource {
            crate::model::PackageSource {
                s3_bucket_name: self.s3_bucket_name,
                s3_key: self.s3_key,
            }
        }
    }
}
impl PackageSource {
    /// Creates a new builder-style object to manufacture [`PackageSource`](crate::model::PackageSource)
    pub fn builder() -> crate::model::package_source::Builder {
        crate::model::package_source::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DryRunResults {
    /// <p> Specifies the way in which Amazon OpenSearch Service applies the update. Possible responses are <code>Blue/Green</code> (the update requires a blue/green deployment), <code>DynamicUpdate</code> (no blue/green required), <code>Undetermined</code> (the domain is undergoing an update and can't predict the deployment type; try again after the update is complete), and <code>None</code> (the request doesn't include any configuration changes). </p>
    pub deployment_type: std::option::Option<std::string::String>,
    /// <p>Contains an optional message associated with the DryRunResults.</p>
    pub message: std::option::Option<std::string::String>,
}
impl DryRunResults {
    /// <p> Specifies the way in which Amazon OpenSearch Service applies the update. Possible responses are <code>Blue/Green</code> (the update requires a blue/green deployment), <code>DynamicUpdate</code> (no blue/green required), <code>Undetermined</code> (the domain is undergoing an update and can't predict the deployment type; try again after the update is complete), and <code>None</code> (the request doesn't include any configuration changes). </p>
    pub fn deployment_type(&self) -> std::option::Option<&str> {
        self.deployment_type.as_deref()
    }
    /// <p>Contains an optional message associated with the DryRunResults.</p>
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Debug for DryRunResults {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DryRunResults");
        formatter.field("deployment_type", &self.deployment_type);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
/// See [`DryRunResults`](crate::model::DryRunResults)
pub mod dry_run_results {

    /// A builder for [`DryRunResults`](crate::model::DryRunResults)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) deployment_type: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> Specifies the way in which Amazon OpenSearch Service applies the update. Possible responses are <code>Blue/Green</code> (the update requires a blue/green deployment), <code>DynamicUpdate</code> (no blue/green required), <code>Undetermined</code> (the domain is undergoing an update and can't predict the deployment type; try again after the update is complete), and <code>None</code> (the request doesn't include any configuration changes). </p>
        pub fn deployment_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.deployment_type = Some(input.into());
            self
        }
        /// <p> Specifies the way in which Amazon OpenSearch Service applies the update. Possible responses are <code>Blue/Green</code> (the update requires a blue/green deployment), <code>DynamicUpdate</code> (no blue/green required), <code>Undetermined</code> (the domain is undergoing an update and can't predict the deployment type; try again after the update is complete), and <code>None</code> (the request doesn't include any configuration changes). </p>
        pub fn set_deployment_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.deployment_type = input;
            self
        }
        /// <p>Contains an optional message associated with the DryRunResults.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Contains an optional message associated with the DryRunResults.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DryRunResults`](crate::model::DryRunResults)
        pub fn build(self) -> crate::model::DryRunResults {
            crate::model::DryRunResults {
                deployment_type: self.deployment_type,
                message: self.message,
            }
        }
    }
}
impl DryRunResults {
    /// Creates a new builder-style object to manufacture [`DryRunResults`](crate::model::DryRunResults)
    pub fn builder() -> crate::model::dry_run_results::Builder {
        crate::model::dry_run_results::Builder::default()
    }
}

/// <p>The configuration of a domain.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DomainConfig {
    /// <p>String of format Elasticsearch_X.Y or OpenSearch_X.Y to specify the engine version for the OpenSearch or Elasticsearch domain.</p>
    pub engine_version: std::option::Option<crate::model::VersionStatus>,
    /// <p>The <code>ClusterConfig</code> for the domain. </p>
    pub cluster_config: std::option::Option<crate::model::ClusterConfigStatus>,
    /// <p>The <code>EBSOptions</code> for the domain. </p>
    pub ebs_options: std::option::Option<crate::model::EbsOptionsStatus>,
    /// <p>IAM access policy as a JSON-formatted string.</p>
    pub access_policies: std::option::Option<crate::model::AccessPoliciesStatus>,
    /// <p>The <code>SnapshotOptions</code> for the domain. </p>
    pub snapshot_options: std::option::Option<crate::model::SnapshotOptionsStatus>,
    /// <p>The <code>VPCOptions</code> for the specified domain. For more information, see <a href="http://docs.aws.amazon.com/opensearch-service/latest/developerguide/vpc.html" target="_blank"> Launching your Amazon OpenSearch Service domains using a VPC</a>. </p>
    pub vpc_options: std::option::Option<crate::model::VpcDerivedInfoStatus>,
    /// <p>The <code>CognitoOptions</code> for the specified domain. For more information, see <a href="http://docs.aws.amazon.com/opensearch-service/latest/developerguide/cognito-auth.html" target="_blank">Configuring Amazon Cognito authentication for OpenSearch Dashboards</a>. </p>
    pub cognito_options: std::option::Option<crate::model::CognitoOptionsStatus>,
    /// <p>The <code>EncryptionAtRestOptions</code> for the domain. </p>
    pub encryption_at_rest_options:
        std::option::Option<crate::model::EncryptionAtRestOptionsStatus>,
    /// <p>The <code>NodeToNodeEncryptionOptions</code> for the domain. </p>
    pub node_to_node_encryption_options:
        std::option::Option<crate::model::NodeToNodeEncryptionOptionsStatus>,
    /// <p>The <code>AdvancedOptions</code> for the domain. See <a href="http://docs.aws.amazon.com/opensearch-service/latest/developerguide/createupdatedomains.html#createdomain-configure-advanced-options" target="_blank">Advanced options </a> for more information. </p>
    pub advanced_options: std::option::Option<crate::model::AdvancedOptionsStatus>,
    /// <p>Log publishing options for the given domain.</p>
    pub log_publishing_options: std::option::Option<crate::model::LogPublishingOptionsStatus>,
    /// <p>The <code>DomainEndpointOptions</code> for the domain. </p>
    pub domain_endpoint_options: std::option::Option<crate::model::DomainEndpointOptionsStatus>,
    /// <p>Specifies <code>AdvancedSecurityOptions</code> for the domain. </p>
    pub advanced_security_options: std::option::Option<crate::model::AdvancedSecurityOptionsStatus>,
    /// <p>Specifies <code>AutoTuneOptions</code> for the domain. </p>
    pub auto_tune_options: std::option::Option<crate::model::AutoTuneOptionsStatus>,
    /// <p>Specifies change details of the domain configuration change.</p>
    pub change_progress_details: std::option::Option<crate::model::ChangeProgressDetails>,
}
impl DomainConfig {
    /// <p>String of format Elasticsearch_X.Y or OpenSearch_X.Y to specify the engine version for the OpenSearch or Elasticsearch domain.</p>
    pub fn engine_version(&self) -> std::option::Option<&crate::model::VersionStatus> {
        self.engine_version.as_ref()
    }
    /// <p>The <code>ClusterConfig</code> for the domain. </p>
    pub fn cluster_config(&self) -> std::option::Option<&crate::model::ClusterConfigStatus> {
        self.cluster_config.as_ref()
    }
    /// <p>The <code>EBSOptions</code> for the domain. </p>
    pub fn ebs_options(&self) -> std::option::Option<&crate::model::EbsOptionsStatus> {
        self.ebs_options.as_ref()
    }
    /// <p>IAM access policy as a JSON-formatted string.</p>
    pub fn access_policies(&self) -> std::option::Option<&crate::model::AccessPoliciesStatus> {
        self.access_policies.as_ref()
    }
    /// <p>The <code>SnapshotOptions</code> for the domain. </p>
    pub fn snapshot_options(&self) -> std::option::Option<&crate::model::SnapshotOptionsStatus> {
        self.snapshot_options.as_ref()
    }
    /// <p>The <code>VPCOptions</code> for the specified domain. For more information, see <a href="http://docs.aws.amazon.com/opensearch-service/latest/developerguide/vpc.html" target="_blank"> Launching your Amazon OpenSearch Service domains using a VPC</a>. </p>
    pub fn vpc_options(&self) -> std::option::Option<&crate::model::VpcDerivedInfoStatus> {
        self.vpc_options.as_ref()
    }
    /// <p>The <code>CognitoOptions</code> for the specified domain. For more information, see <a href="http://docs.aws.amazon.com/opensearch-service/latest/developerguide/cognito-auth.html" target="_blank">Configuring Amazon Cognito authentication for OpenSearch Dashboards</a>. </p>
    pub fn cognito_options(&self) -> std::option::Option<&crate::model::CognitoOptionsStatus> {
        self.cognito_options.as_ref()
    }
    /// <p>The <code>EncryptionAtRestOptions</code> for the domain. </p>
    pub fn encryption_at_rest_options(
        &self,
    ) -> std::option::Option<&crate::model::EncryptionAtRestOptionsStatus> {
        self.encryption_at_rest_options.as_ref()
    }
    /// <p>The <code>NodeToNodeEncryptionOptions</code> for the domain. </p>
    pub fn node_to_node_encryption_options(
        &self,
    ) -> std::option::Option<&crate::model::NodeToNodeEncryptionOptionsStatus> {
        self.node_to_node_encryption_options.as_ref()
    }
    /// <p>The <code>AdvancedOptions</code> for the domain. See <a href="http://docs.aws.amazon.com/opensearch-service/latest/developerguide/createupdatedomains.html#createdomain-configure-advanced-options" target="_blank">Advanced options </a> for more information. </p>
    pub fn advanced_options(&self) -> std::option::Option<&crate::model::AdvancedOptionsStatus> {
        self.advanced_options.as_ref()
    }
    /// <p>Log publishing options for the given domain.</p>
    pub fn log_publishing_options(
        &self,
    ) -> std::option::Option<&crate::model::LogPublishingOptionsStatus> {
        self.log_publishing_options.as_ref()
    }
    /// <p>The <code>DomainEndpointOptions</code> for the domain. </p>
    pub fn domain_endpoint_options(
        &self,
    ) -> std::option::Option<&crate::model::DomainEndpointOptionsStatus> {
        self.domain_endpoint_options.as_ref()
    }
    /// <p>Specifies <code>AdvancedSecurityOptions</code> for the domain. </p>
    pub fn advanced_security_options(
        &self,
    ) -> std::option::Option<&crate::model::AdvancedSecurityOptionsStatus> {
        self.advanced_security_options.as_ref()
    }
    /// <p>Specifies <code>AutoTuneOptions</code> for the domain. </p>
    pub fn auto_tune_options(&self) -> std::option::Option<&crate::model::AutoTuneOptionsStatus> {
        self.auto_tune_options.as_ref()
    }
    /// <p>Specifies change details of the domain configuration change.</p>
    pub fn change_progress_details(
        &self,
    ) -> std::option::Option<&crate::model::ChangeProgressDetails> {
        self.change_progress_details.as_ref()
    }
}
impl std::fmt::Debug for DomainConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DomainConfig");
        formatter.field("engine_version", &self.engine_version);
        formatter.field("cluster_config", &self.cluster_config);
        formatter.field("ebs_options", &self.ebs_options);
        formatter.field("access_policies", &self.access_policies);
        formatter.field("snapshot_options", &self.snapshot_options);
        formatter.field("vpc_options", &self.vpc_options);
        formatter.field("cognito_options", &self.cognito_options);
        formatter.field(
            "encryption_at_rest_options",
            &self.encryption_at_rest_options,
        );
        formatter.field(
            "node_to_node_encryption_options",
            &self.node_to_node_encryption_options,
        );
        formatter.field("advanced_options", &self.advanced_options);
        formatter.field("log_publishing_options", &self.log_publishing_options);
        formatter.field("domain_endpoint_options", &self.domain_endpoint_options);
        formatter.field("advanced_security_options", &self.advanced_security_options);
        formatter.field("auto_tune_options", &self.auto_tune_options);
        formatter.field("change_progress_details", &self.change_progress_details);
        formatter.finish()
    }
}
/// See [`DomainConfig`](crate::model::DomainConfig)
pub mod domain_config {

    /// A builder for [`DomainConfig`](crate::model::DomainConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) engine_version: std::option::Option<crate::model::VersionStatus>,
        pub(crate) cluster_config: std::option::Option<crate::model::ClusterConfigStatus>,
        pub(crate) ebs_options: std::option::Option<crate::model::EbsOptionsStatus>,
        pub(crate) access_policies: std::option::Option<crate::model::AccessPoliciesStatus>,
        pub(crate) snapshot_options: std::option::Option<crate::model::SnapshotOptionsStatus>,
        pub(crate) vpc_options: std::option::Option<crate::model::VpcDerivedInfoStatus>,
        pub(crate) cognito_options: std::option::Option<crate::model::CognitoOptionsStatus>,
        pub(crate) encryption_at_rest_options:
            std::option::Option<crate::model::EncryptionAtRestOptionsStatus>,
        pub(crate) node_to_node_encryption_options:
            std::option::Option<crate::model::NodeToNodeEncryptionOptionsStatus>,
        pub(crate) advanced_options: std::option::Option<crate::model::AdvancedOptionsStatus>,
        pub(crate) log_publishing_options:
            std::option::Option<crate::model::LogPublishingOptionsStatus>,
        pub(crate) domain_endpoint_options:
            std::option::Option<crate::model::DomainEndpointOptionsStatus>,
        pub(crate) advanced_security_options:
            std::option::Option<crate::model::AdvancedSecurityOptionsStatus>,
        pub(crate) auto_tune_options: std::option::Option<crate::model::AutoTuneOptionsStatus>,
        pub(crate) change_progress_details:
            std::option::Option<crate::model::ChangeProgressDetails>,
    }
    impl Builder {
        /// <p>String of format Elasticsearch_X.Y or OpenSearch_X.Y to specify the engine version for the OpenSearch or Elasticsearch domain.</p>
        pub fn engine_version(mut self, input: crate::model::VersionStatus) -> Self {
            self.engine_version = Some(input);
            self
        }
        /// <p>String of format Elasticsearch_X.Y or OpenSearch_X.Y to specify the engine version for the OpenSearch or Elasticsearch domain.</p>
        pub fn set_engine_version(
            mut self,
            input: std::option::Option<crate::model::VersionStatus>,
        ) -> Self {
            self.engine_version = input;
            self
        }
        /// <p>The <code>ClusterConfig</code> for the domain. </p>
        pub fn cluster_config(mut self, input: crate::model::ClusterConfigStatus) -> Self {
            self.cluster_config = Some(input);
            self
        }
        /// <p>The <code>ClusterConfig</code> for the domain. </p>
        pub fn set_cluster_config(
            mut self,
            input: std::option::Option<crate::model::ClusterConfigStatus>,
        ) -> Self {
            self.cluster_config = input;
            self
        }
        /// <p>The <code>EBSOptions</code> for the domain. </p>
        pub fn ebs_options(mut self, input: crate::model::EbsOptionsStatus) -> Self {
            self.ebs_options = Some(input);
            self
        }
        /// <p>The <code>EBSOptions</code> for the domain. </p>
        pub fn set_ebs_options(
            mut self,
            input: std::option::Option<crate::model::EbsOptionsStatus>,
        ) -> Self {
            self.ebs_options = input;
            self
        }
        /// <p>IAM access policy as a JSON-formatted string.</p>
        pub fn access_policies(mut self, input: crate::model::AccessPoliciesStatus) -> Self {
            self.access_policies = Some(input);
            self
        }
        /// <p>IAM access policy as a JSON-formatted string.</p>
        pub fn set_access_policies(
            mut self,
            input: std::option::Option<crate::model::AccessPoliciesStatus>,
        ) -> Self {
            self.access_policies = input;
            self
        }
        /// <p>The <code>SnapshotOptions</code> for the domain. </p>
        pub fn snapshot_options(mut self, input: crate::model::SnapshotOptionsStatus) -> Self {
            self.snapshot_options = Some(input);
            self
        }
        /// <p>The <code>SnapshotOptions</code> for the domain. </p>
        pub fn set_snapshot_options(
            mut self,
            input: std::option::Option<crate::model::SnapshotOptionsStatus>,
        ) -> Self {
            self.snapshot_options = input;
            self
        }
        /// <p>The <code>VPCOptions</code> for the specified domain. For more information, see <a href="http://docs.aws.amazon.com/opensearch-service/latest/developerguide/vpc.html" target="_blank"> Launching your Amazon OpenSearch Service domains using a VPC</a>. </p>
        pub fn vpc_options(mut self, input: crate::model::VpcDerivedInfoStatus) -> Self {
            self.vpc_options = Some(input);
            self
        }
        /// <p>The <code>VPCOptions</code> for the specified domain. For more information, see <a href="http://docs.aws.amazon.com/opensearch-service/latest/developerguide/vpc.html" target="_blank"> Launching your Amazon OpenSearch Service domains using a VPC</a>. </p>
        pub fn set_vpc_options(
            mut self,
            input: std::option::Option<crate::model::VpcDerivedInfoStatus>,
        ) -> Self {
            self.vpc_options = input;
            self
        }
        /// <p>The <code>CognitoOptions</code> for the specified domain. For more information, see <a href="http://docs.aws.amazon.com/opensearch-service/latest/developerguide/cognito-auth.html" target="_blank">Configuring Amazon Cognito authentication for OpenSearch Dashboards</a>. </p>
        pub fn cognito_options(mut self, input: crate::model::CognitoOptionsStatus) -> Self {
            self.cognito_options = Some(input);
            self
        }
        /// <p>The <code>CognitoOptions</code> for the specified domain. For more information, see <a href="http://docs.aws.amazon.com/opensearch-service/latest/developerguide/cognito-auth.html" target="_blank">Configuring Amazon Cognito authentication for OpenSearch Dashboards</a>. </p>
        pub fn set_cognito_options(
            mut self,
            input: std::option::Option<crate::model::CognitoOptionsStatus>,
        ) -> Self {
            self.cognito_options = input;
            self
        }
        /// <p>The <code>EncryptionAtRestOptions</code> for the domain. </p>
        pub fn encryption_at_rest_options(
            mut self,
            input: crate::model::EncryptionAtRestOptionsStatus,
        ) -> Self {
            self.encryption_at_rest_options = Some(input);
            self
        }
        /// <p>The <code>EncryptionAtRestOptions</code> for the domain. </p>
        pub fn set_encryption_at_rest_options(
            mut self,
            input: std::option::Option<crate::model::EncryptionAtRestOptionsStatus>,
        ) -> Self {
            self.encryption_at_rest_options = input;
            self
        }
        /// <p>The <code>NodeToNodeEncryptionOptions</code> for the domain. </p>
        pub fn node_to_node_encryption_options(
            mut self,
            input: crate::model::NodeToNodeEncryptionOptionsStatus,
        ) -> Self {
            self.node_to_node_encryption_options = Some(input);
            self
        }
        /// <p>The <code>NodeToNodeEncryptionOptions</code> for the domain. </p>
        pub fn set_node_to_node_encryption_options(
            mut self,
            input: std::option::Option<crate::model::NodeToNodeEncryptionOptionsStatus>,
        ) -> Self {
            self.node_to_node_encryption_options = input;
            self
        }
        /// <p>The <code>AdvancedOptions</code> for the domain. See <a href="http://docs.aws.amazon.com/opensearch-service/latest/developerguide/createupdatedomains.html#createdomain-configure-advanced-options" target="_blank">Advanced options </a> for more information. </p>
        pub fn advanced_options(mut self, input: crate::model::AdvancedOptionsStatus) -> Self {
            self.advanced_options = Some(input);
            self
        }
        /// <p>The <code>AdvancedOptions</code> for the domain. See <a href="http://docs.aws.amazon.com/opensearch-service/latest/developerguide/createupdatedomains.html#createdomain-configure-advanced-options" target="_blank">Advanced options </a> for more information. </p>
        pub fn set_advanced_options(
            mut self,
            input: std::option::Option<crate::model::AdvancedOptionsStatus>,
        ) -> Self {
            self.advanced_options = input;
            self
        }
        /// <p>Log publishing options for the given domain.</p>
        pub fn log_publishing_options(
            mut self,
            input: crate::model::LogPublishingOptionsStatus,
        ) -> Self {
            self.log_publishing_options = Some(input);
            self
        }
        /// <p>Log publishing options for the given domain.</p>
        pub fn set_log_publishing_options(
            mut self,
            input: std::option::Option<crate::model::LogPublishingOptionsStatus>,
        ) -> Self {
            self.log_publishing_options = input;
            self
        }
        /// <p>The <code>DomainEndpointOptions</code> for the domain. </p>
        pub fn domain_endpoint_options(
            mut self,
            input: crate::model::DomainEndpointOptionsStatus,
        ) -> Self {
            self.domain_endpoint_options = Some(input);
            self
        }
        /// <p>The <code>DomainEndpointOptions</code> for the domain. </p>
        pub fn set_domain_endpoint_options(
            mut self,
            input: std::option::Option<crate::model::DomainEndpointOptionsStatus>,
        ) -> Self {
            self.domain_endpoint_options = input;
            self
        }
        /// <p>Specifies <code>AdvancedSecurityOptions</code> for the domain. </p>
        pub fn advanced_security_options(
            mut self,
            input: crate::model::AdvancedSecurityOptionsStatus,
        ) -> Self {
            self.advanced_security_options = Some(input);
            self
        }
        /// <p>Specifies <code>AdvancedSecurityOptions</code> for the domain. </p>
        pub fn set_advanced_security_options(
            mut self,
            input: std::option::Option<crate::model::AdvancedSecurityOptionsStatus>,
        ) -> Self {
            self.advanced_security_options = input;
            self
        }
        /// <p>Specifies <code>AutoTuneOptions</code> for the domain. </p>
        pub fn auto_tune_options(mut self, input: crate::model::AutoTuneOptionsStatus) -> Self {
            self.auto_tune_options = Some(input);
            self
        }
        /// <p>Specifies <code>AutoTuneOptions</code> for the domain. </p>
        pub fn set_auto_tune_options(
            mut self,
            input: std::option::Option<crate::model::AutoTuneOptionsStatus>,
        ) -> Self {
            self.auto_tune_options = input;
            self
        }
        /// <p>Specifies change details of the domain configuration change.</p>
        pub fn change_progress_details(
            mut self,
            input: crate::model::ChangeProgressDetails,
        ) -> Self {
            self.change_progress_details = Some(input);
            self
        }
        /// <p>Specifies change details of the domain configuration change.</p>
        pub fn set_change_progress_details(
            mut self,
            input: std::option::Option<crate::model::ChangeProgressDetails>,
        ) -> Self {
            self.change_progress_details = input;
            self
        }
        /// Consumes the builder and constructs a [`DomainConfig`](crate::model::DomainConfig)
        pub fn build(self) -> crate::model::DomainConfig {
            crate::model::DomainConfig {
                engine_version: self.engine_version,
                cluster_config: self.cluster_config,
                ebs_options: self.ebs_options,
                access_policies: self.access_policies,
                snapshot_options: self.snapshot_options,
                vpc_options: self.vpc_options,
                cognito_options: self.cognito_options,
                encryption_at_rest_options: self.encryption_at_rest_options,
                node_to_node_encryption_options: self.node_to_node_encryption_options,
                advanced_options: self.advanced_options,
                log_publishing_options: self.log_publishing_options,
                domain_endpoint_options: self.domain_endpoint_options,
                advanced_security_options: self.advanced_security_options,
                auto_tune_options: self.auto_tune_options,
                change_progress_details: self.change_progress_details,
            }
        }
    }
}
impl DomainConfig {
    /// Creates a new builder-style object to manufacture [`DomainConfig`](crate::model::DomainConfig)
    pub fn builder() -> crate::model::domain_config::Builder {
        crate::model::domain_config::Builder::default()
    }
}

/// <p>The Auto-Tune status for the domain.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AutoTuneOptionsStatus {
    /// <p>Specifies Auto-Tune options for the domain.</p>
    pub options: std::option::Option<crate::model::AutoTuneOptions>,
    /// <p>The status of the Auto-Tune options for the domain.</p>
    pub status: std::option::Option<crate::model::AutoTuneStatus>,
}
impl AutoTuneOptionsStatus {
    /// <p>Specifies Auto-Tune options for the domain.</p>
    pub fn options(&self) -> std::option::Option<&crate::model::AutoTuneOptions> {
        self.options.as_ref()
    }
    /// <p>The status of the Auto-Tune options for the domain.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::AutoTuneStatus> {
        self.status.as_ref()
    }
}
impl std::fmt::Debug for AutoTuneOptionsStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AutoTuneOptionsStatus");
        formatter.field("options", &self.options);
        formatter.field("status", &self.status);
        formatter.finish()
    }
}
/// See [`AutoTuneOptionsStatus`](crate::model::AutoTuneOptionsStatus)
pub mod auto_tune_options_status {

    /// A builder for [`AutoTuneOptionsStatus`](crate::model::AutoTuneOptionsStatus)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) options: std::option::Option<crate::model::AutoTuneOptions>,
        pub(crate) status: std::option::Option<crate::model::AutoTuneStatus>,
    }
    impl Builder {
        /// <p>Specifies Auto-Tune options for the domain.</p>
        pub fn options(mut self, input: crate::model::AutoTuneOptions) -> Self {
            self.options = Some(input);
            self
        }
        /// <p>Specifies Auto-Tune options for the domain.</p>
        pub fn set_options(
            mut self,
            input: std::option::Option<crate::model::AutoTuneOptions>,
        ) -> Self {
            self.options = input;
            self
        }
        /// <p>The status of the Auto-Tune options for the domain.</p>
        pub fn status(mut self, input: crate::model::AutoTuneStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the Auto-Tune options for the domain.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::AutoTuneStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// Consumes the builder and constructs a [`AutoTuneOptionsStatus`](crate::model::AutoTuneOptionsStatus)
        pub fn build(self) -> crate::model::AutoTuneOptionsStatus {
            crate::model::AutoTuneOptionsStatus {
                options: self.options,
                status: self.status,
            }
        }
    }
}
impl AutoTuneOptionsStatus {
    /// Creates a new builder-style object to manufacture [`AutoTuneOptionsStatus`](crate::model::AutoTuneOptionsStatus)
    pub fn builder() -> crate::model::auto_tune_options_status::Builder {
        crate::model::auto_tune_options_status::Builder::default()
    }
}

/// <p>Provides the current Auto-Tune status for the domain.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AutoTuneStatus {
    /// <p>The timestamp of the Auto-Tune options creation date.</p>
    pub creation_date: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The timestamp of when the Auto-Tune options were last updated.</p>
    pub update_date: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The latest version of the Auto-Tune options.</p>
    pub update_version: i32,
    /// <p>The <code>AutoTuneState</code> for the domain. </p>
    pub state: std::option::Option<crate::model::AutoTuneState>,
    /// <p>The error message while enabling or disabling Auto-Tune.</p>
    pub error_message: std::option::Option<std::string::String>,
    /// <p>Indicates whether the domain is being deleted.</p>
    pub pending_deletion: std::option::Option<bool>,
}
impl AutoTuneStatus {
    /// <p>The timestamp of the Auto-Tune options creation date.</p>
    pub fn creation_date(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_date.as_ref()
    }
    /// <p>The timestamp of when the Auto-Tune options were last updated.</p>
    pub fn update_date(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.update_date.as_ref()
    }
    /// <p>The latest version of the Auto-Tune options.</p>
    pub fn update_version(&self) -> i32 {
        self.update_version
    }
    /// <p>The <code>AutoTuneState</code> for the domain. </p>
    pub fn state(&self) -> std::option::Option<&crate::model::AutoTuneState> {
        self.state.as_ref()
    }
    /// <p>The error message while enabling or disabling Auto-Tune.</p>
    pub fn error_message(&self) -> std::option::Option<&str> {
        self.error_message.as_deref()
    }
    /// <p>Indicates whether the domain is being deleted.</p>
    pub fn pending_deletion(&self) -> std::option::Option<bool> {
        self.pending_deletion
    }
}
impl std::fmt::Debug for AutoTuneStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AutoTuneStatus");
        formatter.field("creation_date", &self.creation_date);
        formatter.field("update_date", &self.update_date);
        formatter.field("update_version", &self.update_version);
        formatter.field("state", &self.state);
        formatter.field("error_message", &self.error_message);
        formatter.field("pending_deletion", &self.pending_deletion);
        formatter.finish()
    }
}
/// See [`AutoTuneStatus`](crate::model::AutoTuneStatus)
pub mod auto_tune_status {

    /// A builder for [`AutoTuneStatus`](crate::model::AutoTuneStatus)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) creation_date: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) update_date: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) update_version: std::option::Option<i32>,
        pub(crate) state: std::option::Option<crate::model::AutoTuneState>,
        pub(crate) error_message: std::option::Option<std::string::String>,
        pub(crate) pending_deletion: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The timestamp of the Auto-Tune options creation date.</p>
        pub fn creation_date(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_date = Some(input);
            self
        }
        /// <p>The timestamp of the Auto-Tune options creation date.</p>
        pub fn set_creation_date(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_date = input;
            self
        }
        /// <p>The timestamp of when the Auto-Tune options were last updated.</p>
        pub fn update_date(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.update_date = Some(input);
            self
        }
        /// <p>The timestamp of when the Auto-Tune options were last updated.</p>
        pub fn set_update_date(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.update_date = input;
            self
        }
        /// <p>The latest version of the Auto-Tune options.</p>
        pub fn update_version(mut self, input: i32) -> Self {
            self.update_version = Some(input);
            self
        }
        /// <p>The latest version of the Auto-Tune options.</p>
        pub fn set_update_version(mut self, input: std::option::Option<i32>) -> Self {
            self.update_version = input;
            self
        }
        /// <p>The <code>AutoTuneState</code> for the domain. </p>
        pub fn state(mut self, input: crate::model::AutoTuneState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The <code>AutoTuneState</code> for the domain. </p>
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::AutoTuneState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// <p>The error message while enabling or disabling Auto-Tune.</p>
        pub fn error_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_message = Some(input.into());
            self
        }
        /// <p>The error message while enabling or disabling Auto-Tune.</p>
        pub fn set_error_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.error_message = input;
            self
        }
        /// <p>Indicates whether the domain is being deleted.</p>
        pub fn pending_deletion(mut self, input: bool) -> Self {
            self.pending_deletion = Some(input);
            self
        }
        /// <p>Indicates whether the domain is being deleted.</p>
        pub fn set_pending_deletion(mut self, input: std::option::Option<bool>) -> Self {
            self.pending_deletion = input;
            self
        }
        /// Consumes the builder and constructs a [`AutoTuneStatus`](crate::model::AutoTuneStatus)
        pub fn build(self) -> crate::model::AutoTuneStatus {
            crate::model::AutoTuneStatus {
                creation_date: self.creation_date,
                update_date: self.update_date,
                update_version: self.update_version.unwrap_or_default(),
                state: self.state,
                error_message: self.error_message,
                pending_deletion: self.pending_deletion,
            }
        }
    }
}
impl AutoTuneStatus {
    /// Creates a new builder-style object to manufacture [`AutoTuneStatus`](crate::model::AutoTuneStatus)
    pub fn builder() -> crate::model::auto_tune_status::Builder {
        crate::model::auto_tune_status::Builder::default()
    }
}

/// <p>The Auto-Tune state for the domain. For valid states see <a href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/auto-tune.html" target="_blank">
/// Auto-Tune for Amazon OpenSearch Service</a>.
/// </p>
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AutoTuneState {
    #[allow(missing_docs)] // documentation missing in model
    Disabled,
    #[allow(missing_docs)] // documentation missing in model
    DisabledAndRollbackComplete,
    #[allow(missing_docs)] // documentation missing in model
    DisabledAndRollbackError,
    #[allow(missing_docs)] // documentation missing in model
    DisabledAndRollbackInProgress,
    #[allow(missing_docs)] // documentation missing in model
    DisabledAndRollbackScheduled,
    #[allow(missing_docs)] // documentation missing in model
    DisableInProgress,
    #[allow(missing_docs)] // documentation missing in model
    Enabled,
    #[allow(missing_docs)] // documentation missing in model
    EnableInProgress,
    #[allow(missing_docs)] // documentation missing in model
    Error,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for AutoTuneState {
    fn from(s: &str) -> Self {
        match s {
            "DISABLED" => AutoTuneState::Disabled,
            "DISABLED_AND_ROLLBACK_COMPLETE" => AutoTuneState::DisabledAndRollbackComplete,
            "DISABLED_AND_ROLLBACK_ERROR" => AutoTuneState::DisabledAndRollbackError,
            "DISABLED_AND_ROLLBACK_IN_PROGRESS" => AutoTuneState::DisabledAndRollbackInProgress,
            "DISABLED_AND_ROLLBACK_SCHEDULED" => AutoTuneState::DisabledAndRollbackScheduled,
            "DISABLE_IN_PROGRESS" => AutoTuneState::DisableInProgress,
            "ENABLED" => AutoTuneState::Enabled,
            "ENABLE_IN_PROGRESS" => AutoTuneState::EnableInProgress,
            "ERROR" => AutoTuneState::Error,
            other => AutoTuneState::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for AutoTuneState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AutoTuneState::from(s))
    }
}
impl AutoTuneState {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            AutoTuneState::Disabled => "DISABLED",
            AutoTuneState::DisabledAndRollbackComplete => "DISABLED_AND_ROLLBACK_COMPLETE",
            AutoTuneState::DisabledAndRollbackError => "DISABLED_AND_ROLLBACK_ERROR",
            AutoTuneState::DisabledAndRollbackInProgress => "DISABLED_AND_ROLLBACK_IN_PROGRESS",
            AutoTuneState::DisabledAndRollbackScheduled => "DISABLED_AND_ROLLBACK_SCHEDULED",
            AutoTuneState::DisableInProgress => "DISABLE_IN_PROGRESS",
            AutoTuneState::Enabled => "ENABLED",
            AutoTuneState::EnableInProgress => "ENABLE_IN_PROGRESS",
            AutoTuneState::Error => "ERROR",
            AutoTuneState::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "DISABLED",
            "DISABLED_AND_ROLLBACK_COMPLETE",
            "DISABLED_AND_ROLLBACK_ERROR",
            "DISABLED_AND_ROLLBACK_IN_PROGRESS",
            "DISABLED_AND_ROLLBACK_SCHEDULED",
            "DISABLE_IN_PROGRESS",
            "ENABLED",
            "ENABLE_IN_PROGRESS",
            "ERROR",
        ]
    }
}
impl AsRef<str> for AutoTuneState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The Auto-Tune options: the Auto-Tune desired state for the domain, rollback state when disabling Auto-Tune options and list of maintenance schedules. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AutoTuneOptions {
    /// <p>The Auto-Tune desired state. Valid values are ENABLED and DISABLED.</p>
    pub desired_state: std::option::Option<crate::model::AutoTuneDesiredState>,
    /// <p>The rollback state while disabling Auto-Tune for the domain. Valid values are NO_ROLLBACK and DEFAULT_ROLLBACK. </p>
    pub rollback_on_disable: std::option::Option<crate::model::RollbackOnDisable>,
    /// <p>A list of maintenance schedules. See <a href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/auto-tune.html" target="_blank"> Auto-Tune for Amazon OpenSearch Service </a> for more information. </p>
    pub maintenance_schedules:
        std::option::Option<std::vec::Vec<crate::model::AutoTuneMaintenanceSchedule>>,
}
impl AutoTuneOptions {
    /// <p>The Auto-Tune desired state. Valid values are ENABLED and DISABLED.</p>
    pub fn desired_state(&self) -> std::option::Option<&crate::model::AutoTuneDesiredState> {
        self.desired_state.as_ref()
    }
    /// <p>The rollback state while disabling Auto-Tune for the domain. Valid values are NO_ROLLBACK and DEFAULT_ROLLBACK. </p>
    pub fn rollback_on_disable(&self) -> std::option::Option<&crate::model::RollbackOnDisable> {
        self.rollback_on_disable.as_ref()
    }
    /// <p>A list of maintenance schedules. See <a href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/auto-tune.html" target="_blank"> Auto-Tune for Amazon OpenSearch Service </a> for more information. </p>
    pub fn maintenance_schedules(
        &self,
    ) -> std::option::Option<&[crate::model::AutoTuneMaintenanceSchedule]> {
        self.maintenance_schedules.as_deref()
    }
}
impl std::fmt::Debug for AutoTuneOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AutoTuneOptions");
        formatter.field("desired_state", &self.desired_state);
        formatter.field("rollback_on_disable", &self.rollback_on_disable);
        formatter.field("maintenance_schedules", &self.maintenance_schedules);
        formatter.finish()
    }
}
/// See [`AutoTuneOptions`](crate::model::AutoTuneOptions)
pub mod auto_tune_options {

    /// A builder for [`AutoTuneOptions`](crate::model::AutoTuneOptions)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) desired_state: std::option::Option<crate::model::AutoTuneDesiredState>,
        pub(crate) rollback_on_disable: std::option::Option<crate::model::RollbackOnDisable>,
        pub(crate) maintenance_schedules:
            std::option::Option<std::vec::Vec<crate::model::AutoTuneMaintenanceSchedule>>,
    }
    impl Builder {
        /// <p>The Auto-Tune desired state. Valid values are ENABLED and DISABLED.</p>
        pub fn desired_state(mut self, input: crate::model::AutoTuneDesiredState) -> Self {
            self.desired_state = Some(input);
            self
        }
        /// <p>The Auto-Tune desired state. Valid values are ENABLED and DISABLED.</p>
        pub fn set_desired_state(
            mut self,
            input: std::option::Option<crate::model::AutoTuneDesiredState>,
        ) -> Self {
            self.desired_state = input;
            self
        }
        /// <p>The rollback state while disabling Auto-Tune for the domain. Valid values are NO_ROLLBACK and DEFAULT_ROLLBACK. </p>
        pub fn rollback_on_disable(mut self, input: crate::model::RollbackOnDisable) -> Self {
            self.rollback_on_disable = Some(input);
            self
        }
        /// <p>The rollback state while disabling Auto-Tune for the domain. Valid values are NO_ROLLBACK and DEFAULT_ROLLBACK. </p>
        pub fn set_rollback_on_disable(
            mut self,
            input: std::option::Option<crate::model::RollbackOnDisable>,
        ) -> Self {
            self.rollback_on_disable = input;
            self
        }
        /// Appends an item to `maintenance_schedules`.
        ///
        /// To override the contents of this collection use [`set_maintenance_schedules`](Self::set_maintenance_schedules).
        ///
        /// <p>A list of maintenance schedules. See <a href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/auto-tune.html" target="_blank"> Auto-Tune for Amazon OpenSearch Service </a> for more information. </p>
        pub fn maintenance_schedules(
            mut self,
            input: crate::model::AutoTuneMaintenanceSchedule,
        ) -> Self {
            let mut v = self.maintenance_schedules.unwrap_or_default();
            v.push(input);
            self.maintenance_schedules = Some(v);
            self
        }
        /// <p>A list of maintenance schedules. See <a href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/auto-tune.html" target="_blank"> Auto-Tune for Amazon OpenSearch Service </a> for more information. </p>
        pub fn set_maintenance_schedules(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AutoTuneMaintenanceSchedule>>,
        ) -> Self {
            self.maintenance_schedules = input;
            self
        }
        /// Consumes the builder and constructs a [`AutoTuneOptions`](crate::model::AutoTuneOptions)
        pub fn build(self) -> crate::model::AutoTuneOptions {
            crate::model::AutoTuneOptions {
                desired_state: self.desired_state,
                rollback_on_disable: self.rollback_on_disable,
                maintenance_schedules: self.maintenance_schedules,
            }
        }
    }
}
impl AutoTuneOptions {
    /// Creates a new builder-style object to manufacture [`AutoTuneOptions`](crate::model::AutoTuneOptions)
    pub fn builder() -> crate::model::auto_tune_options::Builder {
        crate::model::auto_tune_options::Builder::default()
    }
}

/// <p>Specifies the Auto-Tune maintenance schedule. See <a href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/auto-tune.html" target="_blank"> Auto-Tune for Amazon OpenSearch Service </a> for more information. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AutoTuneMaintenanceSchedule {
    /// <p>The timestamp at which the Auto-Tune maintenance schedule starts.</p>
    pub start_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Specifies maintenance schedule duration: duration value and duration unit. See <a href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/auto-tune.html" target="_blank"> Auto-Tune for Amazon OpenSearch Service </a> for more information. </p>
    pub duration: std::option::Option<crate::model::Duration>,
    /// <p>A cron expression for a recurring maintenance schedule. See <a href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/auto-tune.html" target="_blank"> Auto-Tune for Amazon OpenSearch Service </a> for more information. </p>
    pub cron_expression_for_recurrence: std::option::Option<std::string::String>,
}
impl AutoTuneMaintenanceSchedule {
    /// <p>The timestamp at which the Auto-Tune maintenance schedule starts.</p>
    pub fn start_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.start_at.as_ref()
    }
    /// <p>Specifies maintenance schedule duration: duration value and duration unit. See <a href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/auto-tune.html" target="_blank"> Auto-Tune for Amazon OpenSearch Service </a> for more information. </p>
    pub fn duration(&self) -> std::option::Option<&crate::model::Duration> {
        self.duration.as_ref()
    }
    /// <p>A cron expression for a recurring maintenance schedule. See <a href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/auto-tune.html" target="_blank"> Auto-Tune for Amazon OpenSearch Service </a> for more information. </p>
    pub fn cron_expression_for_recurrence(&self) -> std::option::Option<&str> {
        self.cron_expression_for_recurrence.as_deref()
    }
}
impl std::fmt::Debug for AutoTuneMaintenanceSchedule {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AutoTuneMaintenanceSchedule");
        formatter.field("start_at", &self.start_at);
        formatter.field("duration", &self.duration);
        formatter.field(
            "cron_expression_for_recurrence",
            &self.cron_expression_for_recurrence,
        );
        formatter.finish()
    }
}
/// See [`AutoTuneMaintenanceSchedule`](crate::model::AutoTuneMaintenanceSchedule)
pub mod auto_tune_maintenance_schedule {

    /// A builder for [`AutoTuneMaintenanceSchedule`](crate::model::AutoTuneMaintenanceSchedule)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) start_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) duration: std::option::Option<crate::model::Duration>,
        pub(crate) cron_expression_for_recurrence: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The timestamp at which the Auto-Tune maintenance schedule starts.</p>
        pub fn start_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.start_at = Some(input);
            self
        }
        /// <p>The timestamp at which the Auto-Tune maintenance schedule starts.</p>
        pub fn set_start_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.start_at = input;
            self
        }
        /// <p>Specifies maintenance schedule duration: duration value and duration unit. See <a href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/auto-tune.html" target="_blank"> Auto-Tune for Amazon OpenSearch Service </a> for more information. </p>
        pub fn duration(mut self, input: crate::model::Duration) -> Self {
            self.duration = Some(input);
            self
        }
        /// <p>Specifies maintenance schedule duration: duration value and duration unit. See <a href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/auto-tune.html" target="_blank"> Auto-Tune for Amazon OpenSearch Service </a> for more information. </p>
        pub fn set_duration(mut self, input: std::option::Option<crate::model::Duration>) -> Self {
            self.duration = input;
            self
        }
        /// <p>A cron expression for a recurring maintenance schedule. See <a href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/auto-tune.html" target="_blank"> Auto-Tune for Amazon OpenSearch Service </a> for more information. </p>
        pub fn cron_expression_for_recurrence(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.cron_expression_for_recurrence = Some(input.into());
            self
        }
        /// <p>A cron expression for a recurring maintenance schedule. See <a href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/auto-tune.html" target="_blank"> Auto-Tune for Amazon OpenSearch Service </a> for more information. </p>
        pub fn set_cron_expression_for_recurrence(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.cron_expression_for_recurrence = input;
            self
        }
        /// Consumes the builder and constructs a [`AutoTuneMaintenanceSchedule`](crate::model::AutoTuneMaintenanceSchedule)
        pub fn build(self) -> crate::model::AutoTuneMaintenanceSchedule {
            crate::model::AutoTuneMaintenanceSchedule {
                start_at: self.start_at,
                duration: self.duration,
                cron_expression_for_recurrence: self.cron_expression_for_recurrence,
            }
        }
    }
}
impl AutoTuneMaintenanceSchedule {
    /// Creates a new builder-style object to manufacture [`AutoTuneMaintenanceSchedule`](crate::model::AutoTuneMaintenanceSchedule)
    pub fn builder() -> crate::model::auto_tune_maintenance_schedule::Builder {
        crate::model::auto_tune_maintenance_schedule::Builder::default()
    }
}

/// <p>The maintenance schedule duration: duration value and duration unit. See <a href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/auto-tune.html" target="_blank"> Auto-Tune for Amazon OpenSearch Service </a> for more information. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Duration {
    /// <p>Integer to specify the value of a maintenance schedule duration. See <a href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/auto-tune.html" target="_blank"> Auto-Tune for Amazon OpenSearch Service </a> for more information. </p>
    pub value: i64,
    /// <p>The unit of a maintenance schedule duration. Valid value is HOURS. See <a href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/auto-tune.html" target="_blank"> Auto-Tune for Amazon OpenSearch Service </a> for more information. </p>
    pub unit: std::option::Option<crate::model::TimeUnit>,
}
impl Duration {
    /// <p>Integer to specify the value of a maintenance schedule duration. See <a href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/auto-tune.html" target="_blank"> Auto-Tune for Amazon OpenSearch Service </a> for more information. </p>
    pub fn value(&self) -> i64 {
        self.value
    }
    /// <p>The unit of a maintenance schedule duration. Valid value is HOURS. See <a href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/auto-tune.html" target="_blank"> Auto-Tune for Amazon OpenSearch Service </a> for more information. </p>
    pub fn unit(&self) -> std::option::Option<&crate::model::TimeUnit> {
        self.unit.as_ref()
    }
}
impl std::fmt::Debug for Duration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Duration");
        formatter.field("value", &self.value);
        formatter.field("unit", &self.unit);
        formatter.finish()
    }
}
/// See [`Duration`](crate::model::Duration)
pub mod duration {

    /// A builder for [`Duration`](crate::model::Duration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) value: std::option::Option<i64>,
        pub(crate) unit: std::option::Option<crate::model::TimeUnit>,
    }
    impl Builder {
        /// <p>Integer to specify the value of a maintenance schedule duration. See <a href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/auto-tune.html" target="_blank"> Auto-Tune for Amazon OpenSearch Service </a> for more information. </p>
        pub fn value(mut self, input: i64) -> Self {
            self.value = Some(input);
            self
        }
        /// <p>Integer to specify the value of a maintenance schedule duration. See <a href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/auto-tune.html" target="_blank"> Auto-Tune for Amazon OpenSearch Service </a> for more information. </p>
        pub fn set_value(mut self, input: std::option::Option<i64>) -> Self {
            self.value = input;
            self
        }
        /// <p>The unit of a maintenance schedule duration. Valid value is HOURS. See <a href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/auto-tune.html" target="_blank"> Auto-Tune for Amazon OpenSearch Service </a> for more information. </p>
        pub fn unit(mut self, input: crate::model::TimeUnit) -> Self {
            self.unit = Some(input);
            self
        }
        /// <p>The unit of a maintenance schedule duration. Valid value is HOURS. See <a href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/auto-tune.html" target="_blank"> Auto-Tune for Amazon OpenSearch Service </a> for more information. </p>
        pub fn set_unit(mut self, input: std::option::Option<crate::model::TimeUnit>) -> Self {
            self.unit = input;
            self
        }
        /// Consumes the builder and constructs a [`Duration`](crate::model::Duration)
        pub fn build(self) -> crate::model::Duration {
            crate::model::Duration {
                value: self.value.unwrap_or_default(),
                unit: self.unit,
            }
        }
    }
}
impl Duration {
    /// Creates a new builder-style object to manufacture [`Duration`](crate::model::Duration)
    pub fn builder() -> crate::model::duration::Builder {
        crate::model::duration::Builder::default()
    }
}

/// <p>The unit of a maintenance schedule duration. Valid value is HOUR. See <a href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/auto-tune.html" target="_blank">
/// Auto-Tune for Amazon OpenSearch Service
/// </a> for more information.
/// </p>
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TimeUnit {
    #[allow(missing_docs)] // documentation missing in model
    Hours,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for TimeUnit {
    fn from(s: &str) -> Self {
        match s {
            "HOURS" => TimeUnit::Hours,
            other => TimeUnit::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for TimeUnit {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TimeUnit::from(s))
    }
}
impl TimeUnit {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            TimeUnit::Hours => "HOURS",
            TimeUnit::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["HOURS"]
    }
}
impl AsRef<str> for TimeUnit {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The rollback state while disabling Auto-Tune for the domain. Valid values are NO_ROLLBACK and DEFAULT_ROLLBACK.
/// </p>
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum RollbackOnDisable {
    #[allow(missing_docs)] // documentation missing in model
    DefaultRollback,
    #[allow(missing_docs)] // documentation missing in model
    NoRollback,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for RollbackOnDisable {
    fn from(s: &str) -> Self {
        match s {
            "DEFAULT_ROLLBACK" => RollbackOnDisable::DefaultRollback,
            "NO_ROLLBACK" => RollbackOnDisable::NoRollback,
            other => RollbackOnDisable::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for RollbackOnDisable {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(RollbackOnDisable::from(s))
    }
}
impl RollbackOnDisable {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            RollbackOnDisable::DefaultRollback => "DEFAULT_ROLLBACK",
            RollbackOnDisable::NoRollback => "NO_ROLLBACK",
            RollbackOnDisable::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["DEFAULT_ROLLBACK", "NO_ROLLBACK"]
    }
}
impl AsRef<str> for RollbackOnDisable {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The Auto-Tune desired state. Valid values are ENABLED and DISABLED.</p>
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AutoTuneDesiredState {
    #[allow(missing_docs)] // documentation missing in model
    Disabled,
    #[allow(missing_docs)] // documentation missing in model
    Enabled,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for AutoTuneDesiredState {
    fn from(s: &str) -> Self {
        match s {
            "DISABLED" => AutoTuneDesiredState::Disabled,
            "ENABLED" => AutoTuneDesiredState::Enabled,
            other => AutoTuneDesiredState::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for AutoTuneDesiredState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AutoTuneDesiredState::from(s))
    }
}
impl AutoTuneDesiredState {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            AutoTuneDesiredState::Disabled => "DISABLED",
            AutoTuneDesiredState::Enabled => "ENABLED",
            AutoTuneDesiredState::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["DISABLED", "ENABLED"]
    }
}
impl AsRef<str> for AutoTuneDesiredState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The status of advanced security options for the specified domain.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AdvancedSecurityOptionsStatus {
    /// <p>Advanced security options for the specified domain.</p>
    pub options: std::option::Option<crate::model::AdvancedSecurityOptions>,
    /// <p>Status of the advanced security options for the specified domain.</p>
    pub status: std::option::Option<crate::model::OptionStatus>,
}
impl AdvancedSecurityOptionsStatus {
    /// <p>Advanced security options for the specified domain.</p>
    pub fn options(&self) -> std::option::Option<&crate::model::AdvancedSecurityOptions> {
        self.options.as_ref()
    }
    /// <p>Status of the advanced security options for the specified domain.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::OptionStatus> {
        self.status.as_ref()
    }
}
impl std::fmt::Debug for AdvancedSecurityOptionsStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AdvancedSecurityOptionsStatus");
        formatter.field("options", &self.options);
        formatter.field("status", &self.status);
        formatter.finish()
    }
}
/// See [`AdvancedSecurityOptionsStatus`](crate::model::AdvancedSecurityOptionsStatus)
pub mod advanced_security_options_status {

    /// A builder for [`AdvancedSecurityOptionsStatus`](crate::model::AdvancedSecurityOptionsStatus)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) options: std::option::Option<crate::model::AdvancedSecurityOptions>,
        pub(crate) status: std::option::Option<crate::model::OptionStatus>,
    }
    impl Builder {
        /// <p>Advanced security options for the specified domain.</p>
        pub fn options(mut self, input: crate::model::AdvancedSecurityOptions) -> Self {
            self.options = Some(input);
            self
        }
        /// <p>Advanced security options for the specified domain.</p>
        pub fn set_options(
            mut self,
            input: std::option::Option<crate::model::AdvancedSecurityOptions>,
        ) -> Self {
            self.options = input;
            self
        }
        /// <p>Status of the advanced security options for the specified domain.</p>
        pub fn status(mut self, input: crate::model::OptionStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>Status of the advanced security options for the specified domain.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::OptionStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// Consumes the builder and constructs a [`AdvancedSecurityOptionsStatus`](crate::model::AdvancedSecurityOptionsStatus)
        pub fn build(self) -> crate::model::AdvancedSecurityOptionsStatus {
            crate::model::AdvancedSecurityOptionsStatus {
                options: self.options,
                status: self.status,
            }
        }
    }
}
impl AdvancedSecurityOptionsStatus {
    /// Creates a new builder-style object to manufacture [`AdvancedSecurityOptionsStatus`](crate::model::AdvancedSecurityOptionsStatus)
    pub fn builder() -> crate::model::advanced_security_options_status::Builder {
        crate::model::advanced_security_options_status::Builder::default()
    }
}

/// <p>Provides the current status of the entity.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct OptionStatus {
    /// <p>The timestamp of when the entity was created.</p>
    pub creation_date: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The timestamp of the last time the entity was updated.</p>
    pub update_date: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The latest version of the entity.</p>
    pub update_version: i32,
    /// <p>Provides the <code>OptionState</code> for the domain. </p>
    pub state: std::option::Option<crate::model::OptionState>,
    /// <p>Indicates whether the domain is being deleted.</p>
    pub pending_deletion: std::option::Option<bool>,
}
impl OptionStatus {
    /// <p>The timestamp of when the entity was created.</p>
    pub fn creation_date(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_date.as_ref()
    }
    /// <p>The timestamp of the last time the entity was updated.</p>
    pub fn update_date(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.update_date.as_ref()
    }
    /// <p>The latest version of the entity.</p>
    pub fn update_version(&self) -> i32 {
        self.update_version
    }
    /// <p>Provides the <code>OptionState</code> for the domain. </p>
    pub fn state(&self) -> std::option::Option<&crate::model::OptionState> {
        self.state.as_ref()
    }
    /// <p>Indicates whether the domain is being deleted.</p>
    pub fn pending_deletion(&self) -> std::option::Option<bool> {
        self.pending_deletion
    }
}
impl std::fmt::Debug for OptionStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("OptionStatus");
        formatter.field("creation_date", &self.creation_date);
        formatter.field("update_date", &self.update_date);
        formatter.field("update_version", &self.update_version);
        formatter.field("state", &self.state);
        formatter.field("pending_deletion", &self.pending_deletion);
        formatter.finish()
    }
}
/// See [`OptionStatus`](crate::model::OptionStatus)
pub mod option_status {

    /// A builder for [`OptionStatus`](crate::model::OptionStatus)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) creation_date: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) update_date: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) update_version: std::option::Option<i32>,
        pub(crate) state: std::option::Option<crate::model::OptionState>,
        pub(crate) pending_deletion: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The timestamp of when the entity was created.</p>
        pub fn creation_date(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_date = Some(input);
            self
        }
        /// <p>The timestamp of when the entity was created.</p>
        pub fn set_creation_date(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_date = input;
            self
        }
        /// <p>The timestamp of the last time the entity was updated.</p>
        pub fn update_date(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.update_date = Some(input);
            self
        }
        /// <p>The timestamp of the last time the entity was updated.</p>
        pub fn set_update_date(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.update_date = input;
            self
        }
        /// <p>The latest version of the entity.</p>
        pub fn update_version(mut self, input: i32) -> Self {
            self.update_version = Some(input);
            self
        }
        /// <p>The latest version of the entity.</p>
        pub fn set_update_version(mut self, input: std::option::Option<i32>) -> Self {
            self.update_version = input;
            self
        }
        /// <p>Provides the <code>OptionState</code> for the domain. </p>
        pub fn state(mut self, input: crate::model::OptionState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>Provides the <code>OptionState</code> for the domain. </p>
        pub fn set_state(mut self, input: std::option::Option<crate::model::OptionState>) -> Self {
            self.state = input;
            self
        }
        /// <p>Indicates whether the domain is being deleted.</p>
        pub fn pending_deletion(mut self, input: bool) -> Self {
            self.pending_deletion = Some(input);
            self
        }
        /// <p>Indicates whether the domain is being deleted.</p>
        pub fn set_pending_deletion(mut self, input: std::option::Option<bool>) -> Self {
            self.pending_deletion = input;
            self
        }
        /// Consumes the builder and constructs a [`OptionStatus`](crate::model::OptionStatus)
        pub fn build(self) -> crate::model::OptionStatus {
            crate::model::OptionStatus {
                creation_date: self.creation_date,
                update_date: self.update_date,
                update_version: self.update_version.unwrap_or_default(),
                state: self.state,
                pending_deletion: self.pending_deletion,
            }
        }
    }
}
impl OptionStatus {
    /// Creates a new builder-style object to manufacture [`OptionStatus`](crate::model::OptionStatus)
    pub fn builder() -> crate::model::option_status::Builder {
        crate::model::option_status::Builder::default()
    }
}

/// <p>The state of a requested change. One of the following:</p>
/// <ul>
/// <li>Processing: The request change is still in progress.</li>
/// <li>Active: The request change is processed and deployed to the domain.</li>
/// </ul>
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum OptionState {
    #[allow(missing_docs)] // documentation missing in model
    Active,
    #[allow(missing_docs)] // documentation missing in model
    Processing,
    #[allow(missing_docs)] // documentation missing in model
    RequiresIndexDocuments,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for OptionState {
    fn from(s: &str) -> Self {
        match s {
            "Active" => OptionState::Active,
            "Processing" => OptionState::Processing,
            "RequiresIndexDocuments" => OptionState::RequiresIndexDocuments,
            other => OptionState::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for OptionState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(OptionState::from(s))
    }
}
impl OptionState {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            OptionState::Active => "Active",
            OptionState::Processing => "Processing",
            OptionState::RequiresIndexDocuments => "RequiresIndexDocuments",
            OptionState::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["Active", "Processing", "RequiresIndexDocuments"]
    }
}
impl AsRef<str> for OptionState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The advanced security configuration: whether advanced security is enabled, whether the internal database option is enabled. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AdvancedSecurityOptions {
    /// <p>True if advanced security is enabled.</p>
    pub enabled: std::option::Option<bool>,
    /// <p>True if the internal user database is enabled.</p>
    pub internal_user_database_enabled: std::option::Option<bool>,
    /// <p>Describes the SAML application configured for a domain.</p>
    pub saml_options: std::option::Option<crate::model::SamlOptionsOutput>,
    /// <p>Specifies the Anonymous Auth Disable Date when Anonymous Auth is enabled.</p>
    pub anonymous_auth_disable_date: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>True if Anonymous auth is enabled. Anonymous auth can be enabled only when AdvancedSecurity is enabled on existing domains.</p>
    pub anonymous_auth_enabled: std::option::Option<bool>,
}
impl AdvancedSecurityOptions {
    /// <p>True if advanced security is enabled.</p>
    pub fn enabled(&self) -> std::option::Option<bool> {
        self.enabled
    }
    /// <p>True if the internal user database is enabled.</p>
    pub fn internal_user_database_enabled(&self) -> std::option::Option<bool> {
        self.internal_user_database_enabled
    }
    /// <p>Describes the SAML application configured for a domain.</p>
    pub fn saml_options(&self) -> std::option::Option<&crate::model::SamlOptionsOutput> {
        self.saml_options.as_ref()
    }
    /// <p>Specifies the Anonymous Auth Disable Date when Anonymous Auth is enabled.</p>
    pub fn anonymous_auth_disable_date(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.anonymous_auth_disable_date.as_ref()
    }
    /// <p>True if Anonymous auth is enabled. Anonymous auth can be enabled only when AdvancedSecurity is enabled on existing domains.</p>
    pub fn anonymous_auth_enabled(&self) -> std::option::Option<bool> {
        self.anonymous_auth_enabled
    }
}
impl std::fmt::Debug for AdvancedSecurityOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AdvancedSecurityOptions");
        formatter.field("enabled", &self.enabled);
        formatter.field(
            "internal_user_database_enabled",
            &self.internal_user_database_enabled,
        );
        formatter.field("saml_options", &self.saml_options);
        formatter.field(
            "anonymous_auth_disable_date",
            &self.anonymous_auth_disable_date,
        );
        formatter.field("anonymous_auth_enabled", &self.anonymous_auth_enabled);
        formatter.finish()
    }
}
/// See [`AdvancedSecurityOptions`](crate::model::AdvancedSecurityOptions)
pub mod advanced_security_options {

    /// A builder for [`AdvancedSecurityOptions`](crate::model::AdvancedSecurityOptions)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) enabled: std::option::Option<bool>,
        pub(crate) internal_user_database_enabled: std::option::Option<bool>,
        pub(crate) saml_options: std::option::Option<crate::model::SamlOptionsOutput>,
        pub(crate) anonymous_auth_disable_date: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) anonymous_auth_enabled: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>True if advanced security is enabled.</p>
        pub fn enabled(mut self, input: bool) -> Self {
            self.enabled = Some(input);
            self
        }
        /// <p>True if advanced security is enabled.</p>
        pub fn set_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.enabled = input;
            self
        }
        /// <p>True if the internal user database is enabled.</p>
        pub fn internal_user_database_enabled(mut self, input: bool) -> Self {
            self.internal_user_database_enabled = Some(input);
            self
        }
        /// <p>True if the internal user database is enabled.</p>
        pub fn set_internal_user_database_enabled(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.internal_user_database_enabled = input;
            self
        }
        /// <p>Describes the SAML application configured for a domain.</p>
        pub fn saml_options(mut self, input: crate::model::SamlOptionsOutput) -> Self {
            self.saml_options = Some(input);
            self
        }
        /// <p>Describes the SAML application configured for a domain.</p>
        pub fn set_saml_options(
            mut self,
            input: std::option::Option<crate::model::SamlOptionsOutput>,
        ) -> Self {
            self.saml_options = input;
            self
        }
        /// <p>Specifies the Anonymous Auth Disable Date when Anonymous Auth is enabled.</p>
        pub fn anonymous_auth_disable_date(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.anonymous_auth_disable_date = Some(input);
            self
        }
        /// <p>Specifies the Anonymous Auth Disable Date when Anonymous Auth is enabled.</p>
        pub fn set_anonymous_auth_disable_date(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.anonymous_auth_disable_date = input;
            self
        }
        /// <p>True if Anonymous auth is enabled. Anonymous auth can be enabled only when AdvancedSecurity is enabled on existing domains.</p>
        pub fn anonymous_auth_enabled(mut self, input: bool) -> Self {
            self.anonymous_auth_enabled = Some(input);
            self
        }
        /// <p>True if Anonymous auth is enabled. Anonymous auth can be enabled only when AdvancedSecurity is enabled on existing domains.</p>
        pub fn set_anonymous_auth_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.anonymous_auth_enabled = input;
            self
        }
        /// Consumes the builder and constructs a [`AdvancedSecurityOptions`](crate::model::AdvancedSecurityOptions)
        pub fn build(self) -> crate::model::AdvancedSecurityOptions {
            crate::model::AdvancedSecurityOptions {
                enabled: self.enabled,
                internal_user_database_enabled: self.internal_user_database_enabled,
                saml_options: self.saml_options,
                anonymous_auth_disable_date: self.anonymous_auth_disable_date,
                anonymous_auth_enabled: self.anonymous_auth_enabled,
            }
        }
    }
}
impl AdvancedSecurityOptions {
    /// Creates a new builder-style object to manufacture [`AdvancedSecurityOptions`](crate::model::AdvancedSecurityOptions)
    pub fn builder() -> crate::model::advanced_security_options::Builder {
        crate::model::advanced_security_options::Builder::default()
    }
}

/// <p>Describes the SAML application configured for the domain.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SamlOptionsOutput {
    /// <p>True if SAML is enabled.</p>
    pub enabled: std::option::Option<bool>,
    /// <p>Describes the SAML identity provider's information.</p>
    pub idp: std::option::Option<crate::model::SamlIdp>,
    /// <p>The key used for matching the SAML subject attribute.</p>
    pub subject_key: std::option::Option<std::string::String>,
    /// <p>The key used for matching the SAML roles attribute.</p>
    pub roles_key: std::option::Option<std::string::String>,
    /// <p>The duration, in minutes, after which a user session becomes inactive.</p>
    pub session_timeout_minutes: std::option::Option<i32>,
}
impl SamlOptionsOutput {
    /// <p>True if SAML is enabled.</p>
    pub fn enabled(&self) -> std::option::Option<bool> {
        self.enabled
    }
    /// <p>Describes the SAML identity provider's information.</p>
    pub fn idp(&self) -> std::option::Option<&crate::model::SamlIdp> {
        self.idp.as_ref()
    }
    /// <p>The key used for matching the SAML subject attribute.</p>
    pub fn subject_key(&self) -> std::option::Option<&str> {
        self.subject_key.as_deref()
    }
    /// <p>The key used for matching the SAML roles attribute.</p>
    pub fn roles_key(&self) -> std::option::Option<&str> {
        self.roles_key.as_deref()
    }
    /// <p>The duration, in minutes, after which a user session becomes inactive.</p>
    pub fn session_timeout_minutes(&self) -> std::option::Option<i32> {
        self.session_timeout_minutes
    }
}
impl std::fmt::Debug for SamlOptionsOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SamlOptionsOutput");
        formatter.field("enabled", &self.enabled);
        formatter.field("idp", &self.idp);
        formatter.field("subject_key", &self.subject_key);
        formatter.field("roles_key", &self.roles_key);
        formatter.field("session_timeout_minutes", &self.session_timeout_minutes);
        formatter.finish()
    }
}
/// See [`SamlOptionsOutput`](crate::model::SamlOptionsOutput)
pub mod saml_options_output {

    /// A builder for [`SamlOptionsOutput`](crate::model::SamlOptionsOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) enabled: std::option::Option<bool>,
        pub(crate) idp: std::option::Option<crate::model::SamlIdp>,
        pub(crate) subject_key: std::option::Option<std::string::String>,
        pub(crate) roles_key: std::option::Option<std::string::String>,
        pub(crate) session_timeout_minutes: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>True if SAML is enabled.</p>
        pub fn enabled(mut self, input: bool) -> Self {
            self.enabled = Some(input);
            self
        }
        /// <p>True if SAML is enabled.</p>
        pub fn set_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.enabled = input;
            self
        }
        /// <p>Describes the SAML identity provider's information.</p>
        pub fn idp(mut self, input: crate::model::SamlIdp) -> Self {
            self.idp = Some(input);
            self
        }
        /// <p>Describes the SAML identity provider's information.</p>
        pub fn set_idp(mut self, input: std::option::Option<crate::model::SamlIdp>) -> Self {
            self.idp = input;
            self
        }
        /// <p>The key used for matching the SAML subject attribute.</p>
        pub fn subject_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.subject_key = Some(input.into());
            self
        }
        /// <p>The key used for matching the SAML subject attribute.</p>
        pub fn set_subject_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.subject_key = input;
            self
        }
        /// <p>The key used for matching the SAML roles attribute.</p>
        pub fn roles_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.roles_key = Some(input.into());
            self
        }
        /// <p>The key used for matching the SAML roles attribute.</p>
        pub fn set_roles_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.roles_key = input;
            self
        }
        /// <p>The duration, in minutes, after which a user session becomes inactive.</p>
        pub fn session_timeout_minutes(mut self, input: i32) -> Self {
            self.session_timeout_minutes = Some(input);
            self
        }
        /// <p>The duration, in minutes, after which a user session becomes inactive.</p>
        pub fn set_session_timeout_minutes(mut self, input: std::option::Option<i32>) -> Self {
            self.session_timeout_minutes = input;
            self
        }
        /// Consumes the builder and constructs a [`SamlOptionsOutput`](crate::model::SamlOptionsOutput)
        pub fn build(self) -> crate::model::SamlOptionsOutput {
            crate::model::SamlOptionsOutput {
                enabled: self.enabled,
                idp: self.idp,
                subject_key: self.subject_key,
                roles_key: self.roles_key,
                session_timeout_minutes: self.session_timeout_minutes,
            }
        }
    }
}
impl SamlOptionsOutput {
    /// Creates a new builder-style object to manufacture [`SamlOptionsOutput`](crate::model::SamlOptionsOutput)
    pub fn builder() -> crate::model::saml_options_output::Builder {
        crate::model::saml_options_output::Builder::default()
    }
}

/// <p>The SAML identity povider's information.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SamlIdp {
    /// <p>The metadata of the SAML application in XML format.</p>
    pub metadata_content: std::option::Option<std::string::String>,
    /// <p>The unique entity ID of the application in SAML identity provider.</p>
    pub entity_id: std::option::Option<std::string::String>,
}
impl SamlIdp {
    /// <p>The metadata of the SAML application in XML format.</p>
    pub fn metadata_content(&self) -> std::option::Option<&str> {
        self.metadata_content.as_deref()
    }
    /// <p>The unique entity ID of the application in SAML identity provider.</p>
    pub fn entity_id(&self) -> std::option::Option<&str> {
        self.entity_id.as_deref()
    }
}
impl std::fmt::Debug for SamlIdp {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SamlIdp");
        formatter.field("metadata_content", &self.metadata_content);
        formatter.field("entity_id", &self.entity_id);
        formatter.finish()
    }
}
/// See [`SamlIdp`](crate::model::SamlIdp)
pub mod saml_idp {

    /// A builder for [`SamlIdp`](crate::model::SamlIdp)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) metadata_content: std::option::Option<std::string::String>,
        pub(crate) entity_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The metadata of the SAML application in XML format.</p>
        pub fn metadata_content(mut self, input: impl Into<std::string::String>) -> Self {
            self.metadata_content = Some(input.into());
            self
        }
        /// <p>The metadata of the SAML application in XML format.</p>
        pub fn set_metadata_content(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.metadata_content = input;
            self
        }
        /// <p>The unique entity ID of the application in SAML identity provider.</p>
        pub fn entity_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.entity_id = Some(input.into());
            self
        }
        /// <p>The unique entity ID of the application in SAML identity provider.</p>
        pub fn set_entity_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.entity_id = input;
            self
        }
        /// Consumes the builder and constructs a [`SamlIdp`](crate::model::SamlIdp)
        pub fn build(self) -> crate::model::SamlIdp {
            crate::model::SamlIdp {
                metadata_content: self.metadata_content,
                entity_id: self.entity_id,
            }
        }
    }
}
impl SamlIdp {
    /// Creates a new builder-style object to manufacture [`SamlIdp`](crate::model::SamlIdp)
    pub fn builder() -> crate::model::saml_idp::Builder {
        crate::model::saml_idp::Builder::default()
    }
}

/// <p>The configured endpoint options for the domain and their current status.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DomainEndpointOptionsStatus {
    /// <p>Options to configure the endpoint for the domain.</p>
    pub options: std::option::Option<crate::model::DomainEndpointOptions>,
    /// <p>The status of the endpoint options for the domain. See <code>OptionStatus</code> for the status information that's included. </p>
    pub status: std::option::Option<crate::model::OptionStatus>,
}
impl DomainEndpointOptionsStatus {
    /// <p>Options to configure the endpoint for the domain.</p>
    pub fn options(&self) -> std::option::Option<&crate::model::DomainEndpointOptions> {
        self.options.as_ref()
    }
    /// <p>The status of the endpoint options for the domain. See <code>OptionStatus</code> for the status information that's included. </p>
    pub fn status(&self) -> std::option::Option<&crate::model::OptionStatus> {
        self.status.as_ref()
    }
}
impl std::fmt::Debug for DomainEndpointOptionsStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DomainEndpointOptionsStatus");
        formatter.field("options", &self.options);
        formatter.field("status", &self.status);
        formatter.finish()
    }
}
/// See [`DomainEndpointOptionsStatus`](crate::model::DomainEndpointOptionsStatus)
pub mod domain_endpoint_options_status {

    /// A builder for [`DomainEndpointOptionsStatus`](crate::model::DomainEndpointOptionsStatus)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) options: std::option::Option<crate::model::DomainEndpointOptions>,
        pub(crate) status: std::option::Option<crate::model::OptionStatus>,
    }
    impl Builder {
        /// <p>Options to configure the endpoint for the domain.</p>
        pub fn options(mut self, input: crate::model::DomainEndpointOptions) -> Self {
            self.options = Some(input);
            self
        }
        /// <p>Options to configure the endpoint for the domain.</p>
        pub fn set_options(
            mut self,
            input: std::option::Option<crate::model::DomainEndpointOptions>,
        ) -> Self {
            self.options = input;
            self
        }
        /// <p>The status of the endpoint options for the domain. See <code>OptionStatus</code> for the status information that's included. </p>
        pub fn status(mut self, input: crate::model::OptionStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the endpoint options for the domain. See <code>OptionStatus</code> for the status information that's included. </p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::OptionStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// Consumes the builder and constructs a [`DomainEndpointOptionsStatus`](crate::model::DomainEndpointOptionsStatus)
        pub fn build(self) -> crate::model::DomainEndpointOptionsStatus {
            crate::model::DomainEndpointOptionsStatus {
                options: self.options,
                status: self.status,
            }
        }
    }
}
impl DomainEndpointOptionsStatus {
    /// Creates a new builder-style object to manufacture [`DomainEndpointOptionsStatus`](crate::model::DomainEndpointOptionsStatus)
    pub fn builder() -> crate::model::domain_endpoint_options_status::Builder {
        crate::model::domain_endpoint_options_status::Builder::default()
    }
}

/// <p>Options to configure the endpoint for the domain.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DomainEndpointOptions {
    /// <p>Whether only HTTPS endpoint should be enabled for the domain.</p>
    pub enforce_https: std::option::Option<bool>,
    /// <p>Specify the TLS security policy to apply to the HTTPS endpoint of the domain. <br><br> Can be one of the following values: </p>
    /// <ul>
    /// <li> <b>Policy-Min-TLS-1-0-2019-07:</b> TLS security policy which supports TLSv1.0 and higher. </li>
    /// <li> <b>Policy-Min-TLS-1-2-2019-07:</b> TLS security policy which supports only TLSv1.2 </li>
    /// </ul>
    /// <p></p>
    pub tls_security_policy: std::option::Option<crate::model::TlsSecurityPolicy>,
    /// <p>Whether to enable a custom endpoint for the domain.</p>
    pub custom_endpoint_enabled: std::option::Option<bool>,
    /// <p>The fully qualified domain for your custom endpoint.</p>
    pub custom_endpoint: std::option::Option<std::string::String>,
    /// <p>The ACM certificate ARN for your custom endpoint.</p>
    pub custom_endpoint_certificate_arn: std::option::Option<std::string::String>,
}
impl DomainEndpointOptions {
    /// <p>Whether only HTTPS endpoint should be enabled for the domain.</p>
    pub fn enforce_https(&self) -> std::option::Option<bool> {
        self.enforce_https
    }
    /// <p>Specify the TLS security policy to apply to the HTTPS endpoint of the domain. <br><br> Can be one of the following values: </p>
    /// <ul>
    /// <li> <b>Policy-Min-TLS-1-0-2019-07:</b> TLS security policy which supports TLSv1.0 and higher. </li>
    /// <li> <b>Policy-Min-TLS-1-2-2019-07:</b> TLS security policy which supports only TLSv1.2 </li>
    /// </ul>
    /// <p></p>
    pub fn tls_security_policy(&self) -> std::option::Option<&crate::model::TlsSecurityPolicy> {
        self.tls_security_policy.as_ref()
    }
    /// <p>Whether to enable a custom endpoint for the domain.</p>
    pub fn custom_endpoint_enabled(&self) -> std::option::Option<bool> {
        self.custom_endpoint_enabled
    }
    /// <p>The fully qualified domain for your custom endpoint.</p>
    pub fn custom_endpoint(&self) -> std::option::Option<&str> {
        self.custom_endpoint.as_deref()
    }
    /// <p>The ACM certificate ARN for your custom endpoint.</p>
    pub fn custom_endpoint_certificate_arn(&self) -> std::option::Option<&str> {
        self.custom_endpoint_certificate_arn.as_deref()
    }
}
impl std::fmt::Debug for DomainEndpointOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DomainEndpointOptions");
        formatter.field("enforce_https", &self.enforce_https);
        formatter.field("tls_security_policy", &self.tls_security_policy);
        formatter.field("custom_endpoint_enabled", &self.custom_endpoint_enabled);
        formatter.field("custom_endpoint", &self.custom_endpoint);
        formatter.field(
            "custom_endpoint_certificate_arn",
            &self.custom_endpoint_certificate_arn,
        );
        formatter.finish()
    }
}
/// See [`DomainEndpointOptions`](crate::model::DomainEndpointOptions)
pub mod domain_endpoint_options {

    /// A builder for [`DomainEndpointOptions`](crate::model::DomainEndpointOptions)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) enforce_https: std::option::Option<bool>,
        pub(crate) tls_security_policy: std::option::Option<crate::model::TlsSecurityPolicy>,
        pub(crate) custom_endpoint_enabled: std::option::Option<bool>,
        pub(crate) custom_endpoint: std::option::Option<std::string::String>,
        pub(crate) custom_endpoint_certificate_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Whether only HTTPS endpoint should be enabled for the domain.</p>
        pub fn enforce_https(mut self, input: bool) -> Self {
            self.enforce_https = Some(input);
            self
        }
        /// <p>Whether only HTTPS endpoint should be enabled for the domain.</p>
        pub fn set_enforce_https(mut self, input: std::option::Option<bool>) -> Self {
            self.enforce_https = input;
            self
        }
        /// <p>Specify the TLS security policy to apply to the HTTPS endpoint of the domain. <br><br> Can be one of the following values: </p>
        /// <ul>
        /// <li> <b>Policy-Min-TLS-1-0-2019-07:</b> TLS security policy which supports TLSv1.0 and higher. </li>
        /// <li> <b>Policy-Min-TLS-1-2-2019-07:</b> TLS security policy which supports only TLSv1.2 </li>
        /// </ul>
        /// <p></p>
        pub fn tls_security_policy(mut self, input: crate::model::TlsSecurityPolicy) -> Self {
            self.tls_security_policy = Some(input);
            self
        }
        /// <p>Specify the TLS security policy to apply to the HTTPS endpoint of the domain. <br><br> Can be one of the following values: </p>
        /// <ul>
        /// <li> <b>Policy-Min-TLS-1-0-2019-07:</b> TLS security policy which supports TLSv1.0 and higher. </li>
        /// <li> <b>Policy-Min-TLS-1-2-2019-07:</b> TLS security policy which supports only TLSv1.2 </li>
        /// </ul>
        /// <p></p>
        pub fn set_tls_security_policy(
            mut self,
            input: std::option::Option<crate::model::TlsSecurityPolicy>,
        ) -> Self {
            self.tls_security_policy = input;
            self
        }
        /// <p>Whether to enable a custom endpoint for the domain.</p>
        pub fn custom_endpoint_enabled(mut self, input: bool) -> Self {
            self.custom_endpoint_enabled = Some(input);
            self
        }
        /// <p>Whether to enable a custom endpoint for the domain.</p>
        pub fn set_custom_endpoint_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.custom_endpoint_enabled = input;
            self
        }
        /// <p>The fully qualified domain for your custom endpoint.</p>
        pub fn custom_endpoint(mut self, input: impl Into<std::string::String>) -> Self {
            self.custom_endpoint = Some(input.into());
            self
        }
        /// <p>The fully qualified domain for your custom endpoint.</p>
        pub fn set_custom_endpoint(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.custom_endpoint = input;
            self
        }
        /// <p>The ACM certificate ARN for your custom endpoint.</p>
        pub fn custom_endpoint_certificate_arn(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.custom_endpoint_certificate_arn = Some(input.into());
            self
        }
        /// <p>The ACM certificate ARN for your custom endpoint.</p>
        pub fn set_custom_endpoint_certificate_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.custom_endpoint_certificate_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`DomainEndpointOptions`](crate::model::DomainEndpointOptions)
        pub fn build(self) -> crate::model::DomainEndpointOptions {
            crate::model::DomainEndpointOptions {
                enforce_https: self.enforce_https,
                tls_security_policy: self.tls_security_policy,
                custom_endpoint_enabled: self.custom_endpoint_enabled,
                custom_endpoint: self.custom_endpoint,
                custom_endpoint_certificate_arn: self.custom_endpoint_certificate_arn,
            }
        }
    }
}
impl DomainEndpointOptions {
    /// Creates a new builder-style object to manufacture [`DomainEndpointOptions`](crate::model::DomainEndpointOptions)
    pub fn builder() -> crate::model::domain_endpoint_options::Builder {
        crate::model::domain_endpoint_options::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TlsSecurityPolicy {
    #[allow(missing_docs)] // documentation missing in model
    PolicyMinTls10201907,
    #[allow(missing_docs)] // documentation missing in model
    PolicyMinTls12201907,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for TlsSecurityPolicy {
    fn from(s: &str) -> Self {
        match s {
            "Policy-Min-TLS-1-0-2019-07" => TlsSecurityPolicy::PolicyMinTls10201907,
            "Policy-Min-TLS-1-2-2019-07" => TlsSecurityPolicy::PolicyMinTls12201907,
            other => TlsSecurityPolicy::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for TlsSecurityPolicy {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TlsSecurityPolicy::from(s))
    }
}
impl TlsSecurityPolicy {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            TlsSecurityPolicy::PolicyMinTls10201907 => "Policy-Min-TLS-1-0-2019-07",
            TlsSecurityPolicy::PolicyMinTls12201907 => "Policy-Min-TLS-1-2-2019-07",
            TlsSecurityPolicy::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["Policy-Min-TLS-1-0-2019-07", "Policy-Min-TLS-1-2-2019-07"]
    }
}
impl AsRef<str> for TlsSecurityPolicy {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The configured log publishing options for the domain and their current status.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LogPublishingOptionsStatus {
    /// <p>The log publishing options configured for the domain.</p>
    pub options: std::option::Option<
        std::collections::HashMap<crate::model::LogType, crate::model::LogPublishingOption>,
    >,
    /// <p>The status of the log publishing options for the domain. See <code>OptionStatus</code> for the status information that's included. </p>
    pub status: std::option::Option<crate::model::OptionStatus>,
}
impl LogPublishingOptionsStatus {
    /// <p>The log publishing options configured for the domain.</p>
    pub fn options(
        &self,
    ) -> std::option::Option<
        &std::collections::HashMap<crate::model::LogType, crate::model::LogPublishingOption>,
    > {
        self.options.as_ref()
    }
    /// <p>The status of the log publishing options for the domain. See <code>OptionStatus</code> for the status information that's included. </p>
    pub fn status(&self) -> std::option::Option<&crate::model::OptionStatus> {
        self.status.as_ref()
    }
}
impl std::fmt::Debug for LogPublishingOptionsStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LogPublishingOptionsStatus");
        formatter.field("options", &self.options);
        formatter.field("status", &self.status);
        formatter.finish()
    }
}
/// See [`LogPublishingOptionsStatus`](crate::model::LogPublishingOptionsStatus)
pub mod log_publishing_options_status {

    /// A builder for [`LogPublishingOptionsStatus`](crate::model::LogPublishingOptionsStatus)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) options: std::option::Option<
            std::collections::HashMap<crate::model::LogType, crate::model::LogPublishingOption>,
        >,
        pub(crate) status: std::option::Option<crate::model::OptionStatus>,
    }
    impl Builder {
        /// Adds a key-value pair to `options`.
        ///
        /// To override the contents of this collection use [`set_options`](Self::set_options).
        ///
        /// <p>The log publishing options configured for the domain.</p>
        pub fn options(
            mut self,
            k: crate::model::LogType,
            v: crate::model::LogPublishingOption,
        ) -> Self {
            let mut hash_map = self.options.unwrap_or_default();
            hash_map.insert(k, v);
            self.options = Some(hash_map);
            self
        }
        /// <p>The log publishing options configured for the domain.</p>
        pub fn set_options(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<crate::model::LogType, crate::model::LogPublishingOption>,
            >,
        ) -> Self {
            self.options = input;
            self
        }
        /// <p>The status of the log publishing options for the domain. See <code>OptionStatus</code> for the status information that's included. </p>
        pub fn status(mut self, input: crate::model::OptionStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the log publishing options for the domain. See <code>OptionStatus</code> for the status information that's included. </p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::OptionStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// Consumes the builder and constructs a [`LogPublishingOptionsStatus`](crate::model::LogPublishingOptionsStatus)
        pub fn build(self) -> crate::model::LogPublishingOptionsStatus {
            crate::model::LogPublishingOptionsStatus {
                options: self.options,
                status: self.status,
            }
        }
    }
}
impl LogPublishingOptionsStatus {
    /// Creates a new builder-style object to manufacture [`LogPublishingOptionsStatus`](crate::model::LogPublishingOptionsStatus)
    pub fn builder() -> crate::model::log_publishing_options_status::Builder {
        crate::model::log_publishing_options_status::Builder::default()
    }
}

/// <p>Log Publishing option that is set for a given domain. <br><br>Attributes and their details: </p>
/// <ul>
/// <li>CloudWatchLogsLogGroupArn: ARN of the Cloudwatch log group to publish logs to.</li>
/// <li>Enabled: Whether the log publishing for a given log type is enabled or not.</li>
/// </ul>
/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LogPublishingOption {
    /// <p>ARN of the Cloudwatch log group to publish logs to.</p>
    pub cloud_watch_logs_log_group_arn: std::option::Option<std::string::String>,
    /// <p>Whether the given log publishing option is enabled or not.</p>
    pub enabled: std::option::Option<bool>,
}
impl LogPublishingOption {
    /// <p>ARN of the Cloudwatch log group to publish logs to.</p>
    pub fn cloud_watch_logs_log_group_arn(&self) -> std::option::Option<&str> {
        self.cloud_watch_logs_log_group_arn.as_deref()
    }
    /// <p>Whether the given log publishing option is enabled or not.</p>
    pub fn enabled(&self) -> std::option::Option<bool> {
        self.enabled
    }
}
impl std::fmt::Debug for LogPublishingOption {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LogPublishingOption");
        formatter.field(
            "cloud_watch_logs_log_group_arn",
            &self.cloud_watch_logs_log_group_arn,
        );
        formatter.field("enabled", &self.enabled);
        formatter.finish()
    }
}
/// See [`LogPublishingOption`](crate::model::LogPublishingOption)
pub mod log_publishing_option {

    /// A builder for [`LogPublishingOption`](crate::model::LogPublishingOption)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) cloud_watch_logs_log_group_arn: std::option::Option<std::string::String>,
        pub(crate) enabled: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>ARN of the Cloudwatch log group to publish logs to.</p>
        pub fn cloud_watch_logs_log_group_arn(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.cloud_watch_logs_log_group_arn = Some(input.into());
            self
        }
        /// <p>ARN of the Cloudwatch log group to publish logs to.</p>
        pub fn set_cloud_watch_logs_log_group_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.cloud_watch_logs_log_group_arn = input;
            self
        }
        /// <p>Whether the given log publishing option is enabled or not.</p>
        pub fn enabled(mut self, input: bool) -> Self {
            self.enabled = Some(input);
            self
        }
        /// <p>Whether the given log publishing option is enabled or not.</p>
        pub fn set_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.enabled = input;
            self
        }
        /// Consumes the builder and constructs a [`LogPublishingOption`](crate::model::LogPublishingOption)
        pub fn build(self) -> crate::model::LogPublishingOption {
            crate::model::LogPublishingOption {
                cloud_watch_logs_log_group_arn: self.cloud_watch_logs_log_group_arn,
                enabled: self.enabled,
            }
        }
    }
}
impl LogPublishingOption {
    /// Creates a new builder-style object to manufacture [`LogPublishingOption`](crate::model::LogPublishingOption)
    pub fn builder() -> crate::model::log_publishing_option::Builder {
        crate::model::log_publishing_option::Builder::default()
    }
}

/// <p>Type of log file. Can be one of the following:
/// <ul>
/// <li>INDEX_SLOW_LOGS: Index slow logs contain insert requests that took more time than configured index query log
/// threshold to execute.
/// </li>
/// <li>SEARCH_SLOW_LOGS: Search slow logs contain search queries that took more time than configured search query
/// log threshold to execute.
/// </li>
/// <li>ES_APPLICATION_LOGS: OpenSearch application logs contain information about errors and warnings raised
/// during the operation of the service and can be useful for troubleshooting.
/// </li>
/// <li>AUDIT_LOGS: Audit logs contain records of user requests for access from the domain.</li>
/// </ul>
/// </p>
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum LogType {
    #[allow(missing_docs)] // documentation missing in model
    AuditLogs,
    #[allow(missing_docs)] // documentation missing in model
    EsApplicationLogs,
    #[allow(missing_docs)] // documentation missing in model
    IndexSlowLogs,
    #[allow(missing_docs)] // documentation missing in model
    SearchSlowLogs,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for LogType {
    fn from(s: &str) -> Self {
        match s {
            "AUDIT_LOGS" => LogType::AuditLogs,
            "ES_APPLICATION_LOGS" => LogType::EsApplicationLogs,
            "INDEX_SLOW_LOGS" => LogType::IndexSlowLogs,
            "SEARCH_SLOW_LOGS" => LogType::SearchSlowLogs,
            other => LogType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for LogType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(LogType::from(s))
    }
}
impl LogType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            LogType::AuditLogs => "AUDIT_LOGS",
            LogType::EsApplicationLogs => "ES_APPLICATION_LOGS",
            LogType::IndexSlowLogs => "INDEX_SLOW_LOGS",
            LogType::SearchSlowLogs => "SEARCH_SLOW_LOGS",
            LogType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "AUDIT_LOGS",
            "ES_APPLICATION_LOGS",
            "INDEX_SLOW_LOGS",
            "SEARCH_SLOW_LOGS",
        ]
    }
}
impl AsRef<str> for LogType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Status of the advanced options for the specified domain. Currently, the following advanced options are available: </p>
/// <ul>
/// <li>Option to allow references to indices in an HTTP request body. Must be <code>false</code> when configuring access to individual sub-resources. By default, the value is <code>true</code>. See <a href="http://docs.aws.amazon.com/opensearch-service/latest/developerguide/createupdatedomains.html#createdomain-configure-advanced-options" target="_blank">Advanced cluster parameters </a> for more information. </li>
/// <li>Option to specify the percentage of heap space allocated to field data. By default, this setting is unbounded. </li>
/// </ul>
/// <p>For more information, see <a href="http://docs.aws.amazon.com/opensearch-service/latest/developerguide/createupdatedomains.html#createdomain-configure-advanced-options"> Advanced cluster parameters</a>. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AdvancedOptionsStatus {
    /// <p>The status of advanced options for the specified domain.</p>
    pub options:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The <code>OptionStatus</code> for advanced options for the specified domain. </p>
    pub status: std::option::Option<crate::model::OptionStatus>,
}
impl AdvancedOptionsStatus {
    /// <p>The status of advanced options for the specified domain.</p>
    pub fn options(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.options.as_ref()
    }
    /// <p>The <code>OptionStatus</code> for advanced options for the specified domain. </p>
    pub fn status(&self) -> std::option::Option<&crate::model::OptionStatus> {
        self.status.as_ref()
    }
}
impl std::fmt::Debug for AdvancedOptionsStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AdvancedOptionsStatus");
        formatter.field("options", &self.options);
        formatter.field("status", &self.status);
        formatter.finish()
    }
}
/// See [`AdvancedOptionsStatus`](crate::model::AdvancedOptionsStatus)
pub mod advanced_options_status {

    /// A builder for [`AdvancedOptionsStatus`](crate::model::AdvancedOptionsStatus)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) options: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) status: std::option::Option<crate::model::OptionStatus>,
    }
    impl Builder {
        /// Adds a key-value pair to `options`.
        ///
        /// To override the contents of this collection use [`set_options`](Self::set_options).
        ///
        /// <p>The status of advanced options for the specified domain.</p>
        pub fn options(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.options.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.options = Some(hash_map);
            self
        }
        /// <p>The status of advanced options for the specified domain.</p>
        pub fn set_options(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.options = input;
            self
        }
        /// <p>The <code>OptionStatus</code> for advanced options for the specified domain. </p>
        pub fn status(mut self, input: crate::model::OptionStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The <code>OptionStatus</code> for advanced options for the specified domain. </p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::OptionStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// Consumes the builder and constructs a [`AdvancedOptionsStatus`](crate::model::AdvancedOptionsStatus)
        pub fn build(self) -> crate::model::AdvancedOptionsStatus {
            crate::model::AdvancedOptionsStatus {
                options: self.options,
                status: self.status,
            }
        }
    }
}
impl AdvancedOptionsStatus {
    /// Creates a new builder-style object to manufacture [`AdvancedOptionsStatus`](crate::model::AdvancedOptionsStatus)
    pub fn builder() -> crate::model::advanced_options_status::Builder {
        crate::model::advanced_options_status::Builder::default()
    }
}

/// <p>Status of the node-to-node encryption options for the specified domain.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NodeToNodeEncryptionOptionsStatus {
    /// <p>The node-to-node encryption options for the specified domain.</p>
    pub options: std::option::Option<crate::model::NodeToNodeEncryptionOptions>,
    /// <p>The status of the node-to-node encryption options for the specified domain.</p>
    pub status: std::option::Option<crate::model::OptionStatus>,
}
impl NodeToNodeEncryptionOptionsStatus {
    /// <p>The node-to-node encryption options for the specified domain.</p>
    pub fn options(&self) -> std::option::Option<&crate::model::NodeToNodeEncryptionOptions> {
        self.options.as_ref()
    }
    /// <p>The status of the node-to-node encryption options for the specified domain.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::OptionStatus> {
        self.status.as_ref()
    }
}
impl std::fmt::Debug for NodeToNodeEncryptionOptionsStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NodeToNodeEncryptionOptionsStatus");
        formatter.field("options", &self.options);
        formatter.field("status", &self.status);
        formatter.finish()
    }
}
/// See [`NodeToNodeEncryptionOptionsStatus`](crate::model::NodeToNodeEncryptionOptionsStatus)
pub mod node_to_node_encryption_options_status {

    /// A builder for [`NodeToNodeEncryptionOptionsStatus`](crate::model::NodeToNodeEncryptionOptionsStatus)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) options: std::option::Option<crate::model::NodeToNodeEncryptionOptions>,
        pub(crate) status: std::option::Option<crate::model::OptionStatus>,
    }
    impl Builder {
        /// <p>The node-to-node encryption options for the specified domain.</p>
        pub fn options(mut self, input: crate::model::NodeToNodeEncryptionOptions) -> Self {
            self.options = Some(input);
            self
        }
        /// <p>The node-to-node encryption options for the specified domain.</p>
        pub fn set_options(
            mut self,
            input: std::option::Option<crate::model::NodeToNodeEncryptionOptions>,
        ) -> Self {
            self.options = input;
            self
        }
        /// <p>The status of the node-to-node encryption options for the specified domain.</p>
        pub fn status(mut self, input: crate::model::OptionStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the node-to-node encryption options for the specified domain.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::OptionStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// Consumes the builder and constructs a [`NodeToNodeEncryptionOptionsStatus`](crate::model::NodeToNodeEncryptionOptionsStatus)
        pub fn build(self) -> crate::model::NodeToNodeEncryptionOptionsStatus {
            crate::model::NodeToNodeEncryptionOptionsStatus {
                options: self.options,
                status: self.status,
            }
        }
    }
}
impl NodeToNodeEncryptionOptionsStatus {
    /// Creates a new builder-style object to manufacture [`NodeToNodeEncryptionOptionsStatus`](crate::model::NodeToNodeEncryptionOptionsStatus)
    pub fn builder() -> crate::model::node_to_node_encryption_options_status::Builder {
        crate::model::node_to_node_encryption_options_status::Builder::default()
    }
}

/// <p>The node-to-node encryption options.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NodeToNodeEncryptionOptions {
    /// <p>True to enable node-to-node encryption.</p>
    pub enabled: std::option::Option<bool>,
}
impl NodeToNodeEncryptionOptions {
    /// <p>True to enable node-to-node encryption.</p>
    pub fn enabled(&self) -> std::option::Option<bool> {
        self.enabled
    }
}
impl std::fmt::Debug for NodeToNodeEncryptionOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NodeToNodeEncryptionOptions");
        formatter.field("enabled", &self.enabled);
        formatter.finish()
    }
}
/// See [`NodeToNodeEncryptionOptions`](crate::model::NodeToNodeEncryptionOptions)
pub mod node_to_node_encryption_options {

    /// A builder for [`NodeToNodeEncryptionOptions`](crate::model::NodeToNodeEncryptionOptions)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) enabled: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>True to enable node-to-node encryption.</p>
        pub fn enabled(mut self, input: bool) -> Self {
            self.enabled = Some(input);
            self
        }
        /// <p>True to enable node-to-node encryption.</p>
        pub fn set_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.enabled = input;
            self
        }
        /// Consumes the builder and constructs a [`NodeToNodeEncryptionOptions`](crate::model::NodeToNodeEncryptionOptions)
        pub fn build(self) -> crate::model::NodeToNodeEncryptionOptions {
            crate::model::NodeToNodeEncryptionOptions {
                enabled: self.enabled,
            }
        }
    }
}
impl NodeToNodeEncryptionOptions {
    /// Creates a new builder-style object to manufacture [`NodeToNodeEncryptionOptions`](crate::model::NodeToNodeEncryptionOptions)
    pub fn builder() -> crate::model::node_to_node_encryption_options::Builder {
        crate::model::node_to_node_encryption_options::Builder::default()
    }
}

/// <p>Status of the encryption At Rest options for the specified domain.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EncryptionAtRestOptionsStatus {
    /// <p>The Encryption At Rest options for the specified domain.</p>
    pub options: std::option::Option<crate::model::EncryptionAtRestOptions>,
    /// <p>The status of the Encryption At Rest options for the specified domain.</p>
    pub status: std::option::Option<crate::model::OptionStatus>,
}
impl EncryptionAtRestOptionsStatus {
    /// <p>The Encryption At Rest options for the specified domain.</p>
    pub fn options(&self) -> std::option::Option<&crate::model::EncryptionAtRestOptions> {
        self.options.as_ref()
    }
    /// <p>The status of the Encryption At Rest options for the specified domain.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::OptionStatus> {
        self.status.as_ref()
    }
}
impl std::fmt::Debug for EncryptionAtRestOptionsStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EncryptionAtRestOptionsStatus");
        formatter.field("options", &self.options);
        formatter.field("status", &self.status);
        formatter.finish()
    }
}
/// See [`EncryptionAtRestOptionsStatus`](crate::model::EncryptionAtRestOptionsStatus)
pub mod encryption_at_rest_options_status {

    /// A builder for [`EncryptionAtRestOptionsStatus`](crate::model::EncryptionAtRestOptionsStatus)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) options: std::option::Option<crate::model::EncryptionAtRestOptions>,
        pub(crate) status: std::option::Option<crate::model::OptionStatus>,
    }
    impl Builder {
        /// <p>The Encryption At Rest options for the specified domain.</p>
        pub fn options(mut self, input: crate::model::EncryptionAtRestOptions) -> Self {
            self.options = Some(input);
            self
        }
        /// <p>The Encryption At Rest options for the specified domain.</p>
        pub fn set_options(
            mut self,
            input: std::option::Option<crate::model::EncryptionAtRestOptions>,
        ) -> Self {
            self.options = input;
            self
        }
        /// <p>The status of the Encryption At Rest options for the specified domain.</p>
        pub fn status(mut self, input: crate::model::OptionStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the Encryption At Rest options for the specified domain.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::OptionStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// Consumes the builder and constructs a [`EncryptionAtRestOptionsStatus`](crate::model::EncryptionAtRestOptionsStatus)
        pub fn build(self) -> crate::model::EncryptionAtRestOptionsStatus {
            crate::model::EncryptionAtRestOptionsStatus {
                options: self.options,
                status: self.status,
            }
        }
    }
}
impl EncryptionAtRestOptionsStatus {
    /// Creates a new builder-style object to manufacture [`EncryptionAtRestOptionsStatus`](crate::model::EncryptionAtRestOptionsStatus)
    pub fn builder() -> crate::model::encryption_at_rest_options_status::Builder {
        crate::model::encryption_at_rest_options_status::Builder::default()
    }
}

/// <p>Specifies encryption at rest options.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EncryptionAtRestOptions {
    /// <p>The option to enable encryption at rest.</p>
    pub enabled: std::option::Option<bool>,
    /// <p>The KMS key ID for encryption at rest options.</p>
    pub kms_key_id: std::option::Option<std::string::String>,
}
impl EncryptionAtRestOptions {
    /// <p>The option to enable encryption at rest.</p>
    pub fn enabled(&self) -> std::option::Option<bool> {
        self.enabled
    }
    /// <p>The KMS key ID for encryption at rest options.</p>
    pub fn kms_key_id(&self) -> std::option::Option<&str> {
        self.kms_key_id.as_deref()
    }
}
impl std::fmt::Debug for EncryptionAtRestOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EncryptionAtRestOptions");
        formatter.field("enabled", &self.enabled);
        formatter.field("kms_key_id", &self.kms_key_id);
        formatter.finish()
    }
}
/// See [`EncryptionAtRestOptions`](crate::model::EncryptionAtRestOptions)
pub mod encryption_at_rest_options {

    /// A builder for [`EncryptionAtRestOptions`](crate::model::EncryptionAtRestOptions)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) enabled: std::option::Option<bool>,
        pub(crate) kms_key_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The option to enable encryption at rest.</p>
        pub fn enabled(mut self, input: bool) -> Self {
            self.enabled = Some(input);
            self
        }
        /// <p>The option to enable encryption at rest.</p>
        pub fn set_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.enabled = input;
            self
        }
        /// <p>The KMS key ID for encryption at rest options.</p>
        pub fn kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.kms_key_id = Some(input.into());
            self
        }
        /// <p>The KMS key ID for encryption at rest options.</p>
        pub fn set_kms_key_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.kms_key_id = input;
            self
        }
        /// Consumes the builder and constructs a [`EncryptionAtRestOptions`](crate::model::EncryptionAtRestOptions)
        pub fn build(self) -> crate::model::EncryptionAtRestOptions {
            crate::model::EncryptionAtRestOptions {
                enabled: self.enabled,
                kms_key_id: self.kms_key_id,
            }
        }
    }
}
impl EncryptionAtRestOptions {
    /// Creates a new builder-style object to manufacture [`EncryptionAtRestOptions`](crate::model::EncryptionAtRestOptions)
    pub fn builder() -> crate::model::encryption_at_rest_options::Builder {
        crate::model::encryption_at_rest_options::Builder::default()
    }
}

/// <p>The status of the Cognito options for the specified domain.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CognitoOptionsStatus {
    /// <p>Cognito options for the specified domain.</p>
    pub options: std::option::Option<crate::model::CognitoOptions>,
    /// <p>The status of the Cognito options for the specified domain.</p>
    pub status: std::option::Option<crate::model::OptionStatus>,
}
impl CognitoOptionsStatus {
    /// <p>Cognito options for the specified domain.</p>
    pub fn options(&self) -> std::option::Option<&crate::model::CognitoOptions> {
        self.options.as_ref()
    }
    /// <p>The status of the Cognito options for the specified domain.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::OptionStatus> {
        self.status.as_ref()
    }
}
impl std::fmt::Debug for CognitoOptionsStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CognitoOptionsStatus");
        formatter.field("options", &self.options);
        formatter.field("status", &self.status);
        formatter.finish()
    }
}
/// See [`CognitoOptionsStatus`](crate::model::CognitoOptionsStatus)
pub mod cognito_options_status {

    /// A builder for [`CognitoOptionsStatus`](crate::model::CognitoOptionsStatus)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) options: std::option::Option<crate::model::CognitoOptions>,
        pub(crate) status: std::option::Option<crate::model::OptionStatus>,
    }
    impl Builder {
        /// <p>Cognito options for the specified domain.</p>
        pub fn options(mut self, input: crate::model::CognitoOptions) -> Self {
            self.options = Some(input);
            self
        }
        /// <p>Cognito options for the specified domain.</p>
        pub fn set_options(
            mut self,
            input: std::option::Option<crate::model::CognitoOptions>,
        ) -> Self {
            self.options = input;
            self
        }
        /// <p>The status of the Cognito options for the specified domain.</p>
        pub fn status(mut self, input: crate::model::OptionStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the Cognito options for the specified domain.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::OptionStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// Consumes the builder and constructs a [`CognitoOptionsStatus`](crate::model::CognitoOptionsStatus)
        pub fn build(self) -> crate::model::CognitoOptionsStatus {
            crate::model::CognitoOptionsStatus {
                options: self.options,
                status: self.status,
            }
        }
    }
}
impl CognitoOptionsStatus {
    /// Creates a new builder-style object to manufacture [`CognitoOptionsStatus`](crate::model::CognitoOptionsStatus)
    pub fn builder() -> crate::model::cognito_options_status::Builder {
        crate::model::cognito_options_status::Builder::default()
    }
}

/// <p>Options to specify the Cognito user and identity pools for OpenSearch Dashboards authentication. For more information, see <a href="http://docs.aws.amazon.com/opensearch-service/latest/developerguide/cognito-auth.html" target="_blank">Configuring Amazon Cognito authentication for OpenSearch Dashboards</a>. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CognitoOptions {
    /// <p>The option to enable Cognito for OpenSearch Dashboards authentication.</p>
    pub enabled: std::option::Option<bool>,
    /// <p>The Cognito user pool ID for OpenSearch Dashboards authentication.</p>
    pub user_pool_id: std::option::Option<std::string::String>,
    /// <p>The Cognito identity pool ID for OpenSearch Dashboards authentication.</p>
    pub identity_pool_id: std::option::Option<std::string::String>,
    /// <p>The role ARN that provides OpenSearch permissions for accessing Cognito resources.</p>
    pub role_arn: std::option::Option<std::string::String>,
}
impl CognitoOptions {
    /// <p>The option to enable Cognito for OpenSearch Dashboards authentication.</p>
    pub fn enabled(&self) -> std::option::Option<bool> {
        self.enabled
    }
    /// <p>The Cognito user pool ID for OpenSearch Dashboards authentication.</p>
    pub fn user_pool_id(&self) -> std::option::Option<&str> {
        self.user_pool_id.as_deref()
    }
    /// <p>The Cognito identity pool ID for OpenSearch Dashboards authentication.</p>
    pub fn identity_pool_id(&self) -> std::option::Option<&str> {
        self.identity_pool_id.as_deref()
    }
    /// <p>The role ARN that provides OpenSearch permissions for accessing Cognito resources.</p>
    pub fn role_arn(&self) -> std::option::Option<&str> {
        self.role_arn.as_deref()
    }
}
impl std::fmt::Debug for CognitoOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CognitoOptions");
        formatter.field("enabled", &self.enabled);
        formatter.field("user_pool_id", &self.user_pool_id);
        formatter.field("identity_pool_id", &self.identity_pool_id);
        formatter.field("role_arn", &self.role_arn);
        formatter.finish()
    }
}
/// See [`CognitoOptions`](crate::model::CognitoOptions)
pub mod cognito_options {

    /// A builder for [`CognitoOptions`](crate::model::CognitoOptions)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) enabled: std::option::Option<bool>,
        pub(crate) user_pool_id: std::option::Option<std::string::String>,
        pub(crate) identity_pool_id: std::option::Option<std::string::String>,
        pub(crate) role_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The option to enable Cognito for OpenSearch Dashboards authentication.</p>
        pub fn enabled(mut self, input: bool) -> Self {
            self.enabled = Some(input);
            self
        }
        /// <p>The option to enable Cognito for OpenSearch Dashboards authentication.</p>
        pub fn set_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.enabled = input;
            self
        }
        /// <p>The Cognito user pool ID for OpenSearch Dashboards authentication.</p>
        pub fn user_pool_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.user_pool_id = Some(input.into());
            self
        }
        /// <p>The Cognito user pool ID for OpenSearch Dashboards authentication.</p>
        pub fn set_user_pool_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.user_pool_id = input;
            self
        }
        /// <p>The Cognito identity pool ID for OpenSearch Dashboards authentication.</p>
        pub fn identity_pool_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.identity_pool_id = Some(input.into());
            self
        }
        /// <p>The Cognito identity pool ID for OpenSearch Dashboards authentication.</p>
        pub fn set_identity_pool_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.identity_pool_id = input;
            self
        }
        /// <p>The role ARN that provides OpenSearch permissions for accessing Cognito resources.</p>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.role_arn = Some(input.into());
            self
        }
        /// <p>The role ARN that provides OpenSearch permissions for accessing Cognito resources.</p>
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.role_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`CognitoOptions`](crate::model::CognitoOptions)
        pub fn build(self) -> crate::model::CognitoOptions {
            crate::model::CognitoOptions {
                enabled: self.enabled,
                user_pool_id: self.user_pool_id,
                identity_pool_id: self.identity_pool_id,
                role_arn: self.role_arn,
            }
        }
    }
}
impl CognitoOptions {
    /// Creates a new builder-style object to manufacture [`CognitoOptions`](crate::model::CognitoOptions)
    pub fn builder() -> crate::model::cognito_options::Builder {
        crate::model::cognito_options::Builder::default()
    }
}

/// <p>Status of the VPC options for the specified domain.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct VpcDerivedInfoStatus {
    /// <p>The VPC options for the specified domain.</p>
    pub options: std::option::Option<crate::model::VpcDerivedInfo>,
    /// <p>The status of the VPC options for the specified domain.</p>
    pub status: std::option::Option<crate::model::OptionStatus>,
}
impl VpcDerivedInfoStatus {
    /// <p>The VPC options for the specified domain.</p>
    pub fn options(&self) -> std::option::Option<&crate::model::VpcDerivedInfo> {
        self.options.as_ref()
    }
    /// <p>The status of the VPC options for the specified domain.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::OptionStatus> {
        self.status.as_ref()
    }
}
impl std::fmt::Debug for VpcDerivedInfoStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("VpcDerivedInfoStatus");
        formatter.field("options", &self.options);
        formatter.field("status", &self.status);
        formatter.finish()
    }
}
/// See [`VpcDerivedInfoStatus`](crate::model::VpcDerivedInfoStatus)
pub mod vpc_derived_info_status {

    /// A builder for [`VpcDerivedInfoStatus`](crate::model::VpcDerivedInfoStatus)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) options: std::option::Option<crate::model::VpcDerivedInfo>,
        pub(crate) status: std::option::Option<crate::model::OptionStatus>,
    }
    impl Builder {
        /// <p>The VPC options for the specified domain.</p>
        pub fn options(mut self, input: crate::model::VpcDerivedInfo) -> Self {
            self.options = Some(input);
            self
        }
        /// <p>The VPC options for the specified domain.</p>
        pub fn set_options(
            mut self,
            input: std::option::Option<crate::model::VpcDerivedInfo>,
        ) -> Self {
            self.options = input;
            self
        }
        /// <p>The status of the VPC options for the specified domain.</p>
        pub fn status(mut self, input: crate::model::OptionStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the VPC options for the specified domain.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::OptionStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// Consumes the builder and constructs a [`VpcDerivedInfoStatus`](crate::model::VpcDerivedInfoStatus)
        pub fn build(self) -> crate::model::VpcDerivedInfoStatus {
            crate::model::VpcDerivedInfoStatus {
                options: self.options,
                status: self.status,
            }
        }
    }
}
impl VpcDerivedInfoStatus {
    /// Creates a new builder-style object to manufacture [`VpcDerivedInfoStatus`](crate::model::VpcDerivedInfoStatus)
    pub fn builder() -> crate::model::vpc_derived_info_status::Builder {
        crate::model::vpc_derived_info_status::Builder::default()
    }
}

/// <p>Options to specify the subnets and security groups for the VPC endpoint. For more information, see <a href="http://docs.aws.amazon.com/opensearch-service/latest/developerguide/vpc.html" target="_blank"> Launching your Amazon OpenSearch Service domains using a VPC</a>. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct VpcDerivedInfo {
    /// <p>The VPC ID for the domain. Exists only if the domain was created with <code>VPCOptions</code>.</p>
    pub vpc_id: std::option::Option<std::string::String>,
    /// <p>The subnets for the VPC endpoint.</p>
    pub subnet_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The Availability Zones for the domain. Exists only if the domain was created with <code>VPCOptions</code>.</p>
    pub availability_zones: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The security groups for the VPC endpoint.</p>
    pub security_group_ids: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl VpcDerivedInfo {
    /// <p>The VPC ID for the domain. Exists only if the domain was created with <code>VPCOptions</code>.</p>
    pub fn vpc_id(&self) -> std::option::Option<&str> {
        self.vpc_id.as_deref()
    }
    /// <p>The subnets for the VPC endpoint.</p>
    pub fn subnet_ids(&self) -> std::option::Option<&[std::string::String]> {
        self.subnet_ids.as_deref()
    }
    /// <p>The Availability Zones for the domain. Exists only if the domain was created with <code>VPCOptions</code>.</p>
    pub fn availability_zones(&self) -> std::option::Option<&[std::string::String]> {
        self.availability_zones.as_deref()
    }
    /// <p>The security groups for the VPC endpoint.</p>
    pub fn security_group_ids(&self) -> std::option::Option<&[std::string::String]> {
        self.security_group_ids.as_deref()
    }
}
impl std::fmt::Debug for VpcDerivedInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("VpcDerivedInfo");
        formatter.field("vpc_id", &self.vpc_id);
        formatter.field("subnet_ids", &self.subnet_ids);
        formatter.field("availability_zones", &self.availability_zones);
        formatter.field("security_group_ids", &self.security_group_ids);
        formatter.finish()
    }
}
/// See [`VpcDerivedInfo`](crate::model::VpcDerivedInfo)
pub mod vpc_derived_info {

    /// A builder for [`VpcDerivedInfo`](crate::model::VpcDerivedInfo)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) vpc_id: std::option::Option<std::string::String>,
        pub(crate) subnet_ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) availability_zones: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) security_group_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The VPC ID for the domain. Exists only if the domain was created with <code>VPCOptions</code>.</p>
        pub fn vpc_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.vpc_id = Some(input.into());
            self
        }
        /// <p>The VPC ID for the domain. Exists only if the domain was created with <code>VPCOptions</code>.</p>
        pub fn set_vpc_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.vpc_id = input;
            self
        }
        /// Appends an item to `subnet_ids`.
        ///
        /// To override the contents of this collection use [`set_subnet_ids`](Self::set_subnet_ids).
        ///
        /// <p>The subnets for the VPC endpoint.</p>
        pub fn subnet_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.subnet_ids.unwrap_or_default();
            v.push(input.into());
            self.subnet_ids = Some(v);
            self
        }
        /// <p>The subnets for the VPC endpoint.</p>
        pub fn set_subnet_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.subnet_ids = input;
            self
        }
        /// Appends an item to `availability_zones`.
        ///
        /// To override the contents of this collection use [`set_availability_zones`](Self::set_availability_zones).
        ///
        /// <p>The Availability Zones for the domain. Exists only if the domain was created with <code>VPCOptions</code>.</p>
        pub fn availability_zones(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.availability_zones.unwrap_or_default();
            v.push(input.into());
            self.availability_zones = Some(v);
            self
        }
        /// <p>The Availability Zones for the domain. Exists only if the domain was created with <code>VPCOptions</code>.</p>
        pub fn set_availability_zones(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.availability_zones = input;
            self
        }
        /// Appends an item to `security_group_ids`.
        ///
        /// To override the contents of this collection use [`set_security_group_ids`](Self::set_security_group_ids).
        ///
        /// <p>The security groups for the VPC endpoint.</p>
        pub fn security_group_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.security_group_ids.unwrap_or_default();
            v.push(input.into());
            self.security_group_ids = Some(v);
            self
        }
        /// <p>The security groups for the VPC endpoint.</p>
        pub fn set_security_group_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.security_group_ids = input;
            self
        }
        /// Consumes the builder and constructs a [`VpcDerivedInfo`](crate::model::VpcDerivedInfo)
        pub fn build(self) -> crate::model::VpcDerivedInfo {
            crate::model::VpcDerivedInfo {
                vpc_id: self.vpc_id,
                subnet_ids: self.subnet_ids,
                availability_zones: self.availability_zones,
                security_group_ids: self.security_group_ids,
            }
        }
    }
}
impl VpcDerivedInfo {
    /// Creates a new builder-style object to manufacture [`VpcDerivedInfo`](crate::model::VpcDerivedInfo)
    pub fn builder() -> crate::model::vpc_derived_info::Builder {
        crate::model::vpc_derived_info::Builder::default()
    }
}

/// <p>Status of a daily automated snapshot.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SnapshotOptionsStatus {
    /// <p>The daily snapshot options specified for the domain.</p>
    pub options: std::option::Option<crate::model::SnapshotOptions>,
    /// <p>The status of a daily automated snapshot.</p>
    pub status: std::option::Option<crate::model::OptionStatus>,
}
impl SnapshotOptionsStatus {
    /// <p>The daily snapshot options specified for the domain.</p>
    pub fn options(&self) -> std::option::Option<&crate::model::SnapshotOptions> {
        self.options.as_ref()
    }
    /// <p>The status of a daily automated snapshot.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::OptionStatus> {
        self.status.as_ref()
    }
}
impl std::fmt::Debug for SnapshotOptionsStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SnapshotOptionsStatus");
        formatter.field("options", &self.options);
        formatter.field("status", &self.status);
        formatter.finish()
    }
}
/// See [`SnapshotOptionsStatus`](crate::model::SnapshotOptionsStatus)
pub mod snapshot_options_status {

    /// A builder for [`SnapshotOptionsStatus`](crate::model::SnapshotOptionsStatus)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) options: std::option::Option<crate::model::SnapshotOptions>,
        pub(crate) status: std::option::Option<crate::model::OptionStatus>,
    }
    impl Builder {
        /// <p>The daily snapshot options specified for the domain.</p>
        pub fn options(mut self, input: crate::model::SnapshotOptions) -> Self {
            self.options = Some(input);
            self
        }
        /// <p>The daily snapshot options specified for the domain.</p>
        pub fn set_options(
            mut self,
            input: std::option::Option<crate::model::SnapshotOptions>,
        ) -> Self {
            self.options = input;
            self
        }
        /// <p>The status of a daily automated snapshot.</p>
        pub fn status(mut self, input: crate::model::OptionStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of a daily automated snapshot.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::OptionStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// Consumes the builder and constructs a [`SnapshotOptionsStatus`](crate::model::SnapshotOptionsStatus)
        pub fn build(self) -> crate::model::SnapshotOptionsStatus {
            crate::model::SnapshotOptionsStatus {
                options: self.options,
                status: self.status,
            }
        }
    }
}
impl SnapshotOptionsStatus {
    /// Creates a new builder-style object to manufacture [`SnapshotOptionsStatus`](crate::model::SnapshotOptionsStatus)
    pub fn builder() -> crate::model::snapshot_options_status::Builder {
        crate::model::snapshot_options_status::Builder::default()
    }
}

/// <p>The time, in UTC format, when the service takes a daily automated snapshot of the specified domain. Default is <code>0</code> hours. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SnapshotOptions {
    /// <p>The time, in UTC format, when the service takes a daily automated snapshot of the specified domain. Default is <code>0</code> hours. </p>
    pub automated_snapshot_start_hour: std::option::Option<i32>,
}
impl SnapshotOptions {
    /// <p>The time, in UTC format, when the service takes a daily automated snapshot of the specified domain. Default is <code>0</code> hours. </p>
    pub fn automated_snapshot_start_hour(&self) -> std::option::Option<i32> {
        self.automated_snapshot_start_hour
    }
}
impl std::fmt::Debug for SnapshotOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SnapshotOptions");
        formatter.field(
            "automated_snapshot_start_hour",
            &self.automated_snapshot_start_hour,
        );
        formatter.finish()
    }
}
/// See [`SnapshotOptions`](crate::model::SnapshotOptions)
pub mod snapshot_options {

    /// A builder for [`SnapshotOptions`](crate::model::SnapshotOptions)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) automated_snapshot_start_hour: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The time, in UTC format, when the service takes a daily automated snapshot of the specified domain. Default is <code>0</code> hours. </p>
        pub fn automated_snapshot_start_hour(mut self, input: i32) -> Self {
            self.automated_snapshot_start_hour = Some(input);
            self
        }
        /// <p>The time, in UTC format, when the service takes a daily automated snapshot of the specified domain. Default is <code>0</code> hours. </p>
        pub fn set_automated_snapshot_start_hour(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.automated_snapshot_start_hour = input;
            self
        }
        /// Consumes the builder and constructs a [`SnapshotOptions`](crate::model::SnapshotOptions)
        pub fn build(self) -> crate::model::SnapshotOptions {
            crate::model::SnapshotOptions {
                automated_snapshot_start_hour: self.automated_snapshot_start_hour,
            }
        }
    }
}
impl SnapshotOptions {
    /// Creates a new builder-style object to manufacture [`SnapshotOptions`](crate::model::SnapshotOptions)
    pub fn builder() -> crate::model::snapshot_options::Builder {
        crate::model::snapshot_options::Builder::default()
    }
}

/// <p>The configured access rules for the domain's document and search endpoints, and the current status of those rules. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AccessPoliciesStatus {
    /// <p>The access policy configured for the domain. Access policies can be resource-based, IP-based, or IAM-based. See <a href="http://docs.aws.amazon.com/opensearch-service/latest/developerguide/createupdatedomains.html#createdomain-configure-access-policies" target="_blank"> Configuring access policies</a>for more information. </p>
    pub options: std::option::Option<std::string::String>,
    /// <p>The status of the access policy for the domain. See <code>OptionStatus</code> for the status information that's included. </p>
    pub status: std::option::Option<crate::model::OptionStatus>,
}
impl AccessPoliciesStatus {
    /// <p>The access policy configured for the domain. Access policies can be resource-based, IP-based, or IAM-based. See <a href="http://docs.aws.amazon.com/opensearch-service/latest/developerguide/createupdatedomains.html#createdomain-configure-access-policies" target="_blank"> Configuring access policies</a>for more information. </p>
    pub fn options(&self) -> std::option::Option<&str> {
        self.options.as_deref()
    }
    /// <p>The status of the access policy for the domain. See <code>OptionStatus</code> for the status information that's included. </p>
    pub fn status(&self) -> std::option::Option<&crate::model::OptionStatus> {
        self.status.as_ref()
    }
}
impl std::fmt::Debug for AccessPoliciesStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AccessPoliciesStatus");
        formatter.field("options", &self.options);
        formatter.field("status", &self.status);
        formatter.finish()
    }
}
/// See [`AccessPoliciesStatus`](crate::model::AccessPoliciesStatus)
pub mod access_policies_status {

    /// A builder for [`AccessPoliciesStatus`](crate::model::AccessPoliciesStatus)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) options: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::OptionStatus>,
    }
    impl Builder {
        /// <p>The access policy configured for the domain. Access policies can be resource-based, IP-based, or IAM-based. See <a href="http://docs.aws.amazon.com/opensearch-service/latest/developerguide/createupdatedomains.html#createdomain-configure-access-policies" target="_blank"> Configuring access policies</a>for more information. </p>
        pub fn options(mut self, input: impl Into<std::string::String>) -> Self {
            self.options = Some(input.into());
            self
        }
        /// <p>The access policy configured for the domain. Access policies can be resource-based, IP-based, or IAM-based. See <a href="http://docs.aws.amazon.com/opensearch-service/latest/developerguide/createupdatedomains.html#createdomain-configure-access-policies" target="_blank"> Configuring access policies</a>for more information. </p>
        pub fn set_options(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.options = input;
            self
        }
        /// <p>The status of the access policy for the domain. See <code>OptionStatus</code> for the status information that's included. </p>
        pub fn status(mut self, input: crate::model::OptionStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the access policy for the domain. See <code>OptionStatus</code> for the status information that's included. </p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::OptionStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// Consumes the builder and constructs a [`AccessPoliciesStatus`](crate::model::AccessPoliciesStatus)
        pub fn build(self) -> crate::model::AccessPoliciesStatus {
            crate::model::AccessPoliciesStatus {
                options: self.options,
                status: self.status,
            }
        }
    }
}
impl AccessPoliciesStatus {
    /// Creates a new builder-style object to manufacture [`AccessPoliciesStatus`](crate::model::AccessPoliciesStatus)
    pub fn builder() -> crate::model::access_policies_status::Builder {
        crate::model::access_policies_status::Builder::default()
    }
}

/// <p>Status of the EBS options for the specified domain.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EbsOptionsStatus {
    /// <p>The EBS options for the specified domain.</p>
    pub options: std::option::Option<crate::model::EbsOptions>,
    /// <p>The status of the EBS options for the specified domain.</p>
    pub status: std::option::Option<crate::model::OptionStatus>,
}
impl EbsOptionsStatus {
    /// <p>The EBS options for the specified domain.</p>
    pub fn options(&self) -> std::option::Option<&crate::model::EbsOptions> {
        self.options.as_ref()
    }
    /// <p>The status of the EBS options for the specified domain.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::OptionStatus> {
        self.status.as_ref()
    }
}
impl std::fmt::Debug for EbsOptionsStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EbsOptionsStatus");
        formatter.field("options", &self.options);
        formatter.field("status", &self.status);
        formatter.finish()
    }
}
/// See [`EbsOptionsStatus`](crate::model::EbsOptionsStatus)
pub mod ebs_options_status {

    /// A builder for [`EbsOptionsStatus`](crate::model::EbsOptionsStatus)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) options: std::option::Option<crate::model::EbsOptions>,
        pub(crate) status: std::option::Option<crate::model::OptionStatus>,
    }
    impl Builder {
        /// <p>The EBS options for the specified domain.</p>
        pub fn options(mut self, input: crate::model::EbsOptions) -> Self {
            self.options = Some(input);
            self
        }
        /// <p>The EBS options for the specified domain.</p>
        pub fn set_options(mut self, input: std::option::Option<crate::model::EbsOptions>) -> Self {
            self.options = input;
            self
        }
        /// <p>The status of the EBS options for the specified domain.</p>
        pub fn status(mut self, input: crate::model::OptionStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the EBS options for the specified domain.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::OptionStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// Consumes the builder and constructs a [`EbsOptionsStatus`](crate::model::EbsOptionsStatus)
        pub fn build(self) -> crate::model::EbsOptionsStatus {
            crate::model::EbsOptionsStatus {
                options: self.options,
                status: self.status,
            }
        }
    }
}
impl EbsOptionsStatus {
    /// Creates a new builder-style object to manufacture [`EbsOptionsStatus`](crate::model::EbsOptionsStatus)
    pub fn builder() -> crate::model::ebs_options_status::Builder {
        crate::model::ebs_options_status::Builder::default()
    }
}

/// <p>Options to enable, disable, and specify the properties of EBS storage volumes.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EbsOptions {
    /// <p>Whether EBS-based storage is enabled.</p>
    pub ebs_enabled: std::option::Option<bool>,
    /// <p>The volume type for EBS-based storage.</p>
    pub volume_type: std::option::Option<crate::model::VolumeType>,
    /// <p>Integer to specify the size of an EBS volume.</p>
    pub volume_size: std::option::Option<i32>,
    /// <p>The IOPD for a Provisioned IOPS EBS volume (SSD).</p>
    pub iops: std::option::Option<i32>,
}
impl EbsOptions {
    /// <p>Whether EBS-based storage is enabled.</p>
    pub fn ebs_enabled(&self) -> std::option::Option<bool> {
        self.ebs_enabled
    }
    /// <p>The volume type for EBS-based storage.</p>
    pub fn volume_type(&self) -> std::option::Option<&crate::model::VolumeType> {
        self.volume_type.as_ref()
    }
    /// <p>Integer to specify the size of an EBS volume.</p>
    pub fn volume_size(&self) -> std::option::Option<i32> {
        self.volume_size
    }
    /// <p>The IOPD for a Provisioned IOPS EBS volume (SSD).</p>
    pub fn iops(&self) -> std::option::Option<i32> {
        self.iops
    }
}
impl std::fmt::Debug for EbsOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EbsOptions");
        formatter.field("ebs_enabled", &self.ebs_enabled);
        formatter.field("volume_type", &self.volume_type);
        formatter.field("volume_size", &self.volume_size);
        formatter.field("iops", &self.iops);
        formatter.finish()
    }
}
/// See [`EbsOptions`](crate::model::EbsOptions)
pub mod ebs_options {

    /// A builder for [`EbsOptions`](crate::model::EbsOptions)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) ebs_enabled: std::option::Option<bool>,
        pub(crate) volume_type: std::option::Option<crate::model::VolumeType>,
        pub(crate) volume_size: std::option::Option<i32>,
        pub(crate) iops: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>Whether EBS-based storage is enabled.</p>
        pub fn ebs_enabled(mut self, input: bool) -> Self {
            self.ebs_enabled = Some(input);
            self
        }
        /// <p>Whether EBS-based storage is enabled.</p>
        pub fn set_ebs_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.ebs_enabled = input;
            self
        }
        /// <p>The volume type for EBS-based storage.</p>
        pub fn volume_type(mut self, input: crate::model::VolumeType) -> Self {
            self.volume_type = Some(input);
            self
        }
        /// <p>The volume type for EBS-based storage.</p>
        pub fn set_volume_type(
            mut self,
            input: std::option::Option<crate::model::VolumeType>,
        ) -> Self {
            self.volume_type = input;
            self
        }
        /// <p>Integer to specify the size of an EBS volume.</p>
        pub fn volume_size(mut self, input: i32) -> Self {
            self.volume_size = Some(input);
            self
        }
        /// <p>Integer to specify the size of an EBS volume.</p>
        pub fn set_volume_size(mut self, input: std::option::Option<i32>) -> Self {
            self.volume_size = input;
            self
        }
        /// <p>The IOPD for a Provisioned IOPS EBS volume (SSD).</p>
        pub fn iops(mut self, input: i32) -> Self {
            self.iops = Some(input);
            self
        }
        /// <p>The IOPD for a Provisioned IOPS EBS volume (SSD).</p>
        pub fn set_iops(mut self, input: std::option::Option<i32>) -> Self {
            self.iops = input;
            self
        }
        /// Consumes the builder and constructs a [`EbsOptions`](crate::model::EbsOptions)
        pub fn build(self) -> crate::model::EbsOptions {
            crate::model::EbsOptions {
                ebs_enabled: self.ebs_enabled,
                volume_type: self.volume_type,
                volume_size: self.volume_size,
                iops: self.iops,
            }
        }
    }
}
impl EbsOptions {
    /// Creates a new builder-style object to manufacture [`EbsOptions`](crate::model::EbsOptions)
    pub fn builder() -> crate::model::ebs_options::Builder {
        crate::model::ebs_options::Builder::default()
    }
}

/// <p>The type of EBS volume, standard, gp2, or io1. See <a href="http://docs.aws.amazon.com/opensearch-service/latest/developerguide/opensearch-createupdatedomains.html#opensearch-createdomain-configure-ebs" target="_blank">Configuring EBS-based Storage</a> for more information.
/// </p>
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum VolumeType {
    #[allow(missing_docs)] // documentation missing in model
    Gp2,
    #[allow(missing_docs)] // documentation missing in model
    Io1,
    #[allow(missing_docs)] // documentation missing in model
    Standard,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for VolumeType {
    fn from(s: &str) -> Self {
        match s {
            "gp2" => VolumeType::Gp2,
            "io1" => VolumeType::Io1,
            "standard" => VolumeType::Standard,
            other => VolumeType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for VolumeType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(VolumeType::from(s))
    }
}
impl VolumeType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            VolumeType::Gp2 => "gp2",
            VolumeType::Io1 => "io1",
            VolumeType::Standard => "standard",
            VolumeType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["gp2", "io1", "standard"]
    }
}
impl AsRef<str> for VolumeType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The configuration status for the specified domain.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ClusterConfigStatus {
    /// <p>The cluster configuration for the specified domain.</p>
    pub options: std::option::Option<crate::model::ClusterConfig>,
    /// <p>The cluster configuration status for the specified domain.</p>
    pub status: std::option::Option<crate::model::OptionStatus>,
}
impl ClusterConfigStatus {
    /// <p>The cluster configuration for the specified domain.</p>
    pub fn options(&self) -> std::option::Option<&crate::model::ClusterConfig> {
        self.options.as_ref()
    }
    /// <p>The cluster configuration status for the specified domain.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::OptionStatus> {
        self.status.as_ref()
    }
}
impl std::fmt::Debug for ClusterConfigStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ClusterConfigStatus");
        formatter.field("options", &self.options);
        formatter.field("status", &self.status);
        formatter.finish()
    }
}
/// See [`ClusterConfigStatus`](crate::model::ClusterConfigStatus)
pub mod cluster_config_status {

    /// A builder for [`ClusterConfigStatus`](crate::model::ClusterConfigStatus)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) options: std::option::Option<crate::model::ClusterConfig>,
        pub(crate) status: std::option::Option<crate::model::OptionStatus>,
    }
    impl Builder {
        /// <p>The cluster configuration for the specified domain.</p>
        pub fn options(mut self, input: crate::model::ClusterConfig) -> Self {
            self.options = Some(input);
            self
        }
        /// <p>The cluster configuration for the specified domain.</p>
        pub fn set_options(
            mut self,
            input: std::option::Option<crate::model::ClusterConfig>,
        ) -> Self {
            self.options = input;
            self
        }
        /// <p>The cluster configuration status for the specified domain.</p>
        pub fn status(mut self, input: crate::model::OptionStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The cluster configuration status for the specified domain.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::OptionStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// Consumes the builder and constructs a [`ClusterConfigStatus`](crate::model::ClusterConfigStatus)
        pub fn build(self) -> crate::model::ClusterConfigStatus {
            crate::model::ClusterConfigStatus {
                options: self.options,
                status: self.status,
            }
        }
    }
}
impl ClusterConfigStatus {
    /// Creates a new builder-style object to manufacture [`ClusterConfigStatus`](crate::model::ClusterConfigStatus)
    pub fn builder() -> crate::model::cluster_config_status::Builder {
        crate::model::cluster_config_status::Builder::default()
    }
}

/// <p>The configuration for the domain cluster, such as the type and number of instances.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ClusterConfig {
    /// <p>The instance type for an OpenSearch cluster. UltraWarm instance types are not supported for data instances. </p>
    pub instance_type: std::option::Option<crate::model::OpenSearchPartitionInstanceType>,
    /// <p>The number of instances in the specified domain cluster.</p>
    pub instance_count: std::option::Option<i32>,
    /// <p>A boolean value to indicate whether a dedicated master node is enabled. See <a href="http://docs.aws.amazon.com/opensearch-service/latest/developerguide/managedomains.html#managedomains-dedicatedmasternodes" target="_blank">Dedicated master nodes in Amazon OpenSearch Service </a> for more information. </p>
    pub dedicated_master_enabled: std::option::Option<bool>,
    /// <p>A boolean value to indicate whether zone awareness is enabled. See <a href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/managedomains-multiaz.html" target="_blank">Configuring a multi-AZ domain in Amazon OpenSearch Service </a> for more information. </p>
    pub zone_awareness_enabled: std::option::Option<bool>,
    /// <p>The zone awareness configuration for a domain when zone awareness is enabled.</p>
    pub zone_awareness_config: std::option::Option<crate::model::ZoneAwarenessConfig>,
    /// <p>The instance type for a dedicated master node.</p>
    pub dedicated_master_type: std::option::Option<crate::model::OpenSearchPartitionInstanceType>,
    /// <p>Total number of dedicated master nodes, active and on standby, for the cluster.</p>
    pub dedicated_master_count: std::option::Option<i32>,
    /// <p>True to enable UltraWarm storage.</p>
    pub warm_enabled: std::option::Option<bool>,
    /// <p>The instance type for the OpenSearch cluster's warm nodes.</p>
    pub warm_type: std::option::Option<crate::model::OpenSearchWarmPartitionInstanceType>,
    /// <p>The number of UltraWarm nodes in the cluster.</p>
    pub warm_count: std::option::Option<i32>,
    /// <p>Specifies the <code>ColdStorageOptions</code> config for a Domain</p>
    pub cold_storage_options: std::option::Option<crate::model::ColdStorageOptions>,
}
impl ClusterConfig {
    /// <p>The instance type for an OpenSearch cluster. UltraWarm instance types are not supported for data instances. </p>
    pub fn instance_type(
        &self,
    ) -> std::option::Option<&crate::model::OpenSearchPartitionInstanceType> {
        self.instance_type.as_ref()
    }
    /// <p>The number of instances in the specified domain cluster.</p>
    pub fn instance_count(&self) -> std::option::Option<i32> {
        self.instance_count
    }
    /// <p>A boolean value to indicate whether a dedicated master node is enabled. See <a href="http://docs.aws.amazon.com/opensearch-service/latest/developerguide/managedomains.html#managedomains-dedicatedmasternodes" target="_blank">Dedicated master nodes in Amazon OpenSearch Service </a> for more information. </p>
    pub fn dedicated_master_enabled(&self) -> std::option::Option<bool> {
        self.dedicated_master_enabled
    }
    /// <p>A boolean value to indicate whether zone awareness is enabled. See <a href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/managedomains-multiaz.html" target="_blank">Configuring a multi-AZ domain in Amazon OpenSearch Service </a> for more information. </p>
    pub fn zone_awareness_enabled(&self) -> std::option::Option<bool> {
        self.zone_awareness_enabled
    }
    /// <p>The zone awareness configuration for a domain when zone awareness is enabled.</p>
    pub fn zone_awareness_config(&self) -> std::option::Option<&crate::model::ZoneAwarenessConfig> {
        self.zone_awareness_config.as_ref()
    }
    /// <p>The instance type for a dedicated master node.</p>
    pub fn dedicated_master_type(
        &self,
    ) -> std::option::Option<&crate::model::OpenSearchPartitionInstanceType> {
        self.dedicated_master_type.as_ref()
    }
    /// <p>Total number of dedicated master nodes, active and on standby, for the cluster.</p>
    pub fn dedicated_master_count(&self) -> std::option::Option<i32> {
        self.dedicated_master_count
    }
    /// <p>True to enable UltraWarm storage.</p>
    pub fn warm_enabled(&self) -> std::option::Option<bool> {
        self.warm_enabled
    }
    /// <p>The instance type for the OpenSearch cluster's warm nodes.</p>
    pub fn warm_type(
        &self,
    ) -> std::option::Option<&crate::model::OpenSearchWarmPartitionInstanceType> {
        self.warm_type.as_ref()
    }
    /// <p>The number of UltraWarm nodes in the cluster.</p>
    pub fn warm_count(&self) -> std::option::Option<i32> {
        self.warm_count
    }
    /// <p>Specifies the <code>ColdStorageOptions</code> config for a Domain</p>
    pub fn cold_storage_options(&self) -> std::option::Option<&crate::model::ColdStorageOptions> {
        self.cold_storage_options.as_ref()
    }
}
impl std::fmt::Debug for ClusterConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ClusterConfig");
        formatter.field("instance_type", &self.instance_type);
        formatter.field("instance_count", &self.instance_count);
        formatter.field("dedicated_master_enabled", &self.dedicated_master_enabled);
        formatter.field("zone_awareness_enabled", &self.zone_awareness_enabled);
        formatter.field("zone_awareness_config", &self.zone_awareness_config);
        formatter.field("dedicated_master_type", &self.dedicated_master_type);
        formatter.field("dedicated_master_count", &self.dedicated_master_count);
        formatter.field("warm_enabled", &self.warm_enabled);
        formatter.field("warm_type", &self.warm_type);
        formatter.field("warm_count", &self.warm_count);
        formatter.field("cold_storage_options", &self.cold_storage_options);
        formatter.finish()
    }
}
/// See [`ClusterConfig`](crate::model::ClusterConfig)
pub mod cluster_config {

    /// A builder for [`ClusterConfig`](crate::model::ClusterConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_type:
            std::option::Option<crate::model::OpenSearchPartitionInstanceType>,
        pub(crate) instance_count: std::option::Option<i32>,
        pub(crate) dedicated_master_enabled: std::option::Option<bool>,
        pub(crate) zone_awareness_enabled: std::option::Option<bool>,
        pub(crate) zone_awareness_config: std::option::Option<crate::model::ZoneAwarenessConfig>,
        pub(crate) dedicated_master_type:
            std::option::Option<crate::model::OpenSearchPartitionInstanceType>,
        pub(crate) dedicated_master_count: std::option::Option<i32>,
        pub(crate) warm_enabled: std::option::Option<bool>,
        pub(crate) warm_type:
            std::option::Option<crate::model::OpenSearchWarmPartitionInstanceType>,
        pub(crate) warm_count: std::option::Option<i32>,
        pub(crate) cold_storage_options: std::option::Option<crate::model::ColdStorageOptions>,
    }
    impl Builder {
        /// <p>The instance type for an OpenSearch cluster. UltraWarm instance types are not supported for data instances. </p>
        pub fn instance_type(
            mut self,
            input: crate::model::OpenSearchPartitionInstanceType,
        ) -> Self {
            self.instance_type = Some(input);
            self
        }
        /// <p>The instance type for an OpenSearch cluster. UltraWarm instance types are not supported for data instances. </p>
        pub fn set_instance_type(
            mut self,
            input: std::option::Option<crate::model::OpenSearchPartitionInstanceType>,
        ) -> Self {
            self.instance_type = input;
            self
        }
        /// <p>The number of instances in the specified domain cluster.</p>
        pub fn instance_count(mut self, input: i32) -> Self {
            self.instance_count = Some(input);
            self
        }
        /// <p>The number of instances in the specified domain cluster.</p>
        pub fn set_instance_count(mut self, input: std::option::Option<i32>) -> Self {
            self.instance_count = input;
            self
        }
        /// <p>A boolean value to indicate whether a dedicated master node is enabled. See <a href="http://docs.aws.amazon.com/opensearch-service/latest/developerguide/managedomains.html#managedomains-dedicatedmasternodes" target="_blank">Dedicated master nodes in Amazon OpenSearch Service </a> for more information. </p>
        pub fn dedicated_master_enabled(mut self, input: bool) -> Self {
            self.dedicated_master_enabled = Some(input);
            self
        }
        /// <p>A boolean value to indicate whether a dedicated master node is enabled. See <a href="http://docs.aws.amazon.com/opensearch-service/latest/developerguide/managedomains.html#managedomains-dedicatedmasternodes" target="_blank">Dedicated master nodes in Amazon OpenSearch Service </a> for more information. </p>
        pub fn set_dedicated_master_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.dedicated_master_enabled = input;
            self
        }
        /// <p>A boolean value to indicate whether zone awareness is enabled. See <a href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/managedomains-multiaz.html" target="_blank">Configuring a multi-AZ domain in Amazon OpenSearch Service </a> for more information. </p>
        pub fn zone_awareness_enabled(mut self, input: bool) -> Self {
            self.zone_awareness_enabled = Some(input);
            self
        }
        /// <p>A boolean value to indicate whether zone awareness is enabled. See <a href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/managedomains-multiaz.html" target="_blank">Configuring a multi-AZ domain in Amazon OpenSearch Service </a> for more information. </p>
        pub fn set_zone_awareness_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.zone_awareness_enabled = input;
            self
        }
        /// <p>The zone awareness configuration for a domain when zone awareness is enabled.</p>
        pub fn zone_awareness_config(mut self, input: crate::model::ZoneAwarenessConfig) -> Self {
            self.zone_awareness_config = Some(input);
            self
        }
        /// <p>The zone awareness configuration for a domain when zone awareness is enabled.</p>
        pub fn set_zone_awareness_config(
            mut self,
            input: std::option::Option<crate::model::ZoneAwarenessConfig>,
        ) -> Self {
            self.zone_awareness_config = input;
            self
        }
        /// <p>The instance type for a dedicated master node.</p>
        pub fn dedicated_master_type(
            mut self,
            input: crate::model::OpenSearchPartitionInstanceType,
        ) -> Self {
            self.dedicated_master_type = Some(input);
            self
        }
        /// <p>The instance type for a dedicated master node.</p>
        pub fn set_dedicated_master_type(
            mut self,
            input: std::option::Option<crate::model::OpenSearchPartitionInstanceType>,
        ) -> Self {
            self.dedicated_master_type = input;
            self
        }
        /// <p>Total number of dedicated master nodes, active and on standby, for the cluster.</p>
        pub fn dedicated_master_count(mut self, input: i32) -> Self {
            self.dedicated_master_count = Some(input);
            self
        }
        /// <p>Total number of dedicated master nodes, active and on standby, for the cluster.</p>
        pub fn set_dedicated_master_count(mut self, input: std::option::Option<i32>) -> Self {
            self.dedicated_master_count = input;
            self
        }
        /// <p>True to enable UltraWarm storage.</p>
        pub fn warm_enabled(mut self, input: bool) -> Self {
            self.warm_enabled = Some(input);
            self
        }
        /// <p>True to enable UltraWarm storage.</p>
        pub fn set_warm_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.warm_enabled = input;
            self
        }
        /// <p>The instance type for the OpenSearch cluster's warm nodes.</p>
        pub fn warm_type(
            mut self,
            input: crate::model::OpenSearchWarmPartitionInstanceType,
        ) -> Self {
            self.warm_type = Some(input);
            self
        }
        /// <p>The instance type for the OpenSearch cluster's warm nodes.</p>
        pub fn set_warm_type(
            mut self,
            input: std::option::Option<crate::model::OpenSearchWarmPartitionInstanceType>,
        ) -> Self {
            self.warm_type = input;
            self
        }
        /// <p>The number of UltraWarm nodes in the cluster.</p>
        pub fn warm_count(mut self, input: i32) -> Self {
            self.warm_count = Some(input);
            self
        }
        /// <p>The number of UltraWarm nodes in the cluster.</p>
        pub fn set_warm_count(mut self, input: std::option::Option<i32>) -> Self {
            self.warm_count = input;
            self
        }
        /// <p>Specifies the <code>ColdStorageOptions</code> config for a Domain</p>
        pub fn cold_storage_options(mut self, input: crate::model::ColdStorageOptions) -> Self {
            self.cold_storage_options = Some(input);
            self
        }
        /// <p>Specifies the <code>ColdStorageOptions</code> config for a Domain</p>
        pub fn set_cold_storage_options(
            mut self,
            input: std::option::Option<crate::model::ColdStorageOptions>,
        ) -> Self {
            self.cold_storage_options = input;
            self
        }
        /// Consumes the builder and constructs a [`ClusterConfig`](crate::model::ClusterConfig)
        pub fn build(self) -> crate::model::ClusterConfig {
            crate::model::ClusterConfig {
                instance_type: self.instance_type,
                instance_count: self.instance_count,
                dedicated_master_enabled: self.dedicated_master_enabled,
                zone_awareness_enabled: self.zone_awareness_enabled,
                zone_awareness_config: self.zone_awareness_config,
                dedicated_master_type: self.dedicated_master_type,
                dedicated_master_count: self.dedicated_master_count,
                warm_enabled: self.warm_enabled,
                warm_type: self.warm_type,
                warm_count: self.warm_count,
                cold_storage_options: self.cold_storage_options,
            }
        }
    }
}
impl ClusterConfig {
    /// Creates a new builder-style object to manufacture [`ClusterConfig`](crate::model::ClusterConfig)
    pub fn builder() -> crate::model::cluster_config::Builder {
        crate::model::cluster_config::Builder::default()
    }
}

/// <p>Specifies the configuration for cold storage options such as enabled</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ColdStorageOptions {
    /// <p>Enable cold storage option. Accepted values true or false</p>
    pub enabled: std::option::Option<bool>,
}
impl ColdStorageOptions {
    /// <p>Enable cold storage option. Accepted values true or false</p>
    pub fn enabled(&self) -> std::option::Option<bool> {
        self.enabled
    }
}
impl std::fmt::Debug for ColdStorageOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ColdStorageOptions");
        formatter.field("enabled", &self.enabled);
        formatter.finish()
    }
}
/// See [`ColdStorageOptions`](crate::model::ColdStorageOptions)
pub mod cold_storage_options {

    /// A builder for [`ColdStorageOptions`](crate::model::ColdStorageOptions)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) enabled: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>Enable cold storage option. Accepted values true or false</p>
        pub fn enabled(mut self, input: bool) -> Self {
            self.enabled = Some(input);
            self
        }
        /// <p>Enable cold storage option. Accepted values true or false</p>
        pub fn set_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.enabled = input;
            self
        }
        /// Consumes the builder and constructs a [`ColdStorageOptions`](crate::model::ColdStorageOptions)
        pub fn build(self) -> crate::model::ColdStorageOptions {
            crate::model::ColdStorageOptions {
                enabled: self.enabled,
            }
        }
    }
}
impl ColdStorageOptions {
    /// Creates a new builder-style object to manufacture [`ColdStorageOptions`](crate::model::ColdStorageOptions)
    pub fn builder() -> crate::model::cold_storage_options::Builder {
        crate::model::cold_storage_options::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum OpenSearchWarmPartitionInstanceType {
    #[allow(missing_docs)] // documentation missing in model
    Ultrawarm1LargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    Ultrawarm1MediumSearch,
    #[allow(missing_docs)] // documentation missing in model
    Ultrawarm1XlargeSearch,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for OpenSearchWarmPartitionInstanceType {
    fn from(s: &str) -> Self {
        match s {
            "ultrawarm1.large.search" => OpenSearchWarmPartitionInstanceType::Ultrawarm1LargeSearch,
            "ultrawarm1.medium.search" => {
                OpenSearchWarmPartitionInstanceType::Ultrawarm1MediumSearch
            }
            "ultrawarm1.xlarge.search" => {
                OpenSearchWarmPartitionInstanceType::Ultrawarm1XlargeSearch
            }
            other => OpenSearchWarmPartitionInstanceType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for OpenSearchWarmPartitionInstanceType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(OpenSearchWarmPartitionInstanceType::from(s))
    }
}
impl OpenSearchWarmPartitionInstanceType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            OpenSearchWarmPartitionInstanceType::Ultrawarm1LargeSearch => "ultrawarm1.large.search",
            OpenSearchWarmPartitionInstanceType::Ultrawarm1MediumSearch => {
                "ultrawarm1.medium.search"
            }
            OpenSearchWarmPartitionInstanceType::Ultrawarm1XlargeSearch => {
                "ultrawarm1.xlarge.search"
            }
            OpenSearchWarmPartitionInstanceType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "ultrawarm1.large.search",
            "ultrawarm1.medium.search",
            "ultrawarm1.xlarge.search",
        ]
    }
}
impl AsRef<str> for OpenSearchWarmPartitionInstanceType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum OpenSearchPartitionInstanceType {
    #[allow(missing_docs)] // documentation missing in model
    C42xlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    C44xlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    C48xlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    C4LargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    C4XlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    C518xlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    C52xlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    C54xlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    C59xlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    C5LargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    C5XlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    C6g12xlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    C6g2xlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    C6g4xlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    C6g8xlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    C6gLargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    C6gXlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    D22xlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    D24xlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    D28xlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    D2XlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    I22xlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    I2XlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    I316xlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    I32xlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    I34xlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    I38xlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    I3LargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    I3XlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    M32xlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    M3LargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    M3MediumSearch,
    #[allow(missing_docs)] // documentation missing in model
    M3XlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    M410xlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    M42xlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    M44xlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    M4LargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    M4XlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    M512xlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    M524xlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    M52xlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    M54xlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    M5LargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    M5XlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    M6g12xlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    M6g2xlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    M6g4xlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    M6g8xlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    M6gLargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    M6gXlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    R32xlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    R34xlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    R38xlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    R3LargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    R3XlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    R416xlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    R42xlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    R44xlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    R48xlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    R4LargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    R4XlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    R512xlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    R524xlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    R52xlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    R54xlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    R5LargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    R5XlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    R6g12xlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    R6g2xlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    R6g4xlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    R6g8xlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    R6gLargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    R6gXlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    R6gd12xlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    R6gd16xlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    R6gd2xlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    R6gd4xlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    R6gd8xlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    R6gdLargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    R6gdXlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    T2MediumSearch,
    #[allow(missing_docs)] // documentation missing in model
    T2MicroSearch,
    #[allow(missing_docs)] // documentation missing in model
    T2SmallSearch,
    #[allow(missing_docs)] // documentation missing in model
    T32xlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    T3LargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    T3MediumSearch,
    #[allow(missing_docs)] // documentation missing in model
    T3MicroSearch,
    #[allow(missing_docs)] // documentation missing in model
    T3NanoSearch,
    #[allow(missing_docs)] // documentation missing in model
    T3SmallSearch,
    #[allow(missing_docs)] // documentation missing in model
    T3XlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    T4gMediumSearch,
    #[allow(missing_docs)] // documentation missing in model
    T4gSmallSearch,
    #[allow(missing_docs)] // documentation missing in model
    Ultrawarm1LargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    Ultrawarm1MediumSearch,
    #[allow(missing_docs)] // documentation missing in model
    Ultrawarm1XlargeSearch,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for OpenSearchPartitionInstanceType {
    fn from(s: &str) -> Self {
        match s {
            "c4.2xlarge.search" => OpenSearchPartitionInstanceType::C42xlargeSearch,
            "c4.4xlarge.search" => OpenSearchPartitionInstanceType::C44xlargeSearch,
            "c4.8xlarge.search" => OpenSearchPartitionInstanceType::C48xlargeSearch,
            "c4.large.search" => OpenSearchPartitionInstanceType::C4LargeSearch,
            "c4.xlarge.search" => OpenSearchPartitionInstanceType::C4XlargeSearch,
            "c5.18xlarge.search" => OpenSearchPartitionInstanceType::C518xlargeSearch,
            "c5.2xlarge.search" => OpenSearchPartitionInstanceType::C52xlargeSearch,
            "c5.4xlarge.search" => OpenSearchPartitionInstanceType::C54xlargeSearch,
            "c5.9xlarge.search" => OpenSearchPartitionInstanceType::C59xlargeSearch,
            "c5.large.search" => OpenSearchPartitionInstanceType::C5LargeSearch,
            "c5.xlarge.search" => OpenSearchPartitionInstanceType::C5XlargeSearch,
            "c6g.12xlarge.search" => OpenSearchPartitionInstanceType::C6g12xlargeSearch,
            "c6g.2xlarge.search" => OpenSearchPartitionInstanceType::C6g2xlargeSearch,
            "c6g.4xlarge.search" => OpenSearchPartitionInstanceType::C6g4xlargeSearch,
            "c6g.8xlarge.search" => OpenSearchPartitionInstanceType::C6g8xlargeSearch,
            "c6g.large.search" => OpenSearchPartitionInstanceType::C6gLargeSearch,
            "c6g.xlarge.search" => OpenSearchPartitionInstanceType::C6gXlargeSearch,
            "d2.2xlarge.search" => OpenSearchPartitionInstanceType::D22xlargeSearch,
            "d2.4xlarge.search" => OpenSearchPartitionInstanceType::D24xlargeSearch,
            "d2.8xlarge.search" => OpenSearchPartitionInstanceType::D28xlargeSearch,
            "d2.xlarge.search" => OpenSearchPartitionInstanceType::D2XlargeSearch,
            "i2.2xlarge.search" => OpenSearchPartitionInstanceType::I22xlargeSearch,
            "i2.xlarge.search" => OpenSearchPartitionInstanceType::I2XlargeSearch,
            "i3.16xlarge.search" => OpenSearchPartitionInstanceType::I316xlargeSearch,
            "i3.2xlarge.search" => OpenSearchPartitionInstanceType::I32xlargeSearch,
            "i3.4xlarge.search" => OpenSearchPartitionInstanceType::I34xlargeSearch,
            "i3.8xlarge.search" => OpenSearchPartitionInstanceType::I38xlargeSearch,
            "i3.large.search" => OpenSearchPartitionInstanceType::I3LargeSearch,
            "i3.xlarge.search" => OpenSearchPartitionInstanceType::I3XlargeSearch,
            "m3.2xlarge.search" => OpenSearchPartitionInstanceType::M32xlargeSearch,
            "m3.large.search" => OpenSearchPartitionInstanceType::M3LargeSearch,
            "m3.medium.search" => OpenSearchPartitionInstanceType::M3MediumSearch,
            "m3.xlarge.search" => OpenSearchPartitionInstanceType::M3XlargeSearch,
            "m4.10xlarge.search" => OpenSearchPartitionInstanceType::M410xlargeSearch,
            "m4.2xlarge.search" => OpenSearchPartitionInstanceType::M42xlargeSearch,
            "m4.4xlarge.search" => OpenSearchPartitionInstanceType::M44xlargeSearch,
            "m4.large.search" => OpenSearchPartitionInstanceType::M4LargeSearch,
            "m4.xlarge.search" => OpenSearchPartitionInstanceType::M4XlargeSearch,
            "m5.12xlarge.search" => OpenSearchPartitionInstanceType::M512xlargeSearch,
            "m5.24xlarge.search" => OpenSearchPartitionInstanceType::M524xlargeSearch,
            "m5.2xlarge.search" => OpenSearchPartitionInstanceType::M52xlargeSearch,
            "m5.4xlarge.search" => OpenSearchPartitionInstanceType::M54xlargeSearch,
            "m5.large.search" => OpenSearchPartitionInstanceType::M5LargeSearch,
            "m5.xlarge.search" => OpenSearchPartitionInstanceType::M5XlargeSearch,
            "m6g.12xlarge.search" => OpenSearchPartitionInstanceType::M6g12xlargeSearch,
            "m6g.2xlarge.search" => OpenSearchPartitionInstanceType::M6g2xlargeSearch,
            "m6g.4xlarge.search" => OpenSearchPartitionInstanceType::M6g4xlargeSearch,
            "m6g.8xlarge.search" => OpenSearchPartitionInstanceType::M6g8xlargeSearch,
            "m6g.large.search" => OpenSearchPartitionInstanceType::M6gLargeSearch,
            "m6g.xlarge.search" => OpenSearchPartitionInstanceType::M6gXlargeSearch,
            "r3.2xlarge.search" => OpenSearchPartitionInstanceType::R32xlargeSearch,
            "r3.4xlarge.search" => OpenSearchPartitionInstanceType::R34xlargeSearch,
            "r3.8xlarge.search" => OpenSearchPartitionInstanceType::R38xlargeSearch,
            "r3.large.search" => OpenSearchPartitionInstanceType::R3LargeSearch,
            "r3.xlarge.search" => OpenSearchPartitionInstanceType::R3XlargeSearch,
            "r4.16xlarge.search" => OpenSearchPartitionInstanceType::R416xlargeSearch,
            "r4.2xlarge.search" => OpenSearchPartitionInstanceType::R42xlargeSearch,
            "r4.4xlarge.search" => OpenSearchPartitionInstanceType::R44xlargeSearch,
            "r4.8xlarge.search" => OpenSearchPartitionInstanceType::R48xlargeSearch,
            "r4.large.search" => OpenSearchPartitionInstanceType::R4LargeSearch,
            "r4.xlarge.search" => OpenSearchPartitionInstanceType::R4XlargeSearch,
            "r5.12xlarge.search" => OpenSearchPartitionInstanceType::R512xlargeSearch,
            "r5.24xlarge.search" => OpenSearchPartitionInstanceType::R524xlargeSearch,
            "r5.2xlarge.search" => OpenSearchPartitionInstanceType::R52xlargeSearch,
            "r5.4xlarge.search" => OpenSearchPartitionInstanceType::R54xlargeSearch,
            "r5.large.search" => OpenSearchPartitionInstanceType::R5LargeSearch,
            "r5.xlarge.search" => OpenSearchPartitionInstanceType::R5XlargeSearch,
            "r6g.12xlarge.search" => OpenSearchPartitionInstanceType::R6g12xlargeSearch,
            "r6g.2xlarge.search" => OpenSearchPartitionInstanceType::R6g2xlargeSearch,
            "r6g.4xlarge.search" => OpenSearchPartitionInstanceType::R6g4xlargeSearch,
            "r6g.8xlarge.search" => OpenSearchPartitionInstanceType::R6g8xlargeSearch,
            "r6g.large.search" => OpenSearchPartitionInstanceType::R6gLargeSearch,
            "r6g.xlarge.search" => OpenSearchPartitionInstanceType::R6gXlargeSearch,
            "r6gd.12xlarge.search" => OpenSearchPartitionInstanceType::R6gd12xlargeSearch,
            "r6gd.16xlarge.search" => OpenSearchPartitionInstanceType::R6gd16xlargeSearch,
            "r6gd.2xlarge.search" => OpenSearchPartitionInstanceType::R6gd2xlargeSearch,
            "r6gd.4xlarge.search" => OpenSearchPartitionInstanceType::R6gd4xlargeSearch,
            "r6gd.8xlarge.search" => OpenSearchPartitionInstanceType::R6gd8xlargeSearch,
            "r6gd.large.search" => OpenSearchPartitionInstanceType::R6gdLargeSearch,
            "r6gd.xlarge.search" => OpenSearchPartitionInstanceType::R6gdXlargeSearch,
            "t2.medium.search" => OpenSearchPartitionInstanceType::T2MediumSearch,
            "t2.micro.search" => OpenSearchPartitionInstanceType::T2MicroSearch,
            "t2.small.search" => OpenSearchPartitionInstanceType::T2SmallSearch,
            "t3.2xlarge.search" => OpenSearchPartitionInstanceType::T32xlargeSearch,
            "t3.large.search" => OpenSearchPartitionInstanceType::T3LargeSearch,
            "t3.medium.search" => OpenSearchPartitionInstanceType::T3MediumSearch,
            "t3.micro.search" => OpenSearchPartitionInstanceType::T3MicroSearch,
            "t3.nano.search" => OpenSearchPartitionInstanceType::T3NanoSearch,
            "t3.small.search" => OpenSearchPartitionInstanceType::T3SmallSearch,
            "t3.xlarge.search" => OpenSearchPartitionInstanceType::T3XlargeSearch,
            "t4g.medium.search" => OpenSearchPartitionInstanceType::T4gMediumSearch,
            "t4g.small.search" => OpenSearchPartitionInstanceType::T4gSmallSearch,
            "ultrawarm1.large.search" => OpenSearchPartitionInstanceType::Ultrawarm1LargeSearch,
            "ultrawarm1.medium.search" => OpenSearchPartitionInstanceType::Ultrawarm1MediumSearch,
            "ultrawarm1.xlarge.search" => OpenSearchPartitionInstanceType::Ultrawarm1XlargeSearch,
            other => OpenSearchPartitionInstanceType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for OpenSearchPartitionInstanceType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(OpenSearchPartitionInstanceType::from(s))
    }
}
impl OpenSearchPartitionInstanceType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            OpenSearchPartitionInstanceType::C42xlargeSearch => "c4.2xlarge.search",
            OpenSearchPartitionInstanceType::C44xlargeSearch => "c4.4xlarge.search",
            OpenSearchPartitionInstanceType::C48xlargeSearch => "c4.8xlarge.search",
            OpenSearchPartitionInstanceType::C4LargeSearch => "c4.large.search",
            OpenSearchPartitionInstanceType::C4XlargeSearch => "c4.xlarge.search",
            OpenSearchPartitionInstanceType::C518xlargeSearch => "c5.18xlarge.search",
            OpenSearchPartitionInstanceType::C52xlargeSearch => "c5.2xlarge.search",
            OpenSearchPartitionInstanceType::C54xlargeSearch => "c5.4xlarge.search",
            OpenSearchPartitionInstanceType::C59xlargeSearch => "c5.9xlarge.search",
            OpenSearchPartitionInstanceType::C5LargeSearch => "c5.large.search",
            OpenSearchPartitionInstanceType::C5XlargeSearch => "c5.xlarge.search",
            OpenSearchPartitionInstanceType::C6g12xlargeSearch => "c6g.12xlarge.search",
            OpenSearchPartitionInstanceType::C6g2xlargeSearch => "c6g.2xlarge.search",
            OpenSearchPartitionInstanceType::C6g4xlargeSearch => "c6g.4xlarge.search",
            OpenSearchPartitionInstanceType::C6g8xlargeSearch => "c6g.8xlarge.search",
            OpenSearchPartitionInstanceType::C6gLargeSearch => "c6g.large.search",
            OpenSearchPartitionInstanceType::C6gXlargeSearch => "c6g.xlarge.search",
            OpenSearchPartitionInstanceType::D22xlargeSearch => "d2.2xlarge.search",
            OpenSearchPartitionInstanceType::D24xlargeSearch => "d2.4xlarge.search",
            OpenSearchPartitionInstanceType::D28xlargeSearch => "d2.8xlarge.search",
            OpenSearchPartitionInstanceType::D2XlargeSearch => "d2.xlarge.search",
            OpenSearchPartitionInstanceType::I22xlargeSearch => "i2.2xlarge.search",
            OpenSearchPartitionInstanceType::I2XlargeSearch => "i2.xlarge.search",
            OpenSearchPartitionInstanceType::I316xlargeSearch => "i3.16xlarge.search",
            OpenSearchPartitionInstanceType::I32xlargeSearch => "i3.2xlarge.search",
            OpenSearchPartitionInstanceType::I34xlargeSearch => "i3.4xlarge.search",
            OpenSearchPartitionInstanceType::I38xlargeSearch => "i3.8xlarge.search",
            OpenSearchPartitionInstanceType::I3LargeSearch => "i3.large.search",
            OpenSearchPartitionInstanceType::I3XlargeSearch => "i3.xlarge.search",
            OpenSearchPartitionInstanceType::M32xlargeSearch => "m3.2xlarge.search",
            OpenSearchPartitionInstanceType::M3LargeSearch => "m3.large.search",
            OpenSearchPartitionInstanceType::M3MediumSearch => "m3.medium.search",
            OpenSearchPartitionInstanceType::M3XlargeSearch => "m3.xlarge.search",
            OpenSearchPartitionInstanceType::M410xlargeSearch => "m4.10xlarge.search",
            OpenSearchPartitionInstanceType::M42xlargeSearch => "m4.2xlarge.search",
            OpenSearchPartitionInstanceType::M44xlargeSearch => "m4.4xlarge.search",
            OpenSearchPartitionInstanceType::M4LargeSearch => "m4.large.search",
            OpenSearchPartitionInstanceType::M4XlargeSearch => "m4.xlarge.search",
            OpenSearchPartitionInstanceType::M512xlargeSearch => "m5.12xlarge.search",
            OpenSearchPartitionInstanceType::M524xlargeSearch => "m5.24xlarge.search",
            OpenSearchPartitionInstanceType::M52xlargeSearch => "m5.2xlarge.search",
            OpenSearchPartitionInstanceType::M54xlargeSearch => "m5.4xlarge.search",
            OpenSearchPartitionInstanceType::M5LargeSearch => "m5.large.search",
            OpenSearchPartitionInstanceType::M5XlargeSearch => "m5.xlarge.search",
            OpenSearchPartitionInstanceType::M6g12xlargeSearch => "m6g.12xlarge.search",
            OpenSearchPartitionInstanceType::M6g2xlargeSearch => "m6g.2xlarge.search",
            OpenSearchPartitionInstanceType::M6g4xlargeSearch => "m6g.4xlarge.search",
            OpenSearchPartitionInstanceType::M6g8xlargeSearch => "m6g.8xlarge.search",
            OpenSearchPartitionInstanceType::M6gLargeSearch => "m6g.large.search",
            OpenSearchPartitionInstanceType::M6gXlargeSearch => "m6g.xlarge.search",
            OpenSearchPartitionInstanceType::R32xlargeSearch => "r3.2xlarge.search",
            OpenSearchPartitionInstanceType::R34xlargeSearch => "r3.4xlarge.search",
            OpenSearchPartitionInstanceType::R38xlargeSearch => "r3.8xlarge.search",
            OpenSearchPartitionInstanceType::R3LargeSearch => "r3.large.search",
            OpenSearchPartitionInstanceType::R3XlargeSearch => "r3.xlarge.search",
            OpenSearchPartitionInstanceType::R416xlargeSearch => "r4.16xlarge.search",
            OpenSearchPartitionInstanceType::R42xlargeSearch => "r4.2xlarge.search",
            OpenSearchPartitionInstanceType::R44xlargeSearch => "r4.4xlarge.search",
            OpenSearchPartitionInstanceType::R48xlargeSearch => "r4.8xlarge.search",
            OpenSearchPartitionInstanceType::R4LargeSearch => "r4.large.search",
            OpenSearchPartitionInstanceType::R4XlargeSearch => "r4.xlarge.search",
            OpenSearchPartitionInstanceType::R512xlargeSearch => "r5.12xlarge.search",
            OpenSearchPartitionInstanceType::R524xlargeSearch => "r5.24xlarge.search",
            OpenSearchPartitionInstanceType::R52xlargeSearch => "r5.2xlarge.search",
            OpenSearchPartitionInstanceType::R54xlargeSearch => "r5.4xlarge.search",
            OpenSearchPartitionInstanceType::R5LargeSearch => "r5.large.search",
            OpenSearchPartitionInstanceType::R5XlargeSearch => "r5.xlarge.search",
            OpenSearchPartitionInstanceType::R6g12xlargeSearch => "r6g.12xlarge.search",
            OpenSearchPartitionInstanceType::R6g2xlargeSearch => "r6g.2xlarge.search",
            OpenSearchPartitionInstanceType::R6g4xlargeSearch => "r6g.4xlarge.search",
            OpenSearchPartitionInstanceType::R6g8xlargeSearch => "r6g.8xlarge.search",
            OpenSearchPartitionInstanceType::R6gLargeSearch => "r6g.large.search",
            OpenSearchPartitionInstanceType::R6gXlargeSearch => "r6g.xlarge.search",
            OpenSearchPartitionInstanceType::R6gd12xlargeSearch => "r6gd.12xlarge.search",
            OpenSearchPartitionInstanceType::R6gd16xlargeSearch => "r6gd.16xlarge.search",
            OpenSearchPartitionInstanceType::R6gd2xlargeSearch => "r6gd.2xlarge.search",
            OpenSearchPartitionInstanceType::R6gd4xlargeSearch => "r6gd.4xlarge.search",
            OpenSearchPartitionInstanceType::R6gd8xlargeSearch => "r6gd.8xlarge.search",
            OpenSearchPartitionInstanceType::R6gdLargeSearch => "r6gd.large.search",
            OpenSearchPartitionInstanceType::R6gdXlargeSearch => "r6gd.xlarge.search",
            OpenSearchPartitionInstanceType::T2MediumSearch => "t2.medium.search",
            OpenSearchPartitionInstanceType::T2MicroSearch => "t2.micro.search",
            OpenSearchPartitionInstanceType::T2SmallSearch => "t2.small.search",
            OpenSearchPartitionInstanceType::T32xlargeSearch => "t3.2xlarge.search",
            OpenSearchPartitionInstanceType::T3LargeSearch => "t3.large.search",
            OpenSearchPartitionInstanceType::T3MediumSearch => "t3.medium.search",
            OpenSearchPartitionInstanceType::T3MicroSearch => "t3.micro.search",
            OpenSearchPartitionInstanceType::T3NanoSearch => "t3.nano.search",
            OpenSearchPartitionInstanceType::T3SmallSearch => "t3.small.search",
            OpenSearchPartitionInstanceType::T3XlargeSearch => "t3.xlarge.search",
            OpenSearchPartitionInstanceType::T4gMediumSearch => "t4g.medium.search",
            OpenSearchPartitionInstanceType::T4gSmallSearch => "t4g.small.search",
            OpenSearchPartitionInstanceType::Ultrawarm1LargeSearch => "ultrawarm1.large.search",
            OpenSearchPartitionInstanceType::Ultrawarm1MediumSearch => "ultrawarm1.medium.search",
            OpenSearchPartitionInstanceType::Ultrawarm1XlargeSearch => "ultrawarm1.xlarge.search",
            OpenSearchPartitionInstanceType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "c4.2xlarge.search",
            "c4.4xlarge.search",
            "c4.8xlarge.search",
            "c4.large.search",
            "c4.xlarge.search",
            "c5.18xlarge.search",
            "c5.2xlarge.search",
            "c5.4xlarge.search",
            "c5.9xlarge.search",
            "c5.large.search",
            "c5.xlarge.search",
            "c6g.12xlarge.search",
            "c6g.2xlarge.search",
            "c6g.4xlarge.search",
            "c6g.8xlarge.search",
            "c6g.large.search",
            "c6g.xlarge.search",
            "d2.2xlarge.search",
            "d2.4xlarge.search",
            "d2.8xlarge.search",
            "d2.xlarge.search",
            "i2.2xlarge.search",
            "i2.xlarge.search",
            "i3.16xlarge.search",
            "i3.2xlarge.search",
            "i3.4xlarge.search",
            "i3.8xlarge.search",
            "i3.large.search",
            "i3.xlarge.search",
            "m3.2xlarge.search",
            "m3.large.search",
            "m3.medium.search",
            "m3.xlarge.search",
            "m4.10xlarge.search",
            "m4.2xlarge.search",
            "m4.4xlarge.search",
            "m4.large.search",
            "m4.xlarge.search",
            "m5.12xlarge.search",
            "m5.24xlarge.search",
            "m5.2xlarge.search",
            "m5.4xlarge.search",
            "m5.large.search",
            "m5.xlarge.search",
            "m6g.12xlarge.search",
            "m6g.2xlarge.search",
            "m6g.4xlarge.search",
            "m6g.8xlarge.search",
            "m6g.large.search",
            "m6g.xlarge.search",
            "r3.2xlarge.search",
            "r3.4xlarge.search",
            "r3.8xlarge.search",
            "r3.large.search",
            "r3.xlarge.search",
            "r4.16xlarge.search",
            "r4.2xlarge.search",
            "r4.4xlarge.search",
            "r4.8xlarge.search",
            "r4.large.search",
            "r4.xlarge.search",
            "r5.12xlarge.search",
            "r5.24xlarge.search",
            "r5.2xlarge.search",
            "r5.4xlarge.search",
            "r5.large.search",
            "r5.xlarge.search",
            "r6g.12xlarge.search",
            "r6g.2xlarge.search",
            "r6g.4xlarge.search",
            "r6g.8xlarge.search",
            "r6g.large.search",
            "r6g.xlarge.search",
            "r6gd.12xlarge.search",
            "r6gd.16xlarge.search",
            "r6gd.2xlarge.search",
            "r6gd.4xlarge.search",
            "r6gd.8xlarge.search",
            "r6gd.large.search",
            "r6gd.xlarge.search",
            "t2.medium.search",
            "t2.micro.search",
            "t2.small.search",
            "t3.2xlarge.search",
            "t3.large.search",
            "t3.medium.search",
            "t3.micro.search",
            "t3.nano.search",
            "t3.small.search",
            "t3.xlarge.search",
            "t4g.medium.search",
            "t4g.small.search",
            "ultrawarm1.large.search",
            "ultrawarm1.medium.search",
            "ultrawarm1.xlarge.search",
        ]
    }
}
impl AsRef<str> for OpenSearchPartitionInstanceType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The zone awareness configuration for the domain cluster, such as the number of availability zones.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ZoneAwarenessConfig {
    /// <p>An integer value to indicate the number of availability zones for a domain when zone awareness is enabled. This should be equal to number of subnets if VPC endpoints is enabled. </p>
    pub availability_zone_count: std::option::Option<i32>,
}
impl ZoneAwarenessConfig {
    /// <p>An integer value to indicate the number of availability zones for a domain when zone awareness is enabled. This should be equal to number of subnets if VPC endpoints is enabled. </p>
    pub fn availability_zone_count(&self) -> std::option::Option<i32> {
        self.availability_zone_count
    }
}
impl std::fmt::Debug for ZoneAwarenessConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ZoneAwarenessConfig");
        formatter.field("availability_zone_count", &self.availability_zone_count);
        formatter.finish()
    }
}
/// See [`ZoneAwarenessConfig`](crate::model::ZoneAwarenessConfig)
pub mod zone_awareness_config {

    /// A builder for [`ZoneAwarenessConfig`](crate::model::ZoneAwarenessConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) availability_zone_count: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>An integer value to indicate the number of availability zones for a domain when zone awareness is enabled. This should be equal to number of subnets if VPC endpoints is enabled. </p>
        pub fn availability_zone_count(mut self, input: i32) -> Self {
            self.availability_zone_count = Some(input);
            self
        }
        /// <p>An integer value to indicate the number of availability zones for a domain when zone awareness is enabled. This should be equal to number of subnets if VPC endpoints is enabled. </p>
        pub fn set_availability_zone_count(mut self, input: std::option::Option<i32>) -> Self {
            self.availability_zone_count = input;
            self
        }
        /// Consumes the builder and constructs a [`ZoneAwarenessConfig`](crate::model::ZoneAwarenessConfig)
        pub fn build(self) -> crate::model::ZoneAwarenessConfig {
            crate::model::ZoneAwarenessConfig {
                availability_zone_count: self.availability_zone_count,
            }
        }
    }
}
impl ZoneAwarenessConfig {
    /// Creates a new builder-style object to manufacture [`ZoneAwarenessConfig`](crate::model::ZoneAwarenessConfig)
    pub fn builder() -> crate::model::zone_awareness_config::Builder {
        crate::model::zone_awareness_config::Builder::default()
    }
}

/// <p>The status of the OpenSearch version options for the specified OpenSearch domain.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct VersionStatus {
    /// <p>The OpenSearch version for the specified OpenSearch domain.</p>
    pub options: std::option::Option<std::string::String>,
    /// <p>The status of the OpenSearch version options for the specified OpenSearch domain.</p>
    pub status: std::option::Option<crate::model::OptionStatus>,
}
impl VersionStatus {
    /// <p>The OpenSearch version for the specified OpenSearch domain.</p>
    pub fn options(&self) -> std::option::Option<&str> {
        self.options.as_deref()
    }
    /// <p>The status of the OpenSearch version options for the specified OpenSearch domain.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::OptionStatus> {
        self.status.as_ref()
    }
}
impl std::fmt::Debug for VersionStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("VersionStatus");
        formatter.field("options", &self.options);
        formatter.field("status", &self.status);
        formatter.finish()
    }
}
/// See [`VersionStatus`](crate::model::VersionStatus)
pub mod version_status {

    /// A builder for [`VersionStatus`](crate::model::VersionStatus)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) options: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::OptionStatus>,
    }
    impl Builder {
        /// <p>The OpenSearch version for the specified OpenSearch domain.</p>
        pub fn options(mut self, input: impl Into<std::string::String>) -> Self {
            self.options = Some(input.into());
            self
        }
        /// <p>The OpenSearch version for the specified OpenSearch domain.</p>
        pub fn set_options(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.options = input;
            self
        }
        /// <p>The status of the OpenSearch version options for the specified OpenSearch domain.</p>
        pub fn status(mut self, input: crate::model::OptionStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the OpenSearch version options for the specified OpenSearch domain.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::OptionStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// Consumes the builder and constructs a [`VersionStatus`](crate::model::VersionStatus)
        pub fn build(self) -> crate::model::VersionStatus {
            crate::model::VersionStatus {
                options: self.options,
                status: self.status,
            }
        }
    }
}
impl VersionStatus {
    /// Creates a new builder-style object to manufacture [`VersionStatus`](crate::model::VersionStatus)
    pub fn builder() -> crate::model::version_status::Builder {
        crate::model::version_status::Builder::default()
    }
}

/// <p>The advanced security configuration: whether advanced security is enabled, whether the internal database option is enabled, master username and password (if internal database is enabled), and master user ARN (if IAM is enabled). </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AdvancedSecurityOptionsInput {
    /// <p>True if advanced security is enabled.</p>
    pub enabled: std::option::Option<bool>,
    /// <p>True if the internal user database is enabled.</p>
    pub internal_user_database_enabled: std::option::Option<bool>,
    /// <p>Credentials for the master user: username and password, ARN, or both.</p>
    pub master_user_options: std::option::Option<crate::model::MasterUserOptions>,
    /// <p>The SAML application configuration for the domain.</p>
    pub saml_options: std::option::Option<crate::model::SamlOptionsInput>,
    /// <p>True if Anonymous auth is enabled. Anonymous auth can be enabled only when AdvancedSecurity is enabled on existing domains.</p>
    pub anonymous_auth_enabled: std::option::Option<bool>,
}
impl AdvancedSecurityOptionsInput {
    /// <p>True if advanced security is enabled.</p>
    pub fn enabled(&self) -> std::option::Option<bool> {
        self.enabled
    }
    /// <p>True if the internal user database is enabled.</p>
    pub fn internal_user_database_enabled(&self) -> std::option::Option<bool> {
        self.internal_user_database_enabled
    }
    /// <p>Credentials for the master user: username and password, ARN, or both.</p>
    pub fn master_user_options(&self) -> std::option::Option<&crate::model::MasterUserOptions> {
        self.master_user_options.as_ref()
    }
    /// <p>The SAML application configuration for the domain.</p>
    pub fn saml_options(&self) -> std::option::Option<&crate::model::SamlOptionsInput> {
        self.saml_options.as_ref()
    }
    /// <p>True if Anonymous auth is enabled. Anonymous auth can be enabled only when AdvancedSecurity is enabled on existing domains.</p>
    pub fn anonymous_auth_enabled(&self) -> std::option::Option<bool> {
        self.anonymous_auth_enabled
    }
}
impl std::fmt::Debug for AdvancedSecurityOptionsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AdvancedSecurityOptionsInput");
        formatter.field("enabled", &self.enabled);
        formatter.field(
            "internal_user_database_enabled",
            &self.internal_user_database_enabled,
        );
        formatter.field("master_user_options", &self.master_user_options);
        formatter.field("saml_options", &self.saml_options);
        formatter.field("anonymous_auth_enabled", &self.anonymous_auth_enabled);
        formatter.finish()
    }
}
/// See [`AdvancedSecurityOptionsInput`](crate::model::AdvancedSecurityOptionsInput)
pub mod advanced_security_options_input {

    /// A builder for [`AdvancedSecurityOptionsInput`](crate::model::AdvancedSecurityOptionsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) enabled: std::option::Option<bool>,
        pub(crate) internal_user_database_enabled: std::option::Option<bool>,
        pub(crate) master_user_options: std::option::Option<crate::model::MasterUserOptions>,
        pub(crate) saml_options: std::option::Option<crate::model::SamlOptionsInput>,
        pub(crate) anonymous_auth_enabled: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>True if advanced security is enabled.</p>
        pub fn enabled(mut self, input: bool) -> Self {
            self.enabled = Some(input);
            self
        }
        /// <p>True if advanced security is enabled.</p>
        pub fn set_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.enabled = input;
            self
        }
        /// <p>True if the internal user database is enabled.</p>
        pub fn internal_user_database_enabled(mut self, input: bool) -> Self {
            self.internal_user_database_enabled = Some(input);
            self
        }
        /// <p>True if the internal user database is enabled.</p>
        pub fn set_internal_user_database_enabled(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.internal_user_database_enabled = input;
            self
        }
        /// <p>Credentials for the master user: username and password, ARN, or both.</p>
        pub fn master_user_options(mut self, input: crate::model::MasterUserOptions) -> Self {
            self.master_user_options = Some(input);
            self
        }
        /// <p>Credentials for the master user: username and password, ARN, or both.</p>
        pub fn set_master_user_options(
            mut self,
            input: std::option::Option<crate::model::MasterUserOptions>,
        ) -> Self {
            self.master_user_options = input;
            self
        }
        /// <p>The SAML application configuration for the domain.</p>
        pub fn saml_options(mut self, input: crate::model::SamlOptionsInput) -> Self {
            self.saml_options = Some(input);
            self
        }
        /// <p>The SAML application configuration for the domain.</p>
        pub fn set_saml_options(
            mut self,
            input: std::option::Option<crate::model::SamlOptionsInput>,
        ) -> Self {
            self.saml_options = input;
            self
        }
        /// <p>True if Anonymous auth is enabled. Anonymous auth can be enabled only when AdvancedSecurity is enabled on existing domains.</p>
        pub fn anonymous_auth_enabled(mut self, input: bool) -> Self {
            self.anonymous_auth_enabled = Some(input);
            self
        }
        /// <p>True if Anonymous auth is enabled. Anonymous auth can be enabled only when AdvancedSecurity is enabled on existing domains.</p>
        pub fn set_anonymous_auth_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.anonymous_auth_enabled = input;
            self
        }
        /// Consumes the builder and constructs a [`AdvancedSecurityOptionsInput`](crate::model::AdvancedSecurityOptionsInput)
        pub fn build(self) -> crate::model::AdvancedSecurityOptionsInput {
            crate::model::AdvancedSecurityOptionsInput {
                enabled: self.enabled,
                internal_user_database_enabled: self.internal_user_database_enabled,
                master_user_options: self.master_user_options,
                saml_options: self.saml_options,
                anonymous_auth_enabled: self.anonymous_auth_enabled,
            }
        }
    }
}
impl AdvancedSecurityOptionsInput {
    /// Creates a new builder-style object to manufacture [`AdvancedSecurityOptionsInput`](crate::model::AdvancedSecurityOptionsInput)
    pub fn builder() -> crate::model::advanced_security_options_input::Builder {
        crate::model::advanced_security_options_input::Builder::default()
    }
}

/// <p>The SAML application configuration for the domain.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SamlOptionsInput {
    /// <p>True if SAML is enabled.</p>
    pub enabled: std::option::Option<bool>,
    /// <p>The SAML Identity Provider's information.</p>
    pub idp: std::option::Option<crate::model::SamlIdp>,
    /// <p>The SAML master username, which is stored in the Amazon OpenSearch Service domain's internal database.</p>
    pub master_user_name: std::option::Option<std::string::String>,
    /// <p>The backend role that the SAML master user is mapped to.</p>
    pub master_backend_role: std::option::Option<std::string::String>,
    /// <p>Element of the SAML assertion to use for username. Default is NameID.</p>
    pub subject_key: std::option::Option<std::string::String>,
    /// <p>Element of the SAML assertion to use for backend roles. Default is roles.</p>
    pub roles_key: std::option::Option<std::string::String>,
    /// <p>The duration, in minutes, after which a user session becomes inactive. Acceptable values are between 1 and 1440, and the default value is 60. </p>
    pub session_timeout_minutes: std::option::Option<i32>,
}
impl SamlOptionsInput {
    /// <p>True if SAML is enabled.</p>
    pub fn enabled(&self) -> std::option::Option<bool> {
        self.enabled
    }
    /// <p>The SAML Identity Provider's information.</p>
    pub fn idp(&self) -> std::option::Option<&crate::model::SamlIdp> {
        self.idp.as_ref()
    }
    /// <p>The SAML master username, which is stored in the Amazon OpenSearch Service domain's internal database.</p>
    pub fn master_user_name(&self) -> std::option::Option<&str> {
        self.master_user_name.as_deref()
    }
    /// <p>The backend role that the SAML master user is mapped to.</p>
    pub fn master_backend_role(&self) -> std::option::Option<&str> {
        self.master_backend_role.as_deref()
    }
    /// <p>Element of the SAML assertion to use for username. Default is NameID.</p>
    pub fn subject_key(&self) -> std::option::Option<&str> {
        self.subject_key.as_deref()
    }
    /// <p>Element of the SAML assertion to use for backend roles. Default is roles.</p>
    pub fn roles_key(&self) -> std::option::Option<&str> {
        self.roles_key.as_deref()
    }
    /// <p>The duration, in minutes, after which a user session becomes inactive. Acceptable values are between 1 and 1440, and the default value is 60. </p>
    pub fn session_timeout_minutes(&self) -> std::option::Option<i32> {
        self.session_timeout_minutes
    }
}
impl std::fmt::Debug for SamlOptionsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SamlOptionsInput");
        formatter.field("enabled", &self.enabled);
        formatter.field("idp", &self.idp);
        formatter.field("master_user_name", &"*** Sensitive Data Redacted ***");
        formatter.field("master_backend_role", &self.master_backend_role);
        formatter.field("subject_key", &self.subject_key);
        formatter.field("roles_key", &self.roles_key);
        formatter.field("session_timeout_minutes", &self.session_timeout_minutes);
        formatter.finish()
    }
}
/// See [`SamlOptionsInput`](crate::model::SamlOptionsInput)
pub mod saml_options_input {

    /// A builder for [`SamlOptionsInput`](crate::model::SamlOptionsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) enabled: std::option::Option<bool>,
        pub(crate) idp: std::option::Option<crate::model::SamlIdp>,
        pub(crate) master_user_name: std::option::Option<std::string::String>,
        pub(crate) master_backend_role: std::option::Option<std::string::String>,
        pub(crate) subject_key: std::option::Option<std::string::String>,
        pub(crate) roles_key: std::option::Option<std::string::String>,
        pub(crate) session_timeout_minutes: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>True if SAML is enabled.</p>
        pub fn enabled(mut self, input: bool) -> Self {
            self.enabled = Some(input);
            self
        }
        /// <p>True if SAML is enabled.</p>
        pub fn set_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.enabled = input;
            self
        }
        /// <p>The SAML Identity Provider's information.</p>
        pub fn idp(mut self, input: crate::model::SamlIdp) -> Self {
            self.idp = Some(input);
            self
        }
        /// <p>The SAML Identity Provider's information.</p>
        pub fn set_idp(mut self, input: std::option::Option<crate::model::SamlIdp>) -> Self {
            self.idp = input;
            self
        }
        /// <p>The SAML master username, which is stored in the Amazon OpenSearch Service domain's internal database.</p>
        pub fn master_user_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.master_user_name = Some(input.into());
            self
        }
        /// <p>The SAML master username, which is stored in the Amazon OpenSearch Service domain's internal database.</p>
        pub fn set_master_user_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.master_user_name = input;
            self
        }
        /// <p>The backend role that the SAML master user is mapped to.</p>
        pub fn master_backend_role(mut self, input: impl Into<std::string::String>) -> Self {
            self.master_backend_role = Some(input.into());
            self
        }
        /// <p>The backend role that the SAML master user is mapped to.</p>
        pub fn set_master_backend_role(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.master_backend_role = input;
            self
        }
        /// <p>Element of the SAML assertion to use for username. Default is NameID.</p>
        pub fn subject_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.subject_key = Some(input.into());
            self
        }
        /// <p>Element of the SAML assertion to use for username. Default is NameID.</p>
        pub fn set_subject_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.subject_key = input;
            self
        }
        /// <p>Element of the SAML assertion to use for backend roles. Default is roles.</p>
        pub fn roles_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.roles_key = Some(input.into());
            self
        }
        /// <p>Element of the SAML assertion to use for backend roles. Default is roles.</p>
        pub fn set_roles_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.roles_key = input;
            self
        }
        /// <p>The duration, in minutes, after which a user session becomes inactive. Acceptable values are between 1 and 1440, and the default value is 60. </p>
        pub fn session_timeout_minutes(mut self, input: i32) -> Self {
            self.session_timeout_minutes = Some(input);
            self
        }
        /// <p>The duration, in minutes, after which a user session becomes inactive. Acceptable values are between 1 and 1440, and the default value is 60. </p>
        pub fn set_session_timeout_minutes(mut self, input: std::option::Option<i32>) -> Self {
            self.session_timeout_minutes = input;
            self
        }
        /// Consumes the builder and constructs a [`SamlOptionsInput`](crate::model::SamlOptionsInput)
        pub fn build(self) -> crate::model::SamlOptionsInput {
            crate::model::SamlOptionsInput {
                enabled: self.enabled,
                idp: self.idp,
                master_user_name: self.master_user_name,
                master_backend_role: self.master_backend_role,
                subject_key: self.subject_key,
                roles_key: self.roles_key,
                session_timeout_minutes: self.session_timeout_minutes,
            }
        }
    }
}
impl SamlOptionsInput {
    /// Creates a new builder-style object to manufacture [`SamlOptionsInput`](crate::model::SamlOptionsInput)
    pub fn builder() -> crate::model::saml_options_input::Builder {
        crate::model::saml_options_input::Builder::default()
    }
}

/// <p>Credentials for the master user: username and password, ARN, or both.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MasterUserOptions {
    /// <p>ARN for the master user (if IAM is enabled).</p>
    pub master_user_arn: std::option::Option<std::string::String>,
    /// <p>The master user's username, which is stored in the Amazon OpenSearch Service domain's internal database.</p>
    pub master_user_name: std::option::Option<std::string::String>,
    /// <p>The master user's password, which is stored in the Amazon OpenSearch Service domain's internal database.</p>
    pub master_user_password: std::option::Option<std::string::String>,
}
impl MasterUserOptions {
    /// <p>ARN for the master user (if IAM is enabled).</p>
    pub fn master_user_arn(&self) -> std::option::Option<&str> {
        self.master_user_arn.as_deref()
    }
    /// <p>The master user's username, which is stored in the Amazon OpenSearch Service domain's internal database.</p>
    pub fn master_user_name(&self) -> std::option::Option<&str> {
        self.master_user_name.as_deref()
    }
    /// <p>The master user's password, which is stored in the Amazon OpenSearch Service domain's internal database.</p>
    pub fn master_user_password(&self) -> std::option::Option<&str> {
        self.master_user_password.as_deref()
    }
}
impl std::fmt::Debug for MasterUserOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MasterUserOptions");
        formatter.field("master_user_arn", &self.master_user_arn);
        formatter.field("master_user_name", &"*** Sensitive Data Redacted ***");
        formatter.field("master_user_password", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
/// See [`MasterUserOptions`](crate::model::MasterUserOptions)
pub mod master_user_options {

    /// A builder for [`MasterUserOptions`](crate::model::MasterUserOptions)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) master_user_arn: std::option::Option<std::string::String>,
        pub(crate) master_user_name: std::option::Option<std::string::String>,
        pub(crate) master_user_password: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>ARN for the master user (if IAM is enabled).</p>
        pub fn master_user_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.master_user_arn = Some(input.into());
            self
        }
        /// <p>ARN for the master user (if IAM is enabled).</p>
        pub fn set_master_user_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.master_user_arn = input;
            self
        }
        /// <p>The master user's username, which is stored in the Amazon OpenSearch Service domain's internal database.</p>
        pub fn master_user_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.master_user_name = Some(input.into());
            self
        }
        /// <p>The master user's username, which is stored in the Amazon OpenSearch Service domain's internal database.</p>
        pub fn set_master_user_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.master_user_name = input;
            self
        }
        /// <p>The master user's password, which is stored in the Amazon OpenSearch Service domain's internal database.</p>
        pub fn master_user_password(mut self, input: impl Into<std::string::String>) -> Self {
            self.master_user_password = Some(input.into());
            self
        }
        /// <p>The master user's password, which is stored in the Amazon OpenSearch Service domain's internal database.</p>
        pub fn set_master_user_password(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.master_user_password = input;
            self
        }
        /// Consumes the builder and constructs a [`MasterUserOptions`](crate::model::MasterUserOptions)
        pub fn build(self) -> crate::model::MasterUserOptions {
            crate::model::MasterUserOptions {
                master_user_arn: self.master_user_arn,
                master_user_name: self.master_user_name,
                master_user_password: self.master_user_password,
            }
        }
    }
}
impl MasterUserOptions {
    /// Creates a new builder-style object to manufacture [`MasterUserOptions`](crate::model::MasterUserOptions)
    pub fn builder() -> crate::model::master_user_options::Builder {
        crate::model::master_user_options::Builder::default()
    }
}

/// <p>Options to specify the subnets and security groups for the VPC endpoint. For more information, see <a href="http://docs.aws.amazon.com/opensearch-service/latest/developerguide/vpc.html" target="_blank"> Launching your Amazon OpenSearch Service domains using a VPC</a>. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct VpcOptions {
    /// <p>The subnets for the VPC endpoint.</p>
    pub subnet_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The security groups for the VPC endpoint.</p>
    pub security_group_ids: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl VpcOptions {
    /// <p>The subnets for the VPC endpoint.</p>
    pub fn subnet_ids(&self) -> std::option::Option<&[std::string::String]> {
        self.subnet_ids.as_deref()
    }
    /// <p>The security groups for the VPC endpoint.</p>
    pub fn security_group_ids(&self) -> std::option::Option<&[std::string::String]> {
        self.security_group_ids.as_deref()
    }
}
impl std::fmt::Debug for VpcOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("VpcOptions");
        formatter.field("subnet_ids", &self.subnet_ids);
        formatter.field("security_group_ids", &self.security_group_ids);
        formatter.finish()
    }
}
/// See [`VpcOptions`](crate::model::VpcOptions)
pub mod vpc_options {

    /// A builder for [`VpcOptions`](crate::model::VpcOptions)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) subnet_ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) security_group_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// Appends an item to `subnet_ids`.
        ///
        /// To override the contents of this collection use [`set_subnet_ids`](Self::set_subnet_ids).
        ///
        /// <p>The subnets for the VPC endpoint.</p>
        pub fn subnet_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.subnet_ids.unwrap_or_default();
            v.push(input.into());
            self.subnet_ids = Some(v);
            self
        }
        /// <p>The subnets for the VPC endpoint.</p>
        pub fn set_subnet_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.subnet_ids = input;
            self
        }
        /// Appends an item to `security_group_ids`.
        ///
        /// To override the contents of this collection use [`set_security_group_ids`](Self::set_security_group_ids).
        ///
        /// <p>The security groups for the VPC endpoint.</p>
        pub fn security_group_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.security_group_ids.unwrap_or_default();
            v.push(input.into());
            self.security_group_ids = Some(v);
            self
        }
        /// <p>The security groups for the VPC endpoint.</p>
        pub fn set_security_group_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.security_group_ids = input;
            self
        }
        /// Consumes the builder and constructs a [`VpcOptions`](crate::model::VpcOptions)
        pub fn build(self) -> crate::model::VpcOptions {
            crate::model::VpcOptions {
                subnet_ids: self.subnet_ids,
                security_group_ids: self.security_group_ids,
            }
        }
    }
}
impl VpcOptions {
    /// Creates a new builder-style object to manufacture [`VpcOptions`](crate::model::VpcOptions)
    pub fn builder() -> crate::model::vpc_options::Builder {
        crate::model::vpc_options::Builder::default()
    }
}

/// <p>The current options of an domain service software options.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ServiceSoftwareOptions {
    /// <p>The current service software version present on the domain.</p>
    pub current_version: std::option::Option<std::string::String>,
    /// <p>The new service software version if one is available.</p>
    pub new_version: std::option::Option<std::string::String>,
    /// <p> <code>True</code> if you're able to update your service software version. <code>False</code> if you can't update your service software version. </p>
    pub update_available: std::option::Option<bool>,
    /// <p> <code>True</code> if you're able to cancel your service software version update. <code>False</code> if you can't cancel your service software update. </p>
    pub cancellable: std::option::Option<bool>,
    /// <p>The status of your service software update. This field can take the following values: <code> ELIGIBLE</code>, <code>PENDING_UPDATE</code>, <code>IN_PROGRESS</code>, <code>COMPLETED</code>, and <code> NOT_ELIGIBLE</code>. </p>
    pub update_status: std::option::Option<crate::model::DeploymentStatus>,
    /// <p>The description of the <code>UpdateStatus</code>. </p>
    pub description: std::option::Option<std::string::String>,
    /// <p>The timestamp, in Epoch time, until which you can manually request a service software update. After this date, we automatically update your service software. </p>
    pub automated_update_date: std::option::Option<aws_smithy_types::DateTime>,
    /// <p> <code>True</code> if a service software is never automatically updated. <code>False</code> if a service software is automatically updated after <code>AutomatedUpdateDate</code>. </p>
    pub optional_deployment: std::option::Option<bool>,
}
impl ServiceSoftwareOptions {
    /// <p>The current service software version present on the domain.</p>
    pub fn current_version(&self) -> std::option::Option<&str> {
        self.current_version.as_deref()
    }
    /// <p>The new service software version if one is available.</p>
    pub fn new_version(&self) -> std::option::Option<&str> {
        self.new_version.as_deref()
    }
    /// <p> <code>True</code> if you're able to update your service software version. <code>False</code> if you can't update your service software version. </p>
    pub fn update_available(&self) -> std::option::Option<bool> {
        self.update_available
    }
    /// <p> <code>True</code> if you're able to cancel your service software version update. <code>False</code> if you can't cancel your service software update. </p>
    pub fn cancellable(&self) -> std::option::Option<bool> {
        self.cancellable
    }
    /// <p>The status of your service software update. This field can take the following values: <code> ELIGIBLE</code>, <code>PENDING_UPDATE</code>, <code>IN_PROGRESS</code>, <code>COMPLETED</code>, and <code> NOT_ELIGIBLE</code>. </p>
    pub fn update_status(&self) -> std::option::Option<&crate::model::DeploymentStatus> {
        self.update_status.as_ref()
    }
    /// <p>The description of the <code>UpdateStatus</code>. </p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The timestamp, in Epoch time, until which you can manually request a service software update. After this date, we automatically update your service software. </p>
    pub fn automated_update_date(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.automated_update_date.as_ref()
    }
    /// <p> <code>True</code> if a service software is never automatically updated. <code>False</code> if a service software is automatically updated after <code>AutomatedUpdateDate</code>. </p>
    pub fn optional_deployment(&self) -> std::option::Option<bool> {
        self.optional_deployment
    }
}
impl std::fmt::Debug for ServiceSoftwareOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ServiceSoftwareOptions");
        formatter.field("current_version", &self.current_version);
        formatter.field("new_version", &self.new_version);
        formatter.field("update_available", &self.update_available);
        formatter.field("cancellable", &self.cancellable);
        formatter.field("update_status", &self.update_status);
        formatter.field("description", &self.description);
        formatter.field("automated_update_date", &self.automated_update_date);
        formatter.field("optional_deployment", &self.optional_deployment);
        formatter.finish()
    }
}
/// See [`ServiceSoftwareOptions`](crate::model::ServiceSoftwareOptions)
pub mod service_software_options {

    /// A builder for [`ServiceSoftwareOptions`](crate::model::ServiceSoftwareOptions)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) current_version: std::option::Option<std::string::String>,
        pub(crate) new_version: std::option::Option<std::string::String>,
        pub(crate) update_available: std::option::Option<bool>,
        pub(crate) cancellable: std::option::Option<bool>,
        pub(crate) update_status: std::option::Option<crate::model::DeploymentStatus>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) automated_update_date: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) optional_deployment: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The current service software version present on the domain.</p>
        pub fn current_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.current_version = Some(input.into());
            self
        }
        /// <p>The current service software version present on the domain.</p>
        pub fn set_current_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.current_version = input;
            self
        }
        /// <p>The new service software version if one is available.</p>
        pub fn new_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.new_version = Some(input.into());
            self
        }
        /// <p>The new service software version if one is available.</p>
        pub fn set_new_version(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.new_version = input;
            self
        }
        /// <p> <code>True</code> if you're able to update your service software version. <code>False</code> if you can't update your service software version. </p>
        pub fn update_available(mut self, input: bool) -> Self {
            self.update_available = Some(input);
            self
        }
        /// <p> <code>True</code> if you're able to update your service software version. <code>False</code> if you can't update your service software version. </p>
        pub fn set_update_available(mut self, input: std::option::Option<bool>) -> Self {
            self.update_available = input;
            self
        }
        /// <p> <code>True</code> if you're able to cancel your service software version update. <code>False</code> if you can't cancel your service software update. </p>
        pub fn cancellable(mut self, input: bool) -> Self {
            self.cancellable = Some(input);
            self
        }
        /// <p> <code>True</code> if you're able to cancel your service software version update. <code>False</code> if you can't cancel your service software update. </p>
        pub fn set_cancellable(mut self, input: std::option::Option<bool>) -> Self {
            self.cancellable = input;
            self
        }
        /// <p>The status of your service software update. This field can take the following values: <code> ELIGIBLE</code>, <code>PENDING_UPDATE</code>, <code>IN_PROGRESS</code>, <code>COMPLETED</code>, and <code> NOT_ELIGIBLE</code>. </p>
        pub fn update_status(mut self, input: crate::model::DeploymentStatus) -> Self {
            self.update_status = Some(input);
            self
        }
        /// <p>The status of your service software update. This field can take the following values: <code> ELIGIBLE</code>, <code>PENDING_UPDATE</code>, <code>IN_PROGRESS</code>, <code>COMPLETED</code>, and <code> NOT_ELIGIBLE</code>. </p>
        pub fn set_update_status(
            mut self,
            input: std::option::Option<crate::model::DeploymentStatus>,
        ) -> Self {
            self.update_status = input;
            self
        }
        /// <p>The description of the <code>UpdateStatus</code>. </p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the <code>UpdateStatus</code>. </p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The timestamp, in Epoch time, until which you can manually request a service software update. After this date, we automatically update your service software. </p>
        pub fn automated_update_date(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.automated_update_date = Some(input);
            self
        }
        /// <p>The timestamp, in Epoch time, until which you can manually request a service software update. After this date, we automatically update your service software. </p>
        pub fn set_automated_update_date(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.automated_update_date = input;
            self
        }
        /// <p> <code>True</code> if a service software is never automatically updated. <code>False</code> if a service software is automatically updated after <code>AutomatedUpdateDate</code>. </p>
        pub fn optional_deployment(mut self, input: bool) -> Self {
            self.optional_deployment = Some(input);
            self
        }
        /// <p> <code>True</code> if a service software is never automatically updated. <code>False</code> if a service software is automatically updated after <code>AutomatedUpdateDate</code>. </p>
        pub fn set_optional_deployment(mut self, input: std::option::Option<bool>) -> Self {
            self.optional_deployment = input;
            self
        }
        /// Consumes the builder and constructs a [`ServiceSoftwareOptions`](crate::model::ServiceSoftwareOptions)
        pub fn build(self) -> crate::model::ServiceSoftwareOptions {
            crate::model::ServiceSoftwareOptions {
                current_version: self.current_version,
                new_version: self.new_version,
                update_available: self.update_available,
                cancellable: self.cancellable,
                update_status: self.update_status,
                description: self.description,
                automated_update_date: self.automated_update_date,
                optional_deployment: self.optional_deployment,
            }
        }
    }
}
impl ServiceSoftwareOptions {
    /// Creates a new builder-style object to manufacture [`ServiceSoftwareOptions`](crate::model::ServiceSoftwareOptions)
    pub fn builder() -> crate::model::service_software_options::Builder {
        crate::model::service_software_options::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DeploymentStatus {
    #[allow(missing_docs)] // documentation missing in model
    Completed,
    #[allow(missing_docs)] // documentation missing in model
    Eligible,
    #[allow(missing_docs)] // documentation missing in model
    InProgress,
    #[allow(missing_docs)] // documentation missing in model
    NotEligible,
    #[allow(missing_docs)] // documentation missing in model
    PendingUpdate,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for DeploymentStatus {
    fn from(s: &str) -> Self {
        match s {
            "COMPLETED" => DeploymentStatus::Completed,
            "ELIGIBLE" => DeploymentStatus::Eligible,
            "IN_PROGRESS" => DeploymentStatus::InProgress,
            "NOT_ELIGIBLE" => DeploymentStatus::NotEligible,
            "PENDING_UPDATE" => DeploymentStatus::PendingUpdate,
            other => DeploymentStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for DeploymentStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DeploymentStatus::from(s))
    }
}
impl DeploymentStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            DeploymentStatus::Completed => "COMPLETED",
            DeploymentStatus::Eligible => "ELIGIBLE",
            DeploymentStatus::InProgress => "IN_PROGRESS",
            DeploymentStatus::NotEligible => "NOT_ELIGIBLE",
            DeploymentStatus::PendingUpdate => "PENDING_UPDATE",
            DeploymentStatus::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "COMPLETED",
            "ELIGIBLE",
            "IN_PROGRESS",
            "NOT_ELIGIBLE",
            "PENDING_UPDATE",
        ]
    }
}
impl AsRef<str> for DeploymentStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Details of an inbound connection.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InboundConnection {
    /// <p>The <code> <code>AWSDomainInformation</code> </code> for the local OpenSearch domain. </p>
    pub local_domain_info: std::option::Option<crate::model::DomainInformationContainer>,
    /// <p>The <code> <code>AWSDomainInformation</code> </code> for the remote OpenSearch domain. </p>
    pub remote_domain_info: std::option::Option<crate::model::DomainInformationContainer>,
    /// <p>The connection ID for the inbound cross-cluster connection.</p>
    pub connection_id: std::option::Option<std::string::String>,
    /// <p>The <code> <code>InboundConnectionStatus</code> </code> for the outbound connection. </p>
    pub connection_status: std::option::Option<crate::model::InboundConnectionStatus>,
}
impl InboundConnection {
    /// <p>The <code> <code>AWSDomainInformation</code> </code> for the local OpenSearch domain. </p>
    pub fn local_domain_info(
        &self,
    ) -> std::option::Option<&crate::model::DomainInformationContainer> {
        self.local_domain_info.as_ref()
    }
    /// <p>The <code> <code>AWSDomainInformation</code> </code> for the remote OpenSearch domain. </p>
    pub fn remote_domain_info(
        &self,
    ) -> std::option::Option<&crate::model::DomainInformationContainer> {
        self.remote_domain_info.as_ref()
    }
    /// <p>The connection ID for the inbound cross-cluster connection.</p>
    pub fn connection_id(&self) -> std::option::Option<&str> {
        self.connection_id.as_deref()
    }
    /// <p>The <code> <code>InboundConnectionStatus</code> </code> for the outbound connection. </p>
    pub fn connection_status(&self) -> std::option::Option<&crate::model::InboundConnectionStatus> {
        self.connection_status.as_ref()
    }
}
impl std::fmt::Debug for InboundConnection {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InboundConnection");
        formatter.field("local_domain_info", &self.local_domain_info);
        formatter.field("remote_domain_info", &self.remote_domain_info);
        formatter.field("connection_id", &self.connection_id);
        formatter.field("connection_status", &self.connection_status);
        formatter.finish()
    }
}
/// See [`InboundConnection`](crate::model::InboundConnection)
pub mod inbound_connection {

    /// A builder for [`InboundConnection`](crate::model::InboundConnection)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) local_domain_info: std::option::Option<crate::model::DomainInformationContainer>,
        pub(crate) remote_domain_info:
            std::option::Option<crate::model::DomainInformationContainer>,
        pub(crate) connection_id: std::option::Option<std::string::String>,
        pub(crate) connection_status: std::option::Option<crate::model::InboundConnectionStatus>,
    }
    impl Builder {
        /// <p>The <code> <code>AWSDomainInformation</code> </code> for the local OpenSearch domain. </p>
        pub fn local_domain_info(
            mut self,
            input: crate::model::DomainInformationContainer,
        ) -> Self {
            self.local_domain_info = Some(input);
            self
        }
        /// <p>The <code> <code>AWSDomainInformation</code> </code> for the local OpenSearch domain. </p>
        pub fn set_local_domain_info(
            mut self,
            input: std::option::Option<crate::model::DomainInformationContainer>,
        ) -> Self {
            self.local_domain_info = input;
            self
        }
        /// <p>The <code> <code>AWSDomainInformation</code> </code> for the remote OpenSearch domain. </p>
        pub fn remote_domain_info(
            mut self,
            input: crate::model::DomainInformationContainer,
        ) -> Self {
            self.remote_domain_info = Some(input);
            self
        }
        /// <p>The <code> <code>AWSDomainInformation</code> </code> for the remote OpenSearch domain. </p>
        pub fn set_remote_domain_info(
            mut self,
            input: std::option::Option<crate::model::DomainInformationContainer>,
        ) -> Self {
            self.remote_domain_info = input;
            self
        }
        /// <p>The connection ID for the inbound cross-cluster connection.</p>
        pub fn connection_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.connection_id = Some(input.into());
            self
        }
        /// <p>The connection ID for the inbound cross-cluster connection.</p>
        pub fn set_connection_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.connection_id = input;
            self
        }
        /// <p>The <code> <code>InboundConnectionStatus</code> </code> for the outbound connection. </p>
        pub fn connection_status(mut self, input: crate::model::InboundConnectionStatus) -> Self {
            self.connection_status = Some(input);
            self
        }
        /// <p>The <code> <code>InboundConnectionStatus</code> </code> for the outbound connection. </p>
        pub fn set_connection_status(
            mut self,
            input: std::option::Option<crate::model::InboundConnectionStatus>,
        ) -> Self {
            self.connection_status = input;
            self
        }
        /// Consumes the builder and constructs a [`InboundConnection`](crate::model::InboundConnection)
        pub fn build(self) -> crate::model::InboundConnection {
            crate::model::InboundConnection {
                local_domain_info: self.local_domain_info,
                remote_domain_info: self.remote_domain_info,
                connection_id: self.connection_id,
                connection_status: self.connection_status,
            }
        }
    }
}
impl InboundConnection {
    /// Creates a new builder-style object to manufacture [`InboundConnection`](crate::model::InboundConnection)
    pub fn builder() -> crate::model::inbound_connection::Builder {
        crate::model::inbound_connection::Builder::default()
    }
}

/// <p>The connection status of an inbound cross-cluster connection.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InboundConnectionStatus {
    /// <p>The state code for the inbound connection. Can be one of the following:</p>
    /// <ul>
    /// <li>PENDING_ACCEPTANCE: Inbound connection is not yet accepted by the remote domain owner.</li>
    /// <li>APPROVED: Inbound connection is pending acceptance by the remote domain owner.</li>
    /// <li>PROVISIONING: Inbound connection provisioning is in progress.</li>
    /// <li>ACTIVE: Inbound connection is active and ready to use.</li>
    /// <li>REJECTING: Inbound connection rejection is in process.</li>
    /// <li>REJECTED: Inbound connection is rejected.</li>
    /// <li>DELETING: Inbound connection deletion is in progress.</li>
    /// <li>DELETED: Inbound connection is deleted and can no longer be used.</li>
    /// </ul>
    pub status_code: std::option::Option<crate::model::InboundConnectionStatusCode>,
    /// <p>Verbose information for the inbound connection status.</p>
    pub message: std::option::Option<std::string::String>,
}
impl InboundConnectionStatus {
    /// <p>The state code for the inbound connection. Can be one of the following:</p>
    /// <ul>
    /// <li>PENDING_ACCEPTANCE: Inbound connection is not yet accepted by the remote domain owner.</li>
    /// <li>APPROVED: Inbound connection is pending acceptance by the remote domain owner.</li>
    /// <li>PROVISIONING: Inbound connection provisioning is in progress.</li>
    /// <li>ACTIVE: Inbound connection is active and ready to use.</li>
    /// <li>REJECTING: Inbound connection rejection is in process.</li>
    /// <li>REJECTED: Inbound connection is rejected.</li>
    /// <li>DELETING: Inbound connection deletion is in progress.</li>
    /// <li>DELETED: Inbound connection is deleted and can no longer be used.</li>
    /// </ul>
    pub fn status_code(&self) -> std::option::Option<&crate::model::InboundConnectionStatusCode> {
        self.status_code.as_ref()
    }
    /// <p>Verbose information for the inbound connection status.</p>
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Debug for InboundConnectionStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InboundConnectionStatus");
        formatter.field("status_code", &self.status_code);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
/// See [`InboundConnectionStatus`](crate::model::InboundConnectionStatus)
pub mod inbound_connection_status {

    /// A builder for [`InboundConnectionStatus`](crate::model::InboundConnectionStatus)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) status_code: std::option::Option<crate::model::InboundConnectionStatusCode>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The state code for the inbound connection. Can be one of the following:</p>
        /// <ul>
        /// <li>PENDING_ACCEPTANCE: Inbound connection is not yet accepted by the remote domain owner.</li>
        /// <li>APPROVED: Inbound connection is pending acceptance by the remote domain owner.</li>
        /// <li>PROVISIONING: Inbound connection provisioning is in progress.</li>
        /// <li>ACTIVE: Inbound connection is active and ready to use.</li>
        /// <li>REJECTING: Inbound connection rejection is in process.</li>
        /// <li>REJECTED: Inbound connection is rejected.</li>
        /// <li>DELETING: Inbound connection deletion is in progress.</li>
        /// <li>DELETED: Inbound connection is deleted and can no longer be used.</li>
        /// </ul>
        pub fn status_code(mut self, input: crate::model::InboundConnectionStatusCode) -> Self {
            self.status_code = Some(input);
            self
        }
        /// <p>The state code for the inbound connection. Can be one of the following:</p>
        /// <ul>
        /// <li>PENDING_ACCEPTANCE: Inbound connection is not yet accepted by the remote domain owner.</li>
        /// <li>APPROVED: Inbound connection is pending acceptance by the remote domain owner.</li>
        /// <li>PROVISIONING: Inbound connection provisioning is in progress.</li>
        /// <li>ACTIVE: Inbound connection is active and ready to use.</li>
        /// <li>REJECTING: Inbound connection rejection is in process.</li>
        /// <li>REJECTED: Inbound connection is rejected.</li>
        /// <li>DELETING: Inbound connection deletion is in progress.</li>
        /// <li>DELETED: Inbound connection is deleted and can no longer be used.</li>
        /// </ul>
        pub fn set_status_code(
            mut self,
            input: std::option::Option<crate::model::InboundConnectionStatusCode>,
        ) -> Self {
            self.status_code = input;
            self
        }
        /// <p>Verbose information for the inbound connection status.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Verbose information for the inbound connection status.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InboundConnectionStatus`](crate::model::InboundConnectionStatus)
        pub fn build(self) -> crate::model::InboundConnectionStatus {
            crate::model::InboundConnectionStatus {
                status_code: self.status_code,
                message: self.message,
            }
        }
    }
}
impl InboundConnectionStatus {
    /// Creates a new builder-style object to manufacture [`InboundConnectionStatus`](crate::model::InboundConnectionStatus)
    pub fn builder() -> crate::model::inbound_connection_status::Builder {
        crate::model::inbound_connection_status::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum InboundConnectionStatusCode {
    #[allow(missing_docs)] // documentation missing in model
    Active,
    #[allow(missing_docs)] // documentation missing in model
    Approved,
    #[allow(missing_docs)] // documentation missing in model
    Deleted,
    #[allow(missing_docs)] // documentation missing in model
    Deleting,
    #[allow(missing_docs)] // documentation missing in model
    PendingAcceptance,
    #[allow(missing_docs)] // documentation missing in model
    Provisioning,
    #[allow(missing_docs)] // documentation missing in model
    Rejected,
    #[allow(missing_docs)] // documentation missing in model
    Rejecting,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for InboundConnectionStatusCode {
    fn from(s: &str) -> Self {
        match s {
            "ACTIVE" => InboundConnectionStatusCode::Active,
            "APPROVED" => InboundConnectionStatusCode::Approved,
            "DELETED" => InboundConnectionStatusCode::Deleted,
            "DELETING" => InboundConnectionStatusCode::Deleting,
            "PENDING_ACCEPTANCE" => InboundConnectionStatusCode::PendingAcceptance,
            "PROVISIONING" => InboundConnectionStatusCode::Provisioning,
            "REJECTED" => InboundConnectionStatusCode::Rejected,
            "REJECTING" => InboundConnectionStatusCode::Rejecting,
            other => InboundConnectionStatusCode::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for InboundConnectionStatusCode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(InboundConnectionStatusCode::from(s))
    }
}
impl InboundConnectionStatusCode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            InboundConnectionStatusCode::Active => "ACTIVE",
            InboundConnectionStatusCode::Approved => "APPROVED",
            InboundConnectionStatusCode::Deleted => "DELETED",
            InboundConnectionStatusCode::Deleting => "DELETING",
            InboundConnectionStatusCode::PendingAcceptance => "PENDING_ACCEPTANCE",
            InboundConnectionStatusCode::Provisioning => "PROVISIONING",
            InboundConnectionStatusCode::Rejected => "REJECTED",
            InboundConnectionStatusCode::Rejecting => "REJECTING",
            InboundConnectionStatusCode::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "ACTIVE",
            "APPROVED",
            "DELETED",
            "DELETING",
            "PENDING_ACCEPTANCE",
            "PROVISIONING",
            "REJECTED",
            "REJECTING",
        ]
    }
}
impl AsRef<str> for InboundConnectionStatusCode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DomainInformationContainer {
    #[allow(missing_docs)] // documentation missing in model
    pub aws_domain_information: std::option::Option<crate::model::AwsDomainInformation>,
}
impl DomainInformationContainer {
    #[allow(missing_docs)] // documentation missing in model
    pub fn aws_domain_information(
        &self,
    ) -> std::option::Option<&crate::model::AwsDomainInformation> {
        self.aws_domain_information.as_ref()
    }
}
impl std::fmt::Debug for DomainInformationContainer {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DomainInformationContainer");
        formatter.field("aws_domain_information", &self.aws_domain_information);
        formatter.finish()
    }
}
/// See [`DomainInformationContainer`](crate::model::DomainInformationContainer)
pub mod domain_information_container {

    /// A builder for [`DomainInformationContainer`](crate::model::DomainInformationContainer)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) aws_domain_information: std::option::Option<crate::model::AwsDomainInformation>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn aws_domain_information(mut self, input: crate::model::AwsDomainInformation) -> Self {
            self.aws_domain_information = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_aws_domain_information(
            mut self,
            input: std::option::Option<crate::model::AwsDomainInformation>,
        ) -> Self {
            self.aws_domain_information = input;
            self
        }
        /// Consumes the builder and constructs a [`DomainInformationContainer`](crate::model::DomainInformationContainer)
        pub fn build(self) -> crate::model::DomainInformationContainer {
            crate::model::DomainInformationContainer {
                aws_domain_information: self.aws_domain_information,
            }
        }
    }
}
impl DomainInformationContainer {
    /// Creates a new builder-style object to manufacture [`DomainInformationContainer`](crate::model::DomainInformationContainer)
    pub fn builder() -> crate::model::domain_information_container::Builder {
        crate::model::domain_information_container::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsDomainInformation {
    #[allow(missing_docs)] // documentation missing in model
    pub owner_id: std::option::Option<std::string::String>,
    /// <p>The name of an domain. Domain names are unique across the domains owned by an account within an AWS region. Domain names start with a letter or number and can contain the following characters: a-z (lowercase), 0-9, and - (hyphen). </p>
    pub domain_name: std::option::Option<std::string::String>,
    #[allow(missing_docs)] // documentation missing in model
    pub region: std::option::Option<std::string::String>,
}
impl AwsDomainInformation {
    #[allow(missing_docs)] // documentation missing in model
    pub fn owner_id(&self) -> std::option::Option<&str> {
        self.owner_id.as_deref()
    }
    /// <p>The name of an domain. Domain names are unique across the domains owned by an account within an AWS region. Domain names start with a letter or number and can contain the following characters: a-z (lowercase), 0-9, and - (hyphen). </p>
    pub fn domain_name(&self) -> std::option::Option<&str> {
        self.domain_name.as_deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn region(&self) -> std::option::Option<&str> {
        self.region.as_deref()
    }
}
impl std::fmt::Debug for AwsDomainInformation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsDomainInformation");
        formatter.field("owner_id", &self.owner_id);
        formatter.field("domain_name", &self.domain_name);
        formatter.field("region", &self.region);
        formatter.finish()
    }
}
/// See [`AwsDomainInformation`](crate::model::AwsDomainInformation)
pub mod aws_domain_information {

    /// A builder for [`AwsDomainInformation`](crate::model::AwsDomainInformation)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) owner_id: std::option::Option<std::string::String>,
        pub(crate) domain_name: std::option::Option<std::string::String>,
        pub(crate) region: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn owner_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.owner_id = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_owner_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.owner_id = input;
            self
        }
        /// <p>The name of an domain. Domain names are unique across the domains owned by an account within an AWS region. Domain names start with a letter or number and can contain the following characters: a-z (lowercase), 0-9, and - (hyphen). </p>
        pub fn domain_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_name = Some(input.into());
            self
        }
        /// <p>The name of an domain. Domain names are unique across the domains owned by an account within an AWS region. Domain names start with a letter or number and can contain the following characters: a-z (lowercase), 0-9, and - (hyphen). </p>
        pub fn set_domain_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_name = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn region(mut self, input: impl Into<std::string::String>) -> Self {
            self.region = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_region(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.region = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsDomainInformation`](crate::model::AwsDomainInformation)
        pub fn build(self) -> crate::model::AwsDomainInformation {
            crate::model::AwsDomainInformation {
                owner_id: self.owner_id,
                domain_name: self.domain_name,
                region: self.region,
            }
        }
    }
}
impl AwsDomainInformation {
    /// Creates a new builder-style object to manufacture [`AwsDomainInformation`](crate::model::AwsDomainInformation)
    pub fn builder() -> crate::model::aws_domain_information::Builder {
        crate::model::aws_domain_information::Builder::default()
    }
}

/// <p>A key value pair for a resource tag.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Tag {
    /// <p>The <code>TagKey</code>, the name of the tag. Tag keys must be unique for the domain to which they are attached. </p>
    pub key: std::option::Option<std::string::String>,
    /// <p>The <code>TagValue</code>, the value assigned to the corresponding tag key. Tag values can be null and don't have to be unique in a tag set. For example, you can have a key value pair in a tag set of <code>project : Trinity</code> and <code>cost-center : Trinity</code> </p>
    pub value: std::option::Option<std::string::String>,
}
impl Tag {
    /// <p>The <code>TagKey</code>, the name of the tag. Tag keys must be unique for the domain to which they are attached. </p>
    pub fn key(&self) -> std::option::Option<&str> {
        self.key.as_deref()
    }
    /// <p>The <code>TagValue</code>, the value assigned to the corresponding tag key. Tag values can be null and don't have to be unique in a tag set. For example, you can have a key value pair in a tag set of <code>project : Trinity</code> and <code>cost-center : Trinity</code> </p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
}
impl std::fmt::Debug for Tag {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Tag");
        formatter.field("key", &self.key);
        formatter.field("value", &self.value);
        formatter.finish()
    }
}
/// See [`Tag`](crate::model::Tag)
pub mod tag {

    /// A builder for [`Tag`](crate::model::Tag)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The <code>TagKey</code>, the name of the tag. Tag keys must be unique for the domain to which they are attached. </p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        /// <p>The <code>TagKey</code>, the name of the tag. Tag keys must be unique for the domain to which they are attached. </p>
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// <p>The <code>TagValue</code>, the value assigned to the corresponding tag key. Tag values can be null and don't have to be unique in a tag set. For example, you can have a key value pair in a tag set of <code>project : Trinity</code> and <code>cost-center : Trinity</code> </p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>The <code>TagValue</code>, the value assigned to the corresponding tag key. Tag values can be null and don't have to be unique in a tag set. For example, you can have a key value pair in a tag set of <code>project : Trinity</code> and <code>cost-center : Trinity</code> </p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`Tag`](crate::model::Tag)
        pub fn build(self) -> crate::model::Tag {
            crate::model::Tag {
                key: self.key,
                value: self.value,
            }
        }
    }
}
impl Tag {
    /// Creates a new builder-style object to manufacture [`Tag`](crate::model::Tag)
    pub fn builder() -> crate::model::tag::Builder {
        crate::model::tag::Builder::default()
    }
}

/// <p>Information on a package associated with a domain.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DomainPackageDetails {
    /// <p>The internal ID of the package.</p>
    pub package_id: std::option::Option<std::string::String>,
    /// <p>User-specified name of the package.</p>
    pub package_name: std::option::Option<std::string::String>,
    /// <p>Currently supports only TXT-DICTIONARY.</p>
    pub package_type: std::option::Option<crate::model::PackageType>,
    /// <p>The timestamp of the most recent update to the package association status.</p>
    pub last_updated: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The name of the domain you've associated a package with.</p>
    pub domain_name: std::option::Option<std::string::String>,
    /// <p>State of the association. Values are ASSOCIATING, ASSOCIATION_FAILED, ACTIVE, DISSOCIATING, and DISSOCIATION_FAILED.</p>
    pub domain_package_status: std::option::Option<crate::model::DomainPackageStatus>,
    #[allow(missing_docs)] // documentation missing in model
    pub package_version: std::option::Option<std::string::String>,
    /// <p>The relative path on Amazon OpenSearch Service nodes, which can be used as synonym_path when the package is a synonym file.</p>
    pub reference_path: std::option::Option<std::string::String>,
    /// <p>Additional information if the package is in an error state. Null otherwise.</p>
    pub error_details: std::option::Option<crate::model::ErrorDetails>,
}
impl DomainPackageDetails {
    /// <p>The internal ID of the package.</p>
    pub fn package_id(&self) -> std::option::Option<&str> {
        self.package_id.as_deref()
    }
    /// <p>User-specified name of the package.</p>
    pub fn package_name(&self) -> std::option::Option<&str> {
        self.package_name.as_deref()
    }
    /// <p>Currently supports only TXT-DICTIONARY.</p>
    pub fn package_type(&self) -> std::option::Option<&crate::model::PackageType> {
        self.package_type.as_ref()
    }
    /// <p>The timestamp of the most recent update to the package association status.</p>
    pub fn last_updated(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_updated.as_ref()
    }
    /// <p>The name of the domain you've associated a package with.</p>
    pub fn domain_name(&self) -> std::option::Option<&str> {
        self.domain_name.as_deref()
    }
    /// <p>State of the association. Values are ASSOCIATING, ASSOCIATION_FAILED, ACTIVE, DISSOCIATING, and DISSOCIATION_FAILED.</p>
    pub fn domain_package_status(&self) -> std::option::Option<&crate::model::DomainPackageStatus> {
        self.domain_package_status.as_ref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn package_version(&self) -> std::option::Option<&str> {
        self.package_version.as_deref()
    }
    /// <p>The relative path on Amazon OpenSearch Service nodes, which can be used as synonym_path when the package is a synonym file.</p>
    pub fn reference_path(&self) -> std::option::Option<&str> {
        self.reference_path.as_deref()
    }
    /// <p>Additional information if the package is in an error state. Null otherwise.</p>
    pub fn error_details(&self) -> std::option::Option<&crate::model::ErrorDetails> {
        self.error_details.as_ref()
    }
}
impl std::fmt::Debug for DomainPackageDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DomainPackageDetails");
        formatter.field("package_id", &self.package_id);
        formatter.field("package_name", &self.package_name);
        formatter.field("package_type", &self.package_type);
        formatter.field("last_updated", &self.last_updated);
        formatter.field("domain_name", &self.domain_name);
        formatter.field("domain_package_status", &self.domain_package_status);
        formatter.field("package_version", &self.package_version);
        formatter.field("reference_path", &self.reference_path);
        formatter.field("error_details", &self.error_details);
        formatter.finish()
    }
}
/// See [`DomainPackageDetails`](crate::model::DomainPackageDetails)
pub mod domain_package_details {

    /// A builder for [`DomainPackageDetails`](crate::model::DomainPackageDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) package_id: std::option::Option<std::string::String>,
        pub(crate) package_name: std::option::Option<std::string::String>,
        pub(crate) package_type: std::option::Option<crate::model::PackageType>,
        pub(crate) last_updated: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) domain_name: std::option::Option<std::string::String>,
        pub(crate) domain_package_status: std::option::Option<crate::model::DomainPackageStatus>,
        pub(crate) package_version: std::option::Option<std::string::String>,
        pub(crate) reference_path: std::option::Option<std::string::String>,
        pub(crate) error_details: std::option::Option<crate::model::ErrorDetails>,
    }
    impl Builder {
        /// <p>The internal ID of the package.</p>
        pub fn package_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.package_id = Some(input.into());
            self
        }
        /// <p>The internal ID of the package.</p>
        pub fn set_package_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.package_id = input;
            self
        }
        /// <p>User-specified name of the package.</p>
        pub fn package_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.package_name = Some(input.into());
            self
        }
        /// <p>User-specified name of the package.</p>
        pub fn set_package_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.package_name = input;
            self
        }
        /// <p>Currently supports only TXT-DICTIONARY.</p>
        pub fn package_type(mut self, input: crate::model::PackageType) -> Self {
            self.package_type = Some(input);
            self
        }
        /// <p>Currently supports only TXT-DICTIONARY.</p>
        pub fn set_package_type(
            mut self,
            input: std::option::Option<crate::model::PackageType>,
        ) -> Self {
            self.package_type = input;
            self
        }
        /// <p>The timestamp of the most recent update to the package association status.</p>
        pub fn last_updated(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_updated = Some(input);
            self
        }
        /// <p>The timestamp of the most recent update to the package association status.</p>
        pub fn set_last_updated(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_updated = input;
            self
        }
        /// <p>The name of the domain you've associated a package with.</p>
        pub fn domain_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_name = Some(input.into());
            self
        }
        /// <p>The name of the domain you've associated a package with.</p>
        pub fn set_domain_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_name = input;
            self
        }
        /// <p>State of the association. Values are ASSOCIATING, ASSOCIATION_FAILED, ACTIVE, DISSOCIATING, and DISSOCIATION_FAILED.</p>
        pub fn domain_package_status(mut self, input: crate::model::DomainPackageStatus) -> Self {
            self.domain_package_status = Some(input);
            self
        }
        /// <p>State of the association. Values are ASSOCIATING, ASSOCIATION_FAILED, ACTIVE, DISSOCIATING, and DISSOCIATION_FAILED.</p>
        pub fn set_domain_package_status(
            mut self,
            input: std::option::Option<crate::model::DomainPackageStatus>,
        ) -> Self {
            self.domain_package_status = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn package_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.package_version = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_package_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.package_version = input;
            self
        }
        /// <p>The relative path on Amazon OpenSearch Service nodes, which can be used as synonym_path when the package is a synonym file.</p>
        pub fn reference_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.reference_path = Some(input.into());
            self
        }
        /// <p>The relative path on Amazon OpenSearch Service nodes, which can be used as synonym_path when the package is a synonym file.</p>
        pub fn set_reference_path(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.reference_path = input;
            self
        }
        /// <p>Additional information if the package is in an error state. Null otherwise.</p>
        pub fn error_details(mut self, input: crate::model::ErrorDetails) -> Self {
            self.error_details = Some(input);
            self
        }
        /// <p>Additional information if the package is in an error state. Null otherwise.</p>
        pub fn set_error_details(
            mut self,
            input: std::option::Option<crate::model::ErrorDetails>,
        ) -> Self {
            self.error_details = input;
            self
        }
        /// Consumes the builder and constructs a [`DomainPackageDetails`](crate::model::DomainPackageDetails)
        pub fn build(self) -> crate::model::DomainPackageDetails {
            crate::model::DomainPackageDetails {
                package_id: self.package_id,
                package_name: self.package_name,
                package_type: self.package_type,
                last_updated: self.last_updated,
                domain_name: self.domain_name,
                domain_package_status: self.domain_package_status,
                package_version: self.package_version,
                reference_path: self.reference_path,
                error_details: self.error_details,
            }
        }
    }
}
impl DomainPackageDetails {
    /// Creates a new builder-style object to manufacture [`DomainPackageDetails`](crate::model::DomainPackageDetails)
    pub fn builder() -> crate::model::domain_package_details::Builder {
        crate::model::domain_package_details::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DomainPackageStatus {
    #[allow(missing_docs)] // documentation missing in model
    Active,
    #[allow(missing_docs)] // documentation missing in model
    Associating,
    #[allow(missing_docs)] // documentation missing in model
    AssociationFailed,
    #[allow(missing_docs)] // documentation missing in model
    Dissociating,
    #[allow(missing_docs)] // documentation missing in model
    DissociationFailed,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for DomainPackageStatus {
    fn from(s: &str) -> Self {
        match s {
            "ACTIVE" => DomainPackageStatus::Active,
            "ASSOCIATING" => DomainPackageStatus::Associating,
            "ASSOCIATION_FAILED" => DomainPackageStatus::AssociationFailed,
            "DISSOCIATING" => DomainPackageStatus::Dissociating,
            "DISSOCIATION_FAILED" => DomainPackageStatus::DissociationFailed,
            other => DomainPackageStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for DomainPackageStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DomainPackageStatus::from(s))
    }
}
impl DomainPackageStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            DomainPackageStatus::Active => "ACTIVE",
            DomainPackageStatus::Associating => "ASSOCIATING",
            DomainPackageStatus::AssociationFailed => "ASSOCIATION_FAILED",
            DomainPackageStatus::Dissociating => "DISSOCIATING",
            DomainPackageStatus::DissociationFailed => "DISSOCIATION_FAILED",
            DomainPackageStatus::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "ACTIVE",
            "ASSOCIATING",
            "ASSOCIATION_FAILED",
            "DISSOCIATING",
            "DISSOCIATION_FAILED",
        ]
    }
}
impl AsRef<str> for DomainPackageStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InstanceTypeDetails {
    #[allow(missing_docs)] // documentation missing in model
    pub instance_type: std::option::Option<crate::model::OpenSearchPartitionInstanceType>,
    #[allow(missing_docs)] // documentation missing in model
    pub encryption_enabled: std::option::Option<bool>,
    #[allow(missing_docs)] // documentation missing in model
    pub cognito_enabled: std::option::Option<bool>,
    #[allow(missing_docs)] // documentation missing in model
    pub app_logs_enabled: std::option::Option<bool>,
    #[allow(missing_docs)] // documentation missing in model
    pub advanced_security_enabled: std::option::Option<bool>,
    #[allow(missing_docs)] // documentation missing in model
    pub warm_enabled: std::option::Option<bool>,
    #[allow(missing_docs)] // documentation missing in model
    pub instance_role: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl InstanceTypeDetails {
    #[allow(missing_docs)] // documentation missing in model
    pub fn instance_type(
        &self,
    ) -> std::option::Option<&crate::model::OpenSearchPartitionInstanceType> {
        self.instance_type.as_ref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn encryption_enabled(&self) -> std::option::Option<bool> {
        self.encryption_enabled
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn cognito_enabled(&self) -> std::option::Option<bool> {
        self.cognito_enabled
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn app_logs_enabled(&self) -> std::option::Option<bool> {
        self.app_logs_enabled
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn advanced_security_enabled(&self) -> std::option::Option<bool> {
        self.advanced_security_enabled
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn warm_enabled(&self) -> std::option::Option<bool> {
        self.warm_enabled
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn instance_role(&self) -> std::option::Option<&[std::string::String]> {
        self.instance_role.as_deref()
    }
}
impl std::fmt::Debug for InstanceTypeDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InstanceTypeDetails");
        formatter.field("instance_type", &self.instance_type);
        formatter.field("encryption_enabled", &self.encryption_enabled);
        formatter.field("cognito_enabled", &self.cognito_enabled);
        formatter.field("app_logs_enabled", &self.app_logs_enabled);
        formatter.field("advanced_security_enabled", &self.advanced_security_enabled);
        formatter.field("warm_enabled", &self.warm_enabled);
        formatter.field("instance_role", &self.instance_role);
        formatter.finish()
    }
}
/// See [`InstanceTypeDetails`](crate::model::InstanceTypeDetails)
pub mod instance_type_details {

    /// A builder for [`InstanceTypeDetails`](crate::model::InstanceTypeDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_type:
            std::option::Option<crate::model::OpenSearchPartitionInstanceType>,
        pub(crate) encryption_enabled: std::option::Option<bool>,
        pub(crate) cognito_enabled: std::option::Option<bool>,
        pub(crate) app_logs_enabled: std::option::Option<bool>,
        pub(crate) advanced_security_enabled: std::option::Option<bool>,
        pub(crate) warm_enabled: std::option::Option<bool>,
        pub(crate) instance_role: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn instance_type(
            mut self,
            input: crate::model::OpenSearchPartitionInstanceType,
        ) -> Self {
            self.instance_type = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_instance_type(
            mut self,
            input: std::option::Option<crate::model::OpenSearchPartitionInstanceType>,
        ) -> Self {
            self.instance_type = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn encryption_enabled(mut self, input: bool) -> Self {
            self.encryption_enabled = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_encryption_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.encryption_enabled = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn cognito_enabled(mut self, input: bool) -> Self {
            self.cognito_enabled = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_cognito_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.cognito_enabled = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn app_logs_enabled(mut self, input: bool) -> Self {
            self.app_logs_enabled = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_app_logs_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.app_logs_enabled = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn advanced_security_enabled(mut self, input: bool) -> Self {
            self.advanced_security_enabled = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_advanced_security_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.advanced_security_enabled = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn warm_enabled(mut self, input: bool) -> Self {
            self.warm_enabled = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_warm_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.warm_enabled = input;
            self
        }
        /// Appends an item to `instance_role`.
        ///
        /// To override the contents of this collection use [`set_instance_role`](Self::set_instance_role).
        ///
        pub fn instance_role(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.instance_role.unwrap_or_default();
            v.push(input.into());
            self.instance_role = Some(v);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_instance_role(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.instance_role = input;
            self
        }
        /// Consumes the builder and constructs a [`InstanceTypeDetails`](crate::model::InstanceTypeDetails)
        pub fn build(self) -> crate::model::InstanceTypeDetails {
            crate::model::InstanceTypeDetails {
                instance_type: self.instance_type,
                encryption_enabled: self.encryption_enabled,
                cognito_enabled: self.cognito_enabled,
                app_logs_enabled: self.app_logs_enabled,
                advanced_security_enabled: self.advanced_security_enabled,
                warm_enabled: self.warm_enabled,
                instance_role: self.instance_role,
            }
        }
    }
}
impl InstanceTypeDetails {
    /// Creates a new builder-style object to manufacture [`InstanceTypeDetails`](crate::model::InstanceTypeDetails)
    pub fn builder() -> crate::model::instance_type_details::Builder {
        crate::model::instance_type_details::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DomainInfo {
    /// <p>The <code>DomainName</code>. </p>
    pub domain_name: std::option::Option<std::string::String>,
    /// <p> Specifies the <code>EngineType</code> of the domain.</p>
    pub engine_type: std::option::Option<crate::model::EngineType>,
}
impl DomainInfo {
    /// <p>The <code>DomainName</code>. </p>
    pub fn domain_name(&self) -> std::option::Option<&str> {
        self.domain_name.as_deref()
    }
    /// <p> Specifies the <code>EngineType</code> of the domain.</p>
    pub fn engine_type(&self) -> std::option::Option<&crate::model::EngineType> {
        self.engine_type.as_ref()
    }
}
impl std::fmt::Debug for DomainInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DomainInfo");
        formatter.field("domain_name", &self.domain_name);
        formatter.field("engine_type", &self.engine_type);
        formatter.finish()
    }
}
/// See [`DomainInfo`](crate::model::DomainInfo)
pub mod domain_info {

    /// A builder for [`DomainInfo`](crate::model::DomainInfo)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain_name: std::option::Option<std::string::String>,
        pub(crate) engine_type: std::option::Option<crate::model::EngineType>,
    }
    impl Builder {
        /// <p>The <code>DomainName</code>. </p>
        pub fn domain_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_name = Some(input.into());
            self
        }
        /// <p>The <code>DomainName</code>. </p>
        pub fn set_domain_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_name = input;
            self
        }
        /// <p> Specifies the <code>EngineType</code> of the domain.</p>
        pub fn engine_type(mut self, input: crate::model::EngineType) -> Self {
            self.engine_type = Some(input);
            self
        }
        /// <p> Specifies the <code>EngineType</code> of the domain.</p>
        pub fn set_engine_type(
            mut self,
            input: std::option::Option<crate::model::EngineType>,
        ) -> Self {
            self.engine_type = input;
            self
        }
        /// Consumes the builder and constructs a [`DomainInfo`](crate::model::DomainInfo)
        pub fn build(self) -> crate::model::DomainInfo {
            crate::model::DomainInfo {
                domain_name: self.domain_name,
                engine_type: self.engine_type,
            }
        }
    }
}
impl DomainInfo {
    /// Creates a new builder-style object to manufacture [`DomainInfo`](crate::model::DomainInfo)
    pub fn builder() -> crate::model::domain_info::Builder {
        crate::model::domain_info::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum EngineType {
    #[allow(missing_docs)] // documentation missing in model
    Elasticsearch,
    #[allow(missing_docs)] // documentation missing in model
    OpenSearch,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for EngineType {
    fn from(s: &str) -> Self {
        match s {
            "Elasticsearch" => EngineType::Elasticsearch,
            "OpenSearch" => EngineType::OpenSearch,
            other => EngineType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for EngineType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(EngineType::from(s))
    }
}
impl EngineType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            EngineType::Elasticsearch => "Elasticsearch",
            EngineType::OpenSearch => "OpenSearch",
            EngineType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["Elasticsearch", "OpenSearch"]
    }
}
impl AsRef<str> for EngineType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum UpgradeStatus {
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    InProgress,
    #[allow(missing_docs)] // documentation missing in model
    Succeeded,
    #[allow(missing_docs)] // documentation missing in model
    SucceededWithIssues,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for UpgradeStatus {
    fn from(s: &str) -> Self {
        match s {
            "FAILED" => UpgradeStatus::Failed,
            "IN_PROGRESS" => UpgradeStatus::InProgress,
            "SUCCEEDED" => UpgradeStatus::Succeeded,
            "SUCCEEDED_WITH_ISSUES" => UpgradeStatus::SucceededWithIssues,
            other => UpgradeStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for UpgradeStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(UpgradeStatus::from(s))
    }
}
impl UpgradeStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            UpgradeStatus::Failed => "FAILED",
            UpgradeStatus::InProgress => "IN_PROGRESS",
            UpgradeStatus::Succeeded => "SUCCEEDED",
            UpgradeStatus::SucceededWithIssues => "SUCCEEDED_WITH_ISSUES",
            UpgradeStatus::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "FAILED",
            "IN_PROGRESS",
            "SUCCEEDED",
            "SUCCEEDED_WITH_ISSUES",
        ]
    }
}
impl AsRef<str> for UpgradeStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum UpgradeStep {
    #[allow(missing_docs)] // documentation missing in model
    PreUpgradeCheck,
    #[allow(missing_docs)] // documentation missing in model
    Snapshot,
    #[allow(missing_docs)] // documentation missing in model
    Upgrade,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for UpgradeStep {
    fn from(s: &str) -> Self {
        match s {
            "PRE_UPGRADE_CHECK" => UpgradeStep::PreUpgradeCheck,
            "SNAPSHOT" => UpgradeStep::Snapshot,
            "UPGRADE" => UpgradeStep::Upgrade,
            other => UpgradeStep::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for UpgradeStep {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(UpgradeStep::from(s))
    }
}
impl UpgradeStep {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            UpgradeStep::PreUpgradeCheck => "PRE_UPGRADE_CHECK",
            UpgradeStep::Snapshot => "SNAPSHOT",
            UpgradeStep::Upgrade => "UPGRADE",
            UpgradeStep::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["PRE_UPGRADE_CHECK", "SNAPSHOT", "UPGRADE"]
    }
}
impl AsRef<str> for UpgradeStep {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>History of the last 10 upgrades and upgrade eligibility checks.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpgradeHistory {
    /// <p>A string that briefly describes the upgrade.</p>
    pub upgrade_name: std::option::Option<std::string::String>,
    /// <p>UTC timestamp at which the upgrade API call was made in "yyyy-MM-ddTHH:mm:ssZ" format.</p>
    pub start_timestamp: std::option::Option<aws_smithy_types::DateTime>,
    /// <p> The current status of the upgrade. The status can take one of the following values: </p>
    /// <ul>
    /// <li>In Progress</li>
    /// <li>Succeeded</li>
    /// <li>Succeeded with Issues</li>
    /// <li>Failed</li>
    /// </ul>
    /// <p></p>
    pub upgrade_status: std::option::Option<crate::model::UpgradeStatus>,
    /// <p> A list of <code> <code>UpgradeStepItem</code> </code> s representing information about each step performed as part of a specific upgrade or upgrade eligibility check. </p>
    pub steps_list: std::option::Option<std::vec::Vec<crate::model::UpgradeStepItem>>,
}
impl UpgradeHistory {
    /// <p>A string that briefly describes the upgrade.</p>
    pub fn upgrade_name(&self) -> std::option::Option<&str> {
        self.upgrade_name.as_deref()
    }
    /// <p>UTC timestamp at which the upgrade API call was made in "yyyy-MM-ddTHH:mm:ssZ" format.</p>
    pub fn start_timestamp(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.start_timestamp.as_ref()
    }
    /// <p> The current status of the upgrade. The status can take one of the following values: </p>
    /// <ul>
    /// <li>In Progress</li>
    /// <li>Succeeded</li>
    /// <li>Succeeded with Issues</li>
    /// <li>Failed</li>
    /// </ul>
    /// <p></p>
    pub fn upgrade_status(&self) -> std::option::Option<&crate::model::UpgradeStatus> {
        self.upgrade_status.as_ref()
    }
    /// <p> A list of <code> <code>UpgradeStepItem</code> </code> s representing information about each step performed as part of a specific upgrade or upgrade eligibility check. </p>
    pub fn steps_list(&self) -> std::option::Option<&[crate::model::UpgradeStepItem]> {
        self.steps_list.as_deref()
    }
}
impl std::fmt::Debug for UpgradeHistory {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpgradeHistory");
        formatter.field("upgrade_name", &self.upgrade_name);
        formatter.field("start_timestamp", &self.start_timestamp);
        formatter.field("upgrade_status", &self.upgrade_status);
        formatter.field("steps_list", &self.steps_list);
        formatter.finish()
    }
}
/// See [`UpgradeHistory`](crate::model::UpgradeHistory)
pub mod upgrade_history {

    /// A builder for [`UpgradeHistory`](crate::model::UpgradeHistory)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) upgrade_name: std::option::Option<std::string::String>,
        pub(crate) start_timestamp: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) upgrade_status: std::option::Option<crate::model::UpgradeStatus>,
        pub(crate) steps_list: std::option::Option<std::vec::Vec<crate::model::UpgradeStepItem>>,
    }
    impl Builder {
        /// <p>A string that briefly describes the upgrade.</p>
        pub fn upgrade_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.upgrade_name = Some(input.into());
            self
        }
        /// <p>A string that briefly describes the upgrade.</p>
        pub fn set_upgrade_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.upgrade_name = input;
            self
        }
        /// <p>UTC timestamp at which the upgrade API call was made in "yyyy-MM-ddTHH:mm:ssZ" format.</p>
        pub fn start_timestamp(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.start_timestamp = Some(input);
            self
        }
        /// <p>UTC timestamp at which the upgrade API call was made in "yyyy-MM-ddTHH:mm:ssZ" format.</p>
        pub fn set_start_timestamp(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.start_timestamp = input;
            self
        }
        /// <p> The current status of the upgrade. The status can take one of the following values: </p>
        /// <ul>
        /// <li>In Progress</li>
        /// <li>Succeeded</li>
        /// <li>Succeeded with Issues</li>
        /// <li>Failed</li>
        /// </ul>
        /// <p></p>
        pub fn upgrade_status(mut self, input: crate::model::UpgradeStatus) -> Self {
            self.upgrade_status = Some(input);
            self
        }
        /// <p> The current status of the upgrade. The status can take one of the following values: </p>
        /// <ul>
        /// <li>In Progress</li>
        /// <li>Succeeded</li>
        /// <li>Succeeded with Issues</li>
        /// <li>Failed</li>
        /// </ul>
        /// <p></p>
        pub fn set_upgrade_status(
            mut self,
            input: std::option::Option<crate::model::UpgradeStatus>,
        ) -> Self {
            self.upgrade_status = input;
            self
        }
        /// Appends an item to `steps_list`.
        ///
        /// To override the contents of this collection use [`set_steps_list`](Self::set_steps_list).
        ///
        /// <p> A list of <code> <code>UpgradeStepItem</code> </code> s representing information about each step performed as part of a specific upgrade or upgrade eligibility check. </p>
        pub fn steps_list(mut self, input: crate::model::UpgradeStepItem) -> Self {
            let mut v = self.steps_list.unwrap_or_default();
            v.push(input);
            self.steps_list = Some(v);
            self
        }
        /// <p> A list of <code> <code>UpgradeStepItem</code> </code> s representing information about each step performed as part of a specific upgrade or upgrade eligibility check. </p>
        pub fn set_steps_list(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::UpgradeStepItem>>,
        ) -> Self {
            self.steps_list = input;
            self
        }
        /// Consumes the builder and constructs a [`UpgradeHistory`](crate::model::UpgradeHistory)
        pub fn build(self) -> crate::model::UpgradeHistory {
            crate::model::UpgradeHistory {
                upgrade_name: self.upgrade_name,
                start_timestamp: self.start_timestamp,
                upgrade_status: self.upgrade_status,
                steps_list: self.steps_list,
            }
        }
    }
}
impl UpgradeHistory {
    /// Creates a new builder-style object to manufacture [`UpgradeHistory`](crate::model::UpgradeHistory)
    pub fn builder() -> crate::model::upgrade_history::Builder {
        crate::model::upgrade_history::Builder::default()
    }
}

/// <p>Represents a single step of the upgrade or upgrade eligibility check workflow.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpgradeStepItem {
    /// <p> One of three steps an upgrade or upgrade eligibility check goes through: </p>
    /// <ul>
    /// <li>PreUpgradeCheck</li>
    /// <li>Snapshot</li>
    /// <li>Upgrade</li>
    /// </ul>
    /// <p></p>
    pub upgrade_step: std::option::Option<crate::model::UpgradeStep>,
    /// <p> The current status of the upgrade. The status can take one of the following values: </p>
    /// <ul>
    /// <li>In Progress</li>
    /// <li>Succeeded</li>
    /// <li>Succeeded with Issues</li>
    /// <li>Failed</li>
    /// </ul>
    /// <p></p>
    pub upgrade_step_status: std::option::Option<crate::model::UpgradeStatus>,
    /// <p>A list of strings containing detailed information about the errors encountered in a particular step.</p>
    pub issues: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The floating point value representing the progress percentage of a particular step.</p>
    pub progress_percent: std::option::Option<f64>,
}
impl UpgradeStepItem {
    /// <p> One of three steps an upgrade or upgrade eligibility check goes through: </p>
    /// <ul>
    /// <li>PreUpgradeCheck</li>
    /// <li>Snapshot</li>
    /// <li>Upgrade</li>
    /// </ul>
    /// <p></p>
    pub fn upgrade_step(&self) -> std::option::Option<&crate::model::UpgradeStep> {
        self.upgrade_step.as_ref()
    }
    /// <p> The current status of the upgrade. The status can take one of the following values: </p>
    /// <ul>
    /// <li>In Progress</li>
    /// <li>Succeeded</li>
    /// <li>Succeeded with Issues</li>
    /// <li>Failed</li>
    /// </ul>
    /// <p></p>
    pub fn upgrade_step_status(&self) -> std::option::Option<&crate::model::UpgradeStatus> {
        self.upgrade_step_status.as_ref()
    }
    /// <p>A list of strings containing detailed information about the errors encountered in a particular step.</p>
    pub fn issues(&self) -> std::option::Option<&[std::string::String]> {
        self.issues.as_deref()
    }
    /// <p>The floating point value representing the progress percentage of a particular step.</p>
    pub fn progress_percent(&self) -> std::option::Option<f64> {
        self.progress_percent
    }
}
impl std::fmt::Debug for UpgradeStepItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpgradeStepItem");
        formatter.field("upgrade_step", &self.upgrade_step);
        formatter.field("upgrade_step_status", &self.upgrade_step_status);
        formatter.field("issues", &self.issues);
        formatter.field("progress_percent", &self.progress_percent);
        formatter.finish()
    }
}
/// See [`UpgradeStepItem`](crate::model::UpgradeStepItem)
pub mod upgrade_step_item {

    /// A builder for [`UpgradeStepItem`](crate::model::UpgradeStepItem)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) upgrade_step: std::option::Option<crate::model::UpgradeStep>,
        pub(crate) upgrade_step_status: std::option::Option<crate::model::UpgradeStatus>,
        pub(crate) issues: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) progress_percent: std::option::Option<f64>,
    }
    impl Builder {
        /// <p> One of three steps an upgrade or upgrade eligibility check goes through: </p>
        /// <ul>
        /// <li>PreUpgradeCheck</li>
        /// <li>Snapshot</li>
        /// <li>Upgrade</li>
        /// </ul>
        /// <p></p>
        pub fn upgrade_step(mut self, input: crate::model::UpgradeStep) -> Self {
            self.upgrade_step = Some(input);
            self
        }
        /// <p> One of three steps an upgrade or upgrade eligibility check goes through: </p>
        /// <ul>
        /// <li>PreUpgradeCheck</li>
        /// <li>Snapshot</li>
        /// <li>Upgrade</li>
        /// </ul>
        /// <p></p>
        pub fn set_upgrade_step(
            mut self,
            input: std::option::Option<crate::model::UpgradeStep>,
        ) -> Self {
            self.upgrade_step = input;
            self
        }
        /// <p> The current status of the upgrade. The status can take one of the following values: </p>
        /// <ul>
        /// <li>In Progress</li>
        /// <li>Succeeded</li>
        /// <li>Succeeded with Issues</li>
        /// <li>Failed</li>
        /// </ul>
        /// <p></p>
        pub fn upgrade_step_status(mut self, input: crate::model::UpgradeStatus) -> Self {
            self.upgrade_step_status = Some(input);
            self
        }
        /// <p> The current status of the upgrade. The status can take one of the following values: </p>
        /// <ul>
        /// <li>In Progress</li>
        /// <li>Succeeded</li>
        /// <li>Succeeded with Issues</li>
        /// <li>Failed</li>
        /// </ul>
        /// <p></p>
        pub fn set_upgrade_step_status(
            mut self,
            input: std::option::Option<crate::model::UpgradeStatus>,
        ) -> Self {
            self.upgrade_step_status = input;
            self
        }
        /// Appends an item to `issues`.
        ///
        /// To override the contents of this collection use [`set_issues`](Self::set_issues).
        ///
        /// <p>A list of strings containing detailed information about the errors encountered in a particular step.</p>
        pub fn issues(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.issues.unwrap_or_default();
            v.push(input.into());
            self.issues = Some(v);
            self
        }
        /// <p>A list of strings containing detailed information about the errors encountered in a particular step.</p>
        pub fn set_issues(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.issues = input;
            self
        }
        /// <p>The floating point value representing the progress percentage of a particular step.</p>
        pub fn progress_percent(mut self, input: f64) -> Self {
            self.progress_percent = Some(input);
            self
        }
        /// <p>The floating point value representing the progress percentage of a particular step.</p>
        pub fn set_progress_percent(mut self, input: std::option::Option<f64>) -> Self {
            self.progress_percent = input;
            self
        }
        /// Consumes the builder and constructs a [`UpgradeStepItem`](crate::model::UpgradeStepItem)
        pub fn build(self) -> crate::model::UpgradeStepItem {
            crate::model::UpgradeStepItem {
                upgrade_step: self.upgrade_step,
                upgrade_step_status: self.upgrade_step_status,
                issues: self.issues,
                progress_percent: self.progress_percent,
            }
        }
    }
}
impl UpgradeStepItem {
    /// Creates a new builder-style object to manufacture [`UpgradeStepItem`](crate::model::UpgradeStepItem)
    pub fn builder() -> crate::model::upgrade_step_item::Builder {
        crate::model::upgrade_step_item::Builder::default()
    }
}

/// <p>Details of a package version.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PackageVersionHistory {
    /// <p>The package version.</p>
    pub package_version: std::option::Option<std::string::String>,
    /// <p>A message associated with the package version.</p>
    pub commit_message: std::option::Option<std::string::String>,
    /// <p>The timestamp of when the package was created.</p>
    pub created_at: std::option::Option<aws_smithy_types::DateTime>,
}
impl PackageVersionHistory {
    /// <p>The package version.</p>
    pub fn package_version(&self) -> std::option::Option<&str> {
        self.package_version.as_deref()
    }
    /// <p>A message associated with the package version.</p>
    pub fn commit_message(&self) -> std::option::Option<&str> {
        self.commit_message.as_deref()
    }
    /// <p>The timestamp of when the package was created.</p>
    pub fn created_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_at.as_ref()
    }
}
impl std::fmt::Debug for PackageVersionHistory {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PackageVersionHistory");
        formatter.field("package_version", &self.package_version);
        formatter.field("commit_message", &self.commit_message);
        formatter.field("created_at", &self.created_at);
        formatter.finish()
    }
}
/// See [`PackageVersionHistory`](crate::model::PackageVersionHistory)
pub mod package_version_history {

    /// A builder for [`PackageVersionHistory`](crate::model::PackageVersionHistory)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) package_version: std::option::Option<std::string::String>,
        pub(crate) commit_message: std::option::Option<std::string::String>,
        pub(crate) created_at: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The package version.</p>
        pub fn package_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.package_version = Some(input.into());
            self
        }
        /// <p>The package version.</p>
        pub fn set_package_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.package_version = input;
            self
        }
        /// <p>A message associated with the package version.</p>
        pub fn commit_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.commit_message = Some(input.into());
            self
        }
        /// <p>A message associated with the package version.</p>
        pub fn set_commit_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.commit_message = input;
            self
        }
        /// <p>The timestamp of when the package was created.</p>
        pub fn created_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_at = Some(input);
            self
        }
        /// <p>The timestamp of when the package was created.</p>
        pub fn set_created_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_at = input;
            self
        }
        /// Consumes the builder and constructs a [`PackageVersionHistory`](crate::model::PackageVersionHistory)
        pub fn build(self) -> crate::model::PackageVersionHistory {
            crate::model::PackageVersionHistory {
                package_version: self.package_version,
                commit_message: self.commit_message,
                created_at: self.created_at,
            }
        }
    }
}
impl PackageVersionHistory {
    /// Creates a new builder-style object to manufacture [`PackageVersionHistory`](crate::model::PackageVersionHistory)
    pub fn builder() -> crate::model::package_version_history::Builder {
        crate::model::package_version_history::Builder::default()
    }
}

/// <p> A map from an <code> <code>EngineVersion</code> </code> to a list of compatible <code> <code>EngineVersion</code> </code> s to which the domain can be upgraded. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CompatibleVersionsMap {
    /// <p>The current version of OpenSearch a domain is on.</p>
    pub source_version: std::option::Option<std::string::String>,
    /// <p>List of supported OpenSearch versions. </p>
    pub target_versions: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl CompatibleVersionsMap {
    /// <p>The current version of OpenSearch a domain is on.</p>
    pub fn source_version(&self) -> std::option::Option<&str> {
        self.source_version.as_deref()
    }
    /// <p>List of supported OpenSearch versions. </p>
    pub fn target_versions(&self) -> std::option::Option<&[std::string::String]> {
        self.target_versions.as_deref()
    }
}
impl std::fmt::Debug for CompatibleVersionsMap {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CompatibleVersionsMap");
        formatter.field("source_version", &self.source_version);
        formatter.field("target_versions", &self.target_versions);
        formatter.finish()
    }
}
/// See [`CompatibleVersionsMap`](crate::model::CompatibleVersionsMap)
pub mod compatible_versions_map {

    /// A builder for [`CompatibleVersionsMap`](crate::model::CompatibleVersionsMap)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) source_version: std::option::Option<std::string::String>,
        pub(crate) target_versions: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The current version of OpenSearch a domain is on.</p>
        pub fn source_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_version = Some(input.into());
            self
        }
        /// <p>The current version of OpenSearch a domain is on.</p>
        pub fn set_source_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.source_version = input;
            self
        }
        /// Appends an item to `target_versions`.
        ///
        /// To override the contents of this collection use [`set_target_versions`](Self::set_target_versions).
        ///
        /// <p>List of supported OpenSearch versions. </p>
        pub fn target_versions(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.target_versions.unwrap_or_default();
            v.push(input.into());
            self.target_versions = Some(v);
            self
        }
        /// <p>List of supported OpenSearch versions. </p>
        pub fn set_target_versions(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.target_versions = input;
            self
        }
        /// Consumes the builder and constructs a [`CompatibleVersionsMap`](crate::model::CompatibleVersionsMap)
        pub fn build(self) -> crate::model::CompatibleVersionsMap {
            crate::model::CompatibleVersionsMap {
                source_version: self.source_version,
                target_versions: self.target_versions,
            }
        }
    }
}
impl CompatibleVersionsMap {
    /// Creates a new builder-style object to manufacture [`CompatibleVersionsMap`](crate::model::CompatibleVersionsMap)
    pub fn builder() -> crate::model::compatible_versions_map::Builder {
        crate::model::compatible_versions_map::Builder::default()
    }
}

/// <p>Details of a reserved OpenSearch instance.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ReservedInstance {
    /// <p>The customer-specified identifier to track this reservation.</p>
    pub reservation_name: std::option::Option<std::string::String>,
    /// <p>The unique identifier for the reservation.</p>
    pub reserved_instance_id: std::option::Option<std::string::String>,
    #[allow(missing_docs)] // documentation missing in model
    pub billing_subscription_id: std::option::Option<i64>,
    /// <p>The offering identifier.</p>
    pub reserved_instance_offering_id: std::option::Option<std::string::String>,
    /// <p>The OpenSearch instance type offered by the reserved instance offering.</p>
    pub instance_type: std::option::Option<crate::model::OpenSearchPartitionInstanceType>,
    /// <p>The time the reservation started.</p>
    pub start_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The duration, in seconds, for which the OpenSearch instance is reserved.</p>
    pub duration: i32,
    /// <p>The upfront fixed charge you will paid to purchase the specific reserved OpenSearch instance offering.</p>
    pub fixed_price: std::option::Option<f64>,
    /// <p>The rate you are charged for each hour for the domain that is using this reserved instance.</p>
    pub usage_price: std::option::Option<f64>,
    /// <p>The currency code for the reserved OpenSearch instance offering.</p>
    pub currency_code: std::option::Option<std::string::String>,
    /// <p>The number of OpenSearch instances that have been reserved.</p>
    pub instance_count: i32,
    /// <p>The state of the reserved OpenSearch instance.</p>
    pub state: std::option::Option<std::string::String>,
    /// <p>The payment option as defined in the reserved OpenSearch instance offering.</p>
    pub payment_option: std::option::Option<crate::model::ReservedInstancePaymentOption>,
    /// <p>The charge to your account regardless of whether you are creating any domains using the instance offering.</p>
    pub recurring_charges: std::option::Option<std::vec::Vec<crate::model::RecurringCharge>>,
}
impl ReservedInstance {
    /// <p>The customer-specified identifier to track this reservation.</p>
    pub fn reservation_name(&self) -> std::option::Option<&str> {
        self.reservation_name.as_deref()
    }
    /// <p>The unique identifier for the reservation.</p>
    pub fn reserved_instance_id(&self) -> std::option::Option<&str> {
        self.reserved_instance_id.as_deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn billing_subscription_id(&self) -> std::option::Option<i64> {
        self.billing_subscription_id
    }
    /// <p>The offering identifier.</p>
    pub fn reserved_instance_offering_id(&self) -> std::option::Option<&str> {
        self.reserved_instance_offering_id.as_deref()
    }
    /// <p>The OpenSearch instance type offered by the reserved instance offering.</p>
    pub fn instance_type(
        &self,
    ) -> std::option::Option<&crate::model::OpenSearchPartitionInstanceType> {
        self.instance_type.as_ref()
    }
    /// <p>The time the reservation started.</p>
    pub fn start_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.start_time.as_ref()
    }
    /// <p>The duration, in seconds, for which the OpenSearch instance is reserved.</p>
    pub fn duration(&self) -> i32 {
        self.duration
    }
    /// <p>The upfront fixed charge you will paid to purchase the specific reserved OpenSearch instance offering.</p>
    pub fn fixed_price(&self) -> std::option::Option<f64> {
        self.fixed_price
    }
    /// <p>The rate you are charged for each hour for the domain that is using this reserved instance.</p>
    pub fn usage_price(&self) -> std::option::Option<f64> {
        self.usage_price
    }
    /// <p>The currency code for the reserved OpenSearch instance offering.</p>
    pub fn currency_code(&self) -> std::option::Option<&str> {
        self.currency_code.as_deref()
    }
    /// <p>The number of OpenSearch instances that have been reserved.</p>
    pub fn instance_count(&self) -> i32 {
        self.instance_count
    }
    /// <p>The state of the reserved OpenSearch instance.</p>
    pub fn state(&self) -> std::option::Option<&str> {
        self.state.as_deref()
    }
    /// <p>The payment option as defined in the reserved OpenSearch instance offering.</p>
    pub fn payment_option(
        &self,
    ) -> std::option::Option<&crate::model::ReservedInstancePaymentOption> {
        self.payment_option.as_ref()
    }
    /// <p>The charge to your account regardless of whether you are creating any domains using the instance offering.</p>
    pub fn recurring_charges(&self) -> std::option::Option<&[crate::model::RecurringCharge]> {
        self.recurring_charges.as_deref()
    }
}
impl std::fmt::Debug for ReservedInstance {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ReservedInstance");
        formatter.field("reservation_name", &self.reservation_name);
        formatter.field("reserved_instance_id", &self.reserved_instance_id);
        formatter.field("billing_subscription_id", &self.billing_subscription_id);
        formatter.field(
            "reserved_instance_offering_id",
            &self.reserved_instance_offering_id,
        );
        formatter.field("instance_type", &self.instance_type);
        formatter.field("start_time", &self.start_time);
        formatter.field("duration", &self.duration);
        formatter.field("fixed_price", &self.fixed_price);
        formatter.field("usage_price", &self.usage_price);
        formatter.field("currency_code", &self.currency_code);
        formatter.field("instance_count", &self.instance_count);
        formatter.field("state", &self.state);
        formatter.field("payment_option", &self.payment_option);
        formatter.field("recurring_charges", &self.recurring_charges);
        formatter.finish()
    }
}
/// See [`ReservedInstance`](crate::model::ReservedInstance)
pub mod reserved_instance {

    /// A builder for [`ReservedInstance`](crate::model::ReservedInstance)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) reservation_name: std::option::Option<std::string::String>,
        pub(crate) reserved_instance_id: std::option::Option<std::string::String>,
        pub(crate) billing_subscription_id: std::option::Option<i64>,
        pub(crate) reserved_instance_offering_id: std::option::Option<std::string::String>,
        pub(crate) instance_type:
            std::option::Option<crate::model::OpenSearchPartitionInstanceType>,
        pub(crate) start_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) duration: std::option::Option<i32>,
        pub(crate) fixed_price: std::option::Option<f64>,
        pub(crate) usage_price: std::option::Option<f64>,
        pub(crate) currency_code: std::option::Option<std::string::String>,
        pub(crate) instance_count: std::option::Option<i32>,
        pub(crate) state: std::option::Option<std::string::String>,
        pub(crate) payment_option: std::option::Option<crate::model::ReservedInstancePaymentOption>,
        pub(crate) recurring_charges:
            std::option::Option<std::vec::Vec<crate::model::RecurringCharge>>,
    }
    impl Builder {
        /// <p>The customer-specified identifier to track this reservation.</p>
        pub fn reservation_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.reservation_name = Some(input.into());
            self
        }
        /// <p>The customer-specified identifier to track this reservation.</p>
        pub fn set_reservation_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.reservation_name = input;
            self
        }
        /// <p>The unique identifier for the reservation.</p>
        pub fn reserved_instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.reserved_instance_id = Some(input.into());
            self
        }
        /// <p>The unique identifier for the reservation.</p>
        pub fn set_reserved_instance_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.reserved_instance_id = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn billing_subscription_id(mut self, input: i64) -> Self {
            self.billing_subscription_id = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_billing_subscription_id(mut self, input: std::option::Option<i64>) -> Self {
            self.billing_subscription_id = input;
            self
        }
        /// <p>The offering identifier.</p>
        pub fn reserved_instance_offering_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.reserved_instance_offering_id = Some(input.into());
            self
        }
        /// <p>The offering identifier.</p>
        pub fn set_reserved_instance_offering_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.reserved_instance_offering_id = input;
            self
        }
        /// <p>The OpenSearch instance type offered by the reserved instance offering.</p>
        pub fn instance_type(
            mut self,
            input: crate::model::OpenSearchPartitionInstanceType,
        ) -> Self {
            self.instance_type = Some(input);
            self
        }
        /// <p>The OpenSearch instance type offered by the reserved instance offering.</p>
        pub fn set_instance_type(
            mut self,
            input: std::option::Option<crate::model::OpenSearchPartitionInstanceType>,
        ) -> Self {
            self.instance_type = input;
            self
        }
        /// <p>The time the reservation started.</p>
        pub fn start_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.start_time = Some(input);
            self
        }
        /// <p>The time the reservation started.</p>
        pub fn set_start_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.start_time = input;
            self
        }
        /// <p>The duration, in seconds, for which the OpenSearch instance is reserved.</p>
        pub fn duration(mut self, input: i32) -> Self {
            self.duration = Some(input);
            self
        }
        /// <p>The duration, in seconds, for which the OpenSearch instance is reserved.</p>
        pub fn set_duration(mut self, input: std::option::Option<i32>) -> Self {
            self.duration = input;
            self
        }
        /// <p>The upfront fixed charge you will paid to purchase the specific reserved OpenSearch instance offering.</p>
        pub fn fixed_price(mut self, input: f64) -> Self {
            self.fixed_price = Some(input);
            self
        }
        /// <p>The upfront fixed charge you will paid to purchase the specific reserved OpenSearch instance offering.</p>
        pub fn set_fixed_price(mut self, input: std::option::Option<f64>) -> Self {
            self.fixed_price = input;
            self
        }
        /// <p>The rate you are charged for each hour for the domain that is using this reserved instance.</p>
        pub fn usage_price(mut self, input: f64) -> Self {
            self.usage_price = Some(input);
            self
        }
        /// <p>The rate you are charged for each hour for the domain that is using this reserved instance.</p>
        pub fn set_usage_price(mut self, input: std::option::Option<f64>) -> Self {
            self.usage_price = input;
            self
        }
        /// <p>The currency code for the reserved OpenSearch instance offering.</p>
        pub fn currency_code(mut self, input: impl Into<std::string::String>) -> Self {
            self.currency_code = Some(input.into());
            self
        }
        /// <p>The currency code for the reserved OpenSearch instance offering.</p>
        pub fn set_currency_code(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.currency_code = input;
            self
        }
        /// <p>The number of OpenSearch instances that have been reserved.</p>
        pub fn instance_count(mut self, input: i32) -> Self {
            self.instance_count = Some(input);
            self
        }
        /// <p>The number of OpenSearch instances that have been reserved.</p>
        pub fn set_instance_count(mut self, input: std::option::Option<i32>) -> Self {
            self.instance_count = input;
            self
        }
        /// <p>The state of the reserved OpenSearch instance.</p>
        pub fn state(mut self, input: impl Into<std::string::String>) -> Self {
            self.state = Some(input.into());
            self
        }
        /// <p>The state of the reserved OpenSearch instance.</p>
        pub fn set_state(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.state = input;
            self
        }
        /// <p>The payment option as defined in the reserved OpenSearch instance offering.</p>
        pub fn payment_option(
            mut self,
            input: crate::model::ReservedInstancePaymentOption,
        ) -> Self {
            self.payment_option = Some(input);
            self
        }
        /// <p>The payment option as defined in the reserved OpenSearch instance offering.</p>
        pub fn set_payment_option(
            mut self,
            input: std::option::Option<crate::model::ReservedInstancePaymentOption>,
        ) -> Self {
            self.payment_option = input;
            self
        }
        /// Appends an item to `recurring_charges`.
        ///
        /// To override the contents of this collection use [`set_recurring_charges`](Self::set_recurring_charges).
        ///
        /// <p>The charge to your account regardless of whether you are creating any domains using the instance offering.</p>
        pub fn recurring_charges(mut self, input: crate::model::RecurringCharge) -> Self {
            let mut v = self.recurring_charges.unwrap_or_default();
            v.push(input);
            self.recurring_charges = Some(v);
            self
        }
        /// <p>The charge to your account regardless of whether you are creating any domains using the instance offering.</p>
        pub fn set_recurring_charges(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::RecurringCharge>>,
        ) -> Self {
            self.recurring_charges = input;
            self
        }
        /// Consumes the builder and constructs a [`ReservedInstance`](crate::model::ReservedInstance)
        pub fn build(self) -> crate::model::ReservedInstance {
            crate::model::ReservedInstance {
                reservation_name: self.reservation_name,
                reserved_instance_id: self.reserved_instance_id,
                billing_subscription_id: self.billing_subscription_id,
                reserved_instance_offering_id: self.reserved_instance_offering_id,
                instance_type: self.instance_type,
                start_time: self.start_time,
                duration: self.duration.unwrap_or_default(),
                fixed_price: self.fixed_price,
                usage_price: self.usage_price,
                currency_code: self.currency_code,
                instance_count: self.instance_count.unwrap_or_default(),
                state: self.state,
                payment_option: self.payment_option,
                recurring_charges: self.recurring_charges,
            }
        }
    }
}
impl ReservedInstance {
    /// Creates a new builder-style object to manufacture [`ReservedInstance`](crate::model::ReservedInstance)
    pub fn builder() -> crate::model::reserved_instance::Builder {
        crate::model::reserved_instance::Builder::default()
    }
}

/// <p>Contains the specific price and frequency of a recurring charges for a reserved OpenSearch instance, or for a reserved OpenSearch instance offering. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RecurringCharge {
    /// <p>The monetary amount of the recurring charge.</p>
    pub recurring_charge_amount: std::option::Option<f64>,
    /// <p>The frequency of the recurring charge.</p>
    pub recurring_charge_frequency: std::option::Option<std::string::String>,
}
impl RecurringCharge {
    /// <p>The monetary amount of the recurring charge.</p>
    pub fn recurring_charge_amount(&self) -> std::option::Option<f64> {
        self.recurring_charge_amount
    }
    /// <p>The frequency of the recurring charge.</p>
    pub fn recurring_charge_frequency(&self) -> std::option::Option<&str> {
        self.recurring_charge_frequency.as_deref()
    }
}
impl std::fmt::Debug for RecurringCharge {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RecurringCharge");
        formatter.field("recurring_charge_amount", &self.recurring_charge_amount);
        formatter.field(
            "recurring_charge_frequency",
            &self.recurring_charge_frequency,
        );
        formatter.finish()
    }
}
/// See [`RecurringCharge`](crate::model::RecurringCharge)
pub mod recurring_charge {

    /// A builder for [`RecurringCharge`](crate::model::RecurringCharge)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) recurring_charge_amount: std::option::Option<f64>,
        pub(crate) recurring_charge_frequency: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The monetary amount of the recurring charge.</p>
        pub fn recurring_charge_amount(mut self, input: f64) -> Self {
            self.recurring_charge_amount = Some(input);
            self
        }
        /// <p>The monetary amount of the recurring charge.</p>
        pub fn set_recurring_charge_amount(mut self, input: std::option::Option<f64>) -> Self {
            self.recurring_charge_amount = input;
            self
        }
        /// <p>The frequency of the recurring charge.</p>
        pub fn recurring_charge_frequency(mut self, input: impl Into<std::string::String>) -> Self {
            self.recurring_charge_frequency = Some(input.into());
            self
        }
        /// <p>The frequency of the recurring charge.</p>
        pub fn set_recurring_charge_frequency(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.recurring_charge_frequency = input;
            self
        }
        /// Consumes the builder and constructs a [`RecurringCharge`](crate::model::RecurringCharge)
        pub fn build(self) -> crate::model::RecurringCharge {
            crate::model::RecurringCharge {
                recurring_charge_amount: self.recurring_charge_amount,
                recurring_charge_frequency: self.recurring_charge_frequency,
            }
        }
    }
}
impl RecurringCharge {
    /// Creates a new builder-style object to manufacture [`RecurringCharge`](crate::model::RecurringCharge)
    pub fn builder() -> crate::model::recurring_charge::Builder {
        crate::model::recurring_charge::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ReservedInstancePaymentOption {
    #[allow(missing_docs)] // documentation missing in model
    AllUpfront,
    #[allow(missing_docs)] // documentation missing in model
    NoUpfront,
    #[allow(missing_docs)] // documentation missing in model
    PartialUpfront,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ReservedInstancePaymentOption {
    fn from(s: &str) -> Self {
        match s {
            "ALL_UPFRONT" => ReservedInstancePaymentOption::AllUpfront,
            "NO_UPFRONT" => ReservedInstancePaymentOption::NoUpfront,
            "PARTIAL_UPFRONT" => ReservedInstancePaymentOption::PartialUpfront,
            other => ReservedInstancePaymentOption::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ReservedInstancePaymentOption {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ReservedInstancePaymentOption::from(s))
    }
}
impl ReservedInstancePaymentOption {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ReservedInstancePaymentOption::AllUpfront => "ALL_UPFRONT",
            ReservedInstancePaymentOption::NoUpfront => "NO_UPFRONT",
            ReservedInstancePaymentOption::PartialUpfront => "PARTIAL_UPFRONT",
            ReservedInstancePaymentOption::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["ALL_UPFRONT", "NO_UPFRONT", "PARTIAL_UPFRONT"]
    }
}
impl AsRef<str> for ReservedInstancePaymentOption {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Details of a reserved OpenSearch instance offering.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ReservedInstanceOffering {
    /// <p>The OpenSearch reserved instance offering identifier.</p>
    pub reserved_instance_offering_id: std::option::Option<std::string::String>,
    /// <p>The OpenSearch instance type offered by the reserved instance offering.</p>
    pub instance_type: std::option::Option<crate::model::OpenSearchPartitionInstanceType>,
    /// <p>The duration, in seconds, for which the offering will reserve the OpenSearch instance.</p>
    pub duration: i32,
    /// <p>The upfront fixed charge you will pay to purchase the specific reserved OpenSearch instance offering.</p>
    pub fixed_price: std::option::Option<f64>,
    /// <p>The rate you are charged for each hour the domain that is using the offering is running.</p>
    pub usage_price: std::option::Option<f64>,
    /// <p>The currency code for the reserved OpenSearch instance offering.</p>
    pub currency_code: std::option::Option<std::string::String>,
    /// <p>Payment option for the reserved OpenSearch instance offering</p>
    pub payment_option: std::option::Option<crate::model::ReservedInstancePaymentOption>,
    /// <p>The charge to your account regardless of whether you are creating any domains using the instance offering.</p>
    pub recurring_charges: std::option::Option<std::vec::Vec<crate::model::RecurringCharge>>,
}
impl ReservedInstanceOffering {
    /// <p>The OpenSearch reserved instance offering identifier.</p>
    pub fn reserved_instance_offering_id(&self) -> std::option::Option<&str> {
        self.reserved_instance_offering_id.as_deref()
    }
    /// <p>The OpenSearch instance type offered by the reserved instance offering.</p>
    pub fn instance_type(
        &self,
    ) -> std::option::Option<&crate::model::OpenSearchPartitionInstanceType> {
        self.instance_type.as_ref()
    }
    /// <p>The duration, in seconds, for which the offering will reserve the OpenSearch instance.</p>
    pub fn duration(&self) -> i32 {
        self.duration
    }
    /// <p>The upfront fixed charge you will pay to purchase the specific reserved OpenSearch instance offering.</p>
    pub fn fixed_price(&self) -> std::option::Option<f64> {
        self.fixed_price
    }
    /// <p>The rate you are charged for each hour the domain that is using the offering is running.</p>
    pub fn usage_price(&self) -> std::option::Option<f64> {
        self.usage_price
    }
    /// <p>The currency code for the reserved OpenSearch instance offering.</p>
    pub fn currency_code(&self) -> std::option::Option<&str> {
        self.currency_code.as_deref()
    }
    /// <p>Payment option for the reserved OpenSearch instance offering</p>
    pub fn payment_option(
        &self,
    ) -> std::option::Option<&crate::model::ReservedInstancePaymentOption> {
        self.payment_option.as_ref()
    }
    /// <p>The charge to your account regardless of whether you are creating any domains using the instance offering.</p>
    pub fn recurring_charges(&self) -> std::option::Option<&[crate::model::RecurringCharge]> {
        self.recurring_charges.as_deref()
    }
}
impl std::fmt::Debug for ReservedInstanceOffering {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ReservedInstanceOffering");
        formatter.field(
            "reserved_instance_offering_id",
            &self.reserved_instance_offering_id,
        );
        formatter.field("instance_type", &self.instance_type);
        formatter.field("duration", &self.duration);
        formatter.field("fixed_price", &self.fixed_price);
        formatter.field("usage_price", &self.usage_price);
        formatter.field("currency_code", &self.currency_code);
        formatter.field("payment_option", &self.payment_option);
        formatter.field("recurring_charges", &self.recurring_charges);
        formatter.finish()
    }
}
/// See [`ReservedInstanceOffering`](crate::model::ReservedInstanceOffering)
pub mod reserved_instance_offering {

    /// A builder for [`ReservedInstanceOffering`](crate::model::ReservedInstanceOffering)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) reserved_instance_offering_id: std::option::Option<std::string::String>,
        pub(crate) instance_type:
            std::option::Option<crate::model::OpenSearchPartitionInstanceType>,
        pub(crate) duration: std::option::Option<i32>,
        pub(crate) fixed_price: std::option::Option<f64>,
        pub(crate) usage_price: std::option::Option<f64>,
        pub(crate) currency_code: std::option::Option<std::string::String>,
        pub(crate) payment_option: std::option::Option<crate::model::ReservedInstancePaymentOption>,
        pub(crate) recurring_charges:
            std::option::Option<std::vec::Vec<crate::model::RecurringCharge>>,
    }
    impl Builder {
        /// <p>The OpenSearch reserved instance offering identifier.</p>
        pub fn reserved_instance_offering_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.reserved_instance_offering_id = Some(input.into());
            self
        }
        /// <p>The OpenSearch reserved instance offering identifier.</p>
        pub fn set_reserved_instance_offering_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.reserved_instance_offering_id = input;
            self
        }
        /// <p>The OpenSearch instance type offered by the reserved instance offering.</p>
        pub fn instance_type(
            mut self,
            input: crate::model::OpenSearchPartitionInstanceType,
        ) -> Self {
            self.instance_type = Some(input);
            self
        }
        /// <p>The OpenSearch instance type offered by the reserved instance offering.</p>
        pub fn set_instance_type(
            mut self,
            input: std::option::Option<crate::model::OpenSearchPartitionInstanceType>,
        ) -> Self {
            self.instance_type = input;
            self
        }
        /// <p>The duration, in seconds, for which the offering will reserve the OpenSearch instance.</p>
        pub fn duration(mut self, input: i32) -> Self {
            self.duration = Some(input);
            self
        }
        /// <p>The duration, in seconds, for which the offering will reserve the OpenSearch instance.</p>
        pub fn set_duration(mut self, input: std::option::Option<i32>) -> Self {
            self.duration = input;
            self
        }
        /// <p>The upfront fixed charge you will pay to purchase the specific reserved OpenSearch instance offering.</p>
        pub fn fixed_price(mut self, input: f64) -> Self {
            self.fixed_price = Some(input);
            self
        }
        /// <p>The upfront fixed charge you will pay to purchase the specific reserved OpenSearch instance offering.</p>
        pub fn set_fixed_price(mut self, input: std::option::Option<f64>) -> Self {
            self.fixed_price = input;
            self
        }
        /// <p>The rate you are charged for each hour the domain that is using the offering is running.</p>
        pub fn usage_price(mut self, input: f64) -> Self {
            self.usage_price = Some(input);
            self
        }
        /// <p>The rate you are charged for each hour the domain that is using the offering is running.</p>
        pub fn set_usage_price(mut self, input: std::option::Option<f64>) -> Self {
            self.usage_price = input;
            self
        }
        /// <p>The currency code for the reserved OpenSearch instance offering.</p>
        pub fn currency_code(mut self, input: impl Into<std::string::String>) -> Self {
            self.currency_code = Some(input.into());
            self
        }
        /// <p>The currency code for the reserved OpenSearch instance offering.</p>
        pub fn set_currency_code(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.currency_code = input;
            self
        }
        /// <p>Payment option for the reserved OpenSearch instance offering</p>
        pub fn payment_option(
            mut self,
            input: crate::model::ReservedInstancePaymentOption,
        ) -> Self {
            self.payment_option = Some(input);
            self
        }
        /// <p>Payment option for the reserved OpenSearch instance offering</p>
        pub fn set_payment_option(
            mut self,
            input: std::option::Option<crate::model::ReservedInstancePaymentOption>,
        ) -> Self {
            self.payment_option = input;
            self
        }
        /// Appends an item to `recurring_charges`.
        ///
        /// To override the contents of this collection use [`set_recurring_charges`](Self::set_recurring_charges).
        ///
        /// <p>The charge to your account regardless of whether you are creating any domains using the instance offering.</p>
        pub fn recurring_charges(mut self, input: crate::model::RecurringCharge) -> Self {
            let mut v = self.recurring_charges.unwrap_or_default();
            v.push(input);
            self.recurring_charges = Some(v);
            self
        }
        /// <p>The charge to your account regardless of whether you are creating any domains using the instance offering.</p>
        pub fn set_recurring_charges(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::RecurringCharge>>,
        ) -> Self {
            self.recurring_charges = input;
            self
        }
        /// Consumes the builder and constructs a [`ReservedInstanceOffering`](crate::model::ReservedInstanceOffering)
        pub fn build(self) -> crate::model::ReservedInstanceOffering {
            crate::model::ReservedInstanceOffering {
                reserved_instance_offering_id: self.reserved_instance_offering_id,
                instance_type: self.instance_type,
                duration: self.duration.unwrap_or_default(),
                fixed_price: self.fixed_price,
                usage_price: self.usage_price,
                currency_code: self.currency_code,
                payment_option: self.payment_option,
                recurring_charges: self.recurring_charges,
            }
        }
    }
}
impl ReservedInstanceOffering {
    /// Creates a new builder-style object to manufacture [`ReservedInstanceOffering`](crate::model::ReservedInstanceOffering)
    pub fn builder() -> crate::model::reserved_instance_offering::Builder {
        crate::model::reserved_instance_offering::Builder::default()
    }
}

/// <p>A filter to apply to the <code>DescribePackage</code> response. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribePackagesFilter {
    /// <p>Any field from <code>PackageDetails</code>. </p>
    pub name: std::option::Option<crate::model::DescribePackagesFilterName>,
    /// <p>A list of values for the specified field.</p>
    pub value: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl DescribePackagesFilter {
    /// <p>Any field from <code>PackageDetails</code>. </p>
    pub fn name(&self) -> std::option::Option<&crate::model::DescribePackagesFilterName> {
        self.name.as_ref()
    }
    /// <p>A list of values for the specified field.</p>
    pub fn value(&self) -> std::option::Option<&[std::string::String]> {
        self.value.as_deref()
    }
}
impl std::fmt::Debug for DescribePackagesFilter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribePackagesFilter");
        formatter.field("name", &self.name);
        formatter.field("value", &self.value);
        formatter.finish()
    }
}
/// See [`DescribePackagesFilter`](crate::model::DescribePackagesFilter)
pub mod describe_packages_filter {

    /// A builder for [`DescribePackagesFilter`](crate::model::DescribePackagesFilter)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<crate::model::DescribePackagesFilterName>,
        pub(crate) value: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>Any field from <code>PackageDetails</code>. </p>
        pub fn name(mut self, input: crate::model::DescribePackagesFilterName) -> Self {
            self.name = Some(input);
            self
        }
        /// <p>Any field from <code>PackageDetails</code>. </p>
        pub fn set_name(
            mut self,
            input: std::option::Option<crate::model::DescribePackagesFilterName>,
        ) -> Self {
            self.name = input;
            self
        }
        /// Appends an item to `value`.
        ///
        /// To override the contents of this collection use [`set_value`](Self::set_value).
        ///
        /// <p>A list of values for the specified field.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.value.unwrap_or_default();
            v.push(input.into());
            self.value = Some(v);
            self
        }
        /// <p>A list of values for the specified field.</p>
        pub fn set_value(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribePackagesFilter`](crate::model::DescribePackagesFilter)
        pub fn build(self) -> crate::model::DescribePackagesFilter {
            crate::model::DescribePackagesFilter {
                name: self.name,
                value: self.value,
            }
        }
    }
}
impl DescribePackagesFilter {
    /// Creates a new builder-style object to manufacture [`DescribePackagesFilter`](crate::model::DescribePackagesFilter)
    pub fn builder() -> crate::model::describe_packages_filter::Builder {
        crate::model::describe_packages_filter::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DescribePackagesFilterName {
    #[allow(missing_docs)] // documentation missing in model
    PackageId,
    #[allow(missing_docs)] // documentation missing in model
    PackageName,
    #[allow(missing_docs)] // documentation missing in model
    PackageStatus,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for DescribePackagesFilterName {
    fn from(s: &str) -> Self {
        match s {
            "PackageID" => DescribePackagesFilterName::PackageId,
            "PackageName" => DescribePackagesFilterName::PackageName,
            "PackageStatus" => DescribePackagesFilterName::PackageStatus,
            other => DescribePackagesFilterName::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for DescribePackagesFilterName {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DescribePackagesFilterName::from(s))
    }
}
impl DescribePackagesFilterName {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            DescribePackagesFilterName::PackageId => "PackageID",
            DescribePackagesFilterName::PackageName => "PackageName",
            DescribePackagesFilterName::PackageStatus => "PackageStatus",
            DescribePackagesFilterName::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["PackageID", "PackageName", "PackageStatus"]
    }
}
impl AsRef<str> for DescribePackagesFilterName {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Specifies details about an outbound connection.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct OutboundConnection {
    /// <p>The <code> <code>DomainInformation</code> </code> for the local OpenSearch domain. </p>
    pub local_domain_info: std::option::Option<crate::model::DomainInformationContainer>,
    /// <p>The <code> <code>DomainInformation</code> </code> for the remote OpenSearch domain. </p>
    pub remote_domain_info: std::option::Option<crate::model::DomainInformationContainer>,
    /// <p>The connection ID for the outbound cross-cluster connection.</p>
    pub connection_id: std::option::Option<std::string::String>,
    /// <p>The connection alias for the outbound cross-cluster connection.</p>
    pub connection_alias: std::option::Option<std::string::String>,
    /// <p>The <code> <code>OutboundConnectionStatus</code> </code> for the outbound connection. </p>
    pub connection_status: std::option::Option<crate::model::OutboundConnectionStatus>,
}
impl OutboundConnection {
    /// <p>The <code> <code>DomainInformation</code> </code> for the local OpenSearch domain. </p>
    pub fn local_domain_info(
        &self,
    ) -> std::option::Option<&crate::model::DomainInformationContainer> {
        self.local_domain_info.as_ref()
    }
    /// <p>The <code> <code>DomainInformation</code> </code> for the remote OpenSearch domain. </p>
    pub fn remote_domain_info(
        &self,
    ) -> std::option::Option<&crate::model::DomainInformationContainer> {
        self.remote_domain_info.as_ref()
    }
    /// <p>The connection ID for the outbound cross-cluster connection.</p>
    pub fn connection_id(&self) -> std::option::Option<&str> {
        self.connection_id.as_deref()
    }
    /// <p>The connection alias for the outbound cross-cluster connection.</p>
    pub fn connection_alias(&self) -> std::option::Option<&str> {
        self.connection_alias.as_deref()
    }
    /// <p>The <code> <code>OutboundConnectionStatus</code> </code> for the outbound connection. </p>
    pub fn connection_status(
        &self,
    ) -> std::option::Option<&crate::model::OutboundConnectionStatus> {
        self.connection_status.as_ref()
    }
}
impl std::fmt::Debug for OutboundConnection {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("OutboundConnection");
        formatter.field("local_domain_info", &self.local_domain_info);
        formatter.field("remote_domain_info", &self.remote_domain_info);
        formatter.field("connection_id", &self.connection_id);
        formatter.field("connection_alias", &self.connection_alias);
        formatter.field("connection_status", &self.connection_status);
        formatter.finish()
    }
}
/// See [`OutboundConnection`](crate::model::OutboundConnection)
pub mod outbound_connection {

    /// A builder for [`OutboundConnection`](crate::model::OutboundConnection)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) local_domain_info: std::option::Option<crate::model::DomainInformationContainer>,
        pub(crate) remote_domain_info:
            std::option::Option<crate::model::DomainInformationContainer>,
        pub(crate) connection_id: std::option::Option<std::string::String>,
        pub(crate) connection_alias: std::option::Option<std::string::String>,
        pub(crate) connection_status: std::option::Option<crate::model::OutboundConnectionStatus>,
    }
    impl Builder {
        /// <p>The <code> <code>DomainInformation</code> </code> for the local OpenSearch domain. </p>
        pub fn local_domain_info(
            mut self,
            input: crate::model::DomainInformationContainer,
        ) -> Self {
            self.local_domain_info = Some(input);
            self
        }
        /// <p>The <code> <code>DomainInformation</code> </code> for the local OpenSearch domain. </p>
        pub fn set_local_domain_info(
            mut self,
            input: std::option::Option<crate::model::DomainInformationContainer>,
        ) -> Self {
            self.local_domain_info = input;
            self
        }
        /// <p>The <code> <code>DomainInformation</code> </code> for the remote OpenSearch domain. </p>
        pub fn remote_domain_info(
            mut self,
            input: crate::model::DomainInformationContainer,
        ) -> Self {
            self.remote_domain_info = Some(input);
            self
        }
        /// <p>The <code> <code>DomainInformation</code> </code> for the remote OpenSearch domain. </p>
        pub fn set_remote_domain_info(
            mut self,
            input: std::option::Option<crate::model::DomainInformationContainer>,
        ) -> Self {
            self.remote_domain_info = input;
            self
        }
        /// <p>The connection ID for the outbound cross-cluster connection.</p>
        pub fn connection_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.connection_id = Some(input.into());
            self
        }
        /// <p>The connection ID for the outbound cross-cluster connection.</p>
        pub fn set_connection_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.connection_id = input;
            self
        }
        /// <p>The connection alias for the outbound cross-cluster connection.</p>
        pub fn connection_alias(mut self, input: impl Into<std::string::String>) -> Self {
            self.connection_alias = Some(input.into());
            self
        }
        /// <p>The connection alias for the outbound cross-cluster connection.</p>
        pub fn set_connection_alias(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.connection_alias = input;
            self
        }
        /// <p>The <code> <code>OutboundConnectionStatus</code> </code> for the outbound connection. </p>
        pub fn connection_status(mut self, input: crate::model::OutboundConnectionStatus) -> Self {
            self.connection_status = Some(input);
            self
        }
        /// <p>The <code> <code>OutboundConnectionStatus</code> </code> for the outbound connection. </p>
        pub fn set_connection_status(
            mut self,
            input: std::option::Option<crate::model::OutboundConnectionStatus>,
        ) -> Self {
            self.connection_status = input;
            self
        }
        /// Consumes the builder and constructs a [`OutboundConnection`](crate::model::OutboundConnection)
        pub fn build(self) -> crate::model::OutboundConnection {
            crate::model::OutboundConnection {
                local_domain_info: self.local_domain_info,
                remote_domain_info: self.remote_domain_info,
                connection_id: self.connection_id,
                connection_alias: self.connection_alias,
                connection_status: self.connection_status,
            }
        }
    }
}
impl OutboundConnection {
    /// Creates a new builder-style object to manufacture [`OutboundConnection`](crate::model::OutboundConnection)
    pub fn builder() -> crate::model::outbound_connection::Builder {
        crate::model::outbound_connection::Builder::default()
    }
}

/// <p>The connection status of an outbound cross-cluster connection.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct OutboundConnectionStatus {
    /// <p>The state code for the outbound connection. Can be one of the following:</p>
    /// <ul>
    /// <li>VALIDATING: The outbound connection request is being validated.</li>
    /// <li>VALIDATION_FAILED: Validation failed for the connection request.</li>
    /// <li>PENDING_ACCEPTANCE: Outbound connection request is validated and is not yet accepted by the remote domain owner. </li>
    /// <li>APPROVED: Outbound connection has been approved by the remote domain owner for getting provisioned.</li>
    /// <li>PROVISIONING: Outbound connection request is in process.</li>
    /// <li>ACTIVE: Outbound connection is active and ready to use.</li>
    /// <li>REJECTING: Outbound connection rejection by remote domain owner is in progress.</li>
    /// <li>REJECTED: Outbound connection request is rejected by remote domain owner.</li>
    /// <li>DELETING: Outbound connection deletion is in progress.</li>
    /// <li>DELETED: Outbound connection is deleted and can no longer be used.</li>
    /// </ul>
    pub status_code: std::option::Option<crate::model::OutboundConnectionStatusCode>,
    /// <p>Verbose information for the outbound connection status.</p>
    pub message: std::option::Option<std::string::String>,
}
impl OutboundConnectionStatus {
    /// <p>The state code for the outbound connection. Can be one of the following:</p>
    /// <ul>
    /// <li>VALIDATING: The outbound connection request is being validated.</li>
    /// <li>VALIDATION_FAILED: Validation failed for the connection request.</li>
    /// <li>PENDING_ACCEPTANCE: Outbound connection request is validated and is not yet accepted by the remote domain owner. </li>
    /// <li>APPROVED: Outbound connection has been approved by the remote domain owner for getting provisioned.</li>
    /// <li>PROVISIONING: Outbound connection request is in process.</li>
    /// <li>ACTIVE: Outbound connection is active and ready to use.</li>
    /// <li>REJECTING: Outbound connection rejection by remote domain owner is in progress.</li>
    /// <li>REJECTED: Outbound connection request is rejected by remote domain owner.</li>
    /// <li>DELETING: Outbound connection deletion is in progress.</li>
    /// <li>DELETED: Outbound connection is deleted and can no longer be used.</li>
    /// </ul>
    pub fn status_code(&self) -> std::option::Option<&crate::model::OutboundConnectionStatusCode> {
        self.status_code.as_ref()
    }
    /// <p>Verbose information for the outbound connection status.</p>
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Debug for OutboundConnectionStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("OutboundConnectionStatus");
        formatter.field("status_code", &self.status_code);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
/// See [`OutboundConnectionStatus`](crate::model::OutboundConnectionStatus)
pub mod outbound_connection_status {

    /// A builder for [`OutboundConnectionStatus`](crate::model::OutboundConnectionStatus)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) status_code: std::option::Option<crate::model::OutboundConnectionStatusCode>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The state code for the outbound connection. Can be one of the following:</p>
        /// <ul>
        /// <li>VALIDATING: The outbound connection request is being validated.</li>
        /// <li>VALIDATION_FAILED: Validation failed for the connection request.</li>
        /// <li>PENDING_ACCEPTANCE: Outbound connection request is validated and is not yet accepted by the remote domain owner. </li>
        /// <li>APPROVED: Outbound connection has been approved by the remote domain owner for getting provisioned.</li>
        /// <li>PROVISIONING: Outbound connection request is in process.</li>
        /// <li>ACTIVE: Outbound connection is active and ready to use.</li>
        /// <li>REJECTING: Outbound connection rejection by remote domain owner is in progress.</li>
        /// <li>REJECTED: Outbound connection request is rejected by remote domain owner.</li>
        /// <li>DELETING: Outbound connection deletion is in progress.</li>
        /// <li>DELETED: Outbound connection is deleted and can no longer be used.</li>
        /// </ul>
        pub fn status_code(mut self, input: crate::model::OutboundConnectionStatusCode) -> Self {
            self.status_code = Some(input);
            self
        }
        /// <p>The state code for the outbound connection. Can be one of the following:</p>
        /// <ul>
        /// <li>VALIDATING: The outbound connection request is being validated.</li>
        /// <li>VALIDATION_FAILED: Validation failed for the connection request.</li>
        /// <li>PENDING_ACCEPTANCE: Outbound connection request is validated and is not yet accepted by the remote domain owner. </li>
        /// <li>APPROVED: Outbound connection has been approved by the remote domain owner for getting provisioned.</li>
        /// <li>PROVISIONING: Outbound connection request is in process.</li>
        /// <li>ACTIVE: Outbound connection is active and ready to use.</li>
        /// <li>REJECTING: Outbound connection rejection by remote domain owner is in progress.</li>
        /// <li>REJECTED: Outbound connection request is rejected by remote domain owner.</li>
        /// <li>DELETING: Outbound connection deletion is in progress.</li>
        /// <li>DELETED: Outbound connection is deleted and can no longer be used.</li>
        /// </ul>
        pub fn set_status_code(
            mut self,
            input: std::option::Option<crate::model::OutboundConnectionStatusCode>,
        ) -> Self {
            self.status_code = input;
            self
        }
        /// <p>Verbose information for the outbound connection status.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Verbose information for the outbound connection status.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`OutboundConnectionStatus`](crate::model::OutboundConnectionStatus)
        pub fn build(self) -> crate::model::OutboundConnectionStatus {
            crate::model::OutboundConnectionStatus {
                status_code: self.status_code,
                message: self.message,
            }
        }
    }
}
impl OutboundConnectionStatus {
    /// Creates a new builder-style object to manufacture [`OutboundConnectionStatus`](crate::model::OutboundConnectionStatus)
    pub fn builder() -> crate::model::outbound_connection_status::Builder {
        crate::model::outbound_connection_status::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum OutboundConnectionStatusCode {
    #[allow(missing_docs)] // documentation missing in model
    Active,
    #[allow(missing_docs)] // documentation missing in model
    Approved,
    #[allow(missing_docs)] // documentation missing in model
    Deleted,
    #[allow(missing_docs)] // documentation missing in model
    Deleting,
    #[allow(missing_docs)] // documentation missing in model
    PendingAcceptance,
    #[allow(missing_docs)] // documentation missing in model
    Provisioning,
    #[allow(missing_docs)] // documentation missing in model
    Rejected,
    #[allow(missing_docs)] // documentation missing in model
    Rejecting,
    #[allow(missing_docs)] // documentation missing in model
    Validating,
    #[allow(missing_docs)] // documentation missing in model
    ValidationFailed,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for OutboundConnectionStatusCode {
    fn from(s: &str) -> Self {
        match s {
            "ACTIVE" => OutboundConnectionStatusCode::Active,
            "APPROVED" => OutboundConnectionStatusCode::Approved,
            "DELETED" => OutboundConnectionStatusCode::Deleted,
            "DELETING" => OutboundConnectionStatusCode::Deleting,
            "PENDING_ACCEPTANCE" => OutboundConnectionStatusCode::PendingAcceptance,
            "PROVISIONING" => OutboundConnectionStatusCode::Provisioning,
            "REJECTED" => OutboundConnectionStatusCode::Rejected,
            "REJECTING" => OutboundConnectionStatusCode::Rejecting,
            "VALIDATING" => OutboundConnectionStatusCode::Validating,
            "VALIDATION_FAILED" => OutboundConnectionStatusCode::ValidationFailed,
            other => OutboundConnectionStatusCode::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for OutboundConnectionStatusCode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(OutboundConnectionStatusCode::from(s))
    }
}
impl OutboundConnectionStatusCode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            OutboundConnectionStatusCode::Active => "ACTIVE",
            OutboundConnectionStatusCode::Approved => "APPROVED",
            OutboundConnectionStatusCode::Deleted => "DELETED",
            OutboundConnectionStatusCode::Deleting => "DELETING",
            OutboundConnectionStatusCode::PendingAcceptance => "PENDING_ACCEPTANCE",
            OutboundConnectionStatusCode::Provisioning => "PROVISIONING",
            OutboundConnectionStatusCode::Rejected => "REJECTED",
            OutboundConnectionStatusCode::Rejecting => "REJECTING",
            OutboundConnectionStatusCode::Validating => "VALIDATING",
            OutboundConnectionStatusCode::ValidationFailed => "VALIDATION_FAILED",
            OutboundConnectionStatusCode::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "ACTIVE",
            "APPROVED",
            "DELETED",
            "DELETING",
            "PENDING_ACCEPTANCE",
            "PROVISIONING",
            "REJECTED",
            "REJECTING",
            "VALIDATING",
            "VALIDATION_FAILED",
        ]
    }
}
impl AsRef<str> for OutboundConnectionStatusCode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p> A filter used to limit results when describing inbound or outbound cross-cluster connections. Multiple values can be specified per filter. A cross-cluster connection must match at least one of the specified values for it to be returned from an operation. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Filter {
    /// <p> The name of the filter. </p>
    pub name: std::option::Option<std::string::String>,
    /// <p> Contains one or more values for the filter. </p>
    pub values: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl Filter {
    /// <p> The name of the filter. </p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p> Contains one or more values for the filter. </p>
    pub fn values(&self) -> std::option::Option<&[std::string::String]> {
        self.values.as_deref()
    }
}
impl std::fmt::Debug for Filter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Filter");
        formatter.field("name", &self.name);
        formatter.field("values", &self.values);
        formatter.finish()
    }
}
/// See [`Filter`](crate::model::Filter)
pub mod filter {

    /// A builder for [`Filter`](crate::model::Filter)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) values: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p> The name of the filter. </p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p> The name of the filter. </p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Appends an item to `values`.
        ///
        /// To override the contents of this collection use [`set_values`](Self::set_values).
        ///
        /// <p> Contains one or more values for the filter. </p>
        pub fn values(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.values.unwrap_or_default();
            v.push(input.into());
            self.values = Some(v);
            self
        }
        /// <p> Contains one or more values for the filter. </p>
        pub fn set_values(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.values = input;
            self
        }
        /// Consumes the builder and constructs a [`Filter`](crate::model::Filter)
        pub fn build(self) -> crate::model::Filter {
            crate::model::Filter {
                name: self.name,
                values: self.values,
            }
        }
    }
}
impl Filter {
    /// Creates a new builder-style object to manufacture [`Filter`](crate::model::Filter)
    pub fn builder() -> crate::model::filter::Builder {
        crate::model::filter::Builder::default()
    }
}

/// <p> Limits for a given InstanceType and for each of its roles. <br><br> Limits contains the following: <code> <code>StorageTypes</code> </code>, <code> <code>InstanceLimits</code> </code>, and <code> <code>AdditionalLimits</code> </code> </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Limits {
    /// <p>Storage-related types and attributes that are available for a given InstanceType. </p>
    pub storage_types: std::option::Option<std::vec::Vec<crate::model::StorageType>>,
    /// <p>InstanceLimits represents the list of instance-related attributes that are available for a given InstanceType. </p>
    pub instance_limits: std::option::Option<crate::model::InstanceLimits>,
    /// <p> List of additional limits that are specific to a given InstanceType and for each of its <code> <code>InstanceRole</code> </code> . </p>
    pub additional_limits: std::option::Option<std::vec::Vec<crate::model::AdditionalLimit>>,
}
impl Limits {
    /// <p>Storage-related types and attributes that are available for a given InstanceType. </p>
    pub fn storage_types(&self) -> std::option::Option<&[crate::model::StorageType]> {
        self.storage_types.as_deref()
    }
    /// <p>InstanceLimits represents the list of instance-related attributes that are available for a given InstanceType. </p>
    pub fn instance_limits(&self) -> std::option::Option<&crate::model::InstanceLimits> {
        self.instance_limits.as_ref()
    }
    /// <p> List of additional limits that are specific to a given InstanceType and for each of its <code> <code>InstanceRole</code> </code> . </p>
    pub fn additional_limits(&self) -> std::option::Option<&[crate::model::AdditionalLimit]> {
        self.additional_limits.as_deref()
    }
}
impl std::fmt::Debug for Limits {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Limits");
        formatter.field("storage_types", &self.storage_types);
        formatter.field("instance_limits", &self.instance_limits);
        formatter.field("additional_limits", &self.additional_limits);
        formatter.finish()
    }
}
/// See [`Limits`](crate::model::Limits)
pub mod limits {

    /// A builder for [`Limits`](crate::model::Limits)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) storage_types: std::option::Option<std::vec::Vec<crate::model::StorageType>>,
        pub(crate) instance_limits: std::option::Option<crate::model::InstanceLimits>,
        pub(crate) additional_limits:
            std::option::Option<std::vec::Vec<crate::model::AdditionalLimit>>,
    }
    impl Builder {
        /// Appends an item to `storage_types`.
        ///
        /// To override the contents of this collection use [`set_storage_types`](Self::set_storage_types).
        ///
        /// <p>Storage-related types and attributes that are available for a given InstanceType. </p>
        pub fn storage_types(mut self, input: crate::model::StorageType) -> Self {
            let mut v = self.storage_types.unwrap_or_default();
            v.push(input);
            self.storage_types = Some(v);
            self
        }
        /// <p>Storage-related types and attributes that are available for a given InstanceType. </p>
        pub fn set_storage_types(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::StorageType>>,
        ) -> Self {
            self.storage_types = input;
            self
        }
        /// <p>InstanceLimits represents the list of instance-related attributes that are available for a given InstanceType. </p>
        pub fn instance_limits(mut self, input: crate::model::InstanceLimits) -> Self {
            self.instance_limits = Some(input);
            self
        }
        /// <p>InstanceLimits represents the list of instance-related attributes that are available for a given InstanceType. </p>
        pub fn set_instance_limits(
            mut self,
            input: std::option::Option<crate::model::InstanceLimits>,
        ) -> Self {
            self.instance_limits = input;
            self
        }
        /// Appends an item to `additional_limits`.
        ///
        /// To override the contents of this collection use [`set_additional_limits`](Self::set_additional_limits).
        ///
        /// <p> List of additional limits that are specific to a given InstanceType and for each of its <code> <code>InstanceRole</code> </code> . </p>
        pub fn additional_limits(mut self, input: crate::model::AdditionalLimit) -> Self {
            let mut v = self.additional_limits.unwrap_or_default();
            v.push(input);
            self.additional_limits = Some(v);
            self
        }
        /// <p> List of additional limits that are specific to a given InstanceType and for each of its <code> <code>InstanceRole</code> </code> . </p>
        pub fn set_additional_limits(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AdditionalLimit>>,
        ) -> Self {
            self.additional_limits = input;
            self
        }
        /// Consumes the builder and constructs a [`Limits`](crate::model::Limits)
        pub fn build(self) -> crate::model::Limits {
            crate::model::Limits {
                storage_types: self.storage_types,
                instance_limits: self.instance_limits,
                additional_limits: self.additional_limits,
            }
        }
    }
}
impl Limits {
    /// Creates a new builder-style object to manufacture [`Limits`](crate::model::Limits)
    pub fn builder() -> crate::model::limits::Builder {
        crate::model::limits::Builder::default()
    }
}

/// <p> List of limits that are specific to a given InstanceType and for each of its <code> <code>InstanceRole</code> </code> . </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AdditionalLimit {
    /// <p> Additional limit is specific to a given InstanceType and for each of its <code> <code>InstanceRole</code> </code> etc. <br><br> Attributes and their details: <br><br> </p>
    /// <ul>
    /// <li>MaximumNumberOfDataNodesSupported</li> This attribute is present on the master node only to specify how much data nodes up to which given <code> <code>ESPartitionInstanceType</code> </code> can support as master node.
    /// <li>MaximumNumberOfDataNodesWithoutMasterNode</li> This attribute is present on data node only to specify how much data nodes of given <code> <code>ESPartitionInstanceType</code> </code> up to which you don't need any master nodes to govern them.
    /// </ul>
    /// <p></p>
    pub limit_name: std::option::Option<std::string::String>,
    /// <p> Value for a given <code> <code>AdditionalLimit$LimitName</code> </code> . </p>
    pub limit_values: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl AdditionalLimit {
    /// <p> Additional limit is specific to a given InstanceType and for each of its <code> <code>InstanceRole</code> </code> etc. <br><br> Attributes and their details: <br><br> </p>
    /// <ul>
    /// <li>MaximumNumberOfDataNodesSupported</li> This attribute is present on the master node only to specify how much data nodes up to which given <code> <code>ESPartitionInstanceType</code> </code> can support as master node.
    /// <li>MaximumNumberOfDataNodesWithoutMasterNode</li> This attribute is present on data node only to specify how much data nodes of given <code> <code>ESPartitionInstanceType</code> </code> up to which you don't need any master nodes to govern them.
    /// </ul>
    /// <p></p>
    pub fn limit_name(&self) -> std::option::Option<&str> {
        self.limit_name.as_deref()
    }
    /// <p> Value for a given <code> <code>AdditionalLimit$LimitName</code> </code> . </p>
    pub fn limit_values(&self) -> std::option::Option<&[std::string::String]> {
        self.limit_values.as_deref()
    }
}
impl std::fmt::Debug for AdditionalLimit {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AdditionalLimit");
        formatter.field("limit_name", &self.limit_name);
        formatter.field("limit_values", &self.limit_values);
        formatter.finish()
    }
}
/// See [`AdditionalLimit`](crate::model::AdditionalLimit)
pub mod additional_limit {

    /// A builder for [`AdditionalLimit`](crate::model::AdditionalLimit)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) limit_name: std::option::Option<std::string::String>,
        pub(crate) limit_values: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p> Additional limit is specific to a given InstanceType and for each of its <code> <code>InstanceRole</code> </code> etc. <br><br> Attributes and their details: <br><br> </p>
        /// <ul>
        /// <li>MaximumNumberOfDataNodesSupported</li> This attribute is present on the master node only to specify how much data nodes up to which given <code> <code>ESPartitionInstanceType</code> </code> can support as master node.
        /// <li>MaximumNumberOfDataNodesWithoutMasterNode</li> This attribute is present on data node only to specify how much data nodes of given <code> <code>ESPartitionInstanceType</code> </code> up to which you don't need any master nodes to govern them.
        /// </ul>
        /// <p></p>
        pub fn limit_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.limit_name = Some(input.into());
            self
        }
        /// <p> Additional limit is specific to a given InstanceType and for each of its <code> <code>InstanceRole</code> </code> etc. <br><br> Attributes and their details: <br><br> </p>
        /// <ul>
        /// <li>MaximumNumberOfDataNodesSupported</li> This attribute is present on the master node only to specify how much data nodes up to which given <code> <code>ESPartitionInstanceType</code> </code> can support as master node.
        /// <li>MaximumNumberOfDataNodesWithoutMasterNode</li> This attribute is present on data node only to specify how much data nodes of given <code> <code>ESPartitionInstanceType</code> </code> up to which you don't need any master nodes to govern them.
        /// </ul>
        /// <p></p>
        pub fn set_limit_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.limit_name = input;
            self
        }
        /// Appends an item to `limit_values`.
        ///
        /// To override the contents of this collection use [`set_limit_values`](Self::set_limit_values).
        ///
        /// <p> Value for a given <code> <code>AdditionalLimit$LimitName</code> </code> . </p>
        pub fn limit_values(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.limit_values.unwrap_or_default();
            v.push(input.into());
            self.limit_values = Some(v);
            self
        }
        /// <p> Value for a given <code> <code>AdditionalLimit$LimitName</code> </code> . </p>
        pub fn set_limit_values(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.limit_values = input;
            self
        }
        /// Consumes the builder and constructs a [`AdditionalLimit`](crate::model::AdditionalLimit)
        pub fn build(self) -> crate::model::AdditionalLimit {
            crate::model::AdditionalLimit {
                limit_name: self.limit_name,
                limit_values: self.limit_values,
            }
        }
    }
}
impl AdditionalLimit {
    /// Creates a new builder-style object to manufacture [`AdditionalLimit`](crate::model::AdditionalLimit)
    pub fn builder() -> crate::model::additional_limit::Builder {
        crate::model::additional_limit::Builder::default()
    }
}

/// <p>InstanceLimits represents the list of instance-related attributes that are available for a given InstanceType. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InstanceLimits {
    /// <p> InstanceCountLimits represents the limits on the number of instances that can be created in Amazon OpenSearch Service for a given InstanceType. </p>
    pub instance_count_limits: std::option::Option<crate::model::InstanceCountLimits>,
}
impl InstanceLimits {
    /// <p> InstanceCountLimits represents the limits on the number of instances that can be created in Amazon OpenSearch Service for a given InstanceType. </p>
    pub fn instance_count_limits(&self) -> std::option::Option<&crate::model::InstanceCountLimits> {
        self.instance_count_limits.as_ref()
    }
}
impl std::fmt::Debug for InstanceLimits {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InstanceLimits");
        formatter.field("instance_count_limits", &self.instance_count_limits);
        formatter.finish()
    }
}
/// See [`InstanceLimits`](crate::model::InstanceLimits)
pub mod instance_limits {

    /// A builder for [`InstanceLimits`](crate::model::InstanceLimits)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_count_limits: std::option::Option<crate::model::InstanceCountLimits>,
    }
    impl Builder {
        /// <p> InstanceCountLimits represents the limits on the number of instances that can be created in Amazon OpenSearch Service for a given InstanceType. </p>
        pub fn instance_count_limits(mut self, input: crate::model::InstanceCountLimits) -> Self {
            self.instance_count_limits = Some(input);
            self
        }
        /// <p> InstanceCountLimits represents the limits on the number of instances that can be created in Amazon OpenSearch Service for a given InstanceType. </p>
        pub fn set_instance_count_limits(
            mut self,
            input: std::option::Option<crate::model::InstanceCountLimits>,
        ) -> Self {
            self.instance_count_limits = input;
            self
        }
        /// Consumes the builder and constructs a [`InstanceLimits`](crate::model::InstanceLimits)
        pub fn build(self) -> crate::model::InstanceLimits {
            crate::model::InstanceLimits {
                instance_count_limits: self.instance_count_limits,
            }
        }
    }
}
impl InstanceLimits {
    /// Creates a new builder-style object to manufacture [`InstanceLimits`](crate::model::InstanceLimits)
    pub fn builder() -> crate::model::instance_limits::Builder {
        crate::model::instance_limits::Builder::default()
    }
}

/// <p> InstanceCountLimits represents the limits on the number of instances that can be created in Amazon OpenSearch Service for a given InstanceType. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InstanceCountLimits {
    /// <p> Minimum number of instances that can be instantiated for a given InstanceType. </p>
    pub minimum_instance_count: i32,
    /// <p> Maximum number of instances that can be instantiated for a given InstanceType. </p>
    pub maximum_instance_count: i32,
}
impl InstanceCountLimits {
    /// <p> Minimum number of instances that can be instantiated for a given InstanceType. </p>
    pub fn minimum_instance_count(&self) -> i32 {
        self.minimum_instance_count
    }
    /// <p> Maximum number of instances that can be instantiated for a given InstanceType. </p>
    pub fn maximum_instance_count(&self) -> i32 {
        self.maximum_instance_count
    }
}
impl std::fmt::Debug for InstanceCountLimits {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InstanceCountLimits");
        formatter.field("minimum_instance_count", &self.minimum_instance_count);
        formatter.field("maximum_instance_count", &self.maximum_instance_count);
        formatter.finish()
    }
}
/// See [`InstanceCountLimits`](crate::model::InstanceCountLimits)
pub mod instance_count_limits {

    /// A builder for [`InstanceCountLimits`](crate::model::InstanceCountLimits)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) minimum_instance_count: std::option::Option<i32>,
        pub(crate) maximum_instance_count: std::option::Option<i32>,
    }
    impl Builder {
        /// <p> Minimum number of instances that can be instantiated for a given InstanceType. </p>
        pub fn minimum_instance_count(mut self, input: i32) -> Self {
            self.minimum_instance_count = Some(input);
            self
        }
        /// <p> Minimum number of instances that can be instantiated for a given InstanceType. </p>
        pub fn set_minimum_instance_count(mut self, input: std::option::Option<i32>) -> Self {
            self.minimum_instance_count = input;
            self
        }
        /// <p> Maximum number of instances that can be instantiated for a given InstanceType. </p>
        pub fn maximum_instance_count(mut self, input: i32) -> Self {
            self.maximum_instance_count = Some(input);
            self
        }
        /// <p> Maximum number of instances that can be instantiated for a given InstanceType. </p>
        pub fn set_maximum_instance_count(mut self, input: std::option::Option<i32>) -> Self {
            self.maximum_instance_count = input;
            self
        }
        /// Consumes the builder and constructs a [`InstanceCountLimits`](crate::model::InstanceCountLimits)
        pub fn build(self) -> crate::model::InstanceCountLimits {
            crate::model::InstanceCountLimits {
                minimum_instance_count: self.minimum_instance_count.unwrap_or_default(),
                maximum_instance_count: self.maximum_instance_count.unwrap_or_default(),
            }
        }
    }
}
impl InstanceCountLimits {
    /// Creates a new builder-style object to manufacture [`InstanceCountLimits`](crate::model::InstanceCountLimits)
    pub fn builder() -> crate::model::instance_count_limits::Builder {
        crate::model::instance_count_limits::Builder::default()
    }
}

/// <p>StorageTypes represents the list of storage-related types and their attributes that are available for a given InstanceType. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StorageType {
    /// <p> Type of storage. List of available storage options: </p>
    /// <ol>
    /// <li>instance</li> Built-in storage available for the instance
    /// <li>ebs</li> Elastic block storage attached to the instance
    /// </ol>
    /// <p></p>
    pub storage_type_name: std::option::Option<std::string::String>,
    /// <p> Sub-type of the given storage type. List of available sub-storage options: "instance" storageType has no storageSubType. "ebs" storageType has the following valid storageSubTypes: </p>
    /// <ol>
    /// <li>standard</li>
    /// <li>gp2</li>
    /// <li>io1</li>
    /// </ol> See <code> <code>VolumeType</code> </code> for more information regarding each EBS storage option.
    /// <p></p>
    pub storage_sub_type_name: std::option::Option<std::string::String>,
    /// <p>Limits that are applicable for the given storage type. </p>
    pub storage_type_limits: std::option::Option<std::vec::Vec<crate::model::StorageTypeLimit>>,
}
impl StorageType {
    /// <p> Type of storage. List of available storage options: </p>
    /// <ol>
    /// <li>instance</li> Built-in storage available for the instance
    /// <li>ebs</li> Elastic block storage attached to the instance
    /// </ol>
    /// <p></p>
    pub fn storage_type_name(&self) -> std::option::Option<&str> {
        self.storage_type_name.as_deref()
    }
    /// <p> Sub-type of the given storage type. List of available sub-storage options: "instance" storageType has no storageSubType. "ebs" storageType has the following valid storageSubTypes: </p>
    /// <ol>
    /// <li>standard</li>
    /// <li>gp2</li>
    /// <li>io1</li>
    /// </ol> See <code> <code>VolumeType</code> </code> for more information regarding each EBS storage option.
    /// <p></p>
    pub fn storage_sub_type_name(&self) -> std::option::Option<&str> {
        self.storage_sub_type_name.as_deref()
    }
    /// <p>Limits that are applicable for the given storage type. </p>
    pub fn storage_type_limits(&self) -> std::option::Option<&[crate::model::StorageTypeLimit]> {
        self.storage_type_limits.as_deref()
    }
}
impl std::fmt::Debug for StorageType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StorageType");
        formatter.field("storage_type_name", &self.storage_type_name);
        formatter.field("storage_sub_type_name", &self.storage_sub_type_name);
        formatter.field("storage_type_limits", &self.storage_type_limits);
        formatter.finish()
    }
}
/// See [`StorageType`](crate::model::StorageType)
pub mod storage_type {

    /// A builder for [`StorageType`](crate::model::StorageType)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) storage_type_name: std::option::Option<std::string::String>,
        pub(crate) storage_sub_type_name: std::option::Option<std::string::String>,
        pub(crate) storage_type_limits:
            std::option::Option<std::vec::Vec<crate::model::StorageTypeLimit>>,
    }
    impl Builder {
        /// <p> Type of storage. List of available storage options: </p>
        /// <ol>
        /// <li>instance</li> Built-in storage available for the instance
        /// <li>ebs</li> Elastic block storage attached to the instance
        /// </ol>
        /// <p></p>
        pub fn storage_type_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.storage_type_name = Some(input.into());
            self
        }
        /// <p> Type of storage. List of available storage options: </p>
        /// <ol>
        /// <li>instance</li> Built-in storage available for the instance
        /// <li>ebs</li> Elastic block storage attached to the instance
        /// </ol>
        /// <p></p>
        pub fn set_storage_type_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.storage_type_name = input;
            self
        }
        /// <p> Sub-type of the given storage type. List of available sub-storage options: "instance" storageType has no storageSubType. "ebs" storageType has the following valid storageSubTypes: </p>
        /// <ol>
        /// <li>standard</li>
        /// <li>gp2</li>
        /// <li>io1</li>
        /// </ol> See <code> <code>VolumeType</code> </code> for more information regarding each EBS storage option.
        /// <p></p>
        pub fn storage_sub_type_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.storage_sub_type_name = Some(input.into());
            self
        }
        /// <p> Sub-type of the given storage type. List of available sub-storage options: "instance" storageType has no storageSubType. "ebs" storageType has the following valid storageSubTypes: </p>
        /// <ol>
        /// <li>standard</li>
        /// <li>gp2</li>
        /// <li>io1</li>
        /// </ol> See <code> <code>VolumeType</code> </code> for more information regarding each EBS storage option.
        /// <p></p>
        pub fn set_storage_sub_type_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.storage_sub_type_name = input;
            self
        }
        /// Appends an item to `storage_type_limits`.
        ///
        /// To override the contents of this collection use [`set_storage_type_limits`](Self::set_storage_type_limits).
        ///
        /// <p>Limits that are applicable for the given storage type. </p>
        pub fn storage_type_limits(mut self, input: crate::model::StorageTypeLimit) -> Self {
            let mut v = self.storage_type_limits.unwrap_or_default();
            v.push(input);
            self.storage_type_limits = Some(v);
            self
        }
        /// <p>Limits that are applicable for the given storage type. </p>
        pub fn set_storage_type_limits(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::StorageTypeLimit>>,
        ) -> Self {
            self.storage_type_limits = input;
            self
        }
        /// Consumes the builder and constructs a [`StorageType`](crate::model::StorageType)
        pub fn build(self) -> crate::model::StorageType {
            crate::model::StorageType {
                storage_type_name: self.storage_type_name,
                storage_sub_type_name: self.storage_sub_type_name,
                storage_type_limits: self.storage_type_limits,
            }
        }
    }
}
impl StorageType {
    /// Creates a new builder-style object to manufacture [`StorageType`](crate::model::StorageType)
    pub fn builder() -> crate::model::storage_type::Builder {
        crate::model::storage_type::Builder::default()
    }
}

/// <p>Limits that are applicable for the given storage type. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StorageTypeLimit {
    /// <p> Name of storage limits that are applicable for the given storage type. If <code> <code>StorageType</code> </code> is "ebs", the following storage options are applicable: </p>
    /// <ol>
    /// <li>MinimumVolumeSize</li> Minimum amount of volume size that is applicable for the given storage type. Can be empty if not applicable.
    /// <li>MaximumVolumeSize</li> Maximum amount of volume size that is applicable for the given storage type. Can be empty if not applicable.
    /// <li>MaximumIops</li> Maximum amount of Iops that is applicable for given the storage type. Can be empty if not applicable.
    /// <li>MinimumIops</li> Minimum amount of Iops that is applicable for given the storage type. Can be empty if not applicable.
    /// </ol>
    /// <p></p>
    pub limit_name: std::option::Option<std::string::String>,
    /// <p> Values for the <code> <code>StorageTypeLimit$LimitName</code> </code> . </p>
    pub limit_values: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl StorageTypeLimit {
    /// <p> Name of storage limits that are applicable for the given storage type. If <code> <code>StorageType</code> </code> is "ebs", the following storage options are applicable: </p>
    /// <ol>
    /// <li>MinimumVolumeSize</li> Minimum amount of volume size that is applicable for the given storage type. Can be empty if not applicable.
    /// <li>MaximumVolumeSize</li> Maximum amount of volume size that is applicable for the given storage type. Can be empty if not applicable.
    /// <li>MaximumIops</li> Maximum amount of Iops that is applicable for given the storage type. Can be empty if not applicable.
    /// <li>MinimumIops</li> Minimum amount of Iops that is applicable for given the storage type. Can be empty if not applicable.
    /// </ol>
    /// <p></p>
    pub fn limit_name(&self) -> std::option::Option<&str> {
        self.limit_name.as_deref()
    }
    /// <p> Values for the <code> <code>StorageTypeLimit$LimitName</code> </code> . </p>
    pub fn limit_values(&self) -> std::option::Option<&[std::string::String]> {
        self.limit_values.as_deref()
    }
}
impl std::fmt::Debug for StorageTypeLimit {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StorageTypeLimit");
        formatter.field("limit_name", &self.limit_name);
        formatter.field("limit_values", &self.limit_values);
        formatter.finish()
    }
}
/// See [`StorageTypeLimit`](crate::model::StorageTypeLimit)
pub mod storage_type_limit {

    /// A builder for [`StorageTypeLimit`](crate::model::StorageTypeLimit)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) limit_name: std::option::Option<std::string::String>,
        pub(crate) limit_values: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p> Name of storage limits that are applicable for the given storage type. If <code> <code>StorageType</code> </code> is "ebs", the following storage options are applicable: </p>
        /// <ol>
        /// <li>MinimumVolumeSize</li> Minimum amount of volume size that is applicable for the given storage type. Can be empty if not applicable.
        /// <li>MaximumVolumeSize</li> Maximum amount of volume size that is applicable for the given storage type. Can be empty if not applicable.
        /// <li>MaximumIops</li> Maximum amount of Iops that is applicable for given the storage type. Can be empty if not applicable.
        /// <li>MinimumIops</li> Minimum amount of Iops that is applicable for given the storage type. Can be empty if not applicable.
        /// </ol>
        /// <p></p>
        pub fn limit_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.limit_name = Some(input.into());
            self
        }
        /// <p> Name of storage limits that are applicable for the given storage type. If <code> <code>StorageType</code> </code> is "ebs", the following storage options are applicable: </p>
        /// <ol>
        /// <li>MinimumVolumeSize</li> Minimum amount of volume size that is applicable for the given storage type. Can be empty if not applicable.
        /// <li>MaximumVolumeSize</li> Maximum amount of volume size that is applicable for the given storage type. Can be empty if not applicable.
        /// <li>MaximumIops</li> Maximum amount of Iops that is applicable for given the storage type. Can be empty if not applicable.
        /// <li>MinimumIops</li> Minimum amount of Iops that is applicable for given the storage type. Can be empty if not applicable.
        /// </ol>
        /// <p></p>
        pub fn set_limit_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.limit_name = input;
            self
        }
        /// Appends an item to `limit_values`.
        ///
        /// To override the contents of this collection use [`set_limit_values`](Self::set_limit_values).
        ///
        /// <p> Values for the <code> <code>StorageTypeLimit$LimitName</code> </code> . </p>
        pub fn limit_values(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.limit_values.unwrap_or_default();
            v.push(input.into());
            self.limit_values = Some(v);
            self
        }
        /// <p> Values for the <code> <code>StorageTypeLimit$LimitName</code> </code> . </p>
        pub fn set_limit_values(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.limit_values = input;
            self
        }
        /// Consumes the builder and constructs a [`StorageTypeLimit`](crate::model::StorageTypeLimit)
        pub fn build(self) -> crate::model::StorageTypeLimit {
            crate::model::StorageTypeLimit {
                limit_name: self.limit_name,
                limit_values: self.limit_values,
            }
        }
    }
}
impl StorageTypeLimit {
    /// Creates a new builder-style object to manufacture [`StorageTypeLimit`](crate::model::StorageTypeLimit)
    pub fn builder() -> crate::model::storage_type_limit::Builder {
        crate::model::storage_type_limit::Builder::default()
    }
}

/// <p>The current status of a domain.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DomainStatus {
    /// <p>The unique identifier for the specified domain.</p>
    pub domain_id: std::option::Option<std::string::String>,
    /// <p>The name of a domain. Domain names are unique across the domains owned by an account within an AWS region. Domain names start with a letter or number and can contain the following characters: a-z (lowercase), 0-9, and - (hyphen). </p>
    pub domain_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of a domain. See <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html" target="_blank">IAM identifiers </a> in the <i>AWS Identity and Access Management User Guide</i> for more information. </p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>The domain creation status. <code>True</code> if the creation of a domain is complete. <code> False </code> if domain creation is still in progress. </p>
    pub created: std::option::Option<bool>,
    /// <p>The domain deletion status. <code>True</code> if a delete request has been received for the domain but resource cleanup is still in progress. <code>False</code> if the domain has not been deleted. Once domain deletion is complete, the status of the domain is no longer returned. </p>
    pub deleted: std::option::Option<bool>,
    /// <p>The domain endpoint that you use to submit index and search requests.</p>
    pub endpoint: std::option::Option<std::string::String>,
    /// <p>Map containing the domain endpoints used to submit index and search requests. Example <code>key, value</code>: <code>'vpc','vpc-endpoint-h2dsd34efgyghrtguk5gt6j2foh4.us-east-1.es.amazonaws.com'</code>. </p>
    pub endpoints:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The status of the domain configuration. <code>True</code> if Amazon OpenSearch Service is processing configuration changes. <code>False</code> if the configuration is active. </p>
    pub processing: std::option::Option<bool>,
    /// <p>The status of a domain version upgrade. <code>True</code> if Amazon OpenSearch Service is undergoing a version upgrade. <code>False</code> if the configuration is active. </p>
    pub upgrade_processing: std::option::Option<bool>,
    #[allow(missing_docs)] // documentation missing in model
    pub engine_version: std::option::Option<std::string::String>,
    /// <p>The type and number of instances in the domain.</p>
    pub cluster_config: std::option::Option<crate::model::ClusterConfig>,
    /// <p>The <code>EBSOptions</code> for the specified domain. </p>
    pub ebs_options: std::option::Option<crate::model::EbsOptions>,
    /// <p>IAM access policy as a JSON-formatted string.</p>
    pub access_policies: std::option::Option<std::string::String>,
    /// <p>The status of the <code>SnapshotOptions</code>. </p>
    pub snapshot_options: std::option::Option<crate::model::SnapshotOptions>,
    /// <p>The <code>VPCOptions</code> for the specified domain. For more information, see <a href="http://docs.aws.amazon.com/opensearch-service/latest/developerguide/vpc.html" target="_blank"> Launching your Amazon OpenSearch Service domains using a VPC</a>. </p>
    pub vpc_options: std::option::Option<crate::model::VpcDerivedInfo>,
    /// <p>The <code>CognitoOptions</code> for the specified domain. For more information, see <a href="http://docs.aws.amazon.com/opensearch-service/latest/developerguide/cognito-auth.html" target="_blank">Configuring Amazon Cognito authentication for OpenSearch Dashboards</a>. </p>
    pub cognito_options: std::option::Option<crate::model::CognitoOptions>,
    /// <p>The status of the <code>EncryptionAtRestOptions</code>. </p>
    pub encryption_at_rest_options: std::option::Option<crate::model::EncryptionAtRestOptions>,
    /// <p>The status of the <code>NodeToNodeEncryptionOptions</code>. </p>
    pub node_to_node_encryption_options:
        std::option::Option<crate::model::NodeToNodeEncryptionOptions>,
    /// <p>The status of the <code>AdvancedOptions</code>. </p>
    pub advanced_options:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>Log publishing options for the given domain.</p>
    pub log_publishing_options: std::option::Option<
        std::collections::HashMap<crate::model::LogType, crate::model::LogPublishingOption>,
    >,
    /// <p>The current status of the domain's service software.</p>
    pub service_software_options: std::option::Option<crate::model::ServiceSoftwareOptions>,
    /// <p>The current status of the domain's endpoint options.</p>
    pub domain_endpoint_options: std::option::Option<crate::model::DomainEndpointOptions>,
    /// <p>The current status of the domain's advanced security options.</p>
    pub advanced_security_options: std::option::Option<crate::model::AdvancedSecurityOptions>,
    /// <p>The current status of the domain's Auto-Tune options.</p>
    pub auto_tune_options: std::option::Option<crate::model::AutoTuneOptionsOutput>,
    /// <p>Specifies change details of the domain configuration change.</p>
    pub change_progress_details: std::option::Option<crate::model::ChangeProgressDetails>,
}
impl DomainStatus {
    /// <p>The unique identifier for the specified domain.</p>
    pub fn domain_id(&self) -> std::option::Option<&str> {
        self.domain_id.as_deref()
    }
    /// <p>The name of a domain. Domain names are unique across the domains owned by an account within an AWS region. Domain names start with a letter or number and can contain the following characters: a-z (lowercase), 0-9, and - (hyphen). </p>
    pub fn domain_name(&self) -> std::option::Option<&str> {
        self.domain_name.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of a domain. See <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html" target="_blank">IAM identifiers </a> in the <i>AWS Identity and Access Management User Guide</i> for more information. </p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The domain creation status. <code>True</code> if the creation of a domain is complete. <code> False </code> if domain creation is still in progress. </p>
    pub fn created(&self) -> std::option::Option<bool> {
        self.created
    }
    /// <p>The domain deletion status. <code>True</code> if a delete request has been received for the domain but resource cleanup is still in progress. <code>False</code> if the domain has not been deleted. Once domain deletion is complete, the status of the domain is no longer returned. </p>
    pub fn deleted(&self) -> std::option::Option<bool> {
        self.deleted
    }
    /// <p>The domain endpoint that you use to submit index and search requests.</p>
    pub fn endpoint(&self) -> std::option::Option<&str> {
        self.endpoint.as_deref()
    }
    /// <p>Map containing the domain endpoints used to submit index and search requests. Example <code>key, value</code>: <code>'vpc','vpc-endpoint-h2dsd34efgyghrtguk5gt6j2foh4.us-east-1.es.amazonaws.com'</code>. </p>
    pub fn endpoints(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.endpoints.as_ref()
    }
    /// <p>The status of the domain configuration. <code>True</code> if Amazon OpenSearch Service is processing configuration changes. <code>False</code> if the configuration is active. </p>
    pub fn processing(&self) -> std::option::Option<bool> {
        self.processing
    }
    /// <p>The status of a domain version upgrade. <code>True</code> if Amazon OpenSearch Service is undergoing a version upgrade. <code>False</code> if the configuration is active. </p>
    pub fn upgrade_processing(&self) -> std::option::Option<bool> {
        self.upgrade_processing
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn engine_version(&self) -> std::option::Option<&str> {
        self.engine_version.as_deref()
    }
    /// <p>The type and number of instances in the domain.</p>
    pub fn cluster_config(&self) -> std::option::Option<&crate::model::ClusterConfig> {
        self.cluster_config.as_ref()
    }
    /// <p>The <code>EBSOptions</code> for the specified domain. </p>
    pub fn ebs_options(&self) -> std::option::Option<&crate::model::EbsOptions> {
        self.ebs_options.as_ref()
    }
    /// <p>IAM access policy as a JSON-formatted string.</p>
    pub fn access_policies(&self) -> std::option::Option<&str> {
        self.access_policies.as_deref()
    }
    /// <p>The status of the <code>SnapshotOptions</code>. </p>
    pub fn snapshot_options(&self) -> std::option::Option<&crate::model::SnapshotOptions> {
        self.snapshot_options.as_ref()
    }
    /// <p>The <code>VPCOptions</code> for the specified domain. For more information, see <a href="http://docs.aws.amazon.com/opensearch-service/latest/developerguide/vpc.html" target="_blank"> Launching your Amazon OpenSearch Service domains using a VPC</a>. </p>
    pub fn vpc_options(&self) -> std::option::Option<&crate::model::VpcDerivedInfo> {
        self.vpc_options.as_ref()
    }
    /// <p>The <code>CognitoOptions</code> for the specified domain. For more information, see <a href="http://docs.aws.amazon.com/opensearch-service/latest/developerguide/cognito-auth.html" target="_blank">Configuring Amazon Cognito authentication for OpenSearch Dashboards</a>. </p>
    pub fn cognito_options(&self) -> std::option::Option<&crate::model::CognitoOptions> {
        self.cognito_options.as_ref()
    }
    /// <p>The status of the <code>EncryptionAtRestOptions</code>. </p>
    pub fn encryption_at_rest_options(
        &self,
    ) -> std::option::Option<&crate::model::EncryptionAtRestOptions> {
        self.encryption_at_rest_options.as_ref()
    }
    /// <p>The status of the <code>NodeToNodeEncryptionOptions</code>. </p>
    pub fn node_to_node_encryption_options(
        &self,
    ) -> std::option::Option<&crate::model::NodeToNodeEncryptionOptions> {
        self.node_to_node_encryption_options.as_ref()
    }
    /// <p>The status of the <code>AdvancedOptions</code>. </p>
    pub fn advanced_options(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.advanced_options.as_ref()
    }
    /// <p>Log publishing options for the given domain.</p>
    pub fn log_publishing_options(
        &self,
    ) -> std::option::Option<
        &std::collections::HashMap<crate::model::LogType, crate::model::LogPublishingOption>,
    > {
        self.log_publishing_options.as_ref()
    }
    /// <p>The current status of the domain's service software.</p>
    pub fn service_software_options(
        &self,
    ) -> std::option::Option<&crate::model::ServiceSoftwareOptions> {
        self.service_software_options.as_ref()
    }
    /// <p>The current status of the domain's endpoint options.</p>
    pub fn domain_endpoint_options(
        &self,
    ) -> std::option::Option<&crate::model::DomainEndpointOptions> {
        self.domain_endpoint_options.as_ref()
    }
    /// <p>The current status of the domain's advanced security options.</p>
    pub fn advanced_security_options(
        &self,
    ) -> std::option::Option<&crate::model::AdvancedSecurityOptions> {
        self.advanced_security_options.as_ref()
    }
    /// <p>The current status of the domain's Auto-Tune options.</p>
    pub fn auto_tune_options(&self) -> std::option::Option<&crate::model::AutoTuneOptionsOutput> {
        self.auto_tune_options.as_ref()
    }
    /// <p>Specifies change details of the domain configuration change.</p>
    pub fn change_progress_details(
        &self,
    ) -> std::option::Option<&crate::model::ChangeProgressDetails> {
        self.change_progress_details.as_ref()
    }
}
impl std::fmt::Debug for DomainStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DomainStatus");
        formatter.field("domain_id", &self.domain_id);
        formatter.field("domain_name", &self.domain_name);
        formatter.field("arn", &self.arn);
        formatter.field("created", &self.created);
        formatter.field("deleted", &self.deleted);
        formatter.field("endpoint", &self.endpoint);
        formatter.field("endpoints", &self.endpoints);
        formatter.field("processing", &self.processing);
        formatter.field("upgrade_processing", &self.upgrade_processing);
        formatter.field("engine_version", &self.engine_version);
        formatter.field("cluster_config", &self.cluster_config);
        formatter.field("ebs_options", &self.ebs_options);
        formatter.field("access_policies", &self.access_policies);
        formatter.field("snapshot_options", &self.snapshot_options);
        formatter.field("vpc_options", &self.vpc_options);
        formatter.field("cognito_options", &self.cognito_options);
        formatter.field(
            "encryption_at_rest_options",
            &self.encryption_at_rest_options,
        );
        formatter.field(
            "node_to_node_encryption_options",
            &self.node_to_node_encryption_options,
        );
        formatter.field("advanced_options", &self.advanced_options);
        formatter.field("log_publishing_options", &self.log_publishing_options);
        formatter.field("service_software_options", &self.service_software_options);
        formatter.field("domain_endpoint_options", &self.domain_endpoint_options);
        formatter.field("advanced_security_options", &self.advanced_security_options);
        formatter.field("auto_tune_options", &self.auto_tune_options);
        formatter.field("change_progress_details", &self.change_progress_details);
        formatter.finish()
    }
}
/// See [`DomainStatus`](crate::model::DomainStatus)
pub mod domain_status {

    /// A builder for [`DomainStatus`](crate::model::DomainStatus)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain_id: std::option::Option<std::string::String>,
        pub(crate) domain_name: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) created: std::option::Option<bool>,
        pub(crate) deleted: std::option::Option<bool>,
        pub(crate) endpoint: std::option::Option<std::string::String>,
        pub(crate) endpoints: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) processing: std::option::Option<bool>,
        pub(crate) upgrade_processing: std::option::Option<bool>,
        pub(crate) engine_version: std::option::Option<std::string::String>,
        pub(crate) cluster_config: std::option::Option<crate::model::ClusterConfig>,
        pub(crate) ebs_options: std::option::Option<crate::model::EbsOptions>,
        pub(crate) access_policies: std::option::Option<std::string::String>,
        pub(crate) snapshot_options: std::option::Option<crate::model::SnapshotOptions>,
        pub(crate) vpc_options: std::option::Option<crate::model::VpcDerivedInfo>,
        pub(crate) cognito_options: std::option::Option<crate::model::CognitoOptions>,
        pub(crate) encryption_at_rest_options:
            std::option::Option<crate::model::EncryptionAtRestOptions>,
        pub(crate) node_to_node_encryption_options:
            std::option::Option<crate::model::NodeToNodeEncryptionOptions>,
        pub(crate) advanced_options: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) log_publishing_options: std::option::Option<
            std::collections::HashMap<crate::model::LogType, crate::model::LogPublishingOption>,
        >,
        pub(crate) service_software_options:
            std::option::Option<crate::model::ServiceSoftwareOptions>,
        pub(crate) domain_endpoint_options:
            std::option::Option<crate::model::DomainEndpointOptions>,
        pub(crate) advanced_security_options:
            std::option::Option<crate::model::AdvancedSecurityOptions>,
        pub(crate) auto_tune_options: std::option::Option<crate::model::AutoTuneOptionsOutput>,
        pub(crate) change_progress_details:
            std::option::Option<crate::model::ChangeProgressDetails>,
    }
    impl Builder {
        /// <p>The unique identifier for the specified domain.</p>
        pub fn domain_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_id = Some(input.into());
            self
        }
        /// <p>The unique identifier for the specified domain.</p>
        pub fn set_domain_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_id = input;
            self
        }
        /// <p>The name of a domain. Domain names are unique across the domains owned by an account within an AWS region. Domain names start with a letter or number and can contain the following characters: a-z (lowercase), 0-9, and - (hyphen). </p>
        pub fn domain_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_name = Some(input.into());
            self
        }
        /// <p>The name of a domain. Domain names are unique across the domains owned by an account within an AWS region. Domain names start with a letter or number and can contain the following characters: a-z (lowercase), 0-9, and - (hyphen). </p>
        pub fn set_domain_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of a domain. See <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html" target="_blank">IAM identifiers </a> in the <i>AWS Identity and Access Management User Guide</i> for more information. </p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of a domain. See <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html" target="_blank">IAM identifiers </a> in the <i>AWS Identity and Access Management User Guide</i> for more information. </p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The domain creation status. <code>True</code> if the creation of a domain is complete. <code> False </code> if domain creation is still in progress. </p>
        pub fn created(mut self, input: bool) -> Self {
            self.created = Some(input);
            self
        }
        /// <p>The domain creation status. <code>True</code> if the creation of a domain is complete. <code> False </code> if domain creation is still in progress. </p>
        pub fn set_created(mut self, input: std::option::Option<bool>) -> Self {
            self.created = input;
            self
        }
        /// <p>The domain deletion status. <code>True</code> if a delete request has been received for the domain but resource cleanup is still in progress. <code>False</code> if the domain has not been deleted. Once domain deletion is complete, the status of the domain is no longer returned. </p>
        pub fn deleted(mut self, input: bool) -> Self {
            self.deleted = Some(input);
            self
        }
        /// <p>The domain deletion status. <code>True</code> if a delete request has been received for the domain but resource cleanup is still in progress. <code>False</code> if the domain has not been deleted. Once domain deletion is complete, the status of the domain is no longer returned. </p>
        pub fn set_deleted(mut self, input: std::option::Option<bool>) -> Self {
            self.deleted = input;
            self
        }
        /// <p>The domain endpoint that you use to submit index and search requests.</p>
        pub fn endpoint(mut self, input: impl Into<std::string::String>) -> Self {
            self.endpoint = Some(input.into());
            self
        }
        /// <p>The domain endpoint that you use to submit index and search requests.</p>
        pub fn set_endpoint(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.endpoint = input;
            self
        }
        /// Adds a key-value pair to `endpoints`.
        ///
        /// To override the contents of this collection use [`set_endpoints`](Self::set_endpoints).
        ///
        /// <p>Map containing the domain endpoints used to submit index and search requests. Example <code>key, value</code>: <code>'vpc','vpc-endpoint-h2dsd34efgyghrtguk5gt6j2foh4.us-east-1.es.amazonaws.com'</code>. </p>
        pub fn endpoints(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.endpoints.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.endpoints = Some(hash_map);
            self
        }
        /// <p>Map containing the domain endpoints used to submit index and search requests. Example <code>key, value</code>: <code>'vpc','vpc-endpoint-h2dsd34efgyghrtguk5gt6j2foh4.us-east-1.es.amazonaws.com'</code>. </p>
        pub fn set_endpoints(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.endpoints = input;
            self
        }
        /// <p>The status of the domain configuration. <code>True</code> if Amazon OpenSearch Service is processing configuration changes. <code>False</code> if the configuration is active. </p>
        pub fn processing(mut self, input: bool) -> Self {
            self.processing = Some(input);
            self
        }
        /// <p>The status of the domain configuration. <code>True</code> if Amazon OpenSearch Service is processing configuration changes. <code>False</code> if the configuration is active. </p>
        pub fn set_processing(mut self, input: std::option::Option<bool>) -> Self {
            self.processing = input;
            self
        }
        /// <p>The status of a domain version upgrade. <code>True</code> if Amazon OpenSearch Service is undergoing a version upgrade. <code>False</code> if the configuration is active. </p>
        pub fn upgrade_processing(mut self, input: bool) -> Self {
            self.upgrade_processing = Some(input);
            self
        }
        /// <p>The status of a domain version upgrade. <code>True</code> if Amazon OpenSearch Service is undergoing a version upgrade. <code>False</code> if the configuration is active. </p>
        pub fn set_upgrade_processing(mut self, input: std::option::Option<bool>) -> Self {
            self.upgrade_processing = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn engine_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.engine_version = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_engine_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.engine_version = input;
            self
        }
        /// <p>The type and number of instances in the domain.</p>
        pub fn cluster_config(mut self, input: crate::model::ClusterConfig) -> Self {
            self.cluster_config = Some(input);
            self
        }
        /// <p>The type and number of instances in the domain.</p>
        pub fn set_cluster_config(
            mut self,
            input: std::option::Option<crate::model::ClusterConfig>,
        ) -> Self {
            self.cluster_config = input;
            self
        }
        /// <p>The <code>EBSOptions</code> for the specified domain. </p>
        pub fn ebs_options(mut self, input: crate::model::EbsOptions) -> Self {
            self.ebs_options = Some(input);
            self
        }
        /// <p>The <code>EBSOptions</code> for the specified domain. </p>
        pub fn set_ebs_options(
            mut self,
            input: std::option::Option<crate::model::EbsOptions>,
        ) -> Self {
            self.ebs_options = input;
            self
        }
        /// <p>IAM access policy as a JSON-formatted string.</p>
        pub fn access_policies(mut self, input: impl Into<std::string::String>) -> Self {
            self.access_policies = Some(input.into());
            self
        }
        /// <p>IAM access policy as a JSON-formatted string.</p>
        pub fn set_access_policies(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.access_policies = input;
            self
        }
        /// <p>The status of the <code>SnapshotOptions</code>. </p>
        pub fn snapshot_options(mut self, input: crate::model::SnapshotOptions) -> Self {
            self.snapshot_options = Some(input);
            self
        }
        /// <p>The status of the <code>SnapshotOptions</code>. </p>
        pub fn set_snapshot_options(
            mut self,
            input: std::option::Option<crate::model::SnapshotOptions>,
        ) -> Self {
            self.snapshot_options = input;
            self
        }
        /// <p>The <code>VPCOptions</code> for the specified domain. For more information, see <a href="http://docs.aws.amazon.com/opensearch-service/latest/developerguide/vpc.html" target="_blank"> Launching your Amazon OpenSearch Service domains using a VPC</a>. </p>
        pub fn vpc_options(mut self, input: crate::model::VpcDerivedInfo) -> Self {
            self.vpc_options = Some(input);
            self
        }
        /// <p>The <code>VPCOptions</code> for the specified domain. For more information, see <a href="http://docs.aws.amazon.com/opensearch-service/latest/developerguide/vpc.html" target="_blank"> Launching your Amazon OpenSearch Service domains using a VPC</a>. </p>
        pub fn set_vpc_options(
            mut self,
            input: std::option::Option<crate::model::VpcDerivedInfo>,
        ) -> Self {
            self.vpc_options = input;
            self
        }
        /// <p>The <code>CognitoOptions</code> for the specified domain. For more information, see <a href="http://docs.aws.amazon.com/opensearch-service/latest/developerguide/cognito-auth.html" target="_blank">Configuring Amazon Cognito authentication for OpenSearch Dashboards</a>. </p>
        pub fn cognito_options(mut self, input: crate::model::CognitoOptions) -> Self {
            self.cognito_options = Some(input);
            self
        }
        /// <p>The <code>CognitoOptions</code> for the specified domain. For more information, see <a href="http://docs.aws.amazon.com/opensearch-service/latest/developerguide/cognito-auth.html" target="_blank">Configuring Amazon Cognito authentication for OpenSearch Dashboards</a>. </p>
        pub fn set_cognito_options(
            mut self,
            input: std::option::Option<crate::model::CognitoOptions>,
        ) -> Self {
            self.cognito_options = input;
            self
        }
        /// <p>The status of the <code>EncryptionAtRestOptions</code>. </p>
        pub fn encryption_at_rest_options(
            mut self,
            input: crate::model::EncryptionAtRestOptions,
        ) -> Self {
            self.encryption_at_rest_options = Some(input);
            self
        }
        /// <p>The status of the <code>EncryptionAtRestOptions</code>. </p>
        pub fn set_encryption_at_rest_options(
            mut self,
            input: std::option::Option<crate::model::EncryptionAtRestOptions>,
        ) -> Self {
            self.encryption_at_rest_options = input;
            self
        }
        /// <p>The status of the <code>NodeToNodeEncryptionOptions</code>. </p>
        pub fn node_to_node_encryption_options(
            mut self,
            input: crate::model::NodeToNodeEncryptionOptions,
        ) -> Self {
            self.node_to_node_encryption_options = Some(input);
            self
        }
        /// <p>The status of the <code>NodeToNodeEncryptionOptions</code>. </p>
        pub fn set_node_to_node_encryption_options(
            mut self,
            input: std::option::Option<crate::model::NodeToNodeEncryptionOptions>,
        ) -> Self {
            self.node_to_node_encryption_options = input;
            self
        }
        /// Adds a key-value pair to `advanced_options`.
        ///
        /// To override the contents of this collection use [`set_advanced_options`](Self::set_advanced_options).
        ///
        /// <p>The status of the <code>AdvancedOptions</code>. </p>
        pub fn advanced_options(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.advanced_options.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.advanced_options = Some(hash_map);
            self
        }
        /// <p>The status of the <code>AdvancedOptions</code>. </p>
        pub fn set_advanced_options(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.advanced_options = input;
            self
        }
        /// Adds a key-value pair to `log_publishing_options`.
        ///
        /// To override the contents of this collection use [`set_log_publishing_options`](Self::set_log_publishing_options).
        ///
        /// <p>Log publishing options for the given domain.</p>
        pub fn log_publishing_options(
            mut self,
            k: crate::model::LogType,
            v: crate::model::LogPublishingOption,
        ) -> Self {
            let mut hash_map = self.log_publishing_options.unwrap_or_default();
            hash_map.insert(k, v);
            self.log_publishing_options = Some(hash_map);
            self
        }
        /// <p>Log publishing options for the given domain.</p>
        pub fn set_log_publishing_options(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<crate::model::LogType, crate::model::LogPublishingOption>,
            >,
        ) -> Self {
            self.log_publishing_options = input;
            self
        }
        /// <p>The current status of the domain's service software.</p>
        pub fn service_software_options(
            mut self,
            input: crate::model::ServiceSoftwareOptions,
        ) -> Self {
            self.service_software_options = Some(input);
            self
        }
        /// <p>The current status of the domain's service software.</p>
        pub fn set_service_software_options(
            mut self,
            input: std::option::Option<crate::model::ServiceSoftwareOptions>,
        ) -> Self {
            self.service_software_options = input;
            self
        }
        /// <p>The current status of the domain's endpoint options.</p>
        pub fn domain_endpoint_options(
            mut self,
            input: crate::model::DomainEndpointOptions,
        ) -> Self {
            self.domain_endpoint_options = Some(input);
            self
        }
        /// <p>The current status of the domain's endpoint options.</p>
        pub fn set_domain_endpoint_options(
            mut self,
            input: std::option::Option<crate::model::DomainEndpointOptions>,
        ) -> Self {
            self.domain_endpoint_options = input;
            self
        }
        /// <p>The current status of the domain's advanced security options.</p>
        pub fn advanced_security_options(
            mut self,
            input: crate::model::AdvancedSecurityOptions,
        ) -> Self {
            self.advanced_security_options = Some(input);
            self
        }
        /// <p>The current status of the domain's advanced security options.</p>
        pub fn set_advanced_security_options(
            mut self,
            input: std::option::Option<crate::model::AdvancedSecurityOptions>,
        ) -> Self {
            self.advanced_security_options = input;
            self
        }
        /// <p>The current status of the domain's Auto-Tune options.</p>
        pub fn auto_tune_options(mut self, input: crate::model::AutoTuneOptionsOutput) -> Self {
            self.auto_tune_options = Some(input);
            self
        }
        /// <p>The current status of the domain's Auto-Tune options.</p>
        pub fn set_auto_tune_options(
            mut self,
            input: std::option::Option<crate::model::AutoTuneOptionsOutput>,
        ) -> Self {
            self.auto_tune_options = input;
            self
        }
        /// <p>Specifies change details of the domain configuration change.</p>
        pub fn change_progress_details(
            mut self,
            input: crate::model::ChangeProgressDetails,
        ) -> Self {
            self.change_progress_details = Some(input);
            self
        }
        /// <p>Specifies change details of the domain configuration change.</p>
        pub fn set_change_progress_details(
            mut self,
            input: std::option::Option<crate::model::ChangeProgressDetails>,
        ) -> Self {
            self.change_progress_details = input;
            self
        }
        /// Consumes the builder and constructs a [`DomainStatus`](crate::model::DomainStatus)
        pub fn build(self) -> crate::model::DomainStatus {
            crate::model::DomainStatus {
                domain_id: self.domain_id,
                domain_name: self.domain_name,
                arn: self.arn,
                created: self.created,
                deleted: self.deleted,
                endpoint: self.endpoint,
                endpoints: self.endpoints,
                processing: self.processing,
                upgrade_processing: self.upgrade_processing,
                engine_version: self.engine_version,
                cluster_config: self.cluster_config,
                ebs_options: self.ebs_options,
                access_policies: self.access_policies,
                snapshot_options: self.snapshot_options,
                vpc_options: self.vpc_options,
                cognito_options: self.cognito_options,
                encryption_at_rest_options: self.encryption_at_rest_options,
                node_to_node_encryption_options: self.node_to_node_encryption_options,
                advanced_options: self.advanced_options,
                log_publishing_options: self.log_publishing_options,
                service_software_options: self.service_software_options,
                domain_endpoint_options: self.domain_endpoint_options,
                advanced_security_options: self.advanced_security_options,
                auto_tune_options: self.auto_tune_options,
                change_progress_details: self.change_progress_details,
            }
        }
    }
}
impl DomainStatus {
    /// Creates a new builder-style object to manufacture [`DomainStatus`](crate::model::DomainStatus)
    pub fn builder() -> crate::model::domain_status::Builder {
        crate::model::domain_status::Builder::default()
    }
}

/// <p>The Auto-Tune options: the Auto-Tune desired state for the domain and list of maintenance schedules. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AutoTuneOptionsOutput {
    /// <p>The <code>AutoTuneState</code> for the domain. </p>
    pub state: std::option::Option<crate::model::AutoTuneState>,
    /// <p>The error message while enabling or disabling Auto-Tune.</p>
    pub error_message: std::option::Option<std::string::String>,
}
impl AutoTuneOptionsOutput {
    /// <p>The <code>AutoTuneState</code> for the domain. </p>
    pub fn state(&self) -> std::option::Option<&crate::model::AutoTuneState> {
        self.state.as_ref()
    }
    /// <p>The error message while enabling or disabling Auto-Tune.</p>
    pub fn error_message(&self) -> std::option::Option<&str> {
        self.error_message.as_deref()
    }
}
impl std::fmt::Debug for AutoTuneOptionsOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AutoTuneOptionsOutput");
        formatter.field("state", &self.state);
        formatter.field("error_message", &self.error_message);
        formatter.finish()
    }
}
/// See [`AutoTuneOptionsOutput`](crate::model::AutoTuneOptionsOutput)
pub mod auto_tune_options_output {

    /// A builder for [`AutoTuneOptionsOutput`](crate::model::AutoTuneOptionsOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) state: std::option::Option<crate::model::AutoTuneState>,
        pub(crate) error_message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The <code>AutoTuneState</code> for the domain. </p>
        pub fn state(mut self, input: crate::model::AutoTuneState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The <code>AutoTuneState</code> for the domain. </p>
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::AutoTuneState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// <p>The error message while enabling or disabling Auto-Tune.</p>
        pub fn error_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_message = Some(input.into());
            self
        }
        /// <p>The error message while enabling or disabling Auto-Tune.</p>
        pub fn set_error_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.error_message = input;
            self
        }
        /// Consumes the builder and constructs a [`AutoTuneOptionsOutput`](crate::model::AutoTuneOptionsOutput)
        pub fn build(self) -> crate::model::AutoTuneOptionsOutput {
            crate::model::AutoTuneOptionsOutput {
                state: self.state,
                error_message: self.error_message,
            }
        }
    }
}
impl AutoTuneOptionsOutput {
    /// Creates a new builder-style object to manufacture [`AutoTuneOptionsOutput`](crate::model::AutoTuneOptionsOutput)
    pub fn builder() -> crate::model::auto_tune_options_output::Builder {
        crate::model::auto_tune_options_output::Builder::default()
    }
}

/// <p>The progress details of a specific domain configuration change.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ChangeProgressStatusDetails {
    /// <p>The unique change identifier associated with a specific domain configuration change.</p>
    pub change_id: std::option::Option<std::string::String>,
    /// <p>The time at which the configuration change is made on the domain.</p>
    pub start_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The overall status of the domain configuration change. This field can take the following values: <code>PENDING</code>, <code>PROCESSING</code>, <code>COMPLETED</code> and <code>FAILED</code></p>
    pub status: std::option::Option<crate::model::OverallChangeStatus>,
    /// <p>The list of properties involved in the domain configuration change that are still in pending.</p>
    pub pending_properties: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The list of properties involved in the domain configuration change that are completed.</p>
    pub completed_properties: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The total number of stages required for the configuration change.</p>
    pub total_number_of_stages: i32,
    /// <p>The specific stages that the domain is going through to perform the configuration change.</p>
    pub change_progress_stages:
        std::option::Option<std::vec::Vec<crate::model::ChangeProgressStage>>,
}
impl ChangeProgressStatusDetails {
    /// <p>The unique change identifier associated with a specific domain configuration change.</p>
    pub fn change_id(&self) -> std::option::Option<&str> {
        self.change_id.as_deref()
    }
    /// <p>The time at which the configuration change is made on the domain.</p>
    pub fn start_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.start_time.as_ref()
    }
    /// <p>The overall status of the domain configuration change. This field can take the following values: <code>PENDING</code>, <code>PROCESSING</code>, <code>COMPLETED</code> and <code>FAILED</code></p>
    pub fn status(&self) -> std::option::Option<&crate::model::OverallChangeStatus> {
        self.status.as_ref()
    }
    /// <p>The list of properties involved in the domain configuration change that are still in pending.</p>
    pub fn pending_properties(&self) -> std::option::Option<&[std::string::String]> {
        self.pending_properties.as_deref()
    }
    /// <p>The list of properties involved in the domain configuration change that are completed.</p>
    pub fn completed_properties(&self) -> std::option::Option<&[std::string::String]> {
        self.completed_properties.as_deref()
    }
    /// <p>The total number of stages required for the configuration change.</p>
    pub fn total_number_of_stages(&self) -> i32 {
        self.total_number_of_stages
    }
    /// <p>The specific stages that the domain is going through to perform the configuration change.</p>
    pub fn change_progress_stages(
        &self,
    ) -> std::option::Option<&[crate::model::ChangeProgressStage]> {
        self.change_progress_stages.as_deref()
    }
}
impl std::fmt::Debug for ChangeProgressStatusDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ChangeProgressStatusDetails");
        formatter.field("change_id", &self.change_id);
        formatter.field("start_time", &self.start_time);
        formatter.field("status", &self.status);
        formatter.field("pending_properties", &self.pending_properties);
        formatter.field("completed_properties", &self.completed_properties);
        formatter.field("total_number_of_stages", &self.total_number_of_stages);
        formatter.field("change_progress_stages", &self.change_progress_stages);
        formatter.finish()
    }
}
/// See [`ChangeProgressStatusDetails`](crate::model::ChangeProgressStatusDetails)
pub mod change_progress_status_details {

    /// A builder for [`ChangeProgressStatusDetails`](crate::model::ChangeProgressStatusDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) change_id: std::option::Option<std::string::String>,
        pub(crate) start_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) status: std::option::Option<crate::model::OverallChangeStatus>,
        pub(crate) pending_properties: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) completed_properties: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) total_number_of_stages: std::option::Option<i32>,
        pub(crate) change_progress_stages:
            std::option::Option<std::vec::Vec<crate::model::ChangeProgressStage>>,
    }
    impl Builder {
        /// <p>The unique change identifier associated with a specific domain configuration change.</p>
        pub fn change_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.change_id = Some(input.into());
            self
        }
        /// <p>The unique change identifier associated with a specific domain configuration change.</p>
        pub fn set_change_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.change_id = input;
            self
        }
        /// <p>The time at which the configuration change is made on the domain.</p>
        pub fn start_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.start_time = Some(input);
            self
        }
        /// <p>The time at which the configuration change is made on the domain.</p>
        pub fn set_start_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.start_time = input;
            self
        }
        /// <p>The overall status of the domain configuration change. This field can take the following values: <code>PENDING</code>, <code>PROCESSING</code>, <code>COMPLETED</code> and <code>FAILED</code></p>
        pub fn status(mut self, input: crate::model::OverallChangeStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The overall status of the domain configuration change. This field can take the following values: <code>PENDING</code>, <code>PROCESSING</code>, <code>COMPLETED</code> and <code>FAILED</code></p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::OverallChangeStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// Appends an item to `pending_properties`.
        ///
        /// To override the contents of this collection use [`set_pending_properties`](Self::set_pending_properties).
        ///
        /// <p>The list of properties involved in the domain configuration change that are still in pending.</p>
        pub fn pending_properties(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.pending_properties.unwrap_or_default();
            v.push(input.into());
            self.pending_properties = Some(v);
            self
        }
        /// <p>The list of properties involved in the domain configuration change that are still in pending.</p>
        pub fn set_pending_properties(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.pending_properties = input;
            self
        }
        /// Appends an item to `completed_properties`.
        ///
        /// To override the contents of this collection use [`set_completed_properties`](Self::set_completed_properties).
        ///
        /// <p>The list of properties involved in the domain configuration change that are completed.</p>
        pub fn completed_properties(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.completed_properties.unwrap_or_default();
            v.push(input.into());
            self.completed_properties = Some(v);
            self
        }
        /// <p>The list of properties involved in the domain configuration change that are completed.</p>
        pub fn set_completed_properties(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.completed_properties = input;
            self
        }
        /// <p>The total number of stages required for the configuration change.</p>
        pub fn total_number_of_stages(mut self, input: i32) -> Self {
            self.total_number_of_stages = Some(input);
            self
        }
        /// <p>The total number of stages required for the configuration change.</p>
        pub fn set_total_number_of_stages(mut self, input: std::option::Option<i32>) -> Self {
            self.total_number_of_stages = input;
            self
        }
        /// Appends an item to `change_progress_stages`.
        ///
        /// To override the contents of this collection use [`set_change_progress_stages`](Self::set_change_progress_stages).
        ///
        /// <p>The specific stages that the domain is going through to perform the configuration change.</p>
        pub fn change_progress_stages(mut self, input: crate::model::ChangeProgressStage) -> Self {
            let mut v = self.change_progress_stages.unwrap_or_default();
            v.push(input);
            self.change_progress_stages = Some(v);
            self
        }
        /// <p>The specific stages that the domain is going through to perform the configuration change.</p>
        pub fn set_change_progress_stages(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ChangeProgressStage>>,
        ) -> Self {
            self.change_progress_stages = input;
            self
        }
        /// Consumes the builder and constructs a [`ChangeProgressStatusDetails`](crate::model::ChangeProgressStatusDetails)
        pub fn build(self) -> crate::model::ChangeProgressStatusDetails {
            crate::model::ChangeProgressStatusDetails {
                change_id: self.change_id,
                start_time: self.start_time,
                status: self.status,
                pending_properties: self.pending_properties,
                completed_properties: self.completed_properties,
                total_number_of_stages: self.total_number_of_stages.unwrap_or_default(),
                change_progress_stages: self.change_progress_stages,
            }
        }
    }
}
impl ChangeProgressStatusDetails {
    /// Creates a new builder-style object to manufacture [`ChangeProgressStatusDetails`](crate::model::ChangeProgressStatusDetails)
    pub fn builder() -> crate::model::change_progress_status_details::Builder {
        crate::model::change_progress_status_details::Builder::default()
    }
}

/// <p>A progress stage details of a specific domain configuration change.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ChangeProgressStage {
    /// <p>The name of the specific progress stage.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The overall status of a specific progress stage.</p>
    pub status: std::option::Option<std::string::String>,
    /// <p>The description of the progress stage.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>The last updated timestamp of the progress stage.</p>
    pub last_updated: std::option::Option<aws_smithy_types::DateTime>,
}
impl ChangeProgressStage {
    /// <p>The name of the specific progress stage.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The overall status of a specific progress stage.</p>
    pub fn status(&self) -> std::option::Option<&str> {
        self.status.as_deref()
    }
    /// <p>The description of the progress stage.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The last updated timestamp of the progress stage.</p>
    pub fn last_updated(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_updated.as_ref()
    }
}
impl std::fmt::Debug for ChangeProgressStage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ChangeProgressStage");
        formatter.field("name", &self.name);
        formatter.field("status", &self.status);
        formatter.field("description", &self.description);
        formatter.field("last_updated", &self.last_updated);
        formatter.finish()
    }
}
/// See [`ChangeProgressStage`](crate::model::ChangeProgressStage)
pub mod change_progress_stage {

    /// A builder for [`ChangeProgressStage`](crate::model::ChangeProgressStage)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) last_updated: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The name of the specific progress stage.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the specific progress stage.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The overall status of a specific progress stage.</p>
        pub fn status(mut self, input: impl Into<std::string::String>) -> Self {
            self.status = Some(input.into());
            self
        }
        /// <p>The overall status of a specific progress stage.</p>
        pub fn set_status(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.status = input;
            self
        }
        /// <p>The description of the progress stage.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the progress stage.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The last updated timestamp of the progress stage.</p>
        pub fn last_updated(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_updated = Some(input);
            self
        }
        /// <p>The last updated timestamp of the progress stage.</p>
        pub fn set_last_updated(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_updated = input;
            self
        }
        /// Consumes the builder and constructs a [`ChangeProgressStage`](crate::model::ChangeProgressStage)
        pub fn build(self) -> crate::model::ChangeProgressStage {
            crate::model::ChangeProgressStage {
                name: self.name,
                status: self.status,
                description: self.description,
                last_updated: self.last_updated,
            }
        }
    }
}
impl ChangeProgressStage {
    /// Creates a new builder-style object to manufacture [`ChangeProgressStage`](crate::model::ChangeProgressStage)
    pub fn builder() -> crate::model::change_progress_stage::Builder {
        crate::model::change_progress_stage::Builder::default()
    }
}

/// <p>The overall status value of the domain configuration change.</p>
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum OverallChangeStatus {
    #[allow(missing_docs)] // documentation missing in model
    Completed,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    Pending,
    #[allow(missing_docs)] // documentation missing in model
    Processing,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for OverallChangeStatus {
    fn from(s: &str) -> Self {
        match s {
            "COMPLETED" => OverallChangeStatus::Completed,
            "FAILED" => OverallChangeStatus::Failed,
            "PENDING" => OverallChangeStatus::Pending,
            "PROCESSING" => OverallChangeStatus::Processing,
            other => OverallChangeStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for OverallChangeStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(OverallChangeStatus::from(s))
    }
}
impl OverallChangeStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            OverallChangeStatus::Completed => "COMPLETED",
            OverallChangeStatus::Failed => "FAILED",
            OverallChangeStatus::Pending => "PENDING",
            OverallChangeStatus::Processing => "PROCESSING",
            OverallChangeStatus::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["COMPLETED", "FAILED", "PENDING", "PROCESSING"]
    }
}
impl AsRef<str> for OverallChangeStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Specifies the Auto-Tune type and Auto-Tune action details.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AutoTune {
    /// <p>Specifies the Auto-Tune type. Valid value is SCHEDULED_ACTION.</p>
    pub auto_tune_type: std::option::Option<crate::model::AutoTuneType>,
    /// <p>Specifies details about the Auto-Tune action. See <a href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/auto-tune.html" target="_blank"> Auto-Tune for Amazon OpenSearch Service </a> for more information. </p>
    pub auto_tune_details: std::option::Option<crate::model::AutoTuneDetails>,
}
impl AutoTune {
    /// <p>Specifies the Auto-Tune type. Valid value is SCHEDULED_ACTION.</p>
    pub fn auto_tune_type(&self) -> std::option::Option<&crate::model::AutoTuneType> {
        self.auto_tune_type.as_ref()
    }
    /// <p>Specifies details about the Auto-Tune action. See <a href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/auto-tune.html" target="_blank"> Auto-Tune for Amazon OpenSearch Service </a> for more information. </p>
    pub fn auto_tune_details(&self) -> std::option::Option<&crate::model::AutoTuneDetails> {
        self.auto_tune_details.as_ref()
    }
}
impl std::fmt::Debug for AutoTune {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AutoTune");
        formatter.field("auto_tune_type", &self.auto_tune_type);
        formatter.field("auto_tune_details", &self.auto_tune_details);
        formatter.finish()
    }
}
/// See [`AutoTune`](crate::model::AutoTune)
pub mod auto_tune {

    /// A builder for [`AutoTune`](crate::model::AutoTune)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) auto_tune_type: std::option::Option<crate::model::AutoTuneType>,
        pub(crate) auto_tune_details: std::option::Option<crate::model::AutoTuneDetails>,
    }
    impl Builder {
        /// <p>Specifies the Auto-Tune type. Valid value is SCHEDULED_ACTION.</p>
        pub fn auto_tune_type(mut self, input: crate::model::AutoTuneType) -> Self {
            self.auto_tune_type = Some(input);
            self
        }
        /// <p>Specifies the Auto-Tune type. Valid value is SCHEDULED_ACTION.</p>
        pub fn set_auto_tune_type(
            mut self,
            input: std::option::Option<crate::model::AutoTuneType>,
        ) -> Self {
            self.auto_tune_type = input;
            self
        }
        /// <p>Specifies details about the Auto-Tune action. See <a href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/auto-tune.html" target="_blank"> Auto-Tune for Amazon OpenSearch Service </a> for more information. </p>
        pub fn auto_tune_details(mut self, input: crate::model::AutoTuneDetails) -> Self {
            self.auto_tune_details = Some(input);
            self
        }
        /// <p>Specifies details about the Auto-Tune action. See <a href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/auto-tune.html" target="_blank"> Auto-Tune for Amazon OpenSearch Service </a> for more information. </p>
        pub fn set_auto_tune_details(
            mut self,
            input: std::option::Option<crate::model::AutoTuneDetails>,
        ) -> Self {
            self.auto_tune_details = input;
            self
        }
        /// Consumes the builder and constructs a [`AutoTune`](crate::model::AutoTune)
        pub fn build(self) -> crate::model::AutoTune {
            crate::model::AutoTune {
                auto_tune_type: self.auto_tune_type,
                auto_tune_details: self.auto_tune_details,
            }
        }
    }
}
impl AutoTune {
    /// Creates a new builder-style object to manufacture [`AutoTune`](crate::model::AutoTune)
    pub fn builder() -> crate::model::auto_tune::Builder {
        crate::model::auto_tune::Builder::default()
    }
}

/// <p>Specifies details about the Auto-Tune action. See <a href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/auto-tune.html" target="_blank"> Auto-Tune for Amazon OpenSearch Service </a> for more information. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AutoTuneDetails {
    /// <p>Specifies details about the scheduled Auto-Tune action. See <a href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/auto-tune.html" target="_blank"> Auto-Tune for Amazon OpenSearch Service </a> for more information. </p>
    pub scheduled_auto_tune_details: std::option::Option<crate::model::ScheduledAutoTuneDetails>,
}
impl AutoTuneDetails {
    /// <p>Specifies details about the scheduled Auto-Tune action. See <a href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/auto-tune.html" target="_blank"> Auto-Tune for Amazon OpenSearch Service </a> for more information. </p>
    pub fn scheduled_auto_tune_details(
        &self,
    ) -> std::option::Option<&crate::model::ScheduledAutoTuneDetails> {
        self.scheduled_auto_tune_details.as_ref()
    }
}
impl std::fmt::Debug for AutoTuneDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AutoTuneDetails");
        formatter.field(
            "scheduled_auto_tune_details",
            &self.scheduled_auto_tune_details,
        );
        formatter.finish()
    }
}
/// See [`AutoTuneDetails`](crate::model::AutoTuneDetails)
pub mod auto_tune_details {

    /// A builder for [`AutoTuneDetails`](crate::model::AutoTuneDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) scheduled_auto_tune_details:
            std::option::Option<crate::model::ScheduledAutoTuneDetails>,
    }
    impl Builder {
        /// <p>Specifies details about the scheduled Auto-Tune action. See <a href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/auto-tune.html" target="_blank"> Auto-Tune for Amazon OpenSearch Service </a> for more information. </p>
        pub fn scheduled_auto_tune_details(
            mut self,
            input: crate::model::ScheduledAutoTuneDetails,
        ) -> Self {
            self.scheduled_auto_tune_details = Some(input);
            self
        }
        /// <p>Specifies details about the scheduled Auto-Tune action. See <a href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/auto-tune.html" target="_blank"> Auto-Tune for Amazon OpenSearch Service </a> for more information. </p>
        pub fn set_scheduled_auto_tune_details(
            mut self,
            input: std::option::Option<crate::model::ScheduledAutoTuneDetails>,
        ) -> Self {
            self.scheduled_auto_tune_details = input;
            self
        }
        /// Consumes the builder and constructs a [`AutoTuneDetails`](crate::model::AutoTuneDetails)
        pub fn build(self) -> crate::model::AutoTuneDetails {
            crate::model::AutoTuneDetails {
                scheduled_auto_tune_details: self.scheduled_auto_tune_details,
            }
        }
    }
}
impl AutoTuneDetails {
    /// Creates a new builder-style object to manufacture [`AutoTuneDetails`](crate::model::AutoTuneDetails)
    pub fn builder() -> crate::model::auto_tune_details::Builder {
        crate::model::auto_tune_details::Builder::default()
    }
}

/// <p>Specifies details about the scheduled Auto-Tune action. See <a href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/auto-tune.html" target="_blank"> Auto-Tune for Amazon OpenSearch Service </a> for more information. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ScheduledAutoTuneDetails {
    /// <p>The timestamp of the Auto-Tune action scheduled for the domain.</p>
    pub date: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The Auto-Tune action type. Valid values are JVM_HEAP_SIZE_TUNING and JVM_YOUNG_GEN_TUNING.</p>
    pub action_type: std::option::Option<crate::model::ScheduledAutoTuneActionType>,
    /// <p>The Auto-Tune action description.</p>
    pub action: std::option::Option<std::string::String>,
    /// <p>The Auto-Tune action severity. Valid values are LOW, MEDIUM, and HIGH.</p>
    pub severity: std::option::Option<crate::model::ScheduledAutoTuneSeverityType>,
}
impl ScheduledAutoTuneDetails {
    /// <p>The timestamp of the Auto-Tune action scheduled for the domain.</p>
    pub fn date(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.date.as_ref()
    }
    /// <p>The Auto-Tune action type. Valid values are JVM_HEAP_SIZE_TUNING and JVM_YOUNG_GEN_TUNING.</p>
    pub fn action_type(&self) -> std::option::Option<&crate::model::ScheduledAutoTuneActionType> {
        self.action_type.as_ref()
    }
    /// <p>The Auto-Tune action description.</p>
    pub fn action(&self) -> std::option::Option<&str> {
        self.action.as_deref()
    }
    /// <p>The Auto-Tune action severity. Valid values are LOW, MEDIUM, and HIGH.</p>
    pub fn severity(&self) -> std::option::Option<&crate::model::ScheduledAutoTuneSeverityType> {
        self.severity.as_ref()
    }
}
impl std::fmt::Debug for ScheduledAutoTuneDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ScheduledAutoTuneDetails");
        formatter.field("date", &self.date);
        formatter.field("action_type", &self.action_type);
        formatter.field("action", &self.action);
        formatter.field("severity", &self.severity);
        formatter.finish()
    }
}
/// See [`ScheduledAutoTuneDetails`](crate::model::ScheduledAutoTuneDetails)
pub mod scheduled_auto_tune_details {

    /// A builder for [`ScheduledAutoTuneDetails`](crate::model::ScheduledAutoTuneDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) date: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) action_type: std::option::Option<crate::model::ScheduledAutoTuneActionType>,
        pub(crate) action: std::option::Option<std::string::String>,
        pub(crate) severity: std::option::Option<crate::model::ScheduledAutoTuneSeverityType>,
    }
    impl Builder {
        /// <p>The timestamp of the Auto-Tune action scheduled for the domain.</p>
        pub fn date(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.date = Some(input);
            self
        }
        /// <p>The timestamp of the Auto-Tune action scheduled for the domain.</p>
        pub fn set_date(mut self, input: std::option::Option<aws_smithy_types::DateTime>) -> Self {
            self.date = input;
            self
        }
        /// <p>The Auto-Tune action type. Valid values are JVM_HEAP_SIZE_TUNING and JVM_YOUNG_GEN_TUNING.</p>
        pub fn action_type(mut self, input: crate::model::ScheduledAutoTuneActionType) -> Self {
            self.action_type = Some(input);
            self
        }
        /// <p>The Auto-Tune action type. Valid values are JVM_HEAP_SIZE_TUNING and JVM_YOUNG_GEN_TUNING.</p>
        pub fn set_action_type(
            mut self,
            input: std::option::Option<crate::model::ScheduledAutoTuneActionType>,
        ) -> Self {
            self.action_type = input;
            self
        }
        /// <p>The Auto-Tune action description.</p>
        pub fn action(mut self, input: impl Into<std::string::String>) -> Self {
            self.action = Some(input.into());
            self
        }
        /// <p>The Auto-Tune action description.</p>
        pub fn set_action(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.action = input;
            self
        }
        /// <p>The Auto-Tune action severity. Valid values are LOW, MEDIUM, and HIGH.</p>
        pub fn severity(mut self, input: crate::model::ScheduledAutoTuneSeverityType) -> Self {
            self.severity = Some(input);
            self
        }
        /// <p>The Auto-Tune action severity. Valid values are LOW, MEDIUM, and HIGH.</p>
        pub fn set_severity(
            mut self,
            input: std::option::Option<crate::model::ScheduledAutoTuneSeverityType>,
        ) -> Self {
            self.severity = input;
            self
        }
        /// Consumes the builder and constructs a [`ScheduledAutoTuneDetails`](crate::model::ScheduledAutoTuneDetails)
        pub fn build(self) -> crate::model::ScheduledAutoTuneDetails {
            crate::model::ScheduledAutoTuneDetails {
                date: self.date,
                action_type: self.action_type,
                action: self.action,
                severity: self.severity,
            }
        }
    }
}
impl ScheduledAutoTuneDetails {
    /// Creates a new builder-style object to manufacture [`ScheduledAutoTuneDetails`](crate::model::ScheduledAutoTuneDetails)
    pub fn builder() -> crate::model::scheduled_auto_tune_details::Builder {
        crate::model::scheduled_auto_tune_details::Builder::default()
    }
}

/// <p>The Auto-Tune action severity. Valid values are LOW, MEDIUM, and HIGH.</p>
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ScheduledAutoTuneSeverityType {
    #[allow(missing_docs)] // documentation missing in model
    High,
    #[allow(missing_docs)] // documentation missing in model
    Low,
    #[allow(missing_docs)] // documentation missing in model
    Medium,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ScheduledAutoTuneSeverityType {
    fn from(s: &str) -> Self {
        match s {
            "HIGH" => ScheduledAutoTuneSeverityType::High,
            "LOW" => ScheduledAutoTuneSeverityType::Low,
            "MEDIUM" => ScheduledAutoTuneSeverityType::Medium,
            other => ScheduledAutoTuneSeverityType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ScheduledAutoTuneSeverityType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ScheduledAutoTuneSeverityType::from(s))
    }
}
impl ScheduledAutoTuneSeverityType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ScheduledAutoTuneSeverityType::High => "HIGH",
            ScheduledAutoTuneSeverityType::Low => "LOW",
            ScheduledAutoTuneSeverityType::Medium => "MEDIUM",
            ScheduledAutoTuneSeverityType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["HIGH", "LOW", "MEDIUM"]
    }
}
impl AsRef<str> for ScheduledAutoTuneSeverityType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The Auto-Tune action type. Valid values are JVM_HEAP_SIZE_TUNING, and JVM_YOUNG_GEN_TUNING.</p>
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ScheduledAutoTuneActionType {
    #[allow(missing_docs)] // documentation missing in model
    JvmHeapSizeTuning,
    #[allow(missing_docs)] // documentation missing in model
    JvmYoungGenTuning,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ScheduledAutoTuneActionType {
    fn from(s: &str) -> Self {
        match s {
            "JVM_HEAP_SIZE_TUNING" => ScheduledAutoTuneActionType::JvmHeapSizeTuning,
            "JVM_YOUNG_GEN_TUNING" => ScheduledAutoTuneActionType::JvmYoungGenTuning,
            other => ScheduledAutoTuneActionType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ScheduledAutoTuneActionType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ScheduledAutoTuneActionType::from(s))
    }
}
impl ScheduledAutoTuneActionType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ScheduledAutoTuneActionType::JvmHeapSizeTuning => "JVM_HEAP_SIZE_TUNING",
            ScheduledAutoTuneActionType::JvmYoungGenTuning => "JVM_YOUNG_GEN_TUNING",
            ScheduledAutoTuneActionType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["JVM_HEAP_SIZE_TUNING", "JVM_YOUNG_GEN_TUNING"]
    }
}
impl AsRef<str> for ScheduledAutoTuneActionType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Specifies the Auto-Tune type. Valid value is SCHEDULED_ACTION.</p>
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AutoTuneType {
    #[allow(missing_docs)] // documentation missing in model
    ScheduledAction,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for AutoTuneType {
    fn from(s: &str) -> Self {
        match s {
            "SCHEDULED_ACTION" => AutoTuneType::ScheduledAction,
            other => AutoTuneType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for AutoTuneType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AutoTuneType::from(s))
    }
}
impl AutoTuneType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            AutoTuneType::ScheduledAction => "SCHEDULED_ACTION",
            AutoTuneType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["SCHEDULED_ACTION"]
    }
}
impl AsRef<str> for AutoTuneType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The Auto-Tune options: the Auto-Tune desired state for the domain and list of maintenance schedules. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AutoTuneOptionsInput {
    /// <p>The Auto-Tune desired state. Valid values are ENABLED and DISABLED.</p>
    pub desired_state: std::option::Option<crate::model::AutoTuneDesiredState>,
    /// <p>A list of maintenance schedules. See <a href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/auto-tune.html" target="_blank"> Auto-Tune for Amazon OpenSearch Service </a> for more information. </p>
    pub maintenance_schedules:
        std::option::Option<std::vec::Vec<crate::model::AutoTuneMaintenanceSchedule>>,
}
impl AutoTuneOptionsInput {
    /// <p>The Auto-Tune desired state. Valid values are ENABLED and DISABLED.</p>
    pub fn desired_state(&self) -> std::option::Option<&crate::model::AutoTuneDesiredState> {
        self.desired_state.as_ref()
    }
    /// <p>A list of maintenance schedules. See <a href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/auto-tune.html" target="_blank"> Auto-Tune for Amazon OpenSearch Service </a> for more information. </p>
    pub fn maintenance_schedules(
        &self,
    ) -> std::option::Option<&[crate::model::AutoTuneMaintenanceSchedule]> {
        self.maintenance_schedules.as_deref()
    }
}
impl std::fmt::Debug for AutoTuneOptionsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AutoTuneOptionsInput");
        formatter.field("desired_state", &self.desired_state);
        formatter.field("maintenance_schedules", &self.maintenance_schedules);
        formatter.finish()
    }
}
/// See [`AutoTuneOptionsInput`](crate::model::AutoTuneOptionsInput)
pub mod auto_tune_options_input {

    /// A builder for [`AutoTuneOptionsInput`](crate::model::AutoTuneOptionsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) desired_state: std::option::Option<crate::model::AutoTuneDesiredState>,
        pub(crate) maintenance_schedules:
            std::option::Option<std::vec::Vec<crate::model::AutoTuneMaintenanceSchedule>>,
    }
    impl Builder {
        /// <p>The Auto-Tune desired state. Valid values are ENABLED and DISABLED.</p>
        pub fn desired_state(mut self, input: crate::model::AutoTuneDesiredState) -> Self {
            self.desired_state = Some(input);
            self
        }
        /// <p>The Auto-Tune desired state. Valid values are ENABLED and DISABLED.</p>
        pub fn set_desired_state(
            mut self,
            input: std::option::Option<crate::model::AutoTuneDesiredState>,
        ) -> Self {
            self.desired_state = input;
            self
        }
        /// Appends an item to `maintenance_schedules`.
        ///
        /// To override the contents of this collection use [`set_maintenance_schedules`](Self::set_maintenance_schedules).
        ///
        /// <p>A list of maintenance schedules. See <a href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/auto-tune.html" target="_blank"> Auto-Tune for Amazon OpenSearch Service </a> for more information. </p>
        pub fn maintenance_schedules(
            mut self,
            input: crate::model::AutoTuneMaintenanceSchedule,
        ) -> Self {
            let mut v = self.maintenance_schedules.unwrap_or_default();
            v.push(input);
            self.maintenance_schedules = Some(v);
            self
        }
        /// <p>A list of maintenance schedules. See <a href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/auto-tune.html" target="_blank"> Auto-Tune for Amazon OpenSearch Service </a> for more information. </p>
        pub fn set_maintenance_schedules(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AutoTuneMaintenanceSchedule>>,
        ) -> Self {
            self.maintenance_schedules = input;
            self
        }
        /// Consumes the builder and constructs a [`AutoTuneOptionsInput`](crate::model::AutoTuneOptionsInput)
        pub fn build(self) -> crate::model::AutoTuneOptionsInput {
            crate::model::AutoTuneOptionsInput {
                desired_state: self.desired_state,
                maintenance_schedules: self.maintenance_schedules,
            }
        }
    }
}
impl AutoTuneOptionsInput {
    /// Creates a new builder-style object to manufacture [`AutoTuneOptionsInput`](crate::model::AutoTuneOptionsInput)
    pub fn builder() -> crate::model::auto_tune_options_input::Builder {
        crate::model::auto_tune_options_input::Builder::default()
    }
}
