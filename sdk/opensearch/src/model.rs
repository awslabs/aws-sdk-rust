// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Container for information about a configuration change happening on a domain.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ChangeProgressDetails {
    /// <p>The ID of the configuration change.</p>
    #[doc(hidden)]
    pub change_id: std::option::Option<std::string::String>,
    /// <p>A message corresponding to the status of the configuration change.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
}
impl ChangeProgressDetails {
    /// <p>The ID of the configuration change.</p>
    pub fn change_id(&self) -> std::option::Option<&str> {
        self.change_id.as_deref()
    }
    /// <p>A message corresponding to the status of the configuration change.</p>
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
/// See [`ChangeProgressDetails`](crate::model::ChangeProgressDetails).
pub mod change_progress_details {

    /// A builder for [`ChangeProgressDetails`](crate::model::ChangeProgressDetails).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) change_id: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the configuration change.</p>
        pub fn change_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.change_id = Some(input.into());
            self
        }
        /// <p>The ID of the configuration change.</p>
        pub fn set_change_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.change_id = input;
            self
        }
        /// <p>A message corresponding to the status of the configuration change.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A message corresponding to the status of the configuration change.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ChangeProgressDetails`](crate::model::ChangeProgressDetails).
        pub fn build(self) -> crate::model::ChangeProgressDetails {
            crate::model::ChangeProgressDetails {
                change_id: self.change_id,
                message: self.message,
            }
        }
    }
}
impl ChangeProgressDetails {
    /// Creates a new builder-style object to manufacture [`ChangeProgressDetails`](crate::model::ChangeProgressDetails).
    pub fn builder() -> crate::model::change_progress_details::Builder {
        crate::model::change_progress_details::Builder::default()
    }
}

/// <p>The connection endpoint for connecting to an Amazon OpenSearch Service domain through a proxy.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct VpcEndpoint {
    /// <p>The unique identifier of the endpoint.</p>
    #[doc(hidden)]
    pub vpc_endpoint_id: std::option::Option<std::string::String>,
    /// <p>The creator of the endpoint.</p>
    #[doc(hidden)]
    pub vpc_endpoint_owner: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the domain associated with the endpoint.</p>
    #[doc(hidden)]
    pub domain_arn: std::option::Option<std::string::String>,
    /// <p>Options to specify the subnets and security groups for an Amazon OpenSearch Service VPC endpoint.</p>
    #[doc(hidden)]
    pub vpc_options: std::option::Option<crate::model::VpcDerivedInfo>,
    /// <p>The current status of the endpoint.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::VpcEndpointStatus>,
    /// <p>The connection endpoint ID for connecting to the domain.</p>
    #[doc(hidden)]
    pub endpoint: std::option::Option<std::string::String>,
}
impl VpcEndpoint {
    /// <p>The unique identifier of the endpoint.</p>
    pub fn vpc_endpoint_id(&self) -> std::option::Option<&str> {
        self.vpc_endpoint_id.as_deref()
    }
    /// <p>The creator of the endpoint.</p>
    pub fn vpc_endpoint_owner(&self) -> std::option::Option<&str> {
        self.vpc_endpoint_owner.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the domain associated with the endpoint.</p>
    pub fn domain_arn(&self) -> std::option::Option<&str> {
        self.domain_arn.as_deref()
    }
    /// <p>Options to specify the subnets and security groups for an Amazon OpenSearch Service VPC endpoint.</p>
    pub fn vpc_options(&self) -> std::option::Option<&crate::model::VpcDerivedInfo> {
        self.vpc_options.as_ref()
    }
    /// <p>The current status of the endpoint.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::VpcEndpointStatus> {
        self.status.as_ref()
    }
    /// <p>The connection endpoint ID for connecting to the domain.</p>
    pub fn endpoint(&self) -> std::option::Option<&str> {
        self.endpoint.as_deref()
    }
}
/// See [`VpcEndpoint`](crate::model::VpcEndpoint).
pub mod vpc_endpoint {

    /// A builder for [`VpcEndpoint`](crate::model::VpcEndpoint).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) vpc_endpoint_id: std::option::Option<std::string::String>,
        pub(crate) vpc_endpoint_owner: std::option::Option<std::string::String>,
        pub(crate) domain_arn: std::option::Option<std::string::String>,
        pub(crate) vpc_options: std::option::Option<crate::model::VpcDerivedInfo>,
        pub(crate) status: std::option::Option<crate::model::VpcEndpointStatus>,
        pub(crate) endpoint: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique identifier of the endpoint.</p>
        pub fn vpc_endpoint_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.vpc_endpoint_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of the endpoint.</p>
        pub fn set_vpc_endpoint_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.vpc_endpoint_id = input;
            self
        }
        /// <p>The creator of the endpoint.</p>
        pub fn vpc_endpoint_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.vpc_endpoint_owner = Some(input.into());
            self
        }
        /// <p>The creator of the endpoint.</p>
        pub fn set_vpc_endpoint_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.vpc_endpoint_owner = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the domain associated with the endpoint.</p>
        pub fn domain_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the domain associated with the endpoint.</p>
        pub fn set_domain_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_arn = input;
            self
        }
        /// <p>Options to specify the subnets and security groups for an Amazon OpenSearch Service VPC endpoint.</p>
        pub fn vpc_options(mut self, input: crate::model::VpcDerivedInfo) -> Self {
            self.vpc_options = Some(input);
            self
        }
        /// <p>Options to specify the subnets and security groups for an Amazon OpenSearch Service VPC endpoint.</p>
        pub fn set_vpc_options(
            mut self,
            input: std::option::Option<crate::model::VpcDerivedInfo>,
        ) -> Self {
            self.vpc_options = input;
            self
        }
        /// <p>The current status of the endpoint.</p>
        pub fn status(mut self, input: crate::model::VpcEndpointStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The current status of the endpoint.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::VpcEndpointStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>The connection endpoint ID for connecting to the domain.</p>
        pub fn endpoint(mut self, input: impl Into<std::string::String>) -> Self {
            self.endpoint = Some(input.into());
            self
        }
        /// <p>The connection endpoint ID for connecting to the domain.</p>
        pub fn set_endpoint(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.endpoint = input;
            self
        }
        /// Consumes the builder and constructs a [`VpcEndpoint`](crate::model::VpcEndpoint).
        pub fn build(self) -> crate::model::VpcEndpoint {
            crate::model::VpcEndpoint {
                vpc_endpoint_id: self.vpc_endpoint_id,
                vpc_endpoint_owner: self.vpc_endpoint_owner,
                domain_arn: self.domain_arn,
                vpc_options: self.vpc_options,
                status: self.status,
                endpoint: self.endpoint,
            }
        }
    }
}
impl VpcEndpoint {
    /// Creates a new builder-style object to manufacture [`VpcEndpoint`](crate::model::VpcEndpoint).
    pub fn builder() -> crate::model::vpc_endpoint::Builder {
        crate::model::vpc_endpoint::Builder::default()
    }
}

/// When writing a match expression against `VpcEndpointStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let vpcendpointstatus = unimplemented!();
/// match vpcendpointstatus {
///     VpcEndpointStatus::Active => { /* ... */ },
///     VpcEndpointStatus::CreateFailed => { /* ... */ },
///     VpcEndpointStatus::Creating => { /* ... */ },
///     VpcEndpointStatus::DeleteFailed => { /* ... */ },
///     VpcEndpointStatus::Deleting => { /* ... */ },
///     VpcEndpointStatus::UpdateFailed => { /* ... */ },
///     VpcEndpointStatus::Updating => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `vpcendpointstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `VpcEndpointStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `VpcEndpointStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `VpcEndpointStatus::NewFeature` is defined.
/// Specifically, when `vpcendpointstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `VpcEndpointStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum VpcEndpointStatus {
    #[allow(missing_docs)] // documentation missing in model
    Active,
    #[allow(missing_docs)] // documentation missing in model
    CreateFailed,
    #[allow(missing_docs)] // documentation missing in model
    Creating,
    #[allow(missing_docs)] // documentation missing in model
    DeleteFailed,
    #[allow(missing_docs)] // documentation missing in model
    Deleting,
    #[allow(missing_docs)] // documentation missing in model
    UpdateFailed,
    #[allow(missing_docs)] // documentation missing in model
    Updating,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for VpcEndpointStatus {
    fn from(s: &str) -> Self {
        match s {
            "ACTIVE" => VpcEndpointStatus::Active,
            "CREATE_FAILED" => VpcEndpointStatus::CreateFailed,
            "CREATING" => VpcEndpointStatus::Creating,
            "DELETE_FAILED" => VpcEndpointStatus::DeleteFailed,
            "DELETING" => VpcEndpointStatus::Deleting,
            "UPDATE_FAILED" => VpcEndpointStatus::UpdateFailed,
            "UPDATING" => VpcEndpointStatus::Updating,
            other => {
                VpcEndpointStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for VpcEndpointStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(VpcEndpointStatus::from(s))
    }
}
impl VpcEndpointStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            VpcEndpointStatus::Active => "ACTIVE",
            VpcEndpointStatus::CreateFailed => "CREATE_FAILED",
            VpcEndpointStatus::Creating => "CREATING",
            VpcEndpointStatus::DeleteFailed => "DELETE_FAILED",
            VpcEndpointStatus::Deleting => "DELETING",
            VpcEndpointStatus::UpdateFailed => "UPDATE_FAILED",
            VpcEndpointStatus::Updating => "UPDATING",
            VpcEndpointStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "ACTIVE",
            "CREATE_FAILED",
            "CREATING",
            "DELETE_FAILED",
            "DELETING",
            "UPDATE_FAILED",
            "UPDATING",
        ]
    }
}
impl AsRef<str> for VpcEndpointStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Information about the subnets and security groups for an Amazon OpenSearch Service domain provisioned within a virtual private cloud (VPC). For more information, see <a href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/vpc.html">Launching your Amazon OpenSearch Service domains using a VPC</a>. This information only exists if the domain was created with <code>VPCOptions</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct VpcDerivedInfo {
    /// <p>The ID for your VPC. Amazon VPC generates this value when you create a VPC.</p>
    #[doc(hidden)]
    pub vpc_id: std::option::Option<std::string::String>,
    /// <p>A list of subnet IDs associated with the VPC endpoints for the domain.</p>
    #[doc(hidden)]
    pub subnet_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The list of Availability Zones associated with the VPC subnets.</p>
    #[doc(hidden)]
    pub availability_zones: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The list of security group IDs associated with the VPC endpoints for the domain.</p>
    #[doc(hidden)]
    pub security_group_ids: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl VpcDerivedInfo {
    /// <p>The ID for your VPC. Amazon VPC generates this value when you create a VPC.</p>
    pub fn vpc_id(&self) -> std::option::Option<&str> {
        self.vpc_id.as_deref()
    }
    /// <p>A list of subnet IDs associated with the VPC endpoints for the domain.</p>
    pub fn subnet_ids(&self) -> std::option::Option<&[std::string::String]> {
        self.subnet_ids.as_deref()
    }
    /// <p>The list of Availability Zones associated with the VPC subnets.</p>
    pub fn availability_zones(&self) -> std::option::Option<&[std::string::String]> {
        self.availability_zones.as_deref()
    }
    /// <p>The list of security group IDs associated with the VPC endpoints for the domain.</p>
    pub fn security_group_ids(&self) -> std::option::Option<&[std::string::String]> {
        self.security_group_ids.as_deref()
    }
}
/// See [`VpcDerivedInfo`](crate::model::VpcDerivedInfo).
pub mod vpc_derived_info {

    /// A builder for [`VpcDerivedInfo`](crate::model::VpcDerivedInfo).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) vpc_id: std::option::Option<std::string::String>,
        pub(crate) subnet_ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) availability_zones: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) security_group_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The ID for your VPC. Amazon VPC generates this value when you create a VPC.</p>
        pub fn vpc_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.vpc_id = Some(input.into());
            self
        }
        /// <p>The ID for your VPC. Amazon VPC generates this value when you create a VPC.</p>
        pub fn set_vpc_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.vpc_id = input;
            self
        }
        /// Appends an item to `subnet_ids`.
        ///
        /// To override the contents of this collection use [`set_subnet_ids`](Self::set_subnet_ids).
        ///
        /// <p>A list of subnet IDs associated with the VPC endpoints for the domain.</p>
        pub fn subnet_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.subnet_ids.unwrap_or_default();
            v.push(input.into());
            self.subnet_ids = Some(v);
            self
        }
        /// <p>A list of subnet IDs associated with the VPC endpoints for the domain.</p>
        pub fn set_subnet_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.subnet_ids = input;
            self
        }
        /// Appends an item to `availability_zones`.
        ///
        /// To override the contents of this collection use [`set_availability_zones`](Self::set_availability_zones).
        ///
        /// <p>The list of Availability Zones associated with the VPC subnets.</p>
        pub fn availability_zones(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.availability_zones.unwrap_or_default();
            v.push(input.into());
            self.availability_zones = Some(v);
            self
        }
        /// <p>The list of Availability Zones associated with the VPC subnets.</p>
        pub fn set_availability_zones(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.availability_zones = input;
            self
        }
        /// Appends an item to `security_group_ids`.
        ///
        /// To override the contents of this collection use [`set_security_group_ids`](Self::set_security_group_ids).
        ///
        /// <p>The list of security group IDs associated with the VPC endpoints for the domain.</p>
        pub fn security_group_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.security_group_ids.unwrap_or_default();
            v.push(input.into());
            self.security_group_ids = Some(v);
            self
        }
        /// <p>The list of security group IDs associated with the VPC endpoints for the domain.</p>
        pub fn set_security_group_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.security_group_ids = input;
            self
        }
        /// Consumes the builder and constructs a [`VpcDerivedInfo`](crate::model::VpcDerivedInfo).
        pub fn build(self) -> crate::model::VpcDerivedInfo {
            crate::model::VpcDerivedInfo {
                vpc_id: self.vpc_id,
                subnet_ids: self.subnet_ids,
                availability_zones: self.availability_zones,
                security_group_ids: self.security_group_ids,
            }
        }
    }
}
impl VpcDerivedInfo {
    /// Creates a new builder-style object to manufacture [`VpcDerivedInfo`](crate::model::VpcDerivedInfo).
    pub fn builder() -> crate::model::vpc_derived_info::Builder {
        crate::model::vpc_derived_info::Builder::default()
    }
}

/// <p>Options to specify the subnets and security groups for an Amazon OpenSearch Service VPC endpoint. For more information, see <a href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/vpc.html">Launching your Amazon OpenSearch Service domains using a VPC</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct VpcOptions {
    /// <p>A list of subnet IDs associated with the VPC endpoints for the domain. If your domain uses multiple Availability Zones, you need to provide two subnet IDs, one per zone. Otherwise, provide only one.</p>
    #[doc(hidden)]
    pub subnet_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The list of security group IDs associated with the VPC endpoints for the domain. If you do not provide a security group ID, OpenSearch Service uses the default security group for the VPC.</p>
    #[doc(hidden)]
    pub security_group_ids: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl VpcOptions {
    /// <p>A list of subnet IDs associated with the VPC endpoints for the domain. If your domain uses multiple Availability Zones, you need to provide two subnet IDs, one per zone. Otherwise, provide only one.</p>
    pub fn subnet_ids(&self) -> std::option::Option<&[std::string::String]> {
        self.subnet_ids.as_deref()
    }
    /// <p>The list of security group IDs associated with the VPC endpoints for the domain. If you do not provide a security group ID, OpenSearch Service uses the default security group for the VPC.</p>
    pub fn security_group_ids(&self) -> std::option::Option<&[std::string::String]> {
        self.security_group_ids.as_deref()
    }
}
/// See [`VpcOptions`](crate::model::VpcOptions).
pub mod vpc_options {

    /// A builder for [`VpcOptions`](crate::model::VpcOptions).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) subnet_ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) security_group_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// Appends an item to `subnet_ids`.
        ///
        /// To override the contents of this collection use [`set_subnet_ids`](Self::set_subnet_ids).
        ///
        /// <p>A list of subnet IDs associated with the VPC endpoints for the domain. If your domain uses multiple Availability Zones, you need to provide two subnet IDs, one per zone. Otherwise, provide only one.</p>
        pub fn subnet_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.subnet_ids.unwrap_or_default();
            v.push(input.into());
            self.subnet_ids = Some(v);
            self
        }
        /// <p>A list of subnet IDs associated with the VPC endpoints for the domain. If your domain uses multiple Availability Zones, you need to provide two subnet IDs, one per zone. Otherwise, provide only one.</p>
        pub fn set_subnet_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.subnet_ids = input;
            self
        }
        /// Appends an item to `security_group_ids`.
        ///
        /// To override the contents of this collection use [`set_security_group_ids`](Self::set_security_group_ids).
        ///
        /// <p>The list of security group IDs associated with the VPC endpoints for the domain. If you do not provide a security group ID, OpenSearch Service uses the default security group for the VPC.</p>
        pub fn security_group_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.security_group_ids.unwrap_or_default();
            v.push(input.into());
            self.security_group_ids = Some(v);
            self
        }
        /// <p>The list of security group IDs associated with the VPC endpoints for the domain. If you do not provide a security group ID, OpenSearch Service uses the default security group for the VPC.</p>
        pub fn set_security_group_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.security_group_ids = input;
            self
        }
        /// Consumes the builder and constructs a [`VpcOptions`](crate::model::VpcOptions).
        pub fn build(self) -> crate::model::VpcOptions {
            crate::model::VpcOptions {
                subnet_ids: self.subnet_ids,
                security_group_ids: self.security_group_ids,
            }
        }
    }
}
impl VpcOptions {
    /// Creates a new builder-style object to manufacture [`VpcOptions`](crate::model::VpcOptions).
    pub fn builder() -> crate::model::vpc_options::Builder {
        crate::model::vpc_options::Builder::default()
    }
}

/// <p>Basic information about a package.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PackageDetails {
    /// <p>The unique identifier of the package.</p>
    #[doc(hidden)]
    pub package_id: std::option::Option<std::string::String>,
    /// <p>User-specified name of the package.</p>
    #[doc(hidden)]
    pub package_name: std::option::Option<std::string::String>,
    /// <p>The type of package.</p>
    #[doc(hidden)]
    pub package_type: std::option::Option<crate::model::PackageType>,
    /// <p>User-specified description of the package.</p>
    #[doc(hidden)]
    pub package_description: std::option::Option<std::string::String>,
    /// <p>Current status of the package.</p>
    #[doc(hidden)]
    pub package_status: std::option::Option<crate::model::PackageStatus>,
    /// <p>The timestamp when the package was created.</p>
    #[doc(hidden)]
    pub created_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Date and time when the package was last updated.</p>
    #[doc(hidden)]
    pub last_updated_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The package version.</p>
    #[doc(hidden)]
    pub available_package_version: std::option::Option<std::string::String>,
    /// <p>Additional information if the package is in an error state. Null otherwise.</p>
    #[doc(hidden)]
    pub error_details: std::option::Option<crate::model::ErrorDetails>,
}
impl PackageDetails {
    /// <p>The unique identifier of the package.</p>
    pub fn package_id(&self) -> std::option::Option<&str> {
        self.package_id.as_deref()
    }
    /// <p>User-specified name of the package.</p>
    pub fn package_name(&self) -> std::option::Option<&str> {
        self.package_name.as_deref()
    }
    /// <p>The type of package.</p>
    pub fn package_type(&self) -> std::option::Option<&crate::model::PackageType> {
        self.package_type.as_ref()
    }
    /// <p>User-specified description of the package.</p>
    pub fn package_description(&self) -> std::option::Option<&str> {
        self.package_description.as_deref()
    }
    /// <p>Current status of the package.</p>
    pub fn package_status(&self) -> std::option::Option<&crate::model::PackageStatus> {
        self.package_status.as_ref()
    }
    /// <p>The timestamp when the package was created.</p>
    pub fn created_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_at.as_ref()
    }
    /// <p>Date and time when the package was last updated.</p>
    pub fn last_updated_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_updated_at.as_ref()
    }
    /// <p>The package version.</p>
    pub fn available_package_version(&self) -> std::option::Option<&str> {
        self.available_package_version.as_deref()
    }
    /// <p>Additional information if the package is in an error state. Null otherwise.</p>
    pub fn error_details(&self) -> std::option::Option<&crate::model::ErrorDetails> {
        self.error_details.as_ref()
    }
}
/// See [`PackageDetails`](crate::model::PackageDetails).
pub mod package_details {

    /// A builder for [`PackageDetails`](crate::model::PackageDetails).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) package_id: std::option::Option<std::string::String>,
        pub(crate) package_name: std::option::Option<std::string::String>,
        pub(crate) package_type: std::option::Option<crate::model::PackageType>,
        pub(crate) package_description: std::option::Option<std::string::String>,
        pub(crate) package_status: std::option::Option<crate::model::PackageStatus>,
        pub(crate) created_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_updated_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) available_package_version: std::option::Option<std::string::String>,
        pub(crate) error_details: std::option::Option<crate::model::ErrorDetails>,
    }
    impl Builder {
        /// <p>The unique identifier of the package.</p>
        pub fn package_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.package_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of the package.</p>
        pub fn set_package_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.package_id = input;
            self
        }
        /// <p>User-specified name of the package.</p>
        pub fn package_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.package_name = Some(input.into());
            self
        }
        /// <p>User-specified name of the package.</p>
        pub fn set_package_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.package_name = input;
            self
        }
        /// <p>The type of package.</p>
        pub fn package_type(mut self, input: crate::model::PackageType) -> Self {
            self.package_type = Some(input);
            self
        }
        /// <p>The type of package.</p>
        pub fn set_package_type(
            mut self,
            input: std::option::Option<crate::model::PackageType>,
        ) -> Self {
            self.package_type = input;
            self
        }
        /// <p>User-specified description of the package.</p>
        pub fn package_description(mut self, input: impl Into<std::string::String>) -> Self {
            self.package_description = Some(input.into());
            self
        }
        /// <p>User-specified description of the package.</p>
        pub fn set_package_description(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.package_description = input;
            self
        }
        /// <p>Current status of the package.</p>
        pub fn package_status(mut self, input: crate::model::PackageStatus) -> Self {
            self.package_status = Some(input);
            self
        }
        /// <p>Current status of the package.</p>
        pub fn set_package_status(
            mut self,
            input: std::option::Option<crate::model::PackageStatus>,
        ) -> Self {
            self.package_status = input;
            self
        }
        /// <p>The timestamp when the package was created.</p>
        pub fn created_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_at = Some(input);
            self
        }
        /// <p>The timestamp when the package was created.</p>
        pub fn set_created_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_at = input;
            self
        }
        /// <p>Date and time when the package was last updated.</p>
        pub fn last_updated_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_updated_at = Some(input);
            self
        }
        /// <p>Date and time when the package was last updated.</p>
        pub fn set_last_updated_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_updated_at = input;
            self
        }
        /// <p>The package version.</p>
        pub fn available_package_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.available_package_version = Some(input.into());
            self
        }
        /// <p>The package version.</p>
        pub fn set_available_package_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.available_package_version = input;
            self
        }
        /// <p>Additional information if the package is in an error state. Null otherwise.</p>
        pub fn error_details(mut self, input: crate::model::ErrorDetails) -> Self {
            self.error_details = Some(input);
            self
        }
        /// <p>Additional information if the package is in an error state. Null otherwise.</p>
        pub fn set_error_details(
            mut self,
            input: std::option::Option<crate::model::ErrorDetails>,
        ) -> Self {
            self.error_details = input;
            self
        }
        /// Consumes the builder and constructs a [`PackageDetails`](crate::model::PackageDetails).
        pub fn build(self) -> crate::model::PackageDetails {
            crate::model::PackageDetails {
                package_id: self.package_id,
                package_name: self.package_name,
                package_type: self.package_type,
                package_description: self.package_description,
                package_status: self.package_status,
                created_at: self.created_at,
                last_updated_at: self.last_updated_at,
                available_package_version: self.available_package_version,
                error_details: self.error_details,
            }
        }
    }
}
impl PackageDetails {
    /// Creates a new builder-style object to manufacture [`PackageDetails`](crate::model::PackageDetails).
    pub fn builder() -> crate::model::package_details::Builder {
        crate::model::package_details::Builder::default()
    }
}

/// <p>Additional information if the package is in an error state. Null otherwise.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ErrorDetails {
    /// <p>The type of error that occurred.</p>
    #[doc(hidden)]
    pub error_type: std::option::Option<std::string::String>,
    /// <p>A message describing the error.</p>
    #[doc(hidden)]
    pub error_message: std::option::Option<std::string::String>,
}
impl ErrorDetails {
    /// <p>The type of error that occurred.</p>
    pub fn error_type(&self) -> std::option::Option<&str> {
        self.error_type.as_deref()
    }
    /// <p>A message describing the error.</p>
    pub fn error_message(&self) -> std::option::Option<&str> {
        self.error_message.as_deref()
    }
}
/// See [`ErrorDetails`](crate::model::ErrorDetails).
pub mod error_details {

    /// A builder for [`ErrorDetails`](crate::model::ErrorDetails).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) error_type: std::option::Option<std::string::String>,
        pub(crate) error_message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The type of error that occurred.</p>
        pub fn error_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_type = Some(input.into());
            self
        }
        /// <p>The type of error that occurred.</p>
        pub fn set_error_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.error_type = input;
            self
        }
        /// <p>A message describing the error.</p>
        pub fn error_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_message = Some(input.into());
            self
        }
        /// <p>A message describing the error.</p>
        pub fn set_error_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.error_message = input;
            self
        }
        /// Consumes the builder and constructs a [`ErrorDetails`](crate::model::ErrorDetails).
        pub fn build(self) -> crate::model::ErrorDetails {
            crate::model::ErrorDetails {
                error_type: self.error_type,
                error_message: self.error_message,
            }
        }
    }
}
impl ErrorDetails {
    /// Creates a new builder-style object to manufacture [`ErrorDetails`](crate::model::ErrorDetails).
    pub fn builder() -> crate::model::error_details::Builder {
        crate::model::error_details::Builder::default()
    }
}

/// When writing a match expression against `PackageStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let packagestatus = unimplemented!();
/// match packagestatus {
///     PackageStatus::Available => { /* ... */ },
///     PackageStatus::Copying => { /* ... */ },
///     PackageStatus::CopyFailed => { /* ... */ },
///     PackageStatus::Deleted => { /* ... */ },
///     PackageStatus::DeleteFailed => { /* ... */ },
///     PackageStatus::Deleting => { /* ... */ },
///     PackageStatus::Validating => { /* ... */ },
///     PackageStatus::ValidationFailed => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `packagestatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `PackageStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `PackageStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `PackageStatus::NewFeature` is defined.
/// Specifically, when `packagestatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `PackageStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum PackageStatus {
    #[allow(missing_docs)] // documentation missing in model
    Available,
    #[allow(missing_docs)] // documentation missing in model
    Copying,
    #[allow(missing_docs)] // documentation missing in model
    CopyFailed,
    #[allow(missing_docs)] // documentation missing in model
    Deleted,
    #[allow(missing_docs)] // documentation missing in model
    DeleteFailed,
    #[allow(missing_docs)] // documentation missing in model
    Deleting,
    #[allow(missing_docs)] // documentation missing in model
    Validating,
    #[allow(missing_docs)] // documentation missing in model
    ValidationFailed,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for PackageStatus {
    fn from(s: &str) -> Self {
        match s {
            "AVAILABLE" => PackageStatus::Available,
            "COPYING" => PackageStatus::Copying,
            "COPY_FAILED" => PackageStatus::CopyFailed,
            "DELETED" => PackageStatus::Deleted,
            "DELETE_FAILED" => PackageStatus::DeleteFailed,
            "DELETING" => PackageStatus::Deleting,
            "VALIDATING" => PackageStatus::Validating,
            "VALIDATION_FAILED" => PackageStatus::ValidationFailed,
            other => PackageStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for PackageStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(PackageStatus::from(s))
    }
}
impl PackageStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            PackageStatus::Available => "AVAILABLE",
            PackageStatus::Copying => "COPYING",
            PackageStatus::CopyFailed => "COPY_FAILED",
            PackageStatus::Deleted => "DELETED",
            PackageStatus::DeleteFailed => "DELETE_FAILED",
            PackageStatus::Deleting => "DELETING",
            PackageStatus::Validating => "VALIDATING",
            PackageStatus::ValidationFailed => "VALIDATION_FAILED",
            PackageStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "AVAILABLE",
            "COPYING",
            "COPY_FAILED",
            "DELETED",
            "DELETE_FAILED",
            "DELETING",
            "VALIDATING",
            "VALIDATION_FAILED",
        ]
    }
}
impl AsRef<str> for PackageStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `PackageType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let packagetype = unimplemented!();
/// match packagetype {
///     PackageType::TxtDictionary => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `packagetype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `PackageType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `PackageType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `PackageType::NewFeature` is defined.
/// Specifically, when `packagetype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `PackageType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum PackageType {
    #[allow(missing_docs)] // documentation missing in model
    TxtDictionary,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for PackageType {
    fn from(s: &str) -> Self {
        match s {
            "TXT-DICTIONARY" => PackageType::TxtDictionary,
            other => PackageType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for PackageType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(PackageType::from(s))
    }
}
impl PackageType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            PackageType::TxtDictionary => "TXT-DICTIONARY",
            PackageType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["TXT-DICTIONARY"]
    }
}
impl AsRef<str> for PackageType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The Amazon S3 location to import the package from.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PackageSource {
    /// <p>The name of the Amazon S3 bucket containing the package.</p>
    #[doc(hidden)]
    pub s3_bucket_name: std::option::Option<std::string::String>,
    /// <p>Key (file name) of the package.</p>
    #[doc(hidden)]
    pub s3_key: std::option::Option<std::string::String>,
}
impl PackageSource {
    /// <p>The name of the Amazon S3 bucket containing the package.</p>
    pub fn s3_bucket_name(&self) -> std::option::Option<&str> {
        self.s3_bucket_name.as_deref()
    }
    /// <p>Key (file name) of the package.</p>
    pub fn s3_key(&self) -> std::option::Option<&str> {
        self.s3_key.as_deref()
    }
}
/// See [`PackageSource`](crate::model::PackageSource).
pub mod package_source {

    /// A builder for [`PackageSource`](crate::model::PackageSource).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) s3_bucket_name: std::option::Option<std::string::String>,
        pub(crate) s3_key: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the Amazon S3 bucket containing the package.</p>
        pub fn s3_bucket_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_bucket_name = Some(input.into());
            self
        }
        /// <p>The name of the Amazon S3 bucket containing the package.</p>
        pub fn set_s3_bucket_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.s3_bucket_name = input;
            self
        }
        /// <p>Key (file name) of the package.</p>
        pub fn s3_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_key = Some(input.into());
            self
        }
        /// <p>Key (file name) of the package.</p>
        pub fn set_s3_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.s3_key = input;
            self
        }
        /// Consumes the builder and constructs a [`PackageSource`](crate::model::PackageSource).
        pub fn build(self) -> crate::model::PackageSource {
            crate::model::PackageSource {
                s3_bucket_name: self.s3_bucket_name,
                s3_key: self.s3_key,
            }
        }
    }
}
impl PackageSource {
    /// Creates a new builder-style object to manufacture [`PackageSource`](crate::model::PackageSource).
    pub fn builder() -> crate::model::package_source::Builder {
        crate::model::package_source::Builder::default()
    }
}

/// <p>Information about the progress of a pre-upgrade dry run analysis.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DryRunProgressStatus {
    /// <p>The unique identifier of the dry run.</p>
    #[doc(hidden)]
    pub dry_run_id: std::option::Option<std::string::String>,
    /// <p>The current status of the dry run.</p>
    #[doc(hidden)]
    pub dry_run_status: std::option::Option<std::string::String>,
    /// <p>The timestamp when the dry run was initiated.</p>
    #[doc(hidden)]
    pub creation_date: std::option::Option<std::string::String>,
    /// <p>The timestamp when the dry run was last updated.</p>
    #[doc(hidden)]
    pub update_date: std::option::Option<std::string::String>,
    /// <p>Any validation failures that occurred as a result of the dry run.</p>
    #[doc(hidden)]
    pub validation_failures: std::option::Option<std::vec::Vec<crate::model::ValidationFailure>>,
}
impl DryRunProgressStatus {
    /// <p>The unique identifier of the dry run.</p>
    pub fn dry_run_id(&self) -> std::option::Option<&str> {
        self.dry_run_id.as_deref()
    }
    /// <p>The current status of the dry run.</p>
    pub fn dry_run_status(&self) -> std::option::Option<&str> {
        self.dry_run_status.as_deref()
    }
    /// <p>The timestamp when the dry run was initiated.</p>
    pub fn creation_date(&self) -> std::option::Option<&str> {
        self.creation_date.as_deref()
    }
    /// <p>The timestamp when the dry run was last updated.</p>
    pub fn update_date(&self) -> std::option::Option<&str> {
        self.update_date.as_deref()
    }
    /// <p>Any validation failures that occurred as a result of the dry run.</p>
    pub fn validation_failures(&self) -> std::option::Option<&[crate::model::ValidationFailure]> {
        self.validation_failures.as_deref()
    }
}
/// See [`DryRunProgressStatus`](crate::model::DryRunProgressStatus).
pub mod dry_run_progress_status {

    /// A builder for [`DryRunProgressStatus`](crate::model::DryRunProgressStatus).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) dry_run_id: std::option::Option<std::string::String>,
        pub(crate) dry_run_status: std::option::Option<std::string::String>,
        pub(crate) creation_date: std::option::Option<std::string::String>,
        pub(crate) update_date: std::option::Option<std::string::String>,
        pub(crate) validation_failures:
            std::option::Option<std::vec::Vec<crate::model::ValidationFailure>>,
    }
    impl Builder {
        /// <p>The unique identifier of the dry run.</p>
        pub fn dry_run_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.dry_run_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of the dry run.</p>
        pub fn set_dry_run_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.dry_run_id = input;
            self
        }
        /// <p>The current status of the dry run.</p>
        pub fn dry_run_status(mut self, input: impl Into<std::string::String>) -> Self {
            self.dry_run_status = Some(input.into());
            self
        }
        /// <p>The current status of the dry run.</p>
        pub fn set_dry_run_status(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.dry_run_status = input;
            self
        }
        /// <p>The timestamp when the dry run was initiated.</p>
        pub fn creation_date(mut self, input: impl Into<std::string::String>) -> Self {
            self.creation_date = Some(input.into());
            self
        }
        /// <p>The timestamp when the dry run was initiated.</p>
        pub fn set_creation_date(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.creation_date = input;
            self
        }
        /// <p>The timestamp when the dry run was last updated.</p>
        pub fn update_date(mut self, input: impl Into<std::string::String>) -> Self {
            self.update_date = Some(input.into());
            self
        }
        /// <p>The timestamp when the dry run was last updated.</p>
        pub fn set_update_date(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.update_date = input;
            self
        }
        /// Appends an item to `validation_failures`.
        ///
        /// To override the contents of this collection use [`set_validation_failures`](Self::set_validation_failures).
        ///
        /// <p>Any validation failures that occurred as a result of the dry run.</p>
        pub fn validation_failures(mut self, input: crate::model::ValidationFailure) -> Self {
            let mut v = self.validation_failures.unwrap_or_default();
            v.push(input);
            self.validation_failures = Some(v);
            self
        }
        /// <p>Any validation failures that occurred as a result of the dry run.</p>
        pub fn set_validation_failures(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ValidationFailure>>,
        ) -> Self {
            self.validation_failures = input;
            self
        }
        /// Consumes the builder and constructs a [`DryRunProgressStatus`](crate::model::DryRunProgressStatus).
        pub fn build(self) -> crate::model::DryRunProgressStatus {
            crate::model::DryRunProgressStatus {
                dry_run_id: self.dry_run_id,
                dry_run_status: self.dry_run_status,
                creation_date: self.creation_date,
                update_date: self.update_date,
                validation_failures: self.validation_failures,
            }
        }
    }
}
impl DryRunProgressStatus {
    /// Creates a new builder-style object to manufacture [`DryRunProgressStatus`](crate::model::DryRunProgressStatus).
    pub fn builder() -> crate::model::dry_run_progress_status::Builder {
        crate::model::dry_run_progress_status::Builder::default()
    }
}

/// <p>A validation failure that occurred as the result of a pre-update validation check (verbose dry run) on a domain.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ValidationFailure {
    /// <p>The error code of the failure.</p>
    #[doc(hidden)]
    pub code: std::option::Option<std::string::String>,
    /// <p>A message corresponding to the failure.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
}
impl ValidationFailure {
    /// <p>The error code of the failure.</p>
    pub fn code(&self) -> std::option::Option<&str> {
        self.code.as_deref()
    }
    /// <p>A message corresponding to the failure.</p>
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
/// See [`ValidationFailure`](crate::model::ValidationFailure).
pub mod validation_failure {

    /// A builder for [`ValidationFailure`](crate::model::ValidationFailure).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) code: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The error code of the failure.</p>
        pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
            self.code = Some(input.into());
            self
        }
        /// <p>The error code of the failure.</p>
        pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.code = input;
            self
        }
        /// <p>A message corresponding to the failure.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A message corresponding to the failure.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ValidationFailure`](crate::model::ValidationFailure).
        pub fn build(self) -> crate::model::ValidationFailure {
            crate::model::ValidationFailure {
                code: self.code,
                message: self.message,
            }
        }
    }
}
impl ValidationFailure {
    /// Creates a new builder-style object to manufacture [`ValidationFailure`](crate::model::ValidationFailure).
    pub fn builder() -> crate::model::validation_failure::Builder {
        crate::model::validation_failure::Builder::default()
    }
}

/// <p>Results of a dry run performed in an update domain request.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DryRunResults {
    /// <p> Specifies the way in which OpenSearch Service will apply an update. Possible values are:</p>
    /// <ul>
    /// <li> <p> <b>Blue/Green</b> - The update requires a blue/green deployment.</p> </li>
    /// <li> <p> <b>DynamicUpdate</b> - No blue/green deployment required</p> </li>
    /// <li> <p> <b>Undetermined</b> - The domain is in the middle of an update and can't predict the deployment type. Try again after the update is complete.</p> </li>
    /// <li> <p> <b>None</b> - The request doesn't include any configuration changes.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub deployment_type: std::option::Option<std::string::String>,
    /// <p>A message corresponding to the deployment type.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
}
impl DryRunResults {
    /// <p> Specifies the way in which OpenSearch Service will apply an update. Possible values are:</p>
    /// <ul>
    /// <li> <p> <b>Blue/Green</b> - The update requires a blue/green deployment.</p> </li>
    /// <li> <p> <b>DynamicUpdate</b> - No blue/green deployment required</p> </li>
    /// <li> <p> <b>Undetermined</b> - The domain is in the middle of an update and can't predict the deployment type. Try again after the update is complete.</p> </li>
    /// <li> <p> <b>None</b> - The request doesn't include any configuration changes.</p> </li>
    /// </ul>
    pub fn deployment_type(&self) -> std::option::Option<&str> {
        self.deployment_type.as_deref()
    }
    /// <p>A message corresponding to the deployment type.</p>
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
/// See [`DryRunResults`](crate::model::DryRunResults).
pub mod dry_run_results {

    /// A builder for [`DryRunResults`](crate::model::DryRunResults).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) deployment_type: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> Specifies the way in which OpenSearch Service will apply an update. Possible values are:</p>
        /// <ul>
        /// <li> <p> <b>Blue/Green</b> - The update requires a blue/green deployment.</p> </li>
        /// <li> <p> <b>DynamicUpdate</b> - No blue/green deployment required</p> </li>
        /// <li> <p> <b>Undetermined</b> - The domain is in the middle of an update and can't predict the deployment type. Try again after the update is complete.</p> </li>
        /// <li> <p> <b>None</b> - The request doesn't include any configuration changes.</p> </li>
        /// </ul>
        pub fn deployment_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.deployment_type = Some(input.into());
            self
        }
        /// <p> Specifies the way in which OpenSearch Service will apply an update. Possible values are:</p>
        /// <ul>
        /// <li> <p> <b>Blue/Green</b> - The update requires a blue/green deployment.</p> </li>
        /// <li> <p> <b>DynamicUpdate</b> - No blue/green deployment required</p> </li>
        /// <li> <p> <b>Undetermined</b> - The domain is in the middle of an update and can't predict the deployment type. Try again after the update is complete.</p> </li>
        /// <li> <p> <b>None</b> - The request doesn't include any configuration changes.</p> </li>
        /// </ul>
        pub fn set_deployment_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.deployment_type = input;
            self
        }
        /// <p>A message corresponding to the deployment type.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A message corresponding to the deployment type.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DryRunResults`](crate::model::DryRunResults).
        pub fn build(self) -> crate::model::DryRunResults {
            crate::model::DryRunResults {
                deployment_type: self.deployment_type,
                message: self.message,
            }
        }
    }
}
impl DryRunResults {
    /// Creates a new builder-style object to manufacture [`DryRunResults`](crate::model::DryRunResults).
    pub fn builder() -> crate::model::dry_run_results::Builder {
        crate::model::dry_run_results::Builder::default()
    }
}

/// <p>Container for the configuration of an OpenSearch Service domain.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DomainConfig {
    /// <p>The OpenSearch or Elasticsearch version that the domain is running.</p>
    #[doc(hidden)]
    pub engine_version: std::option::Option<crate::model::VersionStatus>,
    /// <p>Container for the cluster configuration of a the domain.</p>
    #[doc(hidden)]
    pub cluster_config: std::option::Option<crate::model::ClusterConfigStatus>,
    /// <p>Container for EBS options configured for an OpenSearch Service domain.</p>
    #[doc(hidden)]
    pub ebs_options: std::option::Option<crate::model::EbsOptionsStatus>,
    /// <p>Specifies the access policies for the domain.</p>
    #[doc(hidden)]
    pub access_policies: std::option::Option<crate::model::AccessPoliciesStatus>,
    /// <p>DEPRECATED. Container for parameters required to configure automated snapshots of domain indexes.</p>
    #[doc(hidden)]
    pub snapshot_options: std::option::Option<crate::model::SnapshotOptionsStatus>,
    /// <p>The current VPC options for the domain and the status of any updates to their configuration.</p>
    #[doc(hidden)]
    pub vpc_options: std::option::Option<crate::model::VpcDerivedInfoStatus>,
    /// <p>Container for Amazon Cognito options for the domain.</p>
    #[doc(hidden)]
    pub cognito_options: std::option::Option<crate::model::CognitoOptionsStatus>,
    /// <p>Key-value pairs to enable encryption at rest.</p>
    #[doc(hidden)]
    pub encryption_at_rest_options:
        std::option::Option<crate::model::EncryptionAtRestOptionsStatus>,
    /// <p>Whether node-to-node encryption is enabled or disabled.</p>
    #[doc(hidden)]
    pub node_to_node_encryption_options:
        std::option::Option<crate::model::NodeToNodeEncryptionOptionsStatus>,
    /// <p>Key-value pairs to specify advanced configuration options. For more information, see <a href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/createupdatedomains.html#createdomain-configure-advanced-options">Advanced options</a>.</p>
    #[doc(hidden)]
    pub advanced_options: std::option::Option<crate::model::AdvancedOptionsStatus>,
    /// <p>Key-value pairs to configure slow log publishing.</p>
    #[doc(hidden)]
    pub log_publishing_options: std::option::Option<crate::model::LogPublishingOptionsStatus>,
    /// <p>Additional options for the domain endpoint, such as whether to require HTTPS for all traffic.</p>
    #[doc(hidden)]
    pub domain_endpoint_options: std::option::Option<crate::model::DomainEndpointOptionsStatus>,
    /// <p>Container for fine-grained access control settings for the domain.</p>
    #[doc(hidden)]
    pub advanced_security_options: std::option::Option<crate::model::AdvancedSecurityOptionsStatus>,
    /// <p>Container for Auto-Tune settings for the domain.</p>
    #[doc(hidden)]
    pub auto_tune_options: std::option::Option<crate::model::AutoTuneOptionsStatus>,
    /// <p>Container for information about the progress of an existing configuration change.</p>
    #[doc(hidden)]
    pub change_progress_details: std::option::Option<crate::model::ChangeProgressDetails>,
}
impl DomainConfig {
    /// <p>The OpenSearch or Elasticsearch version that the domain is running.</p>
    pub fn engine_version(&self) -> std::option::Option<&crate::model::VersionStatus> {
        self.engine_version.as_ref()
    }
    /// <p>Container for the cluster configuration of a the domain.</p>
    pub fn cluster_config(&self) -> std::option::Option<&crate::model::ClusterConfigStatus> {
        self.cluster_config.as_ref()
    }
    /// <p>Container for EBS options configured for an OpenSearch Service domain.</p>
    pub fn ebs_options(&self) -> std::option::Option<&crate::model::EbsOptionsStatus> {
        self.ebs_options.as_ref()
    }
    /// <p>Specifies the access policies for the domain.</p>
    pub fn access_policies(&self) -> std::option::Option<&crate::model::AccessPoliciesStatus> {
        self.access_policies.as_ref()
    }
    /// <p>DEPRECATED. Container for parameters required to configure automated snapshots of domain indexes.</p>
    pub fn snapshot_options(&self) -> std::option::Option<&crate::model::SnapshotOptionsStatus> {
        self.snapshot_options.as_ref()
    }
    /// <p>The current VPC options for the domain and the status of any updates to their configuration.</p>
    pub fn vpc_options(&self) -> std::option::Option<&crate::model::VpcDerivedInfoStatus> {
        self.vpc_options.as_ref()
    }
    /// <p>Container for Amazon Cognito options for the domain.</p>
    pub fn cognito_options(&self) -> std::option::Option<&crate::model::CognitoOptionsStatus> {
        self.cognito_options.as_ref()
    }
    /// <p>Key-value pairs to enable encryption at rest.</p>
    pub fn encryption_at_rest_options(
        &self,
    ) -> std::option::Option<&crate::model::EncryptionAtRestOptionsStatus> {
        self.encryption_at_rest_options.as_ref()
    }
    /// <p>Whether node-to-node encryption is enabled or disabled.</p>
    pub fn node_to_node_encryption_options(
        &self,
    ) -> std::option::Option<&crate::model::NodeToNodeEncryptionOptionsStatus> {
        self.node_to_node_encryption_options.as_ref()
    }
    /// <p>Key-value pairs to specify advanced configuration options. For more information, see <a href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/createupdatedomains.html#createdomain-configure-advanced-options">Advanced options</a>.</p>
    pub fn advanced_options(&self) -> std::option::Option<&crate::model::AdvancedOptionsStatus> {
        self.advanced_options.as_ref()
    }
    /// <p>Key-value pairs to configure slow log publishing.</p>
    pub fn log_publishing_options(
        &self,
    ) -> std::option::Option<&crate::model::LogPublishingOptionsStatus> {
        self.log_publishing_options.as_ref()
    }
    /// <p>Additional options for the domain endpoint, such as whether to require HTTPS for all traffic.</p>
    pub fn domain_endpoint_options(
        &self,
    ) -> std::option::Option<&crate::model::DomainEndpointOptionsStatus> {
        self.domain_endpoint_options.as_ref()
    }
    /// <p>Container for fine-grained access control settings for the domain.</p>
    pub fn advanced_security_options(
        &self,
    ) -> std::option::Option<&crate::model::AdvancedSecurityOptionsStatus> {
        self.advanced_security_options.as_ref()
    }
    /// <p>Container for Auto-Tune settings for the domain.</p>
    pub fn auto_tune_options(&self) -> std::option::Option<&crate::model::AutoTuneOptionsStatus> {
        self.auto_tune_options.as_ref()
    }
    /// <p>Container for information about the progress of an existing configuration change.</p>
    pub fn change_progress_details(
        &self,
    ) -> std::option::Option<&crate::model::ChangeProgressDetails> {
        self.change_progress_details.as_ref()
    }
}
/// See [`DomainConfig`](crate::model::DomainConfig).
pub mod domain_config {

    /// A builder for [`DomainConfig`](crate::model::DomainConfig).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) engine_version: std::option::Option<crate::model::VersionStatus>,
        pub(crate) cluster_config: std::option::Option<crate::model::ClusterConfigStatus>,
        pub(crate) ebs_options: std::option::Option<crate::model::EbsOptionsStatus>,
        pub(crate) access_policies: std::option::Option<crate::model::AccessPoliciesStatus>,
        pub(crate) snapshot_options: std::option::Option<crate::model::SnapshotOptionsStatus>,
        pub(crate) vpc_options: std::option::Option<crate::model::VpcDerivedInfoStatus>,
        pub(crate) cognito_options: std::option::Option<crate::model::CognitoOptionsStatus>,
        pub(crate) encryption_at_rest_options:
            std::option::Option<crate::model::EncryptionAtRestOptionsStatus>,
        pub(crate) node_to_node_encryption_options:
            std::option::Option<crate::model::NodeToNodeEncryptionOptionsStatus>,
        pub(crate) advanced_options: std::option::Option<crate::model::AdvancedOptionsStatus>,
        pub(crate) log_publishing_options:
            std::option::Option<crate::model::LogPublishingOptionsStatus>,
        pub(crate) domain_endpoint_options:
            std::option::Option<crate::model::DomainEndpointOptionsStatus>,
        pub(crate) advanced_security_options:
            std::option::Option<crate::model::AdvancedSecurityOptionsStatus>,
        pub(crate) auto_tune_options: std::option::Option<crate::model::AutoTuneOptionsStatus>,
        pub(crate) change_progress_details:
            std::option::Option<crate::model::ChangeProgressDetails>,
    }
    impl Builder {
        /// <p>The OpenSearch or Elasticsearch version that the domain is running.</p>
        pub fn engine_version(mut self, input: crate::model::VersionStatus) -> Self {
            self.engine_version = Some(input);
            self
        }
        /// <p>The OpenSearch or Elasticsearch version that the domain is running.</p>
        pub fn set_engine_version(
            mut self,
            input: std::option::Option<crate::model::VersionStatus>,
        ) -> Self {
            self.engine_version = input;
            self
        }
        /// <p>Container for the cluster configuration of a the domain.</p>
        pub fn cluster_config(mut self, input: crate::model::ClusterConfigStatus) -> Self {
            self.cluster_config = Some(input);
            self
        }
        /// <p>Container for the cluster configuration of a the domain.</p>
        pub fn set_cluster_config(
            mut self,
            input: std::option::Option<crate::model::ClusterConfigStatus>,
        ) -> Self {
            self.cluster_config = input;
            self
        }
        /// <p>Container for EBS options configured for an OpenSearch Service domain.</p>
        pub fn ebs_options(mut self, input: crate::model::EbsOptionsStatus) -> Self {
            self.ebs_options = Some(input);
            self
        }
        /// <p>Container for EBS options configured for an OpenSearch Service domain.</p>
        pub fn set_ebs_options(
            mut self,
            input: std::option::Option<crate::model::EbsOptionsStatus>,
        ) -> Self {
            self.ebs_options = input;
            self
        }
        /// <p>Specifies the access policies for the domain.</p>
        pub fn access_policies(mut self, input: crate::model::AccessPoliciesStatus) -> Self {
            self.access_policies = Some(input);
            self
        }
        /// <p>Specifies the access policies for the domain.</p>
        pub fn set_access_policies(
            mut self,
            input: std::option::Option<crate::model::AccessPoliciesStatus>,
        ) -> Self {
            self.access_policies = input;
            self
        }
        /// <p>DEPRECATED. Container for parameters required to configure automated snapshots of domain indexes.</p>
        pub fn snapshot_options(mut self, input: crate::model::SnapshotOptionsStatus) -> Self {
            self.snapshot_options = Some(input);
            self
        }
        /// <p>DEPRECATED. Container for parameters required to configure automated snapshots of domain indexes.</p>
        pub fn set_snapshot_options(
            mut self,
            input: std::option::Option<crate::model::SnapshotOptionsStatus>,
        ) -> Self {
            self.snapshot_options = input;
            self
        }
        /// <p>The current VPC options for the domain and the status of any updates to their configuration.</p>
        pub fn vpc_options(mut self, input: crate::model::VpcDerivedInfoStatus) -> Self {
            self.vpc_options = Some(input);
            self
        }
        /// <p>The current VPC options for the domain and the status of any updates to their configuration.</p>
        pub fn set_vpc_options(
            mut self,
            input: std::option::Option<crate::model::VpcDerivedInfoStatus>,
        ) -> Self {
            self.vpc_options = input;
            self
        }
        /// <p>Container for Amazon Cognito options for the domain.</p>
        pub fn cognito_options(mut self, input: crate::model::CognitoOptionsStatus) -> Self {
            self.cognito_options = Some(input);
            self
        }
        /// <p>Container for Amazon Cognito options for the domain.</p>
        pub fn set_cognito_options(
            mut self,
            input: std::option::Option<crate::model::CognitoOptionsStatus>,
        ) -> Self {
            self.cognito_options = input;
            self
        }
        /// <p>Key-value pairs to enable encryption at rest.</p>
        pub fn encryption_at_rest_options(
            mut self,
            input: crate::model::EncryptionAtRestOptionsStatus,
        ) -> Self {
            self.encryption_at_rest_options = Some(input);
            self
        }
        /// <p>Key-value pairs to enable encryption at rest.</p>
        pub fn set_encryption_at_rest_options(
            mut self,
            input: std::option::Option<crate::model::EncryptionAtRestOptionsStatus>,
        ) -> Self {
            self.encryption_at_rest_options = input;
            self
        }
        /// <p>Whether node-to-node encryption is enabled or disabled.</p>
        pub fn node_to_node_encryption_options(
            mut self,
            input: crate::model::NodeToNodeEncryptionOptionsStatus,
        ) -> Self {
            self.node_to_node_encryption_options = Some(input);
            self
        }
        /// <p>Whether node-to-node encryption is enabled or disabled.</p>
        pub fn set_node_to_node_encryption_options(
            mut self,
            input: std::option::Option<crate::model::NodeToNodeEncryptionOptionsStatus>,
        ) -> Self {
            self.node_to_node_encryption_options = input;
            self
        }
        /// <p>Key-value pairs to specify advanced configuration options. For more information, see <a href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/createupdatedomains.html#createdomain-configure-advanced-options">Advanced options</a>.</p>
        pub fn advanced_options(mut self, input: crate::model::AdvancedOptionsStatus) -> Self {
            self.advanced_options = Some(input);
            self
        }
        /// <p>Key-value pairs to specify advanced configuration options. For more information, see <a href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/createupdatedomains.html#createdomain-configure-advanced-options">Advanced options</a>.</p>
        pub fn set_advanced_options(
            mut self,
            input: std::option::Option<crate::model::AdvancedOptionsStatus>,
        ) -> Self {
            self.advanced_options = input;
            self
        }
        /// <p>Key-value pairs to configure slow log publishing.</p>
        pub fn log_publishing_options(
            mut self,
            input: crate::model::LogPublishingOptionsStatus,
        ) -> Self {
            self.log_publishing_options = Some(input);
            self
        }
        /// <p>Key-value pairs to configure slow log publishing.</p>
        pub fn set_log_publishing_options(
            mut self,
            input: std::option::Option<crate::model::LogPublishingOptionsStatus>,
        ) -> Self {
            self.log_publishing_options = input;
            self
        }
        /// <p>Additional options for the domain endpoint, such as whether to require HTTPS for all traffic.</p>
        pub fn domain_endpoint_options(
            mut self,
            input: crate::model::DomainEndpointOptionsStatus,
        ) -> Self {
            self.domain_endpoint_options = Some(input);
            self
        }
        /// <p>Additional options for the domain endpoint, such as whether to require HTTPS for all traffic.</p>
        pub fn set_domain_endpoint_options(
            mut self,
            input: std::option::Option<crate::model::DomainEndpointOptionsStatus>,
        ) -> Self {
            self.domain_endpoint_options = input;
            self
        }
        /// <p>Container for fine-grained access control settings for the domain.</p>
        pub fn advanced_security_options(
            mut self,
            input: crate::model::AdvancedSecurityOptionsStatus,
        ) -> Self {
            self.advanced_security_options = Some(input);
            self
        }
        /// <p>Container for fine-grained access control settings for the domain.</p>
        pub fn set_advanced_security_options(
            mut self,
            input: std::option::Option<crate::model::AdvancedSecurityOptionsStatus>,
        ) -> Self {
            self.advanced_security_options = input;
            self
        }
        /// <p>Container for Auto-Tune settings for the domain.</p>
        pub fn auto_tune_options(mut self, input: crate::model::AutoTuneOptionsStatus) -> Self {
            self.auto_tune_options = Some(input);
            self
        }
        /// <p>Container for Auto-Tune settings for the domain.</p>
        pub fn set_auto_tune_options(
            mut self,
            input: std::option::Option<crate::model::AutoTuneOptionsStatus>,
        ) -> Self {
            self.auto_tune_options = input;
            self
        }
        /// <p>Container for information about the progress of an existing configuration change.</p>
        pub fn change_progress_details(
            mut self,
            input: crate::model::ChangeProgressDetails,
        ) -> Self {
            self.change_progress_details = Some(input);
            self
        }
        /// <p>Container for information about the progress of an existing configuration change.</p>
        pub fn set_change_progress_details(
            mut self,
            input: std::option::Option<crate::model::ChangeProgressDetails>,
        ) -> Self {
            self.change_progress_details = input;
            self
        }
        /// Consumes the builder and constructs a [`DomainConfig`](crate::model::DomainConfig).
        pub fn build(self) -> crate::model::DomainConfig {
            crate::model::DomainConfig {
                engine_version: self.engine_version,
                cluster_config: self.cluster_config,
                ebs_options: self.ebs_options,
                access_policies: self.access_policies,
                snapshot_options: self.snapshot_options,
                vpc_options: self.vpc_options,
                cognito_options: self.cognito_options,
                encryption_at_rest_options: self.encryption_at_rest_options,
                node_to_node_encryption_options: self.node_to_node_encryption_options,
                advanced_options: self.advanced_options,
                log_publishing_options: self.log_publishing_options,
                domain_endpoint_options: self.domain_endpoint_options,
                advanced_security_options: self.advanced_security_options,
                auto_tune_options: self.auto_tune_options,
                change_progress_details: self.change_progress_details,
            }
        }
    }
}
impl DomainConfig {
    /// Creates a new builder-style object to manufacture [`DomainConfig`](crate::model::DomainConfig).
    pub fn builder() -> crate::model::domain_config::Builder {
        crate::model::domain_config::Builder::default()
    }
}

/// <p>The Auto-Tune status for the domain.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AutoTuneOptionsStatus {
    /// <p>Auto-Tune settings for updating a domain.</p>
    #[doc(hidden)]
    pub options: std::option::Option<crate::model::AutoTuneOptions>,
    /// <p>The current status of Auto-Tune for a domain.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::AutoTuneStatus>,
}
impl AutoTuneOptionsStatus {
    /// <p>Auto-Tune settings for updating a domain.</p>
    pub fn options(&self) -> std::option::Option<&crate::model::AutoTuneOptions> {
        self.options.as_ref()
    }
    /// <p>The current status of Auto-Tune for a domain.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::AutoTuneStatus> {
        self.status.as_ref()
    }
}
/// See [`AutoTuneOptionsStatus`](crate::model::AutoTuneOptionsStatus).
pub mod auto_tune_options_status {

    /// A builder for [`AutoTuneOptionsStatus`](crate::model::AutoTuneOptionsStatus).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) options: std::option::Option<crate::model::AutoTuneOptions>,
        pub(crate) status: std::option::Option<crate::model::AutoTuneStatus>,
    }
    impl Builder {
        /// <p>Auto-Tune settings for updating a domain.</p>
        pub fn options(mut self, input: crate::model::AutoTuneOptions) -> Self {
            self.options = Some(input);
            self
        }
        /// <p>Auto-Tune settings for updating a domain.</p>
        pub fn set_options(
            mut self,
            input: std::option::Option<crate::model::AutoTuneOptions>,
        ) -> Self {
            self.options = input;
            self
        }
        /// <p>The current status of Auto-Tune for a domain.</p>
        pub fn status(mut self, input: crate::model::AutoTuneStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The current status of Auto-Tune for a domain.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::AutoTuneStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// Consumes the builder and constructs a [`AutoTuneOptionsStatus`](crate::model::AutoTuneOptionsStatus).
        pub fn build(self) -> crate::model::AutoTuneOptionsStatus {
            crate::model::AutoTuneOptionsStatus {
                options: self.options,
                status: self.status,
            }
        }
    }
}
impl AutoTuneOptionsStatus {
    /// Creates a new builder-style object to manufacture [`AutoTuneOptionsStatus`](crate::model::AutoTuneOptionsStatus).
    pub fn builder() -> crate::model::auto_tune_options_status::Builder {
        crate::model::auto_tune_options_status::Builder::default()
    }
}

/// <p>The current status of Auto-Tune for the domain. For more information, see <a href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/auto-tune.html">Auto-Tune for Amazon OpenSearch Service</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AutoTuneStatus {
    /// <p>Date and time when Auto-Tune was enabled for the domain.</p>
    #[doc(hidden)]
    pub creation_date: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Date and time when the Auto-Tune options were last updated for the domain.</p>
    #[doc(hidden)]
    pub update_date: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The latest version of the Auto-Tune options.</p>
    #[doc(hidden)]
    pub update_version: i32,
    /// <p>The current state of Auto-Tune on the domain.</p>
    #[doc(hidden)]
    pub state: std::option::Option<crate::model::AutoTuneState>,
    /// <p>Any errors that occurred while enabling or disabling Auto-Tune.</p>
    #[doc(hidden)]
    pub error_message: std::option::Option<std::string::String>,
    /// <p>Indicates whether the domain is being deleted.</p>
    #[doc(hidden)]
    pub pending_deletion: std::option::Option<bool>,
}
impl AutoTuneStatus {
    /// <p>Date and time when Auto-Tune was enabled for the domain.</p>
    pub fn creation_date(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_date.as_ref()
    }
    /// <p>Date and time when the Auto-Tune options were last updated for the domain.</p>
    pub fn update_date(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.update_date.as_ref()
    }
    /// <p>The latest version of the Auto-Tune options.</p>
    pub fn update_version(&self) -> i32 {
        self.update_version
    }
    /// <p>The current state of Auto-Tune on the domain.</p>
    pub fn state(&self) -> std::option::Option<&crate::model::AutoTuneState> {
        self.state.as_ref()
    }
    /// <p>Any errors that occurred while enabling or disabling Auto-Tune.</p>
    pub fn error_message(&self) -> std::option::Option<&str> {
        self.error_message.as_deref()
    }
    /// <p>Indicates whether the domain is being deleted.</p>
    pub fn pending_deletion(&self) -> std::option::Option<bool> {
        self.pending_deletion
    }
}
/// See [`AutoTuneStatus`](crate::model::AutoTuneStatus).
pub mod auto_tune_status {

    /// A builder for [`AutoTuneStatus`](crate::model::AutoTuneStatus).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) creation_date: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) update_date: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) update_version: std::option::Option<i32>,
        pub(crate) state: std::option::Option<crate::model::AutoTuneState>,
        pub(crate) error_message: std::option::Option<std::string::String>,
        pub(crate) pending_deletion: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>Date and time when Auto-Tune was enabled for the domain.</p>
        pub fn creation_date(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_date = Some(input);
            self
        }
        /// <p>Date and time when Auto-Tune was enabled for the domain.</p>
        pub fn set_creation_date(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_date = input;
            self
        }
        /// <p>Date and time when the Auto-Tune options were last updated for the domain.</p>
        pub fn update_date(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.update_date = Some(input);
            self
        }
        /// <p>Date and time when the Auto-Tune options were last updated for the domain.</p>
        pub fn set_update_date(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.update_date = input;
            self
        }
        /// <p>The latest version of the Auto-Tune options.</p>
        pub fn update_version(mut self, input: i32) -> Self {
            self.update_version = Some(input);
            self
        }
        /// <p>The latest version of the Auto-Tune options.</p>
        pub fn set_update_version(mut self, input: std::option::Option<i32>) -> Self {
            self.update_version = input;
            self
        }
        /// <p>The current state of Auto-Tune on the domain.</p>
        pub fn state(mut self, input: crate::model::AutoTuneState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The current state of Auto-Tune on the domain.</p>
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::AutoTuneState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// <p>Any errors that occurred while enabling or disabling Auto-Tune.</p>
        pub fn error_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_message = Some(input.into());
            self
        }
        /// <p>Any errors that occurred while enabling or disabling Auto-Tune.</p>
        pub fn set_error_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.error_message = input;
            self
        }
        /// <p>Indicates whether the domain is being deleted.</p>
        pub fn pending_deletion(mut self, input: bool) -> Self {
            self.pending_deletion = Some(input);
            self
        }
        /// <p>Indicates whether the domain is being deleted.</p>
        pub fn set_pending_deletion(mut self, input: std::option::Option<bool>) -> Self {
            self.pending_deletion = input;
            self
        }
        /// Consumes the builder and constructs a [`AutoTuneStatus`](crate::model::AutoTuneStatus).
        pub fn build(self) -> crate::model::AutoTuneStatus {
            crate::model::AutoTuneStatus {
                creation_date: self.creation_date,
                update_date: self.update_date,
                update_version: self.update_version.unwrap_or_default(),
                state: self.state,
                error_message: self.error_message,
                pending_deletion: self.pending_deletion,
            }
        }
    }
}
impl AutoTuneStatus {
    /// Creates a new builder-style object to manufacture [`AutoTuneStatus`](crate::model::AutoTuneStatus).
    pub fn builder() -> crate::model::auto_tune_status::Builder {
        crate::model::auto_tune_status::Builder::default()
    }
}

/// When writing a match expression against `AutoTuneState`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let autotunestate = unimplemented!();
/// match autotunestate {
///     AutoTuneState::Disabled => { /* ... */ },
///     AutoTuneState::DisabledAndRollbackComplete => { /* ... */ },
///     AutoTuneState::DisabledAndRollbackError => { /* ... */ },
///     AutoTuneState::DisabledAndRollbackInProgress => { /* ... */ },
///     AutoTuneState::DisabledAndRollbackScheduled => { /* ... */ },
///     AutoTuneState::DisableInProgress => { /* ... */ },
///     AutoTuneState::Enabled => { /* ... */ },
///     AutoTuneState::EnableInProgress => { /* ... */ },
///     AutoTuneState::Error => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `autotunestate` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `AutoTuneState::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `AutoTuneState::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `AutoTuneState::NewFeature` is defined.
/// Specifically, when `autotunestate` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `AutoTuneState::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
/// <p>The Auto-Tune state for the domain. For valid states see <a href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/auto-tune.html"> Auto-Tune for Amazon OpenSearch Service</a>.
/// </p>
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AutoTuneState {
    #[allow(missing_docs)] // documentation missing in model
    Disabled,
    #[allow(missing_docs)] // documentation missing in model
    DisabledAndRollbackComplete,
    #[allow(missing_docs)] // documentation missing in model
    DisabledAndRollbackError,
    #[allow(missing_docs)] // documentation missing in model
    DisabledAndRollbackInProgress,
    #[allow(missing_docs)] // documentation missing in model
    DisabledAndRollbackScheduled,
    #[allow(missing_docs)] // documentation missing in model
    DisableInProgress,
    #[allow(missing_docs)] // documentation missing in model
    Enabled,
    #[allow(missing_docs)] // documentation missing in model
    EnableInProgress,
    #[allow(missing_docs)] // documentation missing in model
    Error,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for AutoTuneState {
    fn from(s: &str) -> Self {
        match s {
            "DISABLED" => AutoTuneState::Disabled,
            "DISABLED_AND_ROLLBACK_COMPLETE" => AutoTuneState::DisabledAndRollbackComplete,
            "DISABLED_AND_ROLLBACK_ERROR" => AutoTuneState::DisabledAndRollbackError,
            "DISABLED_AND_ROLLBACK_IN_PROGRESS" => AutoTuneState::DisabledAndRollbackInProgress,
            "DISABLED_AND_ROLLBACK_SCHEDULED" => AutoTuneState::DisabledAndRollbackScheduled,
            "DISABLE_IN_PROGRESS" => AutoTuneState::DisableInProgress,
            "ENABLED" => AutoTuneState::Enabled,
            "ENABLE_IN_PROGRESS" => AutoTuneState::EnableInProgress,
            "ERROR" => AutoTuneState::Error,
            other => AutoTuneState::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for AutoTuneState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AutoTuneState::from(s))
    }
}
impl AutoTuneState {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            AutoTuneState::Disabled => "DISABLED",
            AutoTuneState::DisabledAndRollbackComplete => "DISABLED_AND_ROLLBACK_COMPLETE",
            AutoTuneState::DisabledAndRollbackError => "DISABLED_AND_ROLLBACK_ERROR",
            AutoTuneState::DisabledAndRollbackInProgress => "DISABLED_AND_ROLLBACK_IN_PROGRESS",
            AutoTuneState::DisabledAndRollbackScheduled => "DISABLED_AND_ROLLBACK_SCHEDULED",
            AutoTuneState::DisableInProgress => "DISABLE_IN_PROGRESS",
            AutoTuneState::Enabled => "ENABLED",
            AutoTuneState::EnableInProgress => "ENABLE_IN_PROGRESS",
            AutoTuneState::Error => "ERROR",
            AutoTuneState::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "DISABLED",
            "DISABLED_AND_ROLLBACK_COMPLETE",
            "DISABLED_AND_ROLLBACK_ERROR",
            "DISABLED_AND_ROLLBACK_IN_PROGRESS",
            "DISABLED_AND_ROLLBACK_SCHEDULED",
            "DISABLE_IN_PROGRESS",
            "ENABLED",
            "ENABLE_IN_PROGRESS",
            "ERROR",
        ]
    }
}
impl AsRef<str> for AutoTuneState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Auto-Tune settings when updating a domain. For more information, see <a href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/auto-tune.html">Auto-Tune for Amazon OpenSearch Service</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AutoTuneOptions {
    /// <p>Whether Auto-Tune is enabled or disabled.</p>
    #[doc(hidden)]
    pub desired_state: std::option::Option<crate::model::AutoTuneDesiredState>,
    /// <p>When disabling Auto-Tune, specify <code>NO_ROLLBACK</code> to retain all prior Auto-Tune settings or <code>DEFAULT_ROLLBACK</code> to revert to the OpenSearch Service defaults. If you specify <code>DEFAULT_ROLLBACK</code>, you must include a <code>MaintenanceSchedule</code> in the request. Otherwise, OpenSearch Service is unable to perform the rollback.</p>
    #[doc(hidden)]
    pub rollback_on_disable: std::option::Option<crate::model::RollbackOnDisable>,
    /// <p>A list of maintenance schedules during which Auto-Tune can deploy changes.</p>
    #[doc(hidden)]
    pub maintenance_schedules:
        std::option::Option<std::vec::Vec<crate::model::AutoTuneMaintenanceSchedule>>,
}
impl AutoTuneOptions {
    /// <p>Whether Auto-Tune is enabled or disabled.</p>
    pub fn desired_state(&self) -> std::option::Option<&crate::model::AutoTuneDesiredState> {
        self.desired_state.as_ref()
    }
    /// <p>When disabling Auto-Tune, specify <code>NO_ROLLBACK</code> to retain all prior Auto-Tune settings or <code>DEFAULT_ROLLBACK</code> to revert to the OpenSearch Service defaults. If you specify <code>DEFAULT_ROLLBACK</code>, you must include a <code>MaintenanceSchedule</code> in the request. Otherwise, OpenSearch Service is unable to perform the rollback.</p>
    pub fn rollback_on_disable(&self) -> std::option::Option<&crate::model::RollbackOnDisable> {
        self.rollback_on_disable.as_ref()
    }
    /// <p>A list of maintenance schedules during which Auto-Tune can deploy changes.</p>
    pub fn maintenance_schedules(
        &self,
    ) -> std::option::Option<&[crate::model::AutoTuneMaintenanceSchedule]> {
        self.maintenance_schedules.as_deref()
    }
}
/// See [`AutoTuneOptions`](crate::model::AutoTuneOptions).
pub mod auto_tune_options {

    /// A builder for [`AutoTuneOptions`](crate::model::AutoTuneOptions).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) desired_state: std::option::Option<crate::model::AutoTuneDesiredState>,
        pub(crate) rollback_on_disable: std::option::Option<crate::model::RollbackOnDisable>,
        pub(crate) maintenance_schedules:
            std::option::Option<std::vec::Vec<crate::model::AutoTuneMaintenanceSchedule>>,
    }
    impl Builder {
        /// <p>Whether Auto-Tune is enabled or disabled.</p>
        pub fn desired_state(mut self, input: crate::model::AutoTuneDesiredState) -> Self {
            self.desired_state = Some(input);
            self
        }
        /// <p>Whether Auto-Tune is enabled or disabled.</p>
        pub fn set_desired_state(
            mut self,
            input: std::option::Option<crate::model::AutoTuneDesiredState>,
        ) -> Self {
            self.desired_state = input;
            self
        }
        /// <p>When disabling Auto-Tune, specify <code>NO_ROLLBACK</code> to retain all prior Auto-Tune settings or <code>DEFAULT_ROLLBACK</code> to revert to the OpenSearch Service defaults. If you specify <code>DEFAULT_ROLLBACK</code>, you must include a <code>MaintenanceSchedule</code> in the request. Otherwise, OpenSearch Service is unable to perform the rollback.</p>
        pub fn rollback_on_disable(mut self, input: crate::model::RollbackOnDisable) -> Self {
            self.rollback_on_disable = Some(input);
            self
        }
        /// <p>When disabling Auto-Tune, specify <code>NO_ROLLBACK</code> to retain all prior Auto-Tune settings or <code>DEFAULT_ROLLBACK</code> to revert to the OpenSearch Service defaults. If you specify <code>DEFAULT_ROLLBACK</code>, you must include a <code>MaintenanceSchedule</code> in the request. Otherwise, OpenSearch Service is unable to perform the rollback.</p>
        pub fn set_rollback_on_disable(
            mut self,
            input: std::option::Option<crate::model::RollbackOnDisable>,
        ) -> Self {
            self.rollback_on_disable = input;
            self
        }
        /// Appends an item to `maintenance_schedules`.
        ///
        /// To override the contents of this collection use [`set_maintenance_schedules`](Self::set_maintenance_schedules).
        ///
        /// <p>A list of maintenance schedules during which Auto-Tune can deploy changes.</p>
        pub fn maintenance_schedules(
            mut self,
            input: crate::model::AutoTuneMaintenanceSchedule,
        ) -> Self {
            let mut v = self.maintenance_schedules.unwrap_or_default();
            v.push(input);
            self.maintenance_schedules = Some(v);
            self
        }
        /// <p>A list of maintenance schedules during which Auto-Tune can deploy changes.</p>
        pub fn set_maintenance_schedules(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AutoTuneMaintenanceSchedule>>,
        ) -> Self {
            self.maintenance_schedules = input;
            self
        }
        /// Consumes the builder and constructs a [`AutoTuneOptions`](crate::model::AutoTuneOptions).
        pub fn build(self) -> crate::model::AutoTuneOptions {
            crate::model::AutoTuneOptions {
                desired_state: self.desired_state,
                rollback_on_disable: self.rollback_on_disable,
                maintenance_schedules: self.maintenance_schedules,
            }
        }
    }
}
impl AutoTuneOptions {
    /// Creates a new builder-style object to manufacture [`AutoTuneOptions`](crate::model::AutoTuneOptions).
    pub fn builder() -> crate::model::auto_tune_options::Builder {
        crate::model::auto_tune_options::Builder::default()
    }
}

/// <p>The Auto-Tune maintenance schedule. For more information, see <a href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/auto-tune.html">Auto-Tune for Amazon OpenSearch Service</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AutoTuneMaintenanceSchedule {
    /// <p>The Epoch timestamp at which the Auto-Tune maintenance schedule starts.</p>
    #[doc(hidden)]
    pub start_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The duration of the maintenance schedule. For example, <code>"Duration": {"Value": 2, "Unit": "HOURS"}</code>.</p>
    #[doc(hidden)]
    pub duration: std::option::Option<crate::model::Duration>,
    /// <p>A cron expression for a recurring maintenance schedule during which Auto-Tune can deploy changes.</p>
    #[doc(hidden)]
    pub cron_expression_for_recurrence: std::option::Option<std::string::String>,
}
impl AutoTuneMaintenanceSchedule {
    /// <p>The Epoch timestamp at which the Auto-Tune maintenance schedule starts.</p>
    pub fn start_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.start_at.as_ref()
    }
    /// <p>The duration of the maintenance schedule. For example, <code>"Duration": {"Value": 2, "Unit": "HOURS"}</code>.</p>
    pub fn duration(&self) -> std::option::Option<&crate::model::Duration> {
        self.duration.as_ref()
    }
    /// <p>A cron expression for a recurring maintenance schedule during which Auto-Tune can deploy changes.</p>
    pub fn cron_expression_for_recurrence(&self) -> std::option::Option<&str> {
        self.cron_expression_for_recurrence.as_deref()
    }
}
/// See [`AutoTuneMaintenanceSchedule`](crate::model::AutoTuneMaintenanceSchedule).
pub mod auto_tune_maintenance_schedule {

    /// A builder for [`AutoTuneMaintenanceSchedule`](crate::model::AutoTuneMaintenanceSchedule).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) start_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) duration: std::option::Option<crate::model::Duration>,
        pub(crate) cron_expression_for_recurrence: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Epoch timestamp at which the Auto-Tune maintenance schedule starts.</p>
        pub fn start_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.start_at = Some(input);
            self
        }
        /// <p>The Epoch timestamp at which the Auto-Tune maintenance schedule starts.</p>
        pub fn set_start_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.start_at = input;
            self
        }
        /// <p>The duration of the maintenance schedule. For example, <code>"Duration": {"Value": 2, "Unit": "HOURS"}</code>.</p>
        pub fn duration(mut self, input: crate::model::Duration) -> Self {
            self.duration = Some(input);
            self
        }
        /// <p>The duration of the maintenance schedule. For example, <code>"Duration": {"Value": 2, "Unit": "HOURS"}</code>.</p>
        pub fn set_duration(mut self, input: std::option::Option<crate::model::Duration>) -> Self {
            self.duration = input;
            self
        }
        /// <p>A cron expression for a recurring maintenance schedule during which Auto-Tune can deploy changes.</p>
        pub fn cron_expression_for_recurrence(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.cron_expression_for_recurrence = Some(input.into());
            self
        }
        /// <p>A cron expression for a recurring maintenance schedule during which Auto-Tune can deploy changes.</p>
        pub fn set_cron_expression_for_recurrence(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.cron_expression_for_recurrence = input;
            self
        }
        /// Consumes the builder and constructs a [`AutoTuneMaintenanceSchedule`](crate::model::AutoTuneMaintenanceSchedule).
        pub fn build(self) -> crate::model::AutoTuneMaintenanceSchedule {
            crate::model::AutoTuneMaintenanceSchedule {
                start_at: self.start_at,
                duration: self.duration,
                cron_expression_for_recurrence: self.cron_expression_for_recurrence,
            }
        }
    }
}
impl AutoTuneMaintenanceSchedule {
    /// Creates a new builder-style object to manufacture [`AutoTuneMaintenanceSchedule`](crate::model::AutoTuneMaintenanceSchedule).
    pub fn builder() -> crate::model::auto_tune_maintenance_schedule::Builder {
        crate::model::auto_tune_maintenance_schedule::Builder::default()
    }
}

/// <p>The duration of a maintenance schedule. For more information, see <a href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/auto-tune.html">Auto-Tune for Amazon OpenSearch Service</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Duration {
    /// <p>Integer to specify the value of a maintenance schedule duration.</p>
    #[doc(hidden)]
    pub value: i64,
    /// <p>The unit of measurement for the duration of a maintenance schedule.</p>
    #[doc(hidden)]
    pub unit: std::option::Option<crate::model::TimeUnit>,
}
impl Duration {
    /// <p>Integer to specify the value of a maintenance schedule duration.</p>
    pub fn value(&self) -> i64 {
        self.value
    }
    /// <p>The unit of measurement for the duration of a maintenance schedule.</p>
    pub fn unit(&self) -> std::option::Option<&crate::model::TimeUnit> {
        self.unit.as_ref()
    }
}
/// See [`Duration`](crate::model::Duration).
pub mod duration {

    /// A builder for [`Duration`](crate::model::Duration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) value: std::option::Option<i64>,
        pub(crate) unit: std::option::Option<crate::model::TimeUnit>,
    }
    impl Builder {
        /// <p>Integer to specify the value of a maintenance schedule duration.</p>
        pub fn value(mut self, input: i64) -> Self {
            self.value = Some(input);
            self
        }
        /// <p>Integer to specify the value of a maintenance schedule duration.</p>
        pub fn set_value(mut self, input: std::option::Option<i64>) -> Self {
            self.value = input;
            self
        }
        /// <p>The unit of measurement for the duration of a maintenance schedule.</p>
        pub fn unit(mut self, input: crate::model::TimeUnit) -> Self {
            self.unit = Some(input);
            self
        }
        /// <p>The unit of measurement for the duration of a maintenance schedule.</p>
        pub fn set_unit(mut self, input: std::option::Option<crate::model::TimeUnit>) -> Self {
            self.unit = input;
            self
        }
        /// Consumes the builder and constructs a [`Duration`](crate::model::Duration).
        pub fn build(self) -> crate::model::Duration {
            crate::model::Duration {
                value: self.value.unwrap_or_default(),
                unit: self.unit,
            }
        }
    }
}
impl Duration {
    /// Creates a new builder-style object to manufacture [`Duration`](crate::model::Duration).
    pub fn builder() -> crate::model::duration::Builder {
        crate::model::duration::Builder::default()
    }
}

/// When writing a match expression against `TimeUnit`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let timeunit = unimplemented!();
/// match timeunit {
///     TimeUnit::Hours => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `timeunit` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `TimeUnit::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `TimeUnit::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `TimeUnit::NewFeature` is defined.
/// Specifically, when `timeunit` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `TimeUnit::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
/// <p>The unit of a maintenance schedule duration. Valid value is <code>HOUR</code>.</p>
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TimeUnit {
    #[allow(missing_docs)] // documentation missing in model
    Hours,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for TimeUnit {
    fn from(s: &str) -> Self {
        match s {
            "HOURS" => TimeUnit::Hours,
            other => TimeUnit::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for TimeUnit {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TimeUnit::from(s))
    }
}
impl TimeUnit {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            TimeUnit::Hours => "HOURS",
            TimeUnit::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["HOURS"]
    }
}
impl AsRef<str> for TimeUnit {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `RollbackOnDisable`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let rollbackondisable = unimplemented!();
/// match rollbackondisable {
///     RollbackOnDisable::DefaultRollback => { /* ... */ },
///     RollbackOnDisable::NoRollback => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `rollbackondisable` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `RollbackOnDisable::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `RollbackOnDisable::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `RollbackOnDisable::NewFeature` is defined.
/// Specifically, when `rollbackondisable` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `RollbackOnDisable::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
/// <p>The rollback state while disabling Auto-Tune for the domain.</p>
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum RollbackOnDisable {
    #[allow(missing_docs)] // documentation missing in model
    DefaultRollback,
    #[allow(missing_docs)] // documentation missing in model
    NoRollback,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for RollbackOnDisable {
    fn from(s: &str) -> Self {
        match s {
            "DEFAULT_ROLLBACK" => RollbackOnDisable::DefaultRollback,
            "NO_ROLLBACK" => RollbackOnDisable::NoRollback,
            other => {
                RollbackOnDisable::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for RollbackOnDisable {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(RollbackOnDisable::from(s))
    }
}
impl RollbackOnDisable {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            RollbackOnDisable::DefaultRollback => "DEFAULT_ROLLBACK",
            RollbackOnDisable::NoRollback => "NO_ROLLBACK",
            RollbackOnDisable::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["DEFAULT_ROLLBACK", "NO_ROLLBACK"]
    }
}
impl AsRef<str> for RollbackOnDisable {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `AutoTuneDesiredState`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let autotunedesiredstate = unimplemented!();
/// match autotunedesiredstate {
///     AutoTuneDesiredState::Disabled => { /* ... */ },
///     AutoTuneDesiredState::Enabled => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `autotunedesiredstate` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `AutoTuneDesiredState::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `AutoTuneDesiredState::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `AutoTuneDesiredState::NewFeature` is defined.
/// Specifically, when `autotunedesiredstate` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `AutoTuneDesiredState::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
/// <p>The Auto-Tune desired state. Valid values are ENABLED and DISABLED.</p>
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AutoTuneDesiredState {
    #[allow(missing_docs)] // documentation missing in model
    Disabled,
    #[allow(missing_docs)] // documentation missing in model
    Enabled,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for AutoTuneDesiredState {
    fn from(s: &str) -> Self {
        match s {
            "DISABLED" => AutoTuneDesiredState::Disabled,
            "ENABLED" => AutoTuneDesiredState::Enabled,
            other => {
                AutoTuneDesiredState::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for AutoTuneDesiredState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AutoTuneDesiredState::from(s))
    }
}
impl AutoTuneDesiredState {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            AutoTuneDesiredState::Disabled => "DISABLED",
            AutoTuneDesiredState::Enabled => "ENABLED",
            AutoTuneDesiredState::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["DISABLED", "ENABLED"]
    }
}
impl AsRef<str> for AutoTuneDesiredState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The status of fine-grained access control settings for a domain.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AdvancedSecurityOptionsStatus {
    /// <p>Container for fine-grained access control settings.</p>
    #[doc(hidden)]
    pub options: std::option::Option<crate::model::AdvancedSecurityOptions>,
    /// <p>Status of the fine-grained access control settings for a domain.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::OptionStatus>,
}
impl AdvancedSecurityOptionsStatus {
    /// <p>Container for fine-grained access control settings.</p>
    pub fn options(&self) -> std::option::Option<&crate::model::AdvancedSecurityOptions> {
        self.options.as_ref()
    }
    /// <p>Status of the fine-grained access control settings for a domain.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::OptionStatus> {
        self.status.as_ref()
    }
}
/// See [`AdvancedSecurityOptionsStatus`](crate::model::AdvancedSecurityOptionsStatus).
pub mod advanced_security_options_status {

    /// A builder for [`AdvancedSecurityOptionsStatus`](crate::model::AdvancedSecurityOptionsStatus).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) options: std::option::Option<crate::model::AdvancedSecurityOptions>,
        pub(crate) status: std::option::Option<crate::model::OptionStatus>,
    }
    impl Builder {
        /// <p>Container for fine-grained access control settings.</p>
        pub fn options(mut self, input: crate::model::AdvancedSecurityOptions) -> Self {
            self.options = Some(input);
            self
        }
        /// <p>Container for fine-grained access control settings.</p>
        pub fn set_options(
            mut self,
            input: std::option::Option<crate::model::AdvancedSecurityOptions>,
        ) -> Self {
            self.options = input;
            self
        }
        /// <p>Status of the fine-grained access control settings for a domain.</p>
        pub fn status(mut self, input: crate::model::OptionStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>Status of the fine-grained access control settings for a domain.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::OptionStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// Consumes the builder and constructs a [`AdvancedSecurityOptionsStatus`](crate::model::AdvancedSecurityOptionsStatus).
        pub fn build(self) -> crate::model::AdvancedSecurityOptionsStatus {
            crate::model::AdvancedSecurityOptionsStatus {
                options: self.options,
                status: self.status,
            }
        }
    }
}
impl AdvancedSecurityOptionsStatus {
    /// Creates a new builder-style object to manufacture [`AdvancedSecurityOptionsStatus`](crate::model::AdvancedSecurityOptionsStatus).
    pub fn builder() -> crate::model::advanced_security_options_status::Builder {
        crate::model::advanced_security_options_status::Builder::default()
    }
}

/// <p>Provides the current status of an entity.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct OptionStatus {
    /// <p>The timestamp when the entity was created.</p>
    #[doc(hidden)]
    pub creation_date: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The timestamp of the last time the entity was updated.</p>
    #[doc(hidden)]
    pub update_date: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The latest version of the entity.</p>
    #[doc(hidden)]
    pub update_version: i32,
    /// <p>The state of the entity.</p>
    #[doc(hidden)]
    pub state: std::option::Option<crate::model::OptionState>,
    /// <p>Indicates whether the entity is being deleted.</p>
    #[doc(hidden)]
    pub pending_deletion: std::option::Option<bool>,
}
impl OptionStatus {
    /// <p>The timestamp when the entity was created.</p>
    pub fn creation_date(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_date.as_ref()
    }
    /// <p>The timestamp of the last time the entity was updated.</p>
    pub fn update_date(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.update_date.as_ref()
    }
    /// <p>The latest version of the entity.</p>
    pub fn update_version(&self) -> i32 {
        self.update_version
    }
    /// <p>The state of the entity.</p>
    pub fn state(&self) -> std::option::Option<&crate::model::OptionState> {
        self.state.as_ref()
    }
    /// <p>Indicates whether the entity is being deleted.</p>
    pub fn pending_deletion(&self) -> std::option::Option<bool> {
        self.pending_deletion
    }
}
/// See [`OptionStatus`](crate::model::OptionStatus).
pub mod option_status {

    /// A builder for [`OptionStatus`](crate::model::OptionStatus).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) creation_date: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) update_date: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) update_version: std::option::Option<i32>,
        pub(crate) state: std::option::Option<crate::model::OptionState>,
        pub(crate) pending_deletion: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The timestamp when the entity was created.</p>
        pub fn creation_date(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_date = Some(input);
            self
        }
        /// <p>The timestamp when the entity was created.</p>
        pub fn set_creation_date(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_date = input;
            self
        }
        /// <p>The timestamp of the last time the entity was updated.</p>
        pub fn update_date(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.update_date = Some(input);
            self
        }
        /// <p>The timestamp of the last time the entity was updated.</p>
        pub fn set_update_date(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.update_date = input;
            self
        }
        /// <p>The latest version of the entity.</p>
        pub fn update_version(mut self, input: i32) -> Self {
            self.update_version = Some(input);
            self
        }
        /// <p>The latest version of the entity.</p>
        pub fn set_update_version(mut self, input: std::option::Option<i32>) -> Self {
            self.update_version = input;
            self
        }
        /// <p>The state of the entity.</p>
        pub fn state(mut self, input: crate::model::OptionState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The state of the entity.</p>
        pub fn set_state(mut self, input: std::option::Option<crate::model::OptionState>) -> Self {
            self.state = input;
            self
        }
        /// <p>Indicates whether the entity is being deleted.</p>
        pub fn pending_deletion(mut self, input: bool) -> Self {
            self.pending_deletion = Some(input);
            self
        }
        /// <p>Indicates whether the entity is being deleted.</p>
        pub fn set_pending_deletion(mut self, input: std::option::Option<bool>) -> Self {
            self.pending_deletion = input;
            self
        }
        /// Consumes the builder and constructs a [`OptionStatus`](crate::model::OptionStatus).
        pub fn build(self) -> crate::model::OptionStatus {
            crate::model::OptionStatus {
                creation_date: self.creation_date,
                update_date: self.update_date,
                update_version: self.update_version.unwrap_or_default(),
                state: self.state,
                pending_deletion: self.pending_deletion,
            }
        }
    }
}
impl OptionStatus {
    /// Creates a new builder-style object to manufacture [`OptionStatus`](crate::model::OptionStatus).
    pub fn builder() -> crate::model::option_status::Builder {
        crate::model::option_status::Builder::default()
    }
}

/// When writing a match expression against `OptionState`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let optionstate = unimplemented!();
/// match optionstate {
///     OptionState::Active => { /* ... */ },
///     OptionState::Processing => { /* ... */ },
///     OptionState::RequiresIndexDocuments => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `optionstate` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `OptionState::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `OptionState::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `OptionState::NewFeature` is defined.
/// Specifically, when `optionstate` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `OptionState::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
/// <p>The state of a requested domain configuration change. Can be one of the following:</p>
/// <ul>
/// <li>
/// <p>
/// <b>Processing</b> - The requested change is still in
/// progress.</p>
/// </li>
/// <li>
/// <p>
/// <b>Active</b> - The requested change is processed and deployed
/// to the domain.</p>
/// </li>
/// </ul>
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum OptionState {
    #[allow(missing_docs)] // documentation missing in model
    Active,
    #[allow(missing_docs)] // documentation missing in model
    Processing,
    #[allow(missing_docs)] // documentation missing in model
    RequiresIndexDocuments,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for OptionState {
    fn from(s: &str) -> Self {
        match s {
            "Active" => OptionState::Active,
            "Processing" => OptionState::Processing,
            "RequiresIndexDocuments" => OptionState::RequiresIndexDocuments,
            other => OptionState::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for OptionState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(OptionState::from(s))
    }
}
impl OptionState {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            OptionState::Active => "Active",
            OptionState::Processing => "Processing",
            OptionState::RequiresIndexDocuments => "RequiresIndexDocuments",
            OptionState::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["Active", "Processing", "RequiresIndexDocuments"]
    }
}
impl AsRef<str> for OptionState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Container for fine-grained access control settings.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AdvancedSecurityOptions {
    /// <p>True if fine-grained access control is enabled.</p>
    #[doc(hidden)]
    pub enabled: std::option::Option<bool>,
    /// <p>True if the internal user database is enabled.</p>
    #[doc(hidden)]
    pub internal_user_database_enabled: std::option::Option<bool>,
    /// <p>Container for information about the SAML configuration for OpenSearch Dashboards.</p>
    #[doc(hidden)]
    pub saml_options: std::option::Option<crate::model::SamlOptionsOutput>,
    /// <p>Date and time when the migration period will be disabled. Only necessary when <a href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/fgac.html#fgac-enabling-existing">enabling fine-grained access control on an existing domain</a>.</p>
    #[doc(hidden)]
    pub anonymous_auth_disable_date: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>True if a 30-day migration period is enabled, during which administrators can create role mappings. Only necessary when <a href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/fgac.html#fgac-enabling-existing">enabling fine-grained access control on an existing domain</a>.</p>
    #[doc(hidden)]
    pub anonymous_auth_enabled: std::option::Option<bool>,
}
impl AdvancedSecurityOptions {
    /// <p>True if fine-grained access control is enabled.</p>
    pub fn enabled(&self) -> std::option::Option<bool> {
        self.enabled
    }
    /// <p>True if the internal user database is enabled.</p>
    pub fn internal_user_database_enabled(&self) -> std::option::Option<bool> {
        self.internal_user_database_enabled
    }
    /// <p>Container for information about the SAML configuration for OpenSearch Dashboards.</p>
    pub fn saml_options(&self) -> std::option::Option<&crate::model::SamlOptionsOutput> {
        self.saml_options.as_ref()
    }
    /// <p>Date and time when the migration period will be disabled. Only necessary when <a href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/fgac.html#fgac-enabling-existing">enabling fine-grained access control on an existing domain</a>.</p>
    pub fn anonymous_auth_disable_date(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.anonymous_auth_disable_date.as_ref()
    }
    /// <p>True if a 30-day migration period is enabled, during which administrators can create role mappings. Only necessary when <a href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/fgac.html#fgac-enabling-existing">enabling fine-grained access control on an existing domain</a>.</p>
    pub fn anonymous_auth_enabled(&self) -> std::option::Option<bool> {
        self.anonymous_auth_enabled
    }
}
/// See [`AdvancedSecurityOptions`](crate::model::AdvancedSecurityOptions).
pub mod advanced_security_options {

    /// A builder for [`AdvancedSecurityOptions`](crate::model::AdvancedSecurityOptions).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) enabled: std::option::Option<bool>,
        pub(crate) internal_user_database_enabled: std::option::Option<bool>,
        pub(crate) saml_options: std::option::Option<crate::model::SamlOptionsOutput>,
        pub(crate) anonymous_auth_disable_date: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) anonymous_auth_enabled: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>True if fine-grained access control is enabled.</p>
        pub fn enabled(mut self, input: bool) -> Self {
            self.enabled = Some(input);
            self
        }
        /// <p>True if fine-grained access control is enabled.</p>
        pub fn set_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.enabled = input;
            self
        }
        /// <p>True if the internal user database is enabled.</p>
        pub fn internal_user_database_enabled(mut self, input: bool) -> Self {
            self.internal_user_database_enabled = Some(input);
            self
        }
        /// <p>True if the internal user database is enabled.</p>
        pub fn set_internal_user_database_enabled(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.internal_user_database_enabled = input;
            self
        }
        /// <p>Container for information about the SAML configuration for OpenSearch Dashboards.</p>
        pub fn saml_options(mut self, input: crate::model::SamlOptionsOutput) -> Self {
            self.saml_options = Some(input);
            self
        }
        /// <p>Container for information about the SAML configuration for OpenSearch Dashboards.</p>
        pub fn set_saml_options(
            mut self,
            input: std::option::Option<crate::model::SamlOptionsOutput>,
        ) -> Self {
            self.saml_options = input;
            self
        }
        /// <p>Date and time when the migration period will be disabled. Only necessary when <a href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/fgac.html#fgac-enabling-existing">enabling fine-grained access control on an existing domain</a>.</p>
        pub fn anonymous_auth_disable_date(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.anonymous_auth_disable_date = Some(input);
            self
        }
        /// <p>Date and time when the migration period will be disabled. Only necessary when <a href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/fgac.html#fgac-enabling-existing">enabling fine-grained access control on an existing domain</a>.</p>
        pub fn set_anonymous_auth_disable_date(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.anonymous_auth_disable_date = input;
            self
        }
        /// <p>True if a 30-day migration period is enabled, during which administrators can create role mappings. Only necessary when <a href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/fgac.html#fgac-enabling-existing">enabling fine-grained access control on an existing domain</a>.</p>
        pub fn anonymous_auth_enabled(mut self, input: bool) -> Self {
            self.anonymous_auth_enabled = Some(input);
            self
        }
        /// <p>True if a 30-day migration period is enabled, during which administrators can create role mappings. Only necessary when <a href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/fgac.html#fgac-enabling-existing">enabling fine-grained access control on an existing domain</a>.</p>
        pub fn set_anonymous_auth_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.anonymous_auth_enabled = input;
            self
        }
        /// Consumes the builder and constructs a [`AdvancedSecurityOptions`](crate::model::AdvancedSecurityOptions).
        pub fn build(self) -> crate::model::AdvancedSecurityOptions {
            crate::model::AdvancedSecurityOptions {
                enabled: self.enabled,
                internal_user_database_enabled: self.internal_user_database_enabled,
                saml_options: self.saml_options,
                anonymous_auth_disable_date: self.anonymous_auth_disable_date,
                anonymous_auth_enabled: self.anonymous_auth_enabled,
            }
        }
    }
}
impl AdvancedSecurityOptions {
    /// Creates a new builder-style object to manufacture [`AdvancedSecurityOptions`](crate::model::AdvancedSecurityOptions).
    pub fn builder() -> crate::model::advanced_security_options::Builder {
        crate::model::advanced_security_options::Builder::default()
    }
}

/// <p>Describes the SAML application configured for the domain.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SamlOptionsOutput {
    /// <p>True if SAML is enabled.</p>
    #[doc(hidden)]
    pub enabled: std::option::Option<bool>,
    /// <p>Describes the SAML identity provider's information.</p>
    #[doc(hidden)]
    pub idp: std::option::Option<crate::model::SamlIdp>,
    /// <p>The key used for matching the SAML subject attribute.</p>
    #[doc(hidden)]
    pub subject_key: std::option::Option<std::string::String>,
    /// <p>The key used for matching the SAML roles attribute.</p>
    #[doc(hidden)]
    pub roles_key: std::option::Option<std::string::String>,
    /// <p>The duration, in minutes, after which a user session becomes inactive.</p>
    #[doc(hidden)]
    pub session_timeout_minutes: std::option::Option<i32>,
}
impl SamlOptionsOutput {
    /// <p>True if SAML is enabled.</p>
    pub fn enabled(&self) -> std::option::Option<bool> {
        self.enabled
    }
    /// <p>Describes the SAML identity provider's information.</p>
    pub fn idp(&self) -> std::option::Option<&crate::model::SamlIdp> {
        self.idp.as_ref()
    }
    /// <p>The key used for matching the SAML subject attribute.</p>
    pub fn subject_key(&self) -> std::option::Option<&str> {
        self.subject_key.as_deref()
    }
    /// <p>The key used for matching the SAML roles attribute.</p>
    pub fn roles_key(&self) -> std::option::Option<&str> {
        self.roles_key.as_deref()
    }
    /// <p>The duration, in minutes, after which a user session becomes inactive.</p>
    pub fn session_timeout_minutes(&self) -> std::option::Option<i32> {
        self.session_timeout_minutes
    }
}
/// See [`SamlOptionsOutput`](crate::model::SamlOptionsOutput).
pub mod saml_options_output {

    /// A builder for [`SamlOptionsOutput`](crate::model::SamlOptionsOutput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) enabled: std::option::Option<bool>,
        pub(crate) idp: std::option::Option<crate::model::SamlIdp>,
        pub(crate) subject_key: std::option::Option<std::string::String>,
        pub(crate) roles_key: std::option::Option<std::string::String>,
        pub(crate) session_timeout_minutes: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>True if SAML is enabled.</p>
        pub fn enabled(mut self, input: bool) -> Self {
            self.enabled = Some(input);
            self
        }
        /// <p>True if SAML is enabled.</p>
        pub fn set_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.enabled = input;
            self
        }
        /// <p>Describes the SAML identity provider's information.</p>
        pub fn idp(mut self, input: crate::model::SamlIdp) -> Self {
            self.idp = Some(input);
            self
        }
        /// <p>Describes the SAML identity provider's information.</p>
        pub fn set_idp(mut self, input: std::option::Option<crate::model::SamlIdp>) -> Self {
            self.idp = input;
            self
        }
        /// <p>The key used for matching the SAML subject attribute.</p>
        pub fn subject_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.subject_key = Some(input.into());
            self
        }
        /// <p>The key used for matching the SAML subject attribute.</p>
        pub fn set_subject_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.subject_key = input;
            self
        }
        /// <p>The key used for matching the SAML roles attribute.</p>
        pub fn roles_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.roles_key = Some(input.into());
            self
        }
        /// <p>The key used for matching the SAML roles attribute.</p>
        pub fn set_roles_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.roles_key = input;
            self
        }
        /// <p>The duration, in minutes, after which a user session becomes inactive.</p>
        pub fn session_timeout_minutes(mut self, input: i32) -> Self {
            self.session_timeout_minutes = Some(input);
            self
        }
        /// <p>The duration, in minutes, after which a user session becomes inactive.</p>
        pub fn set_session_timeout_minutes(mut self, input: std::option::Option<i32>) -> Self {
            self.session_timeout_minutes = input;
            self
        }
        /// Consumes the builder and constructs a [`SamlOptionsOutput`](crate::model::SamlOptionsOutput).
        pub fn build(self) -> crate::model::SamlOptionsOutput {
            crate::model::SamlOptionsOutput {
                enabled: self.enabled,
                idp: self.idp,
                subject_key: self.subject_key,
                roles_key: self.roles_key,
                session_timeout_minutes: self.session_timeout_minutes,
            }
        }
    }
}
impl SamlOptionsOutput {
    /// Creates a new builder-style object to manufacture [`SamlOptionsOutput`](crate::model::SamlOptionsOutput).
    pub fn builder() -> crate::model::saml_options_output::Builder {
        crate::model::saml_options_output::Builder::default()
    }
}

/// <p>The SAML identity povider information.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SamlIdp {
    /// <p>The metadata of the SAML application, in XML format.</p>
    #[doc(hidden)]
    pub metadata_content: std::option::Option<std::string::String>,
    /// <p>The unique entity ID of the application in the SAML identity provider.</p>
    #[doc(hidden)]
    pub entity_id: std::option::Option<std::string::String>,
}
impl SamlIdp {
    /// <p>The metadata of the SAML application, in XML format.</p>
    pub fn metadata_content(&self) -> std::option::Option<&str> {
        self.metadata_content.as_deref()
    }
    /// <p>The unique entity ID of the application in the SAML identity provider.</p>
    pub fn entity_id(&self) -> std::option::Option<&str> {
        self.entity_id.as_deref()
    }
}
/// See [`SamlIdp`](crate::model::SamlIdp).
pub mod saml_idp {

    /// A builder for [`SamlIdp`](crate::model::SamlIdp).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) metadata_content: std::option::Option<std::string::String>,
        pub(crate) entity_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The metadata of the SAML application, in XML format.</p>
        pub fn metadata_content(mut self, input: impl Into<std::string::String>) -> Self {
            self.metadata_content = Some(input.into());
            self
        }
        /// <p>The metadata of the SAML application, in XML format.</p>
        pub fn set_metadata_content(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.metadata_content = input;
            self
        }
        /// <p>The unique entity ID of the application in the SAML identity provider.</p>
        pub fn entity_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.entity_id = Some(input.into());
            self
        }
        /// <p>The unique entity ID of the application in the SAML identity provider.</p>
        pub fn set_entity_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.entity_id = input;
            self
        }
        /// Consumes the builder and constructs a [`SamlIdp`](crate::model::SamlIdp).
        pub fn build(self) -> crate::model::SamlIdp {
            crate::model::SamlIdp {
                metadata_content: self.metadata_content,
                entity_id: self.entity_id,
            }
        }
    }
}
impl SamlIdp {
    /// Creates a new builder-style object to manufacture [`SamlIdp`](crate::model::SamlIdp).
    pub fn builder() -> crate::model::saml_idp::Builder {
        crate::model::saml_idp::Builder::default()
    }
}

/// <p>The configured endpoint options for a domain and their current status.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DomainEndpointOptionsStatus {
    /// <p>Options to configure the endpoint for a domain.</p>
    #[doc(hidden)]
    pub options: std::option::Option<crate::model::DomainEndpointOptions>,
    /// <p>The status of the endpoint options for a domain.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::OptionStatus>,
}
impl DomainEndpointOptionsStatus {
    /// <p>Options to configure the endpoint for a domain.</p>
    pub fn options(&self) -> std::option::Option<&crate::model::DomainEndpointOptions> {
        self.options.as_ref()
    }
    /// <p>The status of the endpoint options for a domain.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::OptionStatus> {
        self.status.as_ref()
    }
}
/// See [`DomainEndpointOptionsStatus`](crate::model::DomainEndpointOptionsStatus).
pub mod domain_endpoint_options_status {

    /// A builder for [`DomainEndpointOptionsStatus`](crate::model::DomainEndpointOptionsStatus).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) options: std::option::Option<crate::model::DomainEndpointOptions>,
        pub(crate) status: std::option::Option<crate::model::OptionStatus>,
    }
    impl Builder {
        /// <p>Options to configure the endpoint for a domain.</p>
        pub fn options(mut self, input: crate::model::DomainEndpointOptions) -> Self {
            self.options = Some(input);
            self
        }
        /// <p>Options to configure the endpoint for a domain.</p>
        pub fn set_options(
            mut self,
            input: std::option::Option<crate::model::DomainEndpointOptions>,
        ) -> Self {
            self.options = input;
            self
        }
        /// <p>The status of the endpoint options for a domain.</p>
        pub fn status(mut self, input: crate::model::OptionStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the endpoint options for a domain.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::OptionStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// Consumes the builder and constructs a [`DomainEndpointOptionsStatus`](crate::model::DomainEndpointOptionsStatus).
        pub fn build(self) -> crate::model::DomainEndpointOptionsStatus {
            crate::model::DomainEndpointOptionsStatus {
                options: self.options,
                status: self.status,
            }
        }
    }
}
impl DomainEndpointOptionsStatus {
    /// Creates a new builder-style object to manufacture [`DomainEndpointOptionsStatus`](crate::model::DomainEndpointOptionsStatus).
    pub fn builder() -> crate::model::domain_endpoint_options_status::Builder {
        crate::model::domain_endpoint_options_status::Builder::default()
    }
}

/// <p>Options to configure a custom endpoint for an OpenSearch Service domain.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DomainEndpointOptions {
    /// <p>True to require that all traffic to the domain arrive over HTTPS.</p>
    #[doc(hidden)]
    pub enforce_https: std::option::Option<bool>,
    /// <p>Specify the TLS security policy to apply to the HTTPS endpoint of the domain.</p>
    /// <p> Can be one of the following values:</p>
    /// <ul>
    /// <li> <p> <b>Policy-Min-TLS-1-0-2019-07:</b> TLS security policy which supports TLS version 1.0 and higher.</p> </li>
    /// <li> <p> <b>Policy-Min-TLS-1-2-2019-07:</b> TLS security policy which supports only TLS version 1.2 </p> </li>
    /// </ul>
    #[doc(hidden)]
    pub tls_security_policy: std::option::Option<crate::model::TlsSecurityPolicy>,
    /// <p>Whether to enable a custom endpoint for the domain.</p>
    #[doc(hidden)]
    pub custom_endpoint_enabled: std::option::Option<bool>,
    /// <p>The fully qualified URL for the custom endpoint.</p>
    #[doc(hidden)]
    pub custom_endpoint: std::option::Option<std::string::String>,
    /// <p>The ARN for your security certificate, managed in Amazon Web Services Certificate Manager (ACM).</p>
    #[doc(hidden)]
    pub custom_endpoint_certificate_arn: std::option::Option<std::string::String>,
}
impl DomainEndpointOptions {
    /// <p>True to require that all traffic to the domain arrive over HTTPS.</p>
    pub fn enforce_https(&self) -> std::option::Option<bool> {
        self.enforce_https
    }
    /// <p>Specify the TLS security policy to apply to the HTTPS endpoint of the domain.</p>
    /// <p> Can be one of the following values:</p>
    /// <ul>
    /// <li> <p> <b>Policy-Min-TLS-1-0-2019-07:</b> TLS security policy which supports TLS version 1.0 and higher.</p> </li>
    /// <li> <p> <b>Policy-Min-TLS-1-2-2019-07:</b> TLS security policy which supports only TLS version 1.2 </p> </li>
    /// </ul>
    pub fn tls_security_policy(&self) -> std::option::Option<&crate::model::TlsSecurityPolicy> {
        self.tls_security_policy.as_ref()
    }
    /// <p>Whether to enable a custom endpoint for the domain.</p>
    pub fn custom_endpoint_enabled(&self) -> std::option::Option<bool> {
        self.custom_endpoint_enabled
    }
    /// <p>The fully qualified URL for the custom endpoint.</p>
    pub fn custom_endpoint(&self) -> std::option::Option<&str> {
        self.custom_endpoint.as_deref()
    }
    /// <p>The ARN for your security certificate, managed in Amazon Web Services Certificate Manager (ACM).</p>
    pub fn custom_endpoint_certificate_arn(&self) -> std::option::Option<&str> {
        self.custom_endpoint_certificate_arn.as_deref()
    }
}
/// See [`DomainEndpointOptions`](crate::model::DomainEndpointOptions).
pub mod domain_endpoint_options {

    /// A builder for [`DomainEndpointOptions`](crate::model::DomainEndpointOptions).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) enforce_https: std::option::Option<bool>,
        pub(crate) tls_security_policy: std::option::Option<crate::model::TlsSecurityPolicy>,
        pub(crate) custom_endpoint_enabled: std::option::Option<bool>,
        pub(crate) custom_endpoint: std::option::Option<std::string::String>,
        pub(crate) custom_endpoint_certificate_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>True to require that all traffic to the domain arrive over HTTPS.</p>
        pub fn enforce_https(mut self, input: bool) -> Self {
            self.enforce_https = Some(input);
            self
        }
        /// <p>True to require that all traffic to the domain arrive over HTTPS.</p>
        pub fn set_enforce_https(mut self, input: std::option::Option<bool>) -> Self {
            self.enforce_https = input;
            self
        }
        /// <p>Specify the TLS security policy to apply to the HTTPS endpoint of the domain.</p>
        /// <p> Can be one of the following values:</p>
        /// <ul>
        /// <li> <p> <b>Policy-Min-TLS-1-0-2019-07:</b> TLS security policy which supports TLS version 1.0 and higher.</p> </li>
        /// <li> <p> <b>Policy-Min-TLS-1-2-2019-07:</b> TLS security policy which supports only TLS version 1.2 </p> </li>
        /// </ul>
        pub fn tls_security_policy(mut self, input: crate::model::TlsSecurityPolicy) -> Self {
            self.tls_security_policy = Some(input);
            self
        }
        /// <p>Specify the TLS security policy to apply to the HTTPS endpoint of the domain.</p>
        /// <p> Can be one of the following values:</p>
        /// <ul>
        /// <li> <p> <b>Policy-Min-TLS-1-0-2019-07:</b> TLS security policy which supports TLS version 1.0 and higher.</p> </li>
        /// <li> <p> <b>Policy-Min-TLS-1-2-2019-07:</b> TLS security policy which supports only TLS version 1.2 </p> </li>
        /// </ul>
        pub fn set_tls_security_policy(
            mut self,
            input: std::option::Option<crate::model::TlsSecurityPolicy>,
        ) -> Self {
            self.tls_security_policy = input;
            self
        }
        /// <p>Whether to enable a custom endpoint for the domain.</p>
        pub fn custom_endpoint_enabled(mut self, input: bool) -> Self {
            self.custom_endpoint_enabled = Some(input);
            self
        }
        /// <p>Whether to enable a custom endpoint for the domain.</p>
        pub fn set_custom_endpoint_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.custom_endpoint_enabled = input;
            self
        }
        /// <p>The fully qualified URL for the custom endpoint.</p>
        pub fn custom_endpoint(mut self, input: impl Into<std::string::String>) -> Self {
            self.custom_endpoint = Some(input.into());
            self
        }
        /// <p>The fully qualified URL for the custom endpoint.</p>
        pub fn set_custom_endpoint(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.custom_endpoint = input;
            self
        }
        /// <p>The ARN for your security certificate, managed in Amazon Web Services Certificate Manager (ACM).</p>
        pub fn custom_endpoint_certificate_arn(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.custom_endpoint_certificate_arn = Some(input.into());
            self
        }
        /// <p>The ARN for your security certificate, managed in Amazon Web Services Certificate Manager (ACM).</p>
        pub fn set_custom_endpoint_certificate_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.custom_endpoint_certificate_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`DomainEndpointOptions`](crate::model::DomainEndpointOptions).
        pub fn build(self) -> crate::model::DomainEndpointOptions {
            crate::model::DomainEndpointOptions {
                enforce_https: self.enforce_https,
                tls_security_policy: self.tls_security_policy,
                custom_endpoint_enabled: self.custom_endpoint_enabled,
                custom_endpoint: self.custom_endpoint,
                custom_endpoint_certificate_arn: self.custom_endpoint_certificate_arn,
            }
        }
    }
}
impl DomainEndpointOptions {
    /// Creates a new builder-style object to manufacture [`DomainEndpointOptions`](crate::model::DomainEndpointOptions).
    pub fn builder() -> crate::model::domain_endpoint_options::Builder {
        crate::model::domain_endpoint_options::Builder::default()
    }
}

/// When writing a match expression against `TlsSecurityPolicy`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let tlssecuritypolicy = unimplemented!();
/// match tlssecuritypolicy {
///     TlsSecurityPolicy::PolicyMinTls10201907 => { /* ... */ },
///     TlsSecurityPolicy::PolicyMinTls12201907 => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `tlssecuritypolicy` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `TlsSecurityPolicy::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `TlsSecurityPolicy::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `TlsSecurityPolicy::NewFeature` is defined.
/// Specifically, when `tlssecuritypolicy` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `TlsSecurityPolicy::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TlsSecurityPolicy {
    #[allow(missing_docs)] // documentation missing in model
    PolicyMinTls10201907,
    #[allow(missing_docs)] // documentation missing in model
    PolicyMinTls12201907,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for TlsSecurityPolicy {
    fn from(s: &str) -> Self {
        match s {
            "Policy-Min-TLS-1-0-2019-07" => TlsSecurityPolicy::PolicyMinTls10201907,
            "Policy-Min-TLS-1-2-2019-07" => TlsSecurityPolicy::PolicyMinTls12201907,
            other => {
                TlsSecurityPolicy::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for TlsSecurityPolicy {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TlsSecurityPolicy::from(s))
    }
}
impl TlsSecurityPolicy {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            TlsSecurityPolicy::PolicyMinTls10201907 => "Policy-Min-TLS-1-0-2019-07",
            TlsSecurityPolicy::PolicyMinTls12201907 => "Policy-Min-TLS-1-2-2019-07",
            TlsSecurityPolicy::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["Policy-Min-TLS-1-0-2019-07", "Policy-Min-TLS-1-2-2019-07"]
    }
}
impl AsRef<str> for TlsSecurityPolicy {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The configured log publishing options for the domain and their current status.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LogPublishingOptionsStatus {
    /// <p>The log publishing options configured for the domain.</p>
    #[doc(hidden)]
    pub options: std::option::Option<
        std::collections::HashMap<crate::model::LogType, crate::model::LogPublishingOption>,
    >,
    /// <p>The status of the log publishing options for the domain.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::OptionStatus>,
}
impl LogPublishingOptionsStatus {
    /// <p>The log publishing options configured for the domain.</p>
    pub fn options(
        &self,
    ) -> std::option::Option<
        &std::collections::HashMap<crate::model::LogType, crate::model::LogPublishingOption>,
    > {
        self.options.as_ref()
    }
    /// <p>The status of the log publishing options for the domain.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::OptionStatus> {
        self.status.as_ref()
    }
}
/// See [`LogPublishingOptionsStatus`](crate::model::LogPublishingOptionsStatus).
pub mod log_publishing_options_status {

    /// A builder for [`LogPublishingOptionsStatus`](crate::model::LogPublishingOptionsStatus).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) options: std::option::Option<
            std::collections::HashMap<crate::model::LogType, crate::model::LogPublishingOption>,
        >,
        pub(crate) status: std::option::Option<crate::model::OptionStatus>,
    }
    impl Builder {
        /// Adds a key-value pair to `options`.
        ///
        /// To override the contents of this collection use [`set_options`](Self::set_options).
        ///
        /// <p>The log publishing options configured for the domain.</p>
        pub fn options(
            mut self,
            k: crate::model::LogType,
            v: crate::model::LogPublishingOption,
        ) -> Self {
            let mut hash_map = self.options.unwrap_or_default();
            hash_map.insert(k, v);
            self.options = Some(hash_map);
            self
        }
        /// <p>The log publishing options configured for the domain.</p>
        pub fn set_options(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<crate::model::LogType, crate::model::LogPublishingOption>,
            >,
        ) -> Self {
            self.options = input;
            self
        }
        /// <p>The status of the log publishing options for the domain.</p>
        pub fn status(mut self, input: crate::model::OptionStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the log publishing options for the domain.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::OptionStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// Consumes the builder and constructs a [`LogPublishingOptionsStatus`](crate::model::LogPublishingOptionsStatus).
        pub fn build(self) -> crate::model::LogPublishingOptionsStatus {
            crate::model::LogPublishingOptionsStatus {
                options: self.options,
                status: self.status,
            }
        }
    }
}
impl LogPublishingOptionsStatus {
    /// Creates a new builder-style object to manufacture [`LogPublishingOptionsStatus`](crate::model::LogPublishingOptionsStatus).
    pub fn builder() -> crate::model::log_publishing_options_status::Builder {
        crate::model::log_publishing_options_status::Builder::default()
    }
}

/// <p>Specifies whether the Amazon OpenSearch Service domain publishes the OpenSearch application and slow logs to Amazon CloudWatch. For more information, see <a href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/createdomain-configure-slow-logs.html">Monitoring OpenSearch logs with Amazon CloudWatch Logs</a>.</p> <note>
/// <p>After you enable log publishing, you still have to enable the collection of slow logs using the OpenSearch REST API.</p>
/// </note>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LogPublishingOption {
    /// <p>The Amazon Resource Name (ARN) of the CloudWatch Logs group to publish logs to.</p>
    #[doc(hidden)]
    pub cloud_watch_logs_log_group_arn: std::option::Option<std::string::String>,
    /// <p>Whether the log should be published.</p>
    #[doc(hidden)]
    pub enabled: std::option::Option<bool>,
}
impl LogPublishingOption {
    /// <p>The Amazon Resource Name (ARN) of the CloudWatch Logs group to publish logs to.</p>
    pub fn cloud_watch_logs_log_group_arn(&self) -> std::option::Option<&str> {
        self.cloud_watch_logs_log_group_arn.as_deref()
    }
    /// <p>Whether the log should be published.</p>
    pub fn enabled(&self) -> std::option::Option<bool> {
        self.enabled
    }
}
/// See [`LogPublishingOption`](crate::model::LogPublishingOption).
pub mod log_publishing_option {

    /// A builder for [`LogPublishingOption`](crate::model::LogPublishingOption).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) cloud_watch_logs_log_group_arn: std::option::Option<std::string::String>,
        pub(crate) enabled: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the CloudWatch Logs group to publish logs to.</p>
        pub fn cloud_watch_logs_log_group_arn(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.cloud_watch_logs_log_group_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the CloudWatch Logs group to publish logs to.</p>
        pub fn set_cloud_watch_logs_log_group_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.cloud_watch_logs_log_group_arn = input;
            self
        }
        /// <p>Whether the log should be published.</p>
        pub fn enabled(mut self, input: bool) -> Self {
            self.enabled = Some(input);
            self
        }
        /// <p>Whether the log should be published.</p>
        pub fn set_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.enabled = input;
            self
        }
        /// Consumes the builder and constructs a [`LogPublishingOption`](crate::model::LogPublishingOption).
        pub fn build(self) -> crate::model::LogPublishingOption {
            crate::model::LogPublishingOption {
                cloud_watch_logs_log_group_arn: self.cloud_watch_logs_log_group_arn,
                enabled: self.enabled,
            }
        }
    }
}
impl LogPublishingOption {
    /// Creates a new builder-style object to manufacture [`LogPublishingOption`](crate::model::LogPublishingOption).
    pub fn builder() -> crate::model::log_publishing_option::Builder {
        crate::model::log_publishing_option::Builder::default()
    }
}

/// When writing a match expression against `LogType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let logtype = unimplemented!();
/// match logtype {
///     LogType::AuditLogs => { /* ... */ },
///     LogType::EsApplicationLogs => { /* ... */ },
///     LogType::IndexSlowLogs => { /* ... */ },
///     LogType::SearchSlowLogs => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `logtype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `LogType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `LogType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `LogType::NewFeature` is defined.
/// Specifically, when `logtype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `LogType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
/// <p>The type of log file. Can be one of the following:</p>
/// <ul>
/// <li>
/// <p>
/// <b>INDEX_SLOW_LOGS</b> - Index slow logs contain insert requests
/// that took more time than the configured index query log threshold to execute.</p>
/// </li>
/// <li>
/// <p>
/// <b>SEARCH_SLOW_LOGS</b> - Search slow logs contain search
/// queries that took more time than the configured search query log threshold to execute.</p>
/// </li>
/// <li>
/// <p>
/// <b>ES_APPLICATION_LOGS</b> - OpenSearch application logs contain
/// information about errors and warnings raised during the operation of the service and can be
/// useful for troubleshooting.</p>
/// </li>
/// <li>
/// <p>
/// <b>AUDIT_LOGS</b> - Audit logs contain records of user requests
/// for access to the domain.</p>
/// </li>
/// </ul>
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum LogType {
    #[allow(missing_docs)] // documentation missing in model
    AuditLogs,
    #[allow(missing_docs)] // documentation missing in model
    EsApplicationLogs,
    #[allow(missing_docs)] // documentation missing in model
    IndexSlowLogs,
    #[allow(missing_docs)] // documentation missing in model
    SearchSlowLogs,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for LogType {
    fn from(s: &str) -> Self {
        match s {
            "AUDIT_LOGS" => LogType::AuditLogs,
            "ES_APPLICATION_LOGS" => LogType::EsApplicationLogs,
            "INDEX_SLOW_LOGS" => LogType::IndexSlowLogs,
            "SEARCH_SLOW_LOGS" => LogType::SearchSlowLogs,
            other => LogType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for LogType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(LogType::from(s))
    }
}
impl LogType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            LogType::AuditLogs => "AUDIT_LOGS",
            LogType::EsApplicationLogs => "ES_APPLICATION_LOGS",
            LogType::IndexSlowLogs => "INDEX_SLOW_LOGS",
            LogType::SearchSlowLogs => "SEARCH_SLOW_LOGS",
            LogType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "AUDIT_LOGS",
            "ES_APPLICATION_LOGS",
            "INDEX_SLOW_LOGS",
            "SEARCH_SLOW_LOGS",
        ]
    }
}
impl AsRef<str> for LogType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Status of the advanced options for the specified domain. The following options are available: </p>
/// <ul>
/// <li> <p> <code>"rest.action.multi.allow_explicit_index": "true" | "false"</code> - Note the use of a string rather than a boolean. Specifies whether explicit references to indexes are allowed inside the body of HTTP requests. If you want to configure access policies for domain sub-resources, such as specific indexes and domain APIs, you must disable this property. Default is true.</p> </li>
/// <li> <p> <code>"indices.fielddata.cache.size": "80" </code> - Note the use of a string rather than a boolean. Specifies the percentage of heap space allocated to field data. Default is unbounded.</p> </li>
/// <li> <p> <code>"indices.query.bool.max_clause_count": "1024"</code> - Note the use of a string rather than a boolean. Specifies the maximum number of clauses allowed in a Lucene boolean query. Default is 1,024. Queries with more than the permitted number of clauses result in a <code>TooManyClauses</code> error.</p> </li>
/// <li> <p> <code>"override_main_response_version": "true" | "false"</code> - Note the use of a string rather than a boolean. Specifies whether the domain reports its version as 7.10 to allow Elasticsearch OSS clients and plugins to continue working with it. Default is false when creating a domain and true when upgrading a domain.</p> </li>
/// </ul>
/// <p>For more information, see <a href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/createupdatedomains.html#createdomain-configure-advanced-options">Advanced cluster parameters</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AdvancedOptionsStatus {
    /// <p>The status of advanced options for the specified domain.</p>
    #[doc(hidden)]
    pub options:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The status of advanced options for the specified domain.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::OptionStatus>,
}
impl AdvancedOptionsStatus {
    /// <p>The status of advanced options for the specified domain.</p>
    pub fn options(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.options.as_ref()
    }
    /// <p>The status of advanced options for the specified domain.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::OptionStatus> {
        self.status.as_ref()
    }
}
/// See [`AdvancedOptionsStatus`](crate::model::AdvancedOptionsStatus).
pub mod advanced_options_status {

    /// A builder for [`AdvancedOptionsStatus`](crate::model::AdvancedOptionsStatus).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) options: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) status: std::option::Option<crate::model::OptionStatus>,
    }
    impl Builder {
        /// Adds a key-value pair to `options`.
        ///
        /// To override the contents of this collection use [`set_options`](Self::set_options).
        ///
        /// <p>The status of advanced options for the specified domain.</p>
        pub fn options(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.options.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.options = Some(hash_map);
            self
        }
        /// <p>The status of advanced options for the specified domain.</p>
        pub fn set_options(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.options = input;
            self
        }
        /// <p>The status of advanced options for the specified domain.</p>
        pub fn status(mut self, input: crate::model::OptionStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of advanced options for the specified domain.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::OptionStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// Consumes the builder and constructs a [`AdvancedOptionsStatus`](crate::model::AdvancedOptionsStatus).
        pub fn build(self) -> crate::model::AdvancedOptionsStatus {
            crate::model::AdvancedOptionsStatus {
                options: self.options,
                status: self.status,
            }
        }
    }
}
impl AdvancedOptionsStatus {
    /// Creates a new builder-style object to manufacture [`AdvancedOptionsStatus`](crate::model::AdvancedOptionsStatus).
    pub fn builder() -> crate::model::advanced_options_status::Builder {
        crate::model::advanced_options_status::Builder::default()
    }
}

/// <p>Status of the node-to-node encryption options for the specified domain.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct NodeToNodeEncryptionOptionsStatus {
    /// <p>The node-to-node encryption options for the specified domain.</p>
    #[doc(hidden)]
    pub options: std::option::Option<crate::model::NodeToNodeEncryptionOptions>,
    /// <p>The status of the node-to-node encryption options for the specified domain.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::OptionStatus>,
}
impl NodeToNodeEncryptionOptionsStatus {
    /// <p>The node-to-node encryption options for the specified domain.</p>
    pub fn options(&self) -> std::option::Option<&crate::model::NodeToNodeEncryptionOptions> {
        self.options.as_ref()
    }
    /// <p>The status of the node-to-node encryption options for the specified domain.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::OptionStatus> {
        self.status.as_ref()
    }
}
/// See [`NodeToNodeEncryptionOptionsStatus`](crate::model::NodeToNodeEncryptionOptionsStatus).
pub mod node_to_node_encryption_options_status {

    /// A builder for [`NodeToNodeEncryptionOptionsStatus`](crate::model::NodeToNodeEncryptionOptionsStatus).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) options: std::option::Option<crate::model::NodeToNodeEncryptionOptions>,
        pub(crate) status: std::option::Option<crate::model::OptionStatus>,
    }
    impl Builder {
        /// <p>The node-to-node encryption options for the specified domain.</p>
        pub fn options(mut self, input: crate::model::NodeToNodeEncryptionOptions) -> Self {
            self.options = Some(input);
            self
        }
        /// <p>The node-to-node encryption options for the specified domain.</p>
        pub fn set_options(
            mut self,
            input: std::option::Option<crate::model::NodeToNodeEncryptionOptions>,
        ) -> Self {
            self.options = input;
            self
        }
        /// <p>The status of the node-to-node encryption options for the specified domain.</p>
        pub fn status(mut self, input: crate::model::OptionStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the node-to-node encryption options for the specified domain.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::OptionStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// Consumes the builder and constructs a [`NodeToNodeEncryptionOptionsStatus`](crate::model::NodeToNodeEncryptionOptionsStatus).
        pub fn build(self) -> crate::model::NodeToNodeEncryptionOptionsStatus {
            crate::model::NodeToNodeEncryptionOptionsStatus {
                options: self.options,
                status: self.status,
            }
        }
    }
}
impl NodeToNodeEncryptionOptionsStatus {
    /// Creates a new builder-style object to manufacture [`NodeToNodeEncryptionOptionsStatus`](crate::model::NodeToNodeEncryptionOptionsStatus).
    pub fn builder() -> crate::model::node_to_node_encryption_options_status::Builder {
        crate::model::node_to_node_encryption_options_status::Builder::default()
    }
}

/// <p>Enables or disables node-to-node encryption. For more information, see <a href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/ntn.html">Node-to-node encryption for Amazon OpenSearch Service</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct NodeToNodeEncryptionOptions {
    /// <p>True to enable node-to-node encryption.</p>
    #[doc(hidden)]
    pub enabled: std::option::Option<bool>,
}
impl NodeToNodeEncryptionOptions {
    /// <p>True to enable node-to-node encryption.</p>
    pub fn enabled(&self) -> std::option::Option<bool> {
        self.enabled
    }
}
/// See [`NodeToNodeEncryptionOptions`](crate::model::NodeToNodeEncryptionOptions).
pub mod node_to_node_encryption_options {

    /// A builder for [`NodeToNodeEncryptionOptions`](crate::model::NodeToNodeEncryptionOptions).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) enabled: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>True to enable node-to-node encryption.</p>
        pub fn enabled(mut self, input: bool) -> Self {
            self.enabled = Some(input);
            self
        }
        /// <p>True to enable node-to-node encryption.</p>
        pub fn set_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.enabled = input;
            self
        }
        /// Consumes the builder and constructs a [`NodeToNodeEncryptionOptions`](crate::model::NodeToNodeEncryptionOptions).
        pub fn build(self) -> crate::model::NodeToNodeEncryptionOptions {
            crate::model::NodeToNodeEncryptionOptions {
                enabled: self.enabled,
            }
        }
    }
}
impl NodeToNodeEncryptionOptions {
    /// Creates a new builder-style object to manufacture [`NodeToNodeEncryptionOptions`](crate::model::NodeToNodeEncryptionOptions).
    pub fn builder() -> crate::model::node_to_node_encryption_options::Builder {
        crate::model::node_to_node_encryption_options::Builder::default()
    }
}

/// <p>Status of the encryption at rest options for the specified OpenSearch Service domain.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct EncryptionAtRestOptionsStatus {
    /// <p>Encryption at rest options for the specified domain.</p>
    #[doc(hidden)]
    pub options: std::option::Option<crate::model::EncryptionAtRestOptions>,
    /// <p>The status of the encryption at rest options for the specified domain.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::OptionStatus>,
}
impl EncryptionAtRestOptionsStatus {
    /// <p>Encryption at rest options for the specified domain.</p>
    pub fn options(&self) -> std::option::Option<&crate::model::EncryptionAtRestOptions> {
        self.options.as_ref()
    }
    /// <p>The status of the encryption at rest options for the specified domain.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::OptionStatus> {
        self.status.as_ref()
    }
}
/// See [`EncryptionAtRestOptionsStatus`](crate::model::EncryptionAtRestOptionsStatus).
pub mod encryption_at_rest_options_status {

    /// A builder for [`EncryptionAtRestOptionsStatus`](crate::model::EncryptionAtRestOptionsStatus).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) options: std::option::Option<crate::model::EncryptionAtRestOptions>,
        pub(crate) status: std::option::Option<crate::model::OptionStatus>,
    }
    impl Builder {
        /// <p>Encryption at rest options for the specified domain.</p>
        pub fn options(mut self, input: crate::model::EncryptionAtRestOptions) -> Self {
            self.options = Some(input);
            self
        }
        /// <p>Encryption at rest options for the specified domain.</p>
        pub fn set_options(
            mut self,
            input: std::option::Option<crate::model::EncryptionAtRestOptions>,
        ) -> Self {
            self.options = input;
            self
        }
        /// <p>The status of the encryption at rest options for the specified domain.</p>
        pub fn status(mut self, input: crate::model::OptionStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the encryption at rest options for the specified domain.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::OptionStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// Consumes the builder and constructs a [`EncryptionAtRestOptionsStatus`](crate::model::EncryptionAtRestOptionsStatus).
        pub fn build(self) -> crate::model::EncryptionAtRestOptionsStatus {
            crate::model::EncryptionAtRestOptionsStatus {
                options: self.options,
                status: self.status,
            }
        }
    }
}
impl EncryptionAtRestOptionsStatus {
    /// Creates a new builder-style object to manufacture [`EncryptionAtRestOptionsStatus`](crate::model::EncryptionAtRestOptionsStatus).
    pub fn builder() -> crate::model::encryption_at_rest_options_status::Builder {
        crate::model::encryption_at_rest_options_status::Builder::default()
    }
}

/// <p>Specifies whether the domain should encrypt data at rest, and if so, the Key Management Service (KMS) key to use. Can be used only to create a new domain, not update an existing one.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct EncryptionAtRestOptions {
    /// <p>True to enable encryption at rest.</p>
    #[doc(hidden)]
    pub enabled: std::option::Option<bool>,
    /// <p>The KMS key ID. Takes the form <code>1a2a3a4-1a2a-3a4a-5a6a-1a2a3a4a5a6a</code>.</p>
    #[doc(hidden)]
    pub kms_key_id: std::option::Option<std::string::String>,
}
impl EncryptionAtRestOptions {
    /// <p>True to enable encryption at rest.</p>
    pub fn enabled(&self) -> std::option::Option<bool> {
        self.enabled
    }
    /// <p>The KMS key ID. Takes the form <code>1a2a3a4-1a2a-3a4a-5a6a-1a2a3a4a5a6a</code>.</p>
    pub fn kms_key_id(&self) -> std::option::Option<&str> {
        self.kms_key_id.as_deref()
    }
}
/// See [`EncryptionAtRestOptions`](crate::model::EncryptionAtRestOptions).
pub mod encryption_at_rest_options {

    /// A builder for [`EncryptionAtRestOptions`](crate::model::EncryptionAtRestOptions).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) enabled: std::option::Option<bool>,
        pub(crate) kms_key_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>True to enable encryption at rest.</p>
        pub fn enabled(mut self, input: bool) -> Self {
            self.enabled = Some(input);
            self
        }
        /// <p>True to enable encryption at rest.</p>
        pub fn set_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.enabled = input;
            self
        }
        /// <p>The KMS key ID. Takes the form <code>1a2a3a4-1a2a-3a4a-5a6a-1a2a3a4a5a6a</code>.</p>
        pub fn kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.kms_key_id = Some(input.into());
            self
        }
        /// <p>The KMS key ID. Takes the form <code>1a2a3a4-1a2a-3a4a-5a6a-1a2a3a4a5a6a</code>.</p>
        pub fn set_kms_key_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.kms_key_id = input;
            self
        }
        /// Consumes the builder and constructs a [`EncryptionAtRestOptions`](crate::model::EncryptionAtRestOptions).
        pub fn build(self) -> crate::model::EncryptionAtRestOptions {
            crate::model::EncryptionAtRestOptions {
                enabled: self.enabled,
                kms_key_id: self.kms_key_id,
            }
        }
    }
}
impl EncryptionAtRestOptions {
    /// Creates a new builder-style object to manufacture [`EncryptionAtRestOptions`](crate::model::EncryptionAtRestOptions).
    pub fn builder() -> crate::model::encryption_at_rest_options::Builder {
        crate::model::encryption_at_rest_options::Builder::default()
    }
}

/// <p>The status of the Cognito options for the specified domain.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CognitoOptionsStatus {
    /// <p>Cognito options for the specified domain.</p>
    #[doc(hidden)]
    pub options: std::option::Option<crate::model::CognitoOptions>,
    /// <p>The status of the Cognito options for the specified domain.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::OptionStatus>,
}
impl CognitoOptionsStatus {
    /// <p>Cognito options for the specified domain.</p>
    pub fn options(&self) -> std::option::Option<&crate::model::CognitoOptions> {
        self.options.as_ref()
    }
    /// <p>The status of the Cognito options for the specified domain.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::OptionStatus> {
        self.status.as_ref()
    }
}
/// See [`CognitoOptionsStatus`](crate::model::CognitoOptionsStatus).
pub mod cognito_options_status {

    /// A builder for [`CognitoOptionsStatus`](crate::model::CognitoOptionsStatus).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) options: std::option::Option<crate::model::CognitoOptions>,
        pub(crate) status: std::option::Option<crate::model::OptionStatus>,
    }
    impl Builder {
        /// <p>Cognito options for the specified domain.</p>
        pub fn options(mut self, input: crate::model::CognitoOptions) -> Self {
            self.options = Some(input);
            self
        }
        /// <p>Cognito options for the specified domain.</p>
        pub fn set_options(
            mut self,
            input: std::option::Option<crate::model::CognitoOptions>,
        ) -> Self {
            self.options = input;
            self
        }
        /// <p>The status of the Cognito options for the specified domain.</p>
        pub fn status(mut self, input: crate::model::OptionStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the Cognito options for the specified domain.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::OptionStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// Consumes the builder and constructs a [`CognitoOptionsStatus`](crate::model::CognitoOptionsStatus).
        pub fn build(self) -> crate::model::CognitoOptionsStatus {
            crate::model::CognitoOptionsStatus {
                options: self.options,
                status: self.status,
            }
        }
    }
}
impl CognitoOptionsStatus {
    /// Creates a new builder-style object to manufacture [`CognitoOptionsStatus`](crate::model::CognitoOptionsStatus).
    pub fn builder() -> crate::model::cognito_options_status::Builder {
        crate::model::cognito_options_status::Builder::default()
    }
}

/// <p>Container for the parameters required to enable Cognito authentication for an OpenSearch Service domain. For more information, see <a href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/cognito-auth.html">Configuring Amazon Cognito authentication for OpenSearch Dashboards</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CognitoOptions {
    /// <p>Whether to enable or disable Amazon Cognito authentication for OpenSearch Dashboards.</p>
    #[doc(hidden)]
    pub enabled: std::option::Option<bool>,
    /// <p>The Amazon Cognito user pool ID that you want OpenSearch Service to use for OpenSearch Dashboards authentication.</p>
    #[doc(hidden)]
    pub user_pool_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Cognito identity pool ID that you want OpenSearch Service to use for OpenSearch Dashboards authentication.</p>
    #[doc(hidden)]
    pub identity_pool_id: std::option::Option<std::string::String>,
    /// <p>The <code>AmazonOpenSearchServiceCognitoAccess</code> role that allows OpenSearch Service to configure your user pool and identity pool.</p>
    #[doc(hidden)]
    pub role_arn: std::option::Option<std::string::String>,
}
impl CognitoOptions {
    /// <p>Whether to enable or disable Amazon Cognito authentication for OpenSearch Dashboards.</p>
    pub fn enabled(&self) -> std::option::Option<bool> {
        self.enabled
    }
    /// <p>The Amazon Cognito user pool ID that you want OpenSearch Service to use for OpenSearch Dashboards authentication.</p>
    pub fn user_pool_id(&self) -> std::option::Option<&str> {
        self.user_pool_id.as_deref()
    }
    /// <p>The Amazon Cognito identity pool ID that you want OpenSearch Service to use for OpenSearch Dashboards authentication.</p>
    pub fn identity_pool_id(&self) -> std::option::Option<&str> {
        self.identity_pool_id.as_deref()
    }
    /// <p>The <code>AmazonOpenSearchServiceCognitoAccess</code> role that allows OpenSearch Service to configure your user pool and identity pool.</p>
    pub fn role_arn(&self) -> std::option::Option<&str> {
        self.role_arn.as_deref()
    }
}
/// See [`CognitoOptions`](crate::model::CognitoOptions).
pub mod cognito_options {

    /// A builder for [`CognitoOptions`](crate::model::CognitoOptions).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) enabled: std::option::Option<bool>,
        pub(crate) user_pool_id: std::option::Option<std::string::String>,
        pub(crate) identity_pool_id: std::option::Option<std::string::String>,
        pub(crate) role_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Whether to enable or disable Amazon Cognito authentication for OpenSearch Dashboards.</p>
        pub fn enabled(mut self, input: bool) -> Self {
            self.enabled = Some(input);
            self
        }
        /// <p>Whether to enable or disable Amazon Cognito authentication for OpenSearch Dashboards.</p>
        pub fn set_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.enabled = input;
            self
        }
        /// <p>The Amazon Cognito user pool ID that you want OpenSearch Service to use for OpenSearch Dashboards authentication.</p>
        pub fn user_pool_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.user_pool_id = Some(input.into());
            self
        }
        /// <p>The Amazon Cognito user pool ID that you want OpenSearch Service to use for OpenSearch Dashboards authentication.</p>
        pub fn set_user_pool_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.user_pool_id = input;
            self
        }
        /// <p>The Amazon Cognito identity pool ID that you want OpenSearch Service to use for OpenSearch Dashboards authentication.</p>
        pub fn identity_pool_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.identity_pool_id = Some(input.into());
            self
        }
        /// <p>The Amazon Cognito identity pool ID that you want OpenSearch Service to use for OpenSearch Dashboards authentication.</p>
        pub fn set_identity_pool_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.identity_pool_id = input;
            self
        }
        /// <p>The <code>AmazonOpenSearchServiceCognitoAccess</code> role that allows OpenSearch Service to configure your user pool and identity pool.</p>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.role_arn = Some(input.into());
            self
        }
        /// <p>The <code>AmazonOpenSearchServiceCognitoAccess</code> role that allows OpenSearch Service to configure your user pool and identity pool.</p>
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.role_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`CognitoOptions`](crate::model::CognitoOptions).
        pub fn build(self) -> crate::model::CognitoOptions {
            crate::model::CognitoOptions {
                enabled: self.enabled,
                user_pool_id: self.user_pool_id,
                identity_pool_id: self.identity_pool_id,
                role_arn: self.role_arn,
            }
        }
    }
}
impl CognitoOptions {
    /// Creates a new builder-style object to manufacture [`CognitoOptions`](crate::model::CognitoOptions).
    pub fn builder() -> crate::model::cognito_options::Builder {
        crate::model::cognito_options::Builder::default()
    }
}

/// <p>Status of the VPC options for a specified domain.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct VpcDerivedInfoStatus {
    /// <p>The VPC options for the specified domain.</p>
    #[doc(hidden)]
    pub options: std::option::Option<crate::model::VpcDerivedInfo>,
    /// <p>The status of the VPC options for the specified domain.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::OptionStatus>,
}
impl VpcDerivedInfoStatus {
    /// <p>The VPC options for the specified domain.</p>
    pub fn options(&self) -> std::option::Option<&crate::model::VpcDerivedInfo> {
        self.options.as_ref()
    }
    /// <p>The status of the VPC options for the specified domain.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::OptionStatus> {
        self.status.as_ref()
    }
}
/// See [`VpcDerivedInfoStatus`](crate::model::VpcDerivedInfoStatus).
pub mod vpc_derived_info_status {

    /// A builder for [`VpcDerivedInfoStatus`](crate::model::VpcDerivedInfoStatus).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) options: std::option::Option<crate::model::VpcDerivedInfo>,
        pub(crate) status: std::option::Option<crate::model::OptionStatus>,
    }
    impl Builder {
        /// <p>The VPC options for the specified domain.</p>
        pub fn options(mut self, input: crate::model::VpcDerivedInfo) -> Self {
            self.options = Some(input);
            self
        }
        /// <p>The VPC options for the specified domain.</p>
        pub fn set_options(
            mut self,
            input: std::option::Option<crate::model::VpcDerivedInfo>,
        ) -> Self {
            self.options = input;
            self
        }
        /// <p>The status of the VPC options for the specified domain.</p>
        pub fn status(mut self, input: crate::model::OptionStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the VPC options for the specified domain.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::OptionStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// Consumes the builder and constructs a [`VpcDerivedInfoStatus`](crate::model::VpcDerivedInfoStatus).
        pub fn build(self) -> crate::model::VpcDerivedInfoStatus {
            crate::model::VpcDerivedInfoStatus {
                options: self.options,
                status: self.status,
            }
        }
    }
}
impl VpcDerivedInfoStatus {
    /// Creates a new builder-style object to manufacture [`VpcDerivedInfoStatus`](crate::model::VpcDerivedInfoStatus).
    pub fn builder() -> crate::model::vpc_derived_info_status::Builder {
        crate::model::vpc_derived_info_status::Builder::default()
    }
}

/// <p>Container for information about a daily automated snapshot for an OpenSearch Service domain.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SnapshotOptionsStatus {
    /// <p>The daily snapshot options specified for the domain.</p>
    #[doc(hidden)]
    pub options: std::option::Option<crate::model::SnapshotOptions>,
    /// <p>The status of a daily automated snapshot.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::OptionStatus>,
}
impl SnapshotOptionsStatus {
    /// <p>The daily snapshot options specified for the domain.</p>
    pub fn options(&self) -> std::option::Option<&crate::model::SnapshotOptions> {
        self.options.as_ref()
    }
    /// <p>The status of a daily automated snapshot.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::OptionStatus> {
        self.status.as_ref()
    }
}
/// See [`SnapshotOptionsStatus`](crate::model::SnapshotOptionsStatus).
pub mod snapshot_options_status {

    /// A builder for [`SnapshotOptionsStatus`](crate::model::SnapshotOptionsStatus).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) options: std::option::Option<crate::model::SnapshotOptions>,
        pub(crate) status: std::option::Option<crate::model::OptionStatus>,
    }
    impl Builder {
        /// <p>The daily snapshot options specified for the domain.</p>
        pub fn options(mut self, input: crate::model::SnapshotOptions) -> Self {
            self.options = Some(input);
            self
        }
        /// <p>The daily snapshot options specified for the domain.</p>
        pub fn set_options(
            mut self,
            input: std::option::Option<crate::model::SnapshotOptions>,
        ) -> Self {
            self.options = input;
            self
        }
        /// <p>The status of a daily automated snapshot.</p>
        pub fn status(mut self, input: crate::model::OptionStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of a daily automated snapshot.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::OptionStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// Consumes the builder and constructs a [`SnapshotOptionsStatus`](crate::model::SnapshotOptionsStatus).
        pub fn build(self) -> crate::model::SnapshotOptionsStatus {
            crate::model::SnapshotOptionsStatus {
                options: self.options,
                status: self.status,
            }
        }
    }
}
impl SnapshotOptionsStatus {
    /// Creates a new builder-style object to manufacture [`SnapshotOptionsStatus`](crate::model::SnapshotOptionsStatus).
    pub fn builder() -> crate::model::snapshot_options_status::Builder {
        crate::model::snapshot_options_status::Builder::default()
    }
}

/// <p>The time, in UTC format, when OpenSearch Service takes a daily automated snapshot of the specified domain. Default is <code>0</code> hours.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SnapshotOptions {
    /// <p>The time, in UTC format, when OpenSearch Service takes a daily automated snapshot of the specified domain. Default is <code>0</code> hours.</p>
    #[doc(hidden)]
    pub automated_snapshot_start_hour: std::option::Option<i32>,
}
impl SnapshotOptions {
    /// <p>The time, in UTC format, when OpenSearch Service takes a daily automated snapshot of the specified domain. Default is <code>0</code> hours.</p>
    pub fn automated_snapshot_start_hour(&self) -> std::option::Option<i32> {
        self.automated_snapshot_start_hour
    }
}
/// See [`SnapshotOptions`](crate::model::SnapshotOptions).
pub mod snapshot_options {

    /// A builder for [`SnapshotOptions`](crate::model::SnapshotOptions).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) automated_snapshot_start_hour: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The time, in UTC format, when OpenSearch Service takes a daily automated snapshot of the specified domain. Default is <code>0</code> hours.</p>
        pub fn automated_snapshot_start_hour(mut self, input: i32) -> Self {
            self.automated_snapshot_start_hour = Some(input);
            self
        }
        /// <p>The time, in UTC format, when OpenSearch Service takes a daily automated snapshot of the specified domain. Default is <code>0</code> hours.</p>
        pub fn set_automated_snapshot_start_hour(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.automated_snapshot_start_hour = input;
            self
        }
        /// Consumes the builder and constructs a [`SnapshotOptions`](crate::model::SnapshotOptions).
        pub fn build(self) -> crate::model::SnapshotOptions {
            crate::model::SnapshotOptions {
                automated_snapshot_start_hour: self.automated_snapshot_start_hour,
            }
        }
    }
}
impl SnapshotOptions {
    /// Creates a new builder-style object to manufacture [`SnapshotOptions`](crate::model::SnapshotOptions).
    pub fn builder() -> crate::model::snapshot_options::Builder {
        crate::model::snapshot_options::Builder::default()
    }
}

/// <p>The configured access rules for the domain's search endpoint, and the current status of those rules.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AccessPoliciesStatus {
    /// <p>The access policy configured for the domain. Access policies can be resource-based, IP-based, or IAM-based. For more information, see <a href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/createupdatedomains.html#createdomain-configure-access-policies">Configuring access policies</a>.</p>
    #[doc(hidden)]
    pub options: std::option::Option<std::string::String>,
    /// <p>The status of the access policy for the domain.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::OptionStatus>,
}
impl AccessPoliciesStatus {
    /// <p>The access policy configured for the domain. Access policies can be resource-based, IP-based, or IAM-based. For more information, see <a href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/createupdatedomains.html#createdomain-configure-access-policies">Configuring access policies</a>.</p>
    pub fn options(&self) -> std::option::Option<&str> {
        self.options.as_deref()
    }
    /// <p>The status of the access policy for the domain.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::OptionStatus> {
        self.status.as_ref()
    }
}
/// See [`AccessPoliciesStatus`](crate::model::AccessPoliciesStatus).
pub mod access_policies_status {

    /// A builder for [`AccessPoliciesStatus`](crate::model::AccessPoliciesStatus).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) options: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::OptionStatus>,
    }
    impl Builder {
        /// <p>The access policy configured for the domain. Access policies can be resource-based, IP-based, or IAM-based. For more information, see <a href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/createupdatedomains.html#createdomain-configure-access-policies">Configuring access policies</a>.</p>
        pub fn options(mut self, input: impl Into<std::string::String>) -> Self {
            self.options = Some(input.into());
            self
        }
        /// <p>The access policy configured for the domain. Access policies can be resource-based, IP-based, or IAM-based. For more information, see <a href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/createupdatedomains.html#createdomain-configure-access-policies">Configuring access policies</a>.</p>
        pub fn set_options(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.options = input;
            self
        }
        /// <p>The status of the access policy for the domain.</p>
        pub fn status(mut self, input: crate::model::OptionStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the access policy for the domain.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::OptionStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// Consumes the builder and constructs a [`AccessPoliciesStatus`](crate::model::AccessPoliciesStatus).
        pub fn build(self) -> crate::model::AccessPoliciesStatus {
            crate::model::AccessPoliciesStatus {
                options: self.options,
                status: self.status,
            }
        }
    }
}
impl AccessPoliciesStatus {
    /// Creates a new builder-style object to manufacture [`AccessPoliciesStatus`](crate::model::AccessPoliciesStatus).
    pub fn builder() -> crate::model::access_policies_status::Builder {
        crate::model::access_policies_status::Builder::default()
    }
}

/// <p>The status of the EBS options for the specified OpenSearch Service domain.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct EbsOptionsStatus {
    /// <p>The configured EBS options for the specified domain.</p>
    #[doc(hidden)]
    pub options: std::option::Option<crate::model::EbsOptions>,
    /// <p>The status of the EBS options for the specified domain.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::OptionStatus>,
}
impl EbsOptionsStatus {
    /// <p>The configured EBS options for the specified domain.</p>
    pub fn options(&self) -> std::option::Option<&crate::model::EbsOptions> {
        self.options.as_ref()
    }
    /// <p>The status of the EBS options for the specified domain.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::OptionStatus> {
        self.status.as_ref()
    }
}
/// See [`EbsOptionsStatus`](crate::model::EbsOptionsStatus).
pub mod ebs_options_status {

    /// A builder for [`EbsOptionsStatus`](crate::model::EbsOptionsStatus).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) options: std::option::Option<crate::model::EbsOptions>,
        pub(crate) status: std::option::Option<crate::model::OptionStatus>,
    }
    impl Builder {
        /// <p>The configured EBS options for the specified domain.</p>
        pub fn options(mut self, input: crate::model::EbsOptions) -> Self {
            self.options = Some(input);
            self
        }
        /// <p>The configured EBS options for the specified domain.</p>
        pub fn set_options(mut self, input: std::option::Option<crate::model::EbsOptions>) -> Self {
            self.options = input;
            self
        }
        /// <p>The status of the EBS options for the specified domain.</p>
        pub fn status(mut self, input: crate::model::OptionStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the EBS options for the specified domain.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::OptionStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// Consumes the builder and constructs a [`EbsOptionsStatus`](crate::model::EbsOptionsStatus).
        pub fn build(self) -> crate::model::EbsOptionsStatus {
            crate::model::EbsOptionsStatus {
                options: self.options,
                status: self.status,
            }
        }
    }
}
impl EbsOptionsStatus {
    /// Creates a new builder-style object to manufacture [`EbsOptionsStatus`](crate::model::EbsOptionsStatus).
    pub fn builder() -> crate::model::ebs_options_status::Builder {
        crate::model::ebs_options_status::Builder::default()
    }
}

/// <p>Container for the parameters required to enable EBS-based storage for an OpenSearch Service domain.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct EbsOptions {
    /// <p>Indicates whether EBS volumes are attached to data nodes in an OpenSearch Service domain.</p>
    #[doc(hidden)]
    pub ebs_enabled: std::option::Option<bool>,
    /// <p>Specifies the type of EBS volumes attached to data nodes.</p>
    #[doc(hidden)]
    pub volume_type: std::option::Option<crate::model::VolumeType>,
    /// <p>Specifies the size (in GiB) of EBS volumes attached to data nodes.</p>
    #[doc(hidden)]
    pub volume_size: std::option::Option<i32>,
    /// <p>Specifies the baseline input/output (I/O) performance of EBS volumes attached to data nodes. Applicable only for the <code>gp3</code> and provisioned IOPS EBS volume types.</p>
    #[doc(hidden)]
    pub iops: std::option::Option<i32>,
    /// <p>Specifies the throughput (in MiB/s) of the EBS volumes attached to data nodes. Applicable only for the <code>gp3</code> volume type.</p>
    #[doc(hidden)]
    pub throughput: std::option::Option<i32>,
}
impl EbsOptions {
    /// <p>Indicates whether EBS volumes are attached to data nodes in an OpenSearch Service domain.</p>
    pub fn ebs_enabled(&self) -> std::option::Option<bool> {
        self.ebs_enabled
    }
    /// <p>Specifies the type of EBS volumes attached to data nodes.</p>
    pub fn volume_type(&self) -> std::option::Option<&crate::model::VolumeType> {
        self.volume_type.as_ref()
    }
    /// <p>Specifies the size (in GiB) of EBS volumes attached to data nodes.</p>
    pub fn volume_size(&self) -> std::option::Option<i32> {
        self.volume_size
    }
    /// <p>Specifies the baseline input/output (I/O) performance of EBS volumes attached to data nodes. Applicable only for the <code>gp3</code> and provisioned IOPS EBS volume types.</p>
    pub fn iops(&self) -> std::option::Option<i32> {
        self.iops
    }
    /// <p>Specifies the throughput (in MiB/s) of the EBS volumes attached to data nodes. Applicable only for the <code>gp3</code> volume type.</p>
    pub fn throughput(&self) -> std::option::Option<i32> {
        self.throughput
    }
}
/// See [`EbsOptions`](crate::model::EbsOptions).
pub mod ebs_options {

    /// A builder for [`EbsOptions`](crate::model::EbsOptions).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) ebs_enabled: std::option::Option<bool>,
        pub(crate) volume_type: std::option::Option<crate::model::VolumeType>,
        pub(crate) volume_size: std::option::Option<i32>,
        pub(crate) iops: std::option::Option<i32>,
        pub(crate) throughput: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>Indicates whether EBS volumes are attached to data nodes in an OpenSearch Service domain.</p>
        pub fn ebs_enabled(mut self, input: bool) -> Self {
            self.ebs_enabled = Some(input);
            self
        }
        /// <p>Indicates whether EBS volumes are attached to data nodes in an OpenSearch Service domain.</p>
        pub fn set_ebs_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.ebs_enabled = input;
            self
        }
        /// <p>Specifies the type of EBS volumes attached to data nodes.</p>
        pub fn volume_type(mut self, input: crate::model::VolumeType) -> Self {
            self.volume_type = Some(input);
            self
        }
        /// <p>Specifies the type of EBS volumes attached to data nodes.</p>
        pub fn set_volume_type(
            mut self,
            input: std::option::Option<crate::model::VolumeType>,
        ) -> Self {
            self.volume_type = input;
            self
        }
        /// <p>Specifies the size (in GiB) of EBS volumes attached to data nodes.</p>
        pub fn volume_size(mut self, input: i32) -> Self {
            self.volume_size = Some(input);
            self
        }
        /// <p>Specifies the size (in GiB) of EBS volumes attached to data nodes.</p>
        pub fn set_volume_size(mut self, input: std::option::Option<i32>) -> Self {
            self.volume_size = input;
            self
        }
        /// <p>Specifies the baseline input/output (I/O) performance of EBS volumes attached to data nodes. Applicable only for the <code>gp3</code> and provisioned IOPS EBS volume types.</p>
        pub fn iops(mut self, input: i32) -> Self {
            self.iops = Some(input);
            self
        }
        /// <p>Specifies the baseline input/output (I/O) performance of EBS volumes attached to data nodes. Applicable only for the <code>gp3</code> and provisioned IOPS EBS volume types.</p>
        pub fn set_iops(mut self, input: std::option::Option<i32>) -> Self {
            self.iops = input;
            self
        }
        /// <p>Specifies the throughput (in MiB/s) of the EBS volumes attached to data nodes. Applicable only for the <code>gp3</code> volume type.</p>
        pub fn throughput(mut self, input: i32) -> Self {
            self.throughput = Some(input);
            self
        }
        /// <p>Specifies the throughput (in MiB/s) of the EBS volumes attached to data nodes. Applicable only for the <code>gp3</code> volume type.</p>
        pub fn set_throughput(mut self, input: std::option::Option<i32>) -> Self {
            self.throughput = input;
            self
        }
        /// Consumes the builder and constructs a [`EbsOptions`](crate::model::EbsOptions).
        pub fn build(self) -> crate::model::EbsOptions {
            crate::model::EbsOptions {
                ebs_enabled: self.ebs_enabled,
                volume_type: self.volume_type,
                volume_size: self.volume_size,
                iops: self.iops,
                throughput: self.throughput,
            }
        }
    }
}
impl EbsOptions {
    /// Creates a new builder-style object to manufacture [`EbsOptions`](crate::model::EbsOptions).
    pub fn builder() -> crate::model::ebs_options::Builder {
        crate::model::ebs_options::Builder::default()
    }
}

/// When writing a match expression against `VolumeType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let volumetype = unimplemented!();
/// match volumetype {
///     VolumeType::Gp2 => { /* ... */ },
///     VolumeType::Gp3 => { /* ... */ },
///     VolumeType::Io1 => { /* ... */ },
///     VolumeType::Standard => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `volumetype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `VolumeType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `VolumeType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `VolumeType::NewFeature` is defined.
/// Specifically, when `volumetype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `VolumeType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
/// <p>The type of EBS volume that a domain uses. For more information, see <a href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/opensearch-createupdatedomains.html#opensearch-createdomain-configure-ebs">Configuring EBS-based storage</a>.</p>
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum VolumeType {
    #[allow(missing_docs)] // documentation missing in model
    Gp2,
    #[allow(missing_docs)] // documentation missing in model
    Gp3,
    #[allow(missing_docs)] // documentation missing in model
    Io1,
    #[allow(missing_docs)] // documentation missing in model
    Standard,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for VolumeType {
    fn from(s: &str) -> Self {
        match s {
            "gp2" => VolumeType::Gp2,
            "gp3" => VolumeType::Gp3,
            "io1" => VolumeType::Io1,
            "standard" => VolumeType::Standard,
            other => VolumeType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for VolumeType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(VolumeType::from(s))
    }
}
impl VolumeType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            VolumeType::Gp2 => "gp2",
            VolumeType::Gp3 => "gp3",
            VolumeType::Io1 => "io1",
            VolumeType::Standard => "standard",
            VolumeType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["gp2", "gp3", "io1", "standard"]
    }
}
impl AsRef<str> for VolumeType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The cluster configuration status for a domain.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ClusterConfigStatus {
    /// <p>Cluster configuration options for the specified domain.</p>
    #[doc(hidden)]
    pub options: std::option::Option<crate::model::ClusterConfig>,
    /// <p>The status of cluster configuration options for the specified domain.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::OptionStatus>,
}
impl ClusterConfigStatus {
    /// <p>Cluster configuration options for the specified domain.</p>
    pub fn options(&self) -> std::option::Option<&crate::model::ClusterConfig> {
        self.options.as_ref()
    }
    /// <p>The status of cluster configuration options for the specified domain.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::OptionStatus> {
        self.status.as_ref()
    }
}
/// See [`ClusterConfigStatus`](crate::model::ClusterConfigStatus).
pub mod cluster_config_status {

    /// A builder for [`ClusterConfigStatus`](crate::model::ClusterConfigStatus).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) options: std::option::Option<crate::model::ClusterConfig>,
        pub(crate) status: std::option::Option<crate::model::OptionStatus>,
    }
    impl Builder {
        /// <p>Cluster configuration options for the specified domain.</p>
        pub fn options(mut self, input: crate::model::ClusterConfig) -> Self {
            self.options = Some(input);
            self
        }
        /// <p>Cluster configuration options for the specified domain.</p>
        pub fn set_options(
            mut self,
            input: std::option::Option<crate::model::ClusterConfig>,
        ) -> Self {
            self.options = input;
            self
        }
        /// <p>The status of cluster configuration options for the specified domain.</p>
        pub fn status(mut self, input: crate::model::OptionStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of cluster configuration options for the specified domain.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::OptionStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// Consumes the builder and constructs a [`ClusterConfigStatus`](crate::model::ClusterConfigStatus).
        pub fn build(self) -> crate::model::ClusterConfigStatus {
            crate::model::ClusterConfigStatus {
                options: self.options,
                status: self.status,
            }
        }
    }
}
impl ClusterConfigStatus {
    /// Creates a new builder-style object to manufacture [`ClusterConfigStatus`](crate::model::ClusterConfigStatus).
    pub fn builder() -> crate::model::cluster_config_status::Builder {
        crate::model::cluster_config_status::Builder::default()
    }
}

/// <p>Container for the cluster configuration of an OpenSearch Service domain. For more information, see <a href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/createupdatedomains.html">Creating and managing Amazon OpenSearch Service domains</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ClusterConfig {
    /// <p>Instance type of data nodes in the cluster.</p>
    #[doc(hidden)]
    pub instance_type: std::option::Option<crate::model::OpenSearchPartitionInstanceType>,
    /// <p>Number of dedicated master nodes in the cluster. This number must be greater than 1, otherwise you receive a validation exception.</p>
    #[doc(hidden)]
    pub instance_count: std::option::Option<i32>,
    /// <p>Indicates whether dedicated master nodes are enabled for the cluster.<code>True</code> if the cluster will use a dedicated master node.<code>False</code> if the cluster will not.</p>
    #[doc(hidden)]
    pub dedicated_master_enabled: std::option::Option<bool>,
    /// <p>Indicates whether multiple Availability Zones are enabled. For more information, see <a href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/managedomains-multiaz.html">Configuring a multi-AZ domain in Amazon OpenSearch Service</a>.</p>
    #[doc(hidden)]
    pub zone_awareness_enabled: std::option::Option<bool>,
    /// <p>Container for zone awareness configuration options. Only required if <code>ZoneAwarenessEnabled</code> is <code>true</code>.</p>
    #[doc(hidden)]
    pub zone_awareness_config: std::option::Option<crate::model::ZoneAwarenessConfig>,
    /// <p>OpenSearch Service instance type of the dedicated master nodes in the cluster.</p>
    #[doc(hidden)]
    pub dedicated_master_type: std::option::Option<crate::model::OpenSearchPartitionInstanceType>,
    /// <p>Number of dedicated master nodes in the cluster. This number must be greater than 1, otherwise you receive a validation exception.</p>
    #[doc(hidden)]
    pub dedicated_master_count: std::option::Option<i32>,
    /// <p>Whether to enable warm storage for the cluster.</p>
    #[doc(hidden)]
    pub warm_enabled: std::option::Option<bool>,
    /// <p>The instance type for the cluster's warm nodes.</p>
    #[doc(hidden)]
    pub warm_type: std::option::Option<crate::model::OpenSearchWarmPartitionInstanceType>,
    /// <p>The number of warm nodes in the cluster.</p>
    #[doc(hidden)]
    pub warm_count: std::option::Option<i32>,
    /// <p>Container for cold storage configuration options.</p>
    #[doc(hidden)]
    pub cold_storage_options: std::option::Option<crate::model::ColdStorageOptions>,
}
impl ClusterConfig {
    /// <p>Instance type of data nodes in the cluster.</p>
    pub fn instance_type(
        &self,
    ) -> std::option::Option<&crate::model::OpenSearchPartitionInstanceType> {
        self.instance_type.as_ref()
    }
    /// <p>Number of dedicated master nodes in the cluster. This number must be greater than 1, otherwise you receive a validation exception.</p>
    pub fn instance_count(&self) -> std::option::Option<i32> {
        self.instance_count
    }
    /// <p>Indicates whether dedicated master nodes are enabled for the cluster.<code>True</code> if the cluster will use a dedicated master node.<code>False</code> if the cluster will not.</p>
    pub fn dedicated_master_enabled(&self) -> std::option::Option<bool> {
        self.dedicated_master_enabled
    }
    /// <p>Indicates whether multiple Availability Zones are enabled. For more information, see <a href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/managedomains-multiaz.html">Configuring a multi-AZ domain in Amazon OpenSearch Service</a>.</p>
    pub fn zone_awareness_enabled(&self) -> std::option::Option<bool> {
        self.zone_awareness_enabled
    }
    /// <p>Container for zone awareness configuration options. Only required if <code>ZoneAwarenessEnabled</code> is <code>true</code>.</p>
    pub fn zone_awareness_config(&self) -> std::option::Option<&crate::model::ZoneAwarenessConfig> {
        self.zone_awareness_config.as_ref()
    }
    /// <p>OpenSearch Service instance type of the dedicated master nodes in the cluster.</p>
    pub fn dedicated_master_type(
        &self,
    ) -> std::option::Option<&crate::model::OpenSearchPartitionInstanceType> {
        self.dedicated_master_type.as_ref()
    }
    /// <p>Number of dedicated master nodes in the cluster. This number must be greater than 1, otherwise you receive a validation exception.</p>
    pub fn dedicated_master_count(&self) -> std::option::Option<i32> {
        self.dedicated_master_count
    }
    /// <p>Whether to enable warm storage for the cluster.</p>
    pub fn warm_enabled(&self) -> std::option::Option<bool> {
        self.warm_enabled
    }
    /// <p>The instance type for the cluster's warm nodes.</p>
    pub fn warm_type(
        &self,
    ) -> std::option::Option<&crate::model::OpenSearchWarmPartitionInstanceType> {
        self.warm_type.as_ref()
    }
    /// <p>The number of warm nodes in the cluster.</p>
    pub fn warm_count(&self) -> std::option::Option<i32> {
        self.warm_count
    }
    /// <p>Container for cold storage configuration options.</p>
    pub fn cold_storage_options(&self) -> std::option::Option<&crate::model::ColdStorageOptions> {
        self.cold_storage_options.as_ref()
    }
}
/// See [`ClusterConfig`](crate::model::ClusterConfig).
pub mod cluster_config {

    /// A builder for [`ClusterConfig`](crate::model::ClusterConfig).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_type:
            std::option::Option<crate::model::OpenSearchPartitionInstanceType>,
        pub(crate) instance_count: std::option::Option<i32>,
        pub(crate) dedicated_master_enabled: std::option::Option<bool>,
        pub(crate) zone_awareness_enabled: std::option::Option<bool>,
        pub(crate) zone_awareness_config: std::option::Option<crate::model::ZoneAwarenessConfig>,
        pub(crate) dedicated_master_type:
            std::option::Option<crate::model::OpenSearchPartitionInstanceType>,
        pub(crate) dedicated_master_count: std::option::Option<i32>,
        pub(crate) warm_enabled: std::option::Option<bool>,
        pub(crate) warm_type:
            std::option::Option<crate::model::OpenSearchWarmPartitionInstanceType>,
        pub(crate) warm_count: std::option::Option<i32>,
        pub(crate) cold_storage_options: std::option::Option<crate::model::ColdStorageOptions>,
    }
    impl Builder {
        /// <p>Instance type of data nodes in the cluster.</p>
        pub fn instance_type(
            mut self,
            input: crate::model::OpenSearchPartitionInstanceType,
        ) -> Self {
            self.instance_type = Some(input);
            self
        }
        /// <p>Instance type of data nodes in the cluster.</p>
        pub fn set_instance_type(
            mut self,
            input: std::option::Option<crate::model::OpenSearchPartitionInstanceType>,
        ) -> Self {
            self.instance_type = input;
            self
        }
        /// <p>Number of dedicated master nodes in the cluster. This number must be greater than 1, otherwise you receive a validation exception.</p>
        pub fn instance_count(mut self, input: i32) -> Self {
            self.instance_count = Some(input);
            self
        }
        /// <p>Number of dedicated master nodes in the cluster. This number must be greater than 1, otherwise you receive a validation exception.</p>
        pub fn set_instance_count(mut self, input: std::option::Option<i32>) -> Self {
            self.instance_count = input;
            self
        }
        /// <p>Indicates whether dedicated master nodes are enabled for the cluster.<code>True</code> if the cluster will use a dedicated master node.<code>False</code> if the cluster will not.</p>
        pub fn dedicated_master_enabled(mut self, input: bool) -> Self {
            self.dedicated_master_enabled = Some(input);
            self
        }
        /// <p>Indicates whether dedicated master nodes are enabled for the cluster.<code>True</code> if the cluster will use a dedicated master node.<code>False</code> if the cluster will not.</p>
        pub fn set_dedicated_master_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.dedicated_master_enabled = input;
            self
        }
        /// <p>Indicates whether multiple Availability Zones are enabled. For more information, see <a href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/managedomains-multiaz.html">Configuring a multi-AZ domain in Amazon OpenSearch Service</a>.</p>
        pub fn zone_awareness_enabled(mut self, input: bool) -> Self {
            self.zone_awareness_enabled = Some(input);
            self
        }
        /// <p>Indicates whether multiple Availability Zones are enabled. For more information, see <a href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/managedomains-multiaz.html">Configuring a multi-AZ domain in Amazon OpenSearch Service</a>.</p>
        pub fn set_zone_awareness_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.zone_awareness_enabled = input;
            self
        }
        /// <p>Container for zone awareness configuration options. Only required if <code>ZoneAwarenessEnabled</code> is <code>true</code>.</p>
        pub fn zone_awareness_config(mut self, input: crate::model::ZoneAwarenessConfig) -> Self {
            self.zone_awareness_config = Some(input);
            self
        }
        /// <p>Container for zone awareness configuration options. Only required if <code>ZoneAwarenessEnabled</code> is <code>true</code>.</p>
        pub fn set_zone_awareness_config(
            mut self,
            input: std::option::Option<crate::model::ZoneAwarenessConfig>,
        ) -> Self {
            self.zone_awareness_config = input;
            self
        }
        /// <p>OpenSearch Service instance type of the dedicated master nodes in the cluster.</p>
        pub fn dedicated_master_type(
            mut self,
            input: crate::model::OpenSearchPartitionInstanceType,
        ) -> Self {
            self.dedicated_master_type = Some(input);
            self
        }
        /// <p>OpenSearch Service instance type of the dedicated master nodes in the cluster.</p>
        pub fn set_dedicated_master_type(
            mut self,
            input: std::option::Option<crate::model::OpenSearchPartitionInstanceType>,
        ) -> Self {
            self.dedicated_master_type = input;
            self
        }
        /// <p>Number of dedicated master nodes in the cluster. This number must be greater than 1, otherwise you receive a validation exception.</p>
        pub fn dedicated_master_count(mut self, input: i32) -> Self {
            self.dedicated_master_count = Some(input);
            self
        }
        /// <p>Number of dedicated master nodes in the cluster. This number must be greater than 1, otherwise you receive a validation exception.</p>
        pub fn set_dedicated_master_count(mut self, input: std::option::Option<i32>) -> Self {
            self.dedicated_master_count = input;
            self
        }
        /// <p>Whether to enable warm storage for the cluster.</p>
        pub fn warm_enabled(mut self, input: bool) -> Self {
            self.warm_enabled = Some(input);
            self
        }
        /// <p>Whether to enable warm storage for the cluster.</p>
        pub fn set_warm_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.warm_enabled = input;
            self
        }
        /// <p>The instance type for the cluster's warm nodes.</p>
        pub fn warm_type(
            mut self,
            input: crate::model::OpenSearchWarmPartitionInstanceType,
        ) -> Self {
            self.warm_type = Some(input);
            self
        }
        /// <p>The instance type for the cluster's warm nodes.</p>
        pub fn set_warm_type(
            mut self,
            input: std::option::Option<crate::model::OpenSearchWarmPartitionInstanceType>,
        ) -> Self {
            self.warm_type = input;
            self
        }
        /// <p>The number of warm nodes in the cluster.</p>
        pub fn warm_count(mut self, input: i32) -> Self {
            self.warm_count = Some(input);
            self
        }
        /// <p>The number of warm nodes in the cluster.</p>
        pub fn set_warm_count(mut self, input: std::option::Option<i32>) -> Self {
            self.warm_count = input;
            self
        }
        /// <p>Container for cold storage configuration options.</p>
        pub fn cold_storage_options(mut self, input: crate::model::ColdStorageOptions) -> Self {
            self.cold_storage_options = Some(input);
            self
        }
        /// <p>Container for cold storage configuration options.</p>
        pub fn set_cold_storage_options(
            mut self,
            input: std::option::Option<crate::model::ColdStorageOptions>,
        ) -> Self {
            self.cold_storage_options = input;
            self
        }
        /// Consumes the builder and constructs a [`ClusterConfig`](crate::model::ClusterConfig).
        pub fn build(self) -> crate::model::ClusterConfig {
            crate::model::ClusterConfig {
                instance_type: self.instance_type,
                instance_count: self.instance_count,
                dedicated_master_enabled: self.dedicated_master_enabled,
                zone_awareness_enabled: self.zone_awareness_enabled,
                zone_awareness_config: self.zone_awareness_config,
                dedicated_master_type: self.dedicated_master_type,
                dedicated_master_count: self.dedicated_master_count,
                warm_enabled: self.warm_enabled,
                warm_type: self.warm_type,
                warm_count: self.warm_count,
                cold_storage_options: self.cold_storage_options,
            }
        }
    }
}
impl ClusterConfig {
    /// Creates a new builder-style object to manufacture [`ClusterConfig`](crate::model::ClusterConfig).
    pub fn builder() -> crate::model::cluster_config::Builder {
        crate::model::cluster_config::Builder::default()
    }
}

/// <p>Container for the parameters required to enable cold storage for an OpenSearch Service domain. For more information, see <a href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/cold-storage.html">Cold storage for Amazon OpenSearch Service</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ColdStorageOptions {
    /// <p>Whether to enable or disable cold storage on the domain.</p>
    #[doc(hidden)]
    pub enabled: std::option::Option<bool>,
}
impl ColdStorageOptions {
    /// <p>Whether to enable or disable cold storage on the domain.</p>
    pub fn enabled(&self) -> std::option::Option<bool> {
        self.enabled
    }
}
/// See [`ColdStorageOptions`](crate::model::ColdStorageOptions).
pub mod cold_storage_options {

    /// A builder for [`ColdStorageOptions`](crate::model::ColdStorageOptions).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) enabled: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>Whether to enable or disable cold storage on the domain.</p>
        pub fn enabled(mut self, input: bool) -> Self {
            self.enabled = Some(input);
            self
        }
        /// <p>Whether to enable or disable cold storage on the domain.</p>
        pub fn set_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.enabled = input;
            self
        }
        /// Consumes the builder and constructs a [`ColdStorageOptions`](crate::model::ColdStorageOptions).
        pub fn build(self) -> crate::model::ColdStorageOptions {
            crate::model::ColdStorageOptions {
                enabled: self.enabled,
            }
        }
    }
}
impl ColdStorageOptions {
    /// Creates a new builder-style object to manufacture [`ColdStorageOptions`](crate::model::ColdStorageOptions).
    pub fn builder() -> crate::model::cold_storage_options::Builder {
        crate::model::cold_storage_options::Builder::default()
    }
}

/// When writing a match expression against `OpenSearchWarmPartitionInstanceType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let opensearchwarmpartitioninstancetype = unimplemented!();
/// match opensearchwarmpartitioninstancetype {
///     OpenSearchWarmPartitionInstanceType::Ultrawarm1LargeSearch => { /* ... */ },
///     OpenSearchWarmPartitionInstanceType::Ultrawarm1MediumSearch => { /* ... */ },
///     OpenSearchWarmPartitionInstanceType::Ultrawarm1XlargeSearch => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `opensearchwarmpartitioninstancetype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `OpenSearchWarmPartitionInstanceType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `OpenSearchWarmPartitionInstanceType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `OpenSearchWarmPartitionInstanceType::NewFeature` is defined.
/// Specifically, when `opensearchwarmpartitioninstancetype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `OpenSearchWarmPartitionInstanceType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum OpenSearchWarmPartitionInstanceType {
    #[allow(missing_docs)] // documentation missing in model
    Ultrawarm1LargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    Ultrawarm1MediumSearch,
    #[allow(missing_docs)] // documentation missing in model
    Ultrawarm1XlargeSearch,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for OpenSearchWarmPartitionInstanceType {
    fn from(s: &str) -> Self {
        match s {
            "ultrawarm1.large.search" => OpenSearchWarmPartitionInstanceType::Ultrawarm1LargeSearch,
            "ultrawarm1.medium.search" => {
                OpenSearchWarmPartitionInstanceType::Ultrawarm1MediumSearch
            }
            "ultrawarm1.xlarge.search" => {
                OpenSearchWarmPartitionInstanceType::Ultrawarm1XlargeSearch
            }
            other => OpenSearchWarmPartitionInstanceType::Unknown(
                crate::types::UnknownVariantValue(other.to_owned()),
            ),
        }
    }
}
impl std::str::FromStr for OpenSearchWarmPartitionInstanceType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(OpenSearchWarmPartitionInstanceType::from(s))
    }
}
impl OpenSearchWarmPartitionInstanceType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            OpenSearchWarmPartitionInstanceType::Ultrawarm1LargeSearch => "ultrawarm1.large.search",
            OpenSearchWarmPartitionInstanceType::Ultrawarm1MediumSearch => {
                "ultrawarm1.medium.search"
            }
            OpenSearchWarmPartitionInstanceType::Ultrawarm1XlargeSearch => {
                "ultrawarm1.xlarge.search"
            }
            OpenSearchWarmPartitionInstanceType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "ultrawarm1.large.search",
            "ultrawarm1.medium.search",
            "ultrawarm1.xlarge.search",
        ]
    }
}
impl AsRef<str> for OpenSearchWarmPartitionInstanceType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `OpenSearchPartitionInstanceType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let opensearchpartitioninstancetype = unimplemented!();
/// match opensearchpartitioninstancetype {
///     OpenSearchPartitionInstanceType::C42xlargeSearch => { /* ... */ },
///     OpenSearchPartitionInstanceType::C44xlargeSearch => { /* ... */ },
///     OpenSearchPartitionInstanceType::C48xlargeSearch => { /* ... */ },
///     OpenSearchPartitionInstanceType::C4LargeSearch => { /* ... */ },
///     OpenSearchPartitionInstanceType::C4XlargeSearch => { /* ... */ },
///     OpenSearchPartitionInstanceType::C518xlargeSearch => { /* ... */ },
///     OpenSearchPartitionInstanceType::C52xlargeSearch => { /* ... */ },
///     OpenSearchPartitionInstanceType::C54xlargeSearch => { /* ... */ },
///     OpenSearchPartitionInstanceType::C59xlargeSearch => { /* ... */ },
///     OpenSearchPartitionInstanceType::C5LargeSearch => { /* ... */ },
///     OpenSearchPartitionInstanceType::C5XlargeSearch => { /* ... */ },
///     OpenSearchPartitionInstanceType::C6g12xlargeSearch => { /* ... */ },
///     OpenSearchPartitionInstanceType::C6g2xlargeSearch => { /* ... */ },
///     OpenSearchPartitionInstanceType::C6g4xlargeSearch => { /* ... */ },
///     OpenSearchPartitionInstanceType::C6g8xlargeSearch => { /* ... */ },
///     OpenSearchPartitionInstanceType::C6gLargeSearch => { /* ... */ },
///     OpenSearchPartitionInstanceType::C6gXlargeSearch => { /* ... */ },
///     OpenSearchPartitionInstanceType::D22xlargeSearch => { /* ... */ },
///     OpenSearchPartitionInstanceType::D24xlargeSearch => { /* ... */ },
///     OpenSearchPartitionInstanceType::D28xlargeSearch => { /* ... */ },
///     OpenSearchPartitionInstanceType::D2XlargeSearch => { /* ... */ },
///     OpenSearchPartitionInstanceType::I22xlargeSearch => { /* ... */ },
///     OpenSearchPartitionInstanceType::I2XlargeSearch => { /* ... */ },
///     OpenSearchPartitionInstanceType::I316xlargeSearch => { /* ... */ },
///     OpenSearchPartitionInstanceType::I32xlargeSearch => { /* ... */ },
///     OpenSearchPartitionInstanceType::I34xlargeSearch => { /* ... */ },
///     OpenSearchPartitionInstanceType::I38xlargeSearch => { /* ... */ },
///     OpenSearchPartitionInstanceType::I3LargeSearch => { /* ... */ },
///     OpenSearchPartitionInstanceType::I3XlargeSearch => { /* ... */ },
///     OpenSearchPartitionInstanceType::M32xlargeSearch => { /* ... */ },
///     OpenSearchPartitionInstanceType::M3LargeSearch => { /* ... */ },
///     OpenSearchPartitionInstanceType::M3MediumSearch => { /* ... */ },
///     OpenSearchPartitionInstanceType::M3XlargeSearch => { /* ... */ },
///     OpenSearchPartitionInstanceType::M410xlargeSearch => { /* ... */ },
///     OpenSearchPartitionInstanceType::M42xlargeSearch => { /* ... */ },
///     OpenSearchPartitionInstanceType::M44xlargeSearch => { /* ... */ },
///     OpenSearchPartitionInstanceType::M4LargeSearch => { /* ... */ },
///     OpenSearchPartitionInstanceType::M4XlargeSearch => { /* ... */ },
///     OpenSearchPartitionInstanceType::M512xlargeSearch => { /* ... */ },
///     OpenSearchPartitionInstanceType::M524xlargeSearch => { /* ... */ },
///     OpenSearchPartitionInstanceType::M52xlargeSearch => { /* ... */ },
///     OpenSearchPartitionInstanceType::M54xlargeSearch => { /* ... */ },
///     OpenSearchPartitionInstanceType::M5LargeSearch => { /* ... */ },
///     OpenSearchPartitionInstanceType::M5XlargeSearch => { /* ... */ },
///     OpenSearchPartitionInstanceType::M6g12xlargeSearch => { /* ... */ },
///     OpenSearchPartitionInstanceType::M6g2xlargeSearch => { /* ... */ },
///     OpenSearchPartitionInstanceType::M6g4xlargeSearch => { /* ... */ },
///     OpenSearchPartitionInstanceType::M6g8xlargeSearch => { /* ... */ },
///     OpenSearchPartitionInstanceType::M6gLargeSearch => { /* ... */ },
///     OpenSearchPartitionInstanceType::M6gXlargeSearch => { /* ... */ },
///     OpenSearchPartitionInstanceType::R32xlargeSearch => { /* ... */ },
///     OpenSearchPartitionInstanceType::R34xlargeSearch => { /* ... */ },
///     OpenSearchPartitionInstanceType::R38xlargeSearch => { /* ... */ },
///     OpenSearchPartitionInstanceType::R3LargeSearch => { /* ... */ },
///     OpenSearchPartitionInstanceType::R3XlargeSearch => { /* ... */ },
///     OpenSearchPartitionInstanceType::R416xlargeSearch => { /* ... */ },
///     OpenSearchPartitionInstanceType::R42xlargeSearch => { /* ... */ },
///     OpenSearchPartitionInstanceType::R44xlargeSearch => { /* ... */ },
///     OpenSearchPartitionInstanceType::R48xlargeSearch => { /* ... */ },
///     OpenSearchPartitionInstanceType::R4LargeSearch => { /* ... */ },
///     OpenSearchPartitionInstanceType::R4XlargeSearch => { /* ... */ },
///     OpenSearchPartitionInstanceType::R512xlargeSearch => { /* ... */ },
///     OpenSearchPartitionInstanceType::R524xlargeSearch => { /* ... */ },
///     OpenSearchPartitionInstanceType::R52xlargeSearch => { /* ... */ },
///     OpenSearchPartitionInstanceType::R54xlargeSearch => { /* ... */ },
///     OpenSearchPartitionInstanceType::R5LargeSearch => { /* ... */ },
///     OpenSearchPartitionInstanceType::R5XlargeSearch => { /* ... */ },
///     OpenSearchPartitionInstanceType::R6g12xlargeSearch => { /* ... */ },
///     OpenSearchPartitionInstanceType::R6g2xlargeSearch => { /* ... */ },
///     OpenSearchPartitionInstanceType::R6g4xlargeSearch => { /* ... */ },
///     OpenSearchPartitionInstanceType::R6g8xlargeSearch => { /* ... */ },
///     OpenSearchPartitionInstanceType::R6gLargeSearch => { /* ... */ },
///     OpenSearchPartitionInstanceType::R6gXlargeSearch => { /* ... */ },
///     OpenSearchPartitionInstanceType::R6gd12xlargeSearch => { /* ... */ },
///     OpenSearchPartitionInstanceType::R6gd16xlargeSearch => { /* ... */ },
///     OpenSearchPartitionInstanceType::R6gd2xlargeSearch => { /* ... */ },
///     OpenSearchPartitionInstanceType::R6gd4xlargeSearch => { /* ... */ },
///     OpenSearchPartitionInstanceType::R6gd8xlargeSearch => { /* ... */ },
///     OpenSearchPartitionInstanceType::R6gdLargeSearch => { /* ... */ },
///     OpenSearchPartitionInstanceType::R6gdXlargeSearch => { /* ... */ },
///     OpenSearchPartitionInstanceType::T2MediumSearch => { /* ... */ },
///     OpenSearchPartitionInstanceType::T2MicroSearch => { /* ... */ },
///     OpenSearchPartitionInstanceType::T2SmallSearch => { /* ... */ },
///     OpenSearchPartitionInstanceType::T32xlargeSearch => { /* ... */ },
///     OpenSearchPartitionInstanceType::T3LargeSearch => { /* ... */ },
///     OpenSearchPartitionInstanceType::T3MediumSearch => { /* ... */ },
///     OpenSearchPartitionInstanceType::T3MicroSearch => { /* ... */ },
///     OpenSearchPartitionInstanceType::T3NanoSearch => { /* ... */ },
///     OpenSearchPartitionInstanceType::T3SmallSearch => { /* ... */ },
///     OpenSearchPartitionInstanceType::T3XlargeSearch => { /* ... */ },
///     OpenSearchPartitionInstanceType::T4gMediumSearch => { /* ... */ },
///     OpenSearchPartitionInstanceType::T4gSmallSearch => { /* ... */ },
///     OpenSearchPartitionInstanceType::Ultrawarm1LargeSearch => { /* ... */ },
///     OpenSearchPartitionInstanceType::Ultrawarm1MediumSearch => { /* ... */ },
///     OpenSearchPartitionInstanceType::Ultrawarm1XlargeSearch => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `opensearchpartitioninstancetype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `OpenSearchPartitionInstanceType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `OpenSearchPartitionInstanceType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `OpenSearchPartitionInstanceType::NewFeature` is defined.
/// Specifically, when `opensearchpartitioninstancetype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `OpenSearchPartitionInstanceType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum OpenSearchPartitionInstanceType {
    #[allow(missing_docs)] // documentation missing in model
    C42xlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    C44xlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    C48xlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    C4LargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    C4XlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    C518xlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    C52xlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    C54xlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    C59xlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    C5LargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    C5XlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    C6g12xlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    C6g2xlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    C6g4xlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    C6g8xlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    C6gLargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    C6gXlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    D22xlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    D24xlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    D28xlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    D2XlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    I22xlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    I2XlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    I316xlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    I32xlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    I34xlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    I38xlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    I3LargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    I3XlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    M32xlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    M3LargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    M3MediumSearch,
    #[allow(missing_docs)] // documentation missing in model
    M3XlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    M410xlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    M42xlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    M44xlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    M4LargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    M4XlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    M512xlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    M524xlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    M52xlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    M54xlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    M5LargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    M5XlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    M6g12xlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    M6g2xlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    M6g4xlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    M6g8xlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    M6gLargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    M6gXlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    R32xlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    R34xlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    R38xlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    R3LargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    R3XlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    R416xlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    R42xlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    R44xlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    R48xlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    R4LargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    R4XlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    R512xlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    R524xlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    R52xlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    R54xlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    R5LargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    R5XlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    R6g12xlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    R6g2xlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    R6g4xlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    R6g8xlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    R6gLargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    R6gXlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    R6gd12xlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    R6gd16xlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    R6gd2xlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    R6gd4xlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    R6gd8xlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    R6gdLargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    R6gdXlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    T2MediumSearch,
    #[allow(missing_docs)] // documentation missing in model
    T2MicroSearch,
    #[allow(missing_docs)] // documentation missing in model
    T2SmallSearch,
    #[allow(missing_docs)] // documentation missing in model
    T32xlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    T3LargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    T3MediumSearch,
    #[allow(missing_docs)] // documentation missing in model
    T3MicroSearch,
    #[allow(missing_docs)] // documentation missing in model
    T3NanoSearch,
    #[allow(missing_docs)] // documentation missing in model
    T3SmallSearch,
    #[allow(missing_docs)] // documentation missing in model
    T3XlargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    T4gMediumSearch,
    #[allow(missing_docs)] // documentation missing in model
    T4gSmallSearch,
    #[allow(missing_docs)] // documentation missing in model
    Ultrawarm1LargeSearch,
    #[allow(missing_docs)] // documentation missing in model
    Ultrawarm1MediumSearch,
    #[allow(missing_docs)] // documentation missing in model
    Ultrawarm1XlargeSearch,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for OpenSearchPartitionInstanceType {
    fn from(s: &str) -> Self {
        match s {
            "c4.2xlarge.search" => OpenSearchPartitionInstanceType::C42xlargeSearch,
            "c4.4xlarge.search" => OpenSearchPartitionInstanceType::C44xlargeSearch,
            "c4.8xlarge.search" => OpenSearchPartitionInstanceType::C48xlargeSearch,
            "c4.large.search" => OpenSearchPartitionInstanceType::C4LargeSearch,
            "c4.xlarge.search" => OpenSearchPartitionInstanceType::C4XlargeSearch,
            "c5.18xlarge.search" => OpenSearchPartitionInstanceType::C518xlargeSearch,
            "c5.2xlarge.search" => OpenSearchPartitionInstanceType::C52xlargeSearch,
            "c5.4xlarge.search" => OpenSearchPartitionInstanceType::C54xlargeSearch,
            "c5.9xlarge.search" => OpenSearchPartitionInstanceType::C59xlargeSearch,
            "c5.large.search" => OpenSearchPartitionInstanceType::C5LargeSearch,
            "c5.xlarge.search" => OpenSearchPartitionInstanceType::C5XlargeSearch,
            "c6g.12xlarge.search" => OpenSearchPartitionInstanceType::C6g12xlargeSearch,
            "c6g.2xlarge.search" => OpenSearchPartitionInstanceType::C6g2xlargeSearch,
            "c6g.4xlarge.search" => OpenSearchPartitionInstanceType::C6g4xlargeSearch,
            "c6g.8xlarge.search" => OpenSearchPartitionInstanceType::C6g8xlargeSearch,
            "c6g.large.search" => OpenSearchPartitionInstanceType::C6gLargeSearch,
            "c6g.xlarge.search" => OpenSearchPartitionInstanceType::C6gXlargeSearch,
            "d2.2xlarge.search" => OpenSearchPartitionInstanceType::D22xlargeSearch,
            "d2.4xlarge.search" => OpenSearchPartitionInstanceType::D24xlargeSearch,
            "d2.8xlarge.search" => OpenSearchPartitionInstanceType::D28xlargeSearch,
            "d2.xlarge.search" => OpenSearchPartitionInstanceType::D2XlargeSearch,
            "i2.2xlarge.search" => OpenSearchPartitionInstanceType::I22xlargeSearch,
            "i2.xlarge.search" => OpenSearchPartitionInstanceType::I2XlargeSearch,
            "i3.16xlarge.search" => OpenSearchPartitionInstanceType::I316xlargeSearch,
            "i3.2xlarge.search" => OpenSearchPartitionInstanceType::I32xlargeSearch,
            "i3.4xlarge.search" => OpenSearchPartitionInstanceType::I34xlargeSearch,
            "i3.8xlarge.search" => OpenSearchPartitionInstanceType::I38xlargeSearch,
            "i3.large.search" => OpenSearchPartitionInstanceType::I3LargeSearch,
            "i3.xlarge.search" => OpenSearchPartitionInstanceType::I3XlargeSearch,
            "m3.2xlarge.search" => OpenSearchPartitionInstanceType::M32xlargeSearch,
            "m3.large.search" => OpenSearchPartitionInstanceType::M3LargeSearch,
            "m3.medium.search" => OpenSearchPartitionInstanceType::M3MediumSearch,
            "m3.xlarge.search" => OpenSearchPartitionInstanceType::M3XlargeSearch,
            "m4.10xlarge.search" => OpenSearchPartitionInstanceType::M410xlargeSearch,
            "m4.2xlarge.search" => OpenSearchPartitionInstanceType::M42xlargeSearch,
            "m4.4xlarge.search" => OpenSearchPartitionInstanceType::M44xlargeSearch,
            "m4.large.search" => OpenSearchPartitionInstanceType::M4LargeSearch,
            "m4.xlarge.search" => OpenSearchPartitionInstanceType::M4XlargeSearch,
            "m5.12xlarge.search" => OpenSearchPartitionInstanceType::M512xlargeSearch,
            "m5.24xlarge.search" => OpenSearchPartitionInstanceType::M524xlargeSearch,
            "m5.2xlarge.search" => OpenSearchPartitionInstanceType::M52xlargeSearch,
            "m5.4xlarge.search" => OpenSearchPartitionInstanceType::M54xlargeSearch,
            "m5.large.search" => OpenSearchPartitionInstanceType::M5LargeSearch,
            "m5.xlarge.search" => OpenSearchPartitionInstanceType::M5XlargeSearch,
            "m6g.12xlarge.search" => OpenSearchPartitionInstanceType::M6g12xlargeSearch,
            "m6g.2xlarge.search" => OpenSearchPartitionInstanceType::M6g2xlargeSearch,
            "m6g.4xlarge.search" => OpenSearchPartitionInstanceType::M6g4xlargeSearch,
            "m6g.8xlarge.search" => OpenSearchPartitionInstanceType::M6g8xlargeSearch,
            "m6g.large.search" => OpenSearchPartitionInstanceType::M6gLargeSearch,
            "m6g.xlarge.search" => OpenSearchPartitionInstanceType::M6gXlargeSearch,
            "r3.2xlarge.search" => OpenSearchPartitionInstanceType::R32xlargeSearch,
            "r3.4xlarge.search" => OpenSearchPartitionInstanceType::R34xlargeSearch,
            "r3.8xlarge.search" => OpenSearchPartitionInstanceType::R38xlargeSearch,
            "r3.large.search" => OpenSearchPartitionInstanceType::R3LargeSearch,
            "r3.xlarge.search" => OpenSearchPartitionInstanceType::R3XlargeSearch,
            "r4.16xlarge.search" => OpenSearchPartitionInstanceType::R416xlargeSearch,
            "r4.2xlarge.search" => OpenSearchPartitionInstanceType::R42xlargeSearch,
            "r4.4xlarge.search" => OpenSearchPartitionInstanceType::R44xlargeSearch,
            "r4.8xlarge.search" => OpenSearchPartitionInstanceType::R48xlargeSearch,
            "r4.large.search" => OpenSearchPartitionInstanceType::R4LargeSearch,
            "r4.xlarge.search" => OpenSearchPartitionInstanceType::R4XlargeSearch,
            "r5.12xlarge.search" => OpenSearchPartitionInstanceType::R512xlargeSearch,
            "r5.24xlarge.search" => OpenSearchPartitionInstanceType::R524xlargeSearch,
            "r5.2xlarge.search" => OpenSearchPartitionInstanceType::R52xlargeSearch,
            "r5.4xlarge.search" => OpenSearchPartitionInstanceType::R54xlargeSearch,
            "r5.large.search" => OpenSearchPartitionInstanceType::R5LargeSearch,
            "r5.xlarge.search" => OpenSearchPartitionInstanceType::R5XlargeSearch,
            "r6g.12xlarge.search" => OpenSearchPartitionInstanceType::R6g12xlargeSearch,
            "r6g.2xlarge.search" => OpenSearchPartitionInstanceType::R6g2xlargeSearch,
            "r6g.4xlarge.search" => OpenSearchPartitionInstanceType::R6g4xlargeSearch,
            "r6g.8xlarge.search" => OpenSearchPartitionInstanceType::R6g8xlargeSearch,
            "r6g.large.search" => OpenSearchPartitionInstanceType::R6gLargeSearch,
            "r6g.xlarge.search" => OpenSearchPartitionInstanceType::R6gXlargeSearch,
            "r6gd.12xlarge.search" => OpenSearchPartitionInstanceType::R6gd12xlargeSearch,
            "r6gd.16xlarge.search" => OpenSearchPartitionInstanceType::R6gd16xlargeSearch,
            "r6gd.2xlarge.search" => OpenSearchPartitionInstanceType::R6gd2xlargeSearch,
            "r6gd.4xlarge.search" => OpenSearchPartitionInstanceType::R6gd4xlargeSearch,
            "r6gd.8xlarge.search" => OpenSearchPartitionInstanceType::R6gd8xlargeSearch,
            "r6gd.large.search" => OpenSearchPartitionInstanceType::R6gdLargeSearch,
            "r6gd.xlarge.search" => OpenSearchPartitionInstanceType::R6gdXlargeSearch,
            "t2.medium.search" => OpenSearchPartitionInstanceType::T2MediumSearch,
            "t2.micro.search" => OpenSearchPartitionInstanceType::T2MicroSearch,
            "t2.small.search" => OpenSearchPartitionInstanceType::T2SmallSearch,
            "t3.2xlarge.search" => OpenSearchPartitionInstanceType::T32xlargeSearch,
            "t3.large.search" => OpenSearchPartitionInstanceType::T3LargeSearch,
            "t3.medium.search" => OpenSearchPartitionInstanceType::T3MediumSearch,
            "t3.micro.search" => OpenSearchPartitionInstanceType::T3MicroSearch,
            "t3.nano.search" => OpenSearchPartitionInstanceType::T3NanoSearch,
            "t3.small.search" => OpenSearchPartitionInstanceType::T3SmallSearch,
            "t3.xlarge.search" => OpenSearchPartitionInstanceType::T3XlargeSearch,
            "t4g.medium.search" => OpenSearchPartitionInstanceType::T4gMediumSearch,
            "t4g.small.search" => OpenSearchPartitionInstanceType::T4gSmallSearch,
            "ultrawarm1.large.search" => OpenSearchPartitionInstanceType::Ultrawarm1LargeSearch,
            "ultrawarm1.medium.search" => OpenSearchPartitionInstanceType::Ultrawarm1MediumSearch,
            "ultrawarm1.xlarge.search" => OpenSearchPartitionInstanceType::Ultrawarm1XlargeSearch,
            other => OpenSearchPartitionInstanceType::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for OpenSearchPartitionInstanceType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(OpenSearchPartitionInstanceType::from(s))
    }
}
impl OpenSearchPartitionInstanceType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            OpenSearchPartitionInstanceType::C42xlargeSearch => "c4.2xlarge.search",
            OpenSearchPartitionInstanceType::C44xlargeSearch => "c4.4xlarge.search",
            OpenSearchPartitionInstanceType::C48xlargeSearch => "c4.8xlarge.search",
            OpenSearchPartitionInstanceType::C4LargeSearch => "c4.large.search",
            OpenSearchPartitionInstanceType::C4XlargeSearch => "c4.xlarge.search",
            OpenSearchPartitionInstanceType::C518xlargeSearch => "c5.18xlarge.search",
            OpenSearchPartitionInstanceType::C52xlargeSearch => "c5.2xlarge.search",
            OpenSearchPartitionInstanceType::C54xlargeSearch => "c5.4xlarge.search",
            OpenSearchPartitionInstanceType::C59xlargeSearch => "c5.9xlarge.search",
            OpenSearchPartitionInstanceType::C5LargeSearch => "c5.large.search",
            OpenSearchPartitionInstanceType::C5XlargeSearch => "c5.xlarge.search",
            OpenSearchPartitionInstanceType::C6g12xlargeSearch => "c6g.12xlarge.search",
            OpenSearchPartitionInstanceType::C6g2xlargeSearch => "c6g.2xlarge.search",
            OpenSearchPartitionInstanceType::C6g4xlargeSearch => "c6g.4xlarge.search",
            OpenSearchPartitionInstanceType::C6g8xlargeSearch => "c6g.8xlarge.search",
            OpenSearchPartitionInstanceType::C6gLargeSearch => "c6g.large.search",
            OpenSearchPartitionInstanceType::C6gXlargeSearch => "c6g.xlarge.search",
            OpenSearchPartitionInstanceType::D22xlargeSearch => "d2.2xlarge.search",
            OpenSearchPartitionInstanceType::D24xlargeSearch => "d2.4xlarge.search",
            OpenSearchPartitionInstanceType::D28xlargeSearch => "d2.8xlarge.search",
            OpenSearchPartitionInstanceType::D2XlargeSearch => "d2.xlarge.search",
            OpenSearchPartitionInstanceType::I22xlargeSearch => "i2.2xlarge.search",
            OpenSearchPartitionInstanceType::I2XlargeSearch => "i2.xlarge.search",
            OpenSearchPartitionInstanceType::I316xlargeSearch => "i3.16xlarge.search",
            OpenSearchPartitionInstanceType::I32xlargeSearch => "i3.2xlarge.search",
            OpenSearchPartitionInstanceType::I34xlargeSearch => "i3.4xlarge.search",
            OpenSearchPartitionInstanceType::I38xlargeSearch => "i3.8xlarge.search",
            OpenSearchPartitionInstanceType::I3LargeSearch => "i3.large.search",
            OpenSearchPartitionInstanceType::I3XlargeSearch => "i3.xlarge.search",
            OpenSearchPartitionInstanceType::M32xlargeSearch => "m3.2xlarge.search",
            OpenSearchPartitionInstanceType::M3LargeSearch => "m3.large.search",
            OpenSearchPartitionInstanceType::M3MediumSearch => "m3.medium.search",
            OpenSearchPartitionInstanceType::M3XlargeSearch => "m3.xlarge.search",
            OpenSearchPartitionInstanceType::M410xlargeSearch => "m4.10xlarge.search",
            OpenSearchPartitionInstanceType::M42xlargeSearch => "m4.2xlarge.search",
            OpenSearchPartitionInstanceType::M44xlargeSearch => "m4.4xlarge.search",
            OpenSearchPartitionInstanceType::M4LargeSearch => "m4.large.search",
            OpenSearchPartitionInstanceType::M4XlargeSearch => "m4.xlarge.search",
            OpenSearchPartitionInstanceType::M512xlargeSearch => "m5.12xlarge.search",
            OpenSearchPartitionInstanceType::M524xlargeSearch => "m5.24xlarge.search",
            OpenSearchPartitionInstanceType::M52xlargeSearch => "m5.2xlarge.search",
            OpenSearchPartitionInstanceType::M54xlargeSearch => "m5.4xlarge.search",
            OpenSearchPartitionInstanceType::M5LargeSearch => "m5.large.search",
            OpenSearchPartitionInstanceType::M5XlargeSearch => "m5.xlarge.search",
            OpenSearchPartitionInstanceType::M6g12xlargeSearch => "m6g.12xlarge.search",
            OpenSearchPartitionInstanceType::M6g2xlargeSearch => "m6g.2xlarge.search",
            OpenSearchPartitionInstanceType::M6g4xlargeSearch => "m6g.4xlarge.search",
            OpenSearchPartitionInstanceType::M6g8xlargeSearch => "m6g.8xlarge.search",
            OpenSearchPartitionInstanceType::M6gLargeSearch => "m6g.large.search",
            OpenSearchPartitionInstanceType::M6gXlargeSearch => "m6g.xlarge.search",
            OpenSearchPartitionInstanceType::R32xlargeSearch => "r3.2xlarge.search",
            OpenSearchPartitionInstanceType::R34xlargeSearch => "r3.4xlarge.search",
            OpenSearchPartitionInstanceType::R38xlargeSearch => "r3.8xlarge.search",
            OpenSearchPartitionInstanceType::R3LargeSearch => "r3.large.search",
            OpenSearchPartitionInstanceType::R3XlargeSearch => "r3.xlarge.search",
            OpenSearchPartitionInstanceType::R416xlargeSearch => "r4.16xlarge.search",
            OpenSearchPartitionInstanceType::R42xlargeSearch => "r4.2xlarge.search",
            OpenSearchPartitionInstanceType::R44xlargeSearch => "r4.4xlarge.search",
            OpenSearchPartitionInstanceType::R48xlargeSearch => "r4.8xlarge.search",
            OpenSearchPartitionInstanceType::R4LargeSearch => "r4.large.search",
            OpenSearchPartitionInstanceType::R4XlargeSearch => "r4.xlarge.search",
            OpenSearchPartitionInstanceType::R512xlargeSearch => "r5.12xlarge.search",
            OpenSearchPartitionInstanceType::R524xlargeSearch => "r5.24xlarge.search",
            OpenSearchPartitionInstanceType::R52xlargeSearch => "r5.2xlarge.search",
            OpenSearchPartitionInstanceType::R54xlargeSearch => "r5.4xlarge.search",
            OpenSearchPartitionInstanceType::R5LargeSearch => "r5.large.search",
            OpenSearchPartitionInstanceType::R5XlargeSearch => "r5.xlarge.search",
            OpenSearchPartitionInstanceType::R6g12xlargeSearch => "r6g.12xlarge.search",
            OpenSearchPartitionInstanceType::R6g2xlargeSearch => "r6g.2xlarge.search",
            OpenSearchPartitionInstanceType::R6g4xlargeSearch => "r6g.4xlarge.search",
            OpenSearchPartitionInstanceType::R6g8xlargeSearch => "r6g.8xlarge.search",
            OpenSearchPartitionInstanceType::R6gLargeSearch => "r6g.large.search",
            OpenSearchPartitionInstanceType::R6gXlargeSearch => "r6g.xlarge.search",
            OpenSearchPartitionInstanceType::R6gd12xlargeSearch => "r6gd.12xlarge.search",
            OpenSearchPartitionInstanceType::R6gd16xlargeSearch => "r6gd.16xlarge.search",
            OpenSearchPartitionInstanceType::R6gd2xlargeSearch => "r6gd.2xlarge.search",
            OpenSearchPartitionInstanceType::R6gd4xlargeSearch => "r6gd.4xlarge.search",
            OpenSearchPartitionInstanceType::R6gd8xlargeSearch => "r6gd.8xlarge.search",
            OpenSearchPartitionInstanceType::R6gdLargeSearch => "r6gd.large.search",
            OpenSearchPartitionInstanceType::R6gdXlargeSearch => "r6gd.xlarge.search",
            OpenSearchPartitionInstanceType::T2MediumSearch => "t2.medium.search",
            OpenSearchPartitionInstanceType::T2MicroSearch => "t2.micro.search",
            OpenSearchPartitionInstanceType::T2SmallSearch => "t2.small.search",
            OpenSearchPartitionInstanceType::T32xlargeSearch => "t3.2xlarge.search",
            OpenSearchPartitionInstanceType::T3LargeSearch => "t3.large.search",
            OpenSearchPartitionInstanceType::T3MediumSearch => "t3.medium.search",
            OpenSearchPartitionInstanceType::T3MicroSearch => "t3.micro.search",
            OpenSearchPartitionInstanceType::T3NanoSearch => "t3.nano.search",
            OpenSearchPartitionInstanceType::T3SmallSearch => "t3.small.search",
            OpenSearchPartitionInstanceType::T3XlargeSearch => "t3.xlarge.search",
            OpenSearchPartitionInstanceType::T4gMediumSearch => "t4g.medium.search",
            OpenSearchPartitionInstanceType::T4gSmallSearch => "t4g.small.search",
            OpenSearchPartitionInstanceType::Ultrawarm1LargeSearch => "ultrawarm1.large.search",
            OpenSearchPartitionInstanceType::Ultrawarm1MediumSearch => "ultrawarm1.medium.search",
            OpenSearchPartitionInstanceType::Ultrawarm1XlargeSearch => "ultrawarm1.xlarge.search",
            OpenSearchPartitionInstanceType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "c4.2xlarge.search",
            "c4.4xlarge.search",
            "c4.8xlarge.search",
            "c4.large.search",
            "c4.xlarge.search",
            "c5.18xlarge.search",
            "c5.2xlarge.search",
            "c5.4xlarge.search",
            "c5.9xlarge.search",
            "c5.large.search",
            "c5.xlarge.search",
            "c6g.12xlarge.search",
            "c6g.2xlarge.search",
            "c6g.4xlarge.search",
            "c6g.8xlarge.search",
            "c6g.large.search",
            "c6g.xlarge.search",
            "d2.2xlarge.search",
            "d2.4xlarge.search",
            "d2.8xlarge.search",
            "d2.xlarge.search",
            "i2.2xlarge.search",
            "i2.xlarge.search",
            "i3.16xlarge.search",
            "i3.2xlarge.search",
            "i3.4xlarge.search",
            "i3.8xlarge.search",
            "i3.large.search",
            "i3.xlarge.search",
            "m3.2xlarge.search",
            "m3.large.search",
            "m3.medium.search",
            "m3.xlarge.search",
            "m4.10xlarge.search",
            "m4.2xlarge.search",
            "m4.4xlarge.search",
            "m4.large.search",
            "m4.xlarge.search",
            "m5.12xlarge.search",
            "m5.24xlarge.search",
            "m5.2xlarge.search",
            "m5.4xlarge.search",
            "m5.large.search",
            "m5.xlarge.search",
            "m6g.12xlarge.search",
            "m6g.2xlarge.search",
            "m6g.4xlarge.search",
            "m6g.8xlarge.search",
            "m6g.large.search",
            "m6g.xlarge.search",
            "r3.2xlarge.search",
            "r3.4xlarge.search",
            "r3.8xlarge.search",
            "r3.large.search",
            "r3.xlarge.search",
            "r4.16xlarge.search",
            "r4.2xlarge.search",
            "r4.4xlarge.search",
            "r4.8xlarge.search",
            "r4.large.search",
            "r4.xlarge.search",
            "r5.12xlarge.search",
            "r5.24xlarge.search",
            "r5.2xlarge.search",
            "r5.4xlarge.search",
            "r5.large.search",
            "r5.xlarge.search",
            "r6g.12xlarge.search",
            "r6g.2xlarge.search",
            "r6g.4xlarge.search",
            "r6g.8xlarge.search",
            "r6g.large.search",
            "r6g.xlarge.search",
            "r6gd.12xlarge.search",
            "r6gd.16xlarge.search",
            "r6gd.2xlarge.search",
            "r6gd.4xlarge.search",
            "r6gd.8xlarge.search",
            "r6gd.large.search",
            "r6gd.xlarge.search",
            "t2.medium.search",
            "t2.micro.search",
            "t2.small.search",
            "t3.2xlarge.search",
            "t3.large.search",
            "t3.medium.search",
            "t3.micro.search",
            "t3.nano.search",
            "t3.small.search",
            "t3.xlarge.search",
            "t4g.medium.search",
            "t4g.small.search",
            "ultrawarm1.large.search",
            "ultrawarm1.medium.search",
            "ultrawarm1.xlarge.search",
        ]
    }
}
impl AsRef<str> for OpenSearchPartitionInstanceType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The zone awareness configuration for an Amazon OpenSearch Service domain.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ZoneAwarenessConfig {
    /// <p>If you enabled multiple Availability Zones, this value is the number of zones that you want the domain to use. Valid values are <code>2</code> and <code>3</code>. If your domain is provisioned within a VPC, this value be equal to number of subnets.</p>
    #[doc(hidden)]
    pub availability_zone_count: std::option::Option<i32>,
}
impl ZoneAwarenessConfig {
    /// <p>If you enabled multiple Availability Zones, this value is the number of zones that you want the domain to use. Valid values are <code>2</code> and <code>3</code>. If your domain is provisioned within a VPC, this value be equal to number of subnets.</p>
    pub fn availability_zone_count(&self) -> std::option::Option<i32> {
        self.availability_zone_count
    }
}
/// See [`ZoneAwarenessConfig`](crate::model::ZoneAwarenessConfig).
pub mod zone_awareness_config {

    /// A builder for [`ZoneAwarenessConfig`](crate::model::ZoneAwarenessConfig).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) availability_zone_count: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>If you enabled multiple Availability Zones, this value is the number of zones that you want the domain to use. Valid values are <code>2</code> and <code>3</code>. If your domain is provisioned within a VPC, this value be equal to number of subnets.</p>
        pub fn availability_zone_count(mut self, input: i32) -> Self {
            self.availability_zone_count = Some(input);
            self
        }
        /// <p>If you enabled multiple Availability Zones, this value is the number of zones that you want the domain to use. Valid values are <code>2</code> and <code>3</code>. If your domain is provisioned within a VPC, this value be equal to number of subnets.</p>
        pub fn set_availability_zone_count(mut self, input: std::option::Option<i32>) -> Self {
            self.availability_zone_count = input;
            self
        }
        /// Consumes the builder and constructs a [`ZoneAwarenessConfig`](crate::model::ZoneAwarenessConfig).
        pub fn build(self) -> crate::model::ZoneAwarenessConfig {
            crate::model::ZoneAwarenessConfig {
                availability_zone_count: self.availability_zone_count,
            }
        }
    }
}
impl ZoneAwarenessConfig {
    /// Creates a new builder-style object to manufacture [`ZoneAwarenessConfig`](crate::model::ZoneAwarenessConfig).
    pub fn builder() -> crate::model::zone_awareness_config::Builder {
        crate::model::zone_awareness_config::Builder::default()
    }
}

/// <p>The status of the the OpenSearch or Elasticsearch version options for the specified Amazon OpenSearch Service domain.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct VersionStatus {
    /// <p>The OpenSearch or Elasticsearch version for the specified domain.</p>
    #[doc(hidden)]
    pub options: std::option::Option<std::string::String>,
    /// <p>The status of the version options for the specified domain.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::OptionStatus>,
}
impl VersionStatus {
    /// <p>The OpenSearch or Elasticsearch version for the specified domain.</p>
    pub fn options(&self) -> std::option::Option<&str> {
        self.options.as_deref()
    }
    /// <p>The status of the version options for the specified domain.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::OptionStatus> {
        self.status.as_ref()
    }
}
/// See [`VersionStatus`](crate::model::VersionStatus).
pub mod version_status {

    /// A builder for [`VersionStatus`](crate::model::VersionStatus).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) options: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::OptionStatus>,
    }
    impl Builder {
        /// <p>The OpenSearch or Elasticsearch version for the specified domain.</p>
        pub fn options(mut self, input: impl Into<std::string::String>) -> Self {
            self.options = Some(input.into());
            self
        }
        /// <p>The OpenSearch or Elasticsearch version for the specified domain.</p>
        pub fn set_options(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.options = input;
            self
        }
        /// <p>The status of the version options for the specified domain.</p>
        pub fn status(mut self, input: crate::model::OptionStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the version options for the specified domain.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::OptionStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// Consumes the builder and constructs a [`VersionStatus`](crate::model::VersionStatus).
        pub fn build(self) -> crate::model::VersionStatus {
            crate::model::VersionStatus {
                options: self.options,
                status: self.status,
            }
        }
    }
}
impl VersionStatus {
    /// Creates a new builder-style object to manufacture [`VersionStatus`](crate::model::VersionStatus).
    pub fn builder() -> crate::model::version_status::Builder {
        crate::model::version_status::Builder::default()
    }
}

/// When writing a match expression against `DryRunMode`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let dryrunmode = unimplemented!();
/// match dryrunmode {
///     DryRunMode::Basic => { /* ... */ },
///     DryRunMode::Verbose => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `dryrunmode` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `DryRunMode::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `DryRunMode::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `DryRunMode::NewFeature` is defined.
/// Specifically, when `dryrunmode` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `DryRunMode::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DryRunMode {
    #[allow(missing_docs)] // documentation missing in model
    Basic,
    #[allow(missing_docs)] // documentation missing in model
    Verbose,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for DryRunMode {
    fn from(s: &str) -> Self {
        match s {
            "Basic" => DryRunMode::Basic,
            "Verbose" => DryRunMode::Verbose,
            other => DryRunMode::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for DryRunMode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DryRunMode::from(s))
    }
}
impl DryRunMode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            DryRunMode::Basic => "Basic",
            DryRunMode::Verbose => "Verbose",
            DryRunMode::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["Basic", "Verbose"]
    }
}
impl AsRef<str> for DryRunMode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Options for enabling and configuring fine-grained access control. For more information, see <a href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/fgac.html">Fine-grained access control in Amazon OpenSearch Service</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AdvancedSecurityOptionsInput {
    /// <p>True to enable fine-grained access control.</p>
    #[doc(hidden)]
    pub enabled: std::option::Option<bool>,
    /// <p>True to enable the internal user database.</p>
    #[doc(hidden)]
    pub internal_user_database_enabled: std::option::Option<bool>,
    /// <p>Container for information about the master user.</p>
    #[doc(hidden)]
    pub master_user_options: std::option::Option<crate::model::MasterUserOptions>,
    /// <p>Container for information about the SAML configuration for OpenSearch Dashboards.</p>
    #[doc(hidden)]
    pub saml_options: std::option::Option<crate::model::SamlOptionsInput>,
    /// <p>True to enable a 30-day migration period during which administrators can create role mappings. Only necessary when <a href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/fgac.html#fgac-enabling-existing">enabling fine-grained access control on an existing domain</a>.</p>
    #[doc(hidden)]
    pub anonymous_auth_enabled: std::option::Option<bool>,
}
impl AdvancedSecurityOptionsInput {
    /// <p>True to enable fine-grained access control.</p>
    pub fn enabled(&self) -> std::option::Option<bool> {
        self.enabled
    }
    /// <p>True to enable the internal user database.</p>
    pub fn internal_user_database_enabled(&self) -> std::option::Option<bool> {
        self.internal_user_database_enabled
    }
    /// <p>Container for information about the master user.</p>
    pub fn master_user_options(&self) -> std::option::Option<&crate::model::MasterUserOptions> {
        self.master_user_options.as_ref()
    }
    /// <p>Container for information about the SAML configuration for OpenSearch Dashboards.</p>
    pub fn saml_options(&self) -> std::option::Option<&crate::model::SamlOptionsInput> {
        self.saml_options.as_ref()
    }
    /// <p>True to enable a 30-day migration period during which administrators can create role mappings. Only necessary when <a href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/fgac.html#fgac-enabling-existing">enabling fine-grained access control on an existing domain</a>.</p>
    pub fn anonymous_auth_enabled(&self) -> std::option::Option<bool> {
        self.anonymous_auth_enabled
    }
}
/// See [`AdvancedSecurityOptionsInput`](crate::model::AdvancedSecurityOptionsInput).
pub mod advanced_security_options_input {

    /// A builder for [`AdvancedSecurityOptionsInput`](crate::model::AdvancedSecurityOptionsInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) enabled: std::option::Option<bool>,
        pub(crate) internal_user_database_enabled: std::option::Option<bool>,
        pub(crate) master_user_options: std::option::Option<crate::model::MasterUserOptions>,
        pub(crate) saml_options: std::option::Option<crate::model::SamlOptionsInput>,
        pub(crate) anonymous_auth_enabled: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>True to enable fine-grained access control.</p>
        pub fn enabled(mut self, input: bool) -> Self {
            self.enabled = Some(input);
            self
        }
        /// <p>True to enable fine-grained access control.</p>
        pub fn set_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.enabled = input;
            self
        }
        /// <p>True to enable the internal user database.</p>
        pub fn internal_user_database_enabled(mut self, input: bool) -> Self {
            self.internal_user_database_enabled = Some(input);
            self
        }
        /// <p>True to enable the internal user database.</p>
        pub fn set_internal_user_database_enabled(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.internal_user_database_enabled = input;
            self
        }
        /// <p>Container for information about the master user.</p>
        pub fn master_user_options(mut self, input: crate::model::MasterUserOptions) -> Self {
            self.master_user_options = Some(input);
            self
        }
        /// <p>Container for information about the master user.</p>
        pub fn set_master_user_options(
            mut self,
            input: std::option::Option<crate::model::MasterUserOptions>,
        ) -> Self {
            self.master_user_options = input;
            self
        }
        /// <p>Container for information about the SAML configuration for OpenSearch Dashboards.</p>
        pub fn saml_options(mut self, input: crate::model::SamlOptionsInput) -> Self {
            self.saml_options = Some(input);
            self
        }
        /// <p>Container for information about the SAML configuration for OpenSearch Dashboards.</p>
        pub fn set_saml_options(
            mut self,
            input: std::option::Option<crate::model::SamlOptionsInput>,
        ) -> Self {
            self.saml_options = input;
            self
        }
        /// <p>True to enable a 30-day migration period during which administrators can create role mappings. Only necessary when <a href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/fgac.html#fgac-enabling-existing">enabling fine-grained access control on an existing domain</a>.</p>
        pub fn anonymous_auth_enabled(mut self, input: bool) -> Self {
            self.anonymous_auth_enabled = Some(input);
            self
        }
        /// <p>True to enable a 30-day migration period during which administrators can create role mappings. Only necessary when <a href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/fgac.html#fgac-enabling-existing">enabling fine-grained access control on an existing domain</a>.</p>
        pub fn set_anonymous_auth_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.anonymous_auth_enabled = input;
            self
        }
        /// Consumes the builder and constructs a [`AdvancedSecurityOptionsInput`](crate::model::AdvancedSecurityOptionsInput).
        pub fn build(self) -> crate::model::AdvancedSecurityOptionsInput {
            crate::model::AdvancedSecurityOptionsInput {
                enabled: self.enabled,
                internal_user_database_enabled: self.internal_user_database_enabled,
                master_user_options: self.master_user_options,
                saml_options: self.saml_options,
                anonymous_auth_enabled: self.anonymous_auth_enabled,
            }
        }
    }
}
impl AdvancedSecurityOptionsInput {
    /// Creates a new builder-style object to manufacture [`AdvancedSecurityOptionsInput`](crate::model::AdvancedSecurityOptionsInput).
    pub fn builder() -> crate::model::advanced_security_options_input::Builder {
        crate::model::advanced_security_options_input::Builder::default()
    }
}

/// <p>The SAML authentication configuration for an Amazon OpenSearch Service domain.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SamlOptionsInput {
    /// <p>True to enable SAML authentication for a domain.</p>
    #[doc(hidden)]
    pub enabled: std::option::Option<bool>,
    /// <p>The SAML Identity Provider's information.</p>
    #[doc(hidden)]
    pub idp: std::option::Option<crate::model::SamlIdp>,
    /// <p>The SAML master user name, which is stored in the domain's internal user database.</p>
    #[doc(hidden)]
    pub master_user_name: std::option::Option<std::string::String>,
    /// <p>The backend role that the SAML master user is mapped to.</p>
    #[doc(hidden)]
    pub master_backend_role: std::option::Option<std::string::String>,
    /// <p>Element of the SAML assertion to use for the user name. Default is <code>NameID</code>.</p>
    #[doc(hidden)]
    pub subject_key: std::option::Option<std::string::String>,
    /// <p>Element of the SAML assertion to use for backend roles. Default is <code>roles</code>.</p>
    #[doc(hidden)]
    pub roles_key: std::option::Option<std::string::String>,
    /// <p>The duration, in minutes, after which a user session becomes inactive. Acceptable values are between 1 and 1440, and the default value is 60.</p>
    #[doc(hidden)]
    pub session_timeout_minutes: std::option::Option<i32>,
}
impl SamlOptionsInput {
    /// <p>True to enable SAML authentication for a domain.</p>
    pub fn enabled(&self) -> std::option::Option<bool> {
        self.enabled
    }
    /// <p>The SAML Identity Provider's information.</p>
    pub fn idp(&self) -> std::option::Option<&crate::model::SamlIdp> {
        self.idp.as_ref()
    }
    /// <p>The SAML master user name, which is stored in the domain's internal user database.</p>
    pub fn master_user_name(&self) -> std::option::Option<&str> {
        self.master_user_name.as_deref()
    }
    /// <p>The backend role that the SAML master user is mapped to.</p>
    pub fn master_backend_role(&self) -> std::option::Option<&str> {
        self.master_backend_role.as_deref()
    }
    /// <p>Element of the SAML assertion to use for the user name. Default is <code>NameID</code>.</p>
    pub fn subject_key(&self) -> std::option::Option<&str> {
        self.subject_key.as_deref()
    }
    /// <p>Element of the SAML assertion to use for backend roles. Default is <code>roles</code>.</p>
    pub fn roles_key(&self) -> std::option::Option<&str> {
        self.roles_key.as_deref()
    }
    /// <p>The duration, in minutes, after which a user session becomes inactive. Acceptable values are between 1 and 1440, and the default value is 60.</p>
    pub fn session_timeout_minutes(&self) -> std::option::Option<i32> {
        self.session_timeout_minutes
    }
}
impl std::fmt::Debug for SamlOptionsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SamlOptionsInput");
        formatter.field("enabled", &self.enabled);
        formatter.field("idp", &self.idp);
        formatter.field("master_user_name", &"*** Sensitive Data Redacted ***");
        formatter.field("master_backend_role", &self.master_backend_role);
        formatter.field("subject_key", &self.subject_key);
        formatter.field("roles_key", &self.roles_key);
        formatter.field("session_timeout_minutes", &self.session_timeout_minutes);
        formatter.finish()
    }
}
/// See [`SamlOptionsInput`](crate::model::SamlOptionsInput).
pub mod saml_options_input {

    /// A builder for [`SamlOptionsInput`](crate::model::SamlOptionsInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) enabled: std::option::Option<bool>,
        pub(crate) idp: std::option::Option<crate::model::SamlIdp>,
        pub(crate) master_user_name: std::option::Option<std::string::String>,
        pub(crate) master_backend_role: std::option::Option<std::string::String>,
        pub(crate) subject_key: std::option::Option<std::string::String>,
        pub(crate) roles_key: std::option::Option<std::string::String>,
        pub(crate) session_timeout_minutes: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>True to enable SAML authentication for a domain.</p>
        pub fn enabled(mut self, input: bool) -> Self {
            self.enabled = Some(input);
            self
        }
        /// <p>True to enable SAML authentication for a domain.</p>
        pub fn set_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.enabled = input;
            self
        }
        /// <p>The SAML Identity Provider's information.</p>
        pub fn idp(mut self, input: crate::model::SamlIdp) -> Self {
            self.idp = Some(input);
            self
        }
        /// <p>The SAML Identity Provider's information.</p>
        pub fn set_idp(mut self, input: std::option::Option<crate::model::SamlIdp>) -> Self {
            self.idp = input;
            self
        }
        /// <p>The SAML master user name, which is stored in the domain's internal user database.</p>
        pub fn master_user_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.master_user_name = Some(input.into());
            self
        }
        /// <p>The SAML master user name, which is stored in the domain's internal user database.</p>
        pub fn set_master_user_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.master_user_name = input;
            self
        }
        /// <p>The backend role that the SAML master user is mapped to.</p>
        pub fn master_backend_role(mut self, input: impl Into<std::string::String>) -> Self {
            self.master_backend_role = Some(input.into());
            self
        }
        /// <p>The backend role that the SAML master user is mapped to.</p>
        pub fn set_master_backend_role(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.master_backend_role = input;
            self
        }
        /// <p>Element of the SAML assertion to use for the user name. Default is <code>NameID</code>.</p>
        pub fn subject_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.subject_key = Some(input.into());
            self
        }
        /// <p>Element of the SAML assertion to use for the user name. Default is <code>NameID</code>.</p>
        pub fn set_subject_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.subject_key = input;
            self
        }
        /// <p>Element of the SAML assertion to use for backend roles. Default is <code>roles</code>.</p>
        pub fn roles_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.roles_key = Some(input.into());
            self
        }
        /// <p>Element of the SAML assertion to use for backend roles. Default is <code>roles</code>.</p>
        pub fn set_roles_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.roles_key = input;
            self
        }
        /// <p>The duration, in minutes, after which a user session becomes inactive. Acceptable values are between 1 and 1440, and the default value is 60.</p>
        pub fn session_timeout_minutes(mut self, input: i32) -> Self {
            self.session_timeout_minutes = Some(input);
            self
        }
        /// <p>The duration, in minutes, after which a user session becomes inactive. Acceptable values are between 1 and 1440, and the default value is 60.</p>
        pub fn set_session_timeout_minutes(mut self, input: std::option::Option<i32>) -> Self {
            self.session_timeout_minutes = input;
            self
        }
        /// Consumes the builder and constructs a [`SamlOptionsInput`](crate::model::SamlOptionsInput).
        pub fn build(self) -> crate::model::SamlOptionsInput {
            crate::model::SamlOptionsInput {
                enabled: self.enabled,
                idp: self.idp,
                master_user_name: self.master_user_name,
                master_backend_role: self.master_backend_role,
                subject_key: self.subject_key,
                roles_key: self.roles_key,
                session_timeout_minutes: self.session_timeout_minutes,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("enabled", &self.enabled);
            formatter.field("idp", &self.idp);
            formatter.field("master_user_name", &"*** Sensitive Data Redacted ***");
            formatter.field("master_backend_role", &self.master_backend_role);
            formatter.field("subject_key", &self.subject_key);
            formatter.field("roles_key", &self.roles_key);
            formatter.field("session_timeout_minutes", &self.session_timeout_minutes);
            formatter.finish()
        }
    }
}
impl SamlOptionsInput {
    /// Creates a new builder-style object to manufacture [`SamlOptionsInput`](crate::model::SamlOptionsInput).
    pub fn builder() -> crate::model::saml_options_input::Builder {
        crate::model::saml_options_input::Builder::default()
    }
}

/// <p>Credentials for the master user for a domain.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MasterUserOptions {
    /// <p>Amazon Resource Name (ARN) for the master user. Only specify if <code>InternalUserDatabaseEnabled</code> is <code>false</code>.</p>
    #[doc(hidden)]
    pub master_user_arn: std::option::Option<std::string::String>,
    /// <p>User name for the master user. Only specify if <code>InternalUserDatabaseEnabled</code> is <code>true</code>.</p>
    #[doc(hidden)]
    pub master_user_name: std::option::Option<std::string::String>,
    /// <p>Password for the master user. Only specify if <code>InternalUserDatabaseEnabled</code> is <code>true</code>.</p>
    #[doc(hidden)]
    pub master_user_password: std::option::Option<std::string::String>,
}
impl MasterUserOptions {
    /// <p>Amazon Resource Name (ARN) for the master user. Only specify if <code>InternalUserDatabaseEnabled</code> is <code>false</code>.</p>
    pub fn master_user_arn(&self) -> std::option::Option<&str> {
        self.master_user_arn.as_deref()
    }
    /// <p>User name for the master user. Only specify if <code>InternalUserDatabaseEnabled</code> is <code>true</code>.</p>
    pub fn master_user_name(&self) -> std::option::Option<&str> {
        self.master_user_name.as_deref()
    }
    /// <p>Password for the master user. Only specify if <code>InternalUserDatabaseEnabled</code> is <code>true</code>.</p>
    pub fn master_user_password(&self) -> std::option::Option<&str> {
        self.master_user_password.as_deref()
    }
}
impl std::fmt::Debug for MasterUserOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MasterUserOptions");
        formatter.field("master_user_arn", &self.master_user_arn);
        formatter.field("master_user_name", &"*** Sensitive Data Redacted ***");
        formatter.field("master_user_password", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
/// See [`MasterUserOptions`](crate::model::MasterUserOptions).
pub mod master_user_options {

    /// A builder for [`MasterUserOptions`](crate::model::MasterUserOptions).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) master_user_arn: std::option::Option<std::string::String>,
        pub(crate) master_user_name: std::option::Option<std::string::String>,
        pub(crate) master_user_password: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Amazon Resource Name (ARN) for the master user. Only specify if <code>InternalUserDatabaseEnabled</code> is <code>false</code>.</p>
        pub fn master_user_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.master_user_arn = Some(input.into());
            self
        }
        /// <p>Amazon Resource Name (ARN) for the master user. Only specify if <code>InternalUserDatabaseEnabled</code> is <code>false</code>.</p>
        pub fn set_master_user_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.master_user_arn = input;
            self
        }
        /// <p>User name for the master user. Only specify if <code>InternalUserDatabaseEnabled</code> is <code>true</code>.</p>
        pub fn master_user_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.master_user_name = Some(input.into());
            self
        }
        /// <p>User name for the master user. Only specify if <code>InternalUserDatabaseEnabled</code> is <code>true</code>.</p>
        pub fn set_master_user_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.master_user_name = input;
            self
        }
        /// <p>Password for the master user. Only specify if <code>InternalUserDatabaseEnabled</code> is <code>true</code>.</p>
        pub fn master_user_password(mut self, input: impl Into<std::string::String>) -> Self {
            self.master_user_password = Some(input.into());
            self
        }
        /// <p>Password for the master user. Only specify if <code>InternalUserDatabaseEnabled</code> is <code>true</code>.</p>
        pub fn set_master_user_password(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.master_user_password = input;
            self
        }
        /// Consumes the builder and constructs a [`MasterUserOptions`](crate::model::MasterUserOptions).
        pub fn build(self) -> crate::model::MasterUserOptions {
            crate::model::MasterUserOptions {
                master_user_arn: self.master_user_arn,
                master_user_name: self.master_user_name,
                master_user_password: self.master_user_password,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("master_user_arn", &self.master_user_arn);
            formatter.field("master_user_name", &"*** Sensitive Data Redacted ***");
            formatter.field("master_user_password", &"*** Sensitive Data Redacted ***");
            formatter.finish()
        }
    }
}
impl MasterUserOptions {
    /// Creates a new builder-style object to manufacture [`MasterUserOptions`](crate::model::MasterUserOptions).
    pub fn builder() -> crate::model::master_user_options::Builder {
        crate::model::master_user_options::Builder::default()
    }
}

/// <p>The current status of the service software for an Amazon OpenSearch Service domain. For more information, see <a href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/service-software.html">Service software updates in Amazon OpenSearch Service</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ServiceSoftwareOptions {
    /// <p>The current service software version present on the domain.</p>
    #[doc(hidden)]
    pub current_version: std::option::Option<std::string::String>,
    /// <p>The new service software version, if one is available.</p>
    #[doc(hidden)]
    pub new_version: std::option::Option<std::string::String>,
    /// <p>True if you're able to update your service software version. False if you can't update your service software version.</p>
    #[doc(hidden)]
    pub update_available: std::option::Option<bool>,
    /// <p> True if you're able to cancel your service software version update. False if you can't cancel your service software update.</p>
    #[doc(hidden)]
    pub cancellable: std::option::Option<bool>,
    /// <p>The status of your service software update.</p>
    #[doc(hidden)]
    pub update_status: std::option::Option<crate::model::DeploymentStatus>,
    /// <p>A description of the service software update status.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The timestamp, in Epoch time, until which you can manually request a service software update. After this date, we automatically update your service software.</p>
    #[doc(hidden)]
    pub automated_update_date: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>True if a service software is never automatically updated. False if a service software is automatically updated after the automated update date.</p>
    #[doc(hidden)]
    pub optional_deployment: std::option::Option<bool>,
}
impl ServiceSoftwareOptions {
    /// <p>The current service software version present on the domain.</p>
    pub fn current_version(&self) -> std::option::Option<&str> {
        self.current_version.as_deref()
    }
    /// <p>The new service software version, if one is available.</p>
    pub fn new_version(&self) -> std::option::Option<&str> {
        self.new_version.as_deref()
    }
    /// <p>True if you're able to update your service software version. False if you can't update your service software version.</p>
    pub fn update_available(&self) -> std::option::Option<bool> {
        self.update_available
    }
    /// <p> True if you're able to cancel your service software version update. False if you can't cancel your service software update.</p>
    pub fn cancellable(&self) -> std::option::Option<bool> {
        self.cancellable
    }
    /// <p>The status of your service software update.</p>
    pub fn update_status(&self) -> std::option::Option<&crate::model::DeploymentStatus> {
        self.update_status.as_ref()
    }
    /// <p>A description of the service software update status.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The timestamp, in Epoch time, until which you can manually request a service software update. After this date, we automatically update your service software.</p>
    pub fn automated_update_date(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.automated_update_date.as_ref()
    }
    /// <p>True if a service software is never automatically updated. False if a service software is automatically updated after the automated update date.</p>
    pub fn optional_deployment(&self) -> std::option::Option<bool> {
        self.optional_deployment
    }
}
/// See [`ServiceSoftwareOptions`](crate::model::ServiceSoftwareOptions).
pub mod service_software_options {

    /// A builder for [`ServiceSoftwareOptions`](crate::model::ServiceSoftwareOptions).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) current_version: std::option::Option<std::string::String>,
        pub(crate) new_version: std::option::Option<std::string::String>,
        pub(crate) update_available: std::option::Option<bool>,
        pub(crate) cancellable: std::option::Option<bool>,
        pub(crate) update_status: std::option::Option<crate::model::DeploymentStatus>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) automated_update_date: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) optional_deployment: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The current service software version present on the domain.</p>
        pub fn current_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.current_version = Some(input.into());
            self
        }
        /// <p>The current service software version present on the domain.</p>
        pub fn set_current_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.current_version = input;
            self
        }
        /// <p>The new service software version, if one is available.</p>
        pub fn new_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.new_version = Some(input.into());
            self
        }
        /// <p>The new service software version, if one is available.</p>
        pub fn set_new_version(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.new_version = input;
            self
        }
        /// <p>True if you're able to update your service software version. False if you can't update your service software version.</p>
        pub fn update_available(mut self, input: bool) -> Self {
            self.update_available = Some(input);
            self
        }
        /// <p>True if you're able to update your service software version. False if you can't update your service software version.</p>
        pub fn set_update_available(mut self, input: std::option::Option<bool>) -> Self {
            self.update_available = input;
            self
        }
        /// <p> True if you're able to cancel your service software version update. False if you can't cancel your service software update.</p>
        pub fn cancellable(mut self, input: bool) -> Self {
            self.cancellable = Some(input);
            self
        }
        /// <p> True if you're able to cancel your service software version update. False if you can't cancel your service software update.</p>
        pub fn set_cancellable(mut self, input: std::option::Option<bool>) -> Self {
            self.cancellable = input;
            self
        }
        /// <p>The status of your service software update.</p>
        pub fn update_status(mut self, input: crate::model::DeploymentStatus) -> Self {
            self.update_status = Some(input);
            self
        }
        /// <p>The status of your service software update.</p>
        pub fn set_update_status(
            mut self,
            input: std::option::Option<crate::model::DeploymentStatus>,
        ) -> Self {
            self.update_status = input;
            self
        }
        /// <p>A description of the service software update status.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A description of the service software update status.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The timestamp, in Epoch time, until which you can manually request a service software update. After this date, we automatically update your service software.</p>
        pub fn automated_update_date(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.automated_update_date = Some(input);
            self
        }
        /// <p>The timestamp, in Epoch time, until which you can manually request a service software update. After this date, we automatically update your service software.</p>
        pub fn set_automated_update_date(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.automated_update_date = input;
            self
        }
        /// <p>True if a service software is never automatically updated. False if a service software is automatically updated after the automated update date.</p>
        pub fn optional_deployment(mut self, input: bool) -> Self {
            self.optional_deployment = Some(input);
            self
        }
        /// <p>True if a service software is never automatically updated. False if a service software is automatically updated after the automated update date.</p>
        pub fn set_optional_deployment(mut self, input: std::option::Option<bool>) -> Self {
            self.optional_deployment = input;
            self
        }
        /// Consumes the builder and constructs a [`ServiceSoftwareOptions`](crate::model::ServiceSoftwareOptions).
        pub fn build(self) -> crate::model::ServiceSoftwareOptions {
            crate::model::ServiceSoftwareOptions {
                current_version: self.current_version,
                new_version: self.new_version,
                update_available: self.update_available,
                cancellable: self.cancellable,
                update_status: self.update_status,
                description: self.description,
                automated_update_date: self.automated_update_date,
                optional_deployment: self.optional_deployment,
            }
        }
    }
}
impl ServiceSoftwareOptions {
    /// Creates a new builder-style object to manufacture [`ServiceSoftwareOptions`](crate::model::ServiceSoftwareOptions).
    pub fn builder() -> crate::model::service_software_options::Builder {
        crate::model::service_software_options::Builder::default()
    }
}

/// When writing a match expression against `DeploymentStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let deploymentstatus = unimplemented!();
/// match deploymentstatus {
///     DeploymentStatus::Completed => { /* ... */ },
///     DeploymentStatus::Eligible => { /* ... */ },
///     DeploymentStatus::InProgress => { /* ... */ },
///     DeploymentStatus::NotEligible => { /* ... */ },
///     DeploymentStatus::PendingUpdate => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `deploymentstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `DeploymentStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `DeploymentStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `DeploymentStatus::NewFeature` is defined.
/// Specifically, when `deploymentstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `DeploymentStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DeploymentStatus {
    #[allow(missing_docs)] // documentation missing in model
    Completed,
    #[allow(missing_docs)] // documentation missing in model
    Eligible,
    #[allow(missing_docs)] // documentation missing in model
    InProgress,
    #[allow(missing_docs)] // documentation missing in model
    NotEligible,
    #[allow(missing_docs)] // documentation missing in model
    PendingUpdate,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for DeploymentStatus {
    fn from(s: &str) -> Self {
        match s {
            "COMPLETED" => DeploymentStatus::Completed,
            "ELIGIBLE" => DeploymentStatus::Eligible,
            "IN_PROGRESS" => DeploymentStatus::InProgress,
            "NOT_ELIGIBLE" => DeploymentStatus::NotEligible,
            "PENDING_UPDATE" => DeploymentStatus::PendingUpdate,
            other => DeploymentStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for DeploymentStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DeploymentStatus::from(s))
    }
}
impl DeploymentStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            DeploymentStatus::Completed => "COMPLETED",
            DeploymentStatus::Eligible => "ELIGIBLE",
            DeploymentStatus::InProgress => "IN_PROGRESS",
            DeploymentStatus::NotEligible => "NOT_ELIGIBLE",
            DeploymentStatus::PendingUpdate => "PENDING_UPDATE",
            DeploymentStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "COMPLETED",
            "ELIGIBLE",
            "IN_PROGRESS",
            "NOT_ELIGIBLE",
            "PENDING_UPDATE",
        ]
    }
}
impl AsRef<str> for DeploymentStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes an inbound cross-cluster connection for Amazon OpenSearch Service. For more information, see <a href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/cross-cluster-search.html">Cross-cluster search for Amazon OpenSearch Service</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InboundConnection {
    /// <p>Information about the source (local) domain.</p>
    #[doc(hidden)]
    pub local_domain_info: std::option::Option<crate::model::DomainInformationContainer>,
    /// <p>Information about the destination (remote) domain.</p>
    #[doc(hidden)]
    pub remote_domain_info: std::option::Option<crate::model::DomainInformationContainer>,
    /// <p>The unique identifier of the connection.</p>
    #[doc(hidden)]
    pub connection_id: std::option::Option<std::string::String>,
    /// <p>The current status of the connection.</p>
    #[doc(hidden)]
    pub connection_status: std::option::Option<crate::model::InboundConnectionStatus>,
}
impl InboundConnection {
    /// <p>Information about the source (local) domain.</p>
    pub fn local_domain_info(
        &self,
    ) -> std::option::Option<&crate::model::DomainInformationContainer> {
        self.local_domain_info.as_ref()
    }
    /// <p>Information about the destination (remote) domain.</p>
    pub fn remote_domain_info(
        &self,
    ) -> std::option::Option<&crate::model::DomainInformationContainer> {
        self.remote_domain_info.as_ref()
    }
    /// <p>The unique identifier of the connection.</p>
    pub fn connection_id(&self) -> std::option::Option<&str> {
        self.connection_id.as_deref()
    }
    /// <p>The current status of the connection.</p>
    pub fn connection_status(&self) -> std::option::Option<&crate::model::InboundConnectionStatus> {
        self.connection_status.as_ref()
    }
}
/// See [`InboundConnection`](crate::model::InboundConnection).
pub mod inbound_connection {

    /// A builder for [`InboundConnection`](crate::model::InboundConnection).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) local_domain_info: std::option::Option<crate::model::DomainInformationContainer>,
        pub(crate) remote_domain_info:
            std::option::Option<crate::model::DomainInformationContainer>,
        pub(crate) connection_id: std::option::Option<std::string::String>,
        pub(crate) connection_status: std::option::Option<crate::model::InboundConnectionStatus>,
    }
    impl Builder {
        /// <p>Information about the source (local) domain.</p>
        pub fn local_domain_info(
            mut self,
            input: crate::model::DomainInformationContainer,
        ) -> Self {
            self.local_domain_info = Some(input);
            self
        }
        /// <p>Information about the source (local) domain.</p>
        pub fn set_local_domain_info(
            mut self,
            input: std::option::Option<crate::model::DomainInformationContainer>,
        ) -> Self {
            self.local_domain_info = input;
            self
        }
        /// <p>Information about the destination (remote) domain.</p>
        pub fn remote_domain_info(
            mut self,
            input: crate::model::DomainInformationContainer,
        ) -> Self {
            self.remote_domain_info = Some(input);
            self
        }
        /// <p>Information about the destination (remote) domain.</p>
        pub fn set_remote_domain_info(
            mut self,
            input: std::option::Option<crate::model::DomainInformationContainer>,
        ) -> Self {
            self.remote_domain_info = input;
            self
        }
        /// <p>The unique identifier of the connection.</p>
        pub fn connection_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.connection_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of the connection.</p>
        pub fn set_connection_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.connection_id = input;
            self
        }
        /// <p>The current status of the connection.</p>
        pub fn connection_status(mut self, input: crate::model::InboundConnectionStatus) -> Self {
            self.connection_status = Some(input);
            self
        }
        /// <p>The current status of the connection.</p>
        pub fn set_connection_status(
            mut self,
            input: std::option::Option<crate::model::InboundConnectionStatus>,
        ) -> Self {
            self.connection_status = input;
            self
        }
        /// Consumes the builder and constructs a [`InboundConnection`](crate::model::InboundConnection).
        pub fn build(self) -> crate::model::InboundConnection {
            crate::model::InboundConnection {
                local_domain_info: self.local_domain_info,
                remote_domain_info: self.remote_domain_info,
                connection_id: self.connection_id,
                connection_status: self.connection_status,
            }
        }
    }
}
impl InboundConnection {
    /// Creates a new builder-style object to manufacture [`InboundConnection`](crate::model::InboundConnection).
    pub fn builder() -> crate::model::inbound_connection::Builder {
        crate::model::inbound_connection::Builder::default()
    }
}

/// <p>The status of an inbound cross-cluster connection for OpenSearch Service.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InboundConnectionStatus {
    /// <p>The status code for the connection. Can be one of the following:</p>
    /// <ul>
    /// <li> <p> <b>PENDING_ACCEPTANCE</b> - Inbound connection is not yet accepted by the remote domain owner.</p> </li>
    /// <li> <p> <b>APPROVED</b>: Inbound connection is pending acceptance by the remote domain owner.</p> </li>
    /// <li> <p> <b>PROVISIONING</b>: Inbound connection is being provisioned.</p> </li>
    /// <li> <p> <b>ACTIVE</b>: Inbound connection is active and ready to use.</p> </li>
    /// <li> <p> <b>REJECTING</b>: Inbound connection rejection is in process.</p> </li>
    /// <li> <p> <b>REJECTED</b>: Inbound connection is rejected.</p> </li>
    /// <li> <p> <b>DELETING</b>: Inbound connection deletion is in progress.</p> </li>
    /// <li> <p> <b>DELETED</b>: Inbound connection is deleted and can no longer be used.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub status_code: std::option::Option<crate::model::InboundConnectionStatusCode>,
    /// <p>Information about the connection.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
}
impl InboundConnectionStatus {
    /// <p>The status code for the connection. Can be one of the following:</p>
    /// <ul>
    /// <li> <p> <b>PENDING_ACCEPTANCE</b> - Inbound connection is not yet accepted by the remote domain owner.</p> </li>
    /// <li> <p> <b>APPROVED</b>: Inbound connection is pending acceptance by the remote domain owner.</p> </li>
    /// <li> <p> <b>PROVISIONING</b>: Inbound connection is being provisioned.</p> </li>
    /// <li> <p> <b>ACTIVE</b>: Inbound connection is active and ready to use.</p> </li>
    /// <li> <p> <b>REJECTING</b>: Inbound connection rejection is in process.</p> </li>
    /// <li> <p> <b>REJECTED</b>: Inbound connection is rejected.</p> </li>
    /// <li> <p> <b>DELETING</b>: Inbound connection deletion is in progress.</p> </li>
    /// <li> <p> <b>DELETED</b>: Inbound connection is deleted and can no longer be used.</p> </li>
    /// </ul>
    pub fn status_code(&self) -> std::option::Option<&crate::model::InboundConnectionStatusCode> {
        self.status_code.as_ref()
    }
    /// <p>Information about the connection.</p>
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
/// See [`InboundConnectionStatus`](crate::model::InboundConnectionStatus).
pub mod inbound_connection_status {

    /// A builder for [`InboundConnectionStatus`](crate::model::InboundConnectionStatus).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) status_code: std::option::Option<crate::model::InboundConnectionStatusCode>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The status code for the connection. Can be one of the following:</p>
        /// <ul>
        /// <li> <p> <b>PENDING_ACCEPTANCE</b> - Inbound connection is not yet accepted by the remote domain owner.</p> </li>
        /// <li> <p> <b>APPROVED</b>: Inbound connection is pending acceptance by the remote domain owner.</p> </li>
        /// <li> <p> <b>PROVISIONING</b>: Inbound connection is being provisioned.</p> </li>
        /// <li> <p> <b>ACTIVE</b>: Inbound connection is active and ready to use.</p> </li>
        /// <li> <p> <b>REJECTING</b>: Inbound connection rejection is in process.</p> </li>
        /// <li> <p> <b>REJECTED</b>: Inbound connection is rejected.</p> </li>
        /// <li> <p> <b>DELETING</b>: Inbound connection deletion is in progress.</p> </li>
        /// <li> <p> <b>DELETED</b>: Inbound connection is deleted and can no longer be used.</p> </li>
        /// </ul>
        pub fn status_code(mut self, input: crate::model::InboundConnectionStatusCode) -> Self {
            self.status_code = Some(input);
            self
        }
        /// <p>The status code for the connection. Can be one of the following:</p>
        /// <ul>
        /// <li> <p> <b>PENDING_ACCEPTANCE</b> - Inbound connection is not yet accepted by the remote domain owner.</p> </li>
        /// <li> <p> <b>APPROVED</b>: Inbound connection is pending acceptance by the remote domain owner.</p> </li>
        /// <li> <p> <b>PROVISIONING</b>: Inbound connection is being provisioned.</p> </li>
        /// <li> <p> <b>ACTIVE</b>: Inbound connection is active and ready to use.</p> </li>
        /// <li> <p> <b>REJECTING</b>: Inbound connection rejection is in process.</p> </li>
        /// <li> <p> <b>REJECTED</b>: Inbound connection is rejected.</p> </li>
        /// <li> <p> <b>DELETING</b>: Inbound connection deletion is in progress.</p> </li>
        /// <li> <p> <b>DELETED</b>: Inbound connection is deleted and can no longer be used.</p> </li>
        /// </ul>
        pub fn set_status_code(
            mut self,
            input: std::option::Option<crate::model::InboundConnectionStatusCode>,
        ) -> Self {
            self.status_code = input;
            self
        }
        /// <p>Information about the connection.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Information about the connection.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InboundConnectionStatus`](crate::model::InboundConnectionStatus).
        pub fn build(self) -> crate::model::InboundConnectionStatus {
            crate::model::InboundConnectionStatus {
                status_code: self.status_code,
                message: self.message,
            }
        }
    }
}
impl InboundConnectionStatus {
    /// Creates a new builder-style object to manufacture [`InboundConnectionStatus`](crate::model::InboundConnectionStatus).
    pub fn builder() -> crate::model::inbound_connection_status::Builder {
        crate::model::inbound_connection_status::Builder::default()
    }
}

/// When writing a match expression against `InboundConnectionStatusCode`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let inboundconnectionstatuscode = unimplemented!();
/// match inboundconnectionstatuscode {
///     InboundConnectionStatusCode::Active => { /* ... */ },
///     InboundConnectionStatusCode::Approved => { /* ... */ },
///     InboundConnectionStatusCode::Deleted => { /* ... */ },
///     InboundConnectionStatusCode::Deleting => { /* ... */ },
///     InboundConnectionStatusCode::PendingAcceptance => { /* ... */ },
///     InboundConnectionStatusCode::Provisioning => { /* ... */ },
///     InboundConnectionStatusCode::Rejected => { /* ... */ },
///     InboundConnectionStatusCode::Rejecting => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `inboundconnectionstatuscode` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `InboundConnectionStatusCode::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `InboundConnectionStatusCode::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `InboundConnectionStatusCode::NewFeature` is defined.
/// Specifically, when `inboundconnectionstatuscode` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `InboundConnectionStatusCode::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum InboundConnectionStatusCode {
    #[allow(missing_docs)] // documentation missing in model
    Active,
    #[allow(missing_docs)] // documentation missing in model
    Approved,
    #[allow(missing_docs)] // documentation missing in model
    Deleted,
    #[allow(missing_docs)] // documentation missing in model
    Deleting,
    #[allow(missing_docs)] // documentation missing in model
    PendingAcceptance,
    #[allow(missing_docs)] // documentation missing in model
    Provisioning,
    #[allow(missing_docs)] // documentation missing in model
    Rejected,
    #[allow(missing_docs)] // documentation missing in model
    Rejecting,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for InboundConnectionStatusCode {
    fn from(s: &str) -> Self {
        match s {
            "ACTIVE" => InboundConnectionStatusCode::Active,
            "APPROVED" => InboundConnectionStatusCode::Approved,
            "DELETED" => InboundConnectionStatusCode::Deleted,
            "DELETING" => InboundConnectionStatusCode::Deleting,
            "PENDING_ACCEPTANCE" => InboundConnectionStatusCode::PendingAcceptance,
            "PROVISIONING" => InboundConnectionStatusCode::Provisioning,
            "REJECTED" => InboundConnectionStatusCode::Rejected,
            "REJECTING" => InboundConnectionStatusCode::Rejecting,
            other => InboundConnectionStatusCode::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for InboundConnectionStatusCode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(InboundConnectionStatusCode::from(s))
    }
}
impl InboundConnectionStatusCode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            InboundConnectionStatusCode::Active => "ACTIVE",
            InboundConnectionStatusCode::Approved => "APPROVED",
            InboundConnectionStatusCode::Deleted => "DELETED",
            InboundConnectionStatusCode::Deleting => "DELETING",
            InboundConnectionStatusCode::PendingAcceptance => "PENDING_ACCEPTANCE",
            InboundConnectionStatusCode::Provisioning => "PROVISIONING",
            InboundConnectionStatusCode::Rejected => "REJECTED",
            InboundConnectionStatusCode::Rejecting => "REJECTING",
            InboundConnectionStatusCode::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "ACTIVE",
            "APPROVED",
            "DELETED",
            "DELETING",
            "PENDING_ACCEPTANCE",
            "PROVISIONING",
            "REJECTED",
            "REJECTING",
        ]
    }
}
impl AsRef<str> for InboundConnectionStatusCode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Container for information about an OpenSearch Service domain.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DomainInformationContainer {
    /// <p>Information about an Amazon OpenSearch Service domain.</p>
    #[doc(hidden)]
    pub aws_domain_information: std::option::Option<crate::model::AwsDomainInformation>,
}
impl DomainInformationContainer {
    /// <p>Information about an Amazon OpenSearch Service domain.</p>
    pub fn aws_domain_information(
        &self,
    ) -> std::option::Option<&crate::model::AwsDomainInformation> {
        self.aws_domain_information.as_ref()
    }
}
/// See [`DomainInformationContainer`](crate::model::DomainInformationContainer).
pub mod domain_information_container {

    /// A builder for [`DomainInformationContainer`](crate::model::DomainInformationContainer).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) aws_domain_information: std::option::Option<crate::model::AwsDomainInformation>,
    }
    impl Builder {
        /// <p>Information about an Amazon OpenSearch Service domain.</p>
        pub fn aws_domain_information(mut self, input: crate::model::AwsDomainInformation) -> Self {
            self.aws_domain_information = Some(input);
            self
        }
        /// <p>Information about an Amazon OpenSearch Service domain.</p>
        pub fn set_aws_domain_information(
            mut self,
            input: std::option::Option<crate::model::AwsDomainInformation>,
        ) -> Self {
            self.aws_domain_information = input;
            self
        }
        /// Consumes the builder and constructs a [`DomainInformationContainer`](crate::model::DomainInformationContainer).
        pub fn build(self) -> crate::model::DomainInformationContainer {
            crate::model::DomainInformationContainer {
                aws_domain_information: self.aws_domain_information,
            }
        }
    }
}
impl DomainInformationContainer {
    /// Creates a new builder-style object to manufacture [`DomainInformationContainer`](crate::model::DomainInformationContainer).
    pub fn builder() -> crate::model::domain_information_container::Builder {
        crate::model::domain_information_container::Builder::default()
    }
}

/// <p>Information about an Amazon OpenSearch Service domain.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AwsDomainInformation {
    /// <p>The Amazon Web Services account ID of the domain owner.</p>
    #[doc(hidden)]
    pub owner_id: std::option::Option<std::string::String>,
    /// <p>Name of the domain.</p>
    #[doc(hidden)]
    pub domain_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services Region in which the domain is located.</p>
    #[doc(hidden)]
    pub region: std::option::Option<std::string::String>,
}
impl AwsDomainInformation {
    /// <p>The Amazon Web Services account ID of the domain owner.</p>
    pub fn owner_id(&self) -> std::option::Option<&str> {
        self.owner_id.as_deref()
    }
    /// <p>Name of the domain.</p>
    pub fn domain_name(&self) -> std::option::Option<&str> {
        self.domain_name.as_deref()
    }
    /// <p>The Amazon Web Services Region in which the domain is located.</p>
    pub fn region(&self) -> std::option::Option<&str> {
        self.region.as_deref()
    }
}
/// See [`AwsDomainInformation`](crate::model::AwsDomainInformation).
pub mod aws_domain_information {

    /// A builder for [`AwsDomainInformation`](crate::model::AwsDomainInformation).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) owner_id: std::option::Option<std::string::String>,
        pub(crate) domain_name: std::option::Option<std::string::String>,
        pub(crate) region: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Web Services account ID of the domain owner.</p>
        pub fn owner_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.owner_id = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services account ID of the domain owner.</p>
        pub fn set_owner_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.owner_id = input;
            self
        }
        /// <p>Name of the domain.</p>
        pub fn domain_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_name = Some(input.into());
            self
        }
        /// <p>Name of the domain.</p>
        pub fn set_domain_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_name = input;
            self
        }
        /// <p>The Amazon Web Services Region in which the domain is located.</p>
        pub fn region(mut self, input: impl Into<std::string::String>) -> Self {
            self.region = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services Region in which the domain is located.</p>
        pub fn set_region(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.region = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsDomainInformation`](crate::model::AwsDomainInformation).
        pub fn build(self) -> crate::model::AwsDomainInformation {
            crate::model::AwsDomainInformation {
                owner_id: self.owner_id,
                domain_name: self.domain_name,
                region: self.region,
            }
        }
    }
}
impl AwsDomainInformation {
    /// Creates a new builder-style object to manufacture [`AwsDomainInformation`](crate::model::AwsDomainInformation).
    pub fn builder() -> crate::model::aws_domain_information::Builder {
        crate::model::aws_domain_information::Builder::default()
    }
}

/// <p>Summary information for an Amazon OpenSearch Service-managed VPC endpoint.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct VpcEndpointSummary {
    /// <p>The unique identifier of the endpoint.</p>
    #[doc(hidden)]
    pub vpc_endpoint_id: std::option::Option<std::string::String>,
    /// <p>The creator of the endpoint.</p>
    #[doc(hidden)]
    pub vpc_endpoint_owner: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the domain associated with the endpoint.</p>
    #[doc(hidden)]
    pub domain_arn: std::option::Option<std::string::String>,
    /// <p>The current status of the endpoint.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::VpcEndpointStatus>,
}
impl VpcEndpointSummary {
    /// <p>The unique identifier of the endpoint.</p>
    pub fn vpc_endpoint_id(&self) -> std::option::Option<&str> {
        self.vpc_endpoint_id.as_deref()
    }
    /// <p>The creator of the endpoint.</p>
    pub fn vpc_endpoint_owner(&self) -> std::option::Option<&str> {
        self.vpc_endpoint_owner.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the domain associated with the endpoint.</p>
    pub fn domain_arn(&self) -> std::option::Option<&str> {
        self.domain_arn.as_deref()
    }
    /// <p>The current status of the endpoint.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::VpcEndpointStatus> {
        self.status.as_ref()
    }
}
/// See [`VpcEndpointSummary`](crate::model::VpcEndpointSummary).
pub mod vpc_endpoint_summary {

    /// A builder for [`VpcEndpointSummary`](crate::model::VpcEndpointSummary).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) vpc_endpoint_id: std::option::Option<std::string::String>,
        pub(crate) vpc_endpoint_owner: std::option::Option<std::string::String>,
        pub(crate) domain_arn: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::VpcEndpointStatus>,
    }
    impl Builder {
        /// <p>The unique identifier of the endpoint.</p>
        pub fn vpc_endpoint_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.vpc_endpoint_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of the endpoint.</p>
        pub fn set_vpc_endpoint_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.vpc_endpoint_id = input;
            self
        }
        /// <p>The creator of the endpoint.</p>
        pub fn vpc_endpoint_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.vpc_endpoint_owner = Some(input.into());
            self
        }
        /// <p>The creator of the endpoint.</p>
        pub fn set_vpc_endpoint_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.vpc_endpoint_owner = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the domain associated with the endpoint.</p>
        pub fn domain_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the domain associated with the endpoint.</p>
        pub fn set_domain_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_arn = input;
            self
        }
        /// <p>The current status of the endpoint.</p>
        pub fn status(mut self, input: crate::model::VpcEndpointStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The current status of the endpoint.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::VpcEndpointStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// Consumes the builder and constructs a [`VpcEndpointSummary`](crate::model::VpcEndpointSummary).
        pub fn build(self) -> crate::model::VpcEndpointSummary {
            crate::model::VpcEndpointSummary {
                vpc_endpoint_id: self.vpc_endpoint_id,
                vpc_endpoint_owner: self.vpc_endpoint_owner,
                domain_arn: self.domain_arn,
                status: self.status,
            }
        }
    }
}
impl VpcEndpointSummary {
    /// Creates a new builder-style object to manufacture [`VpcEndpointSummary`](crate::model::VpcEndpointSummary).
    pub fn builder() -> crate::model::vpc_endpoint_summary::Builder {
        crate::model::vpc_endpoint_summary::Builder::default()
    }
}

/// <p>Information about an Amazon Web Services account or service that has access to an Amazon OpenSearch Service domain through the use of an interface VPC endpoint.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AuthorizedPrincipal {
    /// <p>The type of principal.</p>
    #[doc(hidden)]
    pub principal_type: std::option::Option<crate::model::PrincipalType>,
    /// <p>The <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_elements_principal.html">IAM principal</a> that is allowed access to the domain.</p>
    #[doc(hidden)]
    pub principal: std::option::Option<std::string::String>,
}
impl AuthorizedPrincipal {
    /// <p>The type of principal.</p>
    pub fn principal_type(&self) -> std::option::Option<&crate::model::PrincipalType> {
        self.principal_type.as_ref()
    }
    /// <p>The <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_elements_principal.html">IAM principal</a> that is allowed access to the domain.</p>
    pub fn principal(&self) -> std::option::Option<&str> {
        self.principal.as_deref()
    }
}
/// See [`AuthorizedPrincipal`](crate::model::AuthorizedPrincipal).
pub mod authorized_principal {

    /// A builder for [`AuthorizedPrincipal`](crate::model::AuthorizedPrincipal).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) principal_type: std::option::Option<crate::model::PrincipalType>,
        pub(crate) principal: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The type of principal.</p>
        pub fn principal_type(mut self, input: crate::model::PrincipalType) -> Self {
            self.principal_type = Some(input);
            self
        }
        /// <p>The type of principal.</p>
        pub fn set_principal_type(
            mut self,
            input: std::option::Option<crate::model::PrincipalType>,
        ) -> Self {
            self.principal_type = input;
            self
        }
        /// <p>The <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_elements_principal.html">IAM principal</a> that is allowed access to the domain.</p>
        pub fn principal(mut self, input: impl Into<std::string::String>) -> Self {
            self.principal = Some(input.into());
            self
        }
        /// <p>The <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_elements_principal.html">IAM principal</a> that is allowed access to the domain.</p>
        pub fn set_principal(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.principal = input;
            self
        }
        /// Consumes the builder and constructs a [`AuthorizedPrincipal`](crate::model::AuthorizedPrincipal).
        pub fn build(self) -> crate::model::AuthorizedPrincipal {
            crate::model::AuthorizedPrincipal {
                principal_type: self.principal_type,
                principal: self.principal,
            }
        }
    }
}
impl AuthorizedPrincipal {
    /// Creates a new builder-style object to manufacture [`AuthorizedPrincipal`](crate::model::AuthorizedPrincipal).
    pub fn builder() -> crate::model::authorized_principal::Builder {
        crate::model::authorized_principal::Builder::default()
    }
}

/// When writing a match expression against `PrincipalType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let principaltype = unimplemented!();
/// match principaltype {
///     PrincipalType::AwsAccount => { /* ... */ },
///     PrincipalType::AwsService => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `principaltype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `PrincipalType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `PrincipalType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `PrincipalType::NewFeature` is defined.
/// Specifically, when `principaltype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `PrincipalType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum PrincipalType {
    #[allow(missing_docs)] // documentation missing in model
    AwsAccount,
    #[allow(missing_docs)] // documentation missing in model
    AwsService,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for PrincipalType {
    fn from(s: &str) -> Self {
        match s {
            "AWS_ACCOUNT" => PrincipalType::AwsAccount,
            "AWS_SERVICE" => PrincipalType::AwsService,
            other => PrincipalType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for PrincipalType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(PrincipalType::from(s))
    }
}
impl PrincipalType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            PrincipalType::AwsAccount => "AWS_ACCOUNT",
            PrincipalType::AwsService => "AWS_SERVICE",
            PrincipalType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["AWS_ACCOUNT", "AWS_SERVICE"]
    }
}
impl AsRef<str> for PrincipalType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A tag (key-value pair) for an Amazon OpenSearch Service resource.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Tag {
    /// <p>The tag key. Tag keys must be unique for the domain to which they are attached.</p>
    #[doc(hidden)]
    pub key: std::option::Option<std::string::String>,
    /// <p>The value assigned to the corresponding tag key. Tag values can be null and don't have to be unique in a tag set. For example, you can have a key value pair in a tag set of <code>project : Trinity</code> and <code>cost-center : Trinity</code> </p>
    #[doc(hidden)]
    pub value: std::option::Option<std::string::String>,
}
impl Tag {
    /// <p>The tag key. Tag keys must be unique for the domain to which they are attached.</p>
    pub fn key(&self) -> std::option::Option<&str> {
        self.key.as_deref()
    }
    /// <p>The value assigned to the corresponding tag key. Tag values can be null and don't have to be unique in a tag set. For example, you can have a key value pair in a tag set of <code>project : Trinity</code> and <code>cost-center : Trinity</code> </p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
}
/// See [`Tag`](crate::model::Tag).
pub mod tag {

    /// A builder for [`Tag`](crate::model::Tag).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The tag key. Tag keys must be unique for the domain to which they are attached.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        /// <p>The tag key. Tag keys must be unique for the domain to which they are attached.</p>
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// <p>The value assigned to the corresponding tag key. Tag values can be null and don't have to be unique in a tag set. For example, you can have a key value pair in a tag set of <code>project : Trinity</code> and <code>cost-center : Trinity</code> </p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>The value assigned to the corresponding tag key. Tag values can be null and don't have to be unique in a tag set. For example, you can have a key value pair in a tag set of <code>project : Trinity</code> and <code>cost-center : Trinity</code> </p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`Tag`](crate::model::Tag).
        pub fn build(self) -> crate::model::Tag {
            crate::model::Tag {
                key: self.key,
                value: self.value,
            }
        }
    }
}
impl Tag {
    /// Creates a new builder-style object to manufacture [`Tag`](crate::model::Tag).
    pub fn builder() -> crate::model::tag::Builder {
        crate::model::tag::Builder::default()
    }
}

/// <p>Information about a package that is associated with a domain. For more information, see <a href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/custom-packages.html">Custom packages for Amazon OpenSearch Service</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DomainPackageDetails {
    /// <p>Internal ID of the package.</p>
    #[doc(hidden)]
    pub package_id: std::option::Option<std::string::String>,
    /// <p>User-specified name of the package.</p>
    #[doc(hidden)]
    pub package_name: std::option::Option<std::string::String>,
    /// <p>The type of package.</p>
    #[doc(hidden)]
    pub package_type: std::option::Option<crate::model::PackageType>,
    /// <p>Timestamp of the most recent update to the package association status.</p>
    #[doc(hidden)]
    pub last_updated: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Name of the domain that the package is associated with.</p>
    #[doc(hidden)]
    pub domain_name: std::option::Option<std::string::String>,
    /// <p>State of the association.</p>
    #[doc(hidden)]
    pub domain_package_status: std::option::Option<crate::model::DomainPackageStatus>,
    /// <p>The current version of the package.</p>
    #[doc(hidden)]
    pub package_version: std::option::Option<std::string::String>,
    /// <p>Denotes the location of the package on the OpenSearch Service cluster nodes. It's the same as <code>synonym_path</code> for dictionary files.</p>
    #[doc(hidden)]
    pub reference_path: std::option::Option<std::string::String>,
    /// <p>Additional information if the package is in an error state. Null otherwise.</p>
    #[doc(hidden)]
    pub error_details: std::option::Option<crate::model::ErrorDetails>,
}
impl DomainPackageDetails {
    /// <p>Internal ID of the package.</p>
    pub fn package_id(&self) -> std::option::Option<&str> {
        self.package_id.as_deref()
    }
    /// <p>User-specified name of the package.</p>
    pub fn package_name(&self) -> std::option::Option<&str> {
        self.package_name.as_deref()
    }
    /// <p>The type of package.</p>
    pub fn package_type(&self) -> std::option::Option<&crate::model::PackageType> {
        self.package_type.as_ref()
    }
    /// <p>Timestamp of the most recent update to the package association status.</p>
    pub fn last_updated(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_updated.as_ref()
    }
    /// <p>Name of the domain that the package is associated with.</p>
    pub fn domain_name(&self) -> std::option::Option<&str> {
        self.domain_name.as_deref()
    }
    /// <p>State of the association.</p>
    pub fn domain_package_status(&self) -> std::option::Option<&crate::model::DomainPackageStatus> {
        self.domain_package_status.as_ref()
    }
    /// <p>The current version of the package.</p>
    pub fn package_version(&self) -> std::option::Option<&str> {
        self.package_version.as_deref()
    }
    /// <p>Denotes the location of the package on the OpenSearch Service cluster nodes. It's the same as <code>synonym_path</code> for dictionary files.</p>
    pub fn reference_path(&self) -> std::option::Option<&str> {
        self.reference_path.as_deref()
    }
    /// <p>Additional information if the package is in an error state. Null otherwise.</p>
    pub fn error_details(&self) -> std::option::Option<&crate::model::ErrorDetails> {
        self.error_details.as_ref()
    }
}
/// See [`DomainPackageDetails`](crate::model::DomainPackageDetails).
pub mod domain_package_details {

    /// A builder for [`DomainPackageDetails`](crate::model::DomainPackageDetails).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) package_id: std::option::Option<std::string::String>,
        pub(crate) package_name: std::option::Option<std::string::String>,
        pub(crate) package_type: std::option::Option<crate::model::PackageType>,
        pub(crate) last_updated: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) domain_name: std::option::Option<std::string::String>,
        pub(crate) domain_package_status: std::option::Option<crate::model::DomainPackageStatus>,
        pub(crate) package_version: std::option::Option<std::string::String>,
        pub(crate) reference_path: std::option::Option<std::string::String>,
        pub(crate) error_details: std::option::Option<crate::model::ErrorDetails>,
    }
    impl Builder {
        /// <p>Internal ID of the package.</p>
        pub fn package_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.package_id = Some(input.into());
            self
        }
        /// <p>Internal ID of the package.</p>
        pub fn set_package_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.package_id = input;
            self
        }
        /// <p>User-specified name of the package.</p>
        pub fn package_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.package_name = Some(input.into());
            self
        }
        /// <p>User-specified name of the package.</p>
        pub fn set_package_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.package_name = input;
            self
        }
        /// <p>The type of package.</p>
        pub fn package_type(mut self, input: crate::model::PackageType) -> Self {
            self.package_type = Some(input);
            self
        }
        /// <p>The type of package.</p>
        pub fn set_package_type(
            mut self,
            input: std::option::Option<crate::model::PackageType>,
        ) -> Self {
            self.package_type = input;
            self
        }
        /// <p>Timestamp of the most recent update to the package association status.</p>
        pub fn last_updated(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_updated = Some(input);
            self
        }
        /// <p>Timestamp of the most recent update to the package association status.</p>
        pub fn set_last_updated(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_updated = input;
            self
        }
        /// <p>Name of the domain that the package is associated with.</p>
        pub fn domain_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_name = Some(input.into());
            self
        }
        /// <p>Name of the domain that the package is associated with.</p>
        pub fn set_domain_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_name = input;
            self
        }
        /// <p>State of the association.</p>
        pub fn domain_package_status(mut self, input: crate::model::DomainPackageStatus) -> Self {
            self.domain_package_status = Some(input);
            self
        }
        /// <p>State of the association.</p>
        pub fn set_domain_package_status(
            mut self,
            input: std::option::Option<crate::model::DomainPackageStatus>,
        ) -> Self {
            self.domain_package_status = input;
            self
        }
        /// <p>The current version of the package.</p>
        pub fn package_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.package_version = Some(input.into());
            self
        }
        /// <p>The current version of the package.</p>
        pub fn set_package_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.package_version = input;
            self
        }
        /// <p>Denotes the location of the package on the OpenSearch Service cluster nodes. It's the same as <code>synonym_path</code> for dictionary files.</p>
        pub fn reference_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.reference_path = Some(input.into());
            self
        }
        /// <p>Denotes the location of the package on the OpenSearch Service cluster nodes. It's the same as <code>synonym_path</code> for dictionary files.</p>
        pub fn set_reference_path(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.reference_path = input;
            self
        }
        /// <p>Additional information if the package is in an error state. Null otherwise.</p>
        pub fn error_details(mut self, input: crate::model::ErrorDetails) -> Self {
            self.error_details = Some(input);
            self
        }
        /// <p>Additional information if the package is in an error state. Null otherwise.</p>
        pub fn set_error_details(
            mut self,
            input: std::option::Option<crate::model::ErrorDetails>,
        ) -> Self {
            self.error_details = input;
            self
        }
        /// Consumes the builder and constructs a [`DomainPackageDetails`](crate::model::DomainPackageDetails).
        pub fn build(self) -> crate::model::DomainPackageDetails {
            crate::model::DomainPackageDetails {
                package_id: self.package_id,
                package_name: self.package_name,
                package_type: self.package_type,
                last_updated: self.last_updated,
                domain_name: self.domain_name,
                domain_package_status: self.domain_package_status,
                package_version: self.package_version,
                reference_path: self.reference_path,
                error_details: self.error_details,
            }
        }
    }
}
impl DomainPackageDetails {
    /// Creates a new builder-style object to manufacture [`DomainPackageDetails`](crate::model::DomainPackageDetails).
    pub fn builder() -> crate::model::domain_package_details::Builder {
        crate::model::domain_package_details::Builder::default()
    }
}

/// When writing a match expression against `DomainPackageStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let domainpackagestatus = unimplemented!();
/// match domainpackagestatus {
///     DomainPackageStatus::Active => { /* ... */ },
///     DomainPackageStatus::Associating => { /* ... */ },
///     DomainPackageStatus::AssociationFailed => { /* ... */ },
///     DomainPackageStatus::Dissociating => { /* ... */ },
///     DomainPackageStatus::DissociationFailed => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `domainpackagestatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `DomainPackageStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `DomainPackageStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `DomainPackageStatus::NewFeature` is defined.
/// Specifically, when `domainpackagestatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `DomainPackageStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DomainPackageStatus {
    #[allow(missing_docs)] // documentation missing in model
    Active,
    #[allow(missing_docs)] // documentation missing in model
    Associating,
    #[allow(missing_docs)] // documentation missing in model
    AssociationFailed,
    #[allow(missing_docs)] // documentation missing in model
    Dissociating,
    #[allow(missing_docs)] // documentation missing in model
    DissociationFailed,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for DomainPackageStatus {
    fn from(s: &str) -> Self {
        match s {
            "ACTIVE" => DomainPackageStatus::Active,
            "ASSOCIATING" => DomainPackageStatus::Associating,
            "ASSOCIATION_FAILED" => DomainPackageStatus::AssociationFailed,
            "DISSOCIATING" => DomainPackageStatus::Dissociating,
            "DISSOCIATION_FAILED" => DomainPackageStatus::DissociationFailed,
            other => {
                DomainPackageStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for DomainPackageStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DomainPackageStatus::from(s))
    }
}
impl DomainPackageStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            DomainPackageStatus::Active => "ACTIVE",
            DomainPackageStatus::Associating => "ASSOCIATING",
            DomainPackageStatus::AssociationFailed => "ASSOCIATION_FAILED",
            DomainPackageStatus::Dissociating => "DISSOCIATING",
            DomainPackageStatus::DissociationFailed => "DISSOCIATION_FAILED",
            DomainPackageStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "ACTIVE",
            "ASSOCIATING",
            "ASSOCIATION_FAILED",
            "DISSOCIATING",
            "DISSOCIATION_FAILED",
        ]
    }
}
impl AsRef<str> for DomainPackageStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Lists all instance types and available features for a given OpenSearch or Elasticsearch version.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InstanceTypeDetails {
    /// <p>The instance type.</p>
    #[doc(hidden)]
    pub instance_type: std::option::Option<crate::model::OpenSearchPartitionInstanceType>,
    /// <p>Whether encryption at rest and node-to-node encryption are supported for the instance type.</p>
    #[doc(hidden)]
    pub encryption_enabled: std::option::Option<bool>,
    /// <p>Whether Amazon Cognito access is supported for the instance type.</p>
    #[doc(hidden)]
    pub cognito_enabled: std::option::Option<bool>,
    /// <p>Whether logging is supported for the instance type.</p>
    #[doc(hidden)]
    pub app_logs_enabled: std::option::Option<bool>,
    /// <p>Whether fine-grained access control is supported for the instance type.</p>
    #[doc(hidden)]
    pub advanced_security_enabled: std::option::Option<bool>,
    /// <p>Whether UltraWarm is supported for the instance type.</p>
    #[doc(hidden)]
    pub warm_enabled: std::option::Option<bool>,
    /// <p>Whether the instance acts as a data node, a dedicated master node, or an UltraWarm node.</p>
    #[doc(hidden)]
    pub instance_role: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl InstanceTypeDetails {
    /// <p>The instance type.</p>
    pub fn instance_type(
        &self,
    ) -> std::option::Option<&crate::model::OpenSearchPartitionInstanceType> {
        self.instance_type.as_ref()
    }
    /// <p>Whether encryption at rest and node-to-node encryption are supported for the instance type.</p>
    pub fn encryption_enabled(&self) -> std::option::Option<bool> {
        self.encryption_enabled
    }
    /// <p>Whether Amazon Cognito access is supported for the instance type.</p>
    pub fn cognito_enabled(&self) -> std::option::Option<bool> {
        self.cognito_enabled
    }
    /// <p>Whether logging is supported for the instance type.</p>
    pub fn app_logs_enabled(&self) -> std::option::Option<bool> {
        self.app_logs_enabled
    }
    /// <p>Whether fine-grained access control is supported for the instance type.</p>
    pub fn advanced_security_enabled(&self) -> std::option::Option<bool> {
        self.advanced_security_enabled
    }
    /// <p>Whether UltraWarm is supported for the instance type.</p>
    pub fn warm_enabled(&self) -> std::option::Option<bool> {
        self.warm_enabled
    }
    /// <p>Whether the instance acts as a data node, a dedicated master node, or an UltraWarm node.</p>
    pub fn instance_role(&self) -> std::option::Option<&[std::string::String]> {
        self.instance_role.as_deref()
    }
}
/// See [`InstanceTypeDetails`](crate::model::InstanceTypeDetails).
pub mod instance_type_details {

    /// A builder for [`InstanceTypeDetails`](crate::model::InstanceTypeDetails).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_type:
            std::option::Option<crate::model::OpenSearchPartitionInstanceType>,
        pub(crate) encryption_enabled: std::option::Option<bool>,
        pub(crate) cognito_enabled: std::option::Option<bool>,
        pub(crate) app_logs_enabled: std::option::Option<bool>,
        pub(crate) advanced_security_enabled: std::option::Option<bool>,
        pub(crate) warm_enabled: std::option::Option<bool>,
        pub(crate) instance_role: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The instance type.</p>
        pub fn instance_type(
            mut self,
            input: crate::model::OpenSearchPartitionInstanceType,
        ) -> Self {
            self.instance_type = Some(input);
            self
        }
        /// <p>The instance type.</p>
        pub fn set_instance_type(
            mut self,
            input: std::option::Option<crate::model::OpenSearchPartitionInstanceType>,
        ) -> Self {
            self.instance_type = input;
            self
        }
        /// <p>Whether encryption at rest and node-to-node encryption are supported for the instance type.</p>
        pub fn encryption_enabled(mut self, input: bool) -> Self {
            self.encryption_enabled = Some(input);
            self
        }
        /// <p>Whether encryption at rest and node-to-node encryption are supported for the instance type.</p>
        pub fn set_encryption_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.encryption_enabled = input;
            self
        }
        /// <p>Whether Amazon Cognito access is supported for the instance type.</p>
        pub fn cognito_enabled(mut self, input: bool) -> Self {
            self.cognito_enabled = Some(input);
            self
        }
        /// <p>Whether Amazon Cognito access is supported for the instance type.</p>
        pub fn set_cognito_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.cognito_enabled = input;
            self
        }
        /// <p>Whether logging is supported for the instance type.</p>
        pub fn app_logs_enabled(mut self, input: bool) -> Self {
            self.app_logs_enabled = Some(input);
            self
        }
        /// <p>Whether logging is supported for the instance type.</p>
        pub fn set_app_logs_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.app_logs_enabled = input;
            self
        }
        /// <p>Whether fine-grained access control is supported for the instance type.</p>
        pub fn advanced_security_enabled(mut self, input: bool) -> Self {
            self.advanced_security_enabled = Some(input);
            self
        }
        /// <p>Whether fine-grained access control is supported for the instance type.</p>
        pub fn set_advanced_security_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.advanced_security_enabled = input;
            self
        }
        /// <p>Whether UltraWarm is supported for the instance type.</p>
        pub fn warm_enabled(mut self, input: bool) -> Self {
            self.warm_enabled = Some(input);
            self
        }
        /// <p>Whether UltraWarm is supported for the instance type.</p>
        pub fn set_warm_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.warm_enabled = input;
            self
        }
        /// Appends an item to `instance_role`.
        ///
        /// To override the contents of this collection use [`set_instance_role`](Self::set_instance_role).
        ///
        /// <p>Whether the instance acts as a data node, a dedicated master node, or an UltraWarm node.</p>
        pub fn instance_role(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.instance_role.unwrap_or_default();
            v.push(input.into());
            self.instance_role = Some(v);
            self
        }
        /// <p>Whether the instance acts as a data node, a dedicated master node, or an UltraWarm node.</p>
        pub fn set_instance_role(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.instance_role = input;
            self
        }
        /// Consumes the builder and constructs a [`InstanceTypeDetails`](crate::model::InstanceTypeDetails).
        pub fn build(self) -> crate::model::InstanceTypeDetails {
            crate::model::InstanceTypeDetails {
                instance_type: self.instance_type,
                encryption_enabled: self.encryption_enabled,
                cognito_enabled: self.cognito_enabled,
                app_logs_enabled: self.app_logs_enabled,
                advanced_security_enabled: self.advanced_security_enabled,
                warm_enabled: self.warm_enabled,
                instance_role: self.instance_role,
            }
        }
    }
}
impl InstanceTypeDetails {
    /// Creates a new builder-style object to manufacture [`InstanceTypeDetails`](crate::model::InstanceTypeDetails).
    pub fn builder() -> crate::model::instance_type_details::Builder {
        crate::model::instance_type_details::Builder::default()
    }
}

/// <p>Information about an OpenSearch Service domain.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DomainInfo {
    /// <p>Name of the domain.</p>
    #[doc(hidden)]
    pub domain_name: std::option::Option<std::string::String>,
    /// <p>The type of search engine that the domain is running.<code>OpenSearch</code> for an OpenSearch engine, or <code>Elasticsearch</code> for a legacy Elasticsearch OSS engine.</p>
    #[doc(hidden)]
    pub engine_type: std::option::Option<crate::model::EngineType>,
}
impl DomainInfo {
    /// <p>Name of the domain.</p>
    pub fn domain_name(&self) -> std::option::Option<&str> {
        self.domain_name.as_deref()
    }
    /// <p>The type of search engine that the domain is running.<code>OpenSearch</code> for an OpenSearch engine, or <code>Elasticsearch</code> for a legacy Elasticsearch OSS engine.</p>
    pub fn engine_type(&self) -> std::option::Option<&crate::model::EngineType> {
        self.engine_type.as_ref()
    }
}
/// See [`DomainInfo`](crate::model::DomainInfo).
pub mod domain_info {

    /// A builder for [`DomainInfo`](crate::model::DomainInfo).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain_name: std::option::Option<std::string::String>,
        pub(crate) engine_type: std::option::Option<crate::model::EngineType>,
    }
    impl Builder {
        /// <p>Name of the domain.</p>
        pub fn domain_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_name = Some(input.into());
            self
        }
        /// <p>Name of the domain.</p>
        pub fn set_domain_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_name = input;
            self
        }
        /// <p>The type of search engine that the domain is running.<code>OpenSearch</code> for an OpenSearch engine, or <code>Elasticsearch</code> for a legacy Elasticsearch OSS engine.</p>
        pub fn engine_type(mut self, input: crate::model::EngineType) -> Self {
            self.engine_type = Some(input);
            self
        }
        /// <p>The type of search engine that the domain is running.<code>OpenSearch</code> for an OpenSearch engine, or <code>Elasticsearch</code> for a legacy Elasticsearch OSS engine.</p>
        pub fn set_engine_type(
            mut self,
            input: std::option::Option<crate::model::EngineType>,
        ) -> Self {
            self.engine_type = input;
            self
        }
        /// Consumes the builder and constructs a [`DomainInfo`](crate::model::DomainInfo).
        pub fn build(self) -> crate::model::DomainInfo {
            crate::model::DomainInfo {
                domain_name: self.domain_name,
                engine_type: self.engine_type,
            }
        }
    }
}
impl DomainInfo {
    /// Creates a new builder-style object to manufacture [`DomainInfo`](crate::model::DomainInfo).
    pub fn builder() -> crate::model::domain_info::Builder {
        crate::model::domain_info::Builder::default()
    }
}

/// When writing a match expression against `EngineType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let enginetype = unimplemented!();
/// match enginetype {
///     EngineType::Elasticsearch => { /* ... */ },
///     EngineType::OpenSearch => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `enginetype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `EngineType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `EngineType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `EngineType::NewFeature` is defined.
/// Specifically, when `enginetype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `EngineType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum EngineType {
    #[allow(missing_docs)] // documentation missing in model
    Elasticsearch,
    #[allow(missing_docs)] // documentation missing in model
    OpenSearch,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for EngineType {
    fn from(s: &str) -> Self {
        match s {
            "Elasticsearch" => EngineType::Elasticsearch,
            "OpenSearch" => EngineType::OpenSearch,
            other => EngineType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for EngineType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(EngineType::from(s))
    }
}
impl EngineType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            EngineType::Elasticsearch => "Elasticsearch",
            EngineType::OpenSearch => "OpenSearch",
            EngineType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["Elasticsearch", "OpenSearch"]
    }
}
impl AsRef<str> for EngineType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `UpgradeStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let upgradestatus = unimplemented!();
/// match upgradestatus {
///     UpgradeStatus::Failed => { /* ... */ },
///     UpgradeStatus::InProgress => { /* ... */ },
///     UpgradeStatus::Succeeded => { /* ... */ },
///     UpgradeStatus::SucceededWithIssues => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `upgradestatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `UpgradeStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `UpgradeStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `UpgradeStatus::NewFeature` is defined.
/// Specifically, when `upgradestatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `UpgradeStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum UpgradeStatus {
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    InProgress,
    #[allow(missing_docs)] // documentation missing in model
    Succeeded,
    #[allow(missing_docs)] // documentation missing in model
    SucceededWithIssues,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for UpgradeStatus {
    fn from(s: &str) -> Self {
        match s {
            "FAILED" => UpgradeStatus::Failed,
            "IN_PROGRESS" => UpgradeStatus::InProgress,
            "SUCCEEDED" => UpgradeStatus::Succeeded,
            "SUCCEEDED_WITH_ISSUES" => UpgradeStatus::SucceededWithIssues,
            other => UpgradeStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for UpgradeStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(UpgradeStatus::from(s))
    }
}
impl UpgradeStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            UpgradeStatus::Failed => "FAILED",
            UpgradeStatus::InProgress => "IN_PROGRESS",
            UpgradeStatus::Succeeded => "SUCCEEDED",
            UpgradeStatus::SucceededWithIssues => "SUCCEEDED_WITH_ISSUES",
            UpgradeStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "FAILED",
            "IN_PROGRESS",
            "SUCCEEDED",
            "SUCCEEDED_WITH_ISSUES",
        ]
    }
}
impl AsRef<str> for UpgradeStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `UpgradeStep`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let upgradestep = unimplemented!();
/// match upgradestep {
///     UpgradeStep::PreUpgradeCheck => { /* ... */ },
///     UpgradeStep::Snapshot => { /* ... */ },
///     UpgradeStep::Upgrade => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `upgradestep` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `UpgradeStep::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `UpgradeStep::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `UpgradeStep::NewFeature` is defined.
/// Specifically, when `upgradestep` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `UpgradeStep::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum UpgradeStep {
    #[allow(missing_docs)] // documentation missing in model
    PreUpgradeCheck,
    #[allow(missing_docs)] // documentation missing in model
    Snapshot,
    #[allow(missing_docs)] // documentation missing in model
    Upgrade,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for UpgradeStep {
    fn from(s: &str) -> Self {
        match s {
            "PRE_UPGRADE_CHECK" => UpgradeStep::PreUpgradeCheck,
            "SNAPSHOT" => UpgradeStep::Snapshot,
            "UPGRADE" => UpgradeStep::Upgrade,
            other => UpgradeStep::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for UpgradeStep {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(UpgradeStep::from(s))
    }
}
impl UpgradeStep {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            UpgradeStep::PreUpgradeCheck => "PRE_UPGRADE_CHECK",
            UpgradeStep::Snapshot => "SNAPSHOT",
            UpgradeStep::Upgrade => "UPGRADE",
            UpgradeStep::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["PRE_UPGRADE_CHECK", "SNAPSHOT", "UPGRADE"]
    }
}
impl AsRef<str> for UpgradeStep {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>History of the last 10 upgrades and upgrade eligibility checks for an Amazon OpenSearch Service domain.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpgradeHistory {
    /// <p>A string that describes the upgrade.</p>
    #[doc(hidden)]
    pub upgrade_name: std::option::Option<std::string::String>,
    /// <p>UTC timestamp at which the upgrade API call was made, in the format <code>yyyy-MM-ddTHH:mm:ssZ</code>.</p>
    #[doc(hidden)]
    pub start_timestamp: std::option::Option<aws_smithy_types::DateTime>,
    /// <p> The current status of the upgrade. The status can take one of the following values: </p>
    /// <ul>
    /// <li> <p>In Progress</p> </li>
    /// <li> <p>Succeeded</p> </li>
    /// <li> <p>Succeeded with Issues</p> </li>
    /// <li> <p>Failed</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub upgrade_status: std::option::Option<crate::model::UpgradeStatus>,
    /// <p>A list of each step performed as part of a specific upgrade or upgrade eligibility check.</p>
    #[doc(hidden)]
    pub steps_list: std::option::Option<std::vec::Vec<crate::model::UpgradeStepItem>>,
}
impl UpgradeHistory {
    /// <p>A string that describes the upgrade.</p>
    pub fn upgrade_name(&self) -> std::option::Option<&str> {
        self.upgrade_name.as_deref()
    }
    /// <p>UTC timestamp at which the upgrade API call was made, in the format <code>yyyy-MM-ddTHH:mm:ssZ</code>.</p>
    pub fn start_timestamp(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.start_timestamp.as_ref()
    }
    /// <p> The current status of the upgrade. The status can take one of the following values: </p>
    /// <ul>
    /// <li> <p>In Progress</p> </li>
    /// <li> <p>Succeeded</p> </li>
    /// <li> <p>Succeeded with Issues</p> </li>
    /// <li> <p>Failed</p> </li>
    /// </ul>
    pub fn upgrade_status(&self) -> std::option::Option<&crate::model::UpgradeStatus> {
        self.upgrade_status.as_ref()
    }
    /// <p>A list of each step performed as part of a specific upgrade or upgrade eligibility check.</p>
    pub fn steps_list(&self) -> std::option::Option<&[crate::model::UpgradeStepItem]> {
        self.steps_list.as_deref()
    }
}
/// See [`UpgradeHistory`](crate::model::UpgradeHistory).
pub mod upgrade_history {

    /// A builder for [`UpgradeHistory`](crate::model::UpgradeHistory).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) upgrade_name: std::option::Option<std::string::String>,
        pub(crate) start_timestamp: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) upgrade_status: std::option::Option<crate::model::UpgradeStatus>,
        pub(crate) steps_list: std::option::Option<std::vec::Vec<crate::model::UpgradeStepItem>>,
    }
    impl Builder {
        /// <p>A string that describes the upgrade.</p>
        pub fn upgrade_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.upgrade_name = Some(input.into());
            self
        }
        /// <p>A string that describes the upgrade.</p>
        pub fn set_upgrade_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.upgrade_name = input;
            self
        }
        /// <p>UTC timestamp at which the upgrade API call was made, in the format <code>yyyy-MM-ddTHH:mm:ssZ</code>.</p>
        pub fn start_timestamp(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.start_timestamp = Some(input);
            self
        }
        /// <p>UTC timestamp at which the upgrade API call was made, in the format <code>yyyy-MM-ddTHH:mm:ssZ</code>.</p>
        pub fn set_start_timestamp(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.start_timestamp = input;
            self
        }
        /// <p> The current status of the upgrade. The status can take one of the following values: </p>
        /// <ul>
        /// <li> <p>In Progress</p> </li>
        /// <li> <p>Succeeded</p> </li>
        /// <li> <p>Succeeded with Issues</p> </li>
        /// <li> <p>Failed</p> </li>
        /// </ul>
        pub fn upgrade_status(mut self, input: crate::model::UpgradeStatus) -> Self {
            self.upgrade_status = Some(input);
            self
        }
        /// <p> The current status of the upgrade. The status can take one of the following values: </p>
        /// <ul>
        /// <li> <p>In Progress</p> </li>
        /// <li> <p>Succeeded</p> </li>
        /// <li> <p>Succeeded with Issues</p> </li>
        /// <li> <p>Failed</p> </li>
        /// </ul>
        pub fn set_upgrade_status(
            mut self,
            input: std::option::Option<crate::model::UpgradeStatus>,
        ) -> Self {
            self.upgrade_status = input;
            self
        }
        /// Appends an item to `steps_list`.
        ///
        /// To override the contents of this collection use [`set_steps_list`](Self::set_steps_list).
        ///
        /// <p>A list of each step performed as part of a specific upgrade or upgrade eligibility check.</p>
        pub fn steps_list(mut self, input: crate::model::UpgradeStepItem) -> Self {
            let mut v = self.steps_list.unwrap_or_default();
            v.push(input);
            self.steps_list = Some(v);
            self
        }
        /// <p>A list of each step performed as part of a specific upgrade or upgrade eligibility check.</p>
        pub fn set_steps_list(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::UpgradeStepItem>>,
        ) -> Self {
            self.steps_list = input;
            self
        }
        /// Consumes the builder and constructs a [`UpgradeHistory`](crate::model::UpgradeHistory).
        pub fn build(self) -> crate::model::UpgradeHistory {
            crate::model::UpgradeHistory {
                upgrade_name: self.upgrade_name,
                start_timestamp: self.start_timestamp,
                upgrade_status: self.upgrade_status,
                steps_list: self.steps_list,
            }
        }
    }
}
impl UpgradeHistory {
    /// Creates a new builder-style object to manufacture [`UpgradeHistory`](crate::model::UpgradeHistory).
    pub fn builder() -> crate::model::upgrade_history::Builder {
        crate::model::upgrade_history::Builder::default()
    }
}

/// <p>Represents a single step of an upgrade or upgrade eligibility check workflow.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpgradeStepItem {
    /// <p> One of three steps that an upgrade or upgrade eligibility check goes through: </p>
    /// <ul>
    /// <li> <p>PreUpgradeCheck</p> </li>
    /// <li> <p>Snapshot</p> </li>
    /// <li> <p>Upgrade</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub upgrade_step: std::option::Option<crate::model::UpgradeStep>,
    /// <p> The current status of the upgrade. The status can take one of the following values: </p>
    /// <ul>
    /// <li> <p>In Progress</p> </li>
    /// <li> <p>Succeeded</p> </li>
    /// <li> <p>Succeeded with Issues</p> </li>
    /// <li> <p>Failed</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub upgrade_step_status: std::option::Option<crate::model::UpgradeStatus>,
    /// <p>A list of strings containing detailed information about the errors encountered in a particular step.</p>
    #[doc(hidden)]
    pub issues: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The floating point value representing the progress percentage of a particular step.</p>
    #[doc(hidden)]
    pub progress_percent: std::option::Option<f64>,
}
impl UpgradeStepItem {
    /// <p> One of three steps that an upgrade or upgrade eligibility check goes through: </p>
    /// <ul>
    /// <li> <p>PreUpgradeCheck</p> </li>
    /// <li> <p>Snapshot</p> </li>
    /// <li> <p>Upgrade</p> </li>
    /// </ul>
    pub fn upgrade_step(&self) -> std::option::Option<&crate::model::UpgradeStep> {
        self.upgrade_step.as_ref()
    }
    /// <p> The current status of the upgrade. The status can take one of the following values: </p>
    /// <ul>
    /// <li> <p>In Progress</p> </li>
    /// <li> <p>Succeeded</p> </li>
    /// <li> <p>Succeeded with Issues</p> </li>
    /// <li> <p>Failed</p> </li>
    /// </ul>
    pub fn upgrade_step_status(&self) -> std::option::Option<&crate::model::UpgradeStatus> {
        self.upgrade_step_status.as_ref()
    }
    /// <p>A list of strings containing detailed information about the errors encountered in a particular step.</p>
    pub fn issues(&self) -> std::option::Option<&[std::string::String]> {
        self.issues.as_deref()
    }
    /// <p>The floating point value representing the progress percentage of a particular step.</p>
    pub fn progress_percent(&self) -> std::option::Option<f64> {
        self.progress_percent
    }
}
/// See [`UpgradeStepItem`](crate::model::UpgradeStepItem).
pub mod upgrade_step_item {

    /// A builder for [`UpgradeStepItem`](crate::model::UpgradeStepItem).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) upgrade_step: std::option::Option<crate::model::UpgradeStep>,
        pub(crate) upgrade_step_status: std::option::Option<crate::model::UpgradeStatus>,
        pub(crate) issues: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) progress_percent: std::option::Option<f64>,
    }
    impl Builder {
        /// <p> One of three steps that an upgrade or upgrade eligibility check goes through: </p>
        /// <ul>
        /// <li> <p>PreUpgradeCheck</p> </li>
        /// <li> <p>Snapshot</p> </li>
        /// <li> <p>Upgrade</p> </li>
        /// </ul>
        pub fn upgrade_step(mut self, input: crate::model::UpgradeStep) -> Self {
            self.upgrade_step = Some(input);
            self
        }
        /// <p> One of three steps that an upgrade or upgrade eligibility check goes through: </p>
        /// <ul>
        /// <li> <p>PreUpgradeCheck</p> </li>
        /// <li> <p>Snapshot</p> </li>
        /// <li> <p>Upgrade</p> </li>
        /// </ul>
        pub fn set_upgrade_step(
            mut self,
            input: std::option::Option<crate::model::UpgradeStep>,
        ) -> Self {
            self.upgrade_step = input;
            self
        }
        /// <p> The current status of the upgrade. The status can take one of the following values: </p>
        /// <ul>
        /// <li> <p>In Progress</p> </li>
        /// <li> <p>Succeeded</p> </li>
        /// <li> <p>Succeeded with Issues</p> </li>
        /// <li> <p>Failed</p> </li>
        /// </ul>
        pub fn upgrade_step_status(mut self, input: crate::model::UpgradeStatus) -> Self {
            self.upgrade_step_status = Some(input);
            self
        }
        /// <p> The current status of the upgrade. The status can take one of the following values: </p>
        /// <ul>
        /// <li> <p>In Progress</p> </li>
        /// <li> <p>Succeeded</p> </li>
        /// <li> <p>Succeeded with Issues</p> </li>
        /// <li> <p>Failed</p> </li>
        /// </ul>
        pub fn set_upgrade_step_status(
            mut self,
            input: std::option::Option<crate::model::UpgradeStatus>,
        ) -> Self {
            self.upgrade_step_status = input;
            self
        }
        /// Appends an item to `issues`.
        ///
        /// To override the contents of this collection use [`set_issues`](Self::set_issues).
        ///
        /// <p>A list of strings containing detailed information about the errors encountered in a particular step.</p>
        pub fn issues(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.issues.unwrap_or_default();
            v.push(input.into());
            self.issues = Some(v);
            self
        }
        /// <p>A list of strings containing detailed information about the errors encountered in a particular step.</p>
        pub fn set_issues(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.issues = input;
            self
        }
        /// <p>The floating point value representing the progress percentage of a particular step.</p>
        pub fn progress_percent(mut self, input: f64) -> Self {
            self.progress_percent = Some(input);
            self
        }
        /// <p>The floating point value representing the progress percentage of a particular step.</p>
        pub fn set_progress_percent(mut self, input: std::option::Option<f64>) -> Self {
            self.progress_percent = input;
            self
        }
        /// Consumes the builder and constructs a [`UpgradeStepItem`](crate::model::UpgradeStepItem).
        pub fn build(self) -> crate::model::UpgradeStepItem {
            crate::model::UpgradeStepItem {
                upgrade_step: self.upgrade_step,
                upgrade_step_status: self.upgrade_step_status,
                issues: self.issues,
                progress_percent: self.progress_percent,
            }
        }
    }
}
impl UpgradeStepItem {
    /// Creates a new builder-style object to manufacture [`UpgradeStepItem`](crate::model::UpgradeStepItem).
    pub fn builder() -> crate::model::upgrade_step_item::Builder {
        crate::model::upgrade_step_item::Builder::default()
    }
}

/// <p>Details about a package version.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PackageVersionHistory {
    /// <p>The package version.</p>
    #[doc(hidden)]
    pub package_version: std::option::Option<std::string::String>,
    /// <p>A message associated with the package version when it was uploaded.</p>
    #[doc(hidden)]
    pub commit_message: std::option::Option<std::string::String>,
    /// <p>The date and time when the package was created.</p>
    #[doc(hidden)]
    pub created_at: std::option::Option<aws_smithy_types::DateTime>,
}
impl PackageVersionHistory {
    /// <p>The package version.</p>
    pub fn package_version(&self) -> std::option::Option<&str> {
        self.package_version.as_deref()
    }
    /// <p>A message associated with the package version when it was uploaded.</p>
    pub fn commit_message(&self) -> std::option::Option<&str> {
        self.commit_message.as_deref()
    }
    /// <p>The date and time when the package was created.</p>
    pub fn created_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_at.as_ref()
    }
}
/// See [`PackageVersionHistory`](crate::model::PackageVersionHistory).
pub mod package_version_history {

    /// A builder for [`PackageVersionHistory`](crate::model::PackageVersionHistory).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) package_version: std::option::Option<std::string::String>,
        pub(crate) commit_message: std::option::Option<std::string::String>,
        pub(crate) created_at: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The package version.</p>
        pub fn package_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.package_version = Some(input.into());
            self
        }
        /// <p>The package version.</p>
        pub fn set_package_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.package_version = input;
            self
        }
        /// <p>A message associated with the package version when it was uploaded.</p>
        pub fn commit_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.commit_message = Some(input.into());
            self
        }
        /// <p>A message associated with the package version when it was uploaded.</p>
        pub fn set_commit_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.commit_message = input;
            self
        }
        /// <p>The date and time when the package was created.</p>
        pub fn created_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_at = Some(input);
            self
        }
        /// <p>The date and time when the package was created.</p>
        pub fn set_created_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_at = input;
            self
        }
        /// Consumes the builder and constructs a [`PackageVersionHistory`](crate::model::PackageVersionHistory).
        pub fn build(self) -> crate::model::PackageVersionHistory {
            crate::model::PackageVersionHistory {
                package_version: self.package_version,
                commit_message: self.commit_message,
                created_at: self.created_at,
            }
        }
    }
}
impl PackageVersionHistory {
    /// Creates a new builder-style object to manufacture [`PackageVersionHistory`](crate::model::PackageVersionHistory).
    pub fn builder() -> crate::model::package_version_history::Builder {
        crate::model::package_version_history::Builder::default()
    }
}

/// <p>A map of OpenSearch or Elasticsearch versions and the versions you can upgrade them to.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CompatibleVersionsMap {
    /// <p>The current version that the OpenSearch Service domain is running.</p>
    #[doc(hidden)]
    pub source_version: std::option::Option<std::string::String>,
    /// <p>The possible versions that you can upgrade the domain to.</p>
    #[doc(hidden)]
    pub target_versions: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl CompatibleVersionsMap {
    /// <p>The current version that the OpenSearch Service domain is running.</p>
    pub fn source_version(&self) -> std::option::Option<&str> {
        self.source_version.as_deref()
    }
    /// <p>The possible versions that you can upgrade the domain to.</p>
    pub fn target_versions(&self) -> std::option::Option<&[std::string::String]> {
        self.target_versions.as_deref()
    }
}
/// See [`CompatibleVersionsMap`](crate::model::CompatibleVersionsMap).
pub mod compatible_versions_map {

    /// A builder for [`CompatibleVersionsMap`](crate::model::CompatibleVersionsMap).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) source_version: std::option::Option<std::string::String>,
        pub(crate) target_versions: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The current version that the OpenSearch Service domain is running.</p>
        pub fn source_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_version = Some(input.into());
            self
        }
        /// <p>The current version that the OpenSearch Service domain is running.</p>
        pub fn set_source_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.source_version = input;
            self
        }
        /// Appends an item to `target_versions`.
        ///
        /// To override the contents of this collection use [`set_target_versions`](Self::set_target_versions).
        ///
        /// <p>The possible versions that you can upgrade the domain to.</p>
        pub fn target_versions(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.target_versions.unwrap_or_default();
            v.push(input.into());
            self.target_versions = Some(v);
            self
        }
        /// <p>The possible versions that you can upgrade the domain to.</p>
        pub fn set_target_versions(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.target_versions = input;
            self
        }
        /// Consumes the builder and constructs a [`CompatibleVersionsMap`](crate::model::CompatibleVersionsMap).
        pub fn build(self) -> crate::model::CompatibleVersionsMap {
            crate::model::CompatibleVersionsMap {
                source_version: self.source_version,
                target_versions: self.target_versions,
            }
        }
    }
}
impl CompatibleVersionsMap {
    /// Creates a new builder-style object to manufacture [`CompatibleVersionsMap`](crate::model::CompatibleVersionsMap).
    pub fn builder() -> crate::model::compatible_versions_map::Builder {
        crate::model::compatible_versions_map::Builder::default()
    }
}

/// <p>Error information when attempting to describe an Amazon OpenSearch Service-managed VPC endpoint.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct VpcEndpointError {
    /// <p>The unique identifier of the endpoint.</p>
    #[doc(hidden)]
    pub vpc_endpoint_id: std::option::Option<std::string::String>,
    /// <p>The code associated with the error.</p>
    #[doc(hidden)]
    pub error_code: std::option::Option<crate::model::VpcEndpointErrorCode>,
    /// <p>A message describing the error.</p>
    #[doc(hidden)]
    pub error_message: std::option::Option<std::string::String>,
}
impl VpcEndpointError {
    /// <p>The unique identifier of the endpoint.</p>
    pub fn vpc_endpoint_id(&self) -> std::option::Option<&str> {
        self.vpc_endpoint_id.as_deref()
    }
    /// <p>The code associated with the error.</p>
    pub fn error_code(&self) -> std::option::Option<&crate::model::VpcEndpointErrorCode> {
        self.error_code.as_ref()
    }
    /// <p>A message describing the error.</p>
    pub fn error_message(&self) -> std::option::Option<&str> {
        self.error_message.as_deref()
    }
}
/// See [`VpcEndpointError`](crate::model::VpcEndpointError).
pub mod vpc_endpoint_error {

    /// A builder for [`VpcEndpointError`](crate::model::VpcEndpointError).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) vpc_endpoint_id: std::option::Option<std::string::String>,
        pub(crate) error_code: std::option::Option<crate::model::VpcEndpointErrorCode>,
        pub(crate) error_message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique identifier of the endpoint.</p>
        pub fn vpc_endpoint_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.vpc_endpoint_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of the endpoint.</p>
        pub fn set_vpc_endpoint_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.vpc_endpoint_id = input;
            self
        }
        /// <p>The code associated with the error.</p>
        pub fn error_code(mut self, input: crate::model::VpcEndpointErrorCode) -> Self {
            self.error_code = Some(input);
            self
        }
        /// <p>The code associated with the error.</p>
        pub fn set_error_code(
            mut self,
            input: std::option::Option<crate::model::VpcEndpointErrorCode>,
        ) -> Self {
            self.error_code = input;
            self
        }
        /// <p>A message describing the error.</p>
        pub fn error_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_message = Some(input.into());
            self
        }
        /// <p>A message describing the error.</p>
        pub fn set_error_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.error_message = input;
            self
        }
        /// Consumes the builder and constructs a [`VpcEndpointError`](crate::model::VpcEndpointError).
        pub fn build(self) -> crate::model::VpcEndpointError {
            crate::model::VpcEndpointError {
                vpc_endpoint_id: self.vpc_endpoint_id,
                error_code: self.error_code,
                error_message: self.error_message,
            }
        }
    }
}
impl VpcEndpointError {
    /// Creates a new builder-style object to manufacture [`VpcEndpointError`](crate::model::VpcEndpointError).
    pub fn builder() -> crate::model::vpc_endpoint_error::Builder {
        crate::model::vpc_endpoint_error::Builder::default()
    }
}

/// When writing a match expression against `VpcEndpointErrorCode`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let vpcendpointerrorcode = unimplemented!();
/// match vpcendpointerrorcode {
///     VpcEndpointErrorCode::EndpointNotFound => { /* ... */ },
///     VpcEndpointErrorCode::ServerError => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `vpcendpointerrorcode` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `VpcEndpointErrorCode::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `VpcEndpointErrorCode::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `VpcEndpointErrorCode::NewFeature` is defined.
/// Specifically, when `vpcendpointerrorcode` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `VpcEndpointErrorCode::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum VpcEndpointErrorCode {
    #[allow(missing_docs)] // documentation missing in model
    EndpointNotFound,
    #[allow(missing_docs)] // documentation missing in model
    ServerError,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for VpcEndpointErrorCode {
    fn from(s: &str) -> Self {
        match s {
            "ENDPOINT_NOT_FOUND" => VpcEndpointErrorCode::EndpointNotFound,
            "SERVER_ERROR" => VpcEndpointErrorCode::ServerError,
            other => {
                VpcEndpointErrorCode::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for VpcEndpointErrorCode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(VpcEndpointErrorCode::from(s))
    }
}
impl VpcEndpointErrorCode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            VpcEndpointErrorCode::EndpointNotFound => "ENDPOINT_NOT_FOUND",
            VpcEndpointErrorCode::ServerError => "SERVER_ERROR",
            VpcEndpointErrorCode::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ENDPOINT_NOT_FOUND", "SERVER_ERROR"]
    }
}
impl AsRef<str> for VpcEndpointErrorCode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Details of an OpenSearch Reserved Instance.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ReservedInstance {
    /// <p>The customer-specified identifier to track this reservation.</p>
    #[doc(hidden)]
    pub reservation_name: std::option::Option<std::string::String>,
    /// <p>The unique identifier for the reservation.</p>
    #[doc(hidden)]
    pub reserved_instance_id: std::option::Option<std::string::String>,
    /// <p>The unique identifier of the billing subscription.</p>
    #[doc(hidden)]
    pub billing_subscription_id: std::option::Option<i64>,
    /// <p>The unique identifier of the Reserved Instance offering.</p>
    #[doc(hidden)]
    pub reserved_instance_offering_id: std::option::Option<std::string::String>,
    /// <p>The OpenSearch instance type offered by theReserved Instance offering.</p>
    #[doc(hidden)]
    pub instance_type: std::option::Option<crate::model::OpenSearchPartitionInstanceType>,
    /// <p>The date and time when the reservation was purchased.</p>
    #[doc(hidden)]
    pub start_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The duration, in seconds, for which the OpenSearch instance is reserved.</p>
    #[doc(hidden)]
    pub duration: i32,
    /// <p>The upfront fixed charge you will paid to purchase the specific Reserved Instance offering.</p>
    #[doc(hidden)]
    pub fixed_price: std::option::Option<f64>,
    /// <p>The hourly rate at which you're charged for the domain using this Reserved Instance.</p>
    #[doc(hidden)]
    pub usage_price: std::option::Option<f64>,
    /// <p>The currency code for the offering.</p>
    #[doc(hidden)]
    pub currency_code: std::option::Option<std::string::String>,
    /// <p>The number of OpenSearch instances that have been reserved.</p>
    #[doc(hidden)]
    pub instance_count: i32,
    /// <p>The state of the Reserved Instance.</p>
    #[doc(hidden)]
    pub state: std::option::Option<std::string::String>,
    /// <p>The payment option as defined in the Reserved Instance offering.</p>
    #[doc(hidden)]
    pub payment_option: std::option::Option<crate::model::ReservedInstancePaymentOption>,
    /// <p>The recurring charge to your account, regardless of whether you create any domains using the Reserved Instance offering.</p>
    #[doc(hidden)]
    pub recurring_charges: std::option::Option<std::vec::Vec<crate::model::RecurringCharge>>,
}
impl ReservedInstance {
    /// <p>The customer-specified identifier to track this reservation.</p>
    pub fn reservation_name(&self) -> std::option::Option<&str> {
        self.reservation_name.as_deref()
    }
    /// <p>The unique identifier for the reservation.</p>
    pub fn reserved_instance_id(&self) -> std::option::Option<&str> {
        self.reserved_instance_id.as_deref()
    }
    /// <p>The unique identifier of the billing subscription.</p>
    pub fn billing_subscription_id(&self) -> std::option::Option<i64> {
        self.billing_subscription_id
    }
    /// <p>The unique identifier of the Reserved Instance offering.</p>
    pub fn reserved_instance_offering_id(&self) -> std::option::Option<&str> {
        self.reserved_instance_offering_id.as_deref()
    }
    /// <p>The OpenSearch instance type offered by theReserved Instance offering.</p>
    pub fn instance_type(
        &self,
    ) -> std::option::Option<&crate::model::OpenSearchPartitionInstanceType> {
        self.instance_type.as_ref()
    }
    /// <p>The date and time when the reservation was purchased.</p>
    pub fn start_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.start_time.as_ref()
    }
    /// <p>The duration, in seconds, for which the OpenSearch instance is reserved.</p>
    pub fn duration(&self) -> i32 {
        self.duration
    }
    /// <p>The upfront fixed charge you will paid to purchase the specific Reserved Instance offering.</p>
    pub fn fixed_price(&self) -> std::option::Option<f64> {
        self.fixed_price
    }
    /// <p>The hourly rate at which you're charged for the domain using this Reserved Instance.</p>
    pub fn usage_price(&self) -> std::option::Option<f64> {
        self.usage_price
    }
    /// <p>The currency code for the offering.</p>
    pub fn currency_code(&self) -> std::option::Option<&str> {
        self.currency_code.as_deref()
    }
    /// <p>The number of OpenSearch instances that have been reserved.</p>
    pub fn instance_count(&self) -> i32 {
        self.instance_count
    }
    /// <p>The state of the Reserved Instance.</p>
    pub fn state(&self) -> std::option::Option<&str> {
        self.state.as_deref()
    }
    /// <p>The payment option as defined in the Reserved Instance offering.</p>
    pub fn payment_option(
        &self,
    ) -> std::option::Option<&crate::model::ReservedInstancePaymentOption> {
        self.payment_option.as_ref()
    }
    /// <p>The recurring charge to your account, regardless of whether you create any domains using the Reserved Instance offering.</p>
    pub fn recurring_charges(&self) -> std::option::Option<&[crate::model::RecurringCharge]> {
        self.recurring_charges.as_deref()
    }
}
/// See [`ReservedInstance`](crate::model::ReservedInstance).
pub mod reserved_instance {

    /// A builder for [`ReservedInstance`](crate::model::ReservedInstance).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) reservation_name: std::option::Option<std::string::String>,
        pub(crate) reserved_instance_id: std::option::Option<std::string::String>,
        pub(crate) billing_subscription_id: std::option::Option<i64>,
        pub(crate) reserved_instance_offering_id: std::option::Option<std::string::String>,
        pub(crate) instance_type:
            std::option::Option<crate::model::OpenSearchPartitionInstanceType>,
        pub(crate) start_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) duration: std::option::Option<i32>,
        pub(crate) fixed_price: std::option::Option<f64>,
        pub(crate) usage_price: std::option::Option<f64>,
        pub(crate) currency_code: std::option::Option<std::string::String>,
        pub(crate) instance_count: std::option::Option<i32>,
        pub(crate) state: std::option::Option<std::string::String>,
        pub(crate) payment_option: std::option::Option<crate::model::ReservedInstancePaymentOption>,
        pub(crate) recurring_charges:
            std::option::Option<std::vec::Vec<crate::model::RecurringCharge>>,
    }
    impl Builder {
        /// <p>The customer-specified identifier to track this reservation.</p>
        pub fn reservation_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.reservation_name = Some(input.into());
            self
        }
        /// <p>The customer-specified identifier to track this reservation.</p>
        pub fn set_reservation_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.reservation_name = input;
            self
        }
        /// <p>The unique identifier for the reservation.</p>
        pub fn reserved_instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.reserved_instance_id = Some(input.into());
            self
        }
        /// <p>The unique identifier for the reservation.</p>
        pub fn set_reserved_instance_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.reserved_instance_id = input;
            self
        }
        /// <p>The unique identifier of the billing subscription.</p>
        pub fn billing_subscription_id(mut self, input: i64) -> Self {
            self.billing_subscription_id = Some(input);
            self
        }
        /// <p>The unique identifier of the billing subscription.</p>
        pub fn set_billing_subscription_id(mut self, input: std::option::Option<i64>) -> Self {
            self.billing_subscription_id = input;
            self
        }
        /// <p>The unique identifier of the Reserved Instance offering.</p>
        pub fn reserved_instance_offering_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.reserved_instance_offering_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of the Reserved Instance offering.</p>
        pub fn set_reserved_instance_offering_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.reserved_instance_offering_id = input;
            self
        }
        /// <p>The OpenSearch instance type offered by theReserved Instance offering.</p>
        pub fn instance_type(
            mut self,
            input: crate::model::OpenSearchPartitionInstanceType,
        ) -> Self {
            self.instance_type = Some(input);
            self
        }
        /// <p>The OpenSearch instance type offered by theReserved Instance offering.</p>
        pub fn set_instance_type(
            mut self,
            input: std::option::Option<crate::model::OpenSearchPartitionInstanceType>,
        ) -> Self {
            self.instance_type = input;
            self
        }
        /// <p>The date and time when the reservation was purchased.</p>
        pub fn start_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.start_time = Some(input);
            self
        }
        /// <p>The date and time when the reservation was purchased.</p>
        pub fn set_start_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.start_time = input;
            self
        }
        /// <p>The duration, in seconds, for which the OpenSearch instance is reserved.</p>
        pub fn duration(mut self, input: i32) -> Self {
            self.duration = Some(input);
            self
        }
        /// <p>The duration, in seconds, for which the OpenSearch instance is reserved.</p>
        pub fn set_duration(mut self, input: std::option::Option<i32>) -> Self {
            self.duration = input;
            self
        }
        /// <p>The upfront fixed charge you will paid to purchase the specific Reserved Instance offering.</p>
        pub fn fixed_price(mut self, input: f64) -> Self {
            self.fixed_price = Some(input);
            self
        }
        /// <p>The upfront fixed charge you will paid to purchase the specific Reserved Instance offering.</p>
        pub fn set_fixed_price(mut self, input: std::option::Option<f64>) -> Self {
            self.fixed_price = input;
            self
        }
        /// <p>The hourly rate at which you're charged for the domain using this Reserved Instance.</p>
        pub fn usage_price(mut self, input: f64) -> Self {
            self.usage_price = Some(input);
            self
        }
        /// <p>The hourly rate at which you're charged for the domain using this Reserved Instance.</p>
        pub fn set_usage_price(mut self, input: std::option::Option<f64>) -> Self {
            self.usage_price = input;
            self
        }
        /// <p>The currency code for the offering.</p>
        pub fn currency_code(mut self, input: impl Into<std::string::String>) -> Self {
            self.currency_code = Some(input.into());
            self
        }
        /// <p>The currency code for the offering.</p>
        pub fn set_currency_code(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.currency_code = input;
            self
        }
        /// <p>The number of OpenSearch instances that have been reserved.</p>
        pub fn instance_count(mut self, input: i32) -> Self {
            self.instance_count = Some(input);
            self
        }
        /// <p>The number of OpenSearch instances that have been reserved.</p>
        pub fn set_instance_count(mut self, input: std::option::Option<i32>) -> Self {
            self.instance_count = input;
            self
        }
        /// <p>The state of the Reserved Instance.</p>
        pub fn state(mut self, input: impl Into<std::string::String>) -> Self {
            self.state = Some(input.into());
            self
        }
        /// <p>The state of the Reserved Instance.</p>
        pub fn set_state(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.state = input;
            self
        }
        /// <p>The payment option as defined in the Reserved Instance offering.</p>
        pub fn payment_option(
            mut self,
            input: crate::model::ReservedInstancePaymentOption,
        ) -> Self {
            self.payment_option = Some(input);
            self
        }
        /// <p>The payment option as defined in the Reserved Instance offering.</p>
        pub fn set_payment_option(
            mut self,
            input: std::option::Option<crate::model::ReservedInstancePaymentOption>,
        ) -> Self {
            self.payment_option = input;
            self
        }
        /// Appends an item to `recurring_charges`.
        ///
        /// To override the contents of this collection use [`set_recurring_charges`](Self::set_recurring_charges).
        ///
        /// <p>The recurring charge to your account, regardless of whether you create any domains using the Reserved Instance offering.</p>
        pub fn recurring_charges(mut self, input: crate::model::RecurringCharge) -> Self {
            let mut v = self.recurring_charges.unwrap_or_default();
            v.push(input);
            self.recurring_charges = Some(v);
            self
        }
        /// <p>The recurring charge to your account, regardless of whether you create any domains using the Reserved Instance offering.</p>
        pub fn set_recurring_charges(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::RecurringCharge>>,
        ) -> Self {
            self.recurring_charges = input;
            self
        }
        /// Consumes the builder and constructs a [`ReservedInstance`](crate::model::ReservedInstance).
        pub fn build(self) -> crate::model::ReservedInstance {
            crate::model::ReservedInstance {
                reservation_name: self.reservation_name,
                reserved_instance_id: self.reserved_instance_id,
                billing_subscription_id: self.billing_subscription_id,
                reserved_instance_offering_id: self.reserved_instance_offering_id,
                instance_type: self.instance_type,
                start_time: self.start_time,
                duration: self.duration.unwrap_or_default(),
                fixed_price: self.fixed_price,
                usage_price: self.usage_price,
                currency_code: self.currency_code,
                instance_count: self.instance_count.unwrap_or_default(),
                state: self.state,
                payment_option: self.payment_option,
                recurring_charges: self.recurring_charges,
            }
        }
    }
}
impl ReservedInstance {
    /// Creates a new builder-style object to manufacture [`ReservedInstance`](crate::model::ReservedInstance).
    pub fn builder() -> crate::model::reserved_instance::Builder {
        crate::model::reserved_instance::Builder::default()
    }
}

/// <p>Contains the specific price and frequency of a recurring charges for an OpenSearch Reserved Instance, or for a Reserved Instance offering.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RecurringCharge {
    /// <p>The monetary amount of the recurring charge.</p>
    #[doc(hidden)]
    pub recurring_charge_amount: std::option::Option<f64>,
    /// <p>The frequency of the recurring charge.</p>
    #[doc(hidden)]
    pub recurring_charge_frequency: std::option::Option<std::string::String>,
}
impl RecurringCharge {
    /// <p>The monetary amount of the recurring charge.</p>
    pub fn recurring_charge_amount(&self) -> std::option::Option<f64> {
        self.recurring_charge_amount
    }
    /// <p>The frequency of the recurring charge.</p>
    pub fn recurring_charge_frequency(&self) -> std::option::Option<&str> {
        self.recurring_charge_frequency.as_deref()
    }
}
/// See [`RecurringCharge`](crate::model::RecurringCharge).
pub mod recurring_charge {

    /// A builder for [`RecurringCharge`](crate::model::RecurringCharge).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) recurring_charge_amount: std::option::Option<f64>,
        pub(crate) recurring_charge_frequency: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The monetary amount of the recurring charge.</p>
        pub fn recurring_charge_amount(mut self, input: f64) -> Self {
            self.recurring_charge_amount = Some(input);
            self
        }
        /// <p>The monetary amount of the recurring charge.</p>
        pub fn set_recurring_charge_amount(mut self, input: std::option::Option<f64>) -> Self {
            self.recurring_charge_amount = input;
            self
        }
        /// <p>The frequency of the recurring charge.</p>
        pub fn recurring_charge_frequency(mut self, input: impl Into<std::string::String>) -> Self {
            self.recurring_charge_frequency = Some(input.into());
            self
        }
        /// <p>The frequency of the recurring charge.</p>
        pub fn set_recurring_charge_frequency(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.recurring_charge_frequency = input;
            self
        }
        /// Consumes the builder and constructs a [`RecurringCharge`](crate::model::RecurringCharge).
        pub fn build(self) -> crate::model::RecurringCharge {
            crate::model::RecurringCharge {
                recurring_charge_amount: self.recurring_charge_amount,
                recurring_charge_frequency: self.recurring_charge_frequency,
            }
        }
    }
}
impl RecurringCharge {
    /// Creates a new builder-style object to manufacture [`RecurringCharge`](crate::model::RecurringCharge).
    pub fn builder() -> crate::model::recurring_charge::Builder {
        crate::model::recurring_charge::Builder::default()
    }
}

/// When writing a match expression against `ReservedInstancePaymentOption`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let reservedinstancepaymentoption = unimplemented!();
/// match reservedinstancepaymentoption {
///     ReservedInstancePaymentOption::AllUpfront => { /* ... */ },
///     ReservedInstancePaymentOption::NoUpfront => { /* ... */ },
///     ReservedInstancePaymentOption::PartialUpfront => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `reservedinstancepaymentoption` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ReservedInstancePaymentOption::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ReservedInstancePaymentOption::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ReservedInstancePaymentOption::NewFeature` is defined.
/// Specifically, when `reservedinstancepaymentoption` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ReservedInstancePaymentOption::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ReservedInstancePaymentOption {
    #[allow(missing_docs)] // documentation missing in model
    AllUpfront,
    #[allow(missing_docs)] // documentation missing in model
    NoUpfront,
    #[allow(missing_docs)] // documentation missing in model
    PartialUpfront,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ReservedInstancePaymentOption {
    fn from(s: &str) -> Self {
        match s {
            "ALL_UPFRONT" => ReservedInstancePaymentOption::AllUpfront,
            "NO_UPFRONT" => ReservedInstancePaymentOption::NoUpfront,
            "PARTIAL_UPFRONT" => ReservedInstancePaymentOption::PartialUpfront,
            other => ReservedInstancePaymentOption::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for ReservedInstancePaymentOption {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ReservedInstancePaymentOption::from(s))
    }
}
impl ReservedInstancePaymentOption {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ReservedInstancePaymentOption::AllUpfront => "ALL_UPFRONT",
            ReservedInstancePaymentOption::NoUpfront => "NO_UPFRONT",
            ReservedInstancePaymentOption::PartialUpfront => "PARTIAL_UPFRONT",
            ReservedInstancePaymentOption::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ALL_UPFRONT", "NO_UPFRONT", "PARTIAL_UPFRONT"]
    }
}
impl AsRef<str> for ReservedInstancePaymentOption {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Details of an OpenSearch Reserved Instance offering.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ReservedInstanceOffering {
    /// <p>The unique identifier of the Reserved Instance offering.</p>
    #[doc(hidden)]
    pub reserved_instance_offering_id: std::option::Option<std::string::String>,
    /// <p>The OpenSearch instance type offered by the Reserved Instance offering.</p>
    #[doc(hidden)]
    pub instance_type: std::option::Option<crate::model::OpenSearchPartitionInstanceType>,
    /// <p>The duration, in seconds, for which the offering will reserve the OpenSearch instance.</p>
    #[doc(hidden)]
    pub duration: i32,
    /// <p>The upfront fixed charge you will pay to purchase the specific Reserved Instance offering.</p>
    #[doc(hidden)]
    pub fixed_price: std::option::Option<f64>,
    /// <p>The hourly rate at which you're charged for the domain using this Reserved Instance.</p>
    #[doc(hidden)]
    pub usage_price: std::option::Option<f64>,
    /// <p>The currency code for the Reserved Instance offering.</p>
    #[doc(hidden)]
    pub currency_code: std::option::Option<std::string::String>,
    /// <p>Payment option for the Reserved Instance offering</p>
    #[doc(hidden)]
    pub payment_option: std::option::Option<crate::model::ReservedInstancePaymentOption>,
    /// <p>The recurring charge to your account, regardless of whether you creates any domains using the offering.</p>
    #[doc(hidden)]
    pub recurring_charges: std::option::Option<std::vec::Vec<crate::model::RecurringCharge>>,
}
impl ReservedInstanceOffering {
    /// <p>The unique identifier of the Reserved Instance offering.</p>
    pub fn reserved_instance_offering_id(&self) -> std::option::Option<&str> {
        self.reserved_instance_offering_id.as_deref()
    }
    /// <p>The OpenSearch instance type offered by the Reserved Instance offering.</p>
    pub fn instance_type(
        &self,
    ) -> std::option::Option<&crate::model::OpenSearchPartitionInstanceType> {
        self.instance_type.as_ref()
    }
    /// <p>The duration, in seconds, for which the offering will reserve the OpenSearch instance.</p>
    pub fn duration(&self) -> i32 {
        self.duration
    }
    /// <p>The upfront fixed charge you will pay to purchase the specific Reserved Instance offering.</p>
    pub fn fixed_price(&self) -> std::option::Option<f64> {
        self.fixed_price
    }
    /// <p>The hourly rate at which you're charged for the domain using this Reserved Instance.</p>
    pub fn usage_price(&self) -> std::option::Option<f64> {
        self.usage_price
    }
    /// <p>The currency code for the Reserved Instance offering.</p>
    pub fn currency_code(&self) -> std::option::Option<&str> {
        self.currency_code.as_deref()
    }
    /// <p>Payment option for the Reserved Instance offering</p>
    pub fn payment_option(
        &self,
    ) -> std::option::Option<&crate::model::ReservedInstancePaymentOption> {
        self.payment_option.as_ref()
    }
    /// <p>The recurring charge to your account, regardless of whether you creates any domains using the offering.</p>
    pub fn recurring_charges(&self) -> std::option::Option<&[crate::model::RecurringCharge]> {
        self.recurring_charges.as_deref()
    }
}
/// See [`ReservedInstanceOffering`](crate::model::ReservedInstanceOffering).
pub mod reserved_instance_offering {

    /// A builder for [`ReservedInstanceOffering`](crate::model::ReservedInstanceOffering).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) reserved_instance_offering_id: std::option::Option<std::string::String>,
        pub(crate) instance_type:
            std::option::Option<crate::model::OpenSearchPartitionInstanceType>,
        pub(crate) duration: std::option::Option<i32>,
        pub(crate) fixed_price: std::option::Option<f64>,
        pub(crate) usage_price: std::option::Option<f64>,
        pub(crate) currency_code: std::option::Option<std::string::String>,
        pub(crate) payment_option: std::option::Option<crate::model::ReservedInstancePaymentOption>,
        pub(crate) recurring_charges:
            std::option::Option<std::vec::Vec<crate::model::RecurringCharge>>,
    }
    impl Builder {
        /// <p>The unique identifier of the Reserved Instance offering.</p>
        pub fn reserved_instance_offering_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.reserved_instance_offering_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of the Reserved Instance offering.</p>
        pub fn set_reserved_instance_offering_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.reserved_instance_offering_id = input;
            self
        }
        /// <p>The OpenSearch instance type offered by the Reserved Instance offering.</p>
        pub fn instance_type(
            mut self,
            input: crate::model::OpenSearchPartitionInstanceType,
        ) -> Self {
            self.instance_type = Some(input);
            self
        }
        /// <p>The OpenSearch instance type offered by the Reserved Instance offering.</p>
        pub fn set_instance_type(
            mut self,
            input: std::option::Option<crate::model::OpenSearchPartitionInstanceType>,
        ) -> Self {
            self.instance_type = input;
            self
        }
        /// <p>The duration, in seconds, for which the offering will reserve the OpenSearch instance.</p>
        pub fn duration(mut self, input: i32) -> Self {
            self.duration = Some(input);
            self
        }
        /// <p>The duration, in seconds, for which the offering will reserve the OpenSearch instance.</p>
        pub fn set_duration(mut self, input: std::option::Option<i32>) -> Self {
            self.duration = input;
            self
        }
        /// <p>The upfront fixed charge you will pay to purchase the specific Reserved Instance offering.</p>
        pub fn fixed_price(mut self, input: f64) -> Self {
            self.fixed_price = Some(input);
            self
        }
        /// <p>The upfront fixed charge you will pay to purchase the specific Reserved Instance offering.</p>
        pub fn set_fixed_price(mut self, input: std::option::Option<f64>) -> Self {
            self.fixed_price = input;
            self
        }
        /// <p>The hourly rate at which you're charged for the domain using this Reserved Instance.</p>
        pub fn usage_price(mut self, input: f64) -> Self {
            self.usage_price = Some(input);
            self
        }
        /// <p>The hourly rate at which you're charged for the domain using this Reserved Instance.</p>
        pub fn set_usage_price(mut self, input: std::option::Option<f64>) -> Self {
            self.usage_price = input;
            self
        }
        /// <p>The currency code for the Reserved Instance offering.</p>
        pub fn currency_code(mut self, input: impl Into<std::string::String>) -> Self {
            self.currency_code = Some(input.into());
            self
        }
        /// <p>The currency code for the Reserved Instance offering.</p>
        pub fn set_currency_code(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.currency_code = input;
            self
        }
        /// <p>Payment option for the Reserved Instance offering</p>
        pub fn payment_option(
            mut self,
            input: crate::model::ReservedInstancePaymentOption,
        ) -> Self {
            self.payment_option = Some(input);
            self
        }
        /// <p>Payment option for the Reserved Instance offering</p>
        pub fn set_payment_option(
            mut self,
            input: std::option::Option<crate::model::ReservedInstancePaymentOption>,
        ) -> Self {
            self.payment_option = input;
            self
        }
        /// Appends an item to `recurring_charges`.
        ///
        /// To override the contents of this collection use [`set_recurring_charges`](Self::set_recurring_charges).
        ///
        /// <p>The recurring charge to your account, regardless of whether you creates any domains using the offering.</p>
        pub fn recurring_charges(mut self, input: crate::model::RecurringCharge) -> Self {
            let mut v = self.recurring_charges.unwrap_or_default();
            v.push(input);
            self.recurring_charges = Some(v);
            self
        }
        /// <p>The recurring charge to your account, regardless of whether you creates any domains using the offering.</p>
        pub fn set_recurring_charges(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::RecurringCharge>>,
        ) -> Self {
            self.recurring_charges = input;
            self
        }
        /// Consumes the builder and constructs a [`ReservedInstanceOffering`](crate::model::ReservedInstanceOffering).
        pub fn build(self) -> crate::model::ReservedInstanceOffering {
            crate::model::ReservedInstanceOffering {
                reserved_instance_offering_id: self.reserved_instance_offering_id,
                instance_type: self.instance_type,
                duration: self.duration.unwrap_or_default(),
                fixed_price: self.fixed_price,
                usage_price: self.usage_price,
                currency_code: self.currency_code,
                payment_option: self.payment_option,
                recurring_charges: self.recurring_charges,
            }
        }
    }
}
impl ReservedInstanceOffering {
    /// Creates a new builder-style object to manufacture [`ReservedInstanceOffering`](crate::model::ReservedInstanceOffering).
    pub fn builder() -> crate::model::reserved_instance_offering::Builder {
        crate::model::reserved_instance_offering::Builder::default()
    }
}

/// <p>A filter to apply to the <code>DescribePackage</code> response.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DescribePackagesFilter {
    /// <p>Any field from <code>PackageDetails</code>.</p>
    #[doc(hidden)]
    pub name: std::option::Option<crate::model::DescribePackagesFilterName>,
    /// <p>A list of values for the specified filter field.</p>
    #[doc(hidden)]
    pub value: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl DescribePackagesFilter {
    /// <p>Any field from <code>PackageDetails</code>.</p>
    pub fn name(&self) -> std::option::Option<&crate::model::DescribePackagesFilterName> {
        self.name.as_ref()
    }
    /// <p>A list of values for the specified filter field.</p>
    pub fn value(&self) -> std::option::Option<&[std::string::String]> {
        self.value.as_deref()
    }
}
/// See [`DescribePackagesFilter`](crate::model::DescribePackagesFilter).
pub mod describe_packages_filter {

    /// A builder for [`DescribePackagesFilter`](crate::model::DescribePackagesFilter).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<crate::model::DescribePackagesFilterName>,
        pub(crate) value: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>Any field from <code>PackageDetails</code>.</p>
        pub fn name(mut self, input: crate::model::DescribePackagesFilterName) -> Self {
            self.name = Some(input);
            self
        }
        /// <p>Any field from <code>PackageDetails</code>.</p>
        pub fn set_name(
            mut self,
            input: std::option::Option<crate::model::DescribePackagesFilterName>,
        ) -> Self {
            self.name = input;
            self
        }
        /// Appends an item to `value`.
        ///
        /// To override the contents of this collection use [`set_value`](Self::set_value).
        ///
        /// <p>A list of values for the specified filter field.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.value.unwrap_or_default();
            v.push(input.into());
            self.value = Some(v);
            self
        }
        /// <p>A list of values for the specified filter field.</p>
        pub fn set_value(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribePackagesFilter`](crate::model::DescribePackagesFilter).
        pub fn build(self) -> crate::model::DescribePackagesFilter {
            crate::model::DescribePackagesFilter {
                name: self.name,
                value: self.value,
            }
        }
    }
}
impl DescribePackagesFilter {
    /// Creates a new builder-style object to manufacture [`DescribePackagesFilter`](crate::model::DescribePackagesFilter).
    pub fn builder() -> crate::model::describe_packages_filter::Builder {
        crate::model::describe_packages_filter::Builder::default()
    }
}

/// When writing a match expression against `DescribePackagesFilterName`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let describepackagesfiltername = unimplemented!();
/// match describepackagesfiltername {
///     DescribePackagesFilterName::PackageId => { /* ... */ },
///     DescribePackagesFilterName::PackageName => { /* ... */ },
///     DescribePackagesFilterName::PackageStatus => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `describepackagesfiltername` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `DescribePackagesFilterName::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `DescribePackagesFilterName::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `DescribePackagesFilterName::NewFeature` is defined.
/// Specifically, when `describepackagesfiltername` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `DescribePackagesFilterName::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DescribePackagesFilterName {
    #[allow(missing_docs)] // documentation missing in model
    PackageId,
    #[allow(missing_docs)] // documentation missing in model
    PackageName,
    #[allow(missing_docs)] // documentation missing in model
    PackageStatus,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for DescribePackagesFilterName {
    fn from(s: &str) -> Self {
        match s {
            "PackageID" => DescribePackagesFilterName::PackageId,
            "PackageName" => DescribePackagesFilterName::PackageName,
            "PackageStatus" => DescribePackagesFilterName::PackageStatus,
            other => DescribePackagesFilterName::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for DescribePackagesFilterName {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DescribePackagesFilterName::from(s))
    }
}
impl DescribePackagesFilterName {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            DescribePackagesFilterName::PackageId => "PackageID",
            DescribePackagesFilterName::PackageName => "PackageName",
            DescribePackagesFilterName::PackageStatus => "PackageStatus",
            DescribePackagesFilterName::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["PackageID", "PackageName", "PackageStatus"]
    }
}
impl AsRef<str> for DescribePackagesFilterName {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Specifies details about an outbound cross-cluster connection.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct OutboundConnection {
    /// <p>Information about the source (local) domain.</p>
    #[doc(hidden)]
    pub local_domain_info: std::option::Option<crate::model::DomainInformationContainer>,
    /// <p>Information about the destination (remote) domain.</p>
    #[doc(hidden)]
    pub remote_domain_info: std::option::Option<crate::model::DomainInformationContainer>,
    /// <p>Unique identifier of the connection.</p>
    #[doc(hidden)]
    pub connection_id: std::option::Option<std::string::String>,
    /// <p>Name of the connection.</p>
    #[doc(hidden)]
    pub connection_alias: std::option::Option<std::string::String>,
    /// <p>Status of the connection.</p>
    #[doc(hidden)]
    pub connection_status: std::option::Option<crate::model::OutboundConnectionStatus>,
}
impl OutboundConnection {
    /// <p>Information about the source (local) domain.</p>
    pub fn local_domain_info(
        &self,
    ) -> std::option::Option<&crate::model::DomainInformationContainer> {
        self.local_domain_info.as_ref()
    }
    /// <p>Information about the destination (remote) domain.</p>
    pub fn remote_domain_info(
        &self,
    ) -> std::option::Option<&crate::model::DomainInformationContainer> {
        self.remote_domain_info.as_ref()
    }
    /// <p>Unique identifier of the connection.</p>
    pub fn connection_id(&self) -> std::option::Option<&str> {
        self.connection_id.as_deref()
    }
    /// <p>Name of the connection.</p>
    pub fn connection_alias(&self) -> std::option::Option<&str> {
        self.connection_alias.as_deref()
    }
    /// <p>Status of the connection.</p>
    pub fn connection_status(
        &self,
    ) -> std::option::Option<&crate::model::OutboundConnectionStatus> {
        self.connection_status.as_ref()
    }
}
/// See [`OutboundConnection`](crate::model::OutboundConnection).
pub mod outbound_connection {

    /// A builder for [`OutboundConnection`](crate::model::OutboundConnection).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) local_domain_info: std::option::Option<crate::model::DomainInformationContainer>,
        pub(crate) remote_domain_info:
            std::option::Option<crate::model::DomainInformationContainer>,
        pub(crate) connection_id: std::option::Option<std::string::String>,
        pub(crate) connection_alias: std::option::Option<std::string::String>,
        pub(crate) connection_status: std::option::Option<crate::model::OutboundConnectionStatus>,
    }
    impl Builder {
        /// <p>Information about the source (local) domain.</p>
        pub fn local_domain_info(
            mut self,
            input: crate::model::DomainInformationContainer,
        ) -> Self {
            self.local_domain_info = Some(input);
            self
        }
        /// <p>Information about the source (local) domain.</p>
        pub fn set_local_domain_info(
            mut self,
            input: std::option::Option<crate::model::DomainInformationContainer>,
        ) -> Self {
            self.local_domain_info = input;
            self
        }
        /// <p>Information about the destination (remote) domain.</p>
        pub fn remote_domain_info(
            mut self,
            input: crate::model::DomainInformationContainer,
        ) -> Self {
            self.remote_domain_info = Some(input);
            self
        }
        /// <p>Information about the destination (remote) domain.</p>
        pub fn set_remote_domain_info(
            mut self,
            input: std::option::Option<crate::model::DomainInformationContainer>,
        ) -> Self {
            self.remote_domain_info = input;
            self
        }
        /// <p>Unique identifier of the connection.</p>
        pub fn connection_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.connection_id = Some(input.into());
            self
        }
        /// <p>Unique identifier of the connection.</p>
        pub fn set_connection_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.connection_id = input;
            self
        }
        /// <p>Name of the connection.</p>
        pub fn connection_alias(mut self, input: impl Into<std::string::String>) -> Self {
            self.connection_alias = Some(input.into());
            self
        }
        /// <p>Name of the connection.</p>
        pub fn set_connection_alias(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.connection_alias = input;
            self
        }
        /// <p>Status of the connection.</p>
        pub fn connection_status(mut self, input: crate::model::OutboundConnectionStatus) -> Self {
            self.connection_status = Some(input);
            self
        }
        /// <p>Status of the connection.</p>
        pub fn set_connection_status(
            mut self,
            input: std::option::Option<crate::model::OutboundConnectionStatus>,
        ) -> Self {
            self.connection_status = input;
            self
        }
        /// Consumes the builder and constructs a [`OutboundConnection`](crate::model::OutboundConnection).
        pub fn build(self) -> crate::model::OutboundConnection {
            crate::model::OutboundConnection {
                local_domain_info: self.local_domain_info,
                remote_domain_info: self.remote_domain_info,
                connection_id: self.connection_id,
                connection_alias: self.connection_alias,
                connection_status: self.connection_status,
            }
        }
    }
}
impl OutboundConnection {
    /// Creates a new builder-style object to manufacture [`OutboundConnection`](crate::model::OutboundConnection).
    pub fn builder() -> crate::model::outbound_connection::Builder {
        crate::model::outbound_connection::Builder::default()
    }
}

/// <p>The status of an outbound cross-cluster connection.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct OutboundConnectionStatus {
    /// <p>The status code for the outbound connection. Can be one of the following:</p>
    /// <ul>
    /// <li> <p> <b>VALIDATING</b> - The outbound connection request is being validated.</p> </li>
    /// <li> <p> <b>VALIDATION_FAILED</b> - Validation failed for the connection request.</p> </li>
    /// <li> <p> <b>PENDING_ACCEPTANCE</b>: Outbound connection request is validated and is not yet accepted by the remote domain owner.</p> </li>
    /// <li> <p> <b>APPROVED</b> - Outbound connection has been approved by the remote domain owner for getting provisioned.</p> </li>
    /// <li> <p> <b>PROVISIONING</b> - Outbound connection request is in process.</p> </li>
    /// <li> <p> <b>ACTIVE</b> - Outbound connection is active and ready to use.</p> </li>
    /// <li> <p> <b>REJECTING</b> - Outbound connection rejection by remote domain owner is in progress.</p> </li>
    /// <li> <p> <b>REJECTED</b> - Outbound connection request is rejected by remote domain owner.</p> </li>
    /// <li> <p> <b>DELETING</b> - Outbound connection deletion is in progress.</p> </li>
    /// <li> <p> <b>DELETED</b> - Outbound connection is deleted and can no longer be used.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub status_code: std::option::Option<crate::model::OutboundConnectionStatusCode>,
    /// <p>Verbose information for the outbound connection.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
}
impl OutboundConnectionStatus {
    /// <p>The status code for the outbound connection. Can be one of the following:</p>
    /// <ul>
    /// <li> <p> <b>VALIDATING</b> - The outbound connection request is being validated.</p> </li>
    /// <li> <p> <b>VALIDATION_FAILED</b> - Validation failed for the connection request.</p> </li>
    /// <li> <p> <b>PENDING_ACCEPTANCE</b>: Outbound connection request is validated and is not yet accepted by the remote domain owner.</p> </li>
    /// <li> <p> <b>APPROVED</b> - Outbound connection has been approved by the remote domain owner for getting provisioned.</p> </li>
    /// <li> <p> <b>PROVISIONING</b> - Outbound connection request is in process.</p> </li>
    /// <li> <p> <b>ACTIVE</b> - Outbound connection is active and ready to use.</p> </li>
    /// <li> <p> <b>REJECTING</b> - Outbound connection rejection by remote domain owner is in progress.</p> </li>
    /// <li> <p> <b>REJECTED</b> - Outbound connection request is rejected by remote domain owner.</p> </li>
    /// <li> <p> <b>DELETING</b> - Outbound connection deletion is in progress.</p> </li>
    /// <li> <p> <b>DELETED</b> - Outbound connection is deleted and can no longer be used.</p> </li>
    /// </ul>
    pub fn status_code(&self) -> std::option::Option<&crate::model::OutboundConnectionStatusCode> {
        self.status_code.as_ref()
    }
    /// <p>Verbose information for the outbound connection.</p>
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
/// See [`OutboundConnectionStatus`](crate::model::OutboundConnectionStatus).
pub mod outbound_connection_status {

    /// A builder for [`OutboundConnectionStatus`](crate::model::OutboundConnectionStatus).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) status_code: std::option::Option<crate::model::OutboundConnectionStatusCode>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The status code for the outbound connection. Can be one of the following:</p>
        /// <ul>
        /// <li> <p> <b>VALIDATING</b> - The outbound connection request is being validated.</p> </li>
        /// <li> <p> <b>VALIDATION_FAILED</b> - Validation failed for the connection request.</p> </li>
        /// <li> <p> <b>PENDING_ACCEPTANCE</b>: Outbound connection request is validated and is not yet accepted by the remote domain owner.</p> </li>
        /// <li> <p> <b>APPROVED</b> - Outbound connection has been approved by the remote domain owner for getting provisioned.</p> </li>
        /// <li> <p> <b>PROVISIONING</b> - Outbound connection request is in process.</p> </li>
        /// <li> <p> <b>ACTIVE</b> - Outbound connection is active and ready to use.</p> </li>
        /// <li> <p> <b>REJECTING</b> - Outbound connection rejection by remote domain owner is in progress.</p> </li>
        /// <li> <p> <b>REJECTED</b> - Outbound connection request is rejected by remote domain owner.</p> </li>
        /// <li> <p> <b>DELETING</b> - Outbound connection deletion is in progress.</p> </li>
        /// <li> <p> <b>DELETED</b> - Outbound connection is deleted and can no longer be used.</p> </li>
        /// </ul>
        pub fn status_code(mut self, input: crate::model::OutboundConnectionStatusCode) -> Self {
            self.status_code = Some(input);
            self
        }
        /// <p>The status code for the outbound connection. Can be one of the following:</p>
        /// <ul>
        /// <li> <p> <b>VALIDATING</b> - The outbound connection request is being validated.</p> </li>
        /// <li> <p> <b>VALIDATION_FAILED</b> - Validation failed for the connection request.</p> </li>
        /// <li> <p> <b>PENDING_ACCEPTANCE</b>: Outbound connection request is validated and is not yet accepted by the remote domain owner.</p> </li>
        /// <li> <p> <b>APPROVED</b> - Outbound connection has been approved by the remote domain owner for getting provisioned.</p> </li>
        /// <li> <p> <b>PROVISIONING</b> - Outbound connection request is in process.</p> </li>
        /// <li> <p> <b>ACTIVE</b> - Outbound connection is active and ready to use.</p> </li>
        /// <li> <p> <b>REJECTING</b> - Outbound connection rejection by remote domain owner is in progress.</p> </li>
        /// <li> <p> <b>REJECTED</b> - Outbound connection request is rejected by remote domain owner.</p> </li>
        /// <li> <p> <b>DELETING</b> - Outbound connection deletion is in progress.</p> </li>
        /// <li> <p> <b>DELETED</b> - Outbound connection is deleted and can no longer be used.</p> </li>
        /// </ul>
        pub fn set_status_code(
            mut self,
            input: std::option::Option<crate::model::OutboundConnectionStatusCode>,
        ) -> Self {
            self.status_code = input;
            self
        }
        /// <p>Verbose information for the outbound connection.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Verbose information for the outbound connection.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`OutboundConnectionStatus`](crate::model::OutboundConnectionStatus).
        pub fn build(self) -> crate::model::OutboundConnectionStatus {
            crate::model::OutboundConnectionStatus {
                status_code: self.status_code,
                message: self.message,
            }
        }
    }
}
impl OutboundConnectionStatus {
    /// Creates a new builder-style object to manufacture [`OutboundConnectionStatus`](crate::model::OutboundConnectionStatus).
    pub fn builder() -> crate::model::outbound_connection_status::Builder {
        crate::model::outbound_connection_status::Builder::default()
    }
}

/// When writing a match expression against `OutboundConnectionStatusCode`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let outboundconnectionstatuscode = unimplemented!();
/// match outboundconnectionstatuscode {
///     OutboundConnectionStatusCode::Active => { /* ... */ },
///     OutboundConnectionStatusCode::Approved => { /* ... */ },
///     OutboundConnectionStatusCode::Deleted => { /* ... */ },
///     OutboundConnectionStatusCode::Deleting => { /* ... */ },
///     OutboundConnectionStatusCode::PendingAcceptance => { /* ... */ },
///     OutboundConnectionStatusCode::Provisioning => { /* ... */ },
///     OutboundConnectionStatusCode::Rejected => { /* ... */ },
///     OutboundConnectionStatusCode::Rejecting => { /* ... */ },
///     OutboundConnectionStatusCode::Validating => { /* ... */ },
///     OutboundConnectionStatusCode::ValidationFailed => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `outboundconnectionstatuscode` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `OutboundConnectionStatusCode::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `OutboundConnectionStatusCode::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `OutboundConnectionStatusCode::NewFeature` is defined.
/// Specifically, when `outboundconnectionstatuscode` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `OutboundConnectionStatusCode::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum OutboundConnectionStatusCode {
    #[allow(missing_docs)] // documentation missing in model
    Active,
    #[allow(missing_docs)] // documentation missing in model
    Approved,
    #[allow(missing_docs)] // documentation missing in model
    Deleted,
    #[allow(missing_docs)] // documentation missing in model
    Deleting,
    #[allow(missing_docs)] // documentation missing in model
    PendingAcceptance,
    #[allow(missing_docs)] // documentation missing in model
    Provisioning,
    #[allow(missing_docs)] // documentation missing in model
    Rejected,
    #[allow(missing_docs)] // documentation missing in model
    Rejecting,
    #[allow(missing_docs)] // documentation missing in model
    Validating,
    #[allow(missing_docs)] // documentation missing in model
    ValidationFailed,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for OutboundConnectionStatusCode {
    fn from(s: &str) -> Self {
        match s {
            "ACTIVE" => OutboundConnectionStatusCode::Active,
            "APPROVED" => OutboundConnectionStatusCode::Approved,
            "DELETED" => OutboundConnectionStatusCode::Deleted,
            "DELETING" => OutboundConnectionStatusCode::Deleting,
            "PENDING_ACCEPTANCE" => OutboundConnectionStatusCode::PendingAcceptance,
            "PROVISIONING" => OutboundConnectionStatusCode::Provisioning,
            "REJECTED" => OutboundConnectionStatusCode::Rejected,
            "REJECTING" => OutboundConnectionStatusCode::Rejecting,
            "VALIDATING" => OutboundConnectionStatusCode::Validating,
            "VALIDATION_FAILED" => OutboundConnectionStatusCode::ValidationFailed,
            other => OutboundConnectionStatusCode::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for OutboundConnectionStatusCode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(OutboundConnectionStatusCode::from(s))
    }
}
impl OutboundConnectionStatusCode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            OutboundConnectionStatusCode::Active => "ACTIVE",
            OutboundConnectionStatusCode::Approved => "APPROVED",
            OutboundConnectionStatusCode::Deleted => "DELETED",
            OutboundConnectionStatusCode::Deleting => "DELETING",
            OutboundConnectionStatusCode::PendingAcceptance => "PENDING_ACCEPTANCE",
            OutboundConnectionStatusCode::Provisioning => "PROVISIONING",
            OutboundConnectionStatusCode::Rejected => "REJECTED",
            OutboundConnectionStatusCode::Rejecting => "REJECTING",
            OutboundConnectionStatusCode::Validating => "VALIDATING",
            OutboundConnectionStatusCode::ValidationFailed => "VALIDATION_FAILED",
            OutboundConnectionStatusCode::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "ACTIVE",
            "APPROVED",
            "DELETED",
            "DELETING",
            "PENDING_ACCEPTANCE",
            "PROVISIONING",
            "REJECTED",
            "REJECTING",
            "VALIDATING",
            "VALIDATION_FAILED",
        ]
    }
}
impl AsRef<str> for OutboundConnectionStatusCode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A filter used to limit results when describing inbound or outbound cross-cluster connections. You can specify multiple values per filter. A cross-cluster connection must match at least one of the specified values for it to be returned from an operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Filter {
    /// <p>The name of the filter.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>One or more values for the filter.</p>
    #[doc(hidden)]
    pub values: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl Filter {
    /// <p>The name of the filter.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>One or more values for the filter.</p>
    pub fn values(&self) -> std::option::Option<&[std::string::String]> {
        self.values.as_deref()
    }
}
/// See [`Filter`](crate::model::Filter).
pub mod filter {

    /// A builder for [`Filter`](crate::model::Filter).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) values: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The name of the filter.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the filter.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Appends an item to `values`.
        ///
        /// To override the contents of this collection use [`set_values`](Self::set_values).
        ///
        /// <p>One or more values for the filter.</p>
        pub fn values(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.values.unwrap_or_default();
            v.push(input.into());
            self.values = Some(v);
            self
        }
        /// <p>One or more values for the filter.</p>
        pub fn set_values(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.values = input;
            self
        }
        /// Consumes the builder and constructs a [`Filter`](crate::model::Filter).
        pub fn build(self) -> crate::model::Filter {
            crate::model::Filter {
                name: self.name,
                values: self.values,
            }
        }
    }
}
impl Filter {
    /// Creates a new builder-style object to manufacture [`Filter`](crate::model::Filter).
    pub fn builder() -> crate::model::filter::Builder {
        crate::model::filter::Builder::default()
    }
}

/// <p>Limits for a given instance type and for each of its roles.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Limits {
    /// <p>Storage-related attributes that are available for a given instance type.</p>
    #[doc(hidden)]
    pub storage_types: std::option::Option<std::vec::Vec<crate::model::StorageType>>,
    /// <p>The limits for a given instance type.</p>
    #[doc(hidden)]
    pub instance_limits: std::option::Option<crate::model::InstanceLimits>,
    /// <p>List of additional limits that are specific to a given instance type for each of its instance roles.</p>
    #[doc(hidden)]
    pub additional_limits: std::option::Option<std::vec::Vec<crate::model::AdditionalLimit>>,
}
impl Limits {
    /// <p>Storage-related attributes that are available for a given instance type.</p>
    pub fn storage_types(&self) -> std::option::Option<&[crate::model::StorageType]> {
        self.storage_types.as_deref()
    }
    /// <p>The limits for a given instance type.</p>
    pub fn instance_limits(&self) -> std::option::Option<&crate::model::InstanceLimits> {
        self.instance_limits.as_ref()
    }
    /// <p>List of additional limits that are specific to a given instance type for each of its instance roles.</p>
    pub fn additional_limits(&self) -> std::option::Option<&[crate::model::AdditionalLimit]> {
        self.additional_limits.as_deref()
    }
}
/// See [`Limits`](crate::model::Limits).
pub mod limits {

    /// A builder for [`Limits`](crate::model::Limits).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) storage_types: std::option::Option<std::vec::Vec<crate::model::StorageType>>,
        pub(crate) instance_limits: std::option::Option<crate::model::InstanceLimits>,
        pub(crate) additional_limits:
            std::option::Option<std::vec::Vec<crate::model::AdditionalLimit>>,
    }
    impl Builder {
        /// Appends an item to `storage_types`.
        ///
        /// To override the contents of this collection use [`set_storage_types`](Self::set_storage_types).
        ///
        /// <p>Storage-related attributes that are available for a given instance type.</p>
        pub fn storage_types(mut self, input: crate::model::StorageType) -> Self {
            let mut v = self.storage_types.unwrap_or_default();
            v.push(input);
            self.storage_types = Some(v);
            self
        }
        /// <p>Storage-related attributes that are available for a given instance type.</p>
        pub fn set_storage_types(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::StorageType>>,
        ) -> Self {
            self.storage_types = input;
            self
        }
        /// <p>The limits for a given instance type.</p>
        pub fn instance_limits(mut self, input: crate::model::InstanceLimits) -> Self {
            self.instance_limits = Some(input);
            self
        }
        /// <p>The limits for a given instance type.</p>
        pub fn set_instance_limits(
            mut self,
            input: std::option::Option<crate::model::InstanceLimits>,
        ) -> Self {
            self.instance_limits = input;
            self
        }
        /// Appends an item to `additional_limits`.
        ///
        /// To override the contents of this collection use [`set_additional_limits`](Self::set_additional_limits).
        ///
        /// <p>List of additional limits that are specific to a given instance type for each of its instance roles.</p>
        pub fn additional_limits(mut self, input: crate::model::AdditionalLimit) -> Self {
            let mut v = self.additional_limits.unwrap_or_default();
            v.push(input);
            self.additional_limits = Some(v);
            self
        }
        /// <p>List of additional limits that are specific to a given instance type for each of its instance roles.</p>
        pub fn set_additional_limits(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AdditionalLimit>>,
        ) -> Self {
            self.additional_limits = input;
            self
        }
        /// Consumes the builder and constructs a [`Limits`](crate::model::Limits).
        pub fn build(self) -> crate::model::Limits {
            crate::model::Limits {
                storage_types: self.storage_types,
                instance_limits: self.instance_limits,
                additional_limits: self.additional_limits,
            }
        }
    }
}
impl Limits {
    /// Creates a new builder-style object to manufacture [`Limits`](crate::model::Limits).
    pub fn builder() -> crate::model::limits::Builder {
        crate::model::limits::Builder::default()
    }
}

/// <p> List of limits that are specific to a given instance type.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AdditionalLimit {
    /// <ul>
    /// <li> <p> <code>MaximumNumberOfDataNodesSupported</code> - This attribute only applies to master nodes and specifies the maximum number of data nodes of a given instance type a master node can support.</p> </li>
    /// <li> <p> <code>MaximumNumberOfDataNodesWithoutMasterNode</code> - This attribute only applies to data nodes and specifies the maximum number of data nodes of a given instance type can exist without a master node governing them.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub limit_name: std::option::Option<std::string::String>,
    /// <p> The values of the additional instance type limits.</p>
    #[doc(hidden)]
    pub limit_values: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl AdditionalLimit {
    /// <ul>
    /// <li> <p> <code>MaximumNumberOfDataNodesSupported</code> - This attribute only applies to master nodes and specifies the maximum number of data nodes of a given instance type a master node can support.</p> </li>
    /// <li> <p> <code>MaximumNumberOfDataNodesWithoutMasterNode</code> - This attribute only applies to data nodes and specifies the maximum number of data nodes of a given instance type can exist without a master node governing them.</p> </li>
    /// </ul>
    pub fn limit_name(&self) -> std::option::Option<&str> {
        self.limit_name.as_deref()
    }
    /// <p> The values of the additional instance type limits.</p>
    pub fn limit_values(&self) -> std::option::Option<&[std::string::String]> {
        self.limit_values.as_deref()
    }
}
/// See [`AdditionalLimit`](crate::model::AdditionalLimit).
pub mod additional_limit {

    /// A builder for [`AdditionalLimit`](crate::model::AdditionalLimit).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) limit_name: std::option::Option<std::string::String>,
        pub(crate) limit_values: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <ul>
        /// <li> <p> <code>MaximumNumberOfDataNodesSupported</code> - This attribute only applies to master nodes and specifies the maximum number of data nodes of a given instance type a master node can support.</p> </li>
        /// <li> <p> <code>MaximumNumberOfDataNodesWithoutMasterNode</code> - This attribute only applies to data nodes and specifies the maximum number of data nodes of a given instance type can exist without a master node governing them.</p> </li>
        /// </ul>
        pub fn limit_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.limit_name = Some(input.into());
            self
        }
        /// <ul>
        /// <li> <p> <code>MaximumNumberOfDataNodesSupported</code> - This attribute only applies to master nodes and specifies the maximum number of data nodes of a given instance type a master node can support.</p> </li>
        /// <li> <p> <code>MaximumNumberOfDataNodesWithoutMasterNode</code> - This attribute only applies to data nodes and specifies the maximum number of data nodes of a given instance type can exist without a master node governing them.</p> </li>
        /// </ul>
        pub fn set_limit_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.limit_name = input;
            self
        }
        /// Appends an item to `limit_values`.
        ///
        /// To override the contents of this collection use [`set_limit_values`](Self::set_limit_values).
        ///
        /// <p> The values of the additional instance type limits.</p>
        pub fn limit_values(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.limit_values.unwrap_or_default();
            v.push(input.into());
            self.limit_values = Some(v);
            self
        }
        /// <p> The values of the additional instance type limits.</p>
        pub fn set_limit_values(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.limit_values = input;
            self
        }
        /// Consumes the builder and constructs a [`AdditionalLimit`](crate::model::AdditionalLimit).
        pub fn build(self) -> crate::model::AdditionalLimit {
            crate::model::AdditionalLimit {
                limit_name: self.limit_name,
                limit_values: self.limit_values,
            }
        }
    }
}
impl AdditionalLimit {
    /// Creates a new builder-style object to manufacture [`AdditionalLimit`](crate::model::AdditionalLimit).
    pub fn builder() -> crate::model::additional_limit::Builder {
        crate::model::additional_limit::Builder::default()
    }
}

/// <p>Instance-related attributes that are available for a given instance type.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InstanceLimits {
    /// <p>Limits on the number of instances that can be created for a given instance type.</p>
    #[doc(hidden)]
    pub instance_count_limits: std::option::Option<crate::model::InstanceCountLimits>,
}
impl InstanceLimits {
    /// <p>Limits on the number of instances that can be created for a given instance type.</p>
    pub fn instance_count_limits(&self) -> std::option::Option<&crate::model::InstanceCountLimits> {
        self.instance_count_limits.as_ref()
    }
}
/// See [`InstanceLimits`](crate::model::InstanceLimits).
pub mod instance_limits {

    /// A builder for [`InstanceLimits`](crate::model::InstanceLimits).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_count_limits: std::option::Option<crate::model::InstanceCountLimits>,
    }
    impl Builder {
        /// <p>Limits on the number of instances that can be created for a given instance type.</p>
        pub fn instance_count_limits(mut self, input: crate::model::InstanceCountLimits) -> Self {
            self.instance_count_limits = Some(input);
            self
        }
        /// <p>Limits on the number of instances that can be created for a given instance type.</p>
        pub fn set_instance_count_limits(
            mut self,
            input: std::option::Option<crate::model::InstanceCountLimits>,
        ) -> Self {
            self.instance_count_limits = input;
            self
        }
        /// Consumes the builder and constructs a [`InstanceLimits`](crate::model::InstanceLimits).
        pub fn build(self) -> crate::model::InstanceLimits {
            crate::model::InstanceLimits {
                instance_count_limits: self.instance_count_limits,
            }
        }
    }
}
impl InstanceLimits {
    /// Creates a new builder-style object to manufacture [`InstanceLimits`](crate::model::InstanceLimits).
    pub fn builder() -> crate::model::instance_limits::Builder {
        crate::model::instance_limits::Builder::default()
    }
}

/// <p>Limits on the number of instances that can be created in OpenSearch Service for a given instance type.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InstanceCountLimits {
    /// <p>The maximum allowed number of instances.</p>
    #[doc(hidden)]
    pub minimum_instance_count: i32,
    /// <p>The minimum allowed number of instances.</p>
    #[doc(hidden)]
    pub maximum_instance_count: i32,
}
impl InstanceCountLimits {
    /// <p>The maximum allowed number of instances.</p>
    pub fn minimum_instance_count(&self) -> i32 {
        self.minimum_instance_count
    }
    /// <p>The minimum allowed number of instances.</p>
    pub fn maximum_instance_count(&self) -> i32 {
        self.maximum_instance_count
    }
}
/// See [`InstanceCountLimits`](crate::model::InstanceCountLimits).
pub mod instance_count_limits {

    /// A builder for [`InstanceCountLimits`](crate::model::InstanceCountLimits).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) minimum_instance_count: std::option::Option<i32>,
        pub(crate) maximum_instance_count: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The maximum allowed number of instances.</p>
        pub fn minimum_instance_count(mut self, input: i32) -> Self {
            self.minimum_instance_count = Some(input);
            self
        }
        /// <p>The maximum allowed number of instances.</p>
        pub fn set_minimum_instance_count(mut self, input: std::option::Option<i32>) -> Self {
            self.minimum_instance_count = input;
            self
        }
        /// <p>The minimum allowed number of instances.</p>
        pub fn maximum_instance_count(mut self, input: i32) -> Self {
            self.maximum_instance_count = Some(input);
            self
        }
        /// <p>The minimum allowed number of instances.</p>
        pub fn set_maximum_instance_count(mut self, input: std::option::Option<i32>) -> Self {
            self.maximum_instance_count = input;
            self
        }
        /// Consumes the builder and constructs a [`InstanceCountLimits`](crate::model::InstanceCountLimits).
        pub fn build(self) -> crate::model::InstanceCountLimits {
            crate::model::InstanceCountLimits {
                minimum_instance_count: self.minimum_instance_count.unwrap_or_default(),
                maximum_instance_count: self.maximum_instance_count.unwrap_or_default(),
            }
        }
    }
}
impl InstanceCountLimits {
    /// Creates a new builder-style object to manufacture [`InstanceCountLimits`](crate::model::InstanceCountLimits).
    pub fn builder() -> crate::model::instance_count_limits::Builder {
        crate::model::instance_count_limits::Builder::default()
    }
}

/// <p>A list of storage types for an Amazon OpenSearch Service domain that are available for a given intance type.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct StorageType {
    /// <p>The name of the storage type.</p>
    #[doc(hidden)]
    pub storage_type_name: std::option::Option<std::string::String>,
    /// <p>The storage sub-type, such as <code>gp3</code> or <code>io1</code>.</p>
    #[doc(hidden)]
    pub storage_sub_type_name: std::option::Option<std::string::String>,
    /// <p>Limits that are applicable for the given storage type.</p>
    #[doc(hidden)]
    pub storage_type_limits: std::option::Option<std::vec::Vec<crate::model::StorageTypeLimit>>,
}
impl StorageType {
    /// <p>The name of the storage type.</p>
    pub fn storage_type_name(&self) -> std::option::Option<&str> {
        self.storage_type_name.as_deref()
    }
    /// <p>The storage sub-type, such as <code>gp3</code> or <code>io1</code>.</p>
    pub fn storage_sub_type_name(&self) -> std::option::Option<&str> {
        self.storage_sub_type_name.as_deref()
    }
    /// <p>Limits that are applicable for the given storage type.</p>
    pub fn storage_type_limits(&self) -> std::option::Option<&[crate::model::StorageTypeLimit]> {
        self.storage_type_limits.as_deref()
    }
}
/// See [`StorageType`](crate::model::StorageType).
pub mod storage_type {

    /// A builder for [`StorageType`](crate::model::StorageType).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) storage_type_name: std::option::Option<std::string::String>,
        pub(crate) storage_sub_type_name: std::option::Option<std::string::String>,
        pub(crate) storage_type_limits:
            std::option::Option<std::vec::Vec<crate::model::StorageTypeLimit>>,
    }
    impl Builder {
        /// <p>The name of the storage type.</p>
        pub fn storage_type_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.storage_type_name = Some(input.into());
            self
        }
        /// <p>The name of the storage type.</p>
        pub fn set_storage_type_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.storage_type_name = input;
            self
        }
        /// <p>The storage sub-type, such as <code>gp3</code> or <code>io1</code>.</p>
        pub fn storage_sub_type_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.storage_sub_type_name = Some(input.into());
            self
        }
        /// <p>The storage sub-type, such as <code>gp3</code> or <code>io1</code>.</p>
        pub fn set_storage_sub_type_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.storage_sub_type_name = input;
            self
        }
        /// Appends an item to `storage_type_limits`.
        ///
        /// To override the contents of this collection use [`set_storage_type_limits`](Self::set_storage_type_limits).
        ///
        /// <p>Limits that are applicable for the given storage type.</p>
        pub fn storage_type_limits(mut self, input: crate::model::StorageTypeLimit) -> Self {
            let mut v = self.storage_type_limits.unwrap_or_default();
            v.push(input);
            self.storage_type_limits = Some(v);
            self
        }
        /// <p>Limits that are applicable for the given storage type.</p>
        pub fn set_storage_type_limits(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::StorageTypeLimit>>,
        ) -> Self {
            self.storage_type_limits = input;
            self
        }
        /// Consumes the builder and constructs a [`StorageType`](crate::model::StorageType).
        pub fn build(self) -> crate::model::StorageType {
            crate::model::StorageType {
                storage_type_name: self.storage_type_name,
                storage_sub_type_name: self.storage_sub_type_name,
                storage_type_limits: self.storage_type_limits,
            }
        }
    }
}
impl StorageType {
    /// Creates a new builder-style object to manufacture [`StorageType`](crate::model::StorageType).
    pub fn builder() -> crate::model::storage_type::Builder {
        crate::model::storage_type::Builder::default()
    }
}

/// <p>Limits that are applicable for the given Amazon OpenSearch Service storage type.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct StorageTypeLimit {
    /// <p> Name of storage limits that are applicable for the given storage type. If <code>StorageType</code> is <code>ebs</code>, the following options are available:</p>
    /// <ul>
    /// <li> <p> <b>MinimumVolumeSize</b> - Minimum volume size that is available for the given storage type. Can be empty if not applicable.</p> </li>
    /// <li> <p> <b>MaximumVolumeSize</b> - Maximum volume size that is available for the given storage type. Can be empty if not applicable.</p> </li>
    /// <li> <p> <b>MaximumIops</b> - Maximum amount of IOPS that is available for the given the storage type. Can be empty if not applicable.</p> </li>
    /// <li> <p> <b>MinimumIops</b> - Minimum amount of IOPS that is available for the given the storage type. Can be empty if not applicable.</p> </li>
    /// <li> <p> <b>MaximumThroughput</b> - Maximum amount of throughput that is available for the given the storage type. Can be empty if not applicable.</p> </li>
    /// <li> <p> <b>MinimumThroughput</b> - Minimum amount of throughput that is available for the given the storage type. Can be empty if not applicable.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub limit_name: std::option::Option<std::string::String>,
    /// <p>The limit values.</p>
    #[doc(hidden)]
    pub limit_values: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl StorageTypeLimit {
    /// <p> Name of storage limits that are applicable for the given storage type. If <code>StorageType</code> is <code>ebs</code>, the following options are available:</p>
    /// <ul>
    /// <li> <p> <b>MinimumVolumeSize</b> - Minimum volume size that is available for the given storage type. Can be empty if not applicable.</p> </li>
    /// <li> <p> <b>MaximumVolumeSize</b> - Maximum volume size that is available for the given storage type. Can be empty if not applicable.</p> </li>
    /// <li> <p> <b>MaximumIops</b> - Maximum amount of IOPS that is available for the given the storage type. Can be empty if not applicable.</p> </li>
    /// <li> <p> <b>MinimumIops</b> - Minimum amount of IOPS that is available for the given the storage type. Can be empty if not applicable.</p> </li>
    /// <li> <p> <b>MaximumThroughput</b> - Maximum amount of throughput that is available for the given the storage type. Can be empty if not applicable.</p> </li>
    /// <li> <p> <b>MinimumThroughput</b> - Minimum amount of throughput that is available for the given the storage type. Can be empty if not applicable.</p> </li>
    /// </ul>
    pub fn limit_name(&self) -> std::option::Option<&str> {
        self.limit_name.as_deref()
    }
    /// <p>The limit values.</p>
    pub fn limit_values(&self) -> std::option::Option<&[std::string::String]> {
        self.limit_values.as_deref()
    }
}
/// See [`StorageTypeLimit`](crate::model::StorageTypeLimit).
pub mod storage_type_limit {

    /// A builder for [`StorageTypeLimit`](crate::model::StorageTypeLimit).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) limit_name: std::option::Option<std::string::String>,
        pub(crate) limit_values: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p> Name of storage limits that are applicable for the given storage type. If <code>StorageType</code> is <code>ebs</code>, the following options are available:</p>
        /// <ul>
        /// <li> <p> <b>MinimumVolumeSize</b> - Minimum volume size that is available for the given storage type. Can be empty if not applicable.</p> </li>
        /// <li> <p> <b>MaximumVolumeSize</b> - Maximum volume size that is available for the given storage type. Can be empty if not applicable.</p> </li>
        /// <li> <p> <b>MaximumIops</b> - Maximum amount of IOPS that is available for the given the storage type. Can be empty if not applicable.</p> </li>
        /// <li> <p> <b>MinimumIops</b> - Minimum amount of IOPS that is available for the given the storage type. Can be empty if not applicable.</p> </li>
        /// <li> <p> <b>MaximumThroughput</b> - Maximum amount of throughput that is available for the given the storage type. Can be empty if not applicable.</p> </li>
        /// <li> <p> <b>MinimumThroughput</b> - Minimum amount of throughput that is available for the given the storage type. Can be empty if not applicable.</p> </li>
        /// </ul>
        pub fn limit_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.limit_name = Some(input.into());
            self
        }
        /// <p> Name of storage limits that are applicable for the given storage type. If <code>StorageType</code> is <code>ebs</code>, the following options are available:</p>
        /// <ul>
        /// <li> <p> <b>MinimumVolumeSize</b> - Minimum volume size that is available for the given storage type. Can be empty if not applicable.</p> </li>
        /// <li> <p> <b>MaximumVolumeSize</b> - Maximum volume size that is available for the given storage type. Can be empty if not applicable.</p> </li>
        /// <li> <p> <b>MaximumIops</b> - Maximum amount of IOPS that is available for the given the storage type. Can be empty if not applicable.</p> </li>
        /// <li> <p> <b>MinimumIops</b> - Minimum amount of IOPS that is available for the given the storage type. Can be empty if not applicable.</p> </li>
        /// <li> <p> <b>MaximumThroughput</b> - Maximum amount of throughput that is available for the given the storage type. Can be empty if not applicable.</p> </li>
        /// <li> <p> <b>MinimumThroughput</b> - Minimum amount of throughput that is available for the given the storage type. Can be empty if not applicable.</p> </li>
        /// </ul>
        pub fn set_limit_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.limit_name = input;
            self
        }
        /// Appends an item to `limit_values`.
        ///
        /// To override the contents of this collection use [`set_limit_values`](Self::set_limit_values).
        ///
        /// <p>The limit values.</p>
        pub fn limit_values(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.limit_values.unwrap_or_default();
            v.push(input.into());
            self.limit_values = Some(v);
            self
        }
        /// <p>The limit values.</p>
        pub fn set_limit_values(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.limit_values = input;
            self
        }
        /// Consumes the builder and constructs a [`StorageTypeLimit`](crate::model::StorageTypeLimit).
        pub fn build(self) -> crate::model::StorageTypeLimit {
            crate::model::StorageTypeLimit {
                limit_name: self.limit_name,
                limit_values: self.limit_values,
            }
        }
    }
}
impl StorageTypeLimit {
    /// Creates a new builder-style object to manufacture [`StorageTypeLimit`](crate::model::StorageTypeLimit).
    pub fn builder() -> crate::model::storage_type_limit::Builder {
        crate::model::storage_type_limit::Builder::default()
    }
}

/// <p>The current status of an OpenSearch Service domain.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DomainStatus {
    /// <p>Unique identifier for the domain.</p>
    #[doc(hidden)]
    pub domain_id: std::option::Option<std::string::String>,
    /// <p>Name of the domain. Domain names are unique across all domains owned by the same account within an Amazon Web Services Region.</p>
    #[doc(hidden)]
    pub domain_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the domain. For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html">IAM identifiers </a> in the <i>AWS Identity and Access Management User Guide</i>.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>Creation status of an OpenSearch Service domain. True if domain creation is complete. False if domain creation is still in progress.</p>
    #[doc(hidden)]
    pub created: std::option::Option<bool>,
    /// <p>Deletion status of an OpenSearch Service domain. True if domain deletion is complete. False if domain deletion is still in progress. Once deletion is complete, the status of the domain is no longer returned.</p>
    #[doc(hidden)]
    pub deleted: std::option::Option<bool>,
    /// <p>Domain-specific endpoint used to submit index, search, and data upload requests to the domain.</p>
    #[doc(hidden)]
    pub endpoint: std::option::Option<std::string::String>,
    /// <p>The key-value pair that exists if the OpenSearch Service domain uses VPC endpoints.. Example <code>key, value</code>: <code>'vpc','vpc-endpoint-h2dsd34efgyghrtguk5gt6j2foh4.us-east-1.es.amazonaws.com'</code>.</p>
    #[doc(hidden)]
    pub endpoints:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The status of the domain configuration. True if OpenSearch Service is processing configuration changes. False if the configuration is active.</p>
    #[doc(hidden)]
    pub processing: std::option::Option<bool>,
    /// <p>The status of a domain version upgrade to a new version of OpenSearch or Elasticsearch. True if OpenSearch Service is in the process of a version upgrade. False if the configuration is active.</p>
    #[doc(hidden)]
    pub upgrade_processing: std::option::Option<bool>,
    /// <p>Version of OpenSearch or Elasticsearch that the domain is running, in the format <code>Elasticsearch_X.Y</code> or <code>OpenSearch_X.Y</code>.</p>
    #[doc(hidden)]
    pub engine_version: std::option::Option<std::string::String>,
    /// <p>Container for the cluster configuration of the domain.</p>
    #[doc(hidden)]
    pub cluster_config: std::option::Option<crate::model::ClusterConfig>,
    /// <p>Container for EBS-based storage settings for the domain.</p>
    #[doc(hidden)]
    pub ebs_options: std::option::Option<crate::model::EbsOptions>,
    /// <p>Identity and Access Management (IAM) policy document specifying the access policies for the domain.</p>
    #[doc(hidden)]
    pub access_policies: std::option::Option<std::string::String>,
    /// <p>DEPRECATED. Container for parameters required to configure automated snapshots of domain indexes.</p>
    #[doc(hidden)]
    pub snapshot_options: std::option::Option<crate::model::SnapshotOptions>,
    /// <p>The VPC configuration for the domain.</p>
    #[doc(hidden)]
    pub vpc_options: std::option::Option<crate::model::VpcDerivedInfo>,
    /// <p>Key-value pairs to configure Amazon Cognito authentication for OpenSearch Dashboards.</p>
    #[doc(hidden)]
    pub cognito_options: std::option::Option<crate::model::CognitoOptions>,
    /// <p>Encryption at rest settings for the domain.</p>
    #[doc(hidden)]
    pub encryption_at_rest_options: std::option::Option<crate::model::EncryptionAtRestOptions>,
    /// <p>Whether node-to-node encryption is enabled or disabled.</p>
    #[doc(hidden)]
    pub node_to_node_encryption_options:
        std::option::Option<crate::model::NodeToNodeEncryptionOptions>,
    /// <p>Key-value pairs that specify advanced configuration options.</p>
    #[doc(hidden)]
    pub advanced_options:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>Log publishing options for the domain.</p>
    #[doc(hidden)]
    pub log_publishing_options: std::option::Option<
        std::collections::HashMap<crate::model::LogType, crate::model::LogPublishingOption>,
    >,
    /// <p>The current status of the domain's service software.</p>
    #[doc(hidden)]
    pub service_software_options: std::option::Option<crate::model::ServiceSoftwareOptions>,
    /// <p>Additional options for the domain endpoint, such as whether to require HTTPS for all traffic.</p>
    #[doc(hidden)]
    pub domain_endpoint_options: std::option::Option<crate::model::DomainEndpointOptions>,
    /// <p>Settings for fine-grained access control.</p>
    #[doc(hidden)]
    pub advanced_security_options: std::option::Option<crate::model::AdvancedSecurityOptions>,
    /// <p>Auto-Tune settings for the domain.</p>
    #[doc(hidden)]
    pub auto_tune_options: std::option::Option<crate::model::AutoTuneOptionsOutput>,
    /// <p>Information about a configuration change happening on the domain.</p>
    #[doc(hidden)]
    pub change_progress_details: std::option::Option<crate::model::ChangeProgressDetails>,
}
impl DomainStatus {
    /// <p>Unique identifier for the domain.</p>
    pub fn domain_id(&self) -> std::option::Option<&str> {
        self.domain_id.as_deref()
    }
    /// <p>Name of the domain. Domain names are unique across all domains owned by the same account within an Amazon Web Services Region.</p>
    pub fn domain_name(&self) -> std::option::Option<&str> {
        self.domain_name.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the domain. For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html">IAM identifiers </a> in the <i>AWS Identity and Access Management User Guide</i>.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>Creation status of an OpenSearch Service domain. True if domain creation is complete. False if domain creation is still in progress.</p>
    pub fn created(&self) -> std::option::Option<bool> {
        self.created
    }
    /// <p>Deletion status of an OpenSearch Service domain. True if domain deletion is complete. False if domain deletion is still in progress. Once deletion is complete, the status of the domain is no longer returned.</p>
    pub fn deleted(&self) -> std::option::Option<bool> {
        self.deleted
    }
    /// <p>Domain-specific endpoint used to submit index, search, and data upload requests to the domain.</p>
    pub fn endpoint(&self) -> std::option::Option<&str> {
        self.endpoint.as_deref()
    }
    /// <p>The key-value pair that exists if the OpenSearch Service domain uses VPC endpoints.. Example <code>key, value</code>: <code>'vpc','vpc-endpoint-h2dsd34efgyghrtguk5gt6j2foh4.us-east-1.es.amazonaws.com'</code>.</p>
    pub fn endpoints(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.endpoints.as_ref()
    }
    /// <p>The status of the domain configuration. True if OpenSearch Service is processing configuration changes. False if the configuration is active.</p>
    pub fn processing(&self) -> std::option::Option<bool> {
        self.processing
    }
    /// <p>The status of a domain version upgrade to a new version of OpenSearch or Elasticsearch. True if OpenSearch Service is in the process of a version upgrade. False if the configuration is active.</p>
    pub fn upgrade_processing(&self) -> std::option::Option<bool> {
        self.upgrade_processing
    }
    /// <p>Version of OpenSearch or Elasticsearch that the domain is running, in the format <code>Elasticsearch_X.Y</code> or <code>OpenSearch_X.Y</code>.</p>
    pub fn engine_version(&self) -> std::option::Option<&str> {
        self.engine_version.as_deref()
    }
    /// <p>Container for the cluster configuration of the domain.</p>
    pub fn cluster_config(&self) -> std::option::Option<&crate::model::ClusterConfig> {
        self.cluster_config.as_ref()
    }
    /// <p>Container for EBS-based storage settings for the domain.</p>
    pub fn ebs_options(&self) -> std::option::Option<&crate::model::EbsOptions> {
        self.ebs_options.as_ref()
    }
    /// <p>Identity and Access Management (IAM) policy document specifying the access policies for the domain.</p>
    pub fn access_policies(&self) -> std::option::Option<&str> {
        self.access_policies.as_deref()
    }
    /// <p>DEPRECATED. Container for parameters required to configure automated snapshots of domain indexes.</p>
    pub fn snapshot_options(&self) -> std::option::Option<&crate::model::SnapshotOptions> {
        self.snapshot_options.as_ref()
    }
    /// <p>The VPC configuration for the domain.</p>
    pub fn vpc_options(&self) -> std::option::Option<&crate::model::VpcDerivedInfo> {
        self.vpc_options.as_ref()
    }
    /// <p>Key-value pairs to configure Amazon Cognito authentication for OpenSearch Dashboards.</p>
    pub fn cognito_options(&self) -> std::option::Option<&crate::model::CognitoOptions> {
        self.cognito_options.as_ref()
    }
    /// <p>Encryption at rest settings for the domain.</p>
    pub fn encryption_at_rest_options(
        &self,
    ) -> std::option::Option<&crate::model::EncryptionAtRestOptions> {
        self.encryption_at_rest_options.as_ref()
    }
    /// <p>Whether node-to-node encryption is enabled or disabled.</p>
    pub fn node_to_node_encryption_options(
        &self,
    ) -> std::option::Option<&crate::model::NodeToNodeEncryptionOptions> {
        self.node_to_node_encryption_options.as_ref()
    }
    /// <p>Key-value pairs that specify advanced configuration options.</p>
    pub fn advanced_options(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.advanced_options.as_ref()
    }
    /// <p>Log publishing options for the domain.</p>
    pub fn log_publishing_options(
        &self,
    ) -> std::option::Option<
        &std::collections::HashMap<crate::model::LogType, crate::model::LogPublishingOption>,
    > {
        self.log_publishing_options.as_ref()
    }
    /// <p>The current status of the domain's service software.</p>
    pub fn service_software_options(
        &self,
    ) -> std::option::Option<&crate::model::ServiceSoftwareOptions> {
        self.service_software_options.as_ref()
    }
    /// <p>Additional options for the domain endpoint, such as whether to require HTTPS for all traffic.</p>
    pub fn domain_endpoint_options(
        &self,
    ) -> std::option::Option<&crate::model::DomainEndpointOptions> {
        self.domain_endpoint_options.as_ref()
    }
    /// <p>Settings for fine-grained access control.</p>
    pub fn advanced_security_options(
        &self,
    ) -> std::option::Option<&crate::model::AdvancedSecurityOptions> {
        self.advanced_security_options.as_ref()
    }
    /// <p>Auto-Tune settings for the domain.</p>
    pub fn auto_tune_options(&self) -> std::option::Option<&crate::model::AutoTuneOptionsOutput> {
        self.auto_tune_options.as_ref()
    }
    /// <p>Information about a configuration change happening on the domain.</p>
    pub fn change_progress_details(
        &self,
    ) -> std::option::Option<&crate::model::ChangeProgressDetails> {
        self.change_progress_details.as_ref()
    }
}
/// See [`DomainStatus`](crate::model::DomainStatus).
pub mod domain_status {

    /// A builder for [`DomainStatus`](crate::model::DomainStatus).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain_id: std::option::Option<std::string::String>,
        pub(crate) domain_name: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) created: std::option::Option<bool>,
        pub(crate) deleted: std::option::Option<bool>,
        pub(crate) endpoint: std::option::Option<std::string::String>,
        pub(crate) endpoints: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) processing: std::option::Option<bool>,
        pub(crate) upgrade_processing: std::option::Option<bool>,
        pub(crate) engine_version: std::option::Option<std::string::String>,
        pub(crate) cluster_config: std::option::Option<crate::model::ClusterConfig>,
        pub(crate) ebs_options: std::option::Option<crate::model::EbsOptions>,
        pub(crate) access_policies: std::option::Option<std::string::String>,
        pub(crate) snapshot_options: std::option::Option<crate::model::SnapshotOptions>,
        pub(crate) vpc_options: std::option::Option<crate::model::VpcDerivedInfo>,
        pub(crate) cognito_options: std::option::Option<crate::model::CognitoOptions>,
        pub(crate) encryption_at_rest_options:
            std::option::Option<crate::model::EncryptionAtRestOptions>,
        pub(crate) node_to_node_encryption_options:
            std::option::Option<crate::model::NodeToNodeEncryptionOptions>,
        pub(crate) advanced_options: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) log_publishing_options: std::option::Option<
            std::collections::HashMap<crate::model::LogType, crate::model::LogPublishingOption>,
        >,
        pub(crate) service_software_options:
            std::option::Option<crate::model::ServiceSoftwareOptions>,
        pub(crate) domain_endpoint_options:
            std::option::Option<crate::model::DomainEndpointOptions>,
        pub(crate) advanced_security_options:
            std::option::Option<crate::model::AdvancedSecurityOptions>,
        pub(crate) auto_tune_options: std::option::Option<crate::model::AutoTuneOptionsOutput>,
        pub(crate) change_progress_details:
            std::option::Option<crate::model::ChangeProgressDetails>,
    }
    impl Builder {
        /// <p>Unique identifier for the domain.</p>
        pub fn domain_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_id = Some(input.into());
            self
        }
        /// <p>Unique identifier for the domain.</p>
        pub fn set_domain_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_id = input;
            self
        }
        /// <p>Name of the domain. Domain names are unique across all domains owned by the same account within an Amazon Web Services Region.</p>
        pub fn domain_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_name = Some(input.into());
            self
        }
        /// <p>Name of the domain. Domain names are unique across all domains owned by the same account within an Amazon Web Services Region.</p>
        pub fn set_domain_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the domain. For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html">IAM identifiers </a> in the <i>AWS Identity and Access Management User Guide</i>.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the domain. For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html">IAM identifiers </a> in the <i>AWS Identity and Access Management User Guide</i>.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>Creation status of an OpenSearch Service domain. True if domain creation is complete. False if domain creation is still in progress.</p>
        pub fn created(mut self, input: bool) -> Self {
            self.created = Some(input);
            self
        }
        /// <p>Creation status of an OpenSearch Service domain. True if domain creation is complete. False if domain creation is still in progress.</p>
        pub fn set_created(mut self, input: std::option::Option<bool>) -> Self {
            self.created = input;
            self
        }
        /// <p>Deletion status of an OpenSearch Service domain. True if domain deletion is complete. False if domain deletion is still in progress. Once deletion is complete, the status of the domain is no longer returned.</p>
        pub fn deleted(mut self, input: bool) -> Self {
            self.deleted = Some(input);
            self
        }
        /// <p>Deletion status of an OpenSearch Service domain. True if domain deletion is complete. False if domain deletion is still in progress. Once deletion is complete, the status of the domain is no longer returned.</p>
        pub fn set_deleted(mut self, input: std::option::Option<bool>) -> Self {
            self.deleted = input;
            self
        }
        /// <p>Domain-specific endpoint used to submit index, search, and data upload requests to the domain.</p>
        pub fn endpoint(mut self, input: impl Into<std::string::String>) -> Self {
            self.endpoint = Some(input.into());
            self
        }
        /// <p>Domain-specific endpoint used to submit index, search, and data upload requests to the domain.</p>
        pub fn set_endpoint(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.endpoint = input;
            self
        }
        /// Adds a key-value pair to `endpoints`.
        ///
        /// To override the contents of this collection use [`set_endpoints`](Self::set_endpoints).
        ///
        /// <p>The key-value pair that exists if the OpenSearch Service domain uses VPC endpoints.. Example <code>key, value</code>: <code>'vpc','vpc-endpoint-h2dsd34efgyghrtguk5gt6j2foh4.us-east-1.es.amazonaws.com'</code>.</p>
        pub fn endpoints(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.endpoints.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.endpoints = Some(hash_map);
            self
        }
        /// <p>The key-value pair that exists if the OpenSearch Service domain uses VPC endpoints.. Example <code>key, value</code>: <code>'vpc','vpc-endpoint-h2dsd34efgyghrtguk5gt6j2foh4.us-east-1.es.amazonaws.com'</code>.</p>
        pub fn set_endpoints(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.endpoints = input;
            self
        }
        /// <p>The status of the domain configuration. True if OpenSearch Service is processing configuration changes. False if the configuration is active.</p>
        pub fn processing(mut self, input: bool) -> Self {
            self.processing = Some(input);
            self
        }
        /// <p>The status of the domain configuration. True if OpenSearch Service is processing configuration changes. False if the configuration is active.</p>
        pub fn set_processing(mut self, input: std::option::Option<bool>) -> Self {
            self.processing = input;
            self
        }
        /// <p>The status of a domain version upgrade to a new version of OpenSearch or Elasticsearch. True if OpenSearch Service is in the process of a version upgrade. False if the configuration is active.</p>
        pub fn upgrade_processing(mut self, input: bool) -> Self {
            self.upgrade_processing = Some(input);
            self
        }
        /// <p>The status of a domain version upgrade to a new version of OpenSearch or Elasticsearch. True if OpenSearch Service is in the process of a version upgrade. False if the configuration is active.</p>
        pub fn set_upgrade_processing(mut self, input: std::option::Option<bool>) -> Self {
            self.upgrade_processing = input;
            self
        }
        /// <p>Version of OpenSearch or Elasticsearch that the domain is running, in the format <code>Elasticsearch_X.Y</code> or <code>OpenSearch_X.Y</code>.</p>
        pub fn engine_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.engine_version = Some(input.into());
            self
        }
        /// <p>Version of OpenSearch or Elasticsearch that the domain is running, in the format <code>Elasticsearch_X.Y</code> or <code>OpenSearch_X.Y</code>.</p>
        pub fn set_engine_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.engine_version = input;
            self
        }
        /// <p>Container for the cluster configuration of the domain.</p>
        pub fn cluster_config(mut self, input: crate::model::ClusterConfig) -> Self {
            self.cluster_config = Some(input);
            self
        }
        /// <p>Container for the cluster configuration of the domain.</p>
        pub fn set_cluster_config(
            mut self,
            input: std::option::Option<crate::model::ClusterConfig>,
        ) -> Self {
            self.cluster_config = input;
            self
        }
        /// <p>Container for EBS-based storage settings for the domain.</p>
        pub fn ebs_options(mut self, input: crate::model::EbsOptions) -> Self {
            self.ebs_options = Some(input);
            self
        }
        /// <p>Container for EBS-based storage settings for the domain.</p>
        pub fn set_ebs_options(
            mut self,
            input: std::option::Option<crate::model::EbsOptions>,
        ) -> Self {
            self.ebs_options = input;
            self
        }
        /// <p>Identity and Access Management (IAM) policy document specifying the access policies for the domain.</p>
        pub fn access_policies(mut self, input: impl Into<std::string::String>) -> Self {
            self.access_policies = Some(input.into());
            self
        }
        /// <p>Identity and Access Management (IAM) policy document specifying the access policies for the domain.</p>
        pub fn set_access_policies(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.access_policies = input;
            self
        }
        /// <p>DEPRECATED. Container for parameters required to configure automated snapshots of domain indexes.</p>
        pub fn snapshot_options(mut self, input: crate::model::SnapshotOptions) -> Self {
            self.snapshot_options = Some(input);
            self
        }
        /// <p>DEPRECATED. Container for parameters required to configure automated snapshots of domain indexes.</p>
        pub fn set_snapshot_options(
            mut self,
            input: std::option::Option<crate::model::SnapshotOptions>,
        ) -> Self {
            self.snapshot_options = input;
            self
        }
        /// <p>The VPC configuration for the domain.</p>
        pub fn vpc_options(mut self, input: crate::model::VpcDerivedInfo) -> Self {
            self.vpc_options = Some(input);
            self
        }
        /// <p>The VPC configuration for the domain.</p>
        pub fn set_vpc_options(
            mut self,
            input: std::option::Option<crate::model::VpcDerivedInfo>,
        ) -> Self {
            self.vpc_options = input;
            self
        }
        /// <p>Key-value pairs to configure Amazon Cognito authentication for OpenSearch Dashboards.</p>
        pub fn cognito_options(mut self, input: crate::model::CognitoOptions) -> Self {
            self.cognito_options = Some(input);
            self
        }
        /// <p>Key-value pairs to configure Amazon Cognito authentication for OpenSearch Dashboards.</p>
        pub fn set_cognito_options(
            mut self,
            input: std::option::Option<crate::model::CognitoOptions>,
        ) -> Self {
            self.cognito_options = input;
            self
        }
        /// <p>Encryption at rest settings for the domain.</p>
        pub fn encryption_at_rest_options(
            mut self,
            input: crate::model::EncryptionAtRestOptions,
        ) -> Self {
            self.encryption_at_rest_options = Some(input);
            self
        }
        /// <p>Encryption at rest settings for the domain.</p>
        pub fn set_encryption_at_rest_options(
            mut self,
            input: std::option::Option<crate::model::EncryptionAtRestOptions>,
        ) -> Self {
            self.encryption_at_rest_options = input;
            self
        }
        /// <p>Whether node-to-node encryption is enabled or disabled.</p>
        pub fn node_to_node_encryption_options(
            mut self,
            input: crate::model::NodeToNodeEncryptionOptions,
        ) -> Self {
            self.node_to_node_encryption_options = Some(input);
            self
        }
        /// <p>Whether node-to-node encryption is enabled or disabled.</p>
        pub fn set_node_to_node_encryption_options(
            mut self,
            input: std::option::Option<crate::model::NodeToNodeEncryptionOptions>,
        ) -> Self {
            self.node_to_node_encryption_options = input;
            self
        }
        /// Adds a key-value pair to `advanced_options`.
        ///
        /// To override the contents of this collection use [`set_advanced_options`](Self::set_advanced_options).
        ///
        /// <p>Key-value pairs that specify advanced configuration options.</p>
        pub fn advanced_options(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.advanced_options.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.advanced_options = Some(hash_map);
            self
        }
        /// <p>Key-value pairs that specify advanced configuration options.</p>
        pub fn set_advanced_options(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.advanced_options = input;
            self
        }
        /// Adds a key-value pair to `log_publishing_options`.
        ///
        /// To override the contents of this collection use [`set_log_publishing_options`](Self::set_log_publishing_options).
        ///
        /// <p>Log publishing options for the domain.</p>
        pub fn log_publishing_options(
            mut self,
            k: crate::model::LogType,
            v: crate::model::LogPublishingOption,
        ) -> Self {
            let mut hash_map = self.log_publishing_options.unwrap_or_default();
            hash_map.insert(k, v);
            self.log_publishing_options = Some(hash_map);
            self
        }
        /// <p>Log publishing options for the domain.</p>
        pub fn set_log_publishing_options(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<crate::model::LogType, crate::model::LogPublishingOption>,
            >,
        ) -> Self {
            self.log_publishing_options = input;
            self
        }
        /// <p>The current status of the domain's service software.</p>
        pub fn service_software_options(
            mut self,
            input: crate::model::ServiceSoftwareOptions,
        ) -> Self {
            self.service_software_options = Some(input);
            self
        }
        /// <p>The current status of the domain's service software.</p>
        pub fn set_service_software_options(
            mut self,
            input: std::option::Option<crate::model::ServiceSoftwareOptions>,
        ) -> Self {
            self.service_software_options = input;
            self
        }
        /// <p>Additional options for the domain endpoint, such as whether to require HTTPS for all traffic.</p>
        pub fn domain_endpoint_options(
            mut self,
            input: crate::model::DomainEndpointOptions,
        ) -> Self {
            self.domain_endpoint_options = Some(input);
            self
        }
        /// <p>Additional options for the domain endpoint, such as whether to require HTTPS for all traffic.</p>
        pub fn set_domain_endpoint_options(
            mut self,
            input: std::option::Option<crate::model::DomainEndpointOptions>,
        ) -> Self {
            self.domain_endpoint_options = input;
            self
        }
        /// <p>Settings for fine-grained access control.</p>
        pub fn advanced_security_options(
            mut self,
            input: crate::model::AdvancedSecurityOptions,
        ) -> Self {
            self.advanced_security_options = Some(input);
            self
        }
        /// <p>Settings for fine-grained access control.</p>
        pub fn set_advanced_security_options(
            mut self,
            input: std::option::Option<crate::model::AdvancedSecurityOptions>,
        ) -> Self {
            self.advanced_security_options = input;
            self
        }
        /// <p>Auto-Tune settings for the domain.</p>
        pub fn auto_tune_options(mut self, input: crate::model::AutoTuneOptionsOutput) -> Self {
            self.auto_tune_options = Some(input);
            self
        }
        /// <p>Auto-Tune settings for the domain.</p>
        pub fn set_auto_tune_options(
            mut self,
            input: std::option::Option<crate::model::AutoTuneOptionsOutput>,
        ) -> Self {
            self.auto_tune_options = input;
            self
        }
        /// <p>Information about a configuration change happening on the domain.</p>
        pub fn change_progress_details(
            mut self,
            input: crate::model::ChangeProgressDetails,
        ) -> Self {
            self.change_progress_details = Some(input);
            self
        }
        /// <p>Information about a configuration change happening on the domain.</p>
        pub fn set_change_progress_details(
            mut self,
            input: std::option::Option<crate::model::ChangeProgressDetails>,
        ) -> Self {
            self.change_progress_details = input;
            self
        }
        /// Consumes the builder and constructs a [`DomainStatus`](crate::model::DomainStatus).
        pub fn build(self) -> crate::model::DomainStatus {
            crate::model::DomainStatus {
                domain_id: self.domain_id,
                domain_name: self.domain_name,
                arn: self.arn,
                created: self.created,
                deleted: self.deleted,
                endpoint: self.endpoint,
                endpoints: self.endpoints,
                processing: self.processing,
                upgrade_processing: self.upgrade_processing,
                engine_version: self.engine_version,
                cluster_config: self.cluster_config,
                ebs_options: self.ebs_options,
                access_policies: self.access_policies,
                snapshot_options: self.snapshot_options,
                vpc_options: self.vpc_options,
                cognito_options: self.cognito_options,
                encryption_at_rest_options: self.encryption_at_rest_options,
                node_to_node_encryption_options: self.node_to_node_encryption_options,
                advanced_options: self.advanced_options,
                log_publishing_options: self.log_publishing_options,
                service_software_options: self.service_software_options,
                domain_endpoint_options: self.domain_endpoint_options,
                advanced_security_options: self.advanced_security_options,
                auto_tune_options: self.auto_tune_options,
                change_progress_details: self.change_progress_details,
            }
        }
    }
}
impl DomainStatus {
    /// Creates a new builder-style object to manufacture [`DomainStatus`](crate::model::DomainStatus).
    pub fn builder() -> crate::model::domain_status::Builder {
        crate::model::domain_status::Builder::default()
    }
}

/// <p>The Auto-Tune settings for a domain, displayed when enabling or disabling Auto-Tune.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AutoTuneOptionsOutput {
    /// <p>The current state of Auto-Tune on the domain.</p>
    #[doc(hidden)]
    pub state: std::option::Option<crate::model::AutoTuneState>,
    /// <p>Any errors that occurred while enabling or disabling Auto-Tune.</p>
    #[doc(hidden)]
    pub error_message: std::option::Option<std::string::String>,
}
impl AutoTuneOptionsOutput {
    /// <p>The current state of Auto-Tune on the domain.</p>
    pub fn state(&self) -> std::option::Option<&crate::model::AutoTuneState> {
        self.state.as_ref()
    }
    /// <p>Any errors that occurred while enabling or disabling Auto-Tune.</p>
    pub fn error_message(&self) -> std::option::Option<&str> {
        self.error_message.as_deref()
    }
}
/// See [`AutoTuneOptionsOutput`](crate::model::AutoTuneOptionsOutput).
pub mod auto_tune_options_output {

    /// A builder for [`AutoTuneOptionsOutput`](crate::model::AutoTuneOptionsOutput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) state: std::option::Option<crate::model::AutoTuneState>,
        pub(crate) error_message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The current state of Auto-Tune on the domain.</p>
        pub fn state(mut self, input: crate::model::AutoTuneState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The current state of Auto-Tune on the domain.</p>
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::AutoTuneState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// <p>Any errors that occurred while enabling or disabling Auto-Tune.</p>
        pub fn error_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_message = Some(input.into());
            self
        }
        /// <p>Any errors that occurred while enabling or disabling Auto-Tune.</p>
        pub fn set_error_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.error_message = input;
            self
        }
        /// Consumes the builder and constructs a [`AutoTuneOptionsOutput`](crate::model::AutoTuneOptionsOutput).
        pub fn build(self) -> crate::model::AutoTuneOptionsOutput {
            crate::model::AutoTuneOptionsOutput {
                state: self.state,
                error_message: self.error_message,
            }
        }
    }
}
impl AutoTuneOptionsOutput {
    /// Creates a new builder-style object to manufacture [`AutoTuneOptionsOutput`](crate::model::AutoTuneOptionsOutput).
    pub fn builder() -> crate::model::auto_tune_options_output::Builder {
        crate::model::auto_tune_options_output::Builder::default()
    }
}

/// <p>The progress details of a specific domain configuration change.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ChangeProgressStatusDetails {
    /// <p>The unique change identifier associated with a specific domain configuration change.</p>
    #[doc(hidden)]
    pub change_id: std::option::Option<std::string::String>,
    /// <p>The time at which the configuration change is made on the domain.</p>
    #[doc(hidden)]
    pub start_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The overall status of the domain configuration change.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::OverallChangeStatus>,
    /// <p>The list of properties in the domain configuration change that are still pending.</p>
    #[doc(hidden)]
    pub pending_properties: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The list of properties in the domain configuration change that have completed.</p>
    #[doc(hidden)]
    pub completed_properties: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The total number of stages required for the configuration change.</p>
    #[doc(hidden)]
    pub total_number_of_stages: i32,
    /// <p>The specific stages that the domain is going through to perform the configuration change.</p>
    #[doc(hidden)]
    pub change_progress_stages:
        std::option::Option<std::vec::Vec<crate::model::ChangeProgressStage>>,
}
impl ChangeProgressStatusDetails {
    /// <p>The unique change identifier associated with a specific domain configuration change.</p>
    pub fn change_id(&self) -> std::option::Option<&str> {
        self.change_id.as_deref()
    }
    /// <p>The time at which the configuration change is made on the domain.</p>
    pub fn start_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.start_time.as_ref()
    }
    /// <p>The overall status of the domain configuration change.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::OverallChangeStatus> {
        self.status.as_ref()
    }
    /// <p>The list of properties in the domain configuration change that are still pending.</p>
    pub fn pending_properties(&self) -> std::option::Option<&[std::string::String]> {
        self.pending_properties.as_deref()
    }
    /// <p>The list of properties in the domain configuration change that have completed.</p>
    pub fn completed_properties(&self) -> std::option::Option<&[std::string::String]> {
        self.completed_properties.as_deref()
    }
    /// <p>The total number of stages required for the configuration change.</p>
    pub fn total_number_of_stages(&self) -> i32 {
        self.total_number_of_stages
    }
    /// <p>The specific stages that the domain is going through to perform the configuration change.</p>
    pub fn change_progress_stages(
        &self,
    ) -> std::option::Option<&[crate::model::ChangeProgressStage]> {
        self.change_progress_stages.as_deref()
    }
}
/// See [`ChangeProgressStatusDetails`](crate::model::ChangeProgressStatusDetails).
pub mod change_progress_status_details {

    /// A builder for [`ChangeProgressStatusDetails`](crate::model::ChangeProgressStatusDetails).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) change_id: std::option::Option<std::string::String>,
        pub(crate) start_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) status: std::option::Option<crate::model::OverallChangeStatus>,
        pub(crate) pending_properties: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) completed_properties: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) total_number_of_stages: std::option::Option<i32>,
        pub(crate) change_progress_stages:
            std::option::Option<std::vec::Vec<crate::model::ChangeProgressStage>>,
    }
    impl Builder {
        /// <p>The unique change identifier associated with a specific domain configuration change.</p>
        pub fn change_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.change_id = Some(input.into());
            self
        }
        /// <p>The unique change identifier associated with a specific domain configuration change.</p>
        pub fn set_change_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.change_id = input;
            self
        }
        /// <p>The time at which the configuration change is made on the domain.</p>
        pub fn start_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.start_time = Some(input);
            self
        }
        /// <p>The time at which the configuration change is made on the domain.</p>
        pub fn set_start_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.start_time = input;
            self
        }
        /// <p>The overall status of the domain configuration change.</p>
        pub fn status(mut self, input: crate::model::OverallChangeStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The overall status of the domain configuration change.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::OverallChangeStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// Appends an item to `pending_properties`.
        ///
        /// To override the contents of this collection use [`set_pending_properties`](Self::set_pending_properties).
        ///
        /// <p>The list of properties in the domain configuration change that are still pending.</p>
        pub fn pending_properties(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.pending_properties.unwrap_or_default();
            v.push(input.into());
            self.pending_properties = Some(v);
            self
        }
        /// <p>The list of properties in the domain configuration change that are still pending.</p>
        pub fn set_pending_properties(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.pending_properties = input;
            self
        }
        /// Appends an item to `completed_properties`.
        ///
        /// To override the contents of this collection use [`set_completed_properties`](Self::set_completed_properties).
        ///
        /// <p>The list of properties in the domain configuration change that have completed.</p>
        pub fn completed_properties(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.completed_properties.unwrap_or_default();
            v.push(input.into());
            self.completed_properties = Some(v);
            self
        }
        /// <p>The list of properties in the domain configuration change that have completed.</p>
        pub fn set_completed_properties(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.completed_properties = input;
            self
        }
        /// <p>The total number of stages required for the configuration change.</p>
        pub fn total_number_of_stages(mut self, input: i32) -> Self {
            self.total_number_of_stages = Some(input);
            self
        }
        /// <p>The total number of stages required for the configuration change.</p>
        pub fn set_total_number_of_stages(mut self, input: std::option::Option<i32>) -> Self {
            self.total_number_of_stages = input;
            self
        }
        /// Appends an item to `change_progress_stages`.
        ///
        /// To override the contents of this collection use [`set_change_progress_stages`](Self::set_change_progress_stages).
        ///
        /// <p>The specific stages that the domain is going through to perform the configuration change.</p>
        pub fn change_progress_stages(mut self, input: crate::model::ChangeProgressStage) -> Self {
            let mut v = self.change_progress_stages.unwrap_or_default();
            v.push(input);
            self.change_progress_stages = Some(v);
            self
        }
        /// <p>The specific stages that the domain is going through to perform the configuration change.</p>
        pub fn set_change_progress_stages(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ChangeProgressStage>>,
        ) -> Self {
            self.change_progress_stages = input;
            self
        }
        /// Consumes the builder and constructs a [`ChangeProgressStatusDetails`](crate::model::ChangeProgressStatusDetails).
        pub fn build(self) -> crate::model::ChangeProgressStatusDetails {
            crate::model::ChangeProgressStatusDetails {
                change_id: self.change_id,
                start_time: self.start_time,
                status: self.status,
                pending_properties: self.pending_properties,
                completed_properties: self.completed_properties,
                total_number_of_stages: self.total_number_of_stages.unwrap_or_default(),
                change_progress_stages: self.change_progress_stages,
            }
        }
    }
}
impl ChangeProgressStatusDetails {
    /// Creates a new builder-style object to manufacture [`ChangeProgressStatusDetails`](crate::model::ChangeProgressStatusDetails).
    pub fn builder() -> crate::model::change_progress_status_details::Builder {
        crate::model::change_progress_status_details::Builder::default()
    }
}

/// <p>Progress details for each stage of a domain update.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ChangeProgressStage {
    /// <p>The name of the stage.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The status of the stage.</p>
    #[doc(hidden)]
    pub status: std::option::Option<std::string::String>,
    /// <p>The description of the stage.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The most recent updated timestamp of the stage.</p>
    #[doc(hidden)]
    pub last_updated: std::option::Option<aws_smithy_types::DateTime>,
}
impl ChangeProgressStage {
    /// <p>The name of the stage.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The status of the stage.</p>
    pub fn status(&self) -> std::option::Option<&str> {
        self.status.as_deref()
    }
    /// <p>The description of the stage.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The most recent updated timestamp of the stage.</p>
    pub fn last_updated(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_updated.as_ref()
    }
}
/// See [`ChangeProgressStage`](crate::model::ChangeProgressStage).
pub mod change_progress_stage {

    /// A builder for [`ChangeProgressStage`](crate::model::ChangeProgressStage).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) last_updated: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The name of the stage.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the stage.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The status of the stage.</p>
        pub fn status(mut self, input: impl Into<std::string::String>) -> Self {
            self.status = Some(input.into());
            self
        }
        /// <p>The status of the stage.</p>
        pub fn set_status(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.status = input;
            self
        }
        /// <p>The description of the stage.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the stage.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The most recent updated timestamp of the stage.</p>
        pub fn last_updated(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_updated = Some(input);
            self
        }
        /// <p>The most recent updated timestamp of the stage.</p>
        pub fn set_last_updated(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_updated = input;
            self
        }
        /// Consumes the builder and constructs a [`ChangeProgressStage`](crate::model::ChangeProgressStage).
        pub fn build(self) -> crate::model::ChangeProgressStage {
            crate::model::ChangeProgressStage {
                name: self.name,
                status: self.status,
                description: self.description,
                last_updated: self.last_updated,
            }
        }
    }
}
impl ChangeProgressStage {
    /// Creates a new builder-style object to manufacture [`ChangeProgressStage`](crate::model::ChangeProgressStage).
    pub fn builder() -> crate::model::change_progress_stage::Builder {
        crate::model::change_progress_stage::Builder::default()
    }
}

/// When writing a match expression against `OverallChangeStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let overallchangestatus = unimplemented!();
/// match overallchangestatus {
///     OverallChangeStatus::Completed => { /* ... */ },
///     OverallChangeStatus::Failed => { /* ... */ },
///     OverallChangeStatus::Pending => { /* ... */ },
///     OverallChangeStatus::Processing => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `overallchangestatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `OverallChangeStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `OverallChangeStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `OverallChangeStatus::NewFeature` is defined.
/// Specifically, when `overallchangestatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `OverallChangeStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
/// <p>The overall status value of the domain configuration change.</p>
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum OverallChangeStatus {
    #[allow(missing_docs)] // documentation missing in model
    Completed,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    Pending,
    #[allow(missing_docs)] // documentation missing in model
    Processing,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for OverallChangeStatus {
    fn from(s: &str) -> Self {
        match s {
            "COMPLETED" => OverallChangeStatus::Completed,
            "FAILED" => OverallChangeStatus::Failed,
            "PENDING" => OverallChangeStatus::Pending,
            "PROCESSING" => OverallChangeStatus::Processing,
            other => {
                OverallChangeStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for OverallChangeStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(OverallChangeStatus::from(s))
    }
}
impl OverallChangeStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            OverallChangeStatus::Completed => "COMPLETED",
            OverallChangeStatus::Failed => "FAILED",
            OverallChangeStatus::Pending => "PENDING",
            OverallChangeStatus::Processing => "PROCESSING",
            OverallChangeStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["COMPLETED", "FAILED", "PENDING", "PROCESSING"]
    }
}
impl AsRef<str> for OverallChangeStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Information about an Auto-Tune action. For more information, see <a href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/auto-tune.html">Auto-Tune for Amazon OpenSearch Service</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AutoTune {
    /// <p>The type of Auto-Tune action.</p>
    #[doc(hidden)]
    pub auto_tune_type: std::option::Option<crate::model::AutoTuneType>,
    /// <p>Details about an Auto-Tune action.</p>
    #[doc(hidden)]
    pub auto_tune_details: std::option::Option<crate::model::AutoTuneDetails>,
}
impl AutoTune {
    /// <p>The type of Auto-Tune action.</p>
    pub fn auto_tune_type(&self) -> std::option::Option<&crate::model::AutoTuneType> {
        self.auto_tune_type.as_ref()
    }
    /// <p>Details about an Auto-Tune action.</p>
    pub fn auto_tune_details(&self) -> std::option::Option<&crate::model::AutoTuneDetails> {
        self.auto_tune_details.as_ref()
    }
}
/// See [`AutoTune`](crate::model::AutoTune).
pub mod auto_tune {

    /// A builder for [`AutoTune`](crate::model::AutoTune).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) auto_tune_type: std::option::Option<crate::model::AutoTuneType>,
        pub(crate) auto_tune_details: std::option::Option<crate::model::AutoTuneDetails>,
    }
    impl Builder {
        /// <p>The type of Auto-Tune action.</p>
        pub fn auto_tune_type(mut self, input: crate::model::AutoTuneType) -> Self {
            self.auto_tune_type = Some(input);
            self
        }
        /// <p>The type of Auto-Tune action.</p>
        pub fn set_auto_tune_type(
            mut self,
            input: std::option::Option<crate::model::AutoTuneType>,
        ) -> Self {
            self.auto_tune_type = input;
            self
        }
        /// <p>Details about an Auto-Tune action.</p>
        pub fn auto_tune_details(mut self, input: crate::model::AutoTuneDetails) -> Self {
            self.auto_tune_details = Some(input);
            self
        }
        /// <p>Details about an Auto-Tune action.</p>
        pub fn set_auto_tune_details(
            mut self,
            input: std::option::Option<crate::model::AutoTuneDetails>,
        ) -> Self {
            self.auto_tune_details = input;
            self
        }
        /// Consumes the builder and constructs a [`AutoTune`](crate::model::AutoTune).
        pub fn build(self) -> crate::model::AutoTune {
            crate::model::AutoTune {
                auto_tune_type: self.auto_tune_type,
                auto_tune_details: self.auto_tune_details,
            }
        }
    }
}
impl AutoTune {
    /// Creates a new builder-style object to manufacture [`AutoTune`](crate::model::AutoTune).
    pub fn builder() -> crate::model::auto_tune::Builder {
        crate::model::auto_tune::Builder::default()
    }
}

/// <p>Specifies details about a scheduled Auto-Tune action. For more information, see <a href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/auto-tune.html">Auto-Tune for Amazon OpenSearch Service</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AutoTuneDetails {
    /// <p>Container for details about a scheduled Auto-Tune action.</p>
    #[doc(hidden)]
    pub scheduled_auto_tune_details: std::option::Option<crate::model::ScheduledAutoTuneDetails>,
}
impl AutoTuneDetails {
    /// <p>Container for details about a scheduled Auto-Tune action.</p>
    pub fn scheduled_auto_tune_details(
        &self,
    ) -> std::option::Option<&crate::model::ScheduledAutoTuneDetails> {
        self.scheduled_auto_tune_details.as_ref()
    }
}
/// See [`AutoTuneDetails`](crate::model::AutoTuneDetails).
pub mod auto_tune_details {

    /// A builder for [`AutoTuneDetails`](crate::model::AutoTuneDetails).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) scheduled_auto_tune_details:
            std::option::Option<crate::model::ScheduledAutoTuneDetails>,
    }
    impl Builder {
        /// <p>Container for details about a scheduled Auto-Tune action.</p>
        pub fn scheduled_auto_tune_details(
            mut self,
            input: crate::model::ScheduledAutoTuneDetails,
        ) -> Self {
            self.scheduled_auto_tune_details = Some(input);
            self
        }
        /// <p>Container for details about a scheduled Auto-Tune action.</p>
        pub fn set_scheduled_auto_tune_details(
            mut self,
            input: std::option::Option<crate::model::ScheduledAutoTuneDetails>,
        ) -> Self {
            self.scheduled_auto_tune_details = input;
            self
        }
        /// Consumes the builder and constructs a [`AutoTuneDetails`](crate::model::AutoTuneDetails).
        pub fn build(self) -> crate::model::AutoTuneDetails {
            crate::model::AutoTuneDetails {
                scheduled_auto_tune_details: self.scheduled_auto_tune_details,
            }
        }
    }
}
impl AutoTuneDetails {
    /// Creates a new builder-style object to manufacture [`AutoTuneDetails`](crate::model::AutoTuneDetails).
    pub fn builder() -> crate::model::auto_tune_details::Builder {
        crate::model::auto_tune_details::Builder::default()
    }
}

/// <p>Specifies details about a scheduled Auto-Tune action. For more information, see <a href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/auto-tune.html">Auto-Tune for Amazon OpenSearch Service</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ScheduledAutoTuneDetails {
    /// <p>The date and time when the Auto-Tune action is scheduled for the domain.</p>
    #[doc(hidden)]
    pub date: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The type of Auto-Tune action.</p>
    #[doc(hidden)]
    pub action_type: std::option::Option<crate::model::ScheduledAutoTuneActionType>,
    /// <p>A description of the Auto-Tune action.</p>
    #[doc(hidden)]
    pub action: std::option::Option<std::string::String>,
    /// <p>The severity of the Auto-Tune action. Valid values are <code>LOW</code>, <code>MEDIUM</code>, and <code>HIGH</code>.</p>
    #[doc(hidden)]
    pub severity: std::option::Option<crate::model::ScheduledAutoTuneSeverityType>,
}
impl ScheduledAutoTuneDetails {
    /// <p>The date and time when the Auto-Tune action is scheduled for the domain.</p>
    pub fn date(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.date.as_ref()
    }
    /// <p>The type of Auto-Tune action.</p>
    pub fn action_type(&self) -> std::option::Option<&crate::model::ScheduledAutoTuneActionType> {
        self.action_type.as_ref()
    }
    /// <p>A description of the Auto-Tune action.</p>
    pub fn action(&self) -> std::option::Option<&str> {
        self.action.as_deref()
    }
    /// <p>The severity of the Auto-Tune action. Valid values are <code>LOW</code>, <code>MEDIUM</code>, and <code>HIGH</code>.</p>
    pub fn severity(&self) -> std::option::Option<&crate::model::ScheduledAutoTuneSeverityType> {
        self.severity.as_ref()
    }
}
/// See [`ScheduledAutoTuneDetails`](crate::model::ScheduledAutoTuneDetails).
pub mod scheduled_auto_tune_details {

    /// A builder for [`ScheduledAutoTuneDetails`](crate::model::ScheduledAutoTuneDetails).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) date: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) action_type: std::option::Option<crate::model::ScheduledAutoTuneActionType>,
        pub(crate) action: std::option::Option<std::string::String>,
        pub(crate) severity: std::option::Option<crate::model::ScheduledAutoTuneSeverityType>,
    }
    impl Builder {
        /// <p>The date and time when the Auto-Tune action is scheduled for the domain.</p>
        pub fn date(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.date = Some(input);
            self
        }
        /// <p>The date and time when the Auto-Tune action is scheduled for the domain.</p>
        pub fn set_date(mut self, input: std::option::Option<aws_smithy_types::DateTime>) -> Self {
            self.date = input;
            self
        }
        /// <p>The type of Auto-Tune action.</p>
        pub fn action_type(mut self, input: crate::model::ScheduledAutoTuneActionType) -> Self {
            self.action_type = Some(input);
            self
        }
        /// <p>The type of Auto-Tune action.</p>
        pub fn set_action_type(
            mut self,
            input: std::option::Option<crate::model::ScheduledAutoTuneActionType>,
        ) -> Self {
            self.action_type = input;
            self
        }
        /// <p>A description of the Auto-Tune action.</p>
        pub fn action(mut self, input: impl Into<std::string::String>) -> Self {
            self.action = Some(input.into());
            self
        }
        /// <p>A description of the Auto-Tune action.</p>
        pub fn set_action(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.action = input;
            self
        }
        /// <p>The severity of the Auto-Tune action. Valid values are <code>LOW</code>, <code>MEDIUM</code>, and <code>HIGH</code>.</p>
        pub fn severity(mut self, input: crate::model::ScheduledAutoTuneSeverityType) -> Self {
            self.severity = Some(input);
            self
        }
        /// <p>The severity of the Auto-Tune action. Valid values are <code>LOW</code>, <code>MEDIUM</code>, and <code>HIGH</code>.</p>
        pub fn set_severity(
            mut self,
            input: std::option::Option<crate::model::ScheduledAutoTuneSeverityType>,
        ) -> Self {
            self.severity = input;
            self
        }
        /// Consumes the builder and constructs a [`ScheduledAutoTuneDetails`](crate::model::ScheduledAutoTuneDetails).
        pub fn build(self) -> crate::model::ScheduledAutoTuneDetails {
            crate::model::ScheduledAutoTuneDetails {
                date: self.date,
                action_type: self.action_type,
                action: self.action,
                severity: self.severity,
            }
        }
    }
}
impl ScheduledAutoTuneDetails {
    /// Creates a new builder-style object to manufacture [`ScheduledAutoTuneDetails`](crate::model::ScheduledAutoTuneDetails).
    pub fn builder() -> crate::model::scheduled_auto_tune_details::Builder {
        crate::model::scheduled_auto_tune_details::Builder::default()
    }
}

/// When writing a match expression against `ScheduledAutoTuneSeverityType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let scheduledautotuneseveritytype = unimplemented!();
/// match scheduledautotuneseveritytype {
///     ScheduledAutoTuneSeverityType::High => { /* ... */ },
///     ScheduledAutoTuneSeverityType::Low => { /* ... */ },
///     ScheduledAutoTuneSeverityType::Medium => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `scheduledautotuneseveritytype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ScheduledAutoTuneSeverityType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ScheduledAutoTuneSeverityType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ScheduledAutoTuneSeverityType::NewFeature` is defined.
/// Specifically, when `scheduledautotuneseveritytype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ScheduledAutoTuneSeverityType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
/// <p>The Auto-Tune action severity.</p>
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ScheduledAutoTuneSeverityType {
    #[allow(missing_docs)] // documentation missing in model
    High,
    #[allow(missing_docs)] // documentation missing in model
    Low,
    #[allow(missing_docs)] // documentation missing in model
    Medium,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ScheduledAutoTuneSeverityType {
    fn from(s: &str) -> Self {
        match s {
            "HIGH" => ScheduledAutoTuneSeverityType::High,
            "LOW" => ScheduledAutoTuneSeverityType::Low,
            "MEDIUM" => ScheduledAutoTuneSeverityType::Medium,
            other => ScheduledAutoTuneSeverityType::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for ScheduledAutoTuneSeverityType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ScheduledAutoTuneSeverityType::from(s))
    }
}
impl ScheduledAutoTuneSeverityType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ScheduledAutoTuneSeverityType::High => "HIGH",
            ScheduledAutoTuneSeverityType::Low => "LOW",
            ScheduledAutoTuneSeverityType::Medium => "MEDIUM",
            ScheduledAutoTuneSeverityType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["HIGH", "LOW", "MEDIUM"]
    }
}
impl AsRef<str> for ScheduledAutoTuneSeverityType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `ScheduledAutoTuneActionType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let scheduledautotuneactiontype = unimplemented!();
/// match scheduledautotuneactiontype {
///     ScheduledAutoTuneActionType::JvmHeapSizeTuning => { /* ... */ },
///     ScheduledAutoTuneActionType::JvmYoungGenTuning => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `scheduledautotuneactiontype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ScheduledAutoTuneActionType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ScheduledAutoTuneActionType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ScheduledAutoTuneActionType::NewFeature` is defined.
/// Specifically, when `scheduledautotuneactiontype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ScheduledAutoTuneActionType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
/// <p>The Auto-Tune action type.</p>
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ScheduledAutoTuneActionType {
    #[allow(missing_docs)] // documentation missing in model
    JvmHeapSizeTuning,
    #[allow(missing_docs)] // documentation missing in model
    JvmYoungGenTuning,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ScheduledAutoTuneActionType {
    fn from(s: &str) -> Self {
        match s {
            "JVM_HEAP_SIZE_TUNING" => ScheduledAutoTuneActionType::JvmHeapSizeTuning,
            "JVM_YOUNG_GEN_TUNING" => ScheduledAutoTuneActionType::JvmYoungGenTuning,
            other => ScheduledAutoTuneActionType::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for ScheduledAutoTuneActionType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ScheduledAutoTuneActionType::from(s))
    }
}
impl ScheduledAutoTuneActionType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ScheduledAutoTuneActionType::JvmHeapSizeTuning => "JVM_HEAP_SIZE_TUNING",
            ScheduledAutoTuneActionType::JvmYoungGenTuning => "JVM_YOUNG_GEN_TUNING",
            ScheduledAutoTuneActionType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["JVM_HEAP_SIZE_TUNING", "JVM_YOUNG_GEN_TUNING"]
    }
}
impl AsRef<str> for ScheduledAutoTuneActionType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `AutoTuneType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let autotunetype = unimplemented!();
/// match autotunetype {
///     AutoTuneType::ScheduledAction => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `autotunetype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `AutoTuneType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `AutoTuneType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `AutoTuneType::NewFeature` is defined.
/// Specifically, when `autotunetype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `AutoTuneType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
/// <p>Specifies the Auto-Tune type. Valid value is SCHEDULED_ACTION.</p>
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AutoTuneType {
    #[allow(missing_docs)] // documentation missing in model
    ScheduledAction,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for AutoTuneType {
    fn from(s: &str) -> Self {
        match s {
            "SCHEDULED_ACTION" => AutoTuneType::ScheduledAction,
            other => AutoTuneType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for AutoTuneType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AutoTuneType::from(s))
    }
}
impl AutoTuneType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            AutoTuneType::ScheduledAction => "SCHEDULED_ACTION",
            AutoTuneType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["SCHEDULED_ACTION"]
    }
}
impl AsRef<str> for AutoTuneType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Options for configuring Auto-Tune. For more information, see <a href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/auto-tune.html">Auto-Tune for Amazon OpenSearch Service</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AutoTuneOptionsInput {
    /// <p>Whether Auto-Tune is enabled or disabled.</p>
    #[doc(hidden)]
    pub desired_state: std::option::Option<crate::model::AutoTuneDesiredState>,
    /// <p>A list of maintenance schedules during which Auto-Tune can deploy changes. Maintenance schedules are overwrite, not append. If your request includes no schedules, the request deletes all existing schedules. To preserve existing schedules, make a call to <code>DescribeDomainConfig</code> first and use the <code>MaintenanceSchedules</code> portion of the response as the basis for this section.</p>
    #[doc(hidden)]
    pub maintenance_schedules:
        std::option::Option<std::vec::Vec<crate::model::AutoTuneMaintenanceSchedule>>,
}
impl AutoTuneOptionsInput {
    /// <p>Whether Auto-Tune is enabled or disabled.</p>
    pub fn desired_state(&self) -> std::option::Option<&crate::model::AutoTuneDesiredState> {
        self.desired_state.as_ref()
    }
    /// <p>A list of maintenance schedules during which Auto-Tune can deploy changes. Maintenance schedules are overwrite, not append. If your request includes no schedules, the request deletes all existing schedules. To preserve existing schedules, make a call to <code>DescribeDomainConfig</code> first and use the <code>MaintenanceSchedules</code> portion of the response as the basis for this section.</p>
    pub fn maintenance_schedules(
        &self,
    ) -> std::option::Option<&[crate::model::AutoTuneMaintenanceSchedule]> {
        self.maintenance_schedules.as_deref()
    }
}
/// See [`AutoTuneOptionsInput`](crate::model::AutoTuneOptionsInput).
pub mod auto_tune_options_input {

    /// A builder for [`AutoTuneOptionsInput`](crate::model::AutoTuneOptionsInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) desired_state: std::option::Option<crate::model::AutoTuneDesiredState>,
        pub(crate) maintenance_schedules:
            std::option::Option<std::vec::Vec<crate::model::AutoTuneMaintenanceSchedule>>,
    }
    impl Builder {
        /// <p>Whether Auto-Tune is enabled or disabled.</p>
        pub fn desired_state(mut self, input: crate::model::AutoTuneDesiredState) -> Self {
            self.desired_state = Some(input);
            self
        }
        /// <p>Whether Auto-Tune is enabled or disabled.</p>
        pub fn set_desired_state(
            mut self,
            input: std::option::Option<crate::model::AutoTuneDesiredState>,
        ) -> Self {
            self.desired_state = input;
            self
        }
        /// Appends an item to `maintenance_schedules`.
        ///
        /// To override the contents of this collection use [`set_maintenance_schedules`](Self::set_maintenance_schedules).
        ///
        /// <p>A list of maintenance schedules during which Auto-Tune can deploy changes. Maintenance schedules are overwrite, not append. If your request includes no schedules, the request deletes all existing schedules. To preserve existing schedules, make a call to <code>DescribeDomainConfig</code> first and use the <code>MaintenanceSchedules</code> portion of the response as the basis for this section.</p>
        pub fn maintenance_schedules(
            mut self,
            input: crate::model::AutoTuneMaintenanceSchedule,
        ) -> Self {
            let mut v = self.maintenance_schedules.unwrap_or_default();
            v.push(input);
            self.maintenance_schedules = Some(v);
            self
        }
        /// <p>A list of maintenance schedules during which Auto-Tune can deploy changes. Maintenance schedules are overwrite, not append. If your request includes no schedules, the request deletes all existing schedules. To preserve existing schedules, make a call to <code>DescribeDomainConfig</code> first and use the <code>MaintenanceSchedules</code> portion of the response as the basis for this section.</p>
        pub fn set_maintenance_schedules(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AutoTuneMaintenanceSchedule>>,
        ) -> Self {
            self.maintenance_schedules = input;
            self
        }
        /// Consumes the builder and constructs a [`AutoTuneOptionsInput`](crate::model::AutoTuneOptionsInput).
        pub fn build(self) -> crate::model::AutoTuneOptionsInput {
            crate::model::AutoTuneOptionsInput {
                desired_state: self.desired_state,
                maintenance_schedules: self.maintenance_schedules,
            }
        }
    }
}
impl AutoTuneOptionsInput {
    /// Creates a new builder-style object to manufacture [`AutoTuneOptionsInput`](crate::model::AutoTuneOptionsInput).
    pub fn builder() -> crate::model::auto_tune_options_input::Builder {
        crate::model::auto_tune_options_input::Builder::default()
    }
}
