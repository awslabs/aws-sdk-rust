// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// <p>Allows the remote domain owner to accept an inbound cross-cluster connection request.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct AcceptInboundConnection {
    _private: (),
}
impl AcceptInboundConnection {
    /// Creates a new builder-style object to manufacture [`AcceptInboundConnectionInput`](crate::input::AcceptInboundConnectionInput)
    pub fn builder() -> crate::input::accept_inbound_connection_input::Builder {
        crate::input::accept_inbound_connection_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for AcceptInboundConnection {
    type Output = std::result::Result<
        crate::output::AcceptInboundConnectionOutput,
        crate::error::AcceptInboundConnectionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_accept_inbound_connection_error(response)
        } else {
            crate::operation_deser::parse_accept_inbound_connection_response(response)
        }
    }
}

/// <p>Attaches tags to an existing domain. Tags are a set of case-sensitive key value pairs. An
/// domain can have up to 10 tags. See
/// <a href="http://docs.aws.amazon.com/opensearch-service/latest/developerguide/managedomains.html#managedomains-awsresorcetagging" target="_blank">
/// Tagging Amazon OpenSearch Service domains</a> for more information.
/// </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct AddTags {
    _private: (),
}
impl AddTags {
    /// Creates a new builder-style object to manufacture [`AddTagsInput`](crate::input::AddTagsInput)
    pub fn builder() -> crate::input::add_tags_input::Builder {
        crate::input::add_tags_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for AddTags {
    type Output = std::result::Result<crate::output::AddTagsOutput, crate::error::AddTagsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_add_tags_error(response)
        } else {
            crate::operation_deser::parse_add_tags_response(response)
        }
    }
}

/// <p>Associates a package with an Amazon OpenSearch Service domain.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct AssociatePackage {
    _private: (),
}
impl AssociatePackage {
    /// Creates a new builder-style object to manufacture [`AssociatePackageInput`](crate::input::AssociatePackageInput)
    pub fn builder() -> crate::input::associate_package_input::Builder {
        crate::input::associate_package_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for AssociatePackage {
    type Output = std::result::Result<
        crate::output::AssociatePackageOutput,
        crate::error::AssociatePackageError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_associate_package_error(response)
        } else {
            crate::operation_deser::parse_associate_package_response(response)
        }
    }
}

/// <p>Cancels a scheduled service software update for an Amazon OpenSearch Service domain. You can only perform this operation before
/// the <code>AutomatedUpdateDate</code> and when the <code>UpdateStatus</code> is in the <code>PENDING_UPDATE</code> state.
/// </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CancelServiceSoftwareUpdate {
    _private: (),
}
impl CancelServiceSoftwareUpdate {
    /// Creates a new builder-style object to manufacture [`CancelServiceSoftwareUpdateInput`](crate::input::CancelServiceSoftwareUpdateInput)
    pub fn builder() -> crate::input::cancel_service_software_update_input::Builder {
        crate::input::cancel_service_software_update_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CancelServiceSoftwareUpdate {
    type Output = std::result::Result<
        crate::output::CancelServiceSoftwareUpdateOutput,
        crate::error::CancelServiceSoftwareUpdateError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_cancel_service_software_update_error(response)
        } else {
            crate::operation_deser::parse_cancel_service_software_update_response(response)
        }
    }
}

/// <p>Creates a new Amazon OpenSearch Service domain. For more information,
/// see <a href="http://docs.aws.amazon.com/opensearch-service/latest/developerguide/createupdatedomains.html" target="_blank">Creating and managing Amazon OpenSearch Service domains
/// </a> in the <i>Amazon OpenSearch Service Developer Guide</i>.
/// </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateDomain {
    _private: (),
}
impl CreateDomain {
    /// Creates a new builder-style object to manufacture [`CreateDomainInput`](crate::input::CreateDomainInput)
    pub fn builder() -> crate::input::create_domain_input::Builder {
        crate::input::create_domain_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateDomain {
    type Output =
        std::result::Result<crate::output::CreateDomainOutput, crate::error::CreateDomainError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_domain_error(response)
        } else {
            crate::operation_deser::parse_create_domain_response(response)
        }
    }
}

/// <p>Creates a new cross-cluster connection from a local OpenSearch domain to a remote OpenSearch domain.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateOutboundConnection {
    _private: (),
}
impl CreateOutboundConnection {
    /// Creates a new builder-style object to manufacture [`CreateOutboundConnectionInput`](crate::input::CreateOutboundConnectionInput)
    pub fn builder() -> crate::input::create_outbound_connection_input::Builder {
        crate::input::create_outbound_connection_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateOutboundConnection {
    type Output = std::result::Result<
        crate::output::CreateOutboundConnectionOutput,
        crate::error::CreateOutboundConnectionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_outbound_connection_error(response)
        } else {
            crate::operation_deser::parse_create_outbound_connection_response(response)
        }
    }
}

/// <p>Create a package for use with Amazon OpenSearch Service domains.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreatePackage {
    _private: (),
}
impl CreatePackage {
    /// Creates a new builder-style object to manufacture [`CreatePackageInput`](crate::input::CreatePackageInput)
    pub fn builder() -> crate::input::create_package_input::Builder {
        crate::input::create_package_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreatePackage {
    type Output =
        std::result::Result<crate::output::CreatePackageOutput, crate::error::CreatePackageError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_package_error(response)
        } else {
            crate::operation_deser::parse_create_package_response(response)
        }
    }
}

/// <p>Permanently deletes the specified domain and all of its data. Once a domain is deleted, it cannot
/// be recovered.
/// </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteDomain {
    _private: (),
}
impl DeleteDomain {
    /// Creates a new builder-style object to manufacture [`DeleteDomainInput`](crate::input::DeleteDomainInput)
    pub fn builder() -> crate::input::delete_domain_input::Builder {
        crate::input::delete_domain_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteDomain {
    type Output =
        std::result::Result<crate::output::DeleteDomainOutput, crate::error::DeleteDomainError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_domain_error(response)
        } else {
            crate::operation_deser::parse_delete_domain_response(response)
        }
    }
}

/// <p>Allows the remote domain owner to delete an existing inbound cross-cluster connection.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteInboundConnection {
    _private: (),
}
impl DeleteInboundConnection {
    /// Creates a new builder-style object to manufacture [`DeleteInboundConnectionInput`](crate::input::DeleteInboundConnectionInput)
    pub fn builder() -> crate::input::delete_inbound_connection_input::Builder {
        crate::input::delete_inbound_connection_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteInboundConnection {
    type Output = std::result::Result<
        crate::output::DeleteInboundConnectionOutput,
        crate::error::DeleteInboundConnectionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_inbound_connection_error(response)
        } else {
            crate::operation_deser::parse_delete_inbound_connection_response(response)
        }
    }
}

/// <p>Allows the local domain owner to delete an existing outbound cross-cluster connection.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteOutboundConnection {
    _private: (),
}
impl DeleteOutboundConnection {
    /// Creates a new builder-style object to manufacture [`DeleteOutboundConnectionInput`](crate::input::DeleteOutboundConnectionInput)
    pub fn builder() -> crate::input::delete_outbound_connection_input::Builder {
        crate::input::delete_outbound_connection_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteOutboundConnection {
    type Output = std::result::Result<
        crate::output::DeleteOutboundConnectionOutput,
        crate::error::DeleteOutboundConnectionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_outbound_connection_error(response)
        } else {
            crate::operation_deser::parse_delete_outbound_connection_response(response)
        }
    }
}

/// <p>Deletes the package.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeletePackage {
    _private: (),
}
impl DeletePackage {
    /// Creates a new builder-style object to manufacture [`DeletePackageInput`](crate::input::DeletePackageInput)
    pub fn builder() -> crate::input::delete_package_input::Builder {
        crate::input::delete_package_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeletePackage {
    type Output =
        std::result::Result<crate::output::DeletePackageOutput, crate::error::DeletePackageError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_package_error(response)
        } else {
            crate::operation_deser::parse_delete_package_response(response)
        }
    }
}

/// <p>Returns domain configuration information about the specified domain, including the domain ID,
/// domain endpoint, and domain ARN.
/// </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeDomain {
    _private: (),
}
impl DescribeDomain {
    /// Creates a new builder-style object to manufacture [`DescribeDomainInput`](crate::input::DescribeDomainInput)
    pub fn builder() -> crate::input::describe_domain_input::Builder {
        crate::input::describe_domain_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeDomain {
    type Output =
        std::result::Result<crate::output::DescribeDomainOutput, crate::error::DescribeDomainError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_domain_error(response)
        } else {
            crate::operation_deser::parse_describe_domain_response(response)
        }
    }
}

/// <p>Provides scheduled Auto-Tune action details for the domain, such as Auto-Tune action type,
/// description, severity, and scheduled date.
/// </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeDomainAutoTunes {
    _private: (),
}
impl DescribeDomainAutoTunes {
    /// Creates a new builder-style object to manufacture [`DescribeDomainAutoTunesInput`](crate::input::DescribeDomainAutoTunesInput)
    pub fn builder() -> crate::input::describe_domain_auto_tunes_input::Builder {
        crate::input::describe_domain_auto_tunes_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeDomainAutoTunes {
    type Output = std::result::Result<
        crate::output::DescribeDomainAutoTunesOutput,
        crate::error::DescribeDomainAutoTunesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_domain_auto_tunes_error(response)
        } else {
            crate::operation_deser::parse_describe_domain_auto_tunes_response(response)
        }
    }
}

/// <p>Provides cluster configuration information about the specified domain, such as the state, creation
/// date, update version, and update date for cluster options.
/// </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeDomainConfig {
    _private: (),
}
impl DescribeDomainConfig {
    /// Creates a new builder-style object to manufacture [`DescribeDomainConfigInput`](crate::input::DescribeDomainConfigInput)
    pub fn builder() -> crate::input::describe_domain_config_input::Builder {
        crate::input::describe_domain_config_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeDomainConfig {
    type Output = std::result::Result<
        crate::output::DescribeDomainConfigOutput,
        crate::error::DescribeDomainConfigError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_domain_config_error(response)
        } else {
            crate::operation_deser::parse_describe_domain_config_response(response)
        }
    }
}

/// <p>Returns domain configuration information about the specified domains, including the domain ID,
/// domain endpoint, and domain ARN.
/// </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeDomains {
    _private: (),
}
impl DescribeDomains {
    /// Creates a new builder-style object to manufacture [`DescribeDomainsInput`](crate::input::DescribeDomainsInput)
    pub fn builder() -> crate::input::describe_domains_input::Builder {
        crate::input::describe_domains_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeDomains {
    type Output = std::result::Result<
        crate::output::DescribeDomainsOutput,
        crate::error::DescribeDomainsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_domains_error(response)
        } else {
            crate::operation_deser::parse_describe_domains_response(response)
        }
    }
}

/// <p>Lists all the inbound cross-cluster connections for a remote domain.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeInboundConnections {
    _private: (),
}
impl DescribeInboundConnections {
    /// Creates a new builder-style object to manufacture [`DescribeInboundConnectionsInput`](crate::input::DescribeInboundConnectionsInput)
    pub fn builder() -> crate::input::describe_inbound_connections_input::Builder {
        crate::input::describe_inbound_connections_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeInboundConnections {
    type Output = std::result::Result<
        crate::output::DescribeInboundConnectionsOutput,
        crate::error::DescribeInboundConnectionsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_inbound_connections_error(response)
        } else {
            crate::operation_deser::parse_describe_inbound_connections_response(response)
        }
    }
}

/// <p>
/// Describe the limits for a given instance type and OpenSearch or Elasticsearch version.
/// When modifying an existing domain, specify the
/// <code>
/// <a>DomainName</a>
/// </code>
/// to see which limits you can modify.
/// </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeInstanceTypeLimits {
    _private: (),
}
impl DescribeInstanceTypeLimits {
    /// Creates a new builder-style object to manufacture [`DescribeInstanceTypeLimitsInput`](crate::input::DescribeInstanceTypeLimitsInput)
    pub fn builder() -> crate::input::describe_instance_type_limits_input::Builder {
        crate::input::describe_instance_type_limits_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeInstanceTypeLimits {
    type Output = std::result::Result<
        crate::output::DescribeInstanceTypeLimitsOutput,
        crate::error::DescribeInstanceTypeLimitsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_instance_type_limits_error(response)
        } else {
            crate::operation_deser::parse_describe_instance_type_limits_response(response)
        }
    }
}

/// <p>Lists all the outbound cross-cluster connections for a local domain.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeOutboundConnections {
    _private: (),
}
impl DescribeOutboundConnections {
    /// Creates a new builder-style object to manufacture [`DescribeOutboundConnectionsInput`](crate::input::DescribeOutboundConnectionsInput)
    pub fn builder() -> crate::input::describe_outbound_connections_input::Builder {
        crate::input::describe_outbound_connections_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeOutboundConnections {
    type Output = std::result::Result<
        crate::output::DescribeOutboundConnectionsOutput,
        crate::error::DescribeOutboundConnectionsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_outbound_connections_error(response)
        } else {
            crate::operation_deser::parse_describe_outbound_connections_response(response)
        }
    }
}

/// <p>Describes all packages available to Amazon OpenSearch Service domains. Includes options for filtering, limiting the number of results,
/// and pagination.
/// </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribePackages {
    _private: (),
}
impl DescribePackages {
    /// Creates a new builder-style object to manufacture [`DescribePackagesInput`](crate::input::DescribePackagesInput)
    pub fn builder() -> crate::input::describe_packages_input::Builder {
        crate::input::describe_packages_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribePackages {
    type Output = std::result::Result<
        crate::output::DescribePackagesOutput,
        crate::error::DescribePackagesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_packages_error(response)
        } else {
            crate::operation_deser::parse_describe_packages_response(response)
        }
    }
}

/// <p>Lists available reserved OpenSearch instance offerings.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeReservedInstanceOfferings {
    _private: (),
}
impl DescribeReservedInstanceOfferings {
    /// Creates a new builder-style object to manufacture [`DescribeReservedInstanceOfferingsInput`](crate::input::DescribeReservedInstanceOfferingsInput)
    pub fn builder() -> crate::input::describe_reserved_instance_offerings_input::Builder {
        crate::input::describe_reserved_instance_offerings_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeReservedInstanceOfferings {
    type Output = std::result::Result<
        crate::output::DescribeReservedInstanceOfferingsOutput,
        crate::error::DescribeReservedInstanceOfferingsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_reserved_instance_offerings_error(response)
        } else {
            crate::operation_deser::parse_describe_reserved_instance_offerings_response(response)
        }
    }
}

/// <p>Returns information about reserved OpenSearch instances for this account.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeReservedInstances {
    _private: (),
}
impl DescribeReservedInstances {
    /// Creates a new builder-style object to manufacture [`DescribeReservedInstancesInput`](crate::input::DescribeReservedInstancesInput)
    pub fn builder() -> crate::input::describe_reserved_instances_input::Builder {
        crate::input::describe_reserved_instances_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeReservedInstances {
    type Output = std::result::Result<
        crate::output::DescribeReservedInstancesOutput,
        crate::error::DescribeReservedInstancesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_reserved_instances_error(response)
        } else {
            crate::operation_deser::parse_describe_reserved_instances_response(response)
        }
    }
}

/// <p>Dissociates a package from the Amazon OpenSearch Service domain.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DissociatePackage {
    _private: (),
}
impl DissociatePackage {
    /// Creates a new builder-style object to manufacture [`DissociatePackageInput`](crate::input::DissociatePackageInput)
    pub fn builder() -> crate::input::dissociate_package_input::Builder {
        crate::input::dissociate_package_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DissociatePackage {
    type Output = std::result::Result<
        crate::output::DissociatePackageOutput,
        crate::error::DissociatePackageError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_dissociate_package_error(response)
        } else {
            crate::operation_deser::parse_dissociate_package_response(response)
        }
    }
}

/// <p>
/// Returns a list of upgrade-compatible versions of OpenSearch/Elasticsearch.
/// You can optionally pass a
/// <code>
/// <a>DomainName</a>
/// </code>
/// to get all upgrade-compatible versions of OpenSearch/Elasticsearch for that specific domain.
/// </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetCompatibleVersions {
    _private: (),
}
impl GetCompatibleVersions {
    /// Creates a new builder-style object to manufacture [`GetCompatibleVersionsInput`](crate::input::GetCompatibleVersionsInput)
    pub fn builder() -> crate::input::get_compatible_versions_input::Builder {
        crate::input::get_compatible_versions_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetCompatibleVersions {
    type Output = std::result::Result<
        crate::output::GetCompatibleVersionsOutput,
        crate::error::GetCompatibleVersionsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_compatible_versions_error(response)
        } else {
            crate::operation_deser::parse_get_compatible_versions_response(response)
        }
    }
}

/// <p>Returns a list of package versions, along with their creation time and commit message.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetPackageVersionHistory {
    _private: (),
}
impl GetPackageVersionHistory {
    /// Creates a new builder-style object to manufacture [`GetPackageVersionHistoryInput`](crate::input::GetPackageVersionHistoryInput)
    pub fn builder() -> crate::input::get_package_version_history_input::Builder {
        crate::input::get_package_version_history_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetPackageVersionHistory {
    type Output = std::result::Result<
        crate::output::GetPackageVersionHistoryOutput,
        crate::error::GetPackageVersionHistoryError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_package_version_history_error(response)
        } else {
            crate::operation_deser::parse_get_package_version_history_response(response)
        }
    }
}

/// <p>Retrieves the complete history of the last 10 upgrades performed on the domain.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetUpgradeHistory {
    _private: (),
}
impl GetUpgradeHistory {
    /// Creates a new builder-style object to manufacture [`GetUpgradeHistoryInput`](crate::input::GetUpgradeHistoryInput)
    pub fn builder() -> crate::input::get_upgrade_history_input::Builder {
        crate::input::get_upgrade_history_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetUpgradeHistory {
    type Output = std::result::Result<
        crate::output::GetUpgradeHistoryOutput,
        crate::error::GetUpgradeHistoryError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_upgrade_history_error(response)
        } else {
            crate::operation_deser::parse_get_upgrade_history_response(response)
        }
    }
}

/// <p>Retrieves the latest status of the last upgrade or upgrade eligibility check performed on the domain.
/// </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetUpgradeStatus {
    _private: (),
}
impl GetUpgradeStatus {
    /// Creates a new builder-style object to manufacture [`GetUpgradeStatusInput`](crate::input::GetUpgradeStatusInput)
    pub fn builder() -> crate::input::get_upgrade_status_input::Builder {
        crate::input::get_upgrade_status_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetUpgradeStatus {
    type Output = std::result::Result<
        crate::output::GetUpgradeStatusOutput,
        crate::error::GetUpgradeStatusError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_upgrade_status_error(response)
        } else {
            crate::operation_deser::parse_get_upgrade_status_response(response)
        }
    }
}

/// <p>Returns the names of all domains owned by the current user's account.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListDomainNames {
    _private: (),
}
impl ListDomainNames {
    /// Creates a new builder-style object to manufacture [`ListDomainNamesInput`](crate::input::ListDomainNamesInput)
    pub fn builder() -> crate::input::list_domain_names_input::Builder {
        crate::input::list_domain_names_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListDomainNames {
    type Output = std::result::Result<
        crate::output::ListDomainNamesOutput,
        crate::error::ListDomainNamesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_domain_names_error(response)
        } else {
            crate::operation_deser::parse_list_domain_names_response(response)
        }
    }
}

/// <p>Lists all Amazon OpenSearch Service domains associated with the package.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListDomainsForPackage {
    _private: (),
}
impl ListDomainsForPackage {
    /// Creates a new builder-style object to manufacture [`ListDomainsForPackageInput`](crate::input::ListDomainsForPackageInput)
    pub fn builder() -> crate::input::list_domains_for_package_input::Builder {
        crate::input::list_domains_for_package_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListDomainsForPackage {
    type Output = std::result::Result<
        crate::output::ListDomainsForPackageOutput,
        crate::error::ListDomainsForPackageError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_domains_for_package_error(response)
        } else {
            crate::operation_deser::parse_list_domains_for_package_response(response)
        }
    }
}

#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListInstanceTypeDetails {
    _private: (),
}
impl ListInstanceTypeDetails {
    /// Creates a new builder-style object to manufacture [`ListInstanceTypeDetailsInput`](crate::input::ListInstanceTypeDetailsInput)
    pub fn builder() -> crate::input::list_instance_type_details_input::Builder {
        crate::input::list_instance_type_details_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListInstanceTypeDetails {
    type Output = std::result::Result<
        crate::output::ListInstanceTypeDetailsOutput,
        crate::error::ListInstanceTypeDetailsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_instance_type_details_error(response)
        } else {
            crate::operation_deser::parse_list_instance_type_details_response(response)
        }
    }
}

/// <p>Lists all packages associated with the Amazon OpenSearch Service domain.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListPackagesForDomain {
    _private: (),
}
impl ListPackagesForDomain {
    /// Creates a new builder-style object to manufacture [`ListPackagesForDomainInput`](crate::input::ListPackagesForDomainInput)
    pub fn builder() -> crate::input::list_packages_for_domain_input::Builder {
        crate::input::list_packages_for_domain_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListPackagesForDomain {
    type Output = std::result::Result<
        crate::output::ListPackagesForDomainOutput,
        crate::error::ListPackagesForDomainError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_packages_for_domain_error(response)
        } else {
            crate::operation_deser::parse_list_packages_for_domain_response(response)
        }
    }
}

/// <p>Returns all tags for the given domain.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListTags {
    _private: (),
}
impl ListTags {
    /// Creates a new builder-style object to manufacture [`ListTagsInput`](crate::input::ListTagsInput)
    pub fn builder() -> crate::input::list_tags_input::Builder {
        crate::input::list_tags_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListTags {
    type Output = std::result::Result<crate::output::ListTagsOutput, crate::error::ListTagsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_tags_error(response)
        } else {
            crate::operation_deser::parse_list_tags_response(response)
        }
    }
}

/// <p>List all supported versions of OpenSearch and Elasticsearch.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListVersions {
    _private: (),
}
impl ListVersions {
    /// Creates a new builder-style object to manufacture [`ListVersionsInput`](crate::input::ListVersionsInput)
    pub fn builder() -> crate::input::list_versions_input::Builder {
        crate::input::list_versions_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListVersions {
    type Output =
        std::result::Result<crate::output::ListVersionsOutput, crate::error::ListVersionsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_versions_error(response)
        } else {
            crate::operation_deser::parse_list_versions_response(response)
        }
    }
}

/// <p>Allows you to purchase reserved OpenSearch instances.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PurchaseReservedInstanceOffering {
    _private: (),
}
impl PurchaseReservedInstanceOffering {
    /// Creates a new builder-style object to manufacture [`PurchaseReservedInstanceOfferingInput`](crate::input::PurchaseReservedInstanceOfferingInput)
    pub fn builder() -> crate::input::purchase_reserved_instance_offering_input::Builder {
        crate::input::purchase_reserved_instance_offering_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PurchaseReservedInstanceOffering {
    type Output = std::result::Result<
        crate::output::PurchaseReservedInstanceOfferingOutput,
        crate::error::PurchaseReservedInstanceOfferingError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_purchase_reserved_instance_offering_error(response)
        } else {
            crate::operation_deser::parse_purchase_reserved_instance_offering_response(response)
        }
    }
}

/// <p>Allows the remote domain owner to reject an inbound cross-cluster connection request.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct RejectInboundConnection {
    _private: (),
}
impl RejectInboundConnection {
    /// Creates a new builder-style object to manufacture [`RejectInboundConnectionInput`](crate::input::RejectInboundConnectionInput)
    pub fn builder() -> crate::input::reject_inbound_connection_input::Builder {
        crate::input::reject_inbound_connection_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for RejectInboundConnection {
    type Output = std::result::Result<
        crate::output::RejectInboundConnectionOutput,
        crate::error::RejectInboundConnectionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_reject_inbound_connection_error(response)
        } else {
            crate::operation_deser::parse_reject_inbound_connection_response(response)
        }
    }
}

/// <p>Removes the specified set of tags from the given domain.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct RemoveTags {
    _private: (),
}
impl RemoveTags {
    /// Creates a new builder-style object to manufacture [`RemoveTagsInput`](crate::input::RemoveTagsInput)
    pub fn builder() -> crate::input::remove_tags_input::Builder {
        crate::input::remove_tags_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for RemoveTags {
    type Output =
        std::result::Result<crate::output::RemoveTagsOutput, crate::error::RemoveTagsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_remove_tags_error(response)
        } else {
            crate::operation_deser::parse_remove_tags_response(response)
        }
    }
}

/// <p>Schedules a service software update for an Amazon OpenSearch Service domain.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct StartServiceSoftwareUpdate {
    _private: (),
}
impl StartServiceSoftwareUpdate {
    /// Creates a new builder-style object to manufacture [`StartServiceSoftwareUpdateInput`](crate::input::StartServiceSoftwareUpdateInput)
    pub fn builder() -> crate::input::start_service_software_update_input::Builder {
        crate::input::start_service_software_update_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for StartServiceSoftwareUpdate {
    type Output = std::result::Result<
        crate::output::StartServiceSoftwareUpdateOutput,
        crate::error::StartServiceSoftwareUpdateError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_start_service_software_update_error(response)
        } else {
            crate::operation_deser::parse_start_service_software_update_response(response)
        }
    }
}

/// <p>Modifies the cluster configuration of the specified domain, such as setting the instance type
/// and the number of instances.
/// </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateDomainConfig {
    _private: (),
}
impl UpdateDomainConfig {
    /// Creates a new builder-style object to manufacture [`UpdateDomainConfigInput`](crate::input::UpdateDomainConfigInput)
    pub fn builder() -> crate::input::update_domain_config_input::Builder {
        crate::input::update_domain_config_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateDomainConfig {
    type Output = std::result::Result<
        crate::output::UpdateDomainConfigOutput,
        crate::error::UpdateDomainConfigError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_domain_config_error(response)
        } else {
            crate::operation_deser::parse_update_domain_config_response(response)
        }
    }
}

/// <p>Updates a package for use with Amazon OpenSearch Service domains.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdatePackage {
    _private: (),
}
impl UpdatePackage {
    /// Creates a new builder-style object to manufacture [`UpdatePackageInput`](crate::input::UpdatePackageInput)
    pub fn builder() -> crate::input::update_package_input::Builder {
        crate::input::update_package_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdatePackage {
    type Output =
        std::result::Result<crate::output::UpdatePackageOutput, crate::error::UpdatePackageError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_package_error(response)
        } else {
            crate::operation_deser::parse_update_package_response(response)
        }
    }
}

/// <p>Allows you to either upgrade your domain or perform an upgrade eligibility check to a compatible version of OpenSearch or Elasticsearch.
/// </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpgradeDomain {
    _private: (),
}
impl UpgradeDomain {
    /// Creates a new builder-style object to manufacture [`UpgradeDomainInput`](crate::input::UpgradeDomainInput)
    pub fn builder() -> crate::input::upgrade_domain_input::Builder {
        crate::input::upgrade_domain_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpgradeDomain {
    type Output =
        std::result::Result<crate::output::UpgradeDomainOutput, crate::error::UpgradeDomainError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_upgrade_domain_error(response)
        } else {
            crate::operation_deser::parse_upgrade_domain_response(response)
        }
    }
}
