// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>The result of a <code>DescribeDomainHealth</code> request. Contains health information for the requested domain.</p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct DescribeDomainHealthOutput {
    /// <p>The current state of the domain.</p>
    /// <ul>
    /// <li>
    /// <p><code>Processing</code> - The domain has updates in progress.</p></li>
    /// <li>
    /// <p><code>Active</code> - Requested changes have been processed and deployed to the domain.</p></li>
    /// </ul>
    pub domain_state: ::std::option::Option<crate::types::DomainState>,
    /// <p>The number of Availability Zones configured for the domain. If the service is unable to fetch this information, it will return <code>NotAvailable</code>.</p>
    pub availability_zone_count: ::std::option::Option<::std::string::String>,
    /// <p>The number of active Availability Zones configured for the domain. If the service is unable to fetch this information, it will return <code>NotAvailable</code>.</p>
    pub active_availability_zone_count: ::std::option::Option<::std::string::String>,
    /// <p>The number of standby Availability Zones configured for the domain. If the service is unable to fetch this information, it will return <code>NotAvailable</code>.</p>
    pub stand_by_availability_zone_count: ::std::option::Option<::std::string::String>,
    /// <p>The number of data nodes configured for the domain. If the service is unable to fetch this information, it will return <code>NotAvailable</code>.</p>
    pub data_node_count: ::std::option::Option<::std::string::String>,
    /// <p>A boolean that indicates if dedicated master nodes are activated for the domain.</p>
    pub dedicated_master: ::std::option::Option<bool>,
    /// <p>The number of nodes that can be elected as a master node. If dedicated master nodes is turned on, this value is the number of dedicated master nodes configured for the domain. If the service is unable to fetch this information, it will return <code>NotAvailable</code>.</p>
    pub master_eligible_node_count: ::std::option::Option<::std::string::String>,
    /// <p>The number of warm nodes configured for the domain.</p>
    pub warm_node_count: ::std::option::Option<::std::string::String>,
    /// <p>Indicates whether the domain has an elected master node.</p>
    /// <ul>
    /// <li>
    /// <p><b>Available</b> - The domain has an elected master node.</p></li>
    /// <li>
    /// <p><b>UnAvailable</b> - The master node hasn't yet been elected, and a quorum to elect a new master node hasn't been reached.</p></li>
    /// </ul>
    pub master_node: ::std::option::Option<crate::types::MasterNodeStatus>,
    /// <p>The current health status of your cluster.</p>
    /// <ul>
    /// <li>
    /// <p><code>Red</code> - At least one primary shard is not allocated to any node.</p></li>
    /// <li>
    /// <p><code>Yellow</code> - All primary shards are allocated to nodes, but some replicas aren’t.</p></li>
    /// <li>
    /// <p><code>Green</code> - All primary shards and their replicas are allocated to nodes.</p></li>
    /// <li>
    /// <p><code>NotAvailable</code> - Unable to retrieve cluster health.</p></li>
    /// </ul>
    pub cluster_health: ::std::option::Option<crate::types::DomainHealth>,
    /// <p>The total number of primary and replica shards for the domain.</p>
    pub total_shards: ::std::option::Option<::std::string::String>,
    /// <p>The total number of primary and replica shards not allocated to any of the nodes for the cluster.</p>
    pub total_un_assigned_shards: ::std::option::Option<::std::string::String>,
    /// <p>A list of <code>EnvironmentInfo</code> for the domain.</p>
    pub environment_information: ::std::option::Option<::std::vec::Vec<crate::types::EnvironmentInfo>>,
    _request_id: Option<String>,
}
impl DescribeDomainHealthOutput {
    /// <p>The current state of the domain.</p>
    /// <ul>
    /// <li>
    /// <p><code>Processing</code> - The domain has updates in progress.</p></li>
    /// <li>
    /// <p><code>Active</code> - Requested changes have been processed and deployed to the domain.</p></li>
    /// </ul>
    pub fn domain_state(&self) -> ::std::option::Option<&crate::types::DomainState> {
        self.domain_state.as_ref()
    }
    /// <p>The number of Availability Zones configured for the domain. If the service is unable to fetch this information, it will return <code>NotAvailable</code>.</p>
    pub fn availability_zone_count(&self) -> ::std::option::Option<&str> {
        self.availability_zone_count.as_deref()
    }
    /// <p>The number of active Availability Zones configured for the domain. If the service is unable to fetch this information, it will return <code>NotAvailable</code>.</p>
    pub fn active_availability_zone_count(&self) -> ::std::option::Option<&str> {
        self.active_availability_zone_count.as_deref()
    }
    /// <p>The number of standby Availability Zones configured for the domain. If the service is unable to fetch this information, it will return <code>NotAvailable</code>.</p>
    pub fn stand_by_availability_zone_count(&self) -> ::std::option::Option<&str> {
        self.stand_by_availability_zone_count.as_deref()
    }
    /// <p>The number of data nodes configured for the domain. If the service is unable to fetch this information, it will return <code>NotAvailable</code>.</p>
    pub fn data_node_count(&self) -> ::std::option::Option<&str> {
        self.data_node_count.as_deref()
    }
    /// <p>A boolean that indicates if dedicated master nodes are activated for the domain.</p>
    pub fn dedicated_master(&self) -> ::std::option::Option<bool> {
        self.dedicated_master
    }
    /// <p>The number of nodes that can be elected as a master node. If dedicated master nodes is turned on, this value is the number of dedicated master nodes configured for the domain. If the service is unable to fetch this information, it will return <code>NotAvailable</code>.</p>
    pub fn master_eligible_node_count(&self) -> ::std::option::Option<&str> {
        self.master_eligible_node_count.as_deref()
    }
    /// <p>The number of warm nodes configured for the domain.</p>
    pub fn warm_node_count(&self) -> ::std::option::Option<&str> {
        self.warm_node_count.as_deref()
    }
    /// <p>Indicates whether the domain has an elected master node.</p>
    /// <ul>
    /// <li>
    /// <p><b>Available</b> - The domain has an elected master node.</p></li>
    /// <li>
    /// <p><b>UnAvailable</b> - The master node hasn't yet been elected, and a quorum to elect a new master node hasn't been reached.</p></li>
    /// </ul>
    pub fn master_node(&self) -> ::std::option::Option<&crate::types::MasterNodeStatus> {
        self.master_node.as_ref()
    }
    /// <p>The current health status of your cluster.</p>
    /// <ul>
    /// <li>
    /// <p><code>Red</code> - At least one primary shard is not allocated to any node.</p></li>
    /// <li>
    /// <p><code>Yellow</code> - All primary shards are allocated to nodes, but some replicas aren’t.</p></li>
    /// <li>
    /// <p><code>Green</code> - All primary shards and their replicas are allocated to nodes.</p></li>
    /// <li>
    /// <p><code>NotAvailable</code> - Unable to retrieve cluster health.</p></li>
    /// </ul>
    pub fn cluster_health(&self) -> ::std::option::Option<&crate::types::DomainHealth> {
        self.cluster_health.as_ref()
    }
    /// <p>The total number of primary and replica shards for the domain.</p>
    pub fn total_shards(&self) -> ::std::option::Option<&str> {
        self.total_shards.as_deref()
    }
    /// <p>The total number of primary and replica shards not allocated to any of the nodes for the cluster.</p>
    pub fn total_un_assigned_shards(&self) -> ::std::option::Option<&str> {
        self.total_un_assigned_shards.as_deref()
    }
    /// <p>A list of <code>EnvironmentInfo</code> for the domain.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.environment_information.is_none()`.
    pub fn environment_information(&self) -> &[crate::types::EnvironmentInfo] {
        self.environment_information.as_deref().unwrap_or_default()
    }
}
impl ::aws_types::request_id::RequestId for DescribeDomainHealthOutput {
    fn request_id(&self) -> Option<&str> {
        self._request_id.as_deref()
    }
}
impl DescribeDomainHealthOutput {
    /// Creates a new builder-style object to manufacture [`DescribeDomainHealthOutput`](crate::operation::describe_domain_health::DescribeDomainHealthOutput).
    pub fn builder() -> crate::operation::describe_domain_health::builders::DescribeDomainHealthOutputBuilder {
        crate::operation::describe_domain_health::builders::DescribeDomainHealthOutputBuilder::default()
    }
}

/// A builder for [`DescribeDomainHealthOutput`](crate::operation::describe_domain_health::DescribeDomainHealthOutput).
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
pub struct DescribeDomainHealthOutputBuilder {
    pub(crate) domain_state: ::std::option::Option<crate::types::DomainState>,
    pub(crate) availability_zone_count: ::std::option::Option<::std::string::String>,
    pub(crate) active_availability_zone_count: ::std::option::Option<::std::string::String>,
    pub(crate) stand_by_availability_zone_count: ::std::option::Option<::std::string::String>,
    pub(crate) data_node_count: ::std::option::Option<::std::string::String>,
    pub(crate) dedicated_master: ::std::option::Option<bool>,
    pub(crate) master_eligible_node_count: ::std::option::Option<::std::string::String>,
    pub(crate) warm_node_count: ::std::option::Option<::std::string::String>,
    pub(crate) master_node: ::std::option::Option<crate::types::MasterNodeStatus>,
    pub(crate) cluster_health: ::std::option::Option<crate::types::DomainHealth>,
    pub(crate) total_shards: ::std::option::Option<::std::string::String>,
    pub(crate) total_un_assigned_shards: ::std::option::Option<::std::string::String>,
    pub(crate) environment_information: ::std::option::Option<::std::vec::Vec<crate::types::EnvironmentInfo>>,
    _request_id: Option<String>,
}
impl DescribeDomainHealthOutputBuilder {
    /// <p>The current state of the domain.</p>
    /// <ul>
    /// <li>
    /// <p><code>Processing</code> - The domain has updates in progress.</p></li>
    /// <li>
    /// <p><code>Active</code> - Requested changes have been processed and deployed to the domain.</p></li>
    /// </ul>
    pub fn domain_state(mut self, input: crate::types::DomainState) -> Self {
        self.domain_state = ::std::option::Option::Some(input);
        self
    }
    /// <p>The current state of the domain.</p>
    /// <ul>
    /// <li>
    /// <p><code>Processing</code> - The domain has updates in progress.</p></li>
    /// <li>
    /// <p><code>Active</code> - Requested changes have been processed and deployed to the domain.</p></li>
    /// </ul>
    pub fn set_domain_state(mut self, input: ::std::option::Option<crate::types::DomainState>) -> Self {
        self.domain_state = input;
        self
    }
    /// <p>The current state of the domain.</p>
    /// <ul>
    /// <li>
    /// <p><code>Processing</code> - The domain has updates in progress.</p></li>
    /// <li>
    /// <p><code>Active</code> - Requested changes have been processed and deployed to the domain.</p></li>
    /// </ul>
    pub fn get_domain_state(&self) -> &::std::option::Option<crate::types::DomainState> {
        &self.domain_state
    }
    /// <p>The number of Availability Zones configured for the domain. If the service is unable to fetch this information, it will return <code>NotAvailable</code>.</p>
    pub fn availability_zone_count(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.availability_zone_count = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The number of Availability Zones configured for the domain. If the service is unable to fetch this information, it will return <code>NotAvailable</code>.</p>
    pub fn set_availability_zone_count(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.availability_zone_count = input;
        self
    }
    /// <p>The number of Availability Zones configured for the domain. If the service is unable to fetch this information, it will return <code>NotAvailable</code>.</p>
    pub fn get_availability_zone_count(&self) -> &::std::option::Option<::std::string::String> {
        &self.availability_zone_count
    }
    /// <p>The number of active Availability Zones configured for the domain. If the service is unable to fetch this information, it will return <code>NotAvailable</code>.</p>
    pub fn active_availability_zone_count(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.active_availability_zone_count = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The number of active Availability Zones configured for the domain. If the service is unable to fetch this information, it will return <code>NotAvailable</code>.</p>
    pub fn set_active_availability_zone_count(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.active_availability_zone_count = input;
        self
    }
    /// <p>The number of active Availability Zones configured for the domain. If the service is unable to fetch this information, it will return <code>NotAvailable</code>.</p>
    pub fn get_active_availability_zone_count(&self) -> &::std::option::Option<::std::string::String> {
        &self.active_availability_zone_count
    }
    /// <p>The number of standby Availability Zones configured for the domain. If the service is unable to fetch this information, it will return <code>NotAvailable</code>.</p>
    pub fn stand_by_availability_zone_count(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.stand_by_availability_zone_count = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The number of standby Availability Zones configured for the domain. If the service is unable to fetch this information, it will return <code>NotAvailable</code>.</p>
    pub fn set_stand_by_availability_zone_count(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.stand_by_availability_zone_count = input;
        self
    }
    /// <p>The number of standby Availability Zones configured for the domain. If the service is unable to fetch this information, it will return <code>NotAvailable</code>.</p>
    pub fn get_stand_by_availability_zone_count(&self) -> &::std::option::Option<::std::string::String> {
        &self.stand_by_availability_zone_count
    }
    /// <p>The number of data nodes configured for the domain. If the service is unable to fetch this information, it will return <code>NotAvailable</code>.</p>
    pub fn data_node_count(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.data_node_count = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The number of data nodes configured for the domain. If the service is unable to fetch this information, it will return <code>NotAvailable</code>.</p>
    pub fn set_data_node_count(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.data_node_count = input;
        self
    }
    /// <p>The number of data nodes configured for the domain. If the service is unable to fetch this information, it will return <code>NotAvailable</code>.</p>
    pub fn get_data_node_count(&self) -> &::std::option::Option<::std::string::String> {
        &self.data_node_count
    }
    /// <p>A boolean that indicates if dedicated master nodes are activated for the domain.</p>
    pub fn dedicated_master(mut self, input: bool) -> Self {
        self.dedicated_master = ::std::option::Option::Some(input);
        self
    }
    /// <p>A boolean that indicates if dedicated master nodes are activated for the domain.</p>
    pub fn set_dedicated_master(mut self, input: ::std::option::Option<bool>) -> Self {
        self.dedicated_master = input;
        self
    }
    /// <p>A boolean that indicates if dedicated master nodes are activated for the domain.</p>
    pub fn get_dedicated_master(&self) -> &::std::option::Option<bool> {
        &self.dedicated_master
    }
    /// <p>The number of nodes that can be elected as a master node. If dedicated master nodes is turned on, this value is the number of dedicated master nodes configured for the domain. If the service is unable to fetch this information, it will return <code>NotAvailable</code>.</p>
    pub fn master_eligible_node_count(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.master_eligible_node_count = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The number of nodes that can be elected as a master node. If dedicated master nodes is turned on, this value is the number of dedicated master nodes configured for the domain. If the service is unable to fetch this information, it will return <code>NotAvailable</code>.</p>
    pub fn set_master_eligible_node_count(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.master_eligible_node_count = input;
        self
    }
    /// <p>The number of nodes that can be elected as a master node. If dedicated master nodes is turned on, this value is the number of dedicated master nodes configured for the domain. If the service is unable to fetch this information, it will return <code>NotAvailable</code>.</p>
    pub fn get_master_eligible_node_count(&self) -> &::std::option::Option<::std::string::String> {
        &self.master_eligible_node_count
    }
    /// <p>The number of warm nodes configured for the domain.</p>
    pub fn warm_node_count(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.warm_node_count = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The number of warm nodes configured for the domain.</p>
    pub fn set_warm_node_count(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.warm_node_count = input;
        self
    }
    /// <p>The number of warm nodes configured for the domain.</p>
    pub fn get_warm_node_count(&self) -> &::std::option::Option<::std::string::String> {
        &self.warm_node_count
    }
    /// <p>Indicates whether the domain has an elected master node.</p>
    /// <ul>
    /// <li>
    /// <p><b>Available</b> - The domain has an elected master node.</p></li>
    /// <li>
    /// <p><b>UnAvailable</b> - The master node hasn't yet been elected, and a quorum to elect a new master node hasn't been reached.</p></li>
    /// </ul>
    pub fn master_node(mut self, input: crate::types::MasterNodeStatus) -> Self {
        self.master_node = ::std::option::Option::Some(input);
        self
    }
    /// <p>Indicates whether the domain has an elected master node.</p>
    /// <ul>
    /// <li>
    /// <p><b>Available</b> - The domain has an elected master node.</p></li>
    /// <li>
    /// <p><b>UnAvailable</b> - The master node hasn't yet been elected, and a quorum to elect a new master node hasn't been reached.</p></li>
    /// </ul>
    pub fn set_master_node(mut self, input: ::std::option::Option<crate::types::MasterNodeStatus>) -> Self {
        self.master_node = input;
        self
    }
    /// <p>Indicates whether the domain has an elected master node.</p>
    /// <ul>
    /// <li>
    /// <p><b>Available</b> - The domain has an elected master node.</p></li>
    /// <li>
    /// <p><b>UnAvailable</b> - The master node hasn't yet been elected, and a quorum to elect a new master node hasn't been reached.</p></li>
    /// </ul>
    pub fn get_master_node(&self) -> &::std::option::Option<crate::types::MasterNodeStatus> {
        &self.master_node
    }
    /// <p>The current health status of your cluster.</p>
    /// <ul>
    /// <li>
    /// <p><code>Red</code> - At least one primary shard is not allocated to any node.</p></li>
    /// <li>
    /// <p><code>Yellow</code> - All primary shards are allocated to nodes, but some replicas aren’t.</p></li>
    /// <li>
    /// <p><code>Green</code> - All primary shards and their replicas are allocated to nodes.</p></li>
    /// <li>
    /// <p><code>NotAvailable</code> - Unable to retrieve cluster health.</p></li>
    /// </ul>
    pub fn cluster_health(mut self, input: crate::types::DomainHealth) -> Self {
        self.cluster_health = ::std::option::Option::Some(input);
        self
    }
    /// <p>The current health status of your cluster.</p>
    /// <ul>
    /// <li>
    /// <p><code>Red</code> - At least one primary shard is not allocated to any node.</p></li>
    /// <li>
    /// <p><code>Yellow</code> - All primary shards are allocated to nodes, but some replicas aren’t.</p></li>
    /// <li>
    /// <p><code>Green</code> - All primary shards and their replicas are allocated to nodes.</p></li>
    /// <li>
    /// <p><code>NotAvailable</code> - Unable to retrieve cluster health.</p></li>
    /// </ul>
    pub fn set_cluster_health(mut self, input: ::std::option::Option<crate::types::DomainHealth>) -> Self {
        self.cluster_health = input;
        self
    }
    /// <p>The current health status of your cluster.</p>
    /// <ul>
    /// <li>
    /// <p><code>Red</code> - At least one primary shard is not allocated to any node.</p></li>
    /// <li>
    /// <p><code>Yellow</code> - All primary shards are allocated to nodes, but some replicas aren’t.</p></li>
    /// <li>
    /// <p><code>Green</code> - All primary shards and their replicas are allocated to nodes.</p></li>
    /// <li>
    /// <p><code>NotAvailable</code> - Unable to retrieve cluster health.</p></li>
    /// </ul>
    pub fn get_cluster_health(&self) -> &::std::option::Option<crate::types::DomainHealth> {
        &self.cluster_health
    }
    /// <p>The total number of primary and replica shards for the domain.</p>
    pub fn total_shards(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.total_shards = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The total number of primary and replica shards for the domain.</p>
    pub fn set_total_shards(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.total_shards = input;
        self
    }
    /// <p>The total number of primary and replica shards for the domain.</p>
    pub fn get_total_shards(&self) -> &::std::option::Option<::std::string::String> {
        &self.total_shards
    }
    /// <p>The total number of primary and replica shards not allocated to any of the nodes for the cluster.</p>
    pub fn total_un_assigned_shards(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.total_un_assigned_shards = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The total number of primary and replica shards not allocated to any of the nodes for the cluster.</p>
    pub fn set_total_un_assigned_shards(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.total_un_assigned_shards = input;
        self
    }
    /// <p>The total number of primary and replica shards not allocated to any of the nodes for the cluster.</p>
    pub fn get_total_un_assigned_shards(&self) -> &::std::option::Option<::std::string::String> {
        &self.total_un_assigned_shards
    }
    /// Appends an item to `environment_information`.
    ///
    /// To override the contents of this collection use [`set_environment_information`](Self::set_environment_information).
    ///
    /// <p>A list of <code>EnvironmentInfo</code> for the domain.</p>
    pub fn environment_information(mut self, input: crate::types::EnvironmentInfo) -> Self {
        let mut v = self.environment_information.unwrap_or_default();
        v.push(input);
        self.environment_information = ::std::option::Option::Some(v);
        self
    }
    /// <p>A list of <code>EnvironmentInfo</code> for the domain.</p>
    pub fn set_environment_information(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::EnvironmentInfo>>) -> Self {
        self.environment_information = input;
        self
    }
    /// <p>A list of <code>EnvironmentInfo</code> for the domain.</p>
    pub fn get_environment_information(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::EnvironmentInfo>> {
        &self.environment_information
    }
    pub(crate) fn _request_id(mut self, request_id: impl Into<String>) -> Self {
        self._request_id = Some(request_id.into());
        self
    }

    pub(crate) fn _set_request_id(&mut self, request_id: Option<String>) -> &mut Self {
        self._request_id = request_id;
        self
    }
    /// Consumes the builder and constructs a [`DescribeDomainHealthOutput`](crate::operation::describe_domain_health::DescribeDomainHealthOutput).
    pub fn build(self) -> crate::operation::describe_domain_health::DescribeDomainHealthOutput {
        crate::operation::describe_domain_health::DescribeDomainHealthOutput {
            domain_state: self.domain_state,
            availability_zone_count: self.availability_zone_count,
            active_availability_zone_count: self.active_availability_zone_count,
            stand_by_availability_zone_count: self.stand_by_availability_zone_count,
            data_node_count: self.data_node_count,
            dedicated_master: self.dedicated_master,
            master_eligible_node_count: self.master_eligible_node_count,
            warm_node_count: self.warm_node_count,
            master_node: self.master_node,
            cluster_health: self.cluster_health,
            total_shards: self.total_shards,
            total_un_assigned_shards: self.total_un_assigned_shards,
            environment_information: self.environment_information,
            _request_id: self._request_id,
        }
    }
}
