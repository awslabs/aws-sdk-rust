// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
pub use crate::operation::create_table::_create_table_output::CreateTableOutputBuilder;

pub use crate::operation::create_table::_create_table_input::CreateTableInputBuilder;

impl CreateTableInputBuilder {
    /// Sends a request with this input using the given client.
    pub async fn send_with(
        self,
        client: &crate::Client,
    ) -> ::std::result::Result<
        crate::operation::create_table::CreateTableOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::create_table::CreateTableError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let mut fluent_builder = client.create_table();
        fluent_builder.inner = self;
        fluent_builder.send().await
    }
}
/// Fluent builder constructing a request to `CreateTable`.
///
/// <p>The <code>CreateTable</code> operation adds a new table to the specified keyspace. Within a keyspace, table names must be unique.</p>
/// <p><code>CreateTable</code> is an asynchronous operation. When the request is received, the status of the table is set to <code>CREATING</code>. You can monitor the creation status of the new table by using the <code>GetTable</code> operation, which returns the current <code>status</code> of the table. You can start using a table when the status is <code>ACTIVE</code>.</p>
/// <p>For more information, see <a href="https://docs.aws.amazon.com/keyspaces/latest/devguide/working-with-tables.html#tables-create">Creating tables</a> in the <i>Amazon Keyspaces Developer Guide</i>.</p>
#[derive(::std::clone::Clone, ::std::fmt::Debug)]
pub struct CreateTableFluentBuilder {
    handle: ::std::sync::Arc<crate::client::Handle>,
    inner: crate::operation::create_table::builders::CreateTableInputBuilder,
    config_override: ::std::option::Option<crate::config::Builder>,
}
impl
    crate::client::customize::internal::CustomizableSend<
        crate::operation::create_table::CreateTableOutput,
        crate::operation::create_table::CreateTableError,
    > for CreateTableFluentBuilder
{
    fn send(
        self,
        config_override: crate::config::Builder,
    ) -> crate::client::customize::internal::BoxFuture<
        crate::client::customize::internal::SendResult<
            crate::operation::create_table::CreateTableOutput,
            crate::operation::create_table::CreateTableError,
        >,
    > {
        ::std::boxed::Box::pin(async move { self.config_override(config_override).send().await })
    }
}
impl CreateTableFluentBuilder {
    /// Creates a new `CreateTable`.
    pub(crate) fn new(handle: ::std::sync::Arc<crate::client::Handle>) -> Self {
        Self {
            handle,
            inner: ::std::default::Default::default(),
            config_override: ::std::option::Option::None,
        }
    }
    /// Access the CreateTable as a reference.
    pub fn as_input(&self) -> &crate::operation::create_table::builders::CreateTableInputBuilder {
        &self.inner
    }
    /// Sends the request and returns the response.
    ///
    /// If an error occurs, an `SdkError` will be returned with additional details that
    /// can be matched against.
    ///
    /// By default, any retryable failures will be retried twice. Retry behavior
    /// is configurable with the [RetryConfig](aws_smithy_types::retry::RetryConfig), which can be
    /// set when configuring the client.
    pub async fn send(
        self,
    ) -> ::std::result::Result<
        crate::operation::create_table::CreateTableOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::create_table::CreateTableError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let input = self
            .inner
            .build()
            .map_err(::aws_smithy_runtime_api::client::result::SdkError::construction_failure)?;
        let runtime_plugins = crate::operation::create_table::CreateTable::operation_runtime_plugins(
            self.handle.runtime_plugins.clone(),
            &self.handle.conf,
            self.config_override,
        );
        crate::operation::create_table::CreateTable::orchestrate(&runtime_plugins, input).await
    }

    /// Consumes this builder, creating a customizable operation that can be modified before being sent.
    pub fn customize(
        self,
    ) -> crate::client::customize::CustomizableOperation<
        crate::operation::create_table::CreateTableOutput,
        crate::operation::create_table::CreateTableError,
        Self,
    > {
        crate::client::customize::CustomizableOperation::new(self)
    }
    pub(crate) fn config_override(mut self, config_override: impl Into<crate::config::Builder>) -> Self {
        self.set_config_override(Some(config_override.into()));
        self
    }

    pub(crate) fn set_config_override(&mut self, config_override: Option<crate::config::Builder>) -> &mut Self {
        self.config_override = config_override;
        self
    }
    /// <p>The name of the keyspace that the table is going to be created in.</p>
    pub fn keyspace_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.keyspace_name(input.into());
        self
    }
    /// <p>The name of the keyspace that the table is going to be created in.</p>
    pub fn set_keyspace_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_keyspace_name(input);
        self
    }
    /// <p>The name of the keyspace that the table is going to be created in.</p>
    pub fn get_keyspace_name(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_keyspace_name()
    }
    /// <p>The name of the table.</p>
    pub fn table_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.table_name(input.into());
        self
    }
    /// <p>The name of the table.</p>
    pub fn set_table_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_table_name(input);
        self
    }
    /// <p>The name of the table.</p>
    pub fn get_table_name(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_table_name()
    }
    /// <p>The <code>schemaDefinition</code> consists of the following parameters.</p>
    /// <p>For each column to be created:</p>
    /// <ul>
    /// <li>
    /// <p><code>name</code> - The name of the column.</p></li>
    /// <li>
    /// <p><code>type</code> - An Amazon Keyspaces data type. For more information, see <a href="https://docs.aws.amazon.com/keyspaces/latest/devguide/cql.elements.html#cql.data-types">Data types</a> in the <i>Amazon Keyspaces Developer Guide</i>.</p></li>
    /// </ul>
    /// <p>The primary key of the table consists of the following columns:</p>
    /// <ul>
    /// <li>
    /// <p><code>partitionKeys</code> - The partition key can be a single column, or it can be a compound value composed of two or more columns. The partition key portion of the primary key is required and determines how Amazon Keyspaces stores your data.</p></li>
    /// <li>
    /// <p><code>name</code> - The name of each partition key column.</p></li>
    /// <li>
    /// <p><code>clusteringKeys</code> - The optional clustering column portion of your primary key determines how the data is clustered and sorted within each partition.</p></li>
    /// <li>
    /// <p><code>name</code> - The name of the clustering column.</p></li>
    /// <li>
    /// <p><code>orderBy</code> - Sets the ascendant (<code>ASC</code>) or descendant (<code>DESC</code>) order modifier.</p>
    /// <p>To define a column as static use <code>staticColumns</code> - Static columns store values that are shared by all rows in the same partition:</p></li>
    /// <li>
    /// <p><code>name</code> - The name of the column.</p></li>
    /// <li>
    /// <p><code>type</code> - An Amazon Keyspaces data type.</p></li>
    /// </ul>
    pub fn schema_definition(mut self, input: crate::types::SchemaDefinition) -> Self {
        self.inner = self.inner.schema_definition(input);
        self
    }
    /// <p>The <code>schemaDefinition</code> consists of the following parameters.</p>
    /// <p>For each column to be created:</p>
    /// <ul>
    /// <li>
    /// <p><code>name</code> - The name of the column.</p></li>
    /// <li>
    /// <p><code>type</code> - An Amazon Keyspaces data type. For more information, see <a href="https://docs.aws.amazon.com/keyspaces/latest/devguide/cql.elements.html#cql.data-types">Data types</a> in the <i>Amazon Keyspaces Developer Guide</i>.</p></li>
    /// </ul>
    /// <p>The primary key of the table consists of the following columns:</p>
    /// <ul>
    /// <li>
    /// <p><code>partitionKeys</code> - The partition key can be a single column, or it can be a compound value composed of two or more columns. The partition key portion of the primary key is required and determines how Amazon Keyspaces stores your data.</p></li>
    /// <li>
    /// <p><code>name</code> - The name of each partition key column.</p></li>
    /// <li>
    /// <p><code>clusteringKeys</code> - The optional clustering column portion of your primary key determines how the data is clustered and sorted within each partition.</p></li>
    /// <li>
    /// <p><code>name</code> - The name of the clustering column.</p></li>
    /// <li>
    /// <p><code>orderBy</code> - Sets the ascendant (<code>ASC</code>) or descendant (<code>DESC</code>) order modifier.</p>
    /// <p>To define a column as static use <code>staticColumns</code> - Static columns store values that are shared by all rows in the same partition:</p></li>
    /// <li>
    /// <p><code>name</code> - The name of the column.</p></li>
    /// <li>
    /// <p><code>type</code> - An Amazon Keyspaces data type.</p></li>
    /// </ul>
    pub fn set_schema_definition(mut self, input: ::std::option::Option<crate::types::SchemaDefinition>) -> Self {
        self.inner = self.inner.set_schema_definition(input);
        self
    }
    /// <p>The <code>schemaDefinition</code> consists of the following parameters.</p>
    /// <p>For each column to be created:</p>
    /// <ul>
    /// <li>
    /// <p><code>name</code> - The name of the column.</p></li>
    /// <li>
    /// <p><code>type</code> - An Amazon Keyspaces data type. For more information, see <a href="https://docs.aws.amazon.com/keyspaces/latest/devguide/cql.elements.html#cql.data-types">Data types</a> in the <i>Amazon Keyspaces Developer Guide</i>.</p></li>
    /// </ul>
    /// <p>The primary key of the table consists of the following columns:</p>
    /// <ul>
    /// <li>
    /// <p><code>partitionKeys</code> - The partition key can be a single column, or it can be a compound value composed of two or more columns. The partition key portion of the primary key is required and determines how Amazon Keyspaces stores your data.</p></li>
    /// <li>
    /// <p><code>name</code> - The name of each partition key column.</p></li>
    /// <li>
    /// <p><code>clusteringKeys</code> - The optional clustering column portion of your primary key determines how the data is clustered and sorted within each partition.</p></li>
    /// <li>
    /// <p><code>name</code> - The name of the clustering column.</p></li>
    /// <li>
    /// <p><code>orderBy</code> - Sets the ascendant (<code>ASC</code>) or descendant (<code>DESC</code>) order modifier.</p>
    /// <p>To define a column as static use <code>staticColumns</code> - Static columns store values that are shared by all rows in the same partition:</p></li>
    /// <li>
    /// <p><code>name</code> - The name of the column.</p></li>
    /// <li>
    /// <p><code>type</code> - An Amazon Keyspaces data type.</p></li>
    /// </ul>
    pub fn get_schema_definition(&self) -> &::std::option::Option<crate::types::SchemaDefinition> {
        self.inner.get_schema_definition()
    }
    /// <p>This parameter allows to enter a description of the table.</p>
    pub fn comment(mut self, input: crate::types::Comment) -> Self {
        self.inner = self.inner.comment(input);
        self
    }
    /// <p>This parameter allows to enter a description of the table.</p>
    pub fn set_comment(mut self, input: ::std::option::Option<crate::types::Comment>) -> Self {
        self.inner = self.inner.set_comment(input);
        self
    }
    /// <p>This parameter allows to enter a description of the table.</p>
    pub fn get_comment(&self) -> &::std::option::Option<crate::types::Comment> {
        self.inner.get_comment()
    }
    /// <p>Specifies the read/write throughput capacity mode for the table. The options are:</p>
    /// <ul>
    /// <li>
    /// <p><code>throughputMode:PAY_PER_REQUEST</code> and</p></li>
    /// <li>
    /// <p><code>throughputMode:PROVISIONED</code> - Provisioned capacity mode requires <code>readCapacityUnits</code> and <code>writeCapacityUnits</code> as input.</p></li>
    /// </ul>
    /// <p>The default is <code>throughput_mode:PAY_PER_REQUEST</code>.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/keyspaces/latest/devguide/ReadWriteCapacityMode.html">Read/write capacity modes</a> in the <i>Amazon Keyspaces Developer Guide</i>.</p>
    pub fn capacity_specification(mut self, input: crate::types::CapacitySpecification) -> Self {
        self.inner = self.inner.capacity_specification(input);
        self
    }
    /// <p>Specifies the read/write throughput capacity mode for the table. The options are:</p>
    /// <ul>
    /// <li>
    /// <p><code>throughputMode:PAY_PER_REQUEST</code> and</p></li>
    /// <li>
    /// <p><code>throughputMode:PROVISIONED</code> - Provisioned capacity mode requires <code>readCapacityUnits</code> and <code>writeCapacityUnits</code> as input.</p></li>
    /// </ul>
    /// <p>The default is <code>throughput_mode:PAY_PER_REQUEST</code>.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/keyspaces/latest/devguide/ReadWriteCapacityMode.html">Read/write capacity modes</a> in the <i>Amazon Keyspaces Developer Guide</i>.</p>
    pub fn set_capacity_specification(mut self, input: ::std::option::Option<crate::types::CapacitySpecification>) -> Self {
        self.inner = self.inner.set_capacity_specification(input);
        self
    }
    /// <p>Specifies the read/write throughput capacity mode for the table. The options are:</p>
    /// <ul>
    /// <li>
    /// <p><code>throughputMode:PAY_PER_REQUEST</code> and</p></li>
    /// <li>
    /// <p><code>throughputMode:PROVISIONED</code> - Provisioned capacity mode requires <code>readCapacityUnits</code> and <code>writeCapacityUnits</code> as input.</p></li>
    /// </ul>
    /// <p>The default is <code>throughput_mode:PAY_PER_REQUEST</code>.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/keyspaces/latest/devguide/ReadWriteCapacityMode.html">Read/write capacity modes</a> in the <i>Amazon Keyspaces Developer Guide</i>.</p>
    pub fn get_capacity_specification(&self) -> &::std::option::Option<crate::types::CapacitySpecification> {
        self.inner.get_capacity_specification()
    }
    /// <p>Specifies how the encryption key for encryption at rest is managed for the table. You can choose one of the following KMS key (KMS key):</p>
    /// <ul>
    /// <li>
    /// <p><code>type:AWS_OWNED_KMS_KEY</code> - This key is owned by Amazon Keyspaces.</p></li>
    /// <li>
    /// <p><code>type:CUSTOMER_MANAGED_KMS_KEY</code> - This key is stored in your account and is created, owned, and managed by you. This option requires the <code>kms_key_identifier</code> of the KMS key in Amazon Resource Name (ARN) format as input.</p></li>
    /// </ul>
    /// <p>The default is <code>type:AWS_OWNED_KMS_KEY</code>.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/keyspaces/latest/devguide/EncryptionAtRest.html">Encryption at rest</a> in the <i>Amazon Keyspaces Developer Guide</i>.</p>
    pub fn encryption_specification(mut self, input: crate::types::EncryptionSpecification) -> Self {
        self.inner = self.inner.encryption_specification(input);
        self
    }
    /// <p>Specifies how the encryption key for encryption at rest is managed for the table. You can choose one of the following KMS key (KMS key):</p>
    /// <ul>
    /// <li>
    /// <p><code>type:AWS_OWNED_KMS_KEY</code> - This key is owned by Amazon Keyspaces.</p></li>
    /// <li>
    /// <p><code>type:CUSTOMER_MANAGED_KMS_KEY</code> - This key is stored in your account and is created, owned, and managed by you. This option requires the <code>kms_key_identifier</code> of the KMS key in Amazon Resource Name (ARN) format as input.</p></li>
    /// </ul>
    /// <p>The default is <code>type:AWS_OWNED_KMS_KEY</code>.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/keyspaces/latest/devguide/EncryptionAtRest.html">Encryption at rest</a> in the <i>Amazon Keyspaces Developer Guide</i>.</p>
    pub fn set_encryption_specification(mut self, input: ::std::option::Option<crate::types::EncryptionSpecification>) -> Self {
        self.inner = self.inner.set_encryption_specification(input);
        self
    }
    /// <p>Specifies how the encryption key for encryption at rest is managed for the table. You can choose one of the following KMS key (KMS key):</p>
    /// <ul>
    /// <li>
    /// <p><code>type:AWS_OWNED_KMS_KEY</code> - This key is owned by Amazon Keyspaces.</p></li>
    /// <li>
    /// <p><code>type:CUSTOMER_MANAGED_KMS_KEY</code> - This key is stored in your account and is created, owned, and managed by you. This option requires the <code>kms_key_identifier</code> of the KMS key in Amazon Resource Name (ARN) format as input.</p></li>
    /// </ul>
    /// <p>The default is <code>type:AWS_OWNED_KMS_KEY</code>.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/keyspaces/latest/devguide/EncryptionAtRest.html">Encryption at rest</a> in the <i>Amazon Keyspaces Developer Guide</i>.</p>
    pub fn get_encryption_specification(&self) -> &::std::option::Option<crate::types::EncryptionSpecification> {
        self.inner.get_encryption_specification()
    }
    /// <p>Specifies if <code>pointInTimeRecovery</code> is enabled or disabled for the table. The options are:</p>
    /// <ul>
    /// <li>
    /// <p><code>status=ENABLED</code></p></li>
    /// <li>
    /// <p><code>status=DISABLED</code></p></li>
    /// </ul>
    /// <p>If it's not specified, the default is <code>status=DISABLED</code>.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/keyspaces/latest/devguide/PointInTimeRecovery.html">Point-in-time recovery</a> in the <i>Amazon Keyspaces Developer Guide</i>.</p>
    pub fn point_in_time_recovery(mut self, input: crate::types::PointInTimeRecovery) -> Self {
        self.inner = self.inner.point_in_time_recovery(input);
        self
    }
    /// <p>Specifies if <code>pointInTimeRecovery</code> is enabled or disabled for the table. The options are:</p>
    /// <ul>
    /// <li>
    /// <p><code>status=ENABLED</code></p></li>
    /// <li>
    /// <p><code>status=DISABLED</code></p></li>
    /// </ul>
    /// <p>If it's not specified, the default is <code>status=DISABLED</code>.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/keyspaces/latest/devguide/PointInTimeRecovery.html">Point-in-time recovery</a> in the <i>Amazon Keyspaces Developer Guide</i>.</p>
    pub fn set_point_in_time_recovery(mut self, input: ::std::option::Option<crate::types::PointInTimeRecovery>) -> Self {
        self.inner = self.inner.set_point_in_time_recovery(input);
        self
    }
    /// <p>Specifies if <code>pointInTimeRecovery</code> is enabled or disabled for the table. The options are:</p>
    /// <ul>
    /// <li>
    /// <p><code>status=ENABLED</code></p></li>
    /// <li>
    /// <p><code>status=DISABLED</code></p></li>
    /// </ul>
    /// <p>If it's not specified, the default is <code>status=DISABLED</code>.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/keyspaces/latest/devguide/PointInTimeRecovery.html">Point-in-time recovery</a> in the <i>Amazon Keyspaces Developer Guide</i>.</p>
    pub fn get_point_in_time_recovery(&self) -> &::std::option::Option<crate::types::PointInTimeRecovery> {
        self.inner.get_point_in_time_recovery()
    }
    /// <p>Enables Time to Live custom settings for the table. The options are:</p>
    /// <ul>
    /// <li>
    /// <p><code>status:enabled</code></p></li>
    /// <li>
    /// <p><code>status:disabled</code></p></li>
    /// </ul>
    /// <p>The default is <code>status:disabled</code>. After <code>ttl</code> is enabled, you can't disable it for the table.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/keyspaces/latest/devguide/TTL.html">Expiring data by using Amazon Keyspaces Time to Live (TTL)</a> in the <i>Amazon Keyspaces Developer Guide</i>.</p>
    pub fn ttl(mut self, input: crate::types::TimeToLive) -> Self {
        self.inner = self.inner.ttl(input);
        self
    }
    /// <p>Enables Time to Live custom settings for the table. The options are:</p>
    /// <ul>
    /// <li>
    /// <p><code>status:enabled</code></p></li>
    /// <li>
    /// <p><code>status:disabled</code></p></li>
    /// </ul>
    /// <p>The default is <code>status:disabled</code>. After <code>ttl</code> is enabled, you can't disable it for the table.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/keyspaces/latest/devguide/TTL.html">Expiring data by using Amazon Keyspaces Time to Live (TTL)</a> in the <i>Amazon Keyspaces Developer Guide</i>.</p>
    pub fn set_ttl(mut self, input: ::std::option::Option<crate::types::TimeToLive>) -> Self {
        self.inner = self.inner.set_ttl(input);
        self
    }
    /// <p>Enables Time to Live custom settings for the table. The options are:</p>
    /// <ul>
    /// <li>
    /// <p><code>status:enabled</code></p></li>
    /// <li>
    /// <p><code>status:disabled</code></p></li>
    /// </ul>
    /// <p>The default is <code>status:disabled</code>. After <code>ttl</code> is enabled, you can't disable it for the table.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/keyspaces/latest/devguide/TTL.html">Expiring data by using Amazon Keyspaces Time to Live (TTL)</a> in the <i>Amazon Keyspaces Developer Guide</i>.</p>
    pub fn get_ttl(&self) -> &::std::option::Option<crate::types::TimeToLive> {
        self.inner.get_ttl()
    }
    /// <p>The default Time to Live setting in seconds for the table.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/keyspaces/latest/devguide/TTL-how-it-works.html#ttl-howitworks_default_ttl">Setting the default TTL value for a table</a> in the <i>Amazon Keyspaces Developer Guide</i>.</p>
    pub fn default_time_to_live(mut self, input: i32) -> Self {
        self.inner = self.inner.default_time_to_live(input);
        self
    }
    /// <p>The default Time to Live setting in seconds for the table.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/keyspaces/latest/devguide/TTL-how-it-works.html#ttl-howitworks_default_ttl">Setting the default TTL value for a table</a> in the <i>Amazon Keyspaces Developer Guide</i>.</p>
    pub fn set_default_time_to_live(mut self, input: ::std::option::Option<i32>) -> Self {
        self.inner = self.inner.set_default_time_to_live(input);
        self
    }
    /// <p>The default Time to Live setting in seconds for the table.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/keyspaces/latest/devguide/TTL-how-it-works.html#ttl-howitworks_default_ttl">Setting the default TTL value for a table</a> in the <i>Amazon Keyspaces Developer Guide</i>.</p>
    pub fn get_default_time_to_live(&self) -> &::std::option::Option<i32> {
        self.inner.get_default_time_to_live()
    }
    /// Appends an item to `tags`.
    ///
    /// To override the contents of this collection use [`set_tags`](Self::set_tags).
    ///
    /// <p>A list of key-value pair tags to be attached to the resource.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/keyspaces/latest/devguide/tagging-keyspaces.html">Adding tags and labels to Amazon Keyspaces resources</a> in the <i>Amazon Keyspaces Developer Guide</i>.</p>
    pub fn tags(mut self, input: crate::types::Tag) -> Self {
        self.inner = self.inner.tags(input);
        self
    }
    /// <p>A list of key-value pair tags to be attached to the resource.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/keyspaces/latest/devguide/tagging-keyspaces.html">Adding tags and labels to Amazon Keyspaces resources</a> in the <i>Amazon Keyspaces Developer Guide</i>.</p>
    pub fn set_tags(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::Tag>>) -> Self {
        self.inner = self.inner.set_tags(input);
        self
    }
    /// <p>A list of key-value pair tags to be attached to the resource.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/keyspaces/latest/devguide/tagging-keyspaces.html">Adding tags and labels to Amazon Keyspaces resources</a> in the <i>Amazon Keyspaces Developer Guide</i>.</p>
    pub fn get_tags(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::Tag>> {
        self.inner.get_tags()
    }
    /// <p>Enables client-side timestamps for the table. By default, the setting is disabled. You can enable client-side timestamps with the following option:</p>
    /// <ul>
    /// <li>
    /// <p><code>status: "enabled"</code></p></li>
    /// </ul>
    /// <p>Once client-side timestamps are enabled for a table, this setting cannot be disabled.</p>
    pub fn client_side_timestamps(mut self, input: crate::types::ClientSideTimestamps) -> Self {
        self.inner = self.inner.client_side_timestamps(input);
        self
    }
    /// <p>Enables client-side timestamps for the table. By default, the setting is disabled. You can enable client-side timestamps with the following option:</p>
    /// <ul>
    /// <li>
    /// <p><code>status: "enabled"</code></p></li>
    /// </ul>
    /// <p>Once client-side timestamps are enabled for a table, this setting cannot be disabled.</p>
    pub fn set_client_side_timestamps(mut self, input: ::std::option::Option<crate::types::ClientSideTimestamps>) -> Self {
        self.inner = self.inner.set_client_side_timestamps(input);
        self
    }
    /// <p>Enables client-side timestamps for the table. By default, the setting is disabled. You can enable client-side timestamps with the following option:</p>
    /// <ul>
    /// <li>
    /// <p><code>status: "enabled"</code></p></li>
    /// </ul>
    /// <p>Once client-side timestamps are enabled for a table, this setting cannot be disabled.</p>
    pub fn get_client_side_timestamps(&self) -> &::std::option::Option<crate::types::ClientSideTimestamps> {
        self.inner.get_client_side_timestamps()
    }
    /// <p>The optional auto scaling settings for a table in provisioned capacity mode. Specifies if the service can manage throughput capacity automatically on your behalf.</p>
    /// <p>Auto scaling helps you provision throughput capacity for variable workloads efficiently by increasing and decreasing your table's read and write capacity automatically in response to application traffic. For more information, see <a href="https://docs.aws.amazon.com/keyspaces/latest/devguide/autoscaling.html">Managing throughput capacity automatically with Amazon Keyspaces auto scaling</a> in the <i>Amazon Keyspaces Developer Guide</i>.</p>
    /// <p>By default, auto scaling is disabled for a table.</p>
    pub fn auto_scaling_specification(mut self, input: crate::types::AutoScalingSpecification) -> Self {
        self.inner = self.inner.auto_scaling_specification(input);
        self
    }
    /// <p>The optional auto scaling settings for a table in provisioned capacity mode. Specifies if the service can manage throughput capacity automatically on your behalf.</p>
    /// <p>Auto scaling helps you provision throughput capacity for variable workloads efficiently by increasing and decreasing your table's read and write capacity automatically in response to application traffic. For more information, see <a href="https://docs.aws.amazon.com/keyspaces/latest/devguide/autoscaling.html">Managing throughput capacity automatically with Amazon Keyspaces auto scaling</a> in the <i>Amazon Keyspaces Developer Guide</i>.</p>
    /// <p>By default, auto scaling is disabled for a table.</p>
    pub fn set_auto_scaling_specification(mut self, input: ::std::option::Option<crate::types::AutoScalingSpecification>) -> Self {
        self.inner = self.inner.set_auto_scaling_specification(input);
        self
    }
    /// <p>The optional auto scaling settings for a table in provisioned capacity mode. Specifies if the service can manage throughput capacity automatically on your behalf.</p>
    /// <p>Auto scaling helps you provision throughput capacity for variable workloads efficiently by increasing and decreasing your table's read and write capacity automatically in response to application traffic. For more information, see <a href="https://docs.aws.amazon.com/keyspaces/latest/devguide/autoscaling.html">Managing throughput capacity automatically with Amazon Keyspaces auto scaling</a> in the <i>Amazon Keyspaces Developer Guide</i>.</p>
    /// <p>By default, auto scaling is disabled for a table.</p>
    pub fn get_auto_scaling_specification(&self) -> &::std::option::Option<crate::types::AutoScalingSpecification> {
        self.inner.get_auto_scaling_specification()
    }
    /// Appends an item to `replicaSpecifications`.
    ///
    /// To override the contents of this collection use [`set_replica_specifications`](Self::set_replica_specifications).
    ///
    /// <p>The optional Amazon Web Services Region specific settings of a multi-Region table. These settings overwrite the general settings of the table for the specified Region.</p>
    /// <p>For a multi-Region table in provisioned capacity mode, you can configure the table's read capacity differently for each Region's replica. The write capacity, however, remains synchronized between all replicas to ensure that there's enough capacity to replicate writes across all Regions. To define the read capacity for a table replica in a specific Region, you can do so by configuring the following parameters.</p>
    /// <ul>
    /// <li>
    /// <p><code>region</code>: The Region where these settings are applied. (Required)</p></li>
    /// <li>
    /// <p><code>readCapacityUnits</code>: The provisioned read capacity units. (Optional)</p></li>
    /// <li>
    /// <p><code>readCapacityAutoScaling</code>: The read capacity auto scaling settings for the table. (Optional)</p></li>
    /// </ul>
    pub fn replica_specifications(mut self, input: crate::types::ReplicaSpecification) -> Self {
        self.inner = self.inner.replica_specifications(input);
        self
    }
    /// <p>The optional Amazon Web Services Region specific settings of a multi-Region table. These settings overwrite the general settings of the table for the specified Region.</p>
    /// <p>For a multi-Region table in provisioned capacity mode, you can configure the table's read capacity differently for each Region's replica. The write capacity, however, remains synchronized between all replicas to ensure that there's enough capacity to replicate writes across all Regions. To define the read capacity for a table replica in a specific Region, you can do so by configuring the following parameters.</p>
    /// <ul>
    /// <li>
    /// <p><code>region</code>: The Region where these settings are applied. (Required)</p></li>
    /// <li>
    /// <p><code>readCapacityUnits</code>: The provisioned read capacity units. (Optional)</p></li>
    /// <li>
    /// <p><code>readCapacityAutoScaling</code>: The read capacity auto scaling settings for the table. (Optional)</p></li>
    /// </ul>
    pub fn set_replica_specifications(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::ReplicaSpecification>>) -> Self {
        self.inner = self.inner.set_replica_specifications(input);
        self
    }
    /// <p>The optional Amazon Web Services Region specific settings of a multi-Region table. These settings overwrite the general settings of the table for the specified Region.</p>
    /// <p>For a multi-Region table in provisioned capacity mode, you can configure the table's read capacity differently for each Region's replica. The write capacity, however, remains synchronized between all replicas to ensure that there's enough capacity to replicate writes across all Regions. To define the read capacity for a table replica in a specific Region, you can do so by configuring the following parameters.</p>
    /// <ul>
    /// <li>
    /// <p><code>region</code>: The Region where these settings are applied. (Required)</p></li>
    /// <li>
    /// <p><code>readCapacityUnits</code>: The provisioned read capacity units. (Optional)</p></li>
    /// <li>
    /// <p><code>readCapacityAutoScaling</code>: The read capacity auto scaling settings for the table. (Optional)</p></li>
    /// </ul>
    pub fn get_replica_specifications(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::ReplicaSpecification>> {
        self.inner.get_replica_specifications()
    }
}
