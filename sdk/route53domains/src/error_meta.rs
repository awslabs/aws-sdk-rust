// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// All possible error types for this service.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum Error {
    /// <p> This error is returned if you call <code>AssociateDelegationSignerToDomain</code> when the specified domain has reached the maximum number of DS records. You can't add any additional DS records unless you delete an existing one first. </p>
    DnssecLimitExceeded(crate::error::DnssecLimitExceeded),
    /// <p>The number of domains has exceeded the allowed threshold for the account.</p>
    DomainLimitExceeded(crate::error::DomainLimitExceeded),
    /// <p>The request is already in progress for the domain.</p>
    DuplicateRequest(crate::error::DuplicateRequest),
    /// <p>The requested item is not acceptable. For example, for APIs that accept a domain name, the request might specify a domain name that doesn't belong to the account that submitted the request. For <code>AcceptDomainTransferFromAnotherAwsAccount</code>, the password might be invalid.</p>
    InvalidInput(crate::error::InvalidInput),
    /// <p>The number of operations or jobs running exceeded the allowed threshold for the account.</p>
    OperationLimitExceeded(crate::error::OperationLimitExceeded),
    /// <p>The top-level domain does not support this operation.</p>
    TldRulesViolation(crate::error::TldRulesViolation),
    /// <p>Amazon Route 53 does not support this top-level domain (TLD).</p>
    UnsupportedTld(crate::error::UnsupportedTld),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl std::fmt::Display for Error {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Error::DnssecLimitExceeded(inner) => inner.fmt(f),
            Error::DomainLimitExceeded(inner) => inner.fmt(f),
            Error::DuplicateRequest(inner) => inner.fmt(f),
            Error::InvalidInput(inner) => inner.fmt(f),
            Error::OperationLimitExceeded(inner) => inner.fmt(f),
            Error::TldRulesViolation(inner) => inner.fmt(f),
            Error::UnsupportedTld(inner) => inner.fmt(f),
            Error::Unhandled(inner) => inner.fmt(f),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::error::AcceptDomainTransferFromAnotherAwsAccountError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::error::AcceptDomainTransferFromAnotherAwsAccountError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::AcceptDomainTransferFromAnotherAwsAccountError> for Error {
    fn from(err: crate::error::AcceptDomainTransferFromAnotherAwsAccountError) -> Self {
        match err {
            crate::error::AcceptDomainTransferFromAnotherAwsAccountError::DomainLimitExceeded(inner) => Error::DomainLimitExceeded(inner),
            crate::error::AcceptDomainTransferFromAnotherAwsAccountError::InvalidInput(inner) => Error::InvalidInput(inner),
            crate::error::AcceptDomainTransferFromAnotherAwsAccountError::OperationLimitExceeded(inner) => Error::OperationLimitExceeded(inner),
            crate::error::AcceptDomainTransferFromAnotherAwsAccountError::UnsupportedTld(inner) => Error::UnsupportedTld(inner),
            crate::error::AcceptDomainTransferFromAnotherAwsAccountError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<aws_smithy_http::result::SdkError<crate::error::AssociateDelegationSignerToDomainError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::error::AssociateDelegationSignerToDomainError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::AssociateDelegationSignerToDomainError> for Error {
    fn from(err: crate::error::AssociateDelegationSignerToDomainError) -> Self {
        match err {
            crate::error::AssociateDelegationSignerToDomainError::DnssecLimitExceeded(inner) => {
                Error::DnssecLimitExceeded(inner)
            }
            crate::error::AssociateDelegationSignerToDomainError::DuplicateRequest(inner) => {
                Error::DuplicateRequest(inner)
            }
            crate::error::AssociateDelegationSignerToDomainError::InvalidInput(inner) => {
                Error::InvalidInput(inner)
            }
            crate::error::AssociateDelegationSignerToDomainError::OperationLimitExceeded(inner) => {
                Error::OperationLimitExceeded(inner)
            }
            crate::error::AssociateDelegationSignerToDomainError::TldRulesViolation(inner) => {
                Error::TldRulesViolation(inner)
            }
            crate::error::AssociateDelegationSignerToDomainError::UnsupportedTld(inner) => {
                Error::UnsupportedTld(inner)
            }
            crate::error::AssociateDelegationSignerToDomainError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::error::CancelDomainTransferToAnotherAwsAccountError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::error::CancelDomainTransferToAnotherAwsAccountError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::CancelDomainTransferToAnotherAwsAccountError> for Error {
    fn from(err: crate::error::CancelDomainTransferToAnotherAwsAccountError) -> Self {
        match err {
            crate::error::CancelDomainTransferToAnotherAwsAccountError::InvalidInput(inner) => {
                Error::InvalidInput(inner)
            }
            crate::error::CancelDomainTransferToAnotherAwsAccountError::OperationLimitExceeded(
                inner,
            ) => Error::OperationLimitExceeded(inner),
            crate::error::CancelDomainTransferToAnotherAwsAccountError::UnsupportedTld(inner) => {
                Error::UnsupportedTld(inner)
            }
            crate::error::CancelDomainTransferToAnotherAwsAccountError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::CheckDomainAvailabilityError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::CheckDomainAvailabilityError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::CheckDomainAvailabilityError> for Error {
    fn from(err: crate::error::CheckDomainAvailabilityError) -> Self {
        match err {
            crate::error::CheckDomainAvailabilityError::InvalidInput(inner) => {
                Error::InvalidInput(inner)
            }
            crate::error::CheckDomainAvailabilityError::UnsupportedTld(inner) => {
                Error::UnsupportedTld(inner)
            }
            crate::error::CheckDomainAvailabilityError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::CheckDomainTransferabilityError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::CheckDomainTransferabilityError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::CheckDomainTransferabilityError> for Error {
    fn from(err: crate::error::CheckDomainTransferabilityError) -> Self {
        match err {
            crate::error::CheckDomainTransferabilityError::InvalidInput(inner) => {
                Error::InvalidInput(inner)
            }
            crate::error::CheckDomainTransferabilityError::UnsupportedTld(inner) => {
                Error::UnsupportedTld(inner)
            }
            crate::error::CheckDomainTransferabilityError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DeleteDomainError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::DeleteDomainError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DeleteDomainError> for Error {
    fn from(err: crate::error::DeleteDomainError) -> Self {
        match err {
            crate::error::DeleteDomainError::DuplicateRequest(inner) => {
                Error::DuplicateRequest(inner)
            }
            crate::error::DeleteDomainError::InvalidInput(inner) => Error::InvalidInput(inner),
            crate::error::DeleteDomainError::TldRulesViolation(inner) => {
                Error::TldRulesViolation(inner)
            }
            crate::error::DeleteDomainError::UnsupportedTld(inner) => Error::UnsupportedTld(inner),
            crate::error::DeleteDomainError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DeleteTagsForDomainError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::DeleteTagsForDomainError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DeleteTagsForDomainError> for Error {
    fn from(err: crate::error::DeleteTagsForDomainError) -> Self {
        match err {
            crate::error::DeleteTagsForDomainError::InvalidInput(inner) => {
                Error::InvalidInput(inner)
            }
            crate::error::DeleteTagsForDomainError::OperationLimitExceeded(inner) => {
                Error::OperationLimitExceeded(inner)
            }
            crate::error::DeleteTagsForDomainError::UnsupportedTld(inner) => {
                Error::UnsupportedTld(inner)
            }
            crate::error::DeleteTagsForDomainError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DisableDomainAutoRenewError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::DisableDomainAutoRenewError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DisableDomainAutoRenewError> for Error {
    fn from(err: crate::error::DisableDomainAutoRenewError) -> Self {
        match err {
            crate::error::DisableDomainAutoRenewError::InvalidInput(inner) => {
                Error::InvalidInput(inner)
            }
            crate::error::DisableDomainAutoRenewError::UnsupportedTld(inner) => {
                Error::UnsupportedTld(inner)
            }
            crate::error::DisableDomainAutoRenewError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DisableDomainTransferLockError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::DisableDomainTransferLockError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DisableDomainTransferLockError> for Error {
    fn from(err: crate::error::DisableDomainTransferLockError) -> Self {
        match err {
            crate::error::DisableDomainTransferLockError::DuplicateRequest(inner) => {
                Error::DuplicateRequest(inner)
            }
            crate::error::DisableDomainTransferLockError::InvalidInput(inner) => {
                Error::InvalidInput(inner)
            }
            crate::error::DisableDomainTransferLockError::OperationLimitExceeded(inner) => {
                Error::OperationLimitExceeded(inner)
            }
            crate::error::DisableDomainTransferLockError::TldRulesViolation(inner) => {
                Error::TldRulesViolation(inner)
            }
            crate::error::DisableDomainTransferLockError::UnsupportedTld(inner) => {
                Error::UnsupportedTld(inner)
            }
            crate::error::DisableDomainTransferLockError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::error::DisassociateDelegationSignerFromDomainError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::error::DisassociateDelegationSignerFromDomainError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DisassociateDelegationSignerFromDomainError> for Error {
    fn from(err: crate::error::DisassociateDelegationSignerFromDomainError) -> Self {
        match err {
            crate::error::DisassociateDelegationSignerFromDomainError::DuplicateRequest(inner) => {
                Error::DuplicateRequest(inner)
            }
            crate::error::DisassociateDelegationSignerFromDomainError::InvalidInput(inner) => {
                Error::InvalidInput(inner)
            }
            crate::error::DisassociateDelegationSignerFromDomainError::OperationLimitExceeded(
                inner,
            ) => Error::OperationLimitExceeded(inner),
            crate::error::DisassociateDelegationSignerFromDomainError::TldRulesViolation(inner) => {
                Error::TldRulesViolation(inner)
            }
            crate::error::DisassociateDelegationSignerFromDomainError::UnsupportedTld(inner) => {
                Error::UnsupportedTld(inner)
            }
            crate::error::DisassociateDelegationSignerFromDomainError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::EnableDomainAutoRenewError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::EnableDomainAutoRenewError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::EnableDomainAutoRenewError> for Error {
    fn from(err: crate::error::EnableDomainAutoRenewError) -> Self {
        match err {
            crate::error::EnableDomainAutoRenewError::InvalidInput(inner) => {
                Error::InvalidInput(inner)
            }
            crate::error::EnableDomainAutoRenewError::TldRulesViolation(inner) => {
                Error::TldRulesViolation(inner)
            }
            crate::error::EnableDomainAutoRenewError::UnsupportedTld(inner) => {
                Error::UnsupportedTld(inner)
            }
            crate::error::EnableDomainAutoRenewError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::EnableDomainTransferLockError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::EnableDomainTransferLockError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::EnableDomainTransferLockError> for Error {
    fn from(err: crate::error::EnableDomainTransferLockError) -> Self {
        match err {
            crate::error::EnableDomainTransferLockError::DuplicateRequest(inner) => {
                Error::DuplicateRequest(inner)
            }
            crate::error::EnableDomainTransferLockError::InvalidInput(inner) => {
                Error::InvalidInput(inner)
            }
            crate::error::EnableDomainTransferLockError::OperationLimitExceeded(inner) => {
                Error::OperationLimitExceeded(inner)
            }
            crate::error::EnableDomainTransferLockError::TldRulesViolation(inner) => {
                Error::TldRulesViolation(inner)
            }
            crate::error::EnableDomainTransferLockError::UnsupportedTld(inner) => {
                Error::UnsupportedTld(inner)
            }
            crate::error::EnableDomainTransferLockError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetContactReachabilityStatusError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::GetContactReachabilityStatusError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::GetContactReachabilityStatusError> for Error {
    fn from(err: crate::error::GetContactReachabilityStatusError) -> Self {
        match err {
            crate::error::GetContactReachabilityStatusError::InvalidInput(inner) => {
                Error::InvalidInput(inner)
            }
            crate::error::GetContactReachabilityStatusError::OperationLimitExceeded(inner) => {
                Error::OperationLimitExceeded(inner)
            }
            crate::error::GetContactReachabilityStatusError::UnsupportedTld(inner) => {
                Error::UnsupportedTld(inner)
            }
            crate::error::GetContactReachabilityStatusError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetDomainDetailError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::GetDomainDetailError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::GetDomainDetailError> for Error {
    fn from(err: crate::error::GetDomainDetailError) -> Self {
        match err {
            crate::error::GetDomainDetailError::InvalidInput(inner) => Error::InvalidInput(inner),
            crate::error::GetDomainDetailError::UnsupportedTld(inner) => {
                Error::UnsupportedTld(inner)
            }
            crate::error::GetDomainDetailError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetDomainSuggestionsError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::GetDomainSuggestionsError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::GetDomainSuggestionsError> for Error {
    fn from(err: crate::error::GetDomainSuggestionsError) -> Self {
        match err {
            crate::error::GetDomainSuggestionsError::InvalidInput(inner) => {
                Error::InvalidInput(inner)
            }
            crate::error::GetDomainSuggestionsError::UnsupportedTld(inner) => {
                Error::UnsupportedTld(inner)
            }
            crate::error::GetDomainSuggestionsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetOperationDetailError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::GetOperationDetailError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::GetOperationDetailError> for Error {
    fn from(err: crate::error::GetOperationDetailError) -> Self {
        match err {
            crate::error::GetOperationDetailError::InvalidInput(inner) => {
                Error::InvalidInput(inner)
            }
            crate::error::GetOperationDetailError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ListDomainsError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::ListDomainsError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ListDomainsError> for Error {
    fn from(err: crate::error::ListDomainsError) -> Self {
        match err {
            crate::error::ListDomainsError::InvalidInput(inner) => Error::InvalidInput(inner),
            crate::error::ListDomainsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ListOperationsError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::ListOperationsError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ListOperationsError> for Error {
    fn from(err: crate::error::ListOperationsError) -> Self {
        match err {
            crate::error::ListOperationsError::InvalidInput(inner) => Error::InvalidInput(inner),
            crate::error::ListOperationsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ListPricesError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::ListPricesError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ListPricesError> for Error {
    fn from(err: crate::error::ListPricesError) -> Self {
        match err {
            crate::error::ListPricesError::InvalidInput(inner) => Error::InvalidInput(inner),
            crate::error::ListPricesError::UnsupportedTld(inner) => Error::UnsupportedTld(inner),
            crate::error::ListPricesError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ListTagsForDomainError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::ListTagsForDomainError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ListTagsForDomainError> for Error {
    fn from(err: crate::error::ListTagsForDomainError) -> Self {
        match err {
            crate::error::ListTagsForDomainError::InvalidInput(inner) => Error::InvalidInput(inner),
            crate::error::ListTagsForDomainError::OperationLimitExceeded(inner) => {
                Error::OperationLimitExceeded(inner)
            }
            crate::error::ListTagsForDomainError::UnsupportedTld(inner) => {
                Error::UnsupportedTld(inner)
            }
            crate::error::ListTagsForDomainError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::PushDomainError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::PushDomainError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::PushDomainError> for Error {
    fn from(err: crate::error::PushDomainError) -> Self {
        match err {
            crate::error::PushDomainError::InvalidInput(inner) => Error::InvalidInput(inner),
            crate::error::PushDomainError::OperationLimitExceeded(inner) => {
                Error::OperationLimitExceeded(inner)
            }
            crate::error::PushDomainError::UnsupportedTld(inner) => Error::UnsupportedTld(inner),
            crate::error::PushDomainError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::RegisterDomainError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::RegisterDomainError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::RegisterDomainError> for Error {
    fn from(err: crate::error::RegisterDomainError) -> Self {
        match err {
            crate::error::RegisterDomainError::DomainLimitExceeded(inner) => {
                Error::DomainLimitExceeded(inner)
            }
            crate::error::RegisterDomainError::DuplicateRequest(inner) => {
                Error::DuplicateRequest(inner)
            }
            crate::error::RegisterDomainError::InvalidInput(inner) => Error::InvalidInput(inner),
            crate::error::RegisterDomainError::OperationLimitExceeded(inner) => {
                Error::OperationLimitExceeded(inner)
            }
            crate::error::RegisterDomainError::TldRulesViolation(inner) => {
                Error::TldRulesViolation(inner)
            }
            crate::error::RegisterDomainError::UnsupportedTld(inner) => {
                Error::UnsupportedTld(inner)
            }
            crate::error::RegisterDomainError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::error::RejectDomainTransferFromAnotherAwsAccountError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::error::RejectDomainTransferFromAnotherAwsAccountError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::RejectDomainTransferFromAnotherAwsAccountError> for Error {
    fn from(err: crate::error::RejectDomainTransferFromAnotherAwsAccountError) -> Self {
        match err {
            crate::error::RejectDomainTransferFromAnotherAwsAccountError::InvalidInput(inner) => Error::InvalidInput(inner),
            crate::error::RejectDomainTransferFromAnotherAwsAccountError::OperationLimitExceeded(inner) => Error::OperationLimitExceeded(inner),
            crate::error::RejectDomainTransferFromAnotherAwsAccountError::UnsupportedTld(inner) => Error::UnsupportedTld(inner),
            crate::error::RejectDomainTransferFromAnotherAwsAccountError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::RenewDomainError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::RenewDomainError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::RenewDomainError> for Error {
    fn from(err: crate::error::RenewDomainError) -> Self {
        match err {
            crate::error::RenewDomainError::DuplicateRequest(inner) => {
                Error::DuplicateRequest(inner)
            }
            crate::error::RenewDomainError::InvalidInput(inner) => Error::InvalidInput(inner),
            crate::error::RenewDomainError::OperationLimitExceeded(inner) => {
                Error::OperationLimitExceeded(inner)
            }
            crate::error::RenewDomainError::TldRulesViolation(inner) => {
                Error::TldRulesViolation(inner)
            }
            crate::error::RenewDomainError::UnsupportedTld(inner) => Error::UnsupportedTld(inner),
            crate::error::RenewDomainError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<aws_smithy_http::result::SdkError<crate::error::ResendContactReachabilityEmailError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::error::ResendContactReachabilityEmailError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ResendContactReachabilityEmailError> for Error {
    fn from(err: crate::error::ResendContactReachabilityEmailError) -> Self {
        match err {
            crate::error::ResendContactReachabilityEmailError::InvalidInput(inner) => {
                Error::InvalidInput(inner)
            }
            crate::error::ResendContactReachabilityEmailError::OperationLimitExceeded(inner) => {
                Error::OperationLimitExceeded(inner)
            }
            crate::error::ResendContactReachabilityEmailError::UnsupportedTld(inner) => {
                Error::UnsupportedTld(inner)
            }
            crate::error::ResendContactReachabilityEmailError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ResendOperationAuthorizationError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::ResendOperationAuthorizationError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ResendOperationAuthorizationError> for Error {
    fn from(err: crate::error::ResendOperationAuthorizationError) -> Self {
        match err {
            crate::error::ResendOperationAuthorizationError::InvalidInput(inner) => {
                Error::InvalidInput(inner)
            }
            crate::error::ResendOperationAuthorizationError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::RetrieveDomainAuthCodeError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::RetrieveDomainAuthCodeError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::RetrieveDomainAuthCodeError> for Error {
    fn from(err: crate::error::RetrieveDomainAuthCodeError) -> Self {
        match err {
            crate::error::RetrieveDomainAuthCodeError::InvalidInput(inner) => {
                Error::InvalidInput(inner)
            }
            crate::error::RetrieveDomainAuthCodeError::UnsupportedTld(inner) => {
                Error::UnsupportedTld(inner)
            }
            crate::error::RetrieveDomainAuthCodeError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::TransferDomainError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::TransferDomainError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::TransferDomainError> for Error {
    fn from(err: crate::error::TransferDomainError) -> Self {
        match err {
            crate::error::TransferDomainError::DomainLimitExceeded(inner) => {
                Error::DomainLimitExceeded(inner)
            }
            crate::error::TransferDomainError::DuplicateRequest(inner) => {
                Error::DuplicateRequest(inner)
            }
            crate::error::TransferDomainError::InvalidInput(inner) => Error::InvalidInput(inner),
            crate::error::TransferDomainError::OperationLimitExceeded(inner) => {
                Error::OperationLimitExceeded(inner)
            }
            crate::error::TransferDomainError::TldRulesViolation(inner) => {
                Error::TldRulesViolation(inner)
            }
            crate::error::TransferDomainError::UnsupportedTld(inner) => {
                Error::UnsupportedTld(inner)
            }
            crate::error::TransferDomainError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<aws_smithy_http::result::SdkError<crate::error::TransferDomainToAnotherAwsAccountError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::error::TransferDomainToAnotherAwsAccountError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::TransferDomainToAnotherAwsAccountError> for Error {
    fn from(err: crate::error::TransferDomainToAnotherAwsAccountError) -> Self {
        match err {
            crate::error::TransferDomainToAnotherAwsAccountError::DuplicateRequest(inner) => {
                Error::DuplicateRequest(inner)
            }
            crate::error::TransferDomainToAnotherAwsAccountError::InvalidInput(inner) => {
                Error::InvalidInput(inner)
            }
            crate::error::TransferDomainToAnotherAwsAccountError::OperationLimitExceeded(inner) => {
                Error::OperationLimitExceeded(inner)
            }
            crate::error::TransferDomainToAnotherAwsAccountError::UnsupportedTld(inner) => {
                Error::UnsupportedTld(inner)
            }
            crate::error::TransferDomainToAnotherAwsAccountError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::UpdateDomainContactError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::UpdateDomainContactError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::UpdateDomainContactError> for Error {
    fn from(err: crate::error::UpdateDomainContactError) -> Self {
        match err {
            crate::error::UpdateDomainContactError::DuplicateRequest(inner) => {
                Error::DuplicateRequest(inner)
            }
            crate::error::UpdateDomainContactError::InvalidInput(inner) => {
                Error::InvalidInput(inner)
            }
            crate::error::UpdateDomainContactError::OperationLimitExceeded(inner) => {
                Error::OperationLimitExceeded(inner)
            }
            crate::error::UpdateDomainContactError::TldRulesViolation(inner) => {
                Error::TldRulesViolation(inner)
            }
            crate::error::UpdateDomainContactError::UnsupportedTld(inner) => {
                Error::UnsupportedTld(inner)
            }
            crate::error::UpdateDomainContactError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::UpdateDomainContactPrivacyError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::UpdateDomainContactPrivacyError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::UpdateDomainContactPrivacyError> for Error {
    fn from(err: crate::error::UpdateDomainContactPrivacyError) -> Self {
        match err {
            crate::error::UpdateDomainContactPrivacyError::DuplicateRequest(inner) => {
                Error::DuplicateRequest(inner)
            }
            crate::error::UpdateDomainContactPrivacyError::InvalidInput(inner) => {
                Error::InvalidInput(inner)
            }
            crate::error::UpdateDomainContactPrivacyError::OperationLimitExceeded(inner) => {
                Error::OperationLimitExceeded(inner)
            }
            crate::error::UpdateDomainContactPrivacyError::TldRulesViolation(inner) => {
                Error::TldRulesViolation(inner)
            }
            crate::error::UpdateDomainContactPrivacyError::UnsupportedTld(inner) => {
                Error::UnsupportedTld(inner)
            }
            crate::error::UpdateDomainContactPrivacyError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::UpdateDomainNameserversError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::UpdateDomainNameserversError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::UpdateDomainNameserversError> for Error {
    fn from(err: crate::error::UpdateDomainNameserversError) -> Self {
        match err {
            crate::error::UpdateDomainNameserversError::DuplicateRequest(inner) => {
                Error::DuplicateRequest(inner)
            }
            crate::error::UpdateDomainNameserversError::InvalidInput(inner) => {
                Error::InvalidInput(inner)
            }
            crate::error::UpdateDomainNameserversError::OperationLimitExceeded(inner) => {
                Error::OperationLimitExceeded(inner)
            }
            crate::error::UpdateDomainNameserversError::TldRulesViolation(inner) => {
                Error::TldRulesViolation(inner)
            }
            crate::error::UpdateDomainNameserversError::UnsupportedTld(inner) => {
                Error::UnsupportedTld(inner)
            }
            crate::error::UpdateDomainNameserversError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::UpdateTagsForDomainError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::UpdateTagsForDomainError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::UpdateTagsForDomainError> for Error {
    fn from(err: crate::error::UpdateTagsForDomainError) -> Self {
        match err {
            crate::error::UpdateTagsForDomainError::InvalidInput(inner) => {
                Error::InvalidInput(inner)
            }
            crate::error::UpdateTagsForDomainError::OperationLimitExceeded(inner) => {
                Error::OperationLimitExceeded(inner)
            }
            crate::error::UpdateTagsForDomainError::UnsupportedTld(inner) => {
                Error::UnsupportedTld(inner)
            }
            crate::error::UpdateTagsForDomainError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ViewBillingError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::ViewBillingError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ViewBillingError> for Error {
    fn from(err: crate::error::ViewBillingError) -> Self {
        match err {
            crate::error::ViewBillingError::InvalidInput(inner) => Error::InvalidInput(inner),
            crate::error::ViewBillingError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl std::error::Error for Error {}
impl aws_http::request_id::RequestId for Error {
    fn request_id(&self) -> Option<&str> {
        match self {
            Self::DnssecLimitExceeded(e) => e.request_id(),
            Self::DomainLimitExceeded(e) => e.request_id(),
            Self::DuplicateRequest(e) => e.request_id(),
            Self::InvalidInput(e) => e.request_id(),
            Self::OperationLimitExceeded(e) => e.request_id(),
            Self::TldRulesViolation(e) => e.request_id(),
            Self::UnsupportedTld(e) => e.request_id(),
            Self::Unhandled(e) => e.request_id(),
        }
    }
}
