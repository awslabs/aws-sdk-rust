// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[derive(std::fmt::Debug)]
pub(crate) struct Handle<C = aws_hyper::DynConnector> {
    client: aws_hyper::Client<C>,
    conf: crate::Config,
}

#[derive(Clone, std::fmt::Debug)]
pub struct Client<C = aws_hyper::DynConnector> {
    handle: std::sync::Arc<Handle<C>>,
}
impl<C> Client<C> {
    pub fn from_conf_conn(conf: crate::Config, conn: C) -> Self {
        let client = aws_hyper::Client::new(conn);
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }

    pub fn conf(&self) -> &crate::Config {
        &self.handle.conf
    }
}
impl Client {
    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_env() -> Self {
        Self::from_conf(crate::Config::builder().build())
    }

    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_conf(conf: crate::Config) -> Self {
        let client = aws_hyper::Client::https();
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }
}
impl<C> Client<C>
where
    C: aws_hyper::SmithyConnector,
{
    pub fn accept_domain_transfer_from_another_aws_account(
        &self,
    ) -> fluent_builders::AcceptDomainTransferFromAnotherAwsAccount<C> {
        fluent_builders::AcceptDomainTransferFromAnotherAwsAccount::new(self.handle.clone())
    }
    pub fn cancel_domain_transfer_to_another_aws_account(
        &self,
    ) -> fluent_builders::CancelDomainTransferToAnotherAwsAccount<C> {
        fluent_builders::CancelDomainTransferToAnotherAwsAccount::new(self.handle.clone())
    }
    pub fn check_domain_availability(&self) -> fluent_builders::CheckDomainAvailability<C> {
        fluent_builders::CheckDomainAvailability::new(self.handle.clone())
    }
    pub fn check_domain_transferability(&self) -> fluent_builders::CheckDomainTransferability<C> {
        fluent_builders::CheckDomainTransferability::new(self.handle.clone())
    }
    pub fn delete_tags_for_domain(&self) -> fluent_builders::DeleteTagsForDomain<C> {
        fluent_builders::DeleteTagsForDomain::new(self.handle.clone())
    }
    pub fn disable_domain_auto_renew(&self) -> fluent_builders::DisableDomainAutoRenew<C> {
        fluent_builders::DisableDomainAutoRenew::new(self.handle.clone())
    }
    pub fn disable_domain_transfer_lock(&self) -> fluent_builders::DisableDomainTransferLock<C> {
        fluent_builders::DisableDomainTransferLock::new(self.handle.clone())
    }
    pub fn enable_domain_auto_renew(&self) -> fluent_builders::EnableDomainAutoRenew<C> {
        fluent_builders::EnableDomainAutoRenew::new(self.handle.clone())
    }
    pub fn enable_domain_transfer_lock(&self) -> fluent_builders::EnableDomainTransferLock<C> {
        fluent_builders::EnableDomainTransferLock::new(self.handle.clone())
    }
    pub fn get_contact_reachability_status(
        &self,
    ) -> fluent_builders::GetContactReachabilityStatus<C> {
        fluent_builders::GetContactReachabilityStatus::new(self.handle.clone())
    }
    pub fn get_domain_detail(&self) -> fluent_builders::GetDomainDetail<C> {
        fluent_builders::GetDomainDetail::new(self.handle.clone())
    }
    pub fn get_domain_suggestions(&self) -> fluent_builders::GetDomainSuggestions<C> {
        fluent_builders::GetDomainSuggestions::new(self.handle.clone())
    }
    pub fn get_operation_detail(&self) -> fluent_builders::GetOperationDetail<C> {
        fluent_builders::GetOperationDetail::new(self.handle.clone())
    }
    pub fn list_domains(&self) -> fluent_builders::ListDomains<C> {
        fluent_builders::ListDomains::new(self.handle.clone())
    }
    pub fn list_operations(&self) -> fluent_builders::ListOperations<C> {
        fluent_builders::ListOperations::new(self.handle.clone())
    }
    pub fn list_tags_for_domain(&self) -> fluent_builders::ListTagsForDomain<C> {
        fluent_builders::ListTagsForDomain::new(self.handle.clone())
    }
    pub fn register_domain(&self) -> fluent_builders::RegisterDomain<C> {
        fluent_builders::RegisterDomain::new(self.handle.clone())
    }
    pub fn reject_domain_transfer_from_another_aws_account(
        &self,
    ) -> fluent_builders::RejectDomainTransferFromAnotherAwsAccount<C> {
        fluent_builders::RejectDomainTransferFromAnotherAwsAccount::new(self.handle.clone())
    }
    pub fn renew_domain(&self) -> fluent_builders::RenewDomain<C> {
        fluent_builders::RenewDomain::new(self.handle.clone())
    }
    pub fn resend_contact_reachability_email(
        &self,
    ) -> fluent_builders::ResendContactReachabilityEmail<C> {
        fluent_builders::ResendContactReachabilityEmail::new(self.handle.clone())
    }
    pub fn retrieve_domain_auth_code(&self) -> fluent_builders::RetrieveDomainAuthCode<C> {
        fluent_builders::RetrieveDomainAuthCode::new(self.handle.clone())
    }
    pub fn transfer_domain(&self) -> fluent_builders::TransferDomain<C> {
        fluent_builders::TransferDomain::new(self.handle.clone())
    }
    pub fn transfer_domain_to_another_aws_account(
        &self,
    ) -> fluent_builders::TransferDomainToAnotherAwsAccount<C> {
        fluent_builders::TransferDomainToAnotherAwsAccount::new(self.handle.clone())
    }
    pub fn update_domain_contact(&self) -> fluent_builders::UpdateDomainContact<C> {
        fluent_builders::UpdateDomainContact::new(self.handle.clone())
    }
    pub fn update_domain_contact_privacy(&self) -> fluent_builders::UpdateDomainContactPrivacy<C> {
        fluent_builders::UpdateDomainContactPrivacy::new(self.handle.clone())
    }
    pub fn update_domain_nameservers(&self) -> fluent_builders::UpdateDomainNameservers<C> {
        fluent_builders::UpdateDomainNameservers::new(self.handle.clone())
    }
    pub fn update_tags_for_domain(&self) -> fluent_builders::UpdateTagsForDomain<C> {
        fluent_builders::UpdateTagsForDomain::new(self.handle.clone())
    }
    pub fn view_billing(&self) -> fluent_builders::ViewBilling<C> {
        fluent_builders::ViewBilling::new(self.handle.clone())
    }
}
pub mod fluent_builders {
    #[derive(std::fmt::Debug)]
    pub struct AcceptDomainTransferFromAnotherAwsAccount<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::accept_domain_transfer_from_another_aws_account_input::Builder,
    }
    impl<C> AcceptDomainTransferFromAnotherAwsAccount<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::AcceptDomainTransferFromAnotherAwsAccountOutput,
            smithy_http::result::SdkError<
                crate::error::AcceptDomainTransferFromAnotherAwsAccountError,
            >,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the domain that was specified when another AWS account submitted a
        /// <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains_TransferDomainToAnotherAwsAccount.html">TransferDomainToAnotherAwsAccount</a>
        /// request.
        /// </p>
        pub fn domain_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain_name(input);
            self
        }
        pub fn set_domain_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain_name(input);
            self
        }
        /// <p>The password that was returned by the
        /// <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains_TransferDomainToAnotherAwsAccount.html">TransferDomainToAnotherAwsAccount</a>
        /// request.
        /// </p>
        pub fn password(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.password(input);
            self
        }
        pub fn set_password(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_password(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CancelDomainTransferToAnotherAwsAccount<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::cancel_domain_transfer_to_another_aws_account_input::Builder,
    }
    impl<C> CancelDomainTransferToAnotherAwsAccount<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CancelDomainTransferToAnotherAwsAccountOutput,
            smithy_http::result::SdkError<
                crate::error::CancelDomainTransferToAnotherAwsAccountError,
            >,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the domain for which you want to cancel the transfer to another AWS account.</p>
        pub fn domain_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain_name(input);
            self
        }
        pub fn set_domain_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CheckDomainAvailability<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::check_domain_availability_input::Builder,
    }
    impl<C> CheckDomainAvailability<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CheckDomainAvailabilityOutput,
            smithy_http::result::SdkError<crate::error::CheckDomainAvailabilityError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the domain that you want to get availability for. The top-level domain (TLD), such as .com, must be a TLD that Route 53 supports.
        /// For a list of supported TLDs, see
        /// <a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/registrar-tld-list.html">Domains that You Can Register with Amazon Route 53</a> in the
        /// <i>Amazon Route 53 Developer Guide</i>.</p>
        /// <p>The domain name can contain only the following characters:</p>
        /// <ul>
        /// <li>
        /// <p>Letters a through z. Domain names are not case sensitive.</p>
        /// </li>
        /// <li>
        /// <p>Numbers 0 through 9.</p>
        /// </li>
        /// <li>
        /// <p>Hyphen (-). You can't specify a hyphen at the beginning or end of a label. </p>
        /// </li>
        /// <li>
        /// <p>Period (.) to separate the labels in the name, such as the <code>.</code> in <code>example.com</code>.</p>
        /// </li>
        /// </ul>
        /// <p>Internationalized domain names are not supported for some top-level domains. To determine whether the TLD that you want to use supports
        /// internationalized domain names, see
        /// <a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/registrar-tld-list.html">Domains that You Can Register with Amazon Route 53</a>.
        /// For more information, see
        /// <a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/DomainNameFormat.html#domain-name-format-idns">Formatting Internationalized Domain Names</a>.
        /// </p>
        pub fn domain_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain_name(input);
            self
        }
        pub fn set_domain_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain_name(input);
            self
        }
        /// <p>Reserved for future use.</p>
        pub fn idn_lang_code(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.idn_lang_code(input);
            self
        }
        pub fn set_idn_lang_code(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_idn_lang_code(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CheckDomainTransferability<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::check_domain_transferability_input::Builder,
    }
    impl<C> CheckDomainTransferability<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CheckDomainTransferabilityOutput,
            smithy_http::result::SdkError<crate::error::CheckDomainTransferabilityError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the domain that you want to transfer to Route 53. The top-level domain (TLD), such as .com, must be a TLD that Route 53 supports.
        /// For a list of supported TLDs, see
        /// <a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/registrar-tld-list.html">Domains that You Can Register with Amazon Route 53</a> in the
        /// <i>Amazon Route 53 Developer Guide</i>.</p>
        /// <p>The domain name can contain only the following characters:</p>
        /// <ul>
        /// <li>
        /// <p>Letters a through z. Domain names are not case sensitive.</p>
        /// </li>
        /// <li>
        /// <p>Numbers 0 through 9.</p>
        /// </li>
        /// <li>
        /// <p>Hyphen (-). You can't specify a hyphen at the beginning or end of a label. </p>
        /// </li>
        /// <li>
        /// <p>Period (.) to separate the labels in the name, such as the <code>.</code> in <code>example.com</code>.</p>
        /// </li>
        /// </ul>
        pub fn domain_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain_name(input);
            self
        }
        pub fn set_domain_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain_name(input);
            self
        }
        /// <p>If the registrar for the top-level domain (TLD) requires an authorization code to transfer the domain,
        /// the code that you got from the current registrar for the domain.</p>
        pub fn auth_code(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.auth_code(input);
            self
        }
        pub fn set_auth_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_auth_code(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteTagsForDomain<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_tags_for_domain_input::Builder,
    }
    impl<C> DeleteTagsForDomain<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteTagsForDomainOutput,
            smithy_http::result::SdkError<crate::error::DeleteTagsForDomainError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The domain for which you want to delete one or more tags.</p>
        pub fn domain_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain_name(input);
            self
        }
        pub fn set_domain_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain_name(input);
            self
        }
        /// <p>A list of tag keys to delete.</p>
        pub fn tags_to_delete(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.tags_to_delete(inp);
            self
        }
        pub fn set_tags_to_delete(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_tags_to_delete(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DisableDomainAutoRenew<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::disable_domain_auto_renew_input::Builder,
    }
    impl<C> DisableDomainAutoRenew<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DisableDomainAutoRenewOutput,
            smithy_http::result::SdkError<crate::error::DisableDomainAutoRenewError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the domain that you want to disable automatic renewal for.</p>
        pub fn domain_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain_name(input);
            self
        }
        pub fn set_domain_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DisableDomainTransferLock<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::disable_domain_transfer_lock_input::Builder,
    }
    impl<C> DisableDomainTransferLock<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DisableDomainTransferLockOutput,
            smithy_http::result::SdkError<crate::error::DisableDomainTransferLockError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the domain that you want to remove the transfer lock for.</p>
        pub fn domain_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain_name(input);
            self
        }
        pub fn set_domain_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct EnableDomainAutoRenew<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::enable_domain_auto_renew_input::Builder,
    }
    impl<C> EnableDomainAutoRenew<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::EnableDomainAutoRenewOutput,
            smithy_http::result::SdkError<crate::error::EnableDomainAutoRenewError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the domain that you want to enable automatic renewal for.</p>
        pub fn domain_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain_name(input);
            self
        }
        pub fn set_domain_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct EnableDomainTransferLock<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::enable_domain_transfer_lock_input::Builder,
    }
    impl<C> EnableDomainTransferLock<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::EnableDomainTransferLockOutput,
            smithy_http::result::SdkError<crate::error::EnableDomainTransferLockError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the domain that you want to set the transfer lock for.</p>
        pub fn domain_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain_name(input);
            self
        }
        pub fn set_domain_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetContactReachabilityStatus<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_contact_reachability_status_input::Builder,
    }
    impl<C> GetContactReachabilityStatus<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetContactReachabilityStatusOutput,
            smithy_http::result::SdkError<crate::error::GetContactReachabilityStatusError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the domain for which you want to know whether the registrant contact has confirmed that the email address is valid.</p>
        pub fn domain_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain_name(input);
            self
        }
        pub fn set_domain_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetDomainDetail<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_domain_detail_input::Builder,
    }
    impl<C> GetDomainDetail<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetDomainDetailOutput,
            smithy_http::result::SdkError<crate::error::GetDomainDetailError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the domain that you want to get detailed information about.</p>
        pub fn domain_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain_name(input);
            self
        }
        pub fn set_domain_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetDomainSuggestions<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_domain_suggestions_input::Builder,
    }
    impl<C> GetDomainSuggestions<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetDomainSuggestionsOutput,
            smithy_http::result::SdkError<crate::error::GetDomainSuggestionsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A domain name that you want to use as the basis for a list of possible domain names. The top-level domain (TLD), such as .com,
        /// must be a TLD that Route 53 supports. For a list of supported TLDs, see
        /// <a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/registrar-tld-list.html">Domains that You Can Register with Amazon Route 53</a> in the
        /// <i>Amazon Route 53 Developer Guide</i>.</p>
        /// <p>The domain name can contain only the following characters:</p>
        /// <ul>
        /// <li>
        /// <p>Letters a through z. Domain names are not case sensitive.</p>
        /// </li>
        /// <li>
        /// <p>Numbers 0 through 9.</p>
        /// </li>
        /// <li>
        /// <p>Hyphen (-). You can't specify a hyphen at the beginning or end of a label. </p>
        /// </li>
        /// <li>
        /// <p>Period (.) to separate the labels in the name, such as the <code>.</code> in <code>example.com</code>.</p>
        /// </li>
        /// </ul>
        /// <p>Internationalized domain names are not supported for some top-level domains. To determine whether the TLD that you want to use
        /// supports internationalized domain names, see
        /// <a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/registrar-tld-list.html">Domains that You Can Register with Amazon Route 53</a>.
        /// </p>
        pub fn domain_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain_name(input);
            self
        }
        pub fn set_domain_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain_name(input);
            self
        }
        /// <p>The number of suggested domain names that you want Route 53 to return. Specify a value between 1 and 50.</p>
        pub fn suggestion_count(mut self, input: i32) -> Self {
            self.inner = self.inner.suggestion_count(input);
            self
        }
        pub fn set_suggestion_count(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_suggestion_count(input);
            self
        }
        /// <p>If <code>OnlyAvailable</code> is <code>true</code>, Route 53 returns only domain names that are available.
        /// If <code>OnlyAvailable</code> is <code>false</code>, Route 53 returns domain names without checking whether they're
        /// available to be registered. To determine whether the domain is available, you can call <code>checkDomainAvailability</code>
        /// for each suggestion.</p>
        pub fn only_available(mut self, input: bool) -> Self {
            self.inner = self.inner.only_available(input);
            self
        }
        pub fn set_only_available(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_only_available(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetOperationDetail<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_operation_detail_input::Builder,
    }
    impl<C> GetOperationDetail<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetOperationDetailOutput,
            smithy_http::result::SdkError<crate::error::GetOperationDetailError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identifier for the operation for which you want to get the status. Route 53 returned the identifier
        /// in the response to the original request.</p>
        pub fn operation_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.operation_id(input);
            self
        }
        pub fn set_operation_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_operation_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListDomains<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_domains_input::Builder,
    }
    impl<C> ListDomains<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListDomainsOutput,
            smithy_http::result::SdkError<crate::error::ListDomainsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>For an initial request for a list of domains, omit this element. If the number of domains
        /// that are associated with the current AWS account is greater than the value that you specified for
        /// <code>MaxItems</code>, you can use <code>Marker</code> to return additional domains. Get the value of
        /// <code>NextPageMarker</code> from the previous response, and submit another request that includes the
        /// value of <code>NextPageMarker</code> in the <code>Marker</code> element.</p>
        /// <p>Constraints: The marker must match the value specified in the previous request.</p>
        pub fn marker(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(input);
            self
        }
        pub fn set_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(input);
            self
        }
        /// <p>Number of domains to be returned.</p>
        /// <p>Default: 20</p>
        pub fn max_items(mut self, input: i32) -> Self {
            self.inner = self.inner.max_items(input);
            self
        }
        pub fn set_max_items(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_items(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListOperations<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_operations_input::Builder,
    }
    impl<C> ListOperations<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListOperationsOutput,
            smithy_http::result::SdkError<crate::error::ListOperationsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>An optional parameter that lets you get information about all the operations that you submitted after a specified date and time.
        /// Specify the date and time in Unix time format and Coordinated Universal time (UTC).</p>
        pub fn submitted_since(mut self, input: smithy_types::Instant) -> Self {
            self.inner = self.inner.submitted_since(input);
            self
        }
        pub fn set_submitted_since(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.inner = self.inner.set_submitted_since(input);
            self
        }
        /// <p>For an initial request for a list of operations, omit this element. If the number of operations that are
        /// not yet complete is greater than the value that you specified for <code>MaxItems</code>, you can use <code>Marker</code>
        /// to return additional operations. Get the value of <code>NextPageMarker</code> from the previous response,
        /// and submit another request that includes the value of <code>NextPageMarker</code> in the <code>Marker</code> element.</p>
        pub fn marker(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(input);
            self
        }
        pub fn set_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(input);
            self
        }
        /// <p>Number of domains to be returned.</p>
        /// <p>Default: 20</p>
        pub fn max_items(mut self, input: i32) -> Self {
            self.inner = self.inner.max_items(input);
            self
        }
        pub fn set_max_items(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_items(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListTagsForDomain<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_tags_for_domain_input::Builder,
    }
    impl<C> ListTagsForDomain<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListTagsForDomainOutput,
            smithy_http::result::SdkError<crate::error::ListTagsForDomainError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The domain for which you want to get a list of tags.</p>
        pub fn domain_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain_name(input);
            self
        }
        pub fn set_domain_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RegisterDomain<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::register_domain_input::Builder,
    }
    impl<C> RegisterDomain<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::RegisterDomainOutput,
            smithy_http::result::SdkError<crate::error::RegisterDomainError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The domain name that you want to register. The top-level domain (TLD), such as .com, must be a TLD that Route 53 supports.
        /// For a list of supported TLDs, see
        /// <a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/registrar-tld-list.html">Domains that You Can Register with Amazon Route 53</a> in the
        /// <i>Amazon Route 53 Developer Guide</i>.</p>
        /// <p>The domain name can contain only the following characters:</p>
        /// <ul>
        /// <li>
        /// <p>Letters a through z. Domain names are not case sensitive.</p>
        /// </li>
        /// <li>
        /// <p>Numbers 0 through 9.</p>
        /// </li>
        /// <li>
        /// <p>Hyphen (-). You can't specify a hyphen at the beginning or end of a label. </p>
        /// </li>
        /// <li>
        /// <p>Period (.) to separate the labels in the name, such as the <code>.</code> in <code>example.com</code>.</p>
        /// </li>
        /// </ul>
        /// <p>Internationalized domain names are not supported for some top-level domains. To determine whether the TLD that you want to use supports
        /// internationalized domain names, see
        /// <a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/registrar-tld-list.html">Domains that You Can Register with Amazon Route 53</a>.
        /// For more information, see
        /// <a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/DomainNameFormat.html#domain-name-format-idns">Formatting Internationalized Domain Names</a>.
        /// </p>
        pub fn domain_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain_name(input);
            self
        }
        pub fn set_domain_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain_name(input);
            self
        }
        /// <p>Reserved for future use.</p>
        pub fn idn_lang_code(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.idn_lang_code(input);
            self
        }
        pub fn set_idn_lang_code(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_idn_lang_code(input);
            self
        }
        /// <p>The number of years that you want to register the domain for. Domains are registered for a minimum of one year.
        /// The maximum period depends on the top-level domain. For the range of valid values for your domain, see
        /// <a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/registrar-tld-list.html">Domains that You Can Register with Amazon Route 53</a> in the
        /// <i>Amazon Route 53 Developer Guide</i>.</p>
        /// <p>Default: 1</p>
        pub fn duration_in_years(mut self, input: i32) -> Self {
            self.inner = self.inner.duration_in_years(input);
            self
        }
        pub fn set_duration_in_years(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_duration_in_years(input);
            self
        }
        /// <p>Indicates whether the domain will be automatically renewed (<code>true</code>) or not (<code>false</code>).
        /// Autorenewal only takes effect after the account is charged.</p>
        /// <p>Default: <code>true</code>
        /// </p>
        pub fn auto_renew(mut self, input: bool) -> Self {
            self.inner = self.inner.auto_renew(input);
            self
        }
        pub fn set_auto_renew(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_auto_renew(input);
            self
        }
        /// <p>Provides detailed contact information. For information about the values that you specify for each element, see
        /// <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains_ContactDetail.html">ContactDetail</a>.</p>
        pub fn admin_contact(mut self, input: crate::model::ContactDetail) -> Self {
            self.inner = self.inner.admin_contact(input);
            self
        }
        pub fn set_admin_contact(
            mut self,
            input: std::option::Option<crate::model::ContactDetail>,
        ) -> Self {
            self.inner = self.inner.set_admin_contact(input);
            self
        }
        /// <p>Provides detailed contact information. For information about the values that you specify for each element, see
        /// <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains_ContactDetail.html">ContactDetail</a>.</p>
        pub fn registrant_contact(mut self, input: crate::model::ContactDetail) -> Self {
            self.inner = self.inner.registrant_contact(input);
            self
        }
        pub fn set_registrant_contact(
            mut self,
            input: std::option::Option<crate::model::ContactDetail>,
        ) -> Self {
            self.inner = self.inner.set_registrant_contact(input);
            self
        }
        /// <p>Provides detailed contact information. For information about the values that you specify for each element, see
        /// <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains_ContactDetail.html">ContactDetail</a>.</p>
        pub fn tech_contact(mut self, input: crate::model::ContactDetail) -> Self {
            self.inner = self.inner.tech_contact(input);
            self
        }
        pub fn set_tech_contact(
            mut self,
            input: std::option::Option<crate::model::ContactDetail>,
        ) -> Self {
            self.inner = self.inner.set_tech_contact(input);
            self
        }
        /// <p>Whether you want to conceal contact information from WHOIS queries. If you specify <code>true</code>,
        /// WHOIS ("who is") queries return contact information either for Amazon Registrar (for .com, .net, and .org domains)
        /// or for our registrar associate, Gandi (for all other TLDs). If you specify <code>false</code>,
        /// WHOIS queries return the information that you entered for the admin contact.</p>
        /// <p>Default: <code>true</code>
        /// </p>
        pub fn privacy_protect_admin_contact(mut self, input: bool) -> Self {
            self.inner = self.inner.privacy_protect_admin_contact(input);
            self
        }
        pub fn set_privacy_protect_admin_contact(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.inner = self.inner.set_privacy_protect_admin_contact(input);
            self
        }
        /// <p>Whether you want to conceal contact information from WHOIS queries. If you specify <code>true</code>,
        /// WHOIS ("who is") queries return contact information either for Amazon Registrar (for .com, .net, and .org domains)
        /// or for our registrar associate, Gandi (for all other TLDs). If you specify <code>false</code>,
        /// WHOIS queries return the information that you entered for the registrant contact (the domain owner).</p>
        /// <p>Default: <code>true</code>
        /// </p>
        pub fn privacy_protect_registrant_contact(mut self, input: bool) -> Self {
            self.inner = self.inner.privacy_protect_registrant_contact(input);
            self
        }
        pub fn set_privacy_protect_registrant_contact(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.inner = self.inner.set_privacy_protect_registrant_contact(input);
            self
        }
        /// <p>Whether you want to conceal contact information from WHOIS queries. If you specify <code>true</code>,
        /// WHOIS ("who is") queries return contact information either for Amazon Registrar (for .com, .net, and .org domains)
        /// or for our registrar associate, Gandi (for all other TLDs). If you specify <code>false</code>,
        /// WHOIS queries return the information that you entered for the technical contact.</p>
        /// <p>Default: <code>true</code>
        /// </p>
        pub fn privacy_protect_tech_contact(mut self, input: bool) -> Self {
            self.inner = self.inner.privacy_protect_tech_contact(input);
            self
        }
        pub fn set_privacy_protect_tech_contact(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.inner = self.inner.set_privacy_protect_tech_contact(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RejectDomainTransferFromAnotherAwsAccount<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::reject_domain_transfer_from_another_aws_account_input::Builder,
    }
    impl<C> RejectDomainTransferFromAnotherAwsAccount<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::RejectDomainTransferFromAnotherAwsAccountOutput,
            smithy_http::result::SdkError<
                crate::error::RejectDomainTransferFromAnotherAwsAccountError,
            >,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the domain that was specified when another AWS account submitted a
        /// <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains_TransferDomainToAnotherAwsAccount.html">TransferDomainToAnotherAwsAccount</a>
        /// request.
        /// </p>
        pub fn domain_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain_name(input);
            self
        }
        pub fn set_domain_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RenewDomain<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::renew_domain_input::Builder,
    }
    impl<C> RenewDomain<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::RenewDomainOutput,
            smithy_http::result::SdkError<crate::error::RenewDomainError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the domain that you want to renew.</p>
        pub fn domain_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain_name(input);
            self
        }
        pub fn set_domain_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain_name(input);
            self
        }
        /// <p>The number of years that you want to renew the domain for. The maximum number of years depends on the top-level domain.
        /// For the range of valid values for your domain, see
        /// <a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/registrar-tld-list.html">Domains that You Can Register with Amazon Route 53</a> in the
        /// <i>Amazon Route 53 Developer Guide</i>.</p>
        /// <p>Default: 1</p>
        pub fn duration_in_years(mut self, input: i32) -> Self {
            self.inner = self.inner.duration_in_years(input);
            self
        }
        pub fn set_duration_in_years(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_duration_in_years(input);
            self
        }
        /// <p>The year when the registration for the domain is set to expire. This value must match the current expiration date for the domain.</p>
        pub fn current_expiry_year(mut self, input: i32) -> Self {
            self.inner = self.inner.current_expiry_year(input);
            self
        }
        pub fn set_current_expiry_year(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_current_expiry_year(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ResendContactReachabilityEmail<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::resend_contact_reachability_email_input::Builder,
    }
    impl<C> ResendContactReachabilityEmail<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ResendContactReachabilityEmailOutput,
            smithy_http::result::SdkError<crate::error::ResendContactReachabilityEmailError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the domain for which you want Route 53 to resend a confirmation email to the registrant contact.</p>
        pub fn domain_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain_name(input);
            self
        }
        pub fn set_domain_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RetrieveDomainAuthCode<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::retrieve_domain_auth_code_input::Builder,
    }
    impl<C> RetrieveDomainAuthCode<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::RetrieveDomainAuthCodeOutput,
            smithy_http::result::SdkError<crate::error::RetrieveDomainAuthCodeError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the domain that you want to get an authorization code for.</p>
        pub fn domain_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain_name(input);
            self
        }
        pub fn set_domain_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct TransferDomain<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::transfer_domain_input::Builder,
    }
    impl<C> TransferDomain<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::TransferDomainOutput,
            smithy_http::result::SdkError<crate::error::TransferDomainError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the domain that you want to transfer to Route 53. The top-level domain (TLD), such as .com, must be a TLD that Route 53 supports.
        /// For a list of supported TLDs, see
        /// <a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/registrar-tld-list.html">Domains that You Can Register with Amazon Route 53</a> in the
        /// <i>Amazon Route 53 Developer Guide</i>.</p>
        /// <p>The domain name can contain only the following characters:</p>
        /// <ul>
        /// <li>
        /// <p>Letters a through z. Domain names are not case sensitive.</p>
        /// </li>
        /// <li>
        /// <p>Numbers 0 through 9.</p>
        /// </li>
        /// <li>
        /// <p>Hyphen (-). You can't specify a hyphen at the beginning or end of a label. </p>
        /// </li>
        /// <li>
        /// <p>Period (.) to separate the labels in the name, such as the <code>.</code> in <code>example.com</code>.</p>
        /// </li>
        /// </ul>
        pub fn domain_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain_name(input);
            self
        }
        pub fn set_domain_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain_name(input);
            self
        }
        /// <p>Reserved for future use.</p>
        pub fn idn_lang_code(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.idn_lang_code(input);
            self
        }
        pub fn set_idn_lang_code(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_idn_lang_code(input);
            self
        }
        /// <p>The number of years that you want to register the domain for. Domains are registered for a minimum of one year.
        /// The maximum period depends on the top-level domain.</p>
        /// <p>Default: 1</p>
        pub fn duration_in_years(mut self, input: i32) -> Self {
            self.inner = self.inner.duration_in_years(input);
            self
        }
        pub fn set_duration_in_years(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_duration_in_years(input);
            self
        }
        /// <p>Contains details for the host and glue IP addresses.</p>
        pub fn nameservers(mut self, inp: impl Into<crate::model::Nameserver>) -> Self {
            self.inner = self.inner.nameservers(inp);
            self
        }
        pub fn set_nameservers(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Nameserver>>,
        ) -> Self {
            self.inner = self.inner.set_nameservers(input);
            self
        }
        /// <p>The authorization code for the domain. You get this value from the current registrar.</p>
        pub fn auth_code(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.auth_code(input);
            self
        }
        pub fn set_auth_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_auth_code(input);
            self
        }
        /// <p>Indicates whether the domain will be automatically renewed (true) or not (false). Autorenewal only takes effect
        /// after the account is charged.</p>
        /// <p>Default: true</p>
        pub fn auto_renew(mut self, input: bool) -> Self {
            self.inner = self.inner.auto_renew(input);
            self
        }
        pub fn set_auto_renew(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_auto_renew(input);
            self
        }
        /// <p>Provides detailed contact information.</p>
        pub fn admin_contact(mut self, input: crate::model::ContactDetail) -> Self {
            self.inner = self.inner.admin_contact(input);
            self
        }
        pub fn set_admin_contact(
            mut self,
            input: std::option::Option<crate::model::ContactDetail>,
        ) -> Self {
            self.inner = self.inner.set_admin_contact(input);
            self
        }
        /// <p>Provides detailed contact information.</p>
        pub fn registrant_contact(mut self, input: crate::model::ContactDetail) -> Self {
            self.inner = self.inner.registrant_contact(input);
            self
        }
        pub fn set_registrant_contact(
            mut self,
            input: std::option::Option<crate::model::ContactDetail>,
        ) -> Self {
            self.inner = self.inner.set_registrant_contact(input);
            self
        }
        /// <p>Provides detailed contact information.</p>
        pub fn tech_contact(mut self, input: crate::model::ContactDetail) -> Self {
            self.inner = self.inner.tech_contact(input);
            self
        }
        pub fn set_tech_contact(
            mut self,
            input: std::option::Option<crate::model::ContactDetail>,
        ) -> Self {
            self.inner = self.inner.set_tech_contact(input);
            self
        }
        /// <p>Whether you want to conceal contact information from WHOIS queries. If you specify <code>true</code>,
        /// WHOIS ("who is") queries return contact information either for Amazon Registrar (for .com, .net, and .org domains)
        /// or for our registrar associate, Gandi (for all other TLDs). If you specify <code>false</code>,
        /// WHOIS queries return the information that you entered for the admin contact.</p>
        /// <p>Default: <code>true</code>
        /// </p>
        pub fn privacy_protect_admin_contact(mut self, input: bool) -> Self {
            self.inner = self.inner.privacy_protect_admin_contact(input);
            self
        }
        pub fn set_privacy_protect_admin_contact(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.inner = self.inner.set_privacy_protect_admin_contact(input);
            self
        }
        /// <p>Whether you want to conceal contact information from WHOIS queries. If you specify <code>true</code>,
        /// WHOIS ("who is") queries return contact information either for Amazon Registrar (for .com, .net, and .org domains)
        /// or for our registrar associate, Gandi (for all other TLDs). If you specify <code>false</code>,
        /// WHOIS queries return the information that you entered for the registrant contact (domain owner).</p>
        /// <p>Default: <code>true</code>
        /// </p>
        pub fn privacy_protect_registrant_contact(mut self, input: bool) -> Self {
            self.inner = self.inner.privacy_protect_registrant_contact(input);
            self
        }
        pub fn set_privacy_protect_registrant_contact(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.inner = self.inner.set_privacy_protect_registrant_contact(input);
            self
        }
        /// <p>Whether you want to conceal contact information from WHOIS queries. If you specify <code>true</code>,
        /// WHOIS ("who is") queries return contact information either for Amazon Registrar (for .com, .net, and .org domains)
        /// or for our registrar associate, Gandi (for all other TLDs). If you specify <code>false</code>,
        /// WHOIS queries return the information that you entered for the technical contact.</p>
        /// <p>Default: <code>true</code>
        /// </p>
        pub fn privacy_protect_tech_contact(mut self, input: bool) -> Self {
            self.inner = self.inner.privacy_protect_tech_contact(input);
            self
        }
        pub fn set_privacy_protect_tech_contact(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.inner = self.inner.set_privacy_protect_tech_contact(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct TransferDomainToAnotherAwsAccount<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::transfer_domain_to_another_aws_account_input::Builder,
    }
    impl<C> TransferDomainToAnotherAwsAccount<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::TransferDomainToAnotherAwsAccountOutput,
            smithy_http::result::SdkError<crate::error::TransferDomainToAnotherAwsAccountError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the domain that you want to transfer from the current AWS account to another account.</p>
        pub fn domain_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain_name(input);
            self
        }
        pub fn set_domain_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain_name(input);
            self
        }
        /// <p>The account ID of the AWS account that you want to transfer the domain to, for example, <code>111122223333</code>.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.account_id(input);
            self
        }
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_account_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateDomainContact<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_domain_contact_input::Builder,
    }
    impl<C> UpdateDomainContact<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateDomainContactOutput,
            smithy_http::result::SdkError<crate::error::UpdateDomainContactError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the domain that you want to update contact information for.</p>
        pub fn domain_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain_name(input);
            self
        }
        pub fn set_domain_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain_name(input);
            self
        }
        /// <p>Provides detailed contact information.</p>
        pub fn admin_contact(mut self, input: crate::model::ContactDetail) -> Self {
            self.inner = self.inner.admin_contact(input);
            self
        }
        pub fn set_admin_contact(
            mut self,
            input: std::option::Option<crate::model::ContactDetail>,
        ) -> Self {
            self.inner = self.inner.set_admin_contact(input);
            self
        }
        /// <p>Provides detailed contact information.</p>
        pub fn registrant_contact(mut self, input: crate::model::ContactDetail) -> Self {
            self.inner = self.inner.registrant_contact(input);
            self
        }
        pub fn set_registrant_contact(
            mut self,
            input: std::option::Option<crate::model::ContactDetail>,
        ) -> Self {
            self.inner = self.inner.set_registrant_contact(input);
            self
        }
        /// <p>Provides detailed contact information.</p>
        pub fn tech_contact(mut self, input: crate::model::ContactDetail) -> Self {
            self.inner = self.inner.tech_contact(input);
            self
        }
        pub fn set_tech_contact(
            mut self,
            input: std::option::Option<crate::model::ContactDetail>,
        ) -> Self {
            self.inner = self.inner.set_tech_contact(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateDomainContactPrivacy<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_domain_contact_privacy_input::Builder,
    }
    impl<C> UpdateDomainContactPrivacy<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateDomainContactPrivacyOutput,
            smithy_http::result::SdkError<crate::error::UpdateDomainContactPrivacyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the domain that you want to update the privacy setting for.</p>
        pub fn domain_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain_name(input);
            self
        }
        pub fn set_domain_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain_name(input);
            self
        }
        /// <p>Whether you want to conceal contact information from WHOIS queries. If you specify <code>true</code>,
        /// WHOIS ("who is") queries return contact information either for Amazon Registrar (for .com, .net, and .org domains)
        /// or for our registrar associate, Gandi (for all other TLDs). If you specify <code>false</code>,
        /// WHOIS queries return the information that you entered for the admin contact.</p>
        pub fn admin_privacy(mut self, input: bool) -> Self {
            self.inner = self.inner.admin_privacy(input);
            self
        }
        pub fn set_admin_privacy(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_admin_privacy(input);
            self
        }
        /// <p>Whether you want to conceal contact information from WHOIS queries. If you specify <code>true</code>,
        /// WHOIS ("who is") queries return contact information either for Amazon Registrar (for .com, .net, and .org domains)
        /// or for our registrar associate, Gandi (for all other TLDs). If you specify <code>false</code>,
        /// WHOIS queries return the information that you entered for the registrant contact (domain owner).</p>
        pub fn registrant_privacy(mut self, input: bool) -> Self {
            self.inner = self.inner.registrant_privacy(input);
            self
        }
        pub fn set_registrant_privacy(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_registrant_privacy(input);
            self
        }
        /// <p>Whether you want to conceal contact information from WHOIS queries. If you specify <code>true</code>,
        /// WHOIS ("who is") queries return contact information either for Amazon Registrar (for .com, .net, and .org domains)
        /// or for our registrar associate, Gandi (for all other TLDs). If you specify <code>false</code>,
        /// WHOIS queries return the information that you entered for the technical contact.</p>
        pub fn tech_privacy(mut self, input: bool) -> Self {
            self.inner = self.inner.tech_privacy(input);
            self
        }
        pub fn set_tech_privacy(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_tech_privacy(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateDomainNameservers<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_domain_nameservers_input::Builder,
    }
    impl<C> UpdateDomainNameservers<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateDomainNameserversOutput,
            smithy_http::result::SdkError<crate::error::UpdateDomainNameserversError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the domain that you want to change name servers for.</p>
        pub fn domain_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain_name(input);
            self
        }
        pub fn set_domain_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain_name(input);
            self
        }
        /// <p>The authorization key for .fi domains</p>
        pub fn fi_auth_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.fi_auth_key(input);
            self
        }
        pub fn set_fi_auth_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_fi_auth_key(input);
            self
        }
        /// <p>A list of new name servers for the domain.</p>
        pub fn nameservers(mut self, inp: impl Into<crate::model::Nameserver>) -> Self {
            self.inner = self.inner.nameservers(inp);
            self
        }
        pub fn set_nameservers(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Nameserver>>,
        ) -> Self {
            self.inner = self.inner.set_nameservers(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateTagsForDomain<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_tags_for_domain_input::Builder,
    }
    impl<C> UpdateTagsForDomain<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateTagsForDomainOutput,
            smithy_http::result::SdkError<crate::error::UpdateTagsForDomainError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The domain for which you want to add or update tags.</p>
        pub fn domain_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain_name(input);
            self
        }
        pub fn set_domain_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain_name(input);
            self
        }
        /// <p>A list of the tag keys and values that you want to add or update. If you specify a key
        /// that already exists, the corresponding value will be replaced.</p>
        pub fn tags_to_update(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags_to_update(inp);
            self
        }
        pub fn set_tags_to_update(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags_to_update(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ViewBilling<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::view_billing_input::Builder,
    }
    impl<C> ViewBilling<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ViewBillingOutput,
            smithy_http::result::SdkError<crate::error::ViewBillingError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The beginning date and time for the time period for which you want a list of billing records. Specify the date and time
        /// in Unix time format and Coordinated Universal time (UTC).</p>
        pub fn start(mut self, input: smithy_types::Instant) -> Self {
            self.inner = self.inner.start(input);
            self
        }
        pub fn set_start(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.inner = self.inner.set_start(input);
            self
        }
        /// <p>The end date and time for the time period for which you want a list of billing records. Specify the date and time
        /// in Unix time format and Coordinated Universal time (UTC).</p>
        pub fn end(mut self, input: smithy_types::Instant) -> Self {
            self.inner = self.inner.end(input);
            self
        }
        pub fn set_end(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.inner = self.inner.set_end(input);
            self
        }
        /// <p>For an initial request for a list of billing records, omit this element. If the number of billing records
        /// that are associated with the current AWS account during the specified period is greater than the value that
        /// you specified for <code>MaxItems</code>, you can use <code>Marker</code> to return additional billing records.
        /// Get the value of <code>NextPageMarker</code> from the previous response, and submit another request that includes
        /// the value of <code>NextPageMarker</code> in the <code>Marker</code> element.
        /// </p>
        /// <p>Constraints: The marker must match the value of <code>NextPageMarker</code> that was returned in the previous response.</p>
        pub fn marker(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(input);
            self
        }
        pub fn set_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(input);
            self
        }
        /// <p>The number of billing records to be returned.</p>
        /// <p>Default: 20</p>
        pub fn max_items(mut self, input: i32) -> Self {
            self.inner = self.inner.max_items(input);
            self
        }
        pub fn set_max_items(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_items(input);
            self
        }
    }
}
