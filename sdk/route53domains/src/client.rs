// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[derive(Debug)]
pub(crate) struct Handle<
    C = smithy_client::erase::DynConnector,
    M = aws_hyper::AwsMiddleware,
    R = smithy_client::retry::Standard,
> {
    client: smithy_client::Client<C, M, R>,
    conf: crate::Config,
}

/// An ergonomic service client for `Route53Domains_v20140515`.
///
/// This client allows ergonomic access to a `Route53Domains_v20140515`-shaped service.
/// Each method corresponds to an endpoint defined in the service's Smithy model,
/// and the request and response shapes are auto-generated from that same model.
///
/// # Using a Client
///
/// Once you have a client set up, you can access the service's endpoints
/// by calling the appropriate method on [`Client`]. Each such method
/// returns a request builder for that endpoint, with methods for setting
/// the various fields of the request. Once your request is complete, use
/// the `send` method to send the request. `send` returns a future, which
/// you then have to `.await` to get the service's response.
///
/// [builder pattern]: https://rust-lang.github.io/api-guidelines/type-safety.html#c-builder
/// [SigV4-signed requests]: https://docs.aws.amazon.com/general/latest/gr/signature-version-4.html
#[derive(std::fmt::Debug)]
pub struct Client<
    C = smithy_client::erase::DynConnector,
    M = aws_hyper::AwsMiddleware,
    R = smithy_client::retry::Standard,
> {
    handle: std::sync::Arc<Handle<C, M, R>>,
}

impl<C, M, R> std::clone::Clone for Client<C, M, R> {
    fn clone(&self) -> Self {
        Self {
            handle: self.handle.clone(),
        }
    }
}

#[doc(inline)]
pub use smithy_client::Builder;

impl<C, M, R> From<smithy_client::Client<C, M, R>> for Client<C, M, R> {
    fn from(client: smithy_client::Client<C, M, R>) -> Self {
        Self::with_config(client, crate::Config::builder().build())
    }
}

impl<C, M, R> Client<C, M, R> {
    pub fn with_config(client: smithy_client::Client<C, M, R>, conf: crate::Config) -> Self {
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }

    pub fn conf(&self) -> &crate::Config {
        &self.handle.conf
    }
}
impl<C, M, R> Client<C, M, R>
where
    C: smithy_client::bounds::SmithyConnector,
    M: smithy_client::bounds::SmithyMiddleware<C>,
    R: smithy_client::retry::NewRequestPolicy,
{
    pub fn accept_domain_transfer_from_another_aws_account(
        &self,
    ) -> fluent_builders::AcceptDomainTransferFromAnotherAwsAccount<C, M, R> {
        fluent_builders::AcceptDomainTransferFromAnotherAwsAccount::new(self.handle.clone())
    }
    pub fn cancel_domain_transfer_to_another_aws_account(
        &self,
    ) -> fluent_builders::CancelDomainTransferToAnotherAwsAccount<C, M, R> {
        fluent_builders::CancelDomainTransferToAnotherAwsAccount::new(self.handle.clone())
    }
    pub fn check_domain_availability(&self) -> fluent_builders::CheckDomainAvailability<C, M, R> {
        fluent_builders::CheckDomainAvailability::new(self.handle.clone())
    }
    pub fn check_domain_transferability(
        &self,
    ) -> fluent_builders::CheckDomainTransferability<C, M, R> {
        fluent_builders::CheckDomainTransferability::new(self.handle.clone())
    }
    pub fn delete_tags_for_domain(&self) -> fluent_builders::DeleteTagsForDomain<C, M, R> {
        fluent_builders::DeleteTagsForDomain::new(self.handle.clone())
    }
    pub fn disable_domain_auto_renew(&self) -> fluent_builders::DisableDomainAutoRenew<C, M, R> {
        fluent_builders::DisableDomainAutoRenew::new(self.handle.clone())
    }
    pub fn disable_domain_transfer_lock(
        &self,
    ) -> fluent_builders::DisableDomainTransferLock<C, M, R> {
        fluent_builders::DisableDomainTransferLock::new(self.handle.clone())
    }
    pub fn enable_domain_auto_renew(&self) -> fluent_builders::EnableDomainAutoRenew<C, M, R> {
        fluent_builders::EnableDomainAutoRenew::new(self.handle.clone())
    }
    pub fn enable_domain_transfer_lock(
        &self,
    ) -> fluent_builders::EnableDomainTransferLock<C, M, R> {
        fluent_builders::EnableDomainTransferLock::new(self.handle.clone())
    }
    pub fn get_contact_reachability_status(
        &self,
    ) -> fluent_builders::GetContactReachabilityStatus<C, M, R> {
        fluent_builders::GetContactReachabilityStatus::new(self.handle.clone())
    }
    pub fn get_domain_detail(&self) -> fluent_builders::GetDomainDetail<C, M, R> {
        fluent_builders::GetDomainDetail::new(self.handle.clone())
    }
    pub fn get_domain_suggestions(&self) -> fluent_builders::GetDomainSuggestions<C, M, R> {
        fluent_builders::GetDomainSuggestions::new(self.handle.clone())
    }
    pub fn get_operation_detail(&self) -> fluent_builders::GetOperationDetail<C, M, R> {
        fluent_builders::GetOperationDetail::new(self.handle.clone())
    }
    pub fn list_domains(&self) -> fluent_builders::ListDomains<C, M, R> {
        fluent_builders::ListDomains::new(self.handle.clone())
    }
    pub fn list_operations(&self) -> fluent_builders::ListOperations<C, M, R> {
        fluent_builders::ListOperations::new(self.handle.clone())
    }
    pub fn list_tags_for_domain(&self) -> fluent_builders::ListTagsForDomain<C, M, R> {
        fluent_builders::ListTagsForDomain::new(self.handle.clone())
    }
    pub fn register_domain(&self) -> fluent_builders::RegisterDomain<C, M, R> {
        fluent_builders::RegisterDomain::new(self.handle.clone())
    }
    pub fn reject_domain_transfer_from_another_aws_account(
        &self,
    ) -> fluent_builders::RejectDomainTransferFromAnotherAwsAccount<C, M, R> {
        fluent_builders::RejectDomainTransferFromAnotherAwsAccount::new(self.handle.clone())
    }
    pub fn renew_domain(&self) -> fluent_builders::RenewDomain<C, M, R> {
        fluent_builders::RenewDomain::new(self.handle.clone())
    }
    pub fn resend_contact_reachability_email(
        &self,
    ) -> fluent_builders::ResendContactReachabilityEmail<C, M, R> {
        fluent_builders::ResendContactReachabilityEmail::new(self.handle.clone())
    }
    pub fn retrieve_domain_auth_code(&self) -> fluent_builders::RetrieveDomainAuthCode<C, M, R> {
        fluent_builders::RetrieveDomainAuthCode::new(self.handle.clone())
    }
    pub fn transfer_domain(&self) -> fluent_builders::TransferDomain<C, M, R> {
        fluent_builders::TransferDomain::new(self.handle.clone())
    }
    pub fn transfer_domain_to_another_aws_account(
        &self,
    ) -> fluent_builders::TransferDomainToAnotherAwsAccount<C, M, R> {
        fluent_builders::TransferDomainToAnotherAwsAccount::new(self.handle.clone())
    }
    pub fn update_domain_contact(&self) -> fluent_builders::UpdateDomainContact<C, M, R> {
        fluent_builders::UpdateDomainContact::new(self.handle.clone())
    }
    pub fn update_domain_contact_privacy(
        &self,
    ) -> fluent_builders::UpdateDomainContactPrivacy<C, M, R> {
        fluent_builders::UpdateDomainContactPrivacy::new(self.handle.clone())
    }
    pub fn update_domain_nameservers(&self) -> fluent_builders::UpdateDomainNameservers<C, M, R> {
        fluent_builders::UpdateDomainNameservers::new(self.handle.clone())
    }
    pub fn update_tags_for_domain(&self) -> fluent_builders::UpdateTagsForDomain<C, M, R> {
        fluent_builders::UpdateTagsForDomain::new(self.handle.clone())
    }
    pub fn view_billing(&self) -> fluent_builders::ViewBilling<C, M, R> {
        fluent_builders::ViewBilling::new(self.handle.clone())
    }
}
pub mod fluent_builders {
    #[derive(std::fmt::Debug)]
    pub struct AcceptDomainTransferFromAnotherAwsAccount<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::accept_domain_transfer_from_another_aws_account_input::Builder,
    }
    impl<C, M, R> AcceptDomainTransferFromAnotherAwsAccount<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::AcceptDomainTransferFromAnotherAwsAccountOutput,
            smithy_http::result::SdkError<
                crate::error::AcceptDomainTransferFromAnotherAwsAccountError,
            >,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::AcceptDomainTransferFromAnotherAwsAccountInputOperationOutputAlias,
                crate::output::AcceptDomainTransferFromAnotherAwsAccountOutput,
                crate::error::AcceptDomainTransferFromAnotherAwsAccountError,
                crate::input::AcceptDomainTransferFromAnotherAwsAccountInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the domain that was specified when another AWS account submitted a
        /// <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains_TransferDomainToAnotherAwsAccount.html">TransferDomainToAnotherAwsAccount</a>
        /// request.
        /// </p>
        pub fn domain_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain_name(inp);
            self
        }
        pub fn set_domain_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain_name(input);
            self
        }
        /// <p>The password that was returned by the
        /// <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains_TransferDomainToAnotherAwsAccount.html">TransferDomainToAnotherAwsAccount</a>
        /// request.
        /// </p>
        pub fn password(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.password(inp);
            self
        }
        pub fn set_password(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_password(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CancelDomainTransferToAnotherAwsAccount<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::cancel_domain_transfer_to_another_aws_account_input::Builder,
    }
    impl<C, M, R> CancelDomainTransferToAnotherAwsAccount<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CancelDomainTransferToAnotherAwsAccountOutput,
            smithy_http::result::SdkError<
                crate::error::CancelDomainTransferToAnotherAwsAccountError,
            >,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::CancelDomainTransferToAnotherAwsAccountInputOperationOutputAlias,
                crate::output::CancelDomainTransferToAnotherAwsAccountOutput,
                crate::error::CancelDomainTransferToAnotherAwsAccountError,
                crate::input::CancelDomainTransferToAnotherAwsAccountInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the domain for which you want to cancel the transfer to another AWS account.</p>
        pub fn domain_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain_name(inp);
            self
        }
        pub fn set_domain_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CheckDomainAvailability<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::check_domain_availability_input::Builder,
    }
    impl<C, M, R> CheckDomainAvailability<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CheckDomainAvailabilityOutput,
            smithy_http::result::SdkError<crate::error::CheckDomainAvailabilityError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::CheckDomainAvailabilityInputOperationOutputAlias,
                crate::output::CheckDomainAvailabilityOutput,
                crate::error::CheckDomainAvailabilityError,
                crate::input::CheckDomainAvailabilityInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the domain that you want to get availability for. The top-level domain (TLD), such as .com, must be a TLD that Route 53 supports.
        /// For a list of supported TLDs, see
        /// <a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/registrar-tld-list.html">Domains that You Can Register with Amazon Route 53</a> in the
        /// <i>Amazon Route 53 Developer Guide</i>.</p>
        /// <p>The domain name can contain only the following characters:</p>
        /// <ul>
        /// <li>
        /// <p>Letters a through z. Domain names are not case sensitive.</p>
        /// </li>
        /// <li>
        /// <p>Numbers 0 through 9.</p>
        /// </li>
        /// <li>
        /// <p>Hyphen (-). You can't specify a hyphen at the beginning or end of a label. </p>
        /// </li>
        /// <li>
        /// <p>Period (.) to separate the labels in the name, such as the <code>.</code> in <code>example.com</code>.</p>
        /// </li>
        /// </ul>
        /// <p>Internationalized domain names are not supported for some top-level domains. To determine whether the TLD that you want to use supports
        /// internationalized domain names, see
        /// <a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/registrar-tld-list.html">Domains that You Can Register with Amazon Route 53</a>.
        /// For more information, see
        /// <a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/DomainNameFormat.html#domain-name-format-idns">Formatting Internationalized Domain Names</a>.
        /// </p>
        pub fn domain_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain_name(inp);
            self
        }
        pub fn set_domain_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain_name(input);
            self
        }
        /// <p>Reserved for future use.</p>
        pub fn idn_lang_code(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.idn_lang_code(inp);
            self
        }
        pub fn set_idn_lang_code(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_idn_lang_code(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CheckDomainTransferability<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::check_domain_transferability_input::Builder,
    }
    impl<C, M, R> CheckDomainTransferability<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CheckDomainTransferabilityOutput,
            smithy_http::result::SdkError<crate::error::CheckDomainTransferabilityError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::CheckDomainTransferabilityInputOperationOutputAlias,
                crate::output::CheckDomainTransferabilityOutput,
                crate::error::CheckDomainTransferabilityError,
                crate::input::CheckDomainTransferabilityInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the domain that you want to transfer to Route 53. The top-level domain (TLD), such as .com, must be a TLD that Route 53 supports.
        /// For a list of supported TLDs, see
        /// <a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/registrar-tld-list.html">Domains that You Can Register with Amazon Route 53</a> in the
        /// <i>Amazon Route 53 Developer Guide</i>.</p>
        /// <p>The domain name can contain only the following characters:</p>
        /// <ul>
        /// <li>
        /// <p>Letters a through z. Domain names are not case sensitive.</p>
        /// </li>
        /// <li>
        /// <p>Numbers 0 through 9.</p>
        /// </li>
        /// <li>
        /// <p>Hyphen (-). You can't specify a hyphen at the beginning or end of a label. </p>
        /// </li>
        /// <li>
        /// <p>Period (.) to separate the labels in the name, such as the <code>.</code> in <code>example.com</code>.</p>
        /// </li>
        /// </ul>
        pub fn domain_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain_name(inp);
            self
        }
        pub fn set_domain_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain_name(input);
            self
        }
        /// <p>If the registrar for the top-level domain (TLD) requires an authorization code to transfer the domain,
        /// the code that you got from the current registrar for the domain.</p>
        pub fn auth_code(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.auth_code(inp);
            self
        }
        pub fn set_auth_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_auth_code(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteTagsForDomain<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::delete_tags_for_domain_input::Builder,
    }
    impl<C, M, R> DeleteTagsForDomain<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteTagsForDomainOutput,
            smithy_http::result::SdkError<crate::error::DeleteTagsForDomainError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DeleteTagsForDomainInputOperationOutputAlias,
                crate::output::DeleteTagsForDomainOutput,
                crate::error::DeleteTagsForDomainError,
                crate::input::DeleteTagsForDomainInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The domain for which you want to delete one or more tags.</p>
        pub fn domain_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain_name(inp);
            self
        }
        pub fn set_domain_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain_name(input);
            self
        }
        /// Appends an item to `TagsToDelete`.
        ///
        /// To override the contents of this collection use [`set_tags_to_delete`](Self::set_tags_to_delete).
        /// <p>A list of tag keys to delete.</p>
        pub fn tags_to_delete(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.tags_to_delete(inp);
            self
        }
        pub fn set_tags_to_delete(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_tags_to_delete(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DisableDomainAutoRenew<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::disable_domain_auto_renew_input::Builder,
    }
    impl<C, M, R> DisableDomainAutoRenew<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DisableDomainAutoRenewOutput,
            smithy_http::result::SdkError<crate::error::DisableDomainAutoRenewError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DisableDomainAutoRenewInputOperationOutputAlias,
                crate::output::DisableDomainAutoRenewOutput,
                crate::error::DisableDomainAutoRenewError,
                crate::input::DisableDomainAutoRenewInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the domain that you want to disable automatic renewal for.</p>
        pub fn domain_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain_name(inp);
            self
        }
        pub fn set_domain_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DisableDomainTransferLock<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::disable_domain_transfer_lock_input::Builder,
    }
    impl<C, M, R> DisableDomainTransferLock<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DisableDomainTransferLockOutput,
            smithy_http::result::SdkError<crate::error::DisableDomainTransferLockError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DisableDomainTransferLockInputOperationOutputAlias,
                crate::output::DisableDomainTransferLockOutput,
                crate::error::DisableDomainTransferLockError,
                crate::input::DisableDomainTransferLockInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the domain that you want to remove the transfer lock for.</p>
        pub fn domain_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain_name(inp);
            self
        }
        pub fn set_domain_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct EnableDomainAutoRenew<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::enable_domain_auto_renew_input::Builder,
    }
    impl<C, M, R> EnableDomainAutoRenew<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::EnableDomainAutoRenewOutput,
            smithy_http::result::SdkError<crate::error::EnableDomainAutoRenewError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::EnableDomainAutoRenewInputOperationOutputAlias,
                crate::output::EnableDomainAutoRenewOutput,
                crate::error::EnableDomainAutoRenewError,
                crate::input::EnableDomainAutoRenewInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the domain that you want to enable automatic renewal for.</p>
        pub fn domain_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain_name(inp);
            self
        }
        pub fn set_domain_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct EnableDomainTransferLock<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::enable_domain_transfer_lock_input::Builder,
    }
    impl<C, M, R> EnableDomainTransferLock<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::EnableDomainTransferLockOutput,
            smithy_http::result::SdkError<crate::error::EnableDomainTransferLockError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::EnableDomainTransferLockInputOperationOutputAlias,
                crate::output::EnableDomainTransferLockOutput,
                crate::error::EnableDomainTransferLockError,
                crate::input::EnableDomainTransferLockInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the domain that you want to set the transfer lock for.</p>
        pub fn domain_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain_name(inp);
            self
        }
        pub fn set_domain_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetContactReachabilityStatus<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::get_contact_reachability_status_input::Builder,
    }
    impl<C, M, R> GetContactReachabilityStatus<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetContactReachabilityStatusOutput,
            smithy_http::result::SdkError<crate::error::GetContactReachabilityStatusError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::GetContactReachabilityStatusInputOperationOutputAlias,
                crate::output::GetContactReachabilityStatusOutput,
                crate::error::GetContactReachabilityStatusError,
                crate::input::GetContactReachabilityStatusInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the domain for which you want to know whether the registrant contact has confirmed that the email address is valid.</p>
        pub fn domain_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain_name(inp);
            self
        }
        pub fn set_domain_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetDomainDetail<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::get_domain_detail_input::Builder,
    }
    impl<C, M, R> GetDomainDetail<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetDomainDetailOutput,
            smithy_http::result::SdkError<crate::error::GetDomainDetailError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::GetDomainDetailInputOperationOutputAlias,
                crate::output::GetDomainDetailOutput,
                crate::error::GetDomainDetailError,
                crate::input::GetDomainDetailInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the domain that you want to get detailed information about.</p>
        pub fn domain_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain_name(inp);
            self
        }
        pub fn set_domain_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetDomainSuggestions<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::get_domain_suggestions_input::Builder,
    }
    impl<C, M, R> GetDomainSuggestions<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetDomainSuggestionsOutput,
            smithy_http::result::SdkError<crate::error::GetDomainSuggestionsError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::GetDomainSuggestionsInputOperationOutputAlias,
                crate::output::GetDomainSuggestionsOutput,
                crate::error::GetDomainSuggestionsError,
                crate::input::GetDomainSuggestionsInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A domain name that you want to use as the basis for a list of possible domain names. The top-level domain (TLD), such as .com,
        /// must be a TLD that Route 53 supports. For a list of supported TLDs, see
        /// <a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/registrar-tld-list.html">Domains that You Can Register with Amazon Route 53</a> in the
        /// <i>Amazon Route 53 Developer Guide</i>.</p>
        /// <p>The domain name can contain only the following characters:</p>
        /// <ul>
        /// <li>
        /// <p>Letters a through z. Domain names are not case sensitive.</p>
        /// </li>
        /// <li>
        /// <p>Numbers 0 through 9.</p>
        /// </li>
        /// <li>
        /// <p>Hyphen (-). You can't specify a hyphen at the beginning or end of a label. </p>
        /// </li>
        /// <li>
        /// <p>Period (.) to separate the labels in the name, such as the <code>.</code> in <code>example.com</code>.</p>
        /// </li>
        /// </ul>
        /// <p>Internationalized domain names are not supported for some top-level domains. To determine whether the TLD that you want to use
        /// supports internationalized domain names, see
        /// <a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/registrar-tld-list.html">Domains that You Can Register with Amazon Route 53</a>.
        /// </p>
        pub fn domain_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain_name(inp);
            self
        }
        pub fn set_domain_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain_name(input);
            self
        }
        /// <p>The number of suggested domain names that you want Route 53 to return. Specify a value between 1 and 50.</p>
        pub fn suggestion_count(mut self, inp: i32) -> Self {
            self.inner = self.inner.suggestion_count(inp);
            self
        }
        pub fn set_suggestion_count(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_suggestion_count(input);
            self
        }
        /// <p>If <code>OnlyAvailable</code> is <code>true</code>, Route 53 returns only domain names that are available.
        /// If <code>OnlyAvailable</code> is <code>false</code>, Route 53 returns domain names without checking whether they're
        /// available to be registered. To determine whether the domain is available, you can call <code>checkDomainAvailability</code>
        /// for each suggestion.</p>
        pub fn only_available(mut self, inp: bool) -> Self {
            self.inner = self.inner.only_available(inp);
            self
        }
        pub fn set_only_available(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_only_available(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetOperationDetail<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::get_operation_detail_input::Builder,
    }
    impl<C, M, R> GetOperationDetail<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetOperationDetailOutput,
            smithy_http::result::SdkError<crate::error::GetOperationDetailError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::GetOperationDetailInputOperationOutputAlias,
                crate::output::GetOperationDetailOutput,
                crate::error::GetOperationDetailError,
                crate::input::GetOperationDetailInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identifier for the operation for which you want to get the status. Route 53 returned the identifier
        /// in the response to the original request.</p>
        pub fn operation_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.operation_id(inp);
            self
        }
        pub fn set_operation_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_operation_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListDomains<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::list_domains_input::Builder,
    }
    impl<C, M, R> ListDomains<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListDomainsOutput,
            smithy_http::result::SdkError<crate::error::ListDomainsError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ListDomainsInputOperationOutputAlias,
                crate::output::ListDomainsOutput,
                crate::error::ListDomainsError,
                crate::input::ListDomainsInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>For an initial request for a list of domains, omit this element. If the number of domains
        /// that are associated with the current AWS account is greater than the value that you specified for
        /// <code>MaxItems</code>, you can use <code>Marker</code> to return additional domains. Get the value of
        /// <code>NextPageMarker</code> from the previous response, and submit another request that includes the
        /// value of <code>NextPageMarker</code> in the <code>Marker</code> element.</p>
        /// <p>Constraints: The marker must match the value specified in the previous request.</p>
        pub fn marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(inp);
            self
        }
        pub fn set_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(input);
            self
        }
        /// <p>Number of domains to be returned.</p>
        /// <p>Default: 20</p>
        pub fn max_items(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_items(inp);
            self
        }
        pub fn set_max_items(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_items(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListOperations<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::list_operations_input::Builder,
    }
    impl<C, M, R> ListOperations<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListOperationsOutput,
            smithy_http::result::SdkError<crate::error::ListOperationsError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ListOperationsInputOperationOutputAlias,
                crate::output::ListOperationsOutput,
                crate::error::ListOperationsError,
                crate::input::ListOperationsInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>An optional parameter that lets you get information about all the operations that you submitted after a specified date and time.
        /// Specify the date and time in Unix time format and Coordinated Universal time (UTC).</p>
        pub fn submitted_since(mut self, inp: smithy_types::Instant) -> Self {
            self.inner = self.inner.submitted_since(inp);
            self
        }
        pub fn set_submitted_since(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.inner = self.inner.set_submitted_since(input);
            self
        }
        /// <p>For an initial request for a list of operations, omit this element. If the number of operations that are
        /// not yet complete is greater than the value that you specified for <code>MaxItems</code>, you can use <code>Marker</code>
        /// to return additional operations. Get the value of <code>NextPageMarker</code> from the previous response,
        /// and submit another request that includes the value of <code>NextPageMarker</code> in the <code>Marker</code> element.</p>
        pub fn marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(inp);
            self
        }
        pub fn set_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(input);
            self
        }
        /// <p>Number of domains to be returned.</p>
        /// <p>Default: 20</p>
        pub fn max_items(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_items(inp);
            self
        }
        pub fn set_max_items(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_items(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListTagsForDomain<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::list_tags_for_domain_input::Builder,
    }
    impl<C, M, R> ListTagsForDomain<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListTagsForDomainOutput,
            smithy_http::result::SdkError<crate::error::ListTagsForDomainError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ListTagsForDomainInputOperationOutputAlias,
                crate::output::ListTagsForDomainOutput,
                crate::error::ListTagsForDomainError,
                crate::input::ListTagsForDomainInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The domain for which you want to get a list of tags.</p>
        pub fn domain_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain_name(inp);
            self
        }
        pub fn set_domain_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RegisterDomain<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::register_domain_input::Builder,
    }
    impl<C, M, R> RegisterDomain<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::RegisterDomainOutput,
            smithy_http::result::SdkError<crate::error::RegisterDomainError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::RegisterDomainInputOperationOutputAlias,
                crate::output::RegisterDomainOutput,
                crate::error::RegisterDomainError,
                crate::input::RegisterDomainInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The domain name that you want to register. The top-level domain (TLD), such as .com, must be a TLD that Route 53 supports.
        /// For a list of supported TLDs, see
        /// <a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/registrar-tld-list.html">Domains that You Can Register with Amazon Route 53</a> in the
        /// <i>Amazon Route 53 Developer Guide</i>.</p>
        /// <p>The domain name can contain only the following characters:</p>
        /// <ul>
        /// <li>
        /// <p>Letters a through z. Domain names are not case sensitive.</p>
        /// </li>
        /// <li>
        /// <p>Numbers 0 through 9.</p>
        /// </li>
        /// <li>
        /// <p>Hyphen (-). You can't specify a hyphen at the beginning or end of a label. </p>
        /// </li>
        /// <li>
        /// <p>Period (.) to separate the labels in the name, such as the <code>.</code> in <code>example.com</code>.</p>
        /// </li>
        /// </ul>
        /// <p>Internationalized domain names are not supported for some top-level domains. To determine whether the TLD that you want to use supports
        /// internationalized domain names, see
        /// <a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/registrar-tld-list.html">Domains that You Can Register with Amazon Route 53</a>.
        /// For more information, see
        /// <a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/DomainNameFormat.html#domain-name-format-idns">Formatting Internationalized Domain Names</a>.
        /// </p>
        pub fn domain_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain_name(inp);
            self
        }
        pub fn set_domain_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain_name(input);
            self
        }
        /// <p>Reserved for future use.</p>
        pub fn idn_lang_code(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.idn_lang_code(inp);
            self
        }
        pub fn set_idn_lang_code(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_idn_lang_code(input);
            self
        }
        /// <p>The number of years that you want to register the domain for. Domains are registered for a minimum of one year.
        /// The maximum period depends on the top-level domain. For the range of valid values for your domain, see
        /// <a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/registrar-tld-list.html">Domains that You Can Register with Amazon Route 53</a> in the
        /// <i>Amazon Route 53 Developer Guide</i>.</p>
        /// <p>Default: 1</p>
        pub fn duration_in_years(mut self, inp: i32) -> Self {
            self.inner = self.inner.duration_in_years(inp);
            self
        }
        pub fn set_duration_in_years(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_duration_in_years(input);
            self
        }
        /// <p>Indicates whether the domain will be automatically renewed (<code>true</code>) or not (<code>false</code>).
        /// Autorenewal only takes effect after the account is charged.</p>
        /// <p>Default: <code>true</code>
        /// </p>
        pub fn auto_renew(mut self, inp: bool) -> Self {
            self.inner = self.inner.auto_renew(inp);
            self
        }
        pub fn set_auto_renew(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_auto_renew(input);
            self
        }
        /// <p>Provides detailed contact information. For information about the values that you specify for each element, see
        /// <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains_ContactDetail.html">ContactDetail</a>.</p>
        pub fn admin_contact(mut self, inp: crate::model::ContactDetail) -> Self {
            self.inner = self.inner.admin_contact(inp);
            self
        }
        pub fn set_admin_contact(
            mut self,
            input: std::option::Option<crate::model::ContactDetail>,
        ) -> Self {
            self.inner = self.inner.set_admin_contact(input);
            self
        }
        /// <p>Provides detailed contact information. For information about the values that you specify for each element, see
        /// <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains_ContactDetail.html">ContactDetail</a>.</p>
        pub fn registrant_contact(mut self, inp: crate::model::ContactDetail) -> Self {
            self.inner = self.inner.registrant_contact(inp);
            self
        }
        pub fn set_registrant_contact(
            mut self,
            input: std::option::Option<crate::model::ContactDetail>,
        ) -> Self {
            self.inner = self.inner.set_registrant_contact(input);
            self
        }
        /// <p>Provides detailed contact information. For information about the values that you specify for each element, see
        /// <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains_ContactDetail.html">ContactDetail</a>.</p>
        pub fn tech_contact(mut self, inp: crate::model::ContactDetail) -> Self {
            self.inner = self.inner.tech_contact(inp);
            self
        }
        pub fn set_tech_contact(
            mut self,
            input: std::option::Option<crate::model::ContactDetail>,
        ) -> Self {
            self.inner = self.inner.set_tech_contact(input);
            self
        }
        /// <p>Whether you want to conceal contact information from WHOIS queries. If you specify <code>true</code>,
        /// WHOIS ("who is") queries return contact information either for Amazon Registrar (for .com, .net, and .org domains)
        /// or for our registrar associate, Gandi (for all other TLDs). If you specify <code>false</code>,
        /// WHOIS queries return the information that you entered for the admin contact.</p>
        /// <p>Default: <code>true</code>
        /// </p>
        pub fn privacy_protect_admin_contact(mut self, inp: bool) -> Self {
            self.inner = self.inner.privacy_protect_admin_contact(inp);
            self
        }
        pub fn set_privacy_protect_admin_contact(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.inner = self.inner.set_privacy_protect_admin_contact(input);
            self
        }
        /// <p>Whether you want to conceal contact information from WHOIS queries. If you specify <code>true</code>,
        /// WHOIS ("who is") queries return contact information either for Amazon Registrar (for .com, .net, and .org domains)
        /// or for our registrar associate, Gandi (for all other TLDs). If you specify <code>false</code>,
        /// WHOIS queries return the information that you entered for the registrant contact (the domain owner).</p>
        /// <p>Default: <code>true</code>
        /// </p>
        pub fn privacy_protect_registrant_contact(mut self, inp: bool) -> Self {
            self.inner = self.inner.privacy_protect_registrant_contact(inp);
            self
        }
        pub fn set_privacy_protect_registrant_contact(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.inner = self.inner.set_privacy_protect_registrant_contact(input);
            self
        }
        /// <p>Whether you want to conceal contact information from WHOIS queries. If you specify <code>true</code>,
        /// WHOIS ("who is") queries return contact information either for Amazon Registrar (for .com, .net, and .org domains)
        /// or for our registrar associate, Gandi (for all other TLDs). If you specify <code>false</code>,
        /// WHOIS queries return the information that you entered for the technical contact.</p>
        /// <p>Default: <code>true</code>
        /// </p>
        pub fn privacy_protect_tech_contact(mut self, inp: bool) -> Self {
            self.inner = self.inner.privacy_protect_tech_contact(inp);
            self
        }
        pub fn set_privacy_protect_tech_contact(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.inner = self.inner.set_privacy_protect_tech_contact(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RejectDomainTransferFromAnotherAwsAccount<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::reject_domain_transfer_from_another_aws_account_input::Builder,
    }
    impl<C, M, R> RejectDomainTransferFromAnotherAwsAccount<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::RejectDomainTransferFromAnotherAwsAccountOutput,
            smithy_http::result::SdkError<
                crate::error::RejectDomainTransferFromAnotherAwsAccountError,
            >,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::RejectDomainTransferFromAnotherAwsAccountInputOperationOutputAlias,
                crate::output::RejectDomainTransferFromAnotherAwsAccountOutput,
                crate::error::RejectDomainTransferFromAnotherAwsAccountError,
                crate::input::RejectDomainTransferFromAnotherAwsAccountInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the domain that was specified when another AWS account submitted a
        /// <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains_TransferDomainToAnotherAwsAccount.html">TransferDomainToAnotherAwsAccount</a>
        /// request.
        /// </p>
        pub fn domain_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain_name(inp);
            self
        }
        pub fn set_domain_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RenewDomain<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::renew_domain_input::Builder,
    }
    impl<C, M, R> RenewDomain<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::RenewDomainOutput,
            smithy_http::result::SdkError<crate::error::RenewDomainError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::RenewDomainInputOperationOutputAlias,
                crate::output::RenewDomainOutput,
                crate::error::RenewDomainError,
                crate::input::RenewDomainInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the domain that you want to renew.</p>
        pub fn domain_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain_name(inp);
            self
        }
        pub fn set_domain_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain_name(input);
            self
        }
        /// <p>The number of years that you want to renew the domain for. The maximum number of years depends on the top-level domain.
        /// For the range of valid values for your domain, see
        /// <a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/registrar-tld-list.html">Domains that You Can Register with Amazon Route 53</a> in the
        /// <i>Amazon Route 53 Developer Guide</i>.</p>
        /// <p>Default: 1</p>
        pub fn duration_in_years(mut self, inp: i32) -> Self {
            self.inner = self.inner.duration_in_years(inp);
            self
        }
        pub fn set_duration_in_years(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_duration_in_years(input);
            self
        }
        /// <p>The year when the registration for the domain is set to expire. This value must match the current expiration date for the domain.</p>
        pub fn current_expiry_year(mut self, inp: i32) -> Self {
            self.inner = self.inner.current_expiry_year(inp);
            self
        }
        pub fn set_current_expiry_year(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_current_expiry_year(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ResendContactReachabilityEmail<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::resend_contact_reachability_email_input::Builder,
    }
    impl<C, M, R> ResendContactReachabilityEmail<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ResendContactReachabilityEmailOutput,
            smithy_http::result::SdkError<crate::error::ResendContactReachabilityEmailError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ResendContactReachabilityEmailInputOperationOutputAlias,
                crate::output::ResendContactReachabilityEmailOutput,
                crate::error::ResendContactReachabilityEmailError,
                crate::input::ResendContactReachabilityEmailInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the domain for which you want Route 53 to resend a confirmation email to the registrant contact.</p>
        pub fn domain_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain_name(inp);
            self
        }
        pub fn set_domain_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RetrieveDomainAuthCode<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::retrieve_domain_auth_code_input::Builder,
    }
    impl<C, M, R> RetrieveDomainAuthCode<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::RetrieveDomainAuthCodeOutput,
            smithy_http::result::SdkError<crate::error::RetrieveDomainAuthCodeError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::RetrieveDomainAuthCodeInputOperationOutputAlias,
                crate::output::RetrieveDomainAuthCodeOutput,
                crate::error::RetrieveDomainAuthCodeError,
                crate::input::RetrieveDomainAuthCodeInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the domain that you want to get an authorization code for.</p>
        pub fn domain_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain_name(inp);
            self
        }
        pub fn set_domain_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct TransferDomain<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::transfer_domain_input::Builder,
    }
    impl<C, M, R> TransferDomain<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::TransferDomainOutput,
            smithy_http::result::SdkError<crate::error::TransferDomainError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::TransferDomainInputOperationOutputAlias,
                crate::output::TransferDomainOutput,
                crate::error::TransferDomainError,
                crate::input::TransferDomainInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the domain that you want to transfer to Route 53. The top-level domain (TLD), such as .com, must be a TLD that Route 53 supports.
        /// For a list of supported TLDs, see
        /// <a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/registrar-tld-list.html">Domains that You Can Register with Amazon Route 53</a> in the
        /// <i>Amazon Route 53 Developer Guide</i>.</p>
        /// <p>The domain name can contain only the following characters:</p>
        /// <ul>
        /// <li>
        /// <p>Letters a through z. Domain names are not case sensitive.</p>
        /// </li>
        /// <li>
        /// <p>Numbers 0 through 9.</p>
        /// </li>
        /// <li>
        /// <p>Hyphen (-). You can't specify a hyphen at the beginning or end of a label. </p>
        /// </li>
        /// <li>
        /// <p>Period (.) to separate the labels in the name, such as the <code>.</code> in <code>example.com</code>.</p>
        /// </li>
        /// </ul>
        pub fn domain_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain_name(inp);
            self
        }
        pub fn set_domain_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain_name(input);
            self
        }
        /// <p>Reserved for future use.</p>
        pub fn idn_lang_code(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.idn_lang_code(inp);
            self
        }
        pub fn set_idn_lang_code(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_idn_lang_code(input);
            self
        }
        /// <p>The number of years that you want to register the domain for. Domains are registered for a minimum of one year.
        /// The maximum period depends on the top-level domain.</p>
        /// <p>Default: 1</p>
        pub fn duration_in_years(mut self, inp: i32) -> Self {
            self.inner = self.inner.duration_in_years(inp);
            self
        }
        pub fn set_duration_in_years(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_duration_in_years(input);
            self
        }
        /// Appends an item to `Nameservers`.
        ///
        /// To override the contents of this collection use [`set_nameservers`](Self::set_nameservers).
        /// <p>Contains details for the host and glue IP addresses.</p>
        pub fn nameservers(mut self, inp: impl Into<crate::model::Nameserver>) -> Self {
            self.inner = self.inner.nameservers(inp);
            self
        }
        pub fn set_nameservers(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Nameserver>>,
        ) -> Self {
            self.inner = self.inner.set_nameservers(input);
            self
        }
        /// <p>The authorization code for the domain. You get this value from the current registrar.</p>
        pub fn auth_code(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.auth_code(inp);
            self
        }
        pub fn set_auth_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_auth_code(input);
            self
        }
        /// <p>Indicates whether the domain will be automatically renewed (true) or not (false). Autorenewal only takes effect
        /// after the account is charged.</p>
        /// <p>Default: true</p>
        pub fn auto_renew(mut self, inp: bool) -> Self {
            self.inner = self.inner.auto_renew(inp);
            self
        }
        pub fn set_auto_renew(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_auto_renew(input);
            self
        }
        /// <p>Provides detailed contact information.</p>
        pub fn admin_contact(mut self, inp: crate::model::ContactDetail) -> Self {
            self.inner = self.inner.admin_contact(inp);
            self
        }
        pub fn set_admin_contact(
            mut self,
            input: std::option::Option<crate::model::ContactDetail>,
        ) -> Self {
            self.inner = self.inner.set_admin_contact(input);
            self
        }
        /// <p>Provides detailed contact information.</p>
        pub fn registrant_contact(mut self, inp: crate::model::ContactDetail) -> Self {
            self.inner = self.inner.registrant_contact(inp);
            self
        }
        pub fn set_registrant_contact(
            mut self,
            input: std::option::Option<crate::model::ContactDetail>,
        ) -> Self {
            self.inner = self.inner.set_registrant_contact(input);
            self
        }
        /// <p>Provides detailed contact information.</p>
        pub fn tech_contact(mut self, inp: crate::model::ContactDetail) -> Self {
            self.inner = self.inner.tech_contact(inp);
            self
        }
        pub fn set_tech_contact(
            mut self,
            input: std::option::Option<crate::model::ContactDetail>,
        ) -> Self {
            self.inner = self.inner.set_tech_contact(input);
            self
        }
        /// <p>Whether you want to conceal contact information from WHOIS queries. If you specify <code>true</code>,
        /// WHOIS ("who is") queries return contact information either for Amazon Registrar (for .com, .net, and .org domains)
        /// or for our registrar associate, Gandi (for all other TLDs). If you specify <code>false</code>,
        /// WHOIS queries return the information that you entered for the admin contact.</p>
        /// <p>Default: <code>true</code>
        /// </p>
        pub fn privacy_protect_admin_contact(mut self, inp: bool) -> Self {
            self.inner = self.inner.privacy_protect_admin_contact(inp);
            self
        }
        pub fn set_privacy_protect_admin_contact(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.inner = self.inner.set_privacy_protect_admin_contact(input);
            self
        }
        /// <p>Whether you want to conceal contact information from WHOIS queries. If you specify <code>true</code>,
        /// WHOIS ("who is") queries return contact information either for Amazon Registrar (for .com, .net, and .org domains)
        /// or for our registrar associate, Gandi (for all other TLDs). If you specify <code>false</code>,
        /// WHOIS queries return the information that you entered for the registrant contact (domain owner).</p>
        /// <p>Default: <code>true</code>
        /// </p>
        pub fn privacy_protect_registrant_contact(mut self, inp: bool) -> Self {
            self.inner = self.inner.privacy_protect_registrant_contact(inp);
            self
        }
        pub fn set_privacy_protect_registrant_contact(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.inner = self.inner.set_privacy_protect_registrant_contact(input);
            self
        }
        /// <p>Whether you want to conceal contact information from WHOIS queries. If you specify <code>true</code>,
        /// WHOIS ("who is") queries return contact information either for Amazon Registrar (for .com, .net, and .org domains)
        /// or for our registrar associate, Gandi (for all other TLDs). If you specify <code>false</code>,
        /// WHOIS queries return the information that you entered for the technical contact.</p>
        /// <p>Default: <code>true</code>
        /// </p>
        pub fn privacy_protect_tech_contact(mut self, inp: bool) -> Self {
            self.inner = self.inner.privacy_protect_tech_contact(inp);
            self
        }
        pub fn set_privacy_protect_tech_contact(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.inner = self.inner.set_privacy_protect_tech_contact(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct TransferDomainToAnotherAwsAccount<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::transfer_domain_to_another_aws_account_input::Builder,
    }
    impl<C, M, R> TransferDomainToAnotherAwsAccount<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::TransferDomainToAnotherAwsAccountOutput,
            smithy_http::result::SdkError<crate::error::TransferDomainToAnotherAwsAccountError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::TransferDomainToAnotherAwsAccountInputOperationOutputAlias,
                crate::output::TransferDomainToAnotherAwsAccountOutput,
                crate::error::TransferDomainToAnotherAwsAccountError,
                crate::input::TransferDomainToAnotherAwsAccountInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the domain that you want to transfer from the current AWS account to another account.</p>
        pub fn domain_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain_name(inp);
            self
        }
        pub fn set_domain_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain_name(input);
            self
        }
        /// <p>The account ID of the AWS account that you want to transfer the domain to, for example, <code>111122223333</code>.</p>
        pub fn account_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.account_id(inp);
            self
        }
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_account_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateDomainContact<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::update_domain_contact_input::Builder,
    }
    impl<C, M, R> UpdateDomainContact<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateDomainContactOutput,
            smithy_http::result::SdkError<crate::error::UpdateDomainContactError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::UpdateDomainContactInputOperationOutputAlias,
                crate::output::UpdateDomainContactOutput,
                crate::error::UpdateDomainContactError,
                crate::input::UpdateDomainContactInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the domain that you want to update contact information for.</p>
        pub fn domain_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain_name(inp);
            self
        }
        pub fn set_domain_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain_name(input);
            self
        }
        /// <p>Provides detailed contact information.</p>
        pub fn admin_contact(mut self, inp: crate::model::ContactDetail) -> Self {
            self.inner = self.inner.admin_contact(inp);
            self
        }
        pub fn set_admin_contact(
            mut self,
            input: std::option::Option<crate::model::ContactDetail>,
        ) -> Self {
            self.inner = self.inner.set_admin_contact(input);
            self
        }
        /// <p>Provides detailed contact information.</p>
        pub fn registrant_contact(mut self, inp: crate::model::ContactDetail) -> Self {
            self.inner = self.inner.registrant_contact(inp);
            self
        }
        pub fn set_registrant_contact(
            mut self,
            input: std::option::Option<crate::model::ContactDetail>,
        ) -> Self {
            self.inner = self.inner.set_registrant_contact(input);
            self
        }
        /// <p>Provides detailed contact information.</p>
        pub fn tech_contact(mut self, inp: crate::model::ContactDetail) -> Self {
            self.inner = self.inner.tech_contact(inp);
            self
        }
        pub fn set_tech_contact(
            mut self,
            input: std::option::Option<crate::model::ContactDetail>,
        ) -> Self {
            self.inner = self.inner.set_tech_contact(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateDomainContactPrivacy<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::update_domain_contact_privacy_input::Builder,
    }
    impl<C, M, R> UpdateDomainContactPrivacy<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateDomainContactPrivacyOutput,
            smithy_http::result::SdkError<crate::error::UpdateDomainContactPrivacyError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::UpdateDomainContactPrivacyInputOperationOutputAlias,
                crate::output::UpdateDomainContactPrivacyOutput,
                crate::error::UpdateDomainContactPrivacyError,
                crate::input::UpdateDomainContactPrivacyInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the domain that you want to update the privacy setting for.</p>
        pub fn domain_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain_name(inp);
            self
        }
        pub fn set_domain_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain_name(input);
            self
        }
        /// <p>Whether you want to conceal contact information from WHOIS queries. If you specify <code>true</code>,
        /// WHOIS ("who is") queries return contact information either for Amazon Registrar (for .com, .net, and .org domains)
        /// or for our registrar associate, Gandi (for all other TLDs). If you specify <code>false</code>,
        /// WHOIS queries return the information that you entered for the admin contact.</p>
        pub fn admin_privacy(mut self, inp: bool) -> Self {
            self.inner = self.inner.admin_privacy(inp);
            self
        }
        pub fn set_admin_privacy(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_admin_privacy(input);
            self
        }
        /// <p>Whether you want to conceal contact information from WHOIS queries. If you specify <code>true</code>,
        /// WHOIS ("who is") queries return contact information either for Amazon Registrar (for .com, .net, and .org domains)
        /// or for our registrar associate, Gandi (for all other TLDs). If you specify <code>false</code>,
        /// WHOIS queries return the information that you entered for the registrant contact (domain owner).</p>
        pub fn registrant_privacy(mut self, inp: bool) -> Self {
            self.inner = self.inner.registrant_privacy(inp);
            self
        }
        pub fn set_registrant_privacy(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_registrant_privacy(input);
            self
        }
        /// <p>Whether you want to conceal contact information from WHOIS queries. If you specify <code>true</code>,
        /// WHOIS ("who is") queries return contact information either for Amazon Registrar (for .com, .net, and .org domains)
        /// or for our registrar associate, Gandi (for all other TLDs). If you specify <code>false</code>,
        /// WHOIS queries return the information that you entered for the technical contact.</p>
        pub fn tech_privacy(mut self, inp: bool) -> Self {
            self.inner = self.inner.tech_privacy(inp);
            self
        }
        pub fn set_tech_privacy(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_tech_privacy(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateDomainNameservers<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::update_domain_nameservers_input::Builder,
    }
    impl<C, M, R> UpdateDomainNameservers<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateDomainNameserversOutput,
            smithy_http::result::SdkError<crate::error::UpdateDomainNameserversError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::UpdateDomainNameserversInputOperationOutputAlias,
                crate::output::UpdateDomainNameserversOutput,
                crate::error::UpdateDomainNameserversError,
                crate::input::UpdateDomainNameserversInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the domain that you want to change name servers for.</p>
        pub fn domain_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain_name(inp);
            self
        }
        pub fn set_domain_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain_name(input);
            self
        }
        /// <p>The authorization key for .fi domains</p>
        pub fn fi_auth_key(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.fi_auth_key(inp);
            self
        }
        pub fn set_fi_auth_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_fi_auth_key(input);
            self
        }
        /// Appends an item to `Nameservers`.
        ///
        /// To override the contents of this collection use [`set_nameservers`](Self::set_nameservers).
        /// <p>A list of new name servers for the domain.</p>
        pub fn nameservers(mut self, inp: impl Into<crate::model::Nameserver>) -> Self {
            self.inner = self.inner.nameservers(inp);
            self
        }
        pub fn set_nameservers(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Nameserver>>,
        ) -> Self {
            self.inner = self.inner.set_nameservers(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateTagsForDomain<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::update_tags_for_domain_input::Builder,
    }
    impl<C, M, R> UpdateTagsForDomain<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateTagsForDomainOutput,
            smithy_http::result::SdkError<crate::error::UpdateTagsForDomainError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::UpdateTagsForDomainInputOperationOutputAlias,
                crate::output::UpdateTagsForDomainOutput,
                crate::error::UpdateTagsForDomainError,
                crate::input::UpdateTagsForDomainInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The domain for which you want to add or update tags.</p>
        pub fn domain_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain_name(inp);
            self
        }
        pub fn set_domain_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain_name(input);
            self
        }
        /// Appends an item to `TagsToUpdate`.
        ///
        /// To override the contents of this collection use [`set_tags_to_update`](Self::set_tags_to_update).
        /// <p>A list of the tag keys and values that you want to add or update. If you specify a key
        /// that already exists, the corresponding value will be replaced.</p>
        pub fn tags_to_update(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags_to_update(inp);
            self
        }
        pub fn set_tags_to_update(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags_to_update(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ViewBilling<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::view_billing_input::Builder,
    }
    impl<C, M, R> ViewBilling<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ViewBillingOutput,
            smithy_http::result::SdkError<crate::error::ViewBillingError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ViewBillingInputOperationOutputAlias,
                crate::output::ViewBillingOutput,
                crate::error::ViewBillingError,
                crate::input::ViewBillingInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The beginning date and time for the time period for which you want a list of billing records. Specify the date and time
        /// in Unix time format and Coordinated Universal time (UTC).</p>
        pub fn start(mut self, inp: smithy_types::Instant) -> Self {
            self.inner = self.inner.start(inp);
            self
        }
        pub fn set_start(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.inner = self.inner.set_start(input);
            self
        }
        /// <p>The end date and time for the time period for which you want a list of billing records. Specify the date and time
        /// in Unix time format and Coordinated Universal time (UTC).</p>
        pub fn end(mut self, inp: smithy_types::Instant) -> Self {
            self.inner = self.inner.end(inp);
            self
        }
        pub fn set_end(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.inner = self.inner.set_end(input);
            self
        }
        /// <p>For an initial request for a list of billing records, omit this element. If the number of billing records
        /// that are associated with the current AWS account during the specified period is greater than the value that
        /// you specified for <code>MaxItems</code>, you can use <code>Marker</code> to return additional billing records.
        /// Get the value of <code>NextPageMarker</code> from the previous response, and submit another request that includes
        /// the value of <code>NextPageMarker</code> in the <code>Marker</code> element.
        /// </p>
        /// <p>Constraints: The marker must match the value of <code>NextPageMarker</code> that was returned in the previous response.</p>
        pub fn marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(inp);
            self
        }
        pub fn set_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(input);
            self
        }
        /// <p>The number of billing records to be returned.</p>
        /// <p>Default: 20</p>
        pub fn max_items(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_items(inp);
            self
        }
        pub fn set_max_items(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_items(input);
            self
        }
    }
}
impl<C> Client<C, aws_hyper::AwsMiddleware, smithy_client::retry::Standard> {
    pub fn from_conf_conn(conf: crate::Config, conn: C) -> Self {
        let retry_config = conf.retry_config.as_ref().cloned().unwrap_or_default();
        let client = aws_hyper::Client::new(conn).with_retry_config(retry_config.into());
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }
}
impl
    Client<
        smithy_client::erase::DynConnector,
        aws_hyper::AwsMiddleware,
        smithy_client::retry::Standard,
    >
{
    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn new(config: &aws_types::config::Config) -> Self {
        Self::from_conf(config.into())
    }

    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_conf(conf: crate::Config) -> Self {
        let retry_config = conf.retry_config.as_ref().cloned().unwrap_or_default();
        let client = aws_hyper::Client::https().with_retry_config(retry_config.into());
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }
}
