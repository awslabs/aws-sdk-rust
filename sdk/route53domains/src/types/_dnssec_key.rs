// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Information about the DNSSEC key.</p>
/// <p>You get this from your DNS provider and then give it to Route&nbsp;53 (by using <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains_AssociateDelegationSignerToDomain.html">AssociateDelegationSignerToDomain</a>) to pass it to the registry to establish the chain of trust.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DnssecKey {
    /// <p>The number of the public key’s cryptographic algorithm according to an <a href="https://www.iana.org/assignments/dns-sec-alg-numbers/dns-sec-alg-numbers.xml">IANA</a> assignment. </p>
    /// <p>If Route&nbsp;53 is your DNS service, set this to 13.</p>
    /// <p>For more information about enabling DNSSEC signing, see <a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/dns-configuring-dnssec-enable-signing.html">Enabling DNSSEC signing and establishing a chain of trust</a>.</p>
    #[doc(hidden)]
    pub algorithm: std::option::Option<i32>,
    /// <p>Defines the type of key. It can be either a KSK (key-signing-key, value 257) or ZSK (zone-signing-key, value 256). Using KSK is always encouraged. Only use ZSK if your DNS provider isn't Route&nbsp;53 and you don’t have KSK available.</p>
    /// <p>If you have KSK and ZSK keys, always use KSK to create a delegations signer (DS) record. If you have ZSK keys only – use ZSK to create a DS record.</p>
    #[doc(hidden)]
    pub flags: std::option::Option<i32>,
    /// <p>The base64-encoded public key part of the key pair that is passed to the registry .</p>
    #[doc(hidden)]
    pub public_key: std::option::Option<std::string::String>,
    /// <p> The number of the DS digest algorithm according to an IANA assignment.</p>
    /// <p>For more information, see <a href="https://www.iana.org/assignments/ds-rr-types/ds-rr-types.xhtml">IANA</a> for DNSSEC Delegation Signer (DS) Resource Record (RR) Type Digest Algorithms. </p>
    #[doc(hidden)]
    pub digest_type: std::option::Option<i32>,
    /// <p> The delegation signer digest.</p>
    /// <p>Digest is calculated from the public key provided using specified digest algorithm and this digest is the actual value returned from the registry nameservers as the value of DS records. </p>
    #[doc(hidden)]
    pub digest: std::option::Option<std::string::String>,
    /// <p> A numeric identification of the DNSKEY record referred to by this DS record. </p>
    #[doc(hidden)]
    pub key_tag: std::option::Option<i32>,
    /// <p> An ID assigned to each DS record created by <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains_AssociateDelegationSignerToDomain.html">AssociateDelegationSignerToDomain</a>. </p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
}
impl DnssecKey {
    /// <p>The number of the public key’s cryptographic algorithm according to an <a href="https://www.iana.org/assignments/dns-sec-alg-numbers/dns-sec-alg-numbers.xml">IANA</a> assignment. </p>
    /// <p>If Route&nbsp;53 is your DNS service, set this to 13.</p>
    /// <p>For more information about enabling DNSSEC signing, see <a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/dns-configuring-dnssec-enable-signing.html">Enabling DNSSEC signing and establishing a chain of trust</a>.</p>
    pub fn algorithm(&self) -> std::option::Option<i32> {
        self.algorithm
    }
    /// <p>Defines the type of key. It can be either a KSK (key-signing-key, value 257) or ZSK (zone-signing-key, value 256). Using KSK is always encouraged. Only use ZSK if your DNS provider isn't Route&nbsp;53 and you don’t have KSK available.</p>
    /// <p>If you have KSK and ZSK keys, always use KSK to create a delegations signer (DS) record. If you have ZSK keys only – use ZSK to create a DS record.</p>
    pub fn flags(&self) -> std::option::Option<i32> {
        self.flags
    }
    /// <p>The base64-encoded public key part of the key pair that is passed to the registry .</p>
    pub fn public_key(&self) -> std::option::Option<&str> {
        self.public_key.as_deref()
    }
    /// <p> The number of the DS digest algorithm according to an IANA assignment.</p>
    /// <p>For more information, see <a href="https://www.iana.org/assignments/ds-rr-types/ds-rr-types.xhtml">IANA</a> for DNSSEC Delegation Signer (DS) Resource Record (RR) Type Digest Algorithms. </p>
    pub fn digest_type(&self) -> std::option::Option<i32> {
        self.digest_type
    }
    /// <p> The delegation signer digest.</p>
    /// <p>Digest is calculated from the public key provided using specified digest algorithm and this digest is the actual value returned from the registry nameservers as the value of DS records. </p>
    pub fn digest(&self) -> std::option::Option<&str> {
        self.digest.as_deref()
    }
    /// <p> A numeric identification of the DNSKEY record referred to by this DS record. </p>
    pub fn key_tag(&self) -> std::option::Option<i32> {
        self.key_tag
    }
    /// <p> An ID assigned to each DS record created by <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains_AssociateDelegationSignerToDomain.html">AssociateDelegationSignerToDomain</a>. </p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
}
impl DnssecKey {
    /// Creates a new builder-style object to manufacture [`DnssecKey`](crate::types::DnssecKey).
    pub fn builder() -> crate::types::builders::DnssecKeyBuilder {
        crate::types::builders::DnssecKeyBuilder::default()
    }
}

/// A builder for [`DnssecKey`](crate::types::DnssecKey).
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
pub struct DnssecKeyBuilder {
    pub(crate) algorithm: std::option::Option<i32>,
    pub(crate) flags: std::option::Option<i32>,
    pub(crate) public_key: std::option::Option<std::string::String>,
    pub(crate) digest_type: std::option::Option<i32>,
    pub(crate) digest: std::option::Option<std::string::String>,
    pub(crate) key_tag: std::option::Option<i32>,
    pub(crate) id: std::option::Option<std::string::String>,
}
impl DnssecKeyBuilder {
    /// <p>The number of the public key’s cryptographic algorithm according to an <a href="https://www.iana.org/assignments/dns-sec-alg-numbers/dns-sec-alg-numbers.xml">IANA</a> assignment. </p>
    /// <p>If Route&nbsp;53 is your DNS service, set this to 13.</p>
    /// <p>For more information about enabling DNSSEC signing, see <a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/dns-configuring-dnssec-enable-signing.html">Enabling DNSSEC signing and establishing a chain of trust</a>.</p>
    pub fn algorithm(mut self, input: i32) -> Self {
        self.algorithm = Some(input);
        self
    }
    /// <p>The number of the public key’s cryptographic algorithm according to an <a href="https://www.iana.org/assignments/dns-sec-alg-numbers/dns-sec-alg-numbers.xml">IANA</a> assignment. </p>
    /// <p>If Route&nbsp;53 is your DNS service, set this to 13.</p>
    /// <p>For more information about enabling DNSSEC signing, see <a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/dns-configuring-dnssec-enable-signing.html">Enabling DNSSEC signing and establishing a chain of trust</a>.</p>
    pub fn set_algorithm(mut self, input: std::option::Option<i32>) -> Self {
        self.algorithm = input;
        self
    }
    /// <p>Defines the type of key. It can be either a KSK (key-signing-key, value 257) or ZSK (zone-signing-key, value 256). Using KSK is always encouraged. Only use ZSK if your DNS provider isn't Route&nbsp;53 and you don’t have KSK available.</p>
    /// <p>If you have KSK and ZSK keys, always use KSK to create a delegations signer (DS) record. If you have ZSK keys only – use ZSK to create a DS record.</p>
    pub fn flags(mut self, input: i32) -> Self {
        self.flags = Some(input);
        self
    }
    /// <p>Defines the type of key. It can be either a KSK (key-signing-key, value 257) or ZSK (zone-signing-key, value 256). Using KSK is always encouraged. Only use ZSK if your DNS provider isn't Route&nbsp;53 and you don’t have KSK available.</p>
    /// <p>If you have KSK and ZSK keys, always use KSK to create a delegations signer (DS) record. If you have ZSK keys only – use ZSK to create a DS record.</p>
    pub fn set_flags(mut self, input: std::option::Option<i32>) -> Self {
        self.flags = input;
        self
    }
    /// <p>The base64-encoded public key part of the key pair that is passed to the registry .</p>
    pub fn public_key(mut self, input: impl Into<std::string::String>) -> Self {
        self.public_key = Some(input.into());
        self
    }
    /// <p>The base64-encoded public key part of the key pair that is passed to the registry .</p>
    pub fn set_public_key(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.public_key = input;
        self
    }
    /// <p> The number of the DS digest algorithm according to an IANA assignment.</p>
    /// <p>For more information, see <a href="https://www.iana.org/assignments/ds-rr-types/ds-rr-types.xhtml">IANA</a> for DNSSEC Delegation Signer (DS) Resource Record (RR) Type Digest Algorithms. </p>
    pub fn digest_type(mut self, input: i32) -> Self {
        self.digest_type = Some(input);
        self
    }
    /// <p> The number of the DS digest algorithm according to an IANA assignment.</p>
    /// <p>For more information, see <a href="https://www.iana.org/assignments/ds-rr-types/ds-rr-types.xhtml">IANA</a> for DNSSEC Delegation Signer (DS) Resource Record (RR) Type Digest Algorithms. </p>
    pub fn set_digest_type(mut self, input: std::option::Option<i32>) -> Self {
        self.digest_type = input;
        self
    }
    /// <p> The delegation signer digest.</p>
    /// <p>Digest is calculated from the public key provided using specified digest algorithm and this digest is the actual value returned from the registry nameservers as the value of DS records. </p>
    pub fn digest(mut self, input: impl Into<std::string::String>) -> Self {
        self.digest = Some(input.into());
        self
    }
    /// <p> The delegation signer digest.</p>
    /// <p>Digest is calculated from the public key provided using specified digest algorithm and this digest is the actual value returned from the registry nameservers as the value of DS records. </p>
    pub fn set_digest(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.digest = input;
        self
    }
    /// <p> A numeric identification of the DNSKEY record referred to by this DS record. </p>
    pub fn key_tag(mut self, input: i32) -> Self {
        self.key_tag = Some(input);
        self
    }
    /// <p> A numeric identification of the DNSKEY record referred to by this DS record. </p>
    pub fn set_key_tag(mut self, input: std::option::Option<i32>) -> Self {
        self.key_tag = input;
        self
    }
    /// <p> An ID assigned to each DS record created by <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains_AssociateDelegationSignerToDomain.html">AssociateDelegationSignerToDomain</a>. </p>
    pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
        self.id = Some(input.into());
        self
    }
    /// <p> An ID assigned to each DS record created by <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains_AssociateDelegationSignerToDomain.html">AssociateDelegationSignerToDomain</a>. </p>
    pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.id = input;
        self
    }
    /// Consumes the builder and constructs a [`DnssecKey`](crate::types::DnssecKey).
    pub fn build(self) -> crate::types::DnssecKey {
        crate::types::DnssecKey {
            algorithm: self.algorithm,
            flags: self.flags,
            public_key: self.public_key,
            digest_type: self.digest_type,
            digest: self.digest,
            key_tag: self.key_tag,
            id: self.id,
        }
    }
}
