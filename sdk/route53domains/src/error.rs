// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AcceptDomainTransferFromAnotherAwsAccountError {
    pub kind: AcceptDomainTransferFromAnotherAwsAccountErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AcceptDomainTransferFromAnotherAwsAccountErrorKind {
    DomainLimitExceeded(crate::error::DomainLimitExceeded),
    InvalidInput(crate::error::InvalidInput),
    OperationLimitExceeded(crate::error::OperationLimitExceeded),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AcceptDomainTransferFromAnotherAwsAccountError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AcceptDomainTransferFromAnotherAwsAccountErrorKind::DomainLimitExceeded(_inner) => {
                _inner.fmt(f)
            }
            AcceptDomainTransferFromAnotherAwsAccountErrorKind::InvalidInput(_inner) => {
                _inner.fmt(f)
            }
            AcceptDomainTransferFromAnotherAwsAccountErrorKind::OperationLimitExceeded(_inner) => {
                _inner.fmt(f)
            }
            AcceptDomainTransferFromAnotherAwsAccountErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AcceptDomainTransferFromAnotherAwsAccountError {
    fn code(&self) -> Option<&str> {
        AcceptDomainTransferFromAnotherAwsAccountError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AcceptDomainTransferFromAnotherAwsAccountError {
    pub fn new(
        kind: AcceptDomainTransferFromAnotherAwsAccountErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AcceptDomainTransferFromAnotherAwsAccountErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AcceptDomainTransferFromAnotherAwsAccountErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_domain_limit_exceeded(&self) -> bool {
        matches!(
            &self.kind,
            AcceptDomainTransferFromAnotherAwsAccountErrorKind::DomainLimitExceeded(_)
        )
    }
    pub fn is_invalid_input(&self) -> bool {
        matches!(
            &self.kind,
            AcceptDomainTransferFromAnotherAwsAccountErrorKind::InvalidInput(_)
        )
    }
    pub fn is_operation_limit_exceeded(&self) -> bool {
        matches!(
            &self.kind,
            AcceptDomainTransferFromAnotherAwsAccountErrorKind::OperationLimitExceeded(_)
        )
    }
}
impl std::error::Error for AcceptDomainTransferFromAnotherAwsAccountError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AcceptDomainTransferFromAnotherAwsAccountErrorKind::DomainLimitExceeded(_inner) => {
                Some(_inner)
            }
            AcceptDomainTransferFromAnotherAwsAccountErrorKind::InvalidInput(_inner) => {
                Some(_inner)
            }
            AcceptDomainTransferFromAnotherAwsAccountErrorKind::OperationLimitExceeded(_inner) => {
                Some(_inner)
            }
            AcceptDomainTransferFromAnotherAwsAccountErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CancelDomainTransferToAnotherAwsAccountError {
    pub kind: CancelDomainTransferToAnotherAwsAccountErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CancelDomainTransferToAnotherAwsAccountErrorKind {
    InvalidInput(crate::error::InvalidInput),
    OperationLimitExceeded(crate::error::OperationLimitExceeded),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CancelDomainTransferToAnotherAwsAccountError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CancelDomainTransferToAnotherAwsAccountErrorKind::InvalidInput(_inner) => _inner.fmt(f),
            CancelDomainTransferToAnotherAwsAccountErrorKind::OperationLimitExceeded(_inner) => {
                _inner.fmt(f)
            }
            CancelDomainTransferToAnotherAwsAccountErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CancelDomainTransferToAnotherAwsAccountError {
    fn code(&self) -> Option<&str> {
        CancelDomainTransferToAnotherAwsAccountError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CancelDomainTransferToAnotherAwsAccountError {
    pub fn new(
        kind: CancelDomainTransferToAnotherAwsAccountErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CancelDomainTransferToAnotherAwsAccountErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CancelDomainTransferToAnotherAwsAccountErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_input(&self) -> bool {
        matches!(
            &self.kind,
            CancelDomainTransferToAnotherAwsAccountErrorKind::InvalidInput(_)
        )
    }
    pub fn is_operation_limit_exceeded(&self) -> bool {
        matches!(
            &self.kind,
            CancelDomainTransferToAnotherAwsAccountErrorKind::OperationLimitExceeded(_)
        )
    }
}
impl std::error::Error for CancelDomainTransferToAnotherAwsAccountError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CancelDomainTransferToAnotherAwsAccountErrorKind::InvalidInput(_inner) => Some(_inner),
            CancelDomainTransferToAnotherAwsAccountErrorKind::OperationLimitExceeded(_inner) => {
                Some(_inner)
            }
            CancelDomainTransferToAnotherAwsAccountErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CheckDomainAvailabilityError {
    pub kind: CheckDomainAvailabilityErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CheckDomainAvailabilityErrorKind {
    InvalidInput(crate::error::InvalidInput),
    UnsupportedTld(crate::error::UnsupportedTld),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CheckDomainAvailabilityError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CheckDomainAvailabilityErrorKind::InvalidInput(_inner) => _inner.fmt(f),
            CheckDomainAvailabilityErrorKind::UnsupportedTld(_inner) => _inner.fmt(f),
            CheckDomainAvailabilityErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CheckDomainAvailabilityError {
    fn code(&self) -> Option<&str> {
        CheckDomainAvailabilityError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CheckDomainAvailabilityError {
    pub fn new(kind: CheckDomainAvailabilityErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CheckDomainAvailabilityErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CheckDomainAvailabilityErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_input(&self) -> bool {
        matches!(
            &self.kind,
            CheckDomainAvailabilityErrorKind::InvalidInput(_)
        )
    }
    pub fn is_unsupported_tld(&self) -> bool {
        matches!(
            &self.kind,
            CheckDomainAvailabilityErrorKind::UnsupportedTld(_)
        )
    }
}
impl std::error::Error for CheckDomainAvailabilityError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CheckDomainAvailabilityErrorKind::InvalidInput(_inner) => Some(_inner),
            CheckDomainAvailabilityErrorKind::UnsupportedTld(_inner) => Some(_inner),
            CheckDomainAvailabilityErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CheckDomainTransferabilityError {
    pub kind: CheckDomainTransferabilityErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CheckDomainTransferabilityErrorKind {
    InvalidInput(crate::error::InvalidInput),
    UnsupportedTld(crate::error::UnsupportedTld),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CheckDomainTransferabilityError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CheckDomainTransferabilityErrorKind::InvalidInput(_inner) => _inner.fmt(f),
            CheckDomainTransferabilityErrorKind::UnsupportedTld(_inner) => _inner.fmt(f),
            CheckDomainTransferabilityErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CheckDomainTransferabilityError {
    fn code(&self) -> Option<&str> {
        CheckDomainTransferabilityError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CheckDomainTransferabilityError {
    pub fn new(kind: CheckDomainTransferabilityErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CheckDomainTransferabilityErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CheckDomainTransferabilityErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_input(&self) -> bool {
        matches!(
            &self.kind,
            CheckDomainTransferabilityErrorKind::InvalidInput(_)
        )
    }
    pub fn is_unsupported_tld(&self) -> bool {
        matches!(
            &self.kind,
            CheckDomainTransferabilityErrorKind::UnsupportedTld(_)
        )
    }
}
impl std::error::Error for CheckDomainTransferabilityError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CheckDomainTransferabilityErrorKind::InvalidInput(_inner) => Some(_inner),
            CheckDomainTransferabilityErrorKind::UnsupportedTld(_inner) => Some(_inner),
            CheckDomainTransferabilityErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteTagsForDomainError {
    pub kind: DeleteTagsForDomainErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteTagsForDomainErrorKind {
    InvalidInput(crate::error::InvalidInput),
    OperationLimitExceeded(crate::error::OperationLimitExceeded),
    UnsupportedTld(crate::error::UnsupportedTld),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteTagsForDomainError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteTagsForDomainErrorKind::InvalidInput(_inner) => _inner.fmt(f),
            DeleteTagsForDomainErrorKind::OperationLimitExceeded(_inner) => _inner.fmt(f),
            DeleteTagsForDomainErrorKind::UnsupportedTld(_inner) => _inner.fmt(f),
            DeleteTagsForDomainErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteTagsForDomainError {
    fn code(&self) -> Option<&str> {
        DeleteTagsForDomainError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteTagsForDomainError {
    pub fn new(kind: DeleteTagsForDomainErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteTagsForDomainErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteTagsForDomainErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_input(&self) -> bool {
        matches!(&self.kind, DeleteTagsForDomainErrorKind::InvalidInput(_))
    }
    pub fn is_operation_limit_exceeded(&self) -> bool {
        matches!(
            &self.kind,
            DeleteTagsForDomainErrorKind::OperationLimitExceeded(_)
        )
    }
    pub fn is_unsupported_tld(&self) -> bool {
        matches!(&self.kind, DeleteTagsForDomainErrorKind::UnsupportedTld(_))
    }
}
impl std::error::Error for DeleteTagsForDomainError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteTagsForDomainErrorKind::InvalidInput(_inner) => Some(_inner),
            DeleteTagsForDomainErrorKind::OperationLimitExceeded(_inner) => Some(_inner),
            DeleteTagsForDomainErrorKind::UnsupportedTld(_inner) => Some(_inner),
            DeleteTagsForDomainErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DisableDomainAutoRenewError {
    pub kind: DisableDomainAutoRenewErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DisableDomainAutoRenewErrorKind {
    InvalidInput(crate::error::InvalidInput),
    UnsupportedTld(crate::error::UnsupportedTld),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DisableDomainAutoRenewError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DisableDomainAutoRenewErrorKind::InvalidInput(_inner) => _inner.fmt(f),
            DisableDomainAutoRenewErrorKind::UnsupportedTld(_inner) => _inner.fmt(f),
            DisableDomainAutoRenewErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DisableDomainAutoRenewError {
    fn code(&self) -> Option<&str> {
        DisableDomainAutoRenewError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DisableDomainAutoRenewError {
    pub fn new(kind: DisableDomainAutoRenewErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DisableDomainAutoRenewErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DisableDomainAutoRenewErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_input(&self) -> bool {
        matches!(&self.kind, DisableDomainAutoRenewErrorKind::InvalidInput(_))
    }
    pub fn is_unsupported_tld(&self) -> bool {
        matches!(
            &self.kind,
            DisableDomainAutoRenewErrorKind::UnsupportedTld(_)
        )
    }
}
impl std::error::Error for DisableDomainAutoRenewError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DisableDomainAutoRenewErrorKind::InvalidInput(_inner) => Some(_inner),
            DisableDomainAutoRenewErrorKind::UnsupportedTld(_inner) => Some(_inner),
            DisableDomainAutoRenewErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DisableDomainTransferLockError {
    pub kind: DisableDomainTransferLockErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DisableDomainTransferLockErrorKind {
    DuplicateRequest(crate::error::DuplicateRequest),
    InvalidInput(crate::error::InvalidInput),
    OperationLimitExceeded(crate::error::OperationLimitExceeded),
    TldRulesViolation(crate::error::TldRulesViolation),
    UnsupportedTld(crate::error::UnsupportedTld),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DisableDomainTransferLockError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DisableDomainTransferLockErrorKind::DuplicateRequest(_inner) => _inner.fmt(f),
            DisableDomainTransferLockErrorKind::InvalidInput(_inner) => _inner.fmt(f),
            DisableDomainTransferLockErrorKind::OperationLimitExceeded(_inner) => _inner.fmt(f),
            DisableDomainTransferLockErrorKind::TldRulesViolation(_inner) => _inner.fmt(f),
            DisableDomainTransferLockErrorKind::UnsupportedTld(_inner) => _inner.fmt(f),
            DisableDomainTransferLockErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DisableDomainTransferLockError {
    fn code(&self) -> Option<&str> {
        DisableDomainTransferLockError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DisableDomainTransferLockError {
    pub fn new(kind: DisableDomainTransferLockErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DisableDomainTransferLockErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DisableDomainTransferLockErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_duplicate_request(&self) -> bool {
        matches!(
            &self.kind,
            DisableDomainTransferLockErrorKind::DuplicateRequest(_)
        )
    }
    pub fn is_invalid_input(&self) -> bool {
        matches!(
            &self.kind,
            DisableDomainTransferLockErrorKind::InvalidInput(_)
        )
    }
    pub fn is_operation_limit_exceeded(&self) -> bool {
        matches!(
            &self.kind,
            DisableDomainTransferLockErrorKind::OperationLimitExceeded(_)
        )
    }
    pub fn is_tld_rules_violation(&self) -> bool {
        matches!(
            &self.kind,
            DisableDomainTransferLockErrorKind::TldRulesViolation(_)
        )
    }
    pub fn is_unsupported_tld(&self) -> bool {
        matches!(
            &self.kind,
            DisableDomainTransferLockErrorKind::UnsupportedTld(_)
        )
    }
}
impl std::error::Error for DisableDomainTransferLockError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DisableDomainTransferLockErrorKind::DuplicateRequest(_inner) => Some(_inner),
            DisableDomainTransferLockErrorKind::InvalidInput(_inner) => Some(_inner),
            DisableDomainTransferLockErrorKind::OperationLimitExceeded(_inner) => Some(_inner),
            DisableDomainTransferLockErrorKind::TldRulesViolation(_inner) => Some(_inner),
            DisableDomainTransferLockErrorKind::UnsupportedTld(_inner) => Some(_inner),
            DisableDomainTransferLockErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct EnableDomainAutoRenewError {
    pub kind: EnableDomainAutoRenewErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum EnableDomainAutoRenewErrorKind {
    InvalidInput(crate::error::InvalidInput),
    TldRulesViolation(crate::error::TldRulesViolation),
    UnsupportedTld(crate::error::UnsupportedTld),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for EnableDomainAutoRenewError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            EnableDomainAutoRenewErrorKind::InvalidInput(_inner) => _inner.fmt(f),
            EnableDomainAutoRenewErrorKind::TldRulesViolation(_inner) => _inner.fmt(f),
            EnableDomainAutoRenewErrorKind::UnsupportedTld(_inner) => _inner.fmt(f),
            EnableDomainAutoRenewErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for EnableDomainAutoRenewError {
    fn code(&self) -> Option<&str> {
        EnableDomainAutoRenewError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl EnableDomainAutoRenewError {
    pub fn new(kind: EnableDomainAutoRenewErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: EnableDomainAutoRenewErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: EnableDomainAutoRenewErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_input(&self) -> bool {
        matches!(&self.kind, EnableDomainAutoRenewErrorKind::InvalidInput(_))
    }
    pub fn is_tld_rules_violation(&self) -> bool {
        matches!(
            &self.kind,
            EnableDomainAutoRenewErrorKind::TldRulesViolation(_)
        )
    }
    pub fn is_unsupported_tld(&self) -> bool {
        matches!(
            &self.kind,
            EnableDomainAutoRenewErrorKind::UnsupportedTld(_)
        )
    }
}
impl std::error::Error for EnableDomainAutoRenewError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            EnableDomainAutoRenewErrorKind::InvalidInput(_inner) => Some(_inner),
            EnableDomainAutoRenewErrorKind::TldRulesViolation(_inner) => Some(_inner),
            EnableDomainAutoRenewErrorKind::UnsupportedTld(_inner) => Some(_inner),
            EnableDomainAutoRenewErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct EnableDomainTransferLockError {
    pub kind: EnableDomainTransferLockErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum EnableDomainTransferLockErrorKind {
    DuplicateRequest(crate::error::DuplicateRequest),
    InvalidInput(crate::error::InvalidInput),
    OperationLimitExceeded(crate::error::OperationLimitExceeded),
    TldRulesViolation(crate::error::TldRulesViolation),
    UnsupportedTld(crate::error::UnsupportedTld),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for EnableDomainTransferLockError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            EnableDomainTransferLockErrorKind::DuplicateRequest(_inner) => _inner.fmt(f),
            EnableDomainTransferLockErrorKind::InvalidInput(_inner) => _inner.fmt(f),
            EnableDomainTransferLockErrorKind::OperationLimitExceeded(_inner) => _inner.fmt(f),
            EnableDomainTransferLockErrorKind::TldRulesViolation(_inner) => _inner.fmt(f),
            EnableDomainTransferLockErrorKind::UnsupportedTld(_inner) => _inner.fmt(f),
            EnableDomainTransferLockErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for EnableDomainTransferLockError {
    fn code(&self) -> Option<&str> {
        EnableDomainTransferLockError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl EnableDomainTransferLockError {
    pub fn new(kind: EnableDomainTransferLockErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: EnableDomainTransferLockErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: EnableDomainTransferLockErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_duplicate_request(&self) -> bool {
        matches!(
            &self.kind,
            EnableDomainTransferLockErrorKind::DuplicateRequest(_)
        )
    }
    pub fn is_invalid_input(&self) -> bool {
        matches!(
            &self.kind,
            EnableDomainTransferLockErrorKind::InvalidInput(_)
        )
    }
    pub fn is_operation_limit_exceeded(&self) -> bool {
        matches!(
            &self.kind,
            EnableDomainTransferLockErrorKind::OperationLimitExceeded(_)
        )
    }
    pub fn is_tld_rules_violation(&self) -> bool {
        matches!(
            &self.kind,
            EnableDomainTransferLockErrorKind::TldRulesViolation(_)
        )
    }
    pub fn is_unsupported_tld(&self) -> bool {
        matches!(
            &self.kind,
            EnableDomainTransferLockErrorKind::UnsupportedTld(_)
        )
    }
}
impl std::error::Error for EnableDomainTransferLockError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            EnableDomainTransferLockErrorKind::DuplicateRequest(_inner) => Some(_inner),
            EnableDomainTransferLockErrorKind::InvalidInput(_inner) => Some(_inner),
            EnableDomainTransferLockErrorKind::OperationLimitExceeded(_inner) => Some(_inner),
            EnableDomainTransferLockErrorKind::TldRulesViolation(_inner) => Some(_inner),
            EnableDomainTransferLockErrorKind::UnsupportedTld(_inner) => Some(_inner),
            EnableDomainTransferLockErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetContactReachabilityStatusError {
    pub kind: GetContactReachabilityStatusErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetContactReachabilityStatusErrorKind {
    InvalidInput(crate::error::InvalidInput),
    OperationLimitExceeded(crate::error::OperationLimitExceeded),
    UnsupportedTld(crate::error::UnsupportedTld),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetContactReachabilityStatusError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetContactReachabilityStatusErrorKind::InvalidInput(_inner) => _inner.fmt(f),
            GetContactReachabilityStatusErrorKind::OperationLimitExceeded(_inner) => _inner.fmt(f),
            GetContactReachabilityStatusErrorKind::UnsupportedTld(_inner) => _inner.fmt(f),
            GetContactReachabilityStatusErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetContactReachabilityStatusError {
    fn code(&self) -> Option<&str> {
        GetContactReachabilityStatusError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetContactReachabilityStatusError {
    pub fn new(kind: GetContactReachabilityStatusErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetContactReachabilityStatusErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetContactReachabilityStatusErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_input(&self) -> bool {
        matches!(
            &self.kind,
            GetContactReachabilityStatusErrorKind::InvalidInput(_)
        )
    }
    pub fn is_operation_limit_exceeded(&self) -> bool {
        matches!(
            &self.kind,
            GetContactReachabilityStatusErrorKind::OperationLimitExceeded(_)
        )
    }
    pub fn is_unsupported_tld(&self) -> bool {
        matches!(
            &self.kind,
            GetContactReachabilityStatusErrorKind::UnsupportedTld(_)
        )
    }
}
impl std::error::Error for GetContactReachabilityStatusError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetContactReachabilityStatusErrorKind::InvalidInput(_inner) => Some(_inner),
            GetContactReachabilityStatusErrorKind::OperationLimitExceeded(_inner) => Some(_inner),
            GetContactReachabilityStatusErrorKind::UnsupportedTld(_inner) => Some(_inner),
            GetContactReachabilityStatusErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetDomainDetailError {
    pub kind: GetDomainDetailErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetDomainDetailErrorKind {
    InvalidInput(crate::error::InvalidInput),
    UnsupportedTld(crate::error::UnsupportedTld),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetDomainDetailError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetDomainDetailErrorKind::InvalidInput(_inner) => _inner.fmt(f),
            GetDomainDetailErrorKind::UnsupportedTld(_inner) => _inner.fmt(f),
            GetDomainDetailErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetDomainDetailError {
    fn code(&self) -> Option<&str> {
        GetDomainDetailError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetDomainDetailError {
    pub fn new(kind: GetDomainDetailErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetDomainDetailErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetDomainDetailErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_input(&self) -> bool {
        matches!(&self.kind, GetDomainDetailErrorKind::InvalidInput(_))
    }
    pub fn is_unsupported_tld(&self) -> bool {
        matches!(&self.kind, GetDomainDetailErrorKind::UnsupportedTld(_))
    }
}
impl std::error::Error for GetDomainDetailError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetDomainDetailErrorKind::InvalidInput(_inner) => Some(_inner),
            GetDomainDetailErrorKind::UnsupportedTld(_inner) => Some(_inner),
            GetDomainDetailErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetDomainSuggestionsError {
    pub kind: GetDomainSuggestionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetDomainSuggestionsErrorKind {
    InvalidInput(crate::error::InvalidInput),
    UnsupportedTld(crate::error::UnsupportedTld),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetDomainSuggestionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetDomainSuggestionsErrorKind::InvalidInput(_inner) => _inner.fmt(f),
            GetDomainSuggestionsErrorKind::UnsupportedTld(_inner) => _inner.fmt(f),
            GetDomainSuggestionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetDomainSuggestionsError {
    fn code(&self) -> Option<&str> {
        GetDomainSuggestionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetDomainSuggestionsError {
    pub fn new(kind: GetDomainSuggestionsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetDomainSuggestionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetDomainSuggestionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_input(&self) -> bool {
        matches!(&self.kind, GetDomainSuggestionsErrorKind::InvalidInput(_))
    }
    pub fn is_unsupported_tld(&self) -> bool {
        matches!(&self.kind, GetDomainSuggestionsErrorKind::UnsupportedTld(_))
    }
}
impl std::error::Error for GetDomainSuggestionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetDomainSuggestionsErrorKind::InvalidInput(_inner) => Some(_inner),
            GetDomainSuggestionsErrorKind::UnsupportedTld(_inner) => Some(_inner),
            GetDomainSuggestionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetOperationDetailError {
    pub kind: GetOperationDetailErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetOperationDetailErrorKind {
    InvalidInput(crate::error::InvalidInput),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetOperationDetailError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetOperationDetailErrorKind::InvalidInput(_inner) => _inner.fmt(f),
            GetOperationDetailErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetOperationDetailError {
    fn code(&self) -> Option<&str> {
        GetOperationDetailError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetOperationDetailError {
    pub fn new(kind: GetOperationDetailErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetOperationDetailErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetOperationDetailErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_input(&self) -> bool {
        matches!(&self.kind, GetOperationDetailErrorKind::InvalidInput(_))
    }
}
impl std::error::Error for GetOperationDetailError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetOperationDetailErrorKind::InvalidInput(_inner) => Some(_inner),
            GetOperationDetailErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListDomainsError {
    pub kind: ListDomainsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListDomainsErrorKind {
    InvalidInput(crate::error::InvalidInput),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListDomainsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListDomainsErrorKind::InvalidInput(_inner) => _inner.fmt(f),
            ListDomainsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListDomainsError {
    fn code(&self) -> Option<&str> {
        ListDomainsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListDomainsError {
    pub fn new(kind: ListDomainsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListDomainsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListDomainsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_input(&self) -> bool {
        matches!(&self.kind, ListDomainsErrorKind::InvalidInput(_))
    }
}
impl std::error::Error for ListDomainsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListDomainsErrorKind::InvalidInput(_inner) => Some(_inner),
            ListDomainsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListOperationsError {
    pub kind: ListOperationsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListOperationsErrorKind {
    InvalidInput(crate::error::InvalidInput),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListOperationsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListOperationsErrorKind::InvalidInput(_inner) => _inner.fmt(f),
            ListOperationsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListOperationsError {
    fn code(&self) -> Option<&str> {
        ListOperationsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListOperationsError {
    pub fn new(kind: ListOperationsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListOperationsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListOperationsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_input(&self) -> bool {
        matches!(&self.kind, ListOperationsErrorKind::InvalidInput(_))
    }
}
impl std::error::Error for ListOperationsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListOperationsErrorKind::InvalidInput(_inner) => Some(_inner),
            ListOperationsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListTagsForDomainError {
    pub kind: ListTagsForDomainErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListTagsForDomainErrorKind {
    InvalidInput(crate::error::InvalidInput),
    OperationLimitExceeded(crate::error::OperationLimitExceeded),
    UnsupportedTld(crate::error::UnsupportedTld),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListTagsForDomainError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListTagsForDomainErrorKind::InvalidInput(_inner) => _inner.fmt(f),
            ListTagsForDomainErrorKind::OperationLimitExceeded(_inner) => _inner.fmt(f),
            ListTagsForDomainErrorKind::UnsupportedTld(_inner) => _inner.fmt(f),
            ListTagsForDomainErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListTagsForDomainError {
    fn code(&self) -> Option<&str> {
        ListTagsForDomainError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListTagsForDomainError {
    pub fn new(kind: ListTagsForDomainErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListTagsForDomainErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListTagsForDomainErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_input(&self) -> bool {
        matches!(&self.kind, ListTagsForDomainErrorKind::InvalidInput(_))
    }
    pub fn is_operation_limit_exceeded(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForDomainErrorKind::OperationLimitExceeded(_)
        )
    }
    pub fn is_unsupported_tld(&self) -> bool {
        matches!(&self.kind, ListTagsForDomainErrorKind::UnsupportedTld(_))
    }
}
impl std::error::Error for ListTagsForDomainError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListTagsForDomainErrorKind::InvalidInput(_inner) => Some(_inner),
            ListTagsForDomainErrorKind::OperationLimitExceeded(_inner) => Some(_inner),
            ListTagsForDomainErrorKind::UnsupportedTld(_inner) => Some(_inner),
            ListTagsForDomainErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RegisterDomainError {
    pub kind: RegisterDomainErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RegisterDomainErrorKind {
    DomainLimitExceeded(crate::error::DomainLimitExceeded),
    DuplicateRequest(crate::error::DuplicateRequest),
    InvalidInput(crate::error::InvalidInput),
    OperationLimitExceeded(crate::error::OperationLimitExceeded),
    TldRulesViolation(crate::error::TldRulesViolation),
    UnsupportedTld(crate::error::UnsupportedTld),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RegisterDomainError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RegisterDomainErrorKind::DomainLimitExceeded(_inner) => _inner.fmt(f),
            RegisterDomainErrorKind::DuplicateRequest(_inner) => _inner.fmt(f),
            RegisterDomainErrorKind::InvalidInput(_inner) => _inner.fmt(f),
            RegisterDomainErrorKind::OperationLimitExceeded(_inner) => _inner.fmt(f),
            RegisterDomainErrorKind::TldRulesViolation(_inner) => _inner.fmt(f),
            RegisterDomainErrorKind::UnsupportedTld(_inner) => _inner.fmt(f),
            RegisterDomainErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RegisterDomainError {
    fn code(&self) -> Option<&str> {
        RegisterDomainError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RegisterDomainError {
    pub fn new(kind: RegisterDomainErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RegisterDomainErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RegisterDomainErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_domain_limit_exceeded(&self) -> bool {
        matches!(&self.kind, RegisterDomainErrorKind::DomainLimitExceeded(_))
    }
    pub fn is_duplicate_request(&self) -> bool {
        matches!(&self.kind, RegisterDomainErrorKind::DuplicateRequest(_))
    }
    pub fn is_invalid_input(&self) -> bool {
        matches!(&self.kind, RegisterDomainErrorKind::InvalidInput(_))
    }
    pub fn is_operation_limit_exceeded(&self) -> bool {
        matches!(
            &self.kind,
            RegisterDomainErrorKind::OperationLimitExceeded(_)
        )
    }
    pub fn is_tld_rules_violation(&self) -> bool {
        matches!(&self.kind, RegisterDomainErrorKind::TldRulesViolation(_))
    }
    pub fn is_unsupported_tld(&self) -> bool {
        matches!(&self.kind, RegisterDomainErrorKind::UnsupportedTld(_))
    }
}
impl std::error::Error for RegisterDomainError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RegisterDomainErrorKind::DomainLimitExceeded(_inner) => Some(_inner),
            RegisterDomainErrorKind::DuplicateRequest(_inner) => Some(_inner),
            RegisterDomainErrorKind::InvalidInput(_inner) => Some(_inner),
            RegisterDomainErrorKind::OperationLimitExceeded(_inner) => Some(_inner),
            RegisterDomainErrorKind::TldRulesViolation(_inner) => Some(_inner),
            RegisterDomainErrorKind::UnsupportedTld(_inner) => Some(_inner),
            RegisterDomainErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RejectDomainTransferFromAnotherAwsAccountError {
    pub kind: RejectDomainTransferFromAnotherAwsAccountErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RejectDomainTransferFromAnotherAwsAccountErrorKind {
    InvalidInput(crate::error::InvalidInput),
    OperationLimitExceeded(crate::error::OperationLimitExceeded),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RejectDomainTransferFromAnotherAwsAccountError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RejectDomainTransferFromAnotherAwsAccountErrorKind::InvalidInput(_inner) => {
                _inner.fmt(f)
            }
            RejectDomainTransferFromAnotherAwsAccountErrorKind::OperationLimitExceeded(_inner) => {
                _inner.fmt(f)
            }
            RejectDomainTransferFromAnotherAwsAccountErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RejectDomainTransferFromAnotherAwsAccountError {
    fn code(&self) -> Option<&str> {
        RejectDomainTransferFromAnotherAwsAccountError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RejectDomainTransferFromAnotherAwsAccountError {
    pub fn new(
        kind: RejectDomainTransferFromAnotherAwsAccountErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RejectDomainTransferFromAnotherAwsAccountErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RejectDomainTransferFromAnotherAwsAccountErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_input(&self) -> bool {
        matches!(
            &self.kind,
            RejectDomainTransferFromAnotherAwsAccountErrorKind::InvalidInput(_)
        )
    }
    pub fn is_operation_limit_exceeded(&self) -> bool {
        matches!(
            &self.kind,
            RejectDomainTransferFromAnotherAwsAccountErrorKind::OperationLimitExceeded(_)
        )
    }
}
impl std::error::Error for RejectDomainTransferFromAnotherAwsAccountError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RejectDomainTransferFromAnotherAwsAccountErrorKind::InvalidInput(_inner) => {
                Some(_inner)
            }
            RejectDomainTransferFromAnotherAwsAccountErrorKind::OperationLimitExceeded(_inner) => {
                Some(_inner)
            }
            RejectDomainTransferFromAnotherAwsAccountErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RenewDomainError {
    pub kind: RenewDomainErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RenewDomainErrorKind {
    DuplicateRequest(crate::error::DuplicateRequest),
    InvalidInput(crate::error::InvalidInput),
    OperationLimitExceeded(crate::error::OperationLimitExceeded),
    TldRulesViolation(crate::error::TldRulesViolation),
    UnsupportedTld(crate::error::UnsupportedTld),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RenewDomainError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RenewDomainErrorKind::DuplicateRequest(_inner) => _inner.fmt(f),
            RenewDomainErrorKind::InvalidInput(_inner) => _inner.fmt(f),
            RenewDomainErrorKind::OperationLimitExceeded(_inner) => _inner.fmt(f),
            RenewDomainErrorKind::TldRulesViolation(_inner) => _inner.fmt(f),
            RenewDomainErrorKind::UnsupportedTld(_inner) => _inner.fmt(f),
            RenewDomainErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RenewDomainError {
    fn code(&self) -> Option<&str> {
        RenewDomainError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RenewDomainError {
    pub fn new(kind: RenewDomainErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RenewDomainErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RenewDomainErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_duplicate_request(&self) -> bool {
        matches!(&self.kind, RenewDomainErrorKind::DuplicateRequest(_))
    }
    pub fn is_invalid_input(&self) -> bool {
        matches!(&self.kind, RenewDomainErrorKind::InvalidInput(_))
    }
    pub fn is_operation_limit_exceeded(&self) -> bool {
        matches!(&self.kind, RenewDomainErrorKind::OperationLimitExceeded(_))
    }
    pub fn is_tld_rules_violation(&self) -> bool {
        matches!(&self.kind, RenewDomainErrorKind::TldRulesViolation(_))
    }
    pub fn is_unsupported_tld(&self) -> bool {
        matches!(&self.kind, RenewDomainErrorKind::UnsupportedTld(_))
    }
}
impl std::error::Error for RenewDomainError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RenewDomainErrorKind::DuplicateRequest(_inner) => Some(_inner),
            RenewDomainErrorKind::InvalidInput(_inner) => Some(_inner),
            RenewDomainErrorKind::OperationLimitExceeded(_inner) => Some(_inner),
            RenewDomainErrorKind::TldRulesViolation(_inner) => Some(_inner),
            RenewDomainErrorKind::UnsupportedTld(_inner) => Some(_inner),
            RenewDomainErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ResendContactReachabilityEmailError {
    pub kind: ResendContactReachabilityEmailErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ResendContactReachabilityEmailErrorKind {
    InvalidInput(crate::error::InvalidInput),
    OperationLimitExceeded(crate::error::OperationLimitExceeded),
    UnsupportedTld(crate::error::UnsupportedTld),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ResendContactReachabilityEmailError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ResendContactReachabilityEmailErrorKind::InvalidInput(_inner) => _inner.fmt(f),
            ResendContactReachabilityEmailErrorKind::OperationLimitExceeded(_inner) => {
                _inner.fmt(f)
            }
            ResendContactReachabilityEmailErrorKind::UnsupportedTld(_inner) => _inner.fmt(f),
            ResendContactReachabilityEmailErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ResendContactReachabilityEmailError {
    fn code(&self) -> Option<&str> {
        ResendContactReachabilityEmailError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ResendContactReachabilityEmailError {
    pub fn new(kind: ResendContactReachabilityEmailErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ResendContactReachabilityEmailErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ResendContactReachabilityEmailErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_input(&self) -> bool {
        matches!(
            &self.kind,
            ResendContactReachabilityEmailErrorKind::InvalidInput(_)
        )
    }
    pub fn is_operation_limit_exceeded(&self) -> bool {
        matches!(
            &self.kind,
            ResendContactReachabilityEmailErrorKind::OperationLimitExceeded(_)
        )
    }
    pub fn is_unsupported_tld(&self) -> bool {
        matches!(
            &self.kind,
            ResendContactReachabilityEmailErrorKind::UnsupportedTld(_)
        )
    }
}
impl std::error::Error for ResendContactReachabilityEmailError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ResendContactReachabilityEmailErrorKind::InvalidInput(_inner) => Some(_inner),
            ResendContactReachabilityEmailErrorKind::OperationLimitExceeded(_inner) => Some(_inner),
            ResendContactReachabilityEmailErrorKind::UnsupportedTld(_inner) => Some(_inner),
            ResendContactReachabilityEmailErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RetrieveDomainAuthCodeError {
    pub kind: RetrieveDomainAuthCodeErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RetrieveDomainAuthCodeErrorKind {
    InvalidInput(crate::error::InvalidInput),
    UnsupportedTld(crate::error::UnsupportedTld),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RetrieveDomainAuthCodeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RetrieveDomainAuthCodeErrorKind::InvalidInput(_inner) => _inner.fmt(f),
            RetrieveDomainAuthCodeErrorKind::UnsupportedTld(_inner) => _inner.fmt(f),
            RetrieveDomainAuthCodeErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RetrieveDomainAuthCodeError {
    fn code(&self) -> Option<&str> {
        RetrieveDomainAuthCodeError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RetrieveDomainAuthCodeError {
    pub fn new(kind: RetrieveDomainAuthCodeErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RetrieveDomainAuthCodeErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RetrieveDomainAuthCodeErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_input(&self) -> bool {
        matches!(&self.kind, RetrieveDomainAuthCodeErrorKind::InvalidInput(_))
    }
    pub fn is_unsupported_tld(&self) -> bool {
        matches!(
            &self.kind,
            RetrieveDomainAuthCodeErrorKind::UnsupportedTld(_)
        )
    }
}
impl std::error::Error for RetrieveDomainAuthCodeError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RetrieveDomainAuthCodeErrorKind::InvalidInput(_inner) => Some(_inner),
            RetrieveDomainAuthCodeErrorKind::UnsupportedTld(_inner) => Some(_inner),
            RetrieveDomainAuthCodeErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct TransferDomainError {
    pub kind: TransferDomainErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum TransferDomainErrorKind {
    DomainLimitExceeded(crate::error::DomainLimitExceeded),
    DuplicateRequest(crate::error::DuplicateRequest),
    InvalidInput(crate::error::InvalidInput),
    OperationLimitExceeded(crate::error::OperationLimitExceeded),
    TldRulesViolation(crate::error::TldRulesViolation),
    UnsupportedTld(crate::error::UnsupportedTld),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for TransferDomainError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            TransferDomainErrorKind::DomainLimitExceeded(_inner) => _inner.fmt(f),
            TransferDomainErrorKind::DuplicateRequest(_inner) => _inner.fmt(f),
            TransferDomainErrorKind::InvalidInput(_inner) => _inner.fmt(f),
            TransferDomainErrorKind::OperationLimitExceeded(_inner) => _inner.fmt(f),
            TransferDomainErrorKind::TldRulesViolation(_inner) => _inner.fmt(f),
            TransferDomainErrorKind::UnsupportedTld(_inner) => _inner.fmt(f),
            TransferDomainErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for TransferDomainError {
    fn code(&self) -> Option<&str> {
        TransferDomainError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl TransferDomainError {
    pub fn new(kind: TransferDomainErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: TransferDomainErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: TransferDomainErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_domain_limit_exceeded(&self) -> bool {
        matches!(&self.kind, TransferDomainErrorKind::DomainLimitExceeded(_))
    }
    pub fn is_duplicate_request(&self) -> bool {
        matches!(&self.kind, TransferDomainErrorKind::DuplicateRequest(_))
    }
    pub fn is_invalid_input(&self) -> bool {
        matches!(&self.kind, TransferDomainErrorKind::InvalidInput(_))
    }
    pub fn is_operation_limit_exceeded(&self) -> bool {
        matches!(
            &self.kind,
            TransferDomainErrorKind::OperationLimitExceeded(_)
        )
    }
    pub fn is_tld_rules_violation(&self) -> bool {
        matches!(&self.kind, TransferDomainErrorKind::TldRulesViolation(_))
    }
    pub fn is_unsupported_tld(&self) -> bool {
        matches!(&self.kind, TransferDomainErrorKind::UnsupportedTld(_))
    }
}
impl std::error::Error for TransferDomainError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            TransferDomainErrorKind::DomainLimitExceeded(_inner) => Some(_inner),
            TransferDomainErrorKind::DuplicateRequest(_inner) => Some(_inner),
            TransferDomainErrorKind::InvalidInput(_inner) => Some(_inner),
            TransferDomainErrorKind::OperationLimitExceeded(_inner) => Some(_inner),
            TransferDomainErrorKind::TldRulesViolation(_inner) => Some(_inner),
            TransferDomainErrorKind::UnsupportedTld(_inner) => Some(_inner),
            TransferDomainErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct TransferDomainToAnotherAwsAccountError {
    pub kind: TransferDomainToAnotherAwsAccountErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum TransferDomainToAnotherAwsAccountErrorKind {
    DuplicateRequest(crate::error::DuplicateRequest),
    InvalidInput(crate::error::InvalidInput),
    OperationLimitExceeded(crate::error::OperationLimitExceeded),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for TransferDomainToAnotherAwsAccountError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            TransferDomainToAnotherAwsAccountErrorKind::DuplicateRequest(_inner) => _inner.fmt(f),
            TransferDomainToAnotherAwsAccountErrorKind::InvalidInput(_inner) => _inner.fmt(f),
            TransferDomainToAnotherAwsAccountErrorKind::OperationLimitExceeded(_inner) => {
                _inner.fmt(f)
            }
            TransferDomainToAnotherAwsAccountErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for TransferDomainToAnotherAwsAccountError {
    fn code(&self) -> Option<&str> {
        TransferDomainToAnotherAwsAccountError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl TransferDomainToAnotherAwsAccountError {
    pub fn new(
        kind: TransferDomainToAnotherAwsAccountErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: TransferDomainToAnotherAwsAccountErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: TransferDomainToAnotherAwsAccountErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_duplicate_request(&self) -> bool {
        matches!(
            &self.kind,
            TransferDomainToAnotherAwsAccountErrorKind::DuplicateRequest(_)
        )
    }
    pub fn is_invalid_input(&self) -> bool {
        matches!(
            &self.kind,
            TransferDomainToAnotherAwsAccountErrorKind::InvalidInput(_)
        )
    }
    pub fn is_operation_limit_exceeded(&self) -> bool {
        matches!(
            &self.kind,
            TransferDomainToAnotherAwsAccountErrorKind::OperationLimitExceeded(_)
        )
    }
}
impl std::error::Error for TransferDomainToAnotherAwsAccountError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            TransferDomainToAnotherAwsAccountErrorKind::DuplicateRequest(_inner) => Some(_inner),
            TransferDomainToAnotherAwsAccountErrorKind::InvalidInput(_inner) => Some(_inner),
            TransferDomainToAnotherAwsAccountErrorKind::OperationLimitExceeded(_inner) => {
                Some(_inner)
            }
            TransferDomainToAnotherAwsAccountErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateDomainContactError {
    pub kind: UpdateDomainContactErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateDomainContactErrorKind {
    DuplicateRequest(crate::error::DuplicateRequest),
    InvalidInput(crate::error::InvalidInput),
    OperationLimitExceeded(crate::error::OperationLimitExceeded),
    TldRulesViolation(crate::error::TldRulesViolation),
    UnsupportedTld(crate::error::UnsupportedTld),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateDomainContactError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateDomainContactErrorKind::DuplicateRequest(_inner) => _inner.fmt(f),
            UpdateDomainContactErrorKind::InvalidInput(_inner) => _inner.fmt(f),
            UpdateDomainContactErrorKind::OperationLimitExceeded(_inner) => _inner.fmt(f),
            UpdateDomainContactErrorKind::TldRulesViolation(_inner) => _inner.fmt(f),
            UpdateDomainContactErrorKind::UnsupportedTld(_inner) => _inner.fmt(f),
            UpdateDomainContactErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateDomainContactError {
    fn code(&self) -> Option<&str> {
        UpdateDomainContactError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateDomainContactError {
    pub fn new(kind: UpdateDomainContactErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateDomainContactErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateDomainContactErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_duplicate_request(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDomainContactErrorKind::DuplicateRequest(_)
        )
    }
    pub fn is_invalid_input(&self) -> bool {
        matches!(&self.kind, UpdateDomainContactErrorKind::InvalidInput(_))
    }
    pub fn is_operation_limit_exceeded(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDomainContactErrorKind::OperationLimitExceeded(_)
        )
    }
    pub fn is_tld_rules_violation(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDomainContactErrorKind::TldRulesViolation(_)
        )
    }
    pub fn is_unsupported_tld(&self) -> bool {
        matches!(&self.kind, UpdateDomainContactErrorKind::UnsupportedTld(_))
    }
}
impl std::error::Error for UpdateDomainContactError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateDomainContactErrorKind::DuplicateRequest(_inner) => Some(_inner),
            UpdateDomainContactErrorKind::InvalidInput(_inner) => Some(_inner),
            UpdateDomainContactErrorKind::OperationLimitExceeded(_inner) => Some(_inner),
            UpdateDomainContactErrorKind::TldRulesViolation(_inner) => Some(_inner),
            UpdateDomainContactErrorKind::UnsupportedTld(_inner) => Some(_inner),
            UpdateDomainContactErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateDomainContactPrivacyError {
    pub kind: UpdateDomainContactPrivacyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateDomainContactPrivacyErrorKind {
    DuplicateRequest(crate::error::DuplicateRequest),
    InvalidInput(crate::error::InvalidInput),
    OperationLimitExceeded(crate::error::OperationLimitExceeded),
    TldRulesViolation(crate::error::TldRulesViolation),
    UnsupportedTld(crate::error::UnsupportedTld),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateDomainContactPrivacyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateDomainContactPrivacyErrorKind::DuplicateRequest(_inner) => _inner.fmt(f),
            UpdateDomainContactPrivacyErrorKind::InvalidInput(_inner) => _inner.fmt(f),
            UpdateDomainContactPrivacyErrorKind::OperationLimitExceeded(_inner) => _inner.fmt(f),
            UpdateDomainContactPrivacyErrorKind::TldRulesViolation(_inner) => _inner.fmt(f),
            UpdateDomainContactPrivacyErrorKind::UnsupportedTld(_inner) => _inner.fmt(f),
            UpdateDomainContactPrivacyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateDomainContactPrivacyError {
    fn code(&self) -> Option<&str> {
        UpdateDomainContactPrivacyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateDomainContactPrivacyError {
    pub fn new(kind: UpdateDomainContactPrivacyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateDomainContactPrivacyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateDomainContactPrivacyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_duplicate_request(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDomainContactPrivacyErrorKind::DuplicateRequest(_)
        )
    }
    pub fn is_invalid_input(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDomainContactPrivacyErrorKind::InvalidInput(_)
        )
    }
    pub fn is_operation_limit_exceeded(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDomainContactPrivacyErrorKind::OperationLimitExceeded(_)
        )
    }
    pub fn is_tld_rules_violation(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDomainContactPrivacyErrorKind::TldRulesViolation(_)
        )
    }
    pub fn is_unsupported_tld(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDomainContactPrivacyErrorKind::UnsupportedTld(_)
        )
    }
}
impl std::error::Error for UpdateDomainContactPrivacyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateDomainContactPrivacyErrorKind::DuplicateRequest(_inner) => Some(_inner),
            UpdateDomainContactPrivacyErrorKind::InvalidInput(_inner) => Some(_inner),
            UpdateDomainContactPrivacyErrorKind::OperationLimitExceeded(_inner) => Some(_inner),
            UpdateDomainContactPrivacyErrorKind::TldRulesViolation(_inner) => Some(_inner),
            UpdateDomainContactPrivacyErrorKind::UnsupportedTld(_inner) => Some(_inner),
            UpdateDomainContactPrivacyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateDomainNameserversError {
    pub kind: UpdateDomainNameserversErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateDomainNameserversErrorKind {
    DuplicateRequest(crate::error::DuplicateRequest),
    InvalidInput(crate::error::InvalidInput),
    OperationLimitExceeded(crate::error::OperationLimitExceeded),
    TldRulesViolation(crate::error::TldRulesViolation),
    UnsupportedTld(crate::error::UnsupportedTld),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateDomainNameserversError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateDomainNameserversErrorKind::DuplicateRequest(_inner) => _inner.fmt(f),
            UpdateDomainNameserversErrorKind::InvalidInput(_inner) => _inner.fmt(f),
            UpdateDomainNameserversErrorKind::OperationLimitExceeded(_inner) => _inner.fmt(f),
            UpdateDomainNameserversErrorKind::TldRulesViolation(_inner) => _inner.fmt(f),
            UpdateDomainNameserversErrorKind::UnsupportedTld(_inner) => _inner.fmt(f),
            UpdateDomainNameserversErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateDomainNameserversError {
    fn code(&self) -> Option<&str> {
        UpdateDomainNameserversError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateDomainNameserversError {
    pub fn new(kind: UpdateDomainNameserversErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateDomainNameserversErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateDomainNameserversErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_duplicate_request(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDomainNameserversErrorKind::DuplicateRequest(_)
        )
    }
    pub fn is_invalid_input(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDomainNameserversErrorKind::InvalidInput(_)
        )
    }
    pub fn is_operation_limit_exceeded(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDomainNameserversErrorKind::OperationLimitExceeded(_)
        )
    }
    pub fn is_tld_rules_violation(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDomainNameserversErrorKind::TldRulesViolation(_)
        )
    }
    pub fn is_unsupported_tld(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDomainNameserversErrorKind::UnsupportedTld(_)
        )
    }
}
impl std::error::Error for UpdateDomainNameserversError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateDomainNameserversErrorKind::DuplicateRequest(_inner) => Some(_inner),
            UpdateDomainNameserversErrorKind::InvalidInput(_inner) => Some(_inner),
            UpdateDomainNameserversErrorKind::OperationLimitExceeded(_inner) => Some(_inner),
            UpdateDomainNameserversErrorKind::TldRulesViolation(_inner) => Some(_inner),
            UpdateDomainNameserversErrorKind::UnsupportedTld(_inner) => Some(_inner),
            UpdateDomainNameserversErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateTagsForDomainError {
    pub kind: UpdateTagsForDomainErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateTagsForDomainErrorKind {
    InvalidInput(crate::error::InvalidInput),
    OperationLimitExceeded(crate::error::OperationLimitExceeded),
    UnsupportedTld(crate::error::UnsupportedTld),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateTagsForDomainError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateTagsForDomainErrorKind::InvalidInput(_inner) => _inner.fmt(f),
            UpdateTagsForDomainErrorKind::OperationLimitExceeded(_inner) => _inner.fmt(f),
            UpdateTagsForDomainErrorKind::UnsupportedTld(_inner) => _inner.fmt(f),
            UpdateTagsForDomainErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateTagsForDomainError {
    fn code(&self) -> Option<&str> {
        UpdateTagsForDomainError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateTagsForDomainError {
    pub fn new(kind: UpdateTagsForDomainErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateTagsForDomainErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateTagsForDomainErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_input(&self) -> bool {
        matches!(&self.kind, UpdateTagsForDomainErrorKind::InvalidInput(_))
    }
    pub fn is_operation_limit_exceeded(&self) -> bool {
        matches!(
            &self.kind,
            UpdateTagsForDomainErrorKind::OperationLimitExceeded(_)
        )
    }
    pub fn is_unsupported_tld(&self) -> bool {
        matches!(&self.kind, UpdateTagsForDomainErrorKind::UnsupportedTld(_))
    }
}
impl std::error::Error for UpdateTagsForDomainError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateTagsForDomainErrorKind::InvalidInput(_inner) => Some(_inner),
            UpdateTagsForDomainErrorKind::OperationLimitExceeded(_inner) => Some(_inner),
            UpdateTagsForDomainErrorKind::UnsupportedTld(_inner) => Some(_inner),
            UpdateTagsForDomainErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ViewBillingError {
    pub kind: ViewBillingErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ViewBillingErrorKind {
    InvalidInput(crate::error::InvalidInput),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ViewBillingError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ViewBillingErrorKind::InvalidInput(_inner) => _inner.fmt(f),
            ViewBillingErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ViewBillingError {
    fn code(&self) -> Option<&str> {
        ViewBillingError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ViewBillingError {
    pub fn new(kind: ViewBillingErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ViewBillingErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ViewBillingErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_input(&self) -> bool {
        matches!(&self.kind, ViewBillingErrorKind::InvalidInput(_))
    }
}
impl std::error::Error for ViewBillingError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ViewBillingErrorKind::InvalidInput(_inner) => Some(_inner),
            ViewBillingErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// <p>The requested item is not acceptable. For example, for APIs that accept a domain name, the request might specify a domain name
/// that doesn't belong to the account that submitted the request. For <code>AcceptDomainTransferFromAnotherAwsAccount</code>,
/// the password might be invalid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidInput {
    /// <p>The requested item is not acceptable. For example, for an OperationId it might refer to the ID of an operation
    /// that is already completed. For a domain name, it might not be a valid domain name or belong to the requester account.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidInput");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidInput {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidInput")?;
        if let Some(inner_1) = &self.message {
            write!(f, ": {}", inner_1)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidInput {}
/// See [`InvalidInput`](crate::error::InvalidInput)
pub mod invalid_input {
    /// A builder for [`InvalidInput`](crate::error::InvalidInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The requested item is not acceptable. For example, for an OperationId it might refer to the ID of an operation
        /// that is already completed. For a domain name, it might not be a valid domain name or belong to the requester account.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidInput`](crate::error::InvalidInput)
        pub fn build(self) -> crate::error::InvalidInput {
            crate::error::InvalidInput {
                message: self.message,
            }
        }
    }
}
impl InvalidInput {
    /// Creates a new builder-style object to manufacture [`InvalidInput`](crate::error::InvalidInput)
    pub fn builder() -> crate::error::invalid_input::Builder {
        crate::error::invalid_input::Builder::default()
    }
}

/// <p>Amazon Route 53 does not support this top-level domain (TLD).</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UnsupportedTld {
    /// <p>Amazon Route 53 does not support this top-level domain (TLD).</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UnsupportedTld {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UnsupportedTld");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl UnsupportedTld {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for UnsupportedTld {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "UnsupportedTld [UnsupportedTLD]")?;
        if let Some(inner_2) = &self.message {
            write!(f, ": {}", inner_2)?;
        }
        Ok(())
    }
}
impl std::error::Error for UnsupportedTld {}
/// See [`UnsupportedTld`](crate::error::UnsupportedTld)
pub mod unsupported_tld {
    /// A builder for [`UnsupportedTld`](crate::error::UnsupportedTld)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Amazon Route 53 does not support this top-level domain (TLD).</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`UnsupportedTld`](crate::error::UnsupportedTld)
        pub fn build(self) -> crate::error::UnsupportedTld {
            crate::error::UnsupportedTld {
                message: self.message,
            }
        }
    }
}
impl UnsupportedTld {
    /// Creates a new builder-style object to manufacture [`UnsupportedTld`](crate::error::UnsupportedTld)
    pub fn builder() -> crate::error::unsupported_tld::Builder {
        crate::error::unsupported_tld::Builder::default()
    }
}

/// <p>The number of operations or jobs running exceeded the allowed threshold for the account.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct OperationLimitExceeded {
    /// <p>The number of operations or jobs running exceeded the allowed threshold for the account.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for OperationLimitExceeded {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("OperationLimitExceeded");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl OperationLimitExceeded {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for OperationLimitExceeded {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "OperationLimitExceeded")?;
        if let Some(inner_3) = &self.message {
            write!(f, ": {}", inner_3)?;
        }
        Ok(())
    }
}
impl std::error::Error for OperationLimitExceeded {}
/// See [`OperationLimitExceeded`](crate::error::OperationLimitExceeded)
pub mod operation_limit_exceeded {
    /// A builder for [`OperationLimitExceeded`](crate::error::OperationLimitExceeded)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The number of operations or jobs running exceeded the allowed threshold for the account.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`OperationLimitExceeded`](crate::error::OperationLimitExceeded)
        pub fn build(self) -> crate::error::OperationLimitExceeded {
            crate::error::OperationLimitExceeded {
                message: self.message,
            }
        }
    }
}
impl OperationLimitExceeded {
    /// Creates a new builder-style object to manufacture [`OperationLimitExceeded`](crate::error::OperationLimitExceeded)
    pub fn builder() -> crate::error::operation_limit_exceeded::Builder {
        crate::error::operation_limit_exceeded::Builder::default()
    }
}

/// <p>The top-level domain does not support this operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TldRulesViolation {
    /// <p>The top-level domain does not support this operation.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for TldRulesViolation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TldRulesViolation");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl TldRulesViolation {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TldRulesViolation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TldRulesViolation [TLDRulesViolation]")?;
        if let Some(inner_4) = &self.message {
            write!(f, ": {}", inner_4)?;
        }
        Ok(())
    }
}
impl std::error::Error for TldRulesViolation {}
/// See [`TldRulesViolation`](crate::error::TldRulesViolation)
pub mod tld_rules_violation {
    /// A builder for [`TldRulesViolation`](crate::error::TldRulesViolation)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The top-level domain does not support this operation.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`TldRulesViolation`](crate::error::TldRulesViolation)
        pub fn build(self) -> crate::error::TldRulesViolation {
            crate::error::TldRulesViolation {
                message: self.message,
            }
        }
    }
}
impl TldRulesViolation {
    /// Creates a new builder-style object to manufacture [`TldRulesViolation`](crate::error::TldRulesViolation)
    pub fn builder() -> crate::error::tld_rules_violation::Builder {
        crate::error::tld_rules_violation::Builder::default()
    }
}

/// <p>The request is already in progress for the domain.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DuplicateRequest {
    /// <p>The request is already in progress for the domain.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DuplicateRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DuplicateRequest");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DuplicateRequest {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DuplicateRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DuplicateRequest")?;
        if let Some(inner_5) = &self.message {
            write!(f, ": {}", inner_5)?;
        }
        Ok(())
    }
}
impl std::error::Error for DuplicateRequest {}
/// See [`DuplicateRequest`](crate::error::DuplicateRequest)
pub mod duplicate_request {
    /// A builder for [`DuplicateRequest`](crate::error::DuplicateRequest)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The request is already in progress for the domain.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DuplicateRequest`](crate::error::DuplicateRequest)
        pub fn build(self) -> crate::error::DuplicateRequest {
            crate::error::DuplicateRequest {
                message: self.message,
            }
        }
    }
}
impl DuplicateRequest {
    /// Creates a new builder-style object to manufacture [`DuplicateRequest`](crate::error::DuplicateRequest)
    pub fn builder() -> crate::error::duplicate_request::Builder {
        crate::error::duplicate_request::Builder::default()
    }
}

/// <p>The number of domains has exceeded the allowed threshold for the account.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DomainLimitExceeded {
    /// <p>The number of domains has exceeded the allowed threshold for the account.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DomainLimitExceeded {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DomainLimitExceeded");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DomainLimitExceeded {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DomainLimitExceeded {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DomainLimitExceeded")?;
        if let Some(inner_6) = &self.message {
            write!(f, ": {}", inner_6)?;
        }
        Ok(())
    }
}
impl std::error::Error for DomainLimitExceeded {}
/// See [`DomainLimitExceeded`](crate::error::DomainLimitExceeded)
pub mod domain_limit_exceeded {
    /// A builder for [`DomainLimitExceeded`](crate::error::DomainLimitExceeded)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The number of domains has exceeded the allowed threshold for the account.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DomainLimitExceeded`](crate::error::DomainLimitExceeded)
        pub fn build(self) -> crate::error::DomainLimitExceeded {
            crate::error::DomainLimitExceeded {
                message: self.message,
            }
        }
    }
}
impl DomainLimitExceeded {
    /// Creates a new builder-style object to manufacture [`DomainLimitExceeded`](crate::error::DomainLimitExceeded)
    pub fn builder() -> crate::error::domain_limit_exceeded::Builder {
        crate::error::domain_limit_exceeded::Builder::default()
    }
}
