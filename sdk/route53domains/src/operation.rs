// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// <p>Accepts the transfer of a domain from another AWS account to the current AWS account. You initiate a transfer between AWS accounts using
/// <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains_TransferDomainToAnotherAwsAccount.html">TransferDomainToAnotherAwsAccount</a>.
/// </p>
/// <p>Use either
/// <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains_ListOperations.html">ListOperations</a> or
/// <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains_GetOperationDetail.html">GetOperationDetail</a>
/// to determine whether the operation succeeded.
/// <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains_GetOperationDetail.html">GetOperationDetail</a>
/// provides additional information, for example, <code>Domain Transfer from Aws Account 111122223333 has been cancelled</code>.
/// </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct AcceptDomainTransferFromAnotherAwsAccount {
    _private: (),
}
impl AcceptDomainTransferFromAnotherAwsAccount {
    /// Creates a new builder-style object to manufacture [`AcceptDomainTransferFromAnotherAwsAccountInput`](crate::input::AcceptDomainTransferFromAnotherAwsAccountInput)
    pub fn builder() -> crate::input::accept_domain_transfer_from_another_aws_account_input::Builder
    {
        crate::input::accept_domain_transfer_from_another_aws_account_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for AcceptDomainTransferFromAnotherAwsAccount {
    type Output = std::result::Result<
        crate::output::AcceptDomainTransferFromAnotherAwsAccountOutput,
        crate::error::AcceptDomainTransferFromAnotherAwsAccountError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_accept_domain_transfer_from_another_aws_account_error(
                response,
            )
        } else {
            crate::operation_deser::parse_accept_domain_transfer_from_another_aws_account_response(
                response,
            )
        }
    }
}

/// <p>Cancels the transfer of a domain from the current AWS account to another AWS account. You initiate a transfer between AWS accounts using
/// <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains_TransferDomainToAnotherAwsAccount.html">TransferDomainToAnotherAwsAccount</a>.
/// </p>
/// <important>
/// <p>You must cancel the transfer before the other AWS account accepts the transfer using
/// <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains_AcceptDomainTransferFromAnotherAwsAccount.html">AcceptDomainTransferFromAnotherAwsAccount</a>.</p>
/// </important>
/// <p>Use either
/// <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains_ListOperations.html">ListOperations</a> or
/// <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains_GetOperationDetail.html">GetOperationDetail</a>
/// to determine whether the operation succeeded.
/// <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains_GetOperationDetail.html">GetOperationDetail</a>
/// provides additional information, for example, <code>Domain Transfer from Aws Account 111122223333 has been cancelled</code>.
/// </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CancelDomainTransferToAnotherAwsAccount {
    _private: (),
}
impl CancelDomainTransferToAnotherAwsAccount {
    /// Creates a new builder-style object to manufacture [`CancelDomainTransferToAnotherAwsAccountInput`](crate::input::CancelDomainTransferToAnotherAwsAccountInput)
    pub fn builder() -> crate::input::cancel_domain_transfer_to_another_aws_account_input::Builder {
        crate::input::cancel_domain_transfer_to_another_aws_account_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CancelDomainTransferToAnotherAwsAccount {
    type Output = std::result::Result<
        crate::output::CancelDomainTransferToAnotherAwsAccountOutput,
        crate::error::CancelDomainTransferToAnotherAwsAccountError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_cancel_domain_transfer_to_another_aws_account_error(
                response,
            )
        } else {
            crate::operation_deser::parse_cancel_domain_transfer_to_another_aws_account_response(
                response,
            )
        }
    }
}

/// <p>This operation checks the availability of one domain name. Note that if the availability status of a domain is pending, you must
/// submit another request to determine the availability of the domain name.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CheckDomainAvailability {
    _private: (),
}
impl CheckDomainAvailability {
    /// Creates a new builder-style object to manufacture [`CheckDomainAvailabilityInput`](crate::input::CheckDomainAvailabilityInput)
    pub fn builder() -> crate::input::check_domain_availability_input::Builder {
        crate::input::check_domain_availability_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CheckDomainAvailability {
    type Output = std::result::Result<
        crate::output::CheckDomainAvailabilityOutput,
        crate::error::CheckDomainAvailabilityError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_check_domain_availability_error(response)
        } else {
            crate::operation_deser::parse_check_domain_availability_response(response)
        }
    }
}

/// <p>Checks whether a domain name can be transferred to Amazon Route 53. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CheckDomainTransferability {
    _private: (),
}
impl CheckDomainTransferability {
    /// Creates a new builder-style object to manufacture [`CheckDomainTransferabilityInput`](crate::input::CheckDomainTransferabilityInput)
    pub fn builder() -> crate::input::check_domain_transferability_input::Builder {
        crate::input::check_domain_transferability_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CheckDomainTransferability {
    type Output = std::result::Result<
        crate::output::CheckDomainTransferabilityOutput,
        crate::error::CheckDomainTransferabilityError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_check_domain_transferability_error(response)
        } else {
            crate::operation_deser::parse_check_domain_transferability_response(response)
        }
    }
}

/// <p>This operation deletes the specified tags for a domain.</p>
/// <p>All tag operations are eventually consistent; subsequent operations might not immediately represent all issued operations.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteTagsForDomain {
    _private: (),
}
impl DeleteTagsForDomain {
    /// Creates a new builder-style object to manufacture [`DeleteTagsForDomainInput`](crate::input::DeleteTagsForDomainInput)
    pub fn builder() -> crate::input::delete_tags_for_domain_input::Builder {
        crate::input::delete_tags_for_domain_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteTagsForDomain {
    type Output = std::result::Result<
        crate::output::DeleteTagsForDomainOutput,
        crate::error::DeleteTagsForDomainError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_tags_for_domain_error(response)
        } else {
            crate::operation_deser::parse_delete_tags_for_domain_response(response)
        }
    }
}

/// <p>This operation disables automatic renewal of domain registration for the specified domain.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DisableDomainAutoRenew {
    _private: (),
}
impl DisableDomainAutoRenew {
    /// Creates a new builder-style object to manufacture [`DisableDomainAutoRenewInput`](crate::input::DisableDomainAutoRenewInput)
    pub fn builder() -> crate::input::disable_domain_auto_renew_input::Builder {
        crate::input::disable_domain_auto_renew_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DisableDomainAutoRenew {
    type Output = std::result::Result<
        crate::output::DisableDomainAutoRenewOutput,
        crate::error::DisableDomainAutoRenewError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_disable_domain_auto_renew_error(response)
        } else {
            crate::operation_deser::parse_disable_domain_auto_renew_response(response)
        }
    }
}

/// <p>This operation removes the transfer lock on the domain (specifically the
/// <code>clientTransferProhibited</code> status) to allow domain transfers. We recommend
/// you refrain from performing this action unless you intend to transfer the domain to a
/// different registrar. Successful submission returns an operation ID that you can use to track
/// the progress and completion of the action. If the request is not completed successfully, the
/// domain registrant will be notified by email.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DisableDomainTransferLock {
    _private: (),
}
impl DisableDomainTransferLock {
    /// Creates a new builder-style object to manufacture [`DisableDomainTransferLockInput`](crate::input::DisableDomainTransferLockInput)
    pub fn builder() -> crate::input::disable_domain_transfer_lock_input::Builder {
        crate::input::disable_domain_transfer_lock_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DisableDomainTransferLock {
    type Output = std::result::Result<
        crate::output::DisableDomainTransferLockOutput,
        crate::error::DisableDomainTransferLockError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_disable_domain_transfer_lock_error(response)
        } else {
            crate::operation_deser::parse_disable_domain_transfer_lock_response(response)
        }
    }
}

/// <p>This operation configures Amazon Route 53 to automatically renew the specified domain before the domain registration expires.
/// The cost of renewing your domain registration is billed to your AWS account.</p>
/// <p>The period during which you can renew a domain name varies by TLD. For a list of TLDs and their renewal policies, see
/// <a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/registrar-tld-list.html">Domains That You Can Register with Amazon Route 53</a>
/// in the <i>Amazon Route 53 Developer Guide</i>. Route 53 requires that you renew before the end of the renewal period
/// so we can complete processing before the deadline.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct EnableDomainAutoRenew {
    _private: (),
}
impl EnableDomainAutoRenew {
    /// Creates a new builder-style object to manufacture [`EnableDomainAutoRenewInput`](crate::input::EnableDomainAutoRenewInput)
    pub fn builder() -> crate::input::enable_domain_auto_renew_input::Builder {
        crate::input::enable_domain_auto_renew_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for EnableDomainAutoRenew {
    type Output = std::result::Result<
        crate::output::EnableDomainAutoRenewOutput,
        crate::error::EnableDomainAutoRenewError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_enable_domain_auto_renew_error(response)
        } else {
            crate::operation_deser::parse_enable_domain_auto_renew_response(response)
        }
    }
}

/// <p>This operation sets the transfer lock on the domain (specifically the <code>clientTransferProhibited</code> status)
/// to prevent domain transfers. Successful submission returns an operation ID that you can use to track the progress and
/// completion of the action. If the request is not completed successfully, the domain registrant will be notified by email.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct EnableDomainTransferLock {
    _private: (),
}
impl EnableDomainTransferLock {
    /// Creates a new builder-style object to manufacture [`EnableDomainTransferLockInput`](crate::input::EnableDomainTransferLockInput)
    pub fn builder() -> crate::input::enable_domain_transfer_lock_input::Builder {
        crate::input::enable_domain_transfer_lock_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for EnableDomainTransferLock {
    type Output = std::result::Result<
        crate::output::EnableDomainTransferLockOutput,
        crate::error::EnableDomainTransferLockError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_enable_domain_transfer_lock_error(response)
        } else {
            crate::operation_deser::parse_enable_domain_transfer_lock_response(response)
        }
    }
}

/// <p>For operations that require confirmation that the email address for the registrant contact is valid,
/// such as registering a new domain, this operation returns information about whether the registrant contact has responded.</p>
/// <p>If you want us to resend the email, use the <code>ResendContactReachabilityEmail</code> operation.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetContactReachabilityStatus {
    _private: (),
}
impl GetContactReachabilityStatus {
    /// Creates a new builder-style object to manufacture [`GetContactReachabilityStatusInput`](crate::input::GetContactReachabilityStatusInput)
    pub fn builder() -> crate::input::get_contact_reachability_status_input::Builder {
        crate::input::get_contact_reachability_status_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetContactReachabilityStatus {
    type Output = std::result::Result<
        crate::output::GetContactReachabilityStatusOutput,
        crate::error::GetContactReachabilityStatusError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_contact_reachability_status_error(response)
        } else {
            crate::operation_deser::parse_get_contact_reachability_status_response(response)
        }
    }
}

/// <p>This operation returns detailed information about a specified domain that is associated with the current AWS account.
/// Contact information for the domain is also returned as part of the output.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetDomainDetail {
    _private: (),
}
impl GetDomainDetail {
    /// Creates a new builder-style object to manufacture [`GetDomainDetailInput`](crate::input::GetDomainDetailInput)
    pub fn builder() -> crate::input::get_domain_detail_input::Builder {
        crate::input::get_domain_detail_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetDomainDetail {
    type Output = std::result::Result<
        crate::output::GetDomainDetailOutput,
        crate::error::GetDomainDetailError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_domain_detail_error(response)
        } else {
            crate::operation_deser::parse_get_domain_detail_response(response)
        }
    }
}

/// <p>The GetDomainSuggestions operation returns a list of suggested domain names.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetDomainSuggestions {
    _private: (),
}
impl GetDomainSuggestions {
    /// Creates a new builder-style object to manufacture [`GetDomainSuggestionsInput`](crate::input::GetDomainSuggestionsInput)
    pub fn builder() -> crate::input::get_domain_suggestions_input::Builder {
        crate::input::get_domain_suggestions_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetDomainSuggestions {
    type Output = std::result::Result<
        crate::output::GetDomainSuggestionsOutput,
        crate::error::GetDomainSuggestionsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_domain_suggestions_error(response)
        } else {
            crate::operation_deser::parse_get_domain_suggestions_response(response)
        }
    }
}

/// <p>This operation returns the current status of an operation that is not completed.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetOperationDetail {
    _private: (),
}
impl GetOperationDetail {
    /// Creates a new builder-style object to manufacture [`GetOperationDetailInput`](crate::input::GetOperationDetailInput)
    pub fn builder() -> crate::input::get_operation_detail_input::Builder {
        crate::input::get_operation_detail_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetOperationDetail {
    type Output = std::result::Result<
        crate::output::GetOperationDetailOutput,
        crate::error::GetOperationDetailError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_operation_detail_error(response)
        } else {
            crate::operation_deser::parse_get_operation_detail_response(response)
        }
    }
}

/// <p>This operation returns all the domain names registered with Amazon Route 53 for the current AWS account.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListDomains {
    _private: (),
}
impl ListDomains {
    /// Creates a new builder-style object to manufacture [`ListDomainsInput`](crate::input::ListDomainsInput)
    pub fn builder() -> crate::input::list_domains_input::Builder {
        crate::input::list_domains_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListDomains {
    type Output =
        std::result::Result<crate::output::ListDomainsOutput, crate::error::ListDomainsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_domains_error(response)
        } else {
            crate::operation_deser::parse_list_domains_response(response)
        }
    }
}

/// <p>Returns information about all of the operations that return an operation ID and that have ever been
/// performed on domains that were registered by the current account. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListOperations {
    _private: (),
}
impl ListOperations {
    /// Creates a new builder-style object to manufacture [`ListOperationsInput`](crate::input::ListOperationsInput)
    pub fn builder() -> crate::input::list_operations_input::Builder {
        crate::input::list_operations_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListOperations {
    type Output =
        std::result::Result<crate::output::ListOperationsOutput, crate::error::ListOperationsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_operations_error(response)
        } else {
            crate::operation_deser::parse_list_operations_response(response)
        }
    }
}

/// <p>This operation returns all of the tags that are associated with the specified domain.</p>
/// <p>All tag operations are eventually consistent; subsequent operations might not immediately represent all issued operations.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListTagsForDomain {
    _private: (),
}
impl ListTagsForDomain {
    /// Creates a new builder-style object to manufacture [`ListTagsForDomainInput`](crate::input::ListTagsForDomainInput)
    pub fn builder() -> crate::input::list_tags_for_domain_input::Builder {
        crate::input::list_tags_for_domain_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListTagsForDomain {
    type Output = std::result::Result<
        crate::output::ListTagsForDomainOutput,
        crate::error::ListTagsForDomainError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_tags_for_domain_error(response)
        } else {
            crate::operation_deser::parse_list_tags_for_domain_response(response)
        }
    }
}

/// <p>This operation registers a domain. Domains are registered either by Amazon Registrar (for .com, .net, and .org domains) or by  
/// our registrar associate, Gandi (for all other domains). For some top-level domains (TLDs), this operation requires extra parameters.</p>
/// <p>When you register a domain, Amazon Route 53 does the following:</p>
/// <ul>
/// <li>
/// <p>Creates a Route 53 hosted zone that has the same name as the domain. Route 53 assigns four name servers
/// to your hosted zone and automatically updates your domain registration with the names of these name servers.</p>
/// </li>
/// <li>
/// <p>Enables autorenew, so your domain registration will renew automatically each year. We'll notify you
/// in advance of the renewal date so you can choose whether to renew the registration.</p>
/// </li>
/// <li>
/// <p>Optionally enables privacy protection, so WHOIS queries return contact information either for Amazon Registrar
/// (for .com, .net, and .org domains) or for our registrar associate, Gandi (for all other TLDs). If you don't enable privacy
/// protection, WHOIS queries return the information that you entered for the registrant, admin, and tech contacts.</p>
/// </li>
/// <li>
/// <p>If registration is successful, returns an operation ID that you can use to track the progress and
/// completion of the action. If the request is not completed successfully, the domain registrant is notified by email.</p>
/// </li>
/// <li>
/// <p>Charges your AWS account an amount based on the top-level domain. For more information, see
/// <a href="http://aws.amazon.com/route53/pricing/">Amazon Route 53 Pricing</a>.</p>
/// </li>
/// </ul>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct RegisterDomain {
    _private: (),
}
impl RegisterDomain {
    /// Creates a new builder-style object to manufacture [`RegisterDomainInput`](crate::input::RegisterDomainInput)
    pub fn builder() -> crate::input::register_domain_input::Builder {
        crate::input::register_domain_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for RegisterDomain {
    type Output =
        std::result::Result<crate::output::RegisterDomainOutput, crate::error::RegisterDomainError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_register_domain_error(response)
        } else {
            crate::operation_deser::parse_register_domain_response(response)
        }
    }
}

/// <p>Rejects the transfer of a domain from another AWS account to the current AWS account. You initiate a transfer between AWS accounts using
/// <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains_TransferDomainToAnotherAwsAccount.html">TransferDomainToAnotherAwsAccount</a>.
/// </p>
/// <p>Use either
/// <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains_ListOperations.html">ListOperations</a> or
/// <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains_GetOperationDetail.html">GetOperationDetail</a>
/// to determine whether the operation succeeded.
/// <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains_GetOperationDetail.html">GetOperationDetail</a>
/// provides additional information, for example, <code>Domain Transfer from Aws Account 111122223333 has been cancelled</code>.
/// </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct RejectDomainTransferFromAnotherAwsAccount {
    _private: (),
}
impl RejectDomainTransferFromAnotherAwsAccount {
    /// Creates a new builder-style object to manufacture [`RejectDomainTransferFromAnotherAwsAccountInput`](crate::input::RejectDomainTransferFromAnotherAwsAccountInput)
    pub fn builder() -> crate::input::reject_domain_transfer_from_another_aws_account_input::Builder
    {
        crate::input::reject_domain_transfer_from_another_aws_account_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for RejectDomainTransferFromAnotherAwsAccount {
    type Output = std::result::Result<
        crate::output::RejectDomainTransferFromAnotherAwsAccountOutput,
        crate::error::RejectDomainTransferFromAnotherAwsAccountError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_reject_domain_transfer_from_another_aws_account_error(
                response,
            )
        } else {
            crate::operation_deser::parse_reject_domain_transfer_from_another_aws_account_response(
                response,
            )
        }
    }
}

/// <p>This operation renews a domain for the specified number of years. The cost of renewing your domain is billed to your AWS account.</p>
/// <p>We recommend that you renew your domain several weeks before the expiration date. Some TLD registries delete domains before the
/// expiration date if you haven't renewed far enough in advance. For more information about renewing domain registration, see
/// <a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/domain-renew.html">Renewing Registration for a Domain</a>
/// in the <i>Amazon Route 53 Developer Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct RenewDomain {
    _private: (),
}
impl RenewDomain {
    /// Creates a new builder-style object to manufacture [`RenewDomainInput`](crate::input::RenewDomainInput)
    pub fn builder() -> crate::input::renew_domain_input::Builder {
        crate::input::renew_domain_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for RenewDomain {
    type Output =
        std::result::Result<crate::output::RenewDomainOutput, crate::error::RenewDomainError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_renew_domain_error(response)
        } else {
            crate::operation_deser::parse_renew_domain_response(response)
        }
    }
}

/// <p>For operations that require confirmation that the email address for the registrant contact is valid,
/// such as registering a new domain, this operation resends the confirmation email to the current email address for the registrant contact.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ResendContactReachabilityEmail {
    _private: (),
}
impl ResendContactReachabilityEmail {
    /// Creates a new builder-style object to manufacture [`ResendContactReachabilityEmailInput`](crate::input::ResendContactReachabilityEmailInput)
    pub fn builder() -> crate::input::resend_contact_reachability_email_input::Builder {
        crate::input::resend_contact_reachability_email_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ResendContactReachabilityEmail {
    type Output = std::result::Result<
        crate::output::ResendContactReachabilityEmailOutput,
        crate::error::ResendContactReachabilityEmailError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_resend_contact_reachability_email_error(response)
        } else {
            crate::operation_deser::parse_resend_contact_reachability_email_response(response)
        }
    }
}

/// <p>This operation returns the AuthCode for the domain. To transfer a domain to another registrar, you provide this value to the new registrar.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct RetrieveDomainAuthCode {
    _private: (),
}
impl RetrieveDomainAuthCode {
    /// Creates a new builder-style object to manufacture [`RetrieveDomainAuthCodeInput`](crate::input::RetrieveDomainAuthCodeInput)
    pub fn builder() -> crate::input::retrieve_domain_auth_code_input::Builder {
        crate::input::retrieve_domain_auth_code_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for RetrieveDomainAuthCode {
    type Output = std::result::Result<
        crate::output::RetrieveDomainAuthCodeOutput,
        crate::error::RetrieveDomainAuthCodeError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_retrieve_domain_auth_code_error(response)
        } else {
            crate::operation_deser::parse_retrieve_domain_auth_code_response(response)
        }
    }
}

/// <p>Transfers a domain from another registrar to Amazon Route 53. When the transfer is complete, the domain is registered either with
/// Amazon Registrar (for .com, .net, and .org domains) or with our registrar associate, Gandi (for all other TLDs).</p>
/// <p>For more information about transferring domains, see the following topics:</p>
/// <ul>
/// <li>
/// <p>For transfer requirements, a detailed procedure, and information about viewing the status of a domain that you're transferring
/// to Route 53, see
/// <a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/domain-transfer-to-route-53.html">Transferring Registration for a
/// Domain to Amazon Route 53</a> in the <i>Amazon Route 53 Developer Guide</i>.</p>
/// </li>
/// <li>
/// <p>For information about how to transfer a domain from one AWS account to another, see
/// <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains_TransferDomainToAnotherAwsAccount.html">TransferDomainToAnotherAwsAccount</a>.
/// </p>
/// </li>
/// <li>
/// <p>For information about how to transfer a domain to another domain registrar, see
/// <a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/domain-transfer-from-route-53.html">Transferring a Domain from
/// Amazon Route 53 to Another Registrar</a> in the <i>Amazon Route 53 Developer Guide</i>.</p>
/// </li>
/// </ul>
/// <p>If the registrar for your domain is also the DNS service provider for the domain, we highly recommend that you
/// transfer your DNS service to Route 53 or to another DNS service provider before you transfer your registration. Some registrars
/// provide free DNS service when you purchase a domain registration. When you transfer the registration, the previous registrar
/// will not renew your domain registration and could end your DNS service at any time.</p>
/// <important>
/// <p>If the registrar for your domain is also the DNS service provider for the domain and you don't
/// transfer DNS service to another provider, your website, email, and the web applications associated with the domain
/// might become unavailable.</p>
/// </important>
/// <p>If the transfer is successful, this method returns an operation ID that you can use to track the progress and
/// completion of the action. If the transfer doesn't complete successfully, the domain registrant will be notified by email.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct TransferDomain {
    _private: (),
}
impl TransferDomain {
    /// Creates a new builder-style object to manufacture [`TransferDomainInput`](crate::input::TransferDomainInput)
    pub fn builder() -> crate::input::transfer_domain_input::Builder {
        crate::input::transfer_domain_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for TransferDomain {
    type Output =
        std::result::Result<crate::output::TransferDomainOutput, crate::error::TransferDomainError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_transfer_domain_error(response)
        } else {
            crate::operation_deser::parse_transfer_domain_response(response)
        }
    }
}

/// <p>Transfers a domain from the current AWS account to another AWS account. Note the following:</p>
/// <ul>
/// <li>
/// <p>The AWS account that you're transferring the domain to must accept the transfer. If the other account
/// doesn't accept the transfer within 3 days, we cancel the transfer. See
/// <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains_AcceptDomainTransferFromAnotherAwsAccount.html">AcceptDomainTransferFromAnotherAwsAccount</a>.
/// </p>
/// </li>
/// <li>
/// <p>You can cancel the transfer before the other account accepts it. See
/// <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains_CancelDomainTransferToAnotherAwsAccount.html">CancelDomainTransferToAnotherAwsAccount</a>.
/// </p>
/// </li>
/// <li>
/// <p>The other account can reject the transfer. See
/// <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains_RejectDomainTransferFromAnotherAwsAccount.html">RejectDomainTransferFromAnotherAwsAccount</a>.
/// </p>
/// </li>
/// </ul>
/// <important>
/// <p>When you transfer a domain from one AWS account to another, Route 53 doesn't transfer the hosted zone that is associated
/// with the domain. DNS resolution isn't affected if the domain and the hosted zone are owned by separate accounts,
/// so transferring the hosted zone is optional. For information about transferring the hosted zone to another AWS account, see
/// <a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/hosted-zones-migrating.html">Migrating a Hosted Zone to a
/// Different AWS Account</a> in the <i>Amazon Route 53 Developer Guide</i>.</p>
/// </important>
/// <p>Use either
/// <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains_ListOperations.html">ListOperations</a> or
/// <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains_GetOperationDetail.html">GetOperationDetail</a>
/// to determine whether the operation succeeded.
/// <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains_GetOperationDetail.html">GetOperationDetail</a>
/// provides additional information, for example, <code>Domain Transfer from Aws Account 111122223333 has been cancelled</code>.
/// </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct TransferDomainToAnotherAwsAccount {
    _private: (),
}
impl TransferDomainToAnotherAwsAccount {
    /// Creates a new builder-style object to manufacture [`TransferDomainToAnotherAwsAccountInput`](crate::input::TransferDomainToAnotherAwsAccountInput)
    pub fn builder() -> crate::input::transfer_domain_to_another_aws_account_input::Builder {
        crate::input::transfer_domain_to_another_aws_account_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for TransferDomainToAnotherAwsAccount {
    type Output = std::result::Result<
        crate::output::TransferDomainToAnotherAwsAccountOutput,
        crate::error::TransferDomainToAnotherAwsAccountError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_transfer_domain_to_another_aws_account_error(response)
        } else {
            crate::operation_deser::parse_transfer_domain_to_another_aws_account_response(response)
        }
    }
}

/// <p>This operation updates the contact information for a particular domain. You must specify information for at least one contact:
/// registrant, administrator, or technical.</p>
/// <p>If the update is successful, this method returns an operation ID that you can use to track the progress and completion of the action.
/// If the request is not completed successfully, the domain registrant will be notified by email.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateDomainContact {
    _private: (),
}
impl UpdateDomainContact {
    /// Creates a new builder-style object to manufacture [`UpdateDomainContactInput`](crate::input::UpdateDomainContactInput)
    pub fn builder() -> crate::input::update_domain_contact_input::Builder {
        crate::input::update_domain_contact_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateDomainContact {
    type Output = std::result::Result<
        crate::output::UpdateDomainContactOutput,
        crate::error::UpdateDomainContactError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_domain_contact_error(response)
        } else {
            crate::operation_deser::parse_update_domain_contact_response(response)
        }
    }
}

/// <p>This operation updates the specified domain contact's privacy setting. When privacy protection is enabled,
/// contact information such as email address is replaced either with contact information for Amazon Registrar (for .com, .net, and .org
/// domains) or with contact information for our registrar associate, Gandi.</p>
/// <p>This operation affects only the contact information for the specified contact type (registrant, administrator, or tech).
/// If the request succeeds, Amazon Route 53 returns an operation ID that you can use with
/// <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains_GetOperationDetail.html">GetOperationDetail</a>
/// to track the progress and completion of the action. If the request doesn't complete successfully, the domain registrant will be notified by email.</p>
/// <important>
/// <p>By disabling the privacy service via API, you consent to the publication of the contact information provided for this domain
/// via the public WHOIS database. You certify that you are the registrant of this domain name and have the authority to make this decision.
/// You may withdraw your consent at any time by enabling privacy protection using either <code>UpdateDomainContactPrivacy</code> or the
/// Route 53 console. Enabling privacy protection removes the contact information provided for this domain from the WHOIS database.
/// For more information on our privacy practices, see
/// <a href="https://aws.amazon.com/privacy/">https://aws.amazon.com/privacy/</a>.</p>
/// </important>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateDomainContactPrivacy {
    _private: (),
}
impl UpdateDomainContactPrivacy {
    /// Creates a new builder-style object to manufacture [`UpdateDomainContactPrivacyInput`](crate::input::UpdateDomainContactPrivacyInput)
    pub fn builder() -> crate::input::update_domain_contact_privacy_input::Builder {
        crate::input::update_domain_contact_privacy_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateDomainContactPrivacy {
    type Output = std::result::Result<
        crate::output::UpdateDomainContactPrivacyOutput,
        crate::error::UpdateDomainContactPrivacyError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_domain_contact_privacy_error(response)
        } else {
            crate::operation_deser::parse_update_domain_contact_privacy_response(response)
        }
    }
}

/// <p>This operation replaces the current set of name servers for the domain with the specified set of name servers.
/// If you use Amazon Route 53 as your DNS service, specify the four name servers in the delegation set for the hosted zone for the domain.</p>
/// <p>If successful, this operation returns an operation ID that you can use to track the progress and completion of the action.
/// If the request is not completed successfully, the domain registrant will be notified by email.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateDomainNameservers {
    _private: (),
}
impl UpdateDomainNameservers {
    /// Creates a new builder-style object to manufacture [`UpdateDomainNameserversInput`](crate::input::UpdateDomainNameserversInput)
    pub fn builder() -> crate::input::update_domain_nameservers_input::Builder {
        crate::input::update_domain_nameservers_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateDomainNameservers {
    type Output = std::result::Result<
        crate::output::UpdateDomainNameserversOutput,
        crate::error::UpdateDomainNameserversError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_domain_nameservers_error(response)
        } else {
            crate::operation_deser::parse_update_domain_nameservers_response(response)
        }
    }
}

/// <p>This operation adds or updates tags for a specified domain.</p>
/// <p>All tag operations are eventually consistent; subsequent operations might not immediately represent all issued operations.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateTagsForDomain {
    _private: (),
}
impl UpdateTagsForDomain {
    /// Creates a new builder-style object to manufacture [`UpdateTagsForDomainInput`](crate::input::UpdateTagsForDomainInput)
    pub fn builder() -> crate::input::update_tags_for_domain_input::Builder {
        crate::input::update_tags_for_domain_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateTagsForDomain {
    type Output = std::result::Result<
        crate::output::UpdateTagsForDomainOutput,
        crate::error::UpdateTagsForDomainError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_tags_for_domain_error(response)
        } else {
            crate::operation_deser::parse_update_tags_for_domain_response(response)
        }
    }
}

/// <p>Returns all the domain-related billing records for the current AWS account for a specified period</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ViewBilling {
    _private: (),
}
impl ViewBilling {
    /// Creates a new builder-style object to manufacture [`ViewBillingInput`](crate::input::ViewBillingInput)
    pub fn builder() -> crate::input::view_billing_input::Builder {
        crate::input::view_billing_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ViewBilling {
    type Output =
        std::result::Result<crate::output::ViewBillingOutput, crate::error::ViewBillingError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_view_billing_error(response)
        } else {
            crate::operation_deser::parse_view_billing_response(response)
        }
    }
}
