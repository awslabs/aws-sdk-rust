// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Defines a condition under which a trigger fires.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Condition {
    /// <p>A logical operator.</p>
    #[doc(hidden)]
    pub logical_operator: std::option::Option<crate::types::LogicalOperator>,
    /// <p>The name of the job whose <code>JobRuns</code> this condition applies to, and on which this trigger waits.</p>
    #[doc(hidden)]
    pub job_name: std::option::Option<std::string::String>,
    /// <p>The condition state. Currently, the only job states that a trigger can listen for are <code>SUCCEEDED</code>, <code>STOPPED</code>, <code>FAILED</code>, and <code>TIMEOUT</code>. The only crawler states that a trigger can listen for are <code>SUCCEEDED</code>, <code>FAILED</code>, and <code>CANCELLED</code>.</p>
    #[doc(hidden)]
    pub state: std::option::Option<crate::types::JobRunState>,
    /// <p>The name of the crawler to which this condition applies.</p>
    #[doc(hidden)]
    pub crawler_name: std::option::Option<std::string::String>,
    /// <p>The state of the crawler to which this condition applies.</p>
    #[doc(hidden)]
    pub crawl_state: std::option::Option<crate::types::CrawlState>,
}
impl Condition {
    /// <p>A logical operator.</p>
    pub fn logical_operator(&self) -> std::option::Option<&crate::types::LogicalOperator> {
        self.logical_operator.as_ref()
    }
    /// <p>The name of the job whose <code>JobRuns</code> this condition applies to, and on which this trigger waits.</p>
    pub fn job_name(&self) -> std::option::Option<&str> {
        self.job_name.as_deref()
    }
    /// <p>The condition state. Currently, the only job states that a trigger can listen for are <code>SUCCEEDED</code>, <code>STOPPED</code>, <code>FAILED</code>, and <code>TIMEOUT</code>. The only crawler states that a trigger can listen for are <code>SUCCEEDED</code>, <code>FAILED</code>, and <code>CANCELLED</code>.</p>
    pub fn state(&self) -> std::option::Option<&crate::types::JobRunState> {
        self.state.as_ref()
    }
    /// <p>The name of the crawler to which this condition applies.</p>
    pub fn crawler_name(&self) -> std::option::Option<&str> {
        self.crawler_name.as_deref()
    }
    /// <p>The state of the crawler to which this condition applies.</p>
    pub fn crawl_state(&self) -> std::option::Option<&crate::types::CrawlState> {
        self.crawl_state.as_ref()
    }
}
impl Condition {
    /// Creates a new builder-style object to manufacture [`Condition`](crate::types::Condition).
    pub fn builder() -> crate::types::builders::ConditionBuilder {
        crate::types::builders::ConditionBuilder::default()
    }
}

/// A builder for [`Condition`](crate::types::Condition).
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
pub struct ConditionBuilder {
    pub(crate) logical_operator: std::option::Option<crate::types::LogicalOperator>,
    pub(crate) job_name: std::option::Option<std::string::String>,
    pub(crate) state: std::option::Option<crate::types::JobRunState>,
    pub(crate) crawler_name: std::option::Option<std::string::String>,
    pub(crate) crawl_state: std::option::Option<crate::types::CrawlState>,
}
impl ConditionBuilder {
    /// <p>A logical operator.</p>
    pub fn logical_operator(mut self, input: crate::types::LogicalOperator) -> Self {
        self.logical_operator = Some(input);
        self
    }
    /// <p>A logical operator.</p>
    pub fn set_logical_operator(
        mut self,
        input: std::option::Option<crate::types::LogicalOperator>,
    ) -> Self {
        self.logical_operator = input;
        self
    }
    /// <p>The name of the job whose <code>JobRuns</code> this condition applies to, and on which this trigger waits.</p>
    pub fn job_name(mut self, input: impl Into<std::string::String>) -> Self {
        self.job_name = Some(input.into());
        self
    }
    /// <p>The name of the job whose <code>JobRuns</code> this condition applies to, and on which this trigger waits.</p>
    pub fn set_job_name(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.job_name = input;
        self
    }
    /// <p>The condition state. Currently, the only job states that a trigger can listen for are <code>SUCCEEDED</code>, <code>STOPPED</code>, <code>FAILED</code>, and <code>TIMEOUT</code>. The only crawler states that a trigger can listen for are <code>SUCCEEDED</code>, <code>FAILED</code>, and <code>CANCELLED</code>.</p>
    pub fn state(mut self, input: crate::types::JobRunState) -> Self {
        self.state = Some(input);
        self
    }
    /// <p>The condition state. Currently, the only job states that a trigger can listen for are <code>SUCCEEDED</code>, <code>STOPPED</code>, <code>FAILED</code>, and <code>TIMEOUT</code>. The only crawler states that a trigger can listen for are <code>SUCCEEDED</code>, <code>FAILED</code>, and <code>CANCELLED</code>.</p>
    pub fn set_state(mut self, input: std::option::Option<crate::types::JobRunState>) -> Self {
        self.state = input;
        self
    }
    /// <p>The name of the crawler to which this condition applies.</p>
    pub fn crawler_name(mut self, input: impl Into<std::string::String>) -> Self {
        self.crawler_name = Some(input.into());
        self
    }
    /// <p>The name of the crawler to which this condition applies.</p>
    pub fn set_crawler_name(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.crawler_name = input;
        self
    }
    /// <p>The state of the crawler to which this condition applies.</p>
    pub fn crawl_state(mut self, input: crate::types::CrawlState) -> Self {
        self.crawl_state = Some(input);
        self
    }
    /// <p>The state of the crawler to which this condition applies.</p>
    pub fn set_crawl_state(mut self, input: std::option::Option<crate::types::CrawlState>) -> Self {
        self.crawl_state = input;
        self
    }
    /// Consumes the builder and constructs a [`Condition`](crate::types::Condition).
    pub fn build(self) -> crate::types::Condition {
        crate::types::Condition {
            logical_operator: self.logical_operator,
            job_name: self.job_name,
            state: self.state,
            crawler_name: self.crawler_name,
            crawl_state: self.crawl_state,
        }
    }
}
