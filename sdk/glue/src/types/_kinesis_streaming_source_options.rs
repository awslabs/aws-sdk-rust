// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Additional options for the Amazon Kinesis streaming data source.</p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct KinesisStreamingSourceOptions {
    /// <p>The URL of the Kinesis endpoint.</p>
    pub endpoint_url: ::std::option::Option<::std::string::String>,
    /// <p>The name of the Kinesis data stream.</p>
    pub stream_name: ::std::option::Option<::std::string::String>,
    /// <p>An optional classification.</p>
    pub classification: ::std::option::Option<::std::string::String>,
    /// <p>Specifies the delimiter character.</p>
    pub delimiter: ::std::option::Option<::std::string::String>,
    /// <p>The starting position in the Kinesis data stream to read data from. The possible values are <code>"latest"</code>, <code>"trim_horizon"</code>, <code>"earliest"</code>, or a timestamp string in UTC format in the pattern <code>yyyy-mm-ddTHH:MM:SSZ</code> (where <code>Z</code> represents a UTC timezone offset with a +/-. For example: "2023-04-04T08:00:00-04:00"). The default value is <code>"latest"</code>.</p>
    /// <p>Note: Using a value that is a timestamp string in UTC format for "startingPosition" is supported only for Glue version 4.0 or later.</p>
    pub starting_position: ::std::option::Option<crate::types::StartingPosition>,
    /// <p>The maximum time spent in the job executor to fetch a record from the Kinesis data stream per shard, specified in milliseconds (ms). The default value is <code>1000</code>.</p>
    pub max_fetch_time_in_ms: ::std::option::Option<i64>,
    /// <p>The maximum number of records to fetch per shard in the Kinesis data stream. The default value is <code>100000</code>.</p>
    pub max_fetch_records_per_shard: ::std::option::Option<i64>,
    /// <p>The maximum number of records to fetch from the Kinesis data stream in each getRecords operation. The default value is <code>10000</code>.</p>
    pub max_record_per_read: ::std::option::Option<i64>,
    /// <p>Adds a time delay between two consecutive getRecords operations. The default value is <code>"False"</code>. This option is only configurable for Glue version 2.0 and above.</p>
    pub add_idle_time_between_reads: ::std::option::Option<bool>,
    /// <p>The minimum time delay between two consecutive getRecords operations, specified in ms. The default value is <code>1000</code>. This option is only configurable for Glue version 2.0 and above.</p>
    pub idle_time_between_reads_in_ms: ::std::option::Option<i64>,
    /// <p>The minimum time interval between two ListShards API calls for your script to consider resharding. The default value is <code>1s</code>.</p>
    pub describe_shard_interval: ::std::option::Option<i64>,
    /// <p>The maximum number of retries for Kinesis Data Streams API requests. The default value is <code>3</code>.</p>
    pub num_retries: ::std::option::Option<i32>,
    /// <p>The cool-off time period (specified in ms) before retrying the Kinesis Data Streams API call. The default value is <code>1000</code>.</p>
    pub retry_interval_ms: ::std::option::Option<i64>,
    /// <p>The maximum cool-off time period (specified in ms) between two retries of a Kinesis Data Streams API call. The default value is <code>10000</code>.</p>
    pub max_retry_interval_ms: ::std::option::Option<i64>,
    /// <p>Avoids creating an empty microbatch job by checking for unread data in the Kinesis data stream before the batch is started. The default value is <code>"False"</code>.</p>
    pub avoid_empty_batches: ::std::option::Option<bool>,
    /// <p>The Amazon Resource Name (ARN) of the Kinesis data stream.</p>
    pub stream_arn: ::std::option::Option<::std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the role to assume using AWS Security Token Service (AWS STS). This role must have permissions for describe or read record operations for the Kinesis data stream. You must use this parameter when accessing a data stream in a different account. Used in conjunction with <code>"awsSTSSessionName"</code>.</p>
    pub role_arn: ::std::option::Option<::std::string::String>,
    /// <p>An identifier for the session assuming the role using AWS STS. You must use this parameter when accessing a data stream in a different account. Used in conjunction with <code>"awsSTSRoleARN"</code>.</p>
    pub role_session_name: ::std::option::Option<::std::string::String>,
    /// <p>When this option is set to 'true', the data output will contain an additional column named "__src_timestamp" that indicates the time when the corresponding record received by the stream. The default value is 'false'. This option is supported in Glue version 4.0 or later.</p>
    pub add_record_timestamp: ::std::option::Option<::std::string::String>,
    /// <p>When this option is set to 'true', for each batch, it will emit the metrics for the duration between the oldest record received by the stream and the time it arrives in Glue to CloudWatch. The metric's name is "glue.driver.streaming.maxConsumerLagInMs". The default value is 'false'. This option is supported in Glue version 4.0 or later.</p>
    pub emit_consumer_lag_metrics: ::std::option::Option<::std::string::String>,
    /// <p>The timestamp of the record in the Kinesis data stream to start reading data from. The possible values are a timestamp string in UTC format of the pattern <code>yyyy-mm-ddTHH:MM:SSZ</code> (where Z represents a UTC timezone offset with a +/-. For example: "2023-04-04T08:00:00+08:00").</p>
    pub starting_timestamp: ::std::option::Option<::aws_smithy_types::DateTime>,
}
impl KinesisStreamingSourceOptions {
    /// <p>The URL of the Kinesis endpoint.</p>
    pub fn endpoint_url(&self) -> ::std::option::Option<&str> {
        self.endpoint_url.as_deref()
    }
    /// <p>The name of the Kinesis data stream.</p>
    pub fn stream_name(&self) -> ::std::option::Option<&str> {
        self.stream_name.as_deref()
    }
    /// <p>An optional classification.</p>
    pub fn classification(&self) -> ::std::option::Option<&str> {
        self.classification.as_deref()
    }
    /// <p>Specifies the delimiter character.</p>
    pub fn delimiter(&self) -> ::std::option::Option<&str> {
        self.delimiter.as_deref()
    }
    /// <p>The starting position in the Kinesis data stream to read data from. The possible values are <code>"latest"</code>, <code>"trim_horizon"</code>, <code>"earliest"</code>, or a timestamp string in UTC format in the pattern <code>yyyy-mm-ddTHH:MM:SSZ</code> (where <code>Z</code> represents a UTC timezone offset with a +/-. For example: "2023-04-04T08:00:00-04:00"). The default value is <code>"latest"</code>.</p>
    /// <p>Note: Using a value that is a timestamp string in UTC format for "startingPosition" is supported only for Glue version 4.0 or later.</p>
    pub fn starting_position(&self) -> ::std::option::Option<&crate::types::StartingPosition> {
        self.starting_position.as_ref()
    }
    /// <p>The maximum time spent in the job executor to fetch a record from the Kinesis data stream per shard, specified in milliseconds (ms). The default value is <code>1000</code>.</p>
    pub fn max_fetch_time_in_ms(&self) -> ::std::option::Option<i64> {
        self.max_fetch_time_in_ms
    }
    /// <p>The maximum number of records to fetch per shard in the Kinesis data stream. The default value is <code>100000</code>.</p>
    pub fn max_fetch_records_per_shard(&self) -> ::std::option::Option<i64> {
        self.max_fetch_records_per_shard
    }
    /// <p>The maximum number of records to fetch from the Kinesis data stream in each getRecords operation. The default value is <code>10000</code>.</p>
    pub fn max_record_per_read(&self) -> ::std::option::Option<i64> {
        self.max_record_per_read
    }
    /// <p>Adds a time delay between two consecutive getRecords operations. The default value is <code>"False"</code>. This option is only configurable for Glue version 2.0 and above.</p>
    pub fn add_idle_time_between_reads(&self) -> ::std::option::Option<bool> {
        self.add_idle_time_between_reads
    }
    /// <p>The minimum time delay between two consecutive getRecords operations, specified in ms. The default value is <code>1000</code>. This option is only configurable for Glue version 2.0 and above.</p>
    pub fn idle_time_between_reads_in_ms(&self) -> ::std::option::Option<i64> {
        self.idle_time_between_reads_in_ms
    }
    /// <p>The minimum time interval between two ListShards API calls for your script to consider resharding. The default value is <code>1s</code>.</p>
    pub fn describe_shard_interval(&self) -> ::std::option::Option<i64> {
        self.describe_shard_interval
    }
    /// <p>The maximum number of retries for Kinesis Data Streams API requests. The default value is <code>3</code>.</p>
    pub fn num_retries(&self) -> ::std::option::Option<i32> {
        self.num_retries
    }
    /// <p>The cool-off time period (specified in ms) before retrying the Kinesis Data Streams API call. The default value is <code>1000</code>.</p>
    pub fn retry_interval_ms(&self) -> ::std::option::Option<i64> {
        self.retry_interval_ms
    }
    /// <p>The maximum cool-off time period (specified in ms) between two retries of a Kinesis Data Streams API call. The default value is <code>10000</code>.</p>
    pub fn max_retry_interval_ms(&self) -> ::std::option::Option<i64> {
        self.max_retry_interval_ms
    }
    /// <p>Avoids creating an empty microbatch job by checking for unread data in the Kinesis data stream before the batch is started. The default value is <code>"False"</code>.</p>
    pub fn avoid_empty_batches(&self) -> ::std::option::Option<bool> {
        self.avoid_empty_batches
    }
    /// <p>The Amazon Resource Name (ARN) of the Kinesis data stream.</p>
    pub fn stream_arn(&self) -> ::std::option::Option<&str> {
        self.stream_arn.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the role to assume using AWS Security Token Service (AWS STS). This role must have permissions for describe or read record operations for the Kinesis data stream. You must use this parameter when accessing a data stream in a different account. Used in conjunction with <code>"awsSTSSessionName"</code>.</p>
    pub fn role_arn(&self) -> ::std::option::Option<&str> {
        self.role_arn.as_deref()
    }
    /// <p>An identifier for the session assuming the role using AWS STS. You must use this parameter when accessing a data stream in a different account. Used in conjunction with <code>"awsSTSRoleARN"</code>.</p>
    pub fn role_session_name(&self) -> ::std::option::Option<&str> {
        self.role_session_name.as_deref()
    }
    /// <p>When this option is set to 'true', the data output will contain an additional column named "__src_timestamp" that indicates the time when the corresponding record received by the stream. The default value is 'false'. This option is supported in Glue version 4.0 or later.</p>
    pub fn add_record_timestamp(&self) -> ::std::option::Option<&str> {
        self.add_record_timestamp.as_deref()
    }
    /// <p>When this option is set to 'true', for each batch, it will emit the metrics for the duration between the oldest record received by the stream and the time it arrives in Glue to CloudWatch. The metric's name is "glue.driver.streaming.maxConsumerLagInMs". The default value is 'false'. This option is supported in Glue version 4.0 or later.</p>
    pub fn emit_consumer_lag_metrics(&self) -> ::std::option::Option<&str> {
        self.emit_consumer_lag_metrics.as_deref()
    }
    /// <p>The timestamp of the record in the Kinesis data stream to start reading data from. The possible values are a timestamp string in UTC format of the pattern <code>yyyy-mm-ddTHH:MM:SSZ</code> (where Z represents a UTC timezone offset with a +/-. For example: "2023-04-04T08:00:00+08:00").</p>
    pub fn starting_timestamp(&self) -> ::std::option::Option<&::aws_smithy_types::DateTime> {
        self.starting_timestamp.as_ref()
    }
}
impl KinesisStreamingSourceOptions {
    /// Creates a new builder-style object to manufacture [`KinesisStreamingSourceOptions`](crate::types::KinesisStreamingSourceOptions).
    pub fn builder() -> crate::types::builders::KinesisStreamingSourceOptionsBuilder {
        crate::types::builders::KinesisStreamingSourceOptionsBuilder::default()
    }
}

/// A builder for [`KinesisStreamingSourceOptions`](crate::types::KinesisStreamingSourceOptions).
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
pub struct KinesisStreamingSourceOptionsBuilder {
    pub(crate) endpoint_url: ::std::option::Option<::std::string::String>,
    pub(crate) stream_name: ::std::option::Option<::std::string::String>,
    pub(crate) classification: ::std::option::Option<::std::string::String>,
    pub(crate) delimiter: ::std::option::Option<::std::string::String>,
    pub(crate) starting_position: ::std::option::Option<crate::types::StartingPosition>,
    pub(crate) max_fetch_time_in_ms: ::std::option::Option<i64>,
    pub(crate) max_fetch_records_per_shard: ::std::option::Option<i64>,
    pub(crate) max_record_per_read: ::std::option::Option<i64>,
    pub(crate) add_idle_time_between_reads: ::std::option::Option<bool>,
    pub(crate) idle_time_between_reads_in_ms: ::std::option::Option<i64>,
    pub(crate) describe_shard_interval: ::std::option::Option<i64>,
    pub(crate) num_retries: ::std::option::Option<i32>,
    pub(crate) retry_interval_ms: ::std::option::Option<i64>,
    pub(crate) max_retry_interval_ms: ::std::option::Option<i64>,
    pub(crate) avoid_empty_batches: ::std::option::Option<bool>,
    pub(crate) stream_arn: ::std::option::Option<::std::string::String>,
    pub(crate) role_arn: ::std::option::Option<::std::string::String>,
    pub(crate) role_session_name: ::std::option::Option<::std::string::String>,
    pub(crate) add_record_timestamp: ::std::option::Option<::std::string::String>,
    pub(crate) emit_consumer_lag_metrics: ::std::option::Option<::std::string::String>,
    pub(crate) starting_timestamp: ::std::option::Option<::aws_smithy_types::DateTime>,
}
impl KinesisStreamingSourceOptionsBuilder {
    /// <p>The URL of the Kinesis endpoint.</p>
    pub fn endpoint_url(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.endpoint_url = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The URL of the Kinesis endpoint.</p>
    pub fn set_endpoint_url(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.endpoint_url = input;
        self
    }
    /// <p>The URL of the Kinesis endpoint.</p>
    pub fn get_endpoint_url(&self) -> &::std::option::Option<::std::string::String> {
        &self.endpoint_url
    }
    /// <p>The name of the Kinesis data stream.</p>
    pub fn stream_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.stream_name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The name of the Kinesis data stream.</p>
    pub fn set_stream_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.stream_name = input;
        self
    }
    /// <p>The name of the Kinesis data stream.</p>
    pub fn get_stream_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.stream_name
    }
    /// <p>An optional classification.</p>
    pub fn classification(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.classification = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>An optional classification.</p>
    pub fn set_classification(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.classification = input;
        self
    }
    /// <p>An optional classification.</p>
    pub fn get_classification(&self) -> &::std::option::Option<::std::string::String> {
        &self.classification
    }
    /// <p>Specifies the delimiter character.</p>
    pub fn delimiter(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.delimiter = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>Specifies the delimiter character.</p>
    pub fn set_delimiter(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.delimiter = input;
        self
    }
    /// <p>Specifies the delimiter character.</p>
    pub fn get_delimiter(&self) -> &::std::option::Option<::std::string::String> {
        &self.delimiter
    }
    /// <p>The starting position in the Kinesis data stream to read data from. The possible values are <code>"latest"</code>, <code>"trim_horizon"</code>, <code>"earliest"</code>, or a timestamp string in UTC format in the pattern <code>yyyy-mm-ddTHH:MM:SSZ</code> (where <code>Z</code> represents a UTC timezone offset with a +/-. For example: "2023-04-04T08:00:00-04:00"). The default value is <code>"latest"</code>.</p>
    /// <p>Note: Using a value that is a timestamp string in UTC format for "startingPosition" is supported only for Glue version 4.0 or later.</p>
    pub fn starting_position(mut self, input: crate::types::StartingPosition) -> Self {
        self.starting_position = ::std::option::Option::Some(input);
        self
    }
    /// <p>The starting position in the Kinesis data stream to read data from. The possible values are <code>"latest"</code>, <code>"trim_horizon"</code>, <code>"earliest"</code>, or a timestamp string in UTC format in the pattern <code>yyyy-mm-ddTHH:MM:SSZ</code> (where <code>Z</code> represents a UTC timezone offset with a +/-. For example: "2023-04-04T08:00:00-04:00"). The default value is <code>"latest"</code>.</p>
    /// <p>Note: Using a value that is a timestamp string in UTC format for "startingPosition" is supported only for Glue version 4.0 or later.</p>
    pub fn set_starting_position(mut self, input: ::std::option::Option<crate::types::StartingPosition>) -> Self {
        self.starting_position = input;
        self
    }
    /// <p>The starting position in the Kinesis data stream to read data from. The possible values are <code>"latest"</code>, <code>"trim_horizon"</code>, <code>"earliest"</code>, or a timestamp string in UTC format in the pattern <code>yyyy-mm-ddTHH:MM:SSZ</code> (where <code>Z</code> represents a UTC timezone offset with a +/-. For example: "2023-04-04T08:00:00-04:00"). The default value is <code>"latest"</code>.</p>
    /// <p>Note: Using a value that is a timestamp string in UTC format for "startingPosition" is supported only for Glue version 4.0 or later.</p>
    pub fn get_starting_position(&self) -> &::std::option::Option<crate::types::StartingPosition> {
        &self.starting_position
    }
    /// <p>The maximum time spent in the job executor to fetch a record from the Kinesis data stream per shard, specified in milliseconds (ms). The default value is <code>1000</code>.</p>
    pub fn max_fetch_time_in_ms(mut self, input: i64) -> Self {
        self.max_fetch_time_in_ms = ::std::option::Option::Some(input);
        self
    }
    /// <p>The maximum time spent in the job executor to fetch a record from the Kinesis data stream per shard, specified in milliseconds (ms). The default value is <code>1000</code>.</p>
    pub fn set_max_fetch_time_in_ms(mut self, input: ::std::option::Option<i64>) -> Self {
        self.max_fetch_time_in_ms = input;
        self
    }
    /// <p>The maximum time spent in the job executor to fetch a record from the Kinesis data stream per shard, specified in milliseconds (ms). The default value is <code>1000</code>.</p>
    pub fn get_max_fetch_time_in_ms(&self) -> &::std::option::Option<i64> {
        &self.max_fetch_time_in_ms
    }
    /// <p>The maximum number of records to fetch per shard in the Kinesis data stream. The default value is <code>100000</code>.</p>
    pub fn max_fetch_records_per_shard(mut self, input: i64) -> Self {
        self.max_fetch_records_per_shard = ::std::option::Option::Some(input);
        self
    }
    /// <p>The maximum number of records to fetch per shard in the Kinesis data stream. The default value is <code>100000</code>.</p>
    pub fn set_max_fetch_records_per_shard(mut self, input: ::std::option::Option<i64>) -> Self {
        self.max_fetch_records_per_shard = input;
        self
    }
    /// <p>The maximum number of records to fetch per shard in the Kinesis data stream. The default value is <code>100000</code>.</p>
    pub fn get_max_fetch_records_per_shard(&self) -> &::std::option::Option<i64> {
        &self.max_fetch_records_per_shard
    }
    /// <p>The maximum number of records to fetch from the Kinesis data stream in each getRecords operation. The default value is <code>10000</code>.</p>
    pub fn max_record_per_read(mut self, input: i64) -> Self {
        self.max_record_per_read = ::std::option::Option::Some(input);
        self
    }
    /// <p>The maximum number of records to fetch from the Kinesis data stream in each getRecords operation. The default value is <code>10000</code>.</p>
    pub fn set_max_record_per_read(mut self, input: ::std::option::Option<i64>) -> Self {
        self.max_record_per_read = input;
        self
    }
    /// <p>The maximum number of records to fetch from the Kinesis data stream in each getRecords operation. The default value is <code>10000</code>.</p>
    pub fn get_max_record_per_read(&self) -> &::std::option::Option<i64> {
        &self.max_record_per_read
    }
    /// <p>Adds a time delay between two consecutive getRecords operations. The default value is <code>"False"</code>. This option is only configurable for Glue version 2.0 and above.</p>
    pub fn add_idle_time_between_reads(mut self, input: bool) -> Self {
        self.add_idle_time_between_reads = ::std::option::Option::Some(input);
        self
    }
    /// <p>Adds a time delay between two consecutive getRecords operations. The default value is <code>"False"</code>. This option is only configurable for Glue version 2.0 and above.</p>
    pub fn set_add_idle_time_between_reads(mut self, input: ::std::option::Option<bool>) -> Self {
        self.add_idle_time_between_reads = input;
        self
    }
    /// <p>Adds a time delay between two consecutive getRecords operations. The default value is <code>"False"</code>. This option is only configurable for Glue version 2.0 and above.</p>
    pub fn get_add_idle_time_between_reads(&self) -> &::std::option::Option<bool> {
        &self.add_idle_time_between_reads
    }
    /// <p>The minimum time delay between two consecutive getRecords operations, specified in ms. The default value is <code>1000</code>. This option is only configurable for Glue version 2.0 and above.</p>
    pub fn idle_time_between_reads_in_ms(mut self, input: i64) -> Self {
        self.idle_time_between_reads_in_ms = ::std::option::Option::Some(input);
        self
    }
    /// <p>The minimum time delay between two consecutive getRecords operations, specified in ms. The default value is <code>1000</code>. This option is only configurable for Glue version 2.0 and above.</p>
    pub fn set_idle_time_between_reads_in_ms(mut self, input: ::std::option::Option<i64>) -> Self {
        self.idle_time_between_reads_in_ms = input;
        self
    }
    /// <p>The minimum time delay between two consecutive getRecords operations, specified in ms. The default value is <code>1000</code>. This option is only configurable for Glue version 2.0 and above.</p>
    pub fn get_idle_time_between_reads_in_ms(&self) -> &::std::option::Option<i64> {
        &self.idle_time_between_reads_in_ms
    }
    /// <p>The minimum time interval between two ListShards API calls for your script to consider resharding. The default value is <code>1s</code>.</p>
    pub fn describe_shard_interval(mut self, input: i64) -> Self {
        self.describe_shard_interval = ::std::option::Option::Some(input);
        self
    }
    /// <p>The minimum time interval between two ListShards API calls for your script to consider resharding. The default value is <code>1s</code>.</p>
    pub fn set_describe_shard_interval(mut self, input: ::std::option::Option<i64>) -> Self {
        self.describe_shard_interval = input;
        self
    }
    /// <p>The minimum time interval between two ListShards API calls for your script to consider resharding. The default value is <code>1s</code>.</p>
    pub fn get_describe_shard_interval(&self) -> &::std::option::Option<i64> {
        &self.describe_shard_interval
    }
    /// <p>The maximum number of retries for Kinesis Data Streams API requests. The default value is <code>3</code>.</p>
    pub fn num_retries(mut self, input: i32) -> Self {
        self.num_retries = ::std::option::Option::Some(input);
        self
    }
    /// <p>The maximum number of retries for Kinesis Data Streams API requests. The default value is <code>3</code>.</p>
    pub fn set_num_retries(mut self, input: ::std::option::Option<i32>) -> Self {
        self.num_retries = input;
        self
    }
    /// <p>The maximum number of retries for Kinesis Data Streams API requests. The default value is <code>3</code>.</p>
    pub fn get_num_retries(&self) -> &::std::option::Option<i32> {
        &self.num_retries
    }
    /// <p>The cool-off time period (specified in ms) before retrying the Kinesis Data Streams API call. The default value is <code>1000</code>.</p>
    pub fn retry_interval_ms(mut self, input: i64) -> Self {
        self.retry_interval_ms = ::std::option::Option::Some(input);
        self
    }
    /// <p>The cool-off time period (specified in ms) before retrying the Kinesis Data Streams API call. The default value is <code>1000</code>.</p>
    pub fn set_retry_interval_ms(mut self, input: ::std::option::Option<i64>) -> Self {
        self.retry_interval_ms = input;
        self
    }
    /// <p>The cool-off time period (specified in ms) before retrying the Kinesis Data Streams API call. The default value is <code>1000</code>.</p>
    pub fn get_retry_interval_ms(&self) -> &::std::option::Option<i64> {
        &self.retry_interval_ms
    }
    /// <p>The maximum cool-off time period (specified in ms) between two retries of a Kinesis Data Streams API call. The default value is <code>10000</code>.</p>
    pub fn max_retry_interval_ms(mut self, input: i64) -> Self {
        self.max_retry_interval_ms = ::std::option::Option::Some(input);
        self
    }
    /// <p>The maximum cool-off time period (specified in ms) between two retries of a Kinesis Data Streams API call. The default value is <code>10000</code>.</p>
    pub fn set_max_retry_interval_ms(mut self, input: ::std::option::Option<i64>) -> Self {
        self.max_retry_interval_ms = input;
        self
    }
    /// <p>The maximum cool-off time period (specified in ms) between two retries of a Kinesis Data Streams API call. The default value is <code>10000</code>.</p>
    pub fn get_max_retry_interval_ms(&self) -> &::std::option::Option<i64> {
        &self.max_retry_interval_ms
    }
    /// <p>Avoids creating an empty microbatch job by checking for unread data in the Kinesis data stream before the batch is started. The default value is <code>"False"</code>.</p>
    pub fn avoid_empty_batches(mut self, input: bool) -> Self {
        self.avoid_empty_batches = ::std::option::Option::Some(input);
        self
    }
    /// <p>Avoids creating an empty microbatch job by checking for unread data in the Kinesis data stream before the batch is started. The default value is <code>"False"</code>.</p>
    pub fn set_avoid_empty_batches(mut self, input: ::std::option::Option<bool>) -> Self {
        self.avoid_empty_batches = input;
        self
    }
    /// <p>Avoids creating an empty microbatch job by checking for unread data in the Kinesis data stream before the batch is started. The default value is <code>"False"</code>.</p>
    pub fn get_avoid_empty_batches(&self) -> &::std::option::Option<bool> {
        &self.avoid_empty_batches
    }
    /// <p>The Amazon Resource Name (ARN) of the Kinesis data stream.</p>
    pub fn stream_arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.stream_arn = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the Kinesis data stream.</p>
    pub fn set_stream_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.stream_arn = input;
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the Kinesis data stream.</p>
    pub fn get_stream_arn(&self) -> &::std::option::Option<::std::string::String> {
        &self.stream_arn
    }
    /// <p>The Amazon Resource Name (ARN) of the role to assume using AWS Security Token Service (AWS STS). This role must have permissions for describe or read record operations for the Kinesis data stream. You must use this parameter when accessing a data stream in a different account. Used in conjunction with <code>"awsSTSSessionName"</code>.</p>
    pub fn role_arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.role_arn = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the role to assume using AWS Security Token Service (AWS STS). This role must have permissions for describe or read record operations for the Kinesis data stream. You must use this parameter when accessing a data stream in a different account. Used in conjunction with <code>"awsSTSSessionName"</code>.</p>
    pub fn set_role_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.role_arn = input;
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the role to assume using AWS Security Token Service (AWS STS). This role must have permissions for describe or read record operations for the Kinesis data stream. You must use this parameter when accessing a data stream in a different account. Used in conjunction with <code>"awsSTSSessionName"</code>.</p>
    pub fn get_role_arn(&self) -> &::std::option::Option<::std::string::String> {
        &self.role_arn
    }
    /// <p>An identifier for the session assuming the role using AWS STS. You must use this parameter when accessing a data stream in a different account. Used in conjunction with <code>"awsSTSRoleARN"</code>.</p>
    pub fn role_session_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.role_session_name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>An identifier for the session assuming the role using AWS STS. You must use this parameter when accessing a data stream in a different account. Used in conjunction with <code>"awsSTSRoleARN"</code>.</p>
    pub fn set_role_session_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.role_session_name = input;
        self
    }
    /// <p>An identifier for the session assuming the role using AWS STS. You must use this parameter when accessing a data stream in a different account. Used in conjunction with <code>"awsSTSRoleARN"</code>.</p>
    pub fn get_role_session_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.role_session_name
    }
    /// <p>When this option is set to 'true', the data output will contain an additional column named "__src_timestamp" that indicates the time when the corresponding record received by the stream. The default value is 'false'. This option is supported in Glue version 4.0 or later.</p>
    pub fn add_record_timestamp(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.add_record_timestamp = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>When this option is set to 'true', the data output will contain an additional column named "__src_timestamp" that indicates the time when the corresponding record received by the stream. The default value is 'false'. This option is supported in Glue version 4.0 or later.</p>
    pub fn set_add_record_timestamp(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.add_record_timestamp = input;
        self
    }
    /// <p>When this option is set to 'true', the data output will contain an additional column named "__src_timestamp" that indicates the time when the corresponding record received by the stream. The default value is 'false'. This option is supported in Glue version 4.0 or later.</p>
    pub fn get_add_record_timestamp(&self) -> &::std::option::Option<::std::string::String> {
        &self.add_record_timestamp
    }
    /// <p>When this option is set to 'true', for each batch, it will emit the metrics for the duration between the oldest record received by the stream and the time it arrives in Glue to CloudWatch. The metric's name is "glue.driver.streaming.maxConsumerLagInMs". The default value is 'false'. This option is supported in Glue version 4.0 or later.</p>
    pub fn emit_consumer_lag_metrics(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.emit_consumer_lag_metrics = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>When this option is set to 'true', for each batch, it will emit the metrics for the duration between the oldest record received by the stream and the time it arrives in Glue to CloudWatch. The metric's name is "glue.driver.streaming.maxConsumerLagInMs". The default value is 'false'. This option is supported in Glue version 4.0 or later.</p>
    pub fn set_emit_consumer_lag_metrics(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.emit_consumer_lag_metrics = input;
        self
    }
    /// <p>When this option is set to 'true', for each batch, it will emit the metrics for the duration between the oldest record received by the stream and the time it arrives in Glue to CloudWatch. The metric's name is "glue.driver.streaming.maxConsumerLagInMs". The default value is 'false'. This option is supported in Glue version 4.0 or later.</p>
    pub fn get_emit_consumer_lag_metrics(&self) -> &::std::option::Option<::std::string::String> {
        &self.emit_consumer_lag_metrics
    }
    /// <p>The timestamp of the record in the Kinesis data stream to start reading data from. The possible values are a timestamp string in UTC format of the pattern <code>yyyy-mm-ddTHH:MM:SSZ</code> (where Z represents a UTC timezone offset with a +/-. For example: "2023-04-04T08:00:00+08:00").</p>
    pub fn starting_timestamp(mut self, input: ::aws_smithy_types::DateTime) -> Self {
        self.starting_timestamp = ::std::option::Option::Some(input);
        self
    }
    /// <p>The timestamp of the record in the Kinesis data stream to start reading data from. The possible values are a timestamp string in UTC format of the pattern <code>yyyy-mm-ddTHH:MM:SSZ</code> (where Z represents a UTC timezone offset with a +/-. For example: "2023-04-04T08:00:00+08:00").</p>
    pub fn set_starting_timestamp(mut self, input: ::std::option::Option<::aws_smithy_types::DateTime>) -> Self {
        self.starting_timestamp = input;
        self
    }
    /// <p>The timestamp of the record in the Kinesis data stream to start reading data from. The possible values are a timestamp string in UTC format of the pattern <code>yyyy-mm-ddTHH:MM:SSZ</code> (where Z represents a UTC timezone offset with a +/-. For example: "2023-04-04T08:00:00+08:00").</p>
    pub fn get_starting_timestamp(&self) -> &::std::option::Option<::aws_smithy_types::DateTime> {
        &self.starting_timestamp
    }
    /// Consumes the builder and constructs a [`KinesisStreamingSourceOptions`](crate::types::KinesisStreamingSourceOptions).
    pub fn build(self) -> crate::types::KinesisStreamingSourceOptions {
        crate::types::KinesisStreamingSourceOptions {
            endpoint_url: self.endpoint_url,
            stream_name: self.stream_name,
            classification: self.classification,
            delimiter: self.delimiter,
            starting_position: self.starting_position,
            max_fetch_time_in_ms: self.max_fetch_time_in_ms,
            max_fetch_records_per_shard: self.max_fetch_records_per_shard,
            max_record_per_read: self.max_record_per_read,
            add_idle_time_between_reads: self.add_idle_time_between_reads,
            idle_time_between_reads_in_ms: self.idle_time_between_reads_in_ms,
            describe_shard_interval: self.describe_shard_interval,
            num_retries: self.num_retries,
            retry_interval_ms: self.retry_interval_ms,
            max_retry_interval_ms: self.max_retry_interval_ms,
            avoid_empty_batches: self.avoid_empty_batches,
            stream_arn: self.stream_arn,
            role_arn: self.role_arn,
            role_session_name: self.role_session_name,
            add_record_timestamp: self.add_record_timestamp,
            emit_consumer_lag_metrics: self.emit_consumer_lag_metrics,
            starting_timestamp: self.starting_timestamp,
        }
    }
}
