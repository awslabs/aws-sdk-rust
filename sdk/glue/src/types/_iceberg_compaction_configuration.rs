// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>The configuration for an Iceberg compaction optimizer. This configuration defines parameters for optimizing the layout of data files in Iceberg tables.</p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct IcebergCompactionConfiguration {
    /// <p>The strategy to use for compaction. Valid values are:</p>
    /// <ul>
    /// <li>
    /// <p><code>binpack</code>: Combines small files into larger files, typically targeting sizes over 100MB, while applying any pending deletes. This is the recommended compaction strategy for most use cases.</p></li>
    /// <li>
    /// <p><code>sort</code>: Organizes data based on specified columns which are sorted hierarchically during compaction, improving query performance for filtered operations. This strategy is recommended when your queries frequently filter on specific columns. To use this strategy, you must first define a sort order in your Iceberg table properties using the <code>sort_order</code> table property.</p></li>
    /// <li>
    /// <p><code>z-order</code>: Optimizes data organization by blending multiple attributes into a single scalar value that can be used for sorting, allowing efficient querying across multiple dimensions. This strategy is recommended when you need to query data across multiple dimensions simultaneously. To use this strategy, you must first define a sort order in your Iceberg table properties using the <code>sort_order</code> table property.</p></li>
    /// </ul>
    /// <p>If an input is not provided, the default value 'binpack' will be used.</p>
    pub strategy: ::std::option::Option<crate::types::CompactionStrategy>,
    /// <p>The minimum number of data files that must be present in a partition before compaction will actually compact files. This parameter helps control when compaction is triggered, preventing unnecessary compaction operations on partitions with few files. If an input is not provided, the default value 100 will be used.</p>
    pub min_input_files: ::std::option::Option<i32>,
    /// <p>The minimum number of deletes that must be present in a data file to make it eligible for compaction. This parameter helps optimize compaction by focusing on files that contain a significant number of delete operations, which can improve query performance by removing deleted records. If an input is not provided, the default value 1 will be used.</p>
    pub delete_file_threshold: ::std::option::Option<i32>,
}
impl IcebergCompactionConfiguration {
    /// <p>The strategy to use for compaction. Valid values are:</p>
    /// <ul>
    /// <li>
    /// <p><code>binpack</code>: Combines small files into larger files, typically targeting sizes over 100MB, while applying any pending deletes. This is the recommended compaction strategy for most use cases.</p></li>
    /// <li>
    /// <p><code>sort</code>: Organizes data based on specified columns which are sorted hierarchically during compaction, improving query performance for filtered operations. This strategy is recommended when your queries frequently filter on specific columns. To use this strategy, you must first define a sort order in your Iceberg table properties using the <code>sort_order</code> table property.</p></li>
    /// <li>
    /// <p><code>z-order</code>: Optimizes data organization by blending multiple attributes into a single scalar value that can be used for sorting, allowing efficient querying across multiple dimensions. This strategy is recommended when you need to query data across multiple dimensions simultaneously. To use this strategy, you must first define a sort order in your Iceberg table properties using the <code>sort_order</code> table property.</p></li>
    /// </ul>
    /// <p>If an input is not provided, the default value 'binpack' will be used.</p>
    pub fn strategy(&self) -> ::std::option::Option<&crate::types::CompactionStrategy> {
        self.strategy.as_ref()
    }
    /// <p>The minimum number of data files that must be present in a partition before compaction will actually compact files. This parameter helps control when compaction is triggered, preventing unnecessary compaction operations on partitions with few files. If an input is not provided, the default value 100 will be used.</p>
    pub fn min_input_files(&self) -> ::std::option::Option<i32> {
        self.min_input_files
    }
    /// <p>The minimum number of deletes that must be present in a data file to make it eligible for compaction. This parameter helps optimize compaction by focusing on files that contain a significant number of delete operations, which can improve query performance by removing deleted records. If an input is not provided, the default value 1 will be used.</p>
    pub fn delete_file_threshold(&self) -> ::std::option::Option<i32> {
        self.delete_file_threshold
    }
}
impl IcebergCompactionConfiguration {
    /// Creates a new builder-style object to manufacture [`IcebergCompactionConfiguration`](crate::types::IcebergCompactionConfiguration).
    pub fn builder() -> crate::types::builders::IcebergCompactionConfigurationBuilder {
        crate::types::builders::IcebergCompactionConfigurationBuilder::default()
    }
}

/// A builder for [`IcebergCompactionConfiguration`](crate::types::IcebergCompactionConfiguration).
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
#[non_exhaustive]
pub struct IcebergCompactionConfigurationBuilder {
    pub(crate) strategy: ::std::option::Option<crate::types::CompactionStrategy>,
    pub(crate) min_input_files: ::std::option::Option<i32>,
    pub(crate) delete_file_threshold: ::std::option::Option<i32>,
}
impl IcebergCompactionConfigurationBuilder {
    /// <p>The strategy to use for compaction. Valid values are:</p>
    /// <ul>
    /// <li>
    /// <p><code>binpack</code>: Combines small files into larger files, typically targeting sizes over 100MB, while applying any pending deletes. This is the recommended compaction strategy for most use cases.</p></li>
    /// <li>
    /// <p><code>sort</code>: Organizes data based on specified columns which are sorted hierarchically during compaction, improving query performance for filtered operations. This strategy is recommended when your queries frequently filter on specific columns. To use this strategy, you must first define a sort order in your Iceberg table properties using the <code>sort_order</code> table property.</p></li>
    /// <li>
    /// <p><code>z-order</code>: Optimizes data organization by blending multiple attributes into a single scalar value that can be used for sorting, allowing efficient querying across multiple dimensions. This strategy is recommended when you need to query data across multiple dimensions simultaneously. To use this strategy, you must first define a sort order in your Iceberg table properties using the <code>sort_order</code> table property.</p></li>
    /// </ul>
    /// <p>If an input is not provided, the default value 'binpack' will be used.</p>
    pub fn strategy(mut self, input: crate::types::CompactionStrategy) -> Self {
        self.strategy = ::std::option::Option::Some(input);
        self
    }
    /// <p>The strategy to use for compaction. Valid values are:</p>
    /// <ul>
    /// <li>
    /// <p><code>binpack</code>: Combines small files into larger files, typically targeting sizes over 100MB, while applying any pending deletes. This is the recommended compaction strategy for most use cases.</p></li>
    /// <li>
    /// <p><code>sort</code>: Organizes data based on specified columns which are sorted hierarchically during compaction, improving query performance for filtered operations. This strategy is recommended when your queries frequently filter on specific columns. To use this strategy, you must first define a sort order in your Iceberg table properties using the <code>sort_order</code> table property.</p></li>
    /// <li>
    /// <p><code>z-order</code>: Optimizes data organization by blending multiple attributes into a single scalar value that can be used for sorting, allowing efficient querying across multiple dimensions. This strategy is recommended when you need to query data across multiple dimensions simultaneously. To use this strategy, you must first define a sort order in your Iceberg table properties using the <code>sort_order</code> table property.</p></li>
    /// </ul>
    /// <p>If an input is not provided, the default value 'binpack' will be used.</p>
    pub fn set_strategy(mut self, input: ::std::option::Option<crate::types::CompactionStrategy>) -> Self {
        self.strategy = input;
        self
    }
    /// <p>The strategy to use for compaction. Valid values are:</p>
    /// <ul>
    /// <li>
    /// <p><code>binpack</code>: Combines small files into larger files, typically targeting sizes over 100MB, while applying any pending deletes. This is the recommended compaction strategy for most use cases.</p></li>
    /// <li>
    /// <p><code>sort</code>: Organizes data based on specified columns which are sorted hierarchically during compaction, improving query performance for filtered operations. This strategy is recommended when your queries frequently filter on specific columns. To use this strategy, you must first define a sort order in your Iceberg table properties using the <code>sort_order</code> table property.</p></li>
    /// <li>
    /// <p><code>z-order</code>: Optimizes data organization by blending multiple attributes into a single scalar value that can be used for sorting, allowing efficient querying across multiple dimensions. This strategy is recommended when you need to query data across multiple dimensions simultaneously. To use this strategy, you must first define a sort order in your Iceberg table properties using the <code>sort_order</code> table property.</p></li>
    /// </ul>
    /// <p>If an input is not provided, the default value 'binpack' will be used.</p>
    pub fn get_strategy(&self) -> &::std::option::Option<crate::types::CompactionStrategy> {
        &self.strategy
    }
    /// <p>The minimum number of data files that must be present in a partition before compaction will actually compact files. This parameter helps control when compaction is triggered, preventing unnecessary compaction operations on partitions with few files. If an input is not provided, the default value 100 will be used.</p>
    pub fn min_input_files(mut self, input: i32) -> Self {
        self.min_input_files = ::std::option::Option::Some(input);
        self
    }
    /// <p>The minimum number of data files that must be present in a partition before compaction will actually compact files. This parameter helps control when compaction is triggered, preventing unnecessary compaction operations on partitions with few files. If an input is not provided, the default value 100 will be used.</p>
    pub fn set_min_input_files(mut self, input: ::std::option::Option<i32>) -> Self {
        self.min_input_files = input;
        self
    }
    /// <p>The minimum number of data files that must be present in a partition before compaction will actually compact files. This parameter helps control when compaction is triggered, preventing unnecessary compaction operations on partitions with few files. If an input is not provided, the default value 100 will be used.</p>
    pub fn get_min_input_files(&self) -> &::std::option::Option<i32> {
        &self.min_input_files
    }
    /// <p>The minimum number of deletes that must be present in a data file to make it eligible for compaction. This parameter helps optimize compaction by focusing on files that contain a significant number of delete operations, which can improve query performance by removing deleted records. If an input is not provided, the default value 1 will be used.</p>
    pub fn delete_file_threshold(mut self, input: i32) -> Self {
        self.delete_file_threshold = ::std::option::Option::Some(input);
        self
    }
    /// <p>The minimum number of deletes that must be present in a data file to make it eligible for compaction. This parameter helps optimize compaction by focusing on files that contain a significant number of delete operations, which can improve query performance by removing deleted records. If an input is not provided, the default value 1 will be used.</p>
    pub fn set_delete_file_threshold(mut self, input: ::std::option::Option<i32>) -> Self {
        self.delete_file_threshold = input;
        self
    }
    /// <p>The minimum number of deletes that must be present in a data file to make it eligible for compaction. This parameter helps optimize compaction by focusing on files that contain a significant number of delete operations, which can improve query performance by removing deleted records. If an input is not provided, the default value 1 will be used.</p>
    pub fn get_delete_file_threshold(&self) -> &::std::option::Option<i32> {
        &self.delete_file_threshold
    }
    /// Consumes the builder and constructs a [`IcebergCompactionConfiguration`](crate::types::IcebergCompactionConfiguration).
    pub fn build(self) -> crate::types::IcebergCompactionConfiguration {
        crate::types::IcebergCompactionConfiguration {
            strategy: self.strategy,
            min_input_files: self.min_input_files,
            delete_file_threshold: self.delete_file_threshold,
        }
    }
}
