// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// When writing a match expression against `JdbcDataType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let jdbcdatatype = unimplemented!();
/// match jdbcdatatype {
///     JdbcDataType::Array => { /* ... */ },
///     JdbcDataType::Bigint => { /* ... */ },
///     JdbcDataType::Binary => { /* ... */ },
///     JdbcDataType::Bit => { /* ... */ },
///     JdbcDataType::Blob => { /* ... */ },
///     JdbcDataType::Boolean => { /* ... */ },
///     JdbcDataType::Char => { /* ... */ },
///     JdbcDataType::Clob => { /* ... */ },
///     JdbcDataType::Datalink => { /* ... */ },
///     JdbcDataType::Date => { /* ... */ },
///     JdbcDataType::Decimal => { /* ... */ },
///     JdbcDataType::Distinct => { /* ... */ },
///     JdbcDataType::Double => { /* ... */ },
///     JdbcDataType::Float => { /* ... */ },
///     JdbcDataType::Integer => { /* ... */ },
///     JdbcDataType::JavaObject => { /* ... */ },
///     JdbcDataType::Longnvarchar => { /* ... */ },
///     JdbcDataType::Longvarbinary => { /* ... */ },
///     JdbcDataType::Longvarchar => { /* ... */ },
///     JdbcDataType::Nchar => { /* ... */ },
///     JdbcDataType::Nclob => { /* ... */ },
///     JdbcDataType::Null => { /* ... */ },
///     JdbcDataType::Numeric => { /* ... */ },
///     JdbcDataType::Nvarchar => { /* ... */ },
///     JdbcDataType::Other => { /* ... */ },
///     JdbcDataType::Real => { /* ... */ },
///     JdbcDataType::Ref => { /* ... */ },
///     JdbcDataType::RefCursor => { /* ... */ },
///     JdbcDataType::Rowid => { /* ... */ },
///     JdbcDataType::Smallint => { /* ... */ },
///     JdbcDataType::Sqlxml => { /* ... */ },
///     JdbcDataType::Struct => { /* ... */ },
///     JdbcDataType::Time => { /* ... */ },
///     JdbcDataType::Timestamp => { /* ... */ },
///     JdbcDataType::TimestampWithTimezone => { /* ... */ },
///     JdbcDataType::TimeWithTimezone => { /* ... */ },
///     JdbcDataType::Tinyint => { /* ... */ },
///     JdbcDataType::Varbinary => { /* ... */ },
///     JdbcDataType::Varchar => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `jdbcdatatype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `JdbcDataType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `JdbcDataType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `JdbcDataType::NewFeature` is defined.
/// Specifically, when `jdbcdatatype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `JdbcDataType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum JdbcDataType {
    #[allow(missing_docs)] // documentation missing in model
    Array,
    #[allow(missing_docs)] // documentation missing in model
    Bigint,
    #[allow(missing_docs)] // documentation missing in model
    Binary,
    #[allow(missing_docs)] // documentation missing in model
    Bit,
    #[allow(missing_docs)] // documentation missing in model
    Blob,
    #[allow(missing_docs)] // documentation missing in model
    Boolean,
    #[allow(missing_docs)] // documentation missing in model
    Char,
    #[allow(missing_docs)] // documentation missing in model
    Clob,
    #[allow(missing_docs)] // documentation missing in model
    Datalink,
    #[allow(missing_docs)] // documentation missing in model
    Date,
    #[allow(missing_docs)] // documentation missing in model
    Decimal,
    #[allow(missing_docs)] // documentation missing in model
    Distinct,
    #[allow(missing_docs)] // documentation missing in model
    Double,
    #[allow(missing_docs)] // documentation missing in model
    Float,
    #[allow(missing_docs)] // documentation missing in model
    Integer,
    #[allow(missing_docs)] // documentation missing in model
    JavaObject,
    #[allow(missing_docs)] // documentation missing in model
    Longnvarchar,
    #[allow(missing_docs)] // documentation missing in model
    Longvarbinary,
    #[allow(missing_docs)] // documentation missing in model
    Longvarchar,
    #[allow(missing_docs)] // documentation missing in model
    Nchar,
    #[allow(missing_docs)] // documentation missing in model
    Nclob,
    #[allow(missing_docs)] // documentation missing in model
    Null,
    #[allow(missing_docs)] // documentation missing in model
    Numeric,
    #[allow(missing_docs)] // documentation missing in model
    Nvarchar,
    #[allow(missing_docs)] // documentation missing in model
    Other,
    #[allow(missing_docs)] // documentation missing in model
    Real,
    #[allow(missing_docs)] // documentation missing in model
    Ref,
    #[allow(missing_docs)] // documentation missing in model
    RefCursor,
    #[allow(missing_docs)] // documentation missing in model
    Rowid,
    #[allow(missing_docs)] // documentation missing in model
    Smallint,
    #[allow(missing_docs)] // documentation missing in model
    Sqlxml,
    #[allow(missing_docs)] // documentation missing in model
    Struct,
    #[allow(missing_docs)] // documentation missing in model
    Time,
    #[allow(missing_docs)] // documentation missing in model
    Timestamp,
    #[allow(missing_docs)] // documentation missing in model
    TimestampWithTimezone,
    #[allow(missing_docs)] // documentation missing in model
    TimeWithTimezone,
    #[allow(missing_docs)] // documentation missing in model
    Tinyint,
    #[allow(missing_docs)] // documentation missing in model
    Varbinary,
    #[allow(missing_docs)] // documentation missing in model
    Varchar,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::primitives::UnknownVariantValue),
}
impl std::convert::From<&str> for JdbcDataType {
    fn from(s: &str) -> Self {
        match s {
            "ARRAY" => JdbcDataType::Array,
            "BIGINT" => JdbcDataType::Bigint,
            "BINARY" => JdbcDataType::Binary,
            "BIT" => JdbcDataType::Bit,
            "BLOB" => JdbcDataType::Blob,
            "BOOLEAN" => JdbcDataType::Boolean,
            "CHAR" => JdbcDataType::Char,
            "CLOB" => JdbcDataType::Clob,
            "DATALINK" => JdbcDataType::Datalink,
            "DATE" => JdbcDataType::Date,
            "DECIMAL" => JdbcDataType::Decimal,
            "DISTINCT" => JdbcDataType::Distinct,
            "DOUBLE" => JdbcDataType::Double,
            "FLOAT" => JdbcDataType::Float,
            "INTEGER" => JdbcDataType::Integer,
            "JAVA_OBJECT" => JdbcDataType::JavaObject,
            "LONGNVARCHAR" => JdbcDataType::Longnvarchar,
            "LONGVARBINARY" => JdbcDataType::Longvarbinary,
            "LONGVARCHAR" => JdbcDataType::Longvarchar,
            "NCHAR" => JdbcDataType::Nchar,
            "NCLOB" => JdbcDataType::Nclob,
            "NULL" => JdbcDataType::Null,
            "NUMERIC" => JdbcDataType::Numeric,
            "NVARCHAR" => JdbcDataType::Nvarchar,
            "OTHER" => JdbcDataType::Other,
            "REAL" => JdbcDataType::Real,
            "REF" => JdbcDataType::Ref,
            "REF_CURSOR" => JdbcDataType::RefCursor,
            "ROWID" => JdbcDataType::Rowid,
            "SMALLINT" => JdbcDataType::Smallint,
            "SQLXML" => JdbcDataType::Sqlxml,
            "STRUCT" => JdbcDataType::Struct,
            "TIME" => JdbcDataType::Time,
            "TIMESTAMP" => JdbcDataType::Timestamp,
            "TIMESTAMP_WITH_TIMEZONE" => JdbcDataType::TimestampWithTimezone,
            "TIME_WITH_TIMEZONE" => JdbcDataType::TimeWithTimezone,
            "TINYINT" => JdbcDataType::Tinyint,
            "VARBINARY" => JdbcDataType::Varbinary,
            "VARCHAR" => JdbcDataType::Varchar,
            other => {
                JdbcDataType::Unknown(crate::primitives::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for JdbcDataType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(JdbcDataType::from(s))
    }
}
impl JdbcDataType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            JdbcDataType::Array => "ARRAY",
            JdbcDataType::Bigint => "BIGINT",
            JdbcDataType::Binary => "BINARY",
            JdbcDataType::Bit => "BIT",
            JdbcDataType::Blob => "BLOB",
            JdbcDataType::Boolean => "BOOLEAN",
            JdbcDataType::Char => "CHAR",
            JdbcDataType::Clob => "CLOB",
            JdbcDataType::Datalink => "DATALINK",
            JdbcDataType::Date => "DATE",
            JdbcDataType::Decimal => "DECIMAL",
            JdbcDataType::Distinct => "DISTINCT",
            JdbcDataType::Double => "DOUBLE",
            JdbcDataType::Float => "FLOAT",
            JdbcDataType::Integer => "INTEGER",
            JdbcDataType::JavaObject => "JAVA_OBJECT",
            JdbcDataType::Longnvarchar => "LONGNVARCHAR",
            JdbcDataType::Longvarbinary => "LONGVARBINARY",
            JdbcDataType::Longvarchar => "LONGVARCHAR",
            JdbcDataType::Nchar => "NCHAR",
            JdbcDataType::Nclob => "NCLOB",
            JdbcDataType::Null => "NULL",
            JdbcDataType::Numeric => "NUMERIC",
            JdbcDataType::Nvarchar => "NVARCHAR",
            JdbcDataType::Other => "OTHER",
            JdbcDataType::Real => "REAL",
            JdbcDataType::Ref => "REF",
            JdbcDataType::RefCursor => "REF_CURSOR",
            JdbcDataType::Rowid => "ROWID",
            JdbcDataType::Smallint => "SMALLINT",
            JdbcDataType::Sqlxml => "SQLXML",
            JdbcDataType::Struct => "STRUCT",
            JdbcDataType::Time => "TIME",
            JdbcDataType::Timestamp => "TIMESTAMP",
            JdbcDataType::TimestampWithTimezone => "TIMESTAMP_WITH_TIMEZONE",
            JdbcDataType::TimeWithTimezone => "TIME_WITH_TIMEZONE",
            JdbcDataType::Tinyint => "TINYINT",
            JdbcDataType::Varbinary => "VARBINARY",
            JdbcDataType::Varchar => "VARCHAR",
            JdbcDataType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "ARRAY",
            "BIGINT",
            "BINARY",
            "BIT",
            "BLOB",
            "BOOLEAN",
            "CHAR",
            "CLOB",
            "DATALINK",
            "DATE",
            "DECIMAL",
            "DISTINCT",
            "DOUBLE",
            "FLOAT",
            "INTEGER",
            "JAVA_OBJECT",
            "LONGNVARCHAR",
            "LONGVARBINARY",
            "LONGVARCHAR",
            "NCHAR",
            "NCLOB",
            "NULL",
            "NUMERIC",
            "NVARCHAR",
            "OTHER",
            "REAL",
            "REF",
            "REF_CURSOR",
            "ROWID",
            "SMALLINT",
            "SQLXML",
            "STRUCT",
            "TIME",
            "TIMESTAMP",
            "TIMESTAMP_WITH_TIMEZONE",
            "TIME_WITH_TIMEZONE",
            "TINYINT",
            "VARBINARY",
            "VARCHAR",
        ]
    }
}
impl AsRef<str> for JdbcDataType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
