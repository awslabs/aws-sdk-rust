// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// When writing a match expression against `JdbcDataType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
/// 
/// Here is an example of how you can make a match expression forward-compatible:
/// 
/// ```text
/// # let jdbcdatatype = unimplemented!();
/// match jdbcdatatype {
///     JdbcDataType::Array => { /* ... */ },
///     JdbcDataType::Bigint => { /* ... */ },
///     JdbcDataType::Binary => { /* ... */ },
///     JdbcDataType::Bit => { /* ... */ },
///     JdbcDataType::Blob => { /* ... */ },
///     JdbcDataType::Boolean => { /* ... */ },
///     JdbcDataType::Char => { /* ... */ },
///     JdbcDataType::Clob => { /* ... */ },
///     JdbcDataType::Datalink => { /* ... */ },
///     JdbcDataType::Date => { /* ... */ },
///     JdbcDataType::Decimal => { /* ... */ },
///     JdbcDataType::Distinct => { /* ... */ },
///     JdbcDataType::Double => { /* ... */ },
///     JdbcDataType::Float => { /* ... */ },
///     JdbcDataType::Integer => { /* ... */ },
///     JdbcDataType::JavaObject => { /* ... */ },
///     JdbcDataType::Longnvarchar => { /* ... */ },
///     JdbcDataType::Longvarbinary => { /* ... */ },
///     JdbcDataType::Longvarchar => { /* ... */ },
///     JdbcDataType::Nchar => { /* ... */ },
///     JdbcDataType::Nclob => { /* ... */ },
///     JdbcDataType::Null => { /* ... */ },
///     JdbcDataType::Numeric => { /* ... */ },
///     JdbcDataType::Nvarchar => { /* ... */ },
///     JdbcDataType::Other => { /* ... */ },
///     JdbcDataType::Real => { /* ... */ },
///     JdbcDataType::Ref => { /* ... */ },
///     JdbcDataType::RefCursor => { /* ... */ },
///     JdbcDataType::Rowid => { /* ... */ },
///     JdbcDataType::Smallint => { /* ... */ },
///     JdbcDataType::Sqlxml => { /* ... */ },
///     JdbcDataType::Struct => { /* ... */ },
///     JdbcDataType::Time => { /* ... */ },
///     JdbcDataType::Timestamp => { /* ... */ },
///     JdbcDataType::TimestampWithTimezone => { /* ... */ },
///     JdbcDataType::TimeWithTimezone => { /* ... */ },
///     JdbcDataType::Tinyint => { /* ... */ },
///     JdbcDataType::Varbinary => { /* ... */ },
///     JdbcDataType::Varchar => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `jdbcdatatype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `JdbcDataType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `JdbcDataType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `JdbcDataType::NewFeature` is defined.
/// Specifically, when `jdbcdatatype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `JdbcDataType::NewFeature` also yielding `"NewFeature"`.
/// 
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::Eq, std::cmp::Ord, std::cmp::PartialEq, std::cmp::PartialOrd, std::fmt::Debug, std::hash::Hash)]
pub enum JdbcDataType {
    #[allow(missing_docs)] // documentation missing in model
    Array,
    #[allow(missing_docs)] // documentation missing in model
    Bigint,
    #[allow(missing_docs)] // documentation missing in model
    Binary,
    #[allow(missing_docs)] // documentation missing in model
    Bit,
    #[allow(missing_docs)] // documentation missing in model
    Blob,
    #[allow(missing_docs)] // documentation missing in model
    Boolean,
    #[allow(missing_docs)] // documentation missing in model
    Char,
    #[allow(missing_docs)] // documentation missing in model
    Clob,
    #[allow(missing_docs)] // documentation missing in model
    Datalink,
    #[allow(missing_docs)] // documentation missing in model
    Date,
    #[allow(missing_docs)] // documentation missing in model
    Decimal,
    #[allow(missing_docs)] // documentation missing in model
    Distinct,
    #[allow(missing_docs)] // documentation missing in model
    Double,
    #[allow(missing_docs)] // documentation missing in model
    Float,
    #[allow(missing_docs)] // documentation missing in model
    Integer,
    #[allow(missing_docs)] // documentation missing in model
    JavaObject,
    #[allow(missing_docs)] // documentation missing in model
    Longnvarchar,
    #[allow(missing_docs)] // documentation missing in model
    Longvarbinary,
    #[allow(missing_docs)] // documentation missing in model
    Longvarchar,
    #[allow(missing_docs)] // documentation missing in model
    Nchar,
    #[allow(missing_docs)] // documentation missing in model
    Nclob,
    #[allow(missing_docs)] // documentation missing in model
    Null,
    #[allow(missing_docs)] // documentation missing in model
    Numeric,
    #[allow(missing_docs)] // documentation missing in model
    Nvarchar,
    #[allow(missing_docs)] // documentation missing in model
    Other,
    #[allow(missing_docs)] // documentation missing in model
    Real,
    #[allow(missing_docs)] // documentation missing in model
    Ref,
    #[allow(missing_docs)] // documentation missing in model
    RefCursor,
    #[allow(missing_docs)] // documentation missing in model
    Rowid,
    #[allow(missing_docs)] // documentation missing in model
    Smallint,
    #[allow(missing_docs)] // documentation missing in model
    Sqlxml,
    #[allow(missing_docs)] // documentation missing in model
    Struct,
    #[allow(missing_docs)] // documentation missing in model
    Time,
    #[allow(missing_docs)] // documentation missing in model
    Timestamp,
    #[allow(missing_docs)] // documentation missing in model
    TimestampWithTimezone,
    #[allow(missing_docs)] // documentation missing in model
    TimeWithTimezone,
    #[allow(missing_docs)] // documentation missing in model
    Tinyint,
    #[allow(missing_docs)] // documentation missing in model
    Varbinary,
    #[allow(missing_docs)] // documentation missing in model
    Varchar,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::primitives::UnknownVariantValue)
}
impl std::convert::From<&str> for JdbcDataType {
                fn from(s: &str) -> Self {
                    match s {
                        "ARRAY" => JdbcDataType::Array,
"BIGINT" => JdbcDataType::Bigint,
"BINARY" => JdbcDataType::Binary,
"BIT" => JdbcDataType::Bit,
"BLOB" => JdbcDataType::Blob,
"BOOLEAN" => JdbcDataType::Boolean,
"CHAR" => JdbcDataType::Char,
"CLOB" => JdbcDataType::Clob,
"DATALINK" => JdbcDataType::Datalink,
"DATE" => JdbcDataType::Date,
"DECIMAL" => JdbcDataType::Decimal,
"DISTINCT" => JdbcDataType::Distinct,
"DOUBLE" => JdbcDataType::Double,
"FLOAT" => JdbcDataType::Float,
"INTEGER" => JdbcDataType::Integer,
"JAVA_OBJECT" => JdbcDataType::JavaObject,
"LONGNVARCHAR" => JdbcDataType::Longnvarchar,
"LONGVARBINARY" => JdbcDataType::Longvarbinary,
"LONGVARCHAR" => JdbcDataType::Longvarchar,
"NCHAR" => JdbcDataType::Nchar,
"NCLOB" => JdbcDataType::Nclob,
"NULL" => JdbcDataType::Null,
"NUMERIC" => JdbcDataType::Numeric,
"NVARCHAR" => JdbcDataType::Nvarchar,
"OTHER" => JdbcDataType::Other,
"REAL" => JdbcDataType::Real,
"REF" => JdbcDataType::Ref,
"REF_CURSOR" => JdbcDataType::RefCursor,
"ROWID" => JdbcDataType::Rowid,
"SMALLINT" => JdbcDataType::Smallint,
"SQLXML" => JdbcDataType::Sqlxml,
"STRUCT" => JdbcDataType::Struct,
"TIME" => JdbcDataType::Time,
"TIMESTAMP" => JdbcDataType::Timestamp,
"TIMESTAMP_WITH_TIMEZONE" => JdbcDataType::TimestampWithTimezone,
"TIME_WITH_TIMEZONE" => JdbcDataType::TimeWithTimezone,
"TINYINT" => JdbcDataType::Tinyint,
"VARBINARY" => JdbcDataType::Varbinary,
"VARCHAR" => JdbcDataType::Varchar,
other => JdbcDataType::Unknown(crate::primitives::UnknownVariantValue(other.to_owned()))
                    }
                }
            }
impl std::str::FromStr for JdbcDataType {
                type Err = std::convert::Infallible;

                fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                    Ok(JdbcDataType::from(s))
                }
            }
impl JdbcDataType {
                /// Returns the `&str` value of the enum member.
                pub fn as_str(&self) -> &str {
                    match self {
    JdbcDataType::Array => "ARRAY",
    JdbcDataType::Bigint => "BIGINT",
    JdbcDataType::Binary => "BINARY",
    JdbcDataType::Bit => "BIT",
    JdbcDataType::Blob => "BLOB",
    JdbcDataType::Boolean => "BOOLEAN",
    JdbcDataType::Char => "CHAR",
    JdbcDataType::Clob => "CLOB",
    JdbcDataType::Datalink => "DATALINK",
    JdbcDataType::Date => "DATE",
    JdbcDataType::Decimal => "DECIMAL",
    JdbcDataType::Distinct => "DISTINCT",
    JdbcDataType::Double => "DOUBLE",
    JdbcDataType::Float => "FLOAT",
    JdbcDataType::Integer => "INTEGER",
    JdbcDataType::JavaObject => "JAVA_OBJECT",
    JdbcDataType::Longnvarchar => "LONGNVARCHAR",
    JdbcDataType::Longvarbinary => "LONGVARBINARY",
    JdbcDataType::Longvarchar => "LONGVARCHAR",
    JdbcDataType::Nchar => "NCHAR",
    JdbcDataType::Nclob => "NCLOB",
    JdbcDataType::Null => "NULL",
    JdbcDataType::Numeric => "NUMERIC",
    JdbcDataType::Nvarchar => "NVARCHAR",
    JdbcDataType::Other => "OTHER",
    JdbcDataType::Real => "REAL",
    JdbcDataType::Ref => "REF",
    JdbcDataType::RefCursor => "REF_CURSOR",
    JdbcDataType::Rowid => "ROWID",
    JdbcDataType::Smallint => "SMALLINT",
    JdbcDataType::Sqlxml => "SQLXML",
    JdbcDataType::Struct => "STRUCT",
    JdbcDataType::Time => "TIME",
    JdbcDataType::Timestamp => "TIMESTAMP",
    JdbcDataType::TimestampWithTimezone => "TIMESTAMP_WITH_TIMEZONE",
    JdbcDataType::TimeWithTimezone => "TIME_WITH_TIMEZONE",
    JdbcDataType::Tinyint => "TINYINT",
    JdbcDataType::Varbinary => "VARBINARY",
    JdbcDataType::Varchar => "VARCHAR",
    JdbcDataType::Unknown(value) => value.as_str()
}
                }
                /// Returns all the `&str` representations of the enum members.
                pub const fn values() -> &'static [&'static str] {
                    &["ARRAY", "BIGINT", "BINARY", "BIT", "BLOB", "BOOLEAN", "CHAR", "CLOB", "DATALINK", "DATE", "DECIMAL", "DISTINCT", "DOUBLE", "FLOAT", "INTEGER", "JAVA_OBJECT", "LONGNVARCHAR", "LONGVARBINARY", "LONGVARCHAR", "NCHAR", "NCLOB", "NULL", "NUMERIC", "NVARCHAR", "OTHER", "REAL", "REF", "REF_CURSOR", "ROWID", "SMALLINT", "SQLXML", "STRUCT", "TIME", "TIMESTAMP", "TIMESTAMP_WITH_TIMEZONE", "TIME_WITH_TIMEZONE", "TINYINT", "VARBINARY", "VARCHAR"]
                }
            }
impl AsRef<str> for JdbcDataType {
                fn as_ref(&self) -> &str {
                    self.as_str()
                }
            }

