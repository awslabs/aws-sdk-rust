// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct BatchCreatePartitionError {
    pub kind: BatchCreatePartitionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum BatchCreatePartitionErrorKind {
    AlreadyExistsException(crate::error::AlreadyExistsException),
    EntityNotFoundException(crate::error::EntityNotFoundException),
    GlueEncryptionException(crate::error::GlueEncryptionException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    ResourceNumberLimitExceededException(crate::error::ResourceNumberLimitExceededException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for BatchCreatePartitionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            BatchCreatePartitionErrorKind::AlreadyExistsException(_inner) => _inner.fmt(f),
            BatchCreatePartitionErrorKind::EntityNotFoundException(_inner) => _inner.fmt(f),
            BatchCreatePartitionErrorKind::GlueEncryptionException(_inner) => _inner.fmt(f),
            BatchCreatePartitionErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            BatchCreatePartitionErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            BatchCreatePartitionErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            BatchCreatePartitionErrorKind::ResourceNumberLimitExceededException(_inner) => {
                _inner.fmt(f)
            }
            BatchCreatePartitionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for BatchCreatePartitionError {
    fn code(&self) -> Option<&str> {
        BatchCreatePartitionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl BatchCreatePartitionError {
    pub fn new(kind: BatchCreatePartitionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: BatchCreatePartitionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: BatchCreatePartitionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchCreatePartitionErrorKind::AlreadyExistsException(_)
        )
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchCreatePartitionErrorKind::EntityNotFoundException(_)
        )
    }
    pub fn is_glue_encryption_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchCreatePartitionErrorKind::GlueEncryptionException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchCreatePartitionErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchCreatePartitionErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchCreatePartitionErrorKind::OperationTimeoutException(_)
        )
    }
    pub fn is_resource_number_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchCreatePartitionErrorKind::ResourceNumberLimitExceededException(_)
        )
    }
}
impl std::error::Error for BatchCreatePartitionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            BatchCreatePartitionErrorKind::AlreadyExistsException(_inner) => Some(_inner),
            BatchCreatePartitionErrorKind::EntityNotFoundException(_inner) => Some(_inner),
            BatchCreatePartitionErrorKind::GlueEncryptionException(_inner) => Some(_inner),
            BatchCreatePartitionErrorKind::InternalServiceException(_inner) => Some(_inner),
            BatchCreatePartitionErrorKind::InvalidInputException(_inner) => Some(_inner),
            BatchCreatePartitionErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            BatchCreatePartitionErrorKind::ResourceNumberLimitExceededException(_inner) => {
                Some(_inner)
            }
            BatchCreatePartitionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct BatchDeleteConnectionError {
    pub kind: BatchDeleteConnectionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum BatchDeleteConnectionErrorKind {
    InternalServiceException(crate::error::InternalServiceException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for BatchDeleteConnectionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            BatchDeleteConnectionErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            BatchDeleteConnectionErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            BatchDeleteConnectionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for BatchDeleteConnectionError {
    fn code(&self) -> Option<&str> {
        BatchDeleteConnectionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl BatchDeleteConnectionError {
    pub fn new(kind: BatchDeleteConnectionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: BatchDeleteConnectionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: BatchDeleteConnectionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchDeleteConnectionErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchDeleteConnectionErrorKind::OperationTimeoutException(_)
        )
    }
}
impl std::error::Error for BatchDeleteConnectionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            BatchDeleteConnectionErrorKind::InternalServiceException(_inner) => Some(_inner),
            BatchDeleteConnectionErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            BatchDeleteConnectionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct BatchDeletePartitionError {
    pub kind: BatchDeletePartitionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum BatchDeletePartitionErrorKind {
    EntityNotFoundException(crate::error::EntityNotFoundException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for BatchDeletePartitionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            BatchDeletePartitionErrorKind::EntityNotFoundException(_inner) => _inner.fmt(f),
            BatchDeletePartitionErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            BatchDeletePartitionErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            BatchDeletePartitionErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            BatchDeletePartitionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for BatchDeletePartitionError {
    fn code(&self) -> Option<&str> {
        BatchDeletePartitionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl BatchDeletePartitionError {
    pub fn new(kind: BatchDeletePartitionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: BatchDeletePartitionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: BatchDeletePartitionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchDeletePartitionErrorKind::EntityNotFoundException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchDeletePartitionErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchDeletePartitionErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchDeletePartitionErrorKind::OperationTimeoutException(_)
        )
    }
}
impl std::error::Error for BatchDeletePartitionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            BatchDeletePartitionErrorKind::EntityNotFoundException(_inner) => Some(_inner),
            BatchDeletePartitionErrorKind::InternalServiceException(_inner) => Some(_inner),
            BatchDeletePartitionErrorKind::InvalidInputException(_inner) => Some(_inner),
            BatchDeletePartitionErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            BatchDeletePartitionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct BatchDeleteTableError {
    pub kind: BatchDeleteTableErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum BatchDeleteTableErrorKind {
    EntityNotFoundException(crate::error::EntityNotFoundException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for BatchDeleteTableError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            BatchDeleteTableErrorKind::EntityNotFoundException(_inner) => _inner.fmt(f),
            BatchDeleteTableErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            BatchDeleteTableErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            BatchDeleteTableErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            BatchDeleteTableErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for BatchDeleteTableError {
    fn code(&self) -> Option<&str> {
        BatchDeleteTableError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl BatchDeleteTableError {
    pub fn new(kind: BatchDeleteTableErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: BatchDeleteTableErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: BatchDeleteTableErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchDeleteTableErrorKind::EntityNotFoundException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchDeleteTableErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchDeleteTableErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchDeleteTableErrorKind::OperationTimeoutException(_)
        )
    }
}
impl std::error::Error for BatchDeleteTableError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            BatchDeleteTableErrorKind::EntityNotFoundException(_inner) => Some(_inner),
            BatchDeleteTableErrorKind::InternalServiceException(_inner) => Some(_inner),
            BatchDeleteTableErrorKind::InvalidInputException(_inner) => Some(_inner),
            BatchDeleteTableErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            BatchDeleteTableErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct BatchDeleteTableVersionError {
    pub kind: BatchDeleteTableVersionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum BatchDeleteTableVersionErrorKind {
    EntityNotFoundException(crate::error::EntityNotFoundException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for BatchDeleteTableVersionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            BatchDeleteTableVersionErrorKind::EntityNotFoundException(_inner) => _inner.fmt(f),
            BatchDeleteTableVersionErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            BatchDeleteTableVersionErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            BatchDeleteTableVersionErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            BatchDeleteTableVersionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for BatchDeleteTableVersionError {
    fn code(&self) -> Option<&str> {
        BatchDeleteTableVersionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl BatchDeleteTableVersionError {
    pub fn new(kind: BatchDeleteTableVersionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: BatchDeleteTableVersionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: BatchDeleteTableVersionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchDeleteTableVersionErrorKind::EntityNotFoundException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchDeleteTableVersionErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchDeleteTableVersionErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchDeleteTableVersionErrorKind::OperationTimeoutException(_)
        )
    }
}
impl std::error::Error for BatchDeleteTableVersionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            BatchDeleteTableVersionErrorKind::EntityNotFoundException(_inner) => Some(_inner),
            BatchDeleteTableVersionErrorKind::InternalServiceException(_inner) => Some(_inner),
            BatchDeleteTableVersionErrorKind::InvalidInputException(_inner) => Some(_inner),
            BatchDeleteTableVersionErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            BatchDeleteTableVersionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct BatchGetBlueprintsError {
    pub kind: BatchGetBlueprintsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum BatchGetBlueprintsErrorKind {
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for BatchGetBlueprintsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            BatchGetBlueprintsErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            BatchGetBlueprintsErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            BatchGetBlueprintsErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            BatchGetBlueprintsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for BatchGetBlueprintsError {
    fn code(&self) -> Option<&str> {
        BatchGetBlueprintsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl BatchGetBlueprintsError {
    pub fn new(kind: BatchGetBlueprintsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: BatchGetBlueprintsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: BatchGetBlueprintsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchGetBlueprintsErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchGetBlueprintsErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchGetBlueprintsErrorKind::OperationTimeoutException(_)
        )
    }
}
impl std::error::Error for BatchGetBlueprintsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            BatchGetBlueprintsErrorKind::InternalServiceException(_inner) => Some(_inner),
            BatchGetBlueprintsErrorKind::InvalidInputException(_inner) => Some(_inner),
            BatchGetBlueprintsErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            BatchGetBlueprintsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct BatchGetCrawlersError {
    pub kind: BatchGetCrawlersErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum BatchGetCrawlersErrorKind {
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for BatchGetCrawlersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            BatchGetCrawlersErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            BatchGetCrawlersErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            BatchGetCrawlersErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for BatchGetCrawlersError {
    fn code(&self) -> Option<&str> {
        BatchGetCrawlersError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl BatchGetCrawlersError {
    pub fn new(kind: BatchGetCrawlersErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: BatchGetCrawlersErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: BatchGetCrawlersErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchGetCrawlersErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchGetCrawlersErrorKind::OperationTimeoutException(_)
        )
    }
}
impl std::error::Error for BatchGetCrawlersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            BatchGetCrawlersErrorKind::InvalidInputException(_inner) => Some(_inner),
            BatchGetCrawlersErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            BatchGetCrawlersErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct BatchGetDevEndpointsError {
    pub kind: BatchGetDevEndpointsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum BatchGetDevEndpointsErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for BatchGetDevEndpointsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            BatchGetDevEndpointsErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            BatchGetDevEndpointsErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            BatchGetDevEndpointsErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            BatchGetDevEndpointsErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            BatchGetDevEndpointsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for BatchGetDevEndpointsError {
    fn code(&self) -> Option<&str> {
        BatchGetDevEndpointsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl BatchGetDevEndpointsError {
    pub fn new(kind: BatchGetDevEndpointsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: BatchGetDevEndpointsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: BatchGetDevEndpointsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchGetDevEndpointsErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchGetDevEndpointsErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchGetDevEndpointsErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchGetDevEndpointsErrorKind::OperationTimeoutException(_)
        )
    }
}
impl std::error::Error for BatchGetDevEndpointsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            BatchGetDevEndpointsErrorKind::AccessDeniedException(_inner) => Some(_inner),
            BatchGetDevEndpointsErrorKind::InternalServiceException(_inner) => Some(_inner),
            BatchGetDevEndpointsErrorKind::InvalidInputException(_inner) => Some(_inner),
            BatchGetDevEndpointsErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            BatchGetDevEndpointsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct BatchGetJobsError {
    pub kind: BatchGetJobsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum BatchGetJobsErrorKind {
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for BatchGetJobsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            BatchGetJobsErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            BatchGetJobsErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            BatchGetJobsErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            BatchGetJobsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for BatchGetJobsError {
    fn code(&self) -> Option<&str> {
        BatchGetJobsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl BatchGetJobsError {
    pub fn new(kind: BatchGetJobsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: BatchGetJobsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: BatchGetJobsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchGetJobsErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(&self.kind, BatchGetJobsErrorKind::InvalidInputException(_))
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchGetJobsErrorKind::OperationTimeoutException(_)
        )
    }
}
impl std::error::Error for BatchGetJobsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            BatchGetJobsErrorKind::InternalServiceException(_inner) => Some(_inner),
            BatchGetJobsErrorKind::InvalidInputException(_inner) => Some(_inner),
            BatchGetJobsErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            BatchGetJobsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct BatchGetPartitionError {
    pub kind: BatchGetPartitionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum BatchGetPartitionErrorKind {
    EntityNotFoundException(crate::error::EntityNotFoundException),
    GlueEncryptionException(crate::error::GlueEncryptionException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for BatchGetPartitionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            BatchGetPartitionErrorKind::EntityNotFoundException(_inner) => _inner.fmt(f),
            BatchGetPartitionErrorKind::GlueEncryptionException(_inner) => _inner.fmt(f),
            BatchGetPartitionErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            BatchGetPartitionErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            BatchGetPartitionErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            BatchGetPartitionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for BatchGetPartitionError {
    fn code(&self) -> Option<&str> {
        BatchGetPartitionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl BatchGetPartitionError {
    pub fn new(kind: BatchGetPartitionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: BatchGetPartitionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: BatchGetPartitionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchGetPartitionErrorKind::EntityNotFoundException(_)
        )
    }
    pub fn is_glue_encryption_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchGetPartitionErrorKind::GlueEncryptionException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchGetPartitionErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchGetPartitionErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchGetPartitionErrorKind::OperationTimeoutException(_)
        )
    }
}
impl std::error::Error for BatchGetPartitionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            BatchGetPartitionErrorKind::EntityNotFoundException(_inner) => Some(_inner),
            BatchGetPartitionErrorKind::GlueEncryptionException(_inner) => Some(_inner),
            BatchGetPartitionErrorKind::InternalServiceException(_inner) => Some(_inner),
            BatchGetPartitionErrorKind::InvalidInputException(_inner) => Some(_inner),
            BatchGetPartitionErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            BatchGetPartitionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct BatchGetTriggersError {
    pub kind: BatchGetTriggersErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum BatchGetTriggersErrorKind {
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for BatchGetTriggersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            BatchGetTriggersErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            BatchGetTriggersErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            BatchGetTriggersErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            BatchGetTriggersErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for BatchGetTriggersError {
    fn code(&self) -> Option<&str> {
        BatchGetTriggersError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl BatchGetTriggersError {
    pub fn new(kind: BatchGetTriggersErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: BatchGetTriggersErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: BatchGetTriggersErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchGetTriggersErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchGetTriggersErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchGetTriggersErrorKind::OperationTimeoutException(_)
        )
    }
}
impl std::error::Error for BatchGetTriggersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            BatchGetTriggersErrorKind::InternalServiceException(_inner) => Some(_inner),
            BatchGetTriggersErrorKind::InvalidInputException(_inner) => Some(_inner),
            BatchGetTriggersErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            BatchGetTriggersErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct BatchGetWorkflowsError {
    pub kind: BatchGetWorkflowsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum BatchGetWorkflowsErrorKind {
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for BatchGetWorkflowsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            BatchGetWorkflowsErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            BatchGetWorkflowsErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            BatchGetWorkflowsErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            BatchGetWorkflowsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for BatchGetWorkflowsError {
    fn code(&self) -> Option<&str> {
        BatchGetWorkflowsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl BatchGetWorkflowsError {
    pub fn new(kind: BatchGetWorkflowsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: BatchGetWorkflowsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: BatchGetWorkflowsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchGetWorkflowsErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchGetWorkflowsErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchGetWorkflowsErrorKind::OperationTimeoutException(_)
        )
    }
}
impl std::error::Error for BatchGetWorkflowsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            BatchGetWorkflowsErrorKind::InternalServiceException(_inner) => Some(_inner),
            BatchGetWorkflowsErrorKind::InvalidInputException(_inner) => Some(_inner),
            BatchGetWorkflowsErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            BatchGetWorkflowsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct BatchStopJobRunError {
    pub kind: BatchStopJobRunErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum BatchStopJobRunErrorKind {
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for BatchStopJobRunError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            BatchStopJobRunErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            BatchStopJobRunErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            BatchStopJobRunErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            BatchStopJobRunErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for BatchStopJobRunError {
    fn code(&self) -> Option<&str> {
        BatchStopJobRunError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl BatchStopJobRunError {
    pub fn new(kind: BatchStopJobRunErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: BatchStopJobRunErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: BatchStopJobRunErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchStopJobRunErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchStopJobRunErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchStopJobRunErrorKind::OperationTimeoutException(_)
        )
    }
}
impl std::error::Error for BatchStopJobRunError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            BatchStopJobRunErrorKind::InternalServiceException(_inner) => Some(_inner),
            BatchStopJobRunErrorKind::InvalidInputException(_inner) => Some(_inner),
            BatchStopJobRunErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            BatchStopJobRunErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct BatchUpdatePartitionError {
    pub kind: BatchUpdatePartitionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum BatchUpdatePartitionErrorKind {
    EntityNotFoundException(crate::error::EntityNotFoundException),
    GlueEncryptionException(crate::error::GlueEncryptionException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for BatchUpdatePartitionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            BatchUpdatePartitionErrorKind::EntityNotFoundException(_inner) => _inner.fmt(f),
            BatchUpdatePartitionErrorKind::GlueEncryptionException(_inner) => _inner.fmt(f),
            BatchUpdatePartitionErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            BatchUpdatePartitionErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            BatchUpdatePartitionErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            BatchUpdatePartitionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for BatchUpdatePartitionError {
    fn code(&self) -> Option<&str> {
        BatchUpdatePartitionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl BatchUpdatePartitionError {
    pub fn new(kind: BatchUpdatePartitionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: BatchUpdatePartitionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: BatchUpdatePartitionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchUpdatePartitionErrorKind::EntityNotFoundException(_)
        )
    }
    pub fn is_glue_encryption_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchUpdatePartitionErrorKind::GlueEncryptionException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchUpdatePartitionErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchUpdatePartitionErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchUpdatePartitionErrorKind::OperationTimeoutException(_)
        )
    }
}
impl std::error::Error for BatchUpdatePartitionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            BatchUpdatePartitionErrorKind::EntityNotFoundException(_inner) => Some(_inner),
            BatchUpdatePartitionErrorKind::GlueEncryptionException(_inner) => Some(_inner),
            BatchUpdatePartitionErrorKind::InternalServiceException(_inner) => Some(_inner),
            BatchUpdatePartitionErrorKind::InvalidInputException(_inner) => Some(_inner),
            BatchUpdatePartitionErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            BatchUpdatePartitionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CancelMLTaskRunError {
    pub kind: CancelMLTaskRunErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CancelMLTaskRunErrorKind {
    EntityNotFoundException(crate::error::EntityNotFoundException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CancelMLTaskRunError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CancelMLTaskRunErrorKind::EntityNotFoundException(_inner) => _inner.fmt(f),
            CancelMLTaskRunErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            CancelMLTaskRunErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            CancelMLTaskRunErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            CancelMLTaskRunErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CancelMLTaskRunError {
    fn code(&self) -> Option<&str> {
        CancelMLTaskRunError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CancelMLTaskRunError {
    pub fn new(kind: CancelMLTaskRunErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CancelMLTaskRunErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CancelMLTaskRunErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CancelMLTaskRunErrorKind::EntityNotFoundException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            CancelMLTaskRunErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            CancelMLTaskRunErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            CancelMLTaskRunErrorKind::OperationTimeoutException(_)
        )
    }
}
impl std::error::Error for CancelMLTaskRunError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CancelMLTaskRunErrorKind::EntityNotFoundException(_inner) => Some(_inner),
            CancelMLTaskRunErrorKind::InternalServiceException(_inner) => Some(_inner),
            CancelMLTaskRunErrorKind::InvalidInputException(_inner) => Some(_inner),
            CancelMLTaskRunErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            CancelMLTaskRunErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CheckSchemaVersionValidityError {
    pub kind: CheckSchemaVersionValidityErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CheckSchemaVersionValidityErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CheckSchemaVersionValidityError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CheckSchemaVersionValidityErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            CheckSchemaVersionValidityErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            CheckSchemaVersionValidityErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            CheckSchemaVersionValidityErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CheckSchemaVersionValidityError {
    fn code(&self) -> Option<&str> {
        CheckSchemaVersionValidityError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CheckSchemaVersionValidityError {
    pub fn new(kind: CheckSchemaVersionValidityErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CheckSchemaVersionValidityErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CheckSchemaVersionValidityErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            CheckSchemaVersionValidityErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            CheckSchemaVersionValidityErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            CheckSchemaVersionValidityErrorKind::InvalidInputException(_)
        )
    }
}
impl std::error::Error for CheckSchemaVersionValidityError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CheckSchemaVersionValidityErrorKind::AccessDeniedException(_inner) => Some(_inner),
            CheckSchemaVersionValidityErrorKind::InternalServiceException(_inner) => Some(_inner),
            CheckSchemaVersionValidityErrorKind::InvalidInputException(_inner) => Some(_inner),
            CheckSchemaVersionValidityErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateBlueprintError {
    pub kind: CreateBlueprintErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateBlueprintErrorKind {
    AlreadyExistsException(crate::error::AlreadyExistsException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    ResourceNumberLimitExceededException(crate::error::ResourceNumberLimitExceededException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateBlueprintError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateBlueprintErrorKind::AlreadyExistsException(_inner) => _inner.fmt(f),
            CreateBlueprintErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            CreateBlueprintErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            CreateBlueprintErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            CreateBlueprintErrorKind::ResourceNumberLimitExceededException(_inner) => _inner.fmt(f),
            CreateBlueprintErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateBlueprintError {
    fn code(&self) -> Option<&str> {
        CreateBlueprintError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateBlueprintError {
    pub fn new(kind: CreateBlueprintErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateBlueprintErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateBlueprintErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateBlueprintErrorKind::AlreadyExistsException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateBlueprintErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateBlueprintErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateBlueprintErrorKind::OperationTimeoutException(_)
        )
    }
    pub fn is_resource_number_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateBlueprintErrorKind::ResourceNumberLimitExceededException(_)
        )
    }
}
impl std::error::Error for CreateBlueprintError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateBlueprintErrorKind::AlreadyExistsException(_inner) => Some(_inner),
            CreateBlueprintErrorKind::InternalServiceException(_inner) => Some(_inner),
            CreateBlueprintErrorKind::InvalidInputException(_inner) => Some(_inner),
            CreateBlueprintErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            CreateBlueprintErrorKind::ResourceNumberLimitExceededException(_inner) => Some(_inner),
            CreateBlueprintErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateClassifierError {
    pub kind: CreateClassifierErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateClassifierErrorKind {
    AlreadyExistsException(crate::error::AlreadyExistsException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateClassifierError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateClassifierErrorKind::AlreadyExistsException(_inner) => _inner.fmt(f),
            CreateClassifierErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            CreateClassifierErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            CreateClassifierErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateClassifierError {
    fn code(&self) -> Option<&str> {
        CreateClassifierError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateClassifierError {
    pub fn new(kind: CreateClassifierErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateClassifierErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateClassifierErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateClassifierErrorKind::AlreadyExistsException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateClassifierErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateClassifierErrorKind::OperationTimeoutException(_)
        )
    }
}
impl std::error::Error for CreateClassifierError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateClassifierErrorKind::AlreadyExistsException(_inner) => Some(_inner),
            CreateClassifierErrorKind::InvalidInputException(_inner) => Some(_inner),
            CreateClassifierErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            CreateClassifierErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateConnectionError {
    pub kind: CreateConnectionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateConnectionErrorKind {
    AlreadyExistsException(crate::error::AlreadyExistsException),
    GlueEncryptionException(crate::error::GlueEncryptionException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    ResourceNumberLimitExceededException(crate::error::ResourceNumberLimitExceededException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateConnectionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateConnectionErrorKind::AlreadyExistsException(_inner) => _inner.fmt(f),
            CreateConnectionErrorKind::GlueEncryptionException(_inner) => _inner.fmt(f),
            CreateConnectionErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            CreateConnectionErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            CreateConnectionErrorKind::ResourceNumberLimitExceededException(_inner) => {
                _inner.fmt(f)
            }
            CreateConnectionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateConnectionError {
    fn code(&self) -> Option<&str> {
        CreateConnectionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateConnectionError {
    pub fn new(kind: CreateConnectionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateConnectionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateConnectionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateConnectionErrorKind::AlreadyExistsException(_)
        )
    }
    pub fn is_glue_encryption_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateConnectionErrorKind::GlueEncryptionException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateConnectionErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateConnectionErrorKind::OperationTimeoutException(_)
        )
    }
    pub fn is_resource_number_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateConnectionErrorKind::ResourceNumberLimitExceededException(_)
        )
    }
}
impl std::error::Error for CreateConnectionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateConnectionErrorKind::AlreadyExistsException(_inner) => Some(_inner),
            CreateConnectionErrorKind::GlueEncryptionException(_inner) => Some(_inner),
            CreateConnectionErrorKind::InvalidInputException(_inner) => Some(_inner),
            CreateConnectionErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            CreateConnectionErrorKind::ResourceNumberLimitExceededException(_inner) => Some(_inner),
            CreateConnectionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateCrawlerError {
    pub kind: CreateCrawlerErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateCrawlerErrorKind {
    AlreadyExistsException(crate::error::AlreadyExistsException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    ResourceNumberLimitExceededException(crate::error::ResourceNumberLimitExceededException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateCrawlerError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateCrawlerErrorKind::AlreadyExistsException(_inner) => _inner.fmt(f),
            CreateCrawlerErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            CreateCrawlerErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            CreateCrawlerErrorKind::ResourceNumberLimitExceededException(_inner) => _inner.fmt(f),
            CreateCrawlerErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateCrawlerError {
    fn code(&self) -> Option<&str> {
        CreateCrawlerError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateCrawlerError {
    pub fn new(kind: CreateCrawlerErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateCrawlerErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateCrawlerErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCrawlerErrorKind::AlreadyExistsException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(&self.kind, CreateCrawlerErrorKind::InvalidInputException(_))
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCrawlerErrorKind::OperationTimeoutException(_)
        )
    }
    pub fn is_resource_number_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCrawlerErrorKind::ResourceNumberLimitExceededException(_)
        )
    }
}
impl std::error::Error for CreateCrawlerError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateCrawlerErrorKind::AlreadyExistsException(_inner) => Some(_inner),
            CreateCrawlerErrorKind::InvalidInputException(_inner) => Some(_inner),
            CreateCrawlerErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            CreateCrawlerErrorKind::ResourceNumberLimitExceededException(_inner) => Some(_inner),
            CreateCrawlerErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateDatabaseError {
    pub kind: CreateDatabaseErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateDatabaseErrorKind {
    AlreadyExistsException(crate::error::AlreadyExistsException),
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    GlueEncryptionException(crate::error::GlueEncryptionException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    ResourceNumberLimitExceededException(crate::error::ResourceNumberLimitExceededException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateDatabaseError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateDatabaseErrorKind::AlreadyExistsException(_inner) => _inner.fmt(f),
            CreateDatabaseErrorKind::ConcurrentModificationException(_inner) => _inner.fmt(f),
            CreateDatabaseErrorKind::GlueEncryptionException(_inner) => _inner.fmt(f),
            CreateDatabaseErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            CreateDatabaseErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            CreateDatabaseErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            CreateDatabaseErrorKind::ResourceNumberLimitExceededException(_inner) => _inner.fmt(f),
            CreateDatabaseErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateDatabaseError {
    fn code(&self) -> Option<&str> {
        CreateDatabaseError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateDatabaseError {
    pub fn new(kind: CreateDatabaseErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateDatabaseErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateDatabaseErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDatabaseErrorKind::AlreadyExistsException(_)
        )
    }
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDatabaseErrorKind::ConcurrentModificationException(_)
        )
    }
    pub fn is_glue_encryption_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDatabaseErrorKind::GlueEncryptionException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDatabaseErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDatabaseErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDatabaseErrorKind::OperationTimeoutException(_)
        )
    }
    pub fn is_resource_number_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDatabaseErrorKind::ResourceNumberLimitExceededException(_)
        )
    }
}
impl std::error::Error for CreateDatabaseError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateDatabaseErrorKind::AlreadyExistsException(_inner) => Some(_inner),
            CreateDatabaseErrorKind::ConcurrentModificationException(_inner) => Some(_inner),
            CreateDatabaseErrorKind::GlueEncryptionException(_inner) => Some(_inner),
            CreateDatabaseErrorKind::InternalServiceException(_inner) => Some(_inner),
            CreateDatabaseErrorKind::InvalidInputException(_inner) => Some(_inner),
            CreateDatabaseErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            CreateDatabaseErrorKind::ResourceNumberLimitExceededException(_inner) => Some(_inner),
            CreateDatabaseErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateDevEndpointError {
    pub kind: CreateDevEndpointErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateDevEndpointErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AlreadyExistsException(crate::error::AlreadyExistsException),
    IdempotentParameterMismatchException(crate::error::IdempotentParameterMismatchException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    ResourceNumberLimitExceededException(crate::error::ResourceNumberLimitExceededException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateDevEndpointError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateDevEndpointErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            CreateDevEndpointErrorKind::AlreadyExistsException(_inner) => _inner.fmt(f),
            CreateDevEndpointErrorKind::IdempotentParameterMismatchException(_inner) => {
                _inner.fmt(f)
            }
            CreateDevEndpointErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            CreateDevEndpointErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            CreateDevEndpointErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            CreateDevEndpointErrorKind::ResourceNumberLimitExceededException(_inner) => {
                _inner.fmt(f)
            }
            CreateDevEndpointErrorKind::ValidationException(_inner) => _inner.fmt(f),
            CreateDevEndpointErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateDevEndpointError {
    fn code(&self) -> Option<&str> {
        CreateDevEndpointError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateDevEndpointError {
    pub fn new(kind: CreateDevEndpointErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateDevEndpointErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateDevEndpointErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDevEndpointErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDevEndpointErrorKind::AlreadyExistsException(_)
        )
    }
    pub fn is_idempotent_parameter_mismatch_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDevEndpointErrorKind::IdempotentParameterMismatchException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDevEndpointErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDevEndpointErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDevEndpointErrorKind::OperationTimeoutException(_)
        )
    }
    pub fn is_resource_number_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDevEndpointErrorKind::ResourceNumberLimitExceededException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDevEndpointErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for CreateDevEndpointError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateDevEndpointErrorKind::AccessDeniedException(_inner) => Some(_inner),
            CreateDevEndpointErrorKind::AlreadyExistsException(_inner) => Some(_inner),
            CreateDevEndpointErrorKind::IdempotentParameterMismatchException(_inner) => {
                Some(_inner)
            }
            CreateDevEndpointErrorKind::InternalServiceException(_inner) => Some(_inner),
            CreateDevEndpointErrorKind::InvalidInputException(_inner) => Some(_inner),
            CreateDevEndpointErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            CreateDevEndpointErrorKind::ResourceNumberLimitExceededException(_inner) => {
                Some(_inner)
            }
            CreateDevEndpointErrorKind::ValidationException(_inner) => Some(_inner),
            CreateDevEndpointErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateJobError {
    pub kind: CreateJobErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateJobErrorKind {
    AlreadyExistsException(crate::error::AlreadyExistsException),
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    IdempotentParameterMismatchException(crate::error::IdempotentParameterMismatchException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    ResourceNumberLimitExceededException(crate::error::ResourceNumberLimitExceededException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateJobError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateJobErrorKind::AlreadyExistsException(_inner) => _inner.fmt(f),
            CreateJobErrorKind::ConcurrentModificationException(_inner) => _inner.fmt(f),
            CreateJobErrorKind::IdempotentParameterMismatchException(_inner) => _inner.fmt(f),
            CreateJobErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            CreateJobErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            CreateJobErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            CreateJobErrorKind::ResourceNumberLimitExceededException(_inner) => _inner.fmt(f),
            CreateJobErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateJobError {
    fn code(&self) -> Option<&str> {
        CreateJobError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateJobError {
    pub fn new(kind: CreateJobErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateJobErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateJobErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_already_exists_exception(&self) -> bool {
        matches!(&self.kind, CreateJobErrorKind::AlreadyExistsException(_))
    }
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateJobErrorKind::ConcurrentModificationException(_)
        )
    }
    pub fn is_idempotent_parameter_mismatch_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateJobErrorKind::IdempotentParameterMismatchException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(&self.kind, CreateJobErrorKind::InternalServiceException(_))
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(&self.kind, CreateJobErrorKind::InvalidInputException(_))
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(&self.kind, CreateJobErrorKind::OperationTimeoutException(_))
    }
    pub fn is_resource_number_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateJobErrorKind::ResourceNumberLimitExceededException(_)
        )
    }
}
impl std::error::Error for CreateJobError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateJobErrorKind::AlreadyExistsException(_inner) => Some(_inner),
            CreateJobErrorKind::ConcurrentModificationException(_inner) => Some(_inner),
            CreateJobErrorKind::IdempotentParameterMismatchException(_inner) => Some(_inner),
            CreateJobErrorKind::InternalServiceException(_inner) => Some(_inner),
            CreateJobErrorKind::InvalidInputException(_inner) => Some(_inner),
            CreateJobErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            CreateJobErrorKind::ResourceNumberLimitExceededException(_inner) => Some(_inner),
            CreateJobErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateMLTransformError {
    pub kind: CreateMLTransformErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateMLTransformErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AlreadyExistsException(crate::error::AlreadyExistsException),
    IdempotentParameterMismatchException(crate::error::IdempotentParameterMismatchException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    ResourceNumberLimitExceededException(crate::error::ResourceNumberLimitExceededException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateMLTransformError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateMLTransformErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            CreateMLTransformErrorKind::AlreadyExistsException(_inner) => _inner.fmt(f),
            CreateMLTransformErrorKind::IdempotentParameterMismatchException(_inner) => {
                _inner.fmt(f)
            }
            CreateMLTransformErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            CreateMLTransformErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            CreateMLTransformErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            CreateMLTransformErrorKind::ResourceNumberLimitExceededException(_inner) => {
                _inner.fmt(f)
            }
            CreateMLTransformErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateMLTransformError {
    fn code(&self) -> Option<&str> {
        CreateMLTransformError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateMLTransformError {
    pub fn new(kind: CreateMLTransformErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateMLTransformErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateMLTransformErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateMLTransformErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateMLTransformErrorKind::AlreadyExistsException(_)
        )
    }
    pub fn is_idempotent_parameter_mismatch_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateMLTransformErrorKind::IdempotentParameterMismatchException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateMLTransformErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateMLTransformErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateMLTransformErrorKind::OperationTimeoutException(_)
        )
    }
    pub fn is_resource_number_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateMLTransformErrorKind::ResourceNumberLimitExceededException(_)
        )
    }
}
impl std::error::Error for CreateMLTransformError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateMLTransformErrorKind::AccessDeniedException(_inner) => Some(_inner),
            CreateMLTransformErrorKind::AlreadyExistsException(_inner) => Some(_inner),
            CreateMLTransformErrorKind::IdempotentParameterMismatchException(_inner) => {
                Some(_inner)
            }
            CreateMLTransformErrorKind::InternalServiceException(_inner) => Some(_inner),
            CreateMLTransformErrorKind::InvalidInputException(_inner) => Some(_inner),
            CreateMLTransformErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            CreateMLTransformErrorKind::ResourceNumberLimitExceededException(_inner) => {
                Some(_inner)
            }
            CreateMLTransformErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreatePartitionError {
    pub kind: CreatePartitionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreatePartitionErrorKind {
    AlreadyExistsException(crate::error::AlreadyExistsException),
    EntityNotFoundException(crate::error::EntityNotFoundException),
    GlueEncryptionException(crate::error::GlueEncryptionException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    ResourceNumberLimitExceededException(crate::error::ResourceNumberLimitExceededException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreatePartitionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreatePartitionErrorKind::AlreadyExistsException(_inner) => _inner.fmt(f),
            CreatePartitionErrorKind::EntityNotFoundException(_inner) => _inner.fmt(f),
            CreatePartitionErrorKind::GlueEncryptionException(_inner) => _inner.fmt(f),
            CreatePartitionErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            CreatePartitionErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            CreatePartitionErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            CreatePartitionErrorKind::ResourceNumberLimitExceededException(_inner) => _inner.fmt(f),
            CreatePartitionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreatePartitionError {
    fn code(&self) -> Option<&str> {
        CreatePartitionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreatePartitionError {
    pub fn new(kind: CreatePartitionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreatePartitionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreatePartitionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePartitionErrorKind::AlreadyExistsException(_)
        )
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePartitionErrorKind::EntityNotFoundException(_)
        )
    }
    pub fn is_glue_encryption_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePartitionErrorKind::GlueEncryptionException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePartitionErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePartitionErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePartitionErrorKind::OperationTimeoutException(_)
        )
    }
    pub fn is_resource_number_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePartitionErrorKind::ResourceNumberLimitExceededException(_)
        )
    }
}
impl std::error::Error for CreatePartitionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreatePartitionErrorKind::AlreadyExistsException(_inner) => Some(_inner),
            CreatePartitionErrorKind::EntityNotFoundException(_inner) => Some(_inner),
            CreatePartitionErrorKind::GlueEncryptionException(_inner) => Some(_inner),
            CreatePartitionErrorKind::InternalServiceException(_inner) => Some(_inner),
            CreatePartitionErrorKind::InvalidInputException(_inner) => Some(_inner),
            CreatePartitionErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            CreatePartitionErrorKind::ResourceNumberLimitExceededException(_inner) => Some(_inner),
            CreatePartitionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreatePartitionIndexError {
    pub kind: CreatePartitionIndexErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreatePartitionIndexErrorKind {
    AlreadyExistsException(crate::error::AlreadyExistsException),
    EntityNotFoundException(crate::error::EntityNotFoundException),
    GlueEncryptionException(crate::error::GlueEncryptionException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    ResourceNumberLimitExceededException(crate::error::ResourceNumberLimitExceededException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreatePartitionIndexError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreatePartitionIndexErrorKind::AlreadyExistsException(_inner) => _inner.fmt(f),
            CreatePartitionIndexErrorKind::EntityNotFoundException(_inner) => _inner.fmt(f),
            CreatePartitionIndexErrorKind::GlueEncryptionException(_inner) => _inner.fmt(f),
            CreatePartitionIndexErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            CreatePartitionIndexErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            CreatePartitionIndexErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            CreatePartitionIndexErrorKind::ResourceNumberLimitExceededException(_inner) => {
                _inner.fmt(f)
            }
            CreatePartitionIndexErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreatePartitionIndexError {
    fn code(&self) -> Option<&str> {
        CreatePartitionIndexError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreatePartitionIndexError {
    pub fn new(kind: CreatePartitionIndexErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreatePartitionIndexErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreatePartitionIndexErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePartitionIndexErrorKind::AlreadyExistsException(_)
        )
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePartitionIndexErrorKind::EntityNotFoundException(_)
        )
    }
    pub fn is_glue_encryption_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePartitionIndexErrorKind::GlueEncryptionException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePartitionIndexErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePartitionIndexErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePartitionIndexErrorKind::OperationTimeoutException(_)
        )
    }
    pub fn is_resource_number_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePartitionIndexErrorKind::ResourceNumberLimitExceededException(_)
        )
    }
}
impl std::error::Error for CreatePartitionIndexError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreatePartitionIndexErrorKind::AlreadyExistsException(_inner) => Some(_inner),
            CreatePartitionIndexErrorKind::EntityNotFoundException(_inner) => Some(_inner),
            CreatePartitionIndexErrorKind::GlueEncryptionException(_inner) => Some(_inner),
            CreatePartitionIndexErrorKind::InternalServiceException(_inner) => Some(_inner),
            CreatePartitionIndexErrorKind::InvalidInputException(_inner) => Some(_inner),
            CreatePartitionIndexErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            CreatePartitionIndexErrorKind::ResourceNumberLimitExceededException(_inner) => {
                Some(_inner)
            }
            CreatePartitionIndexErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateRegistryError {
    pub kind: CreateRegistryErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateRegistryErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AlreadyExistsException(crate::error::AlreadyExistsException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    ResourceNumberLimitExceededException(crate::error::ResourceNumberLimitExceededException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateRegistryError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateRegistryErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            CreateRegistryErrorKind::AlreadyExistsException(_inner) => _inner.fmt(f),
            CreateRegistryErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            CreateRegistryErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            CreateRegistryErrorKind::ResourceNumberLimitExceededException(_inner) => _inner.fmt(f),
            CreateRegistryErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateRegistryError {
    fn code(&self) -> Option<&str> {
        CreateRegistryError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateRegistryError {
    pub fn new(kind: CreateRegistryErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateRegistryErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateRegistryErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRegistryErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRegistryErrorKind::AlreadyExistsException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRegistryErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRegistryErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_resource_number_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRegistryErrorKind::ResourceNumberLimitExceededException(_)
        )
    }
}
impl std::error::Error for CreateRegistryError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateRegistryErrorKind::AccessDeniedException(_inner) => Some(_inner),
            CreateRegistryErrorKind::AlreadyExistsException(_inner) => Some(_inner),
            CreateRegistryErrorKind::InternalServiceException(_inner) => Some(_inner),
            CreateRegistryErrorKind::InvalidInputException(_inner) => Some(_inner),
            CreateRegistryErrorKind::ResourceNumberLimitExceededException(_inner) => Some(_inner),
            CreateRegistryErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateSchemaError {
    pub kind: CreateSchemaErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateSchemaErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AlreadyExistsException(crate::error::AlreadyExistsException),
    EntityNotFoundException(crate::error::EntityNotFoundException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    ResourceNumberLimitExceededException(crate::error::ResourceNumberLimitExceededException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateSchemaError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateSchemaErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            CreateSchemaErrorKind::AlreadyExistsException(_inner) => _inner.fmt(f),
            CreateSchemaErrorKind::EntityNotFoundException(_inner) => _inner.fmt(f),
            CreateSchemaErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            CreateSchemaErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            CreateSchemaErrorKind::ResourceNumberLimitExceededException(_inner) => _inner.fmt(f),
            CreateSchemaErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateSchemaError {
    fn code(&self) -> Option<&str> {
        CreateSchemaError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateSchemaError {
    pub fn new(kind: CreateSchemaErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateSchemaErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateSchemaErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, CreateSchemaErrorKind::AccessDeniedException(_))
    }
    pub fn is_already_exists_exception(&self) -> bool {
        matches!(&self.kind, CreateSchemaErrorKind::AlreadyExistsException(_))
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateSchemaErrorKind::EntityNotFoundException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateSchemaErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(&self.kind, CreateSchemaErrorKind::InvalidInputException(_))
    }
    pub fn is_resource_number_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateSchemaErrorKind::ResourceNumberLimitExceededException(_)
        )
    }
}
impl std::error::Error for CreateSchemaError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateSchemaErrorKind::AccessDeniedException(_inner) => Some(_inner),
            CreateSchemaErrorKind::AlreadyExistsException(_inner) => Some(_inner),
            CreateSchemaErrorKind::EntityNotFoundException(_inner) => Some(_inner),
            CreateSchemaErrorKind::InternalServiceException(_inner) => Some(_inner),
            CreateSchemaErrorKind::InvalidInputException(_inner) => Some(_inner),
            CreateSchemaErrorKind::ResourceNumberLimitExceededException(_inner) => Some(_inner),
            CreateSchemaErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateScriptError {
    pub kind: CreateScriptErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateScriptErrorKind {
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateScriptError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateScriptErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            CreateScriptErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            CreateScriptErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            CreateScriptErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateScriptError {
    fn code(&self) -> Option<&str> {
        CreateScriptError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateScriptError {
    pub fn new(kind: CreateScriptErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateScriptErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateScriptErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateScriptErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(&self.kind, CreateScriptErrorKind::InvalidInputException(_))
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateScriptErrorKind::OperationTimeoutException(_)
        )
    }
}
impl std::error::Error for CreateScriptError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateScriptErrorKind::InternalServiceException(_inner) => Some(_inner),
            CreateScriptErrorKind::InvalidInputException(_inner) => Some(_inner),
            CreateScriptErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            CreateScriptErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateSecurityConfigurationError {
    pub kind: CreateSecurityConfigurationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateSecurityConfigurationErrorKind {
    AlreadyExistsException(crate::error::AlreadyExistsException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    ResourceNumberLimitExceededException(crate::error::ResourceNumberLimitExceededException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateSecurityConfigurationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateSecurityConfigurationErrorKind::AlreadyExistsException(_inner) => _inner.fmt(f),
            CreateSecurityConfigurationErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            CreateSecurityConfigurationErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            CreateSecurityConfigurationErrorKind::OperationTimeoutException(_inner) => {
                _inner.fmt(f)
            }
            CreateSecurityConfigurationErrorKind::ResourceNumberLimitExceededException(_inner) => {
                _inner.fmt(f)
            }
            CreateSecurityConfigurationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateSecurityConfigurationError {
    fn code(&self) -> Option<&str> {
        CreateSecurityConfigurationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateSecurityConfigurationError {
    pub fn new(kind: CreateSecurityConfigurationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateSecurityConfigurationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateSecurityConfigurationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateSecurityConfigurationErrorKind::AlreadyExistsException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateSecurityConfigurationErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateSecurityConfigurationErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateSecurityConfigurationErrorKind::OperationTimeoutException(_)
        )
    }
    pub fn is_resource_number_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateSecurityConfigurationErrorKind::ResourceNumberLimitExceededException(_)
        )
    }
}
impl std::error::Error for CreateSecurityConfigurationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateSecurityConfigurationErrorKind::AlreadyExistsException(_inner) => Some(_inner),
            CreateSecurityConfigurationErrorKind::InternalServiceException(_inner) => Some(_inner),
            CreateSecurityConfigurationErrorKind::InvalidInputException(_inner) => Some(_inner),
            CreateSecurityConfigurationErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            CreateSecurityConfigurationErrorKind::ResourceNumberLimitExceededException(_inner) => {
                Some(_inner)
            }
            CreateSecurityConfigurationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateTableError {
    pub kind: CreateTableErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateTableErrorKind {
    AlreadyExistsException(crate::error::AlreadyExistsException),
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    EntityNotFoundException(crate::error::EntityNotFoundException),
    GlueEncryptionException(crate::error::GlueEncryptionException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    ResourceNumberLimitExceededException(crate::error::ResourceNumberLimitExceededException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateTableError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateTableErrorKind::AlreadyExistsException(_inner) => _inner.fmt(f),
            CreateTableErrorKind::ConcurrentModificationException(_inner) => _inner.fmt(f),
            CreateTableErrorKind::EntityNotFoundException(_inner) => _inner.fmt(f),
            CreateTableErrorKind::GlueEncryptionException(_inner) => _inner.fmt(f),
            CreateTableErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            CreateTableErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            CreateTableErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            CreateTableErrorKind::ResourceNumberLimitExceededException(_inner) => _inner.fmt(f),
            CreateTableErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateTableError {
    fn code(&self) -> Option<&str> {
        CreateTableError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateTableError {
    pub fn new(kind: CreateTableErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateTableErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateTableErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_already_exists_exception(&self) -> bool {
        matches!(&self.kind, CreateTableErrorKind::AlreadyExistsException(_))
    }
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateTableErrorKind::ConcurrentModificationException(_)
        )
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(&self.kind, CreateTableErrorKind::EntityNotFoundException(_))
    }
    pub fn is_glue_encryption_exception(&self) -> bool {
        matches!(&self.kind, CreateTableErrorKind::GlueEncryptionException(_))
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateTableErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(&self.kind, CreateTableErrorKind::InvalidInputException(_))
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateTableErrorKind::OperationTimeoutException(_)
        )
    }
    pub fn is_resource_number_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateTableErrorKind::ResourceNumberLimitExceededException(_)
        )
    }
}
impl std::error::Error for CreateTableError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateTableErrorKind::AlreadyExistsException(_inner) => Some(_inner),
            CreateTableErrorKind::ConcurrentModificationException(_inner) => Some(_inner),
            CreateTableErrorKind::EntityNotFoundException(_inner) => Some(_inner),
            CreateTableErrorKind::GlueEncryptionException(_inner) => Some(_inner),
            CreateTableErrorKind::InternalServiceException(_inner) => Some(_inner),
            CreateTableErrorKind::InvalidInputException(_inner) => Some(_inner),
            CreateTableErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            CreateTableErrorKind::ResourceNumberLimitExceededException(_inner) => Some(_inner),
            CreateTableErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateTriggerError {
    pub kind: CreateTriggerErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateTriggerErrorKind {
    AlreadyExistsException(crate::error::AlreadyExistsException),
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    EntityNotFoundException(crate::error::EntityNotFoundException),
    IdempotentParameterMismatchException(crate::error::IdempotentParameterMismatchException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    ResourceNumberLimitExceededException(crate::error::ResourceNumberLimitExceededException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateTriggerError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateTriggerErrorKind::AlreadyExistsException(_inner) => _inner.fmt(f),
            CreateTriggerErrorKind::ConcurrentModificationException(_inner) => _inner.fmt(f),
            CreateTriggerErrorKind::EntityNotFoundException(_inner) => _inner.fmt(f),
            CreateTriggerErrorKind::IdempotentParameterMismatchException(_inner) => _inner.fmt(f),
            CreateTriggerErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            CreateTriggerErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            CreateTriggerErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            CreateTriggerErrorKind::ResourceNumberLimitExceededException(_inner) => _inner.fmt(f),
            CreateTriggerErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateTriggerError {
    fn code(&self) -> Option<&str> {
        CreateTriggerError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateTriggerError {
    pub fn new(kind: CreateTriggerErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateTriggerErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateTriggerErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateTriggerErrorKind::AlreadyExistsException(_)
        )
    }
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateTriggerErrorKind::ConcurrentModificationException(_)
        )
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateTriggerErrorKind::EntityNotFoundException(_)
        )
    }
    pub fn is_idempotent_parameter_mismatch_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateTriggerErrorKind::IdempotentParameterMismatchException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateTriggerErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(&self.kind, CreateTriggerErrorKind::InvalidInputException(_))
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateTriggerErrorKind::OperationTimeoutException(_)
        )
    }
    pub fn is_resource_number_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateTriggerErrorKind::ResourceNumberLimitExceededException(_)
        )
    }
}
impl std::error::Error for CreateTriggerError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateTriggerErrorKind::AlreadyExistsException(_inner) => Some(_inner),
            CreateTriggerErrorKind::ConcurrentModificationException(_inner) => Some(_inner),
            CreateTriggerErrorKind::EntityNotFoundException(_inner) => Some(_inner),
            CreateTriggerErrorKind::IdempotentParameterMismatchException(_inner) => Some(_inner),
            CreateTriggerErrorKind::InternalServiceException(_inner) => Some(_inner),
            CreateTriggerErrorKind::InvalidInputException(_inner) => Some(_inner),
            CreateTriggerErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            CreateTriggerErrorKind::ResourceNumberLimitExceededException(_inner) => Some(_inner),
            CreateTriggerErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateUserDefinedFunctionError {
    pub kind: CreateUserDefinedFunctionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateUserDefinedFunctionErrorKind {
    AlreadyExistsException(crate::error::AlreadyExistsException),
    EntityNotFoundException(crate::error::EntityNotFoundException),
    GlueEncryptionException(crate::error::GlueEncryptionException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    ResourceNumberLimitExceededException(crate::error::ResourceNumberLimitExceededException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateUserDefinedFunctionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateUserDefinedFunctionErrorKind::AlreadyExistsException(_inner) => _inner.fmt(f),
            CreateUserDefinedFunctionErrorKind::EntityNotFoundException(_inner) => _inner.fmt(f),
            CreateUserDefinedFunctionErrorKind::GlueEncryptionException(_inner) => _inner.fmt(f),
            CreateUserDefinedFunctionErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            CreateUserDefinedFunctionErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            CreateUserDefinedFunctionErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            CreateUserDefinedFunctionErrorKind::ResourceNumberLimitExceededException(_inner) => {
                _inner.fmt(f)
            }
            CreateUserDefinedFunctionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateUserDefinedFunctionError {
    fn code(&self) -> Option<&str> {
        CreateUserDefinedFunctionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateUserDefinedFunctionError {
    pub fn new(kind: CreateUserDefinedFunctionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateUserDefinedFunctionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateUserDefinedFunctionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUserDefinedFunctionErrorKind::AlreadyExistsException(_)
        )
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUserDefinedFunctionErrorKind::EntityNotFoundException(_)
        )
    }
    pub fn is_glue_encryption_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUserDefinedFunctionErrorKind::GlueEncryptionException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUserDefinedFunctionErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUserDefinedFunctionErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUserDefinedFunctionErrorKind::OperationTimeoutException(_)
        )
    }
    pub fn is_resource_number_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUserDefinedFunctionErrorKind::ResourceNumberLimitExceededException(_)
        )
    }
}
impl std::error::Error for CreateUserDefinedFunctionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateUserDefinedFunctionErrorKind::AlreadyExistsException(_inner) => Some(_inner),
            CreateUserDefinedFunctionErrorKind::EntityNotFoundException(_inner) => Some(_inner),
            CreateUserDefinedFunctionErrorKind::GlueEncryptionException(_inner) => Some(_inner),
            CreateUserDefinedFunctionErrorKind::InternalServiceException(_inner) => Some(_inner),
            CreateUserDefinedFunctionErrorKind::InvalidInputException(_inner) => Some(_inner),
            CreateUserDefinedFunctionErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            CreateUserDefinedFunctionErrorKind::ResourceNumberLimitExceededException(_inner) => {
                Some(_inner)
            }
            CreateUserDefinedFunctionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateWorkflowError {
    pub kind: CreateWorkflowErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateWorkflowErrorKind {
    AlreadyExistsException(crate::error::AlreadyExistsException),
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    ResourceNumberLimitExceededException(crate::error::ResourceNumberLimitExceededException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateWorkflowError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateWorkflowErrorKind::AlreadyExistsException(_inner) => _inner.fmt(f),
            CreateWorkflowErrorKind::ConcurrentModificationException(_inner) => _inner.fmt(f),
            CreateWorkflowErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            CreateWorkflowErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            CreateWorkflowErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            CreateWorkflowErrorKind::ResourceNumberLimitExceededException(_inner) => _inner.fmt(f),
            CreateWorkflowErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateWorkflowError {
    fn code(&self) -> Option<&str> {
        CreateWorkflowError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateWorkflowError {
    pub fn new(kind: CreateWorkflowErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateWorkflowErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateWorkflowErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateWorkflowErrorKind::AlreadyExistsException(_)
        )
    }
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateWorkflowErrorKind::ConcurrentModificationException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateWorkflowErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateWorkflowErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateWorkflowErrorKind::OperationTimeoutException(_)
        )
    }
    pub fn is_resource_number_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateWorkflowErrorKind::ResourceNumberLimitExceededException(_)
        )
    }
}
impl std::error::Error for CreateWorkflowError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateWorkflowErrorKind::AlreadyExistsException(_inner) => Some(_inner),
            CreateWorkflowErrorKind::ConcurrentModificationException(_inner) => Some(_inner),
            CreateWorkflowErrorKind::InternalServiceException(_inner) => Some(_inner),
            CreateWorkflowErrorKind::InvalidInputException(_inner) => Some(_inner),
            CreateWorkflowErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            CreateWorkflowErrorKind::ResourceNumberLimitExceededException(_inner) => Some(_inner),
            CreateWorkflowErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteBlueprintError {
    pub kind: DeleteBlueprintErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteBlueprintErrorKind {
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteBlueprintError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteBlueprintErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            DeleteBlueprintErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            DeleteBlueprintErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            DeleteBlueprintErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteBlueprintError {
    fn code(&self) -> Option<&str> {
        DeleteBlueprintError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteBlueprintError {
    pub fn new(kind: DeleteBlueprintErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteBlueprintErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteBlueprintErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteBlueprintErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteBlueprintErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteBlueprintErrorKind::OperationTimeoutException(_)
        )
    }
}
impl std::error::Error for DeleteBlueprintError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteBlueprintErrorKind::InternalServiceException(_inner) => Some(_inner),
            DeleteBlueprintErrorKind::InvalidInputException(_inner) => Some(_inner),
            DeleteBlueprintErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            DeleteBlueprintErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteClassifierError {
    pub kind: DeleteClassifierErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteClassifierErrorKind {
    EntityNotFoundException(crate::error::EntityNotFoundException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteClassifierError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteClassifierErrorKind::EntityNotFoundException(_inner) => _inner.fmt(f),
            DeleteClassifierErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            DeleteClassifierErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteClassifierError {
    fn code(&self) -> Option<&str> {
        DeleteClassifierError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteClassifierError {
    pub fn new(kind: DeleteClassifierErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteClassifierErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteClassifierErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteClassifierErrorKind::EntityNotFoundException(_)
        )
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteClassifierErrorKind::OperationTimeoutException(_)
        )
    }
}
impl std::error::Error for DeleteClassifierError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteClassifierErrorKind::EntityNotFoundException(_inner) => Some(_inner),
            DeleteClassifierErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            DeleteClassifierErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteColumnStatisticsForPartitionError {
    pub kind: DeleteColumnStatisticsForPartitionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteColumnStatisticsForPartitionErrorKind {
    EntityNotFoundException(crate::error::EntityNotFoundException),
    GlueEncryptionException(crate::error::GlueEncryptionException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteColumnStatisticsForPartitionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteColumnStatisticsForPartitionErrorKind::EntityNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            DeleteColumnStatisticsForPartitionErrorKind::GlueEncryptionException(_inner) => {
                _inner.fmt(f)
            }
            DeleteColumnStatisticsForPartitionErrorKind::InternalServiceException(_inner) => {
                _inner.fmt(f)
            }
            DeleteColumnStatisticsForPartitionErrorKind::InvalidInputException(_inner) => {
                _inner.fmt(f)
            }
            DeleteColumnStatisticsForPartitionErrorKind::OperationTimeoutException(_inner) => {
                _inner.fmt(f)
            }
            DeleteColumnStatisticsForPartitionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteColumnStatisticsForPartitionError {
    fn code(&self) -> Option<&str> {
        DeleteColumnStatisticsForPartitionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteColumnStatisticsForPartitionError {
    pub fn new(
        kind: DeleteColumnStatisticsForPartitionErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteColumnStatisticsForPartitionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteColumnStatisticsForPartitionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteColumnStatisticsForPartitionErrorKind::EntityNotFoundException(_)
        )
    }
    pub fn is_glue_encryption_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteColumnStatisticsForPartitionErrorKind::GlueEncryptionException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteColumnStatisticsForPartitionErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteColumnStatisticsForPartitionErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteColumnStatisticsForPartitionErrorKind::OperationTimeoutException(_)
        )
    }
}
impl std::error::Error for DeleteColumnStatisticsForPartitionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteColumnStatisticsForPartitionErrorKind::EntityNotFoundException(_inner) => {
                Some(_inner)
            }
            DeleteColumnStatisticsForPartitionErrorKind::GlueEncryptionException(_inner) => {
                Some(_inner)
            }
            DeleteColumnStatisticsForPartitionErrorKind::InternalServiceException(_inner) => {
                Some(_inner)
            }
            DeleteColumnStatisticsForPartitionErrorKind::InvalidInputException(_inner) => {
                Some(_inner)
            }
            DeleteColumnStatisticsForPartitionErrorKind::OperationTimeoutException(_inner) => {
                Some(_inner)
            }
            DeleteColumnStatisticsForPartitionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteColumnStatisticsForTableError {
    pub kind: DeleteColumnStatisticsForTableErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteColumnStatisticsForTableErrorKind {
    EntityNotFoundException(crate::error::EntityNotFoundException),
    GlueEncryptionException(crate::error::GlueEncryptionException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteColumnStatisticsForTableError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteColumnStatisticsForTableErrorKind::EntityNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            DeleteColumnStatisticsForTableErrorKind::GlueEncryptionException(_inner) => {
                _inner.fmt(f)
            }
            DeleteColumnStatisticsForTableErrorKind::InternalServiceException(_inner) => {
                _inner.fmt(f)
            }
            DeleteColumnStatisticsForTableErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            DeleteColumnStatisticsForTableErrorKind::OperationTimeoutException(_inner) => {
                _inner.fmt(f)
            }
            DeleteColumnStatisticsForTableErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteColumnStatisticsForTableError {
    fn code(&self) -> Option<&str> {
        DeleteColumnStatisticsForTableError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteColumnStatisticsForTableError {
    pub fn new(kind: DeleteColumnStatisticsForTableErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteColumnStatisticsForTableErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteColumnStatisticsForTableErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteColumnStatisticsForTableErrorKind::EntityNotFoundException(_)
        )
    }
    pub fn is_glue_encryption_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteColumnStatisticsForTableErrorKind::GlueEncryptionException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteColumnStatisticsForTableErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteColumnStatisticsForTableErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteColumnStatisticsForTableErrorKind::OperationTimeoutException(_)
        )
    }
}
impl std::error::Error for DeleteColumnStatisticsForTableError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteColumnStatisticsForTableErrorKind::EntityNotFoundException(_inner) => {
                Some(_inner)
            }
            DeleteColumnStatisticsForTableErrorKind::GlueEncryptionException(_inner) => {
                Some(_inner)
            }
            DeleteColumnStatisticsForTableErrorKind::InternalServiceException(_inner) => {
                Some(_inner)
            }
            DeleteColumnStatisticsForTableErrorKind::InvalidInputException(_inner) => Some(_inner),
            DeleteColumnStatisticsForTableErrorKind::OperationTimeoutException(_inner) => {
                Some(_inner)
            }
            DeleteColumnStatisticsForTableErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteConnectionError {
    pub kind: DeleteConnectionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteConnectionErrorKind {
    EntityNotFoundException(crate::error::EntityNotFoundException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteConnectionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteConnectionErrorKind::EntityNotFoundException(_inner) => _inner.fmt(f),
            DeleteConnectionErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            DeleteConnectionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteConnectionError {
    fn code(&self) -> Option<&str> {
        DeleteConnectionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteConnectionError {
    pub fn new(kind: DeleteConnectionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteConnectionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteConnectionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteConnectionErrorKind::EntityNotFoundException(_)
        )
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteConnectionErrorKind::OperationTimeoutException(_)
        )
    }
}
impl std::error::Error for DeleteConnectionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteConnectionErrorKind::EntityNotFoundException(_inner) => Some(_inner),
            DeleteConnectionErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            DeleteConnectionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteCrawlerError {
    pub kind: DeleteCrawlerErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteCrawlerErrorKind {
    CrawlerRunningException(crate::error::CrawlerRunningException),
    EntityNotFoundException(crate::error::EntityNotFoundException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    SchedulerTransitioningException(crate::error::SchedulerTransitioningException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteCrawlerError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteCrawlerErrorKind::CrawlerRunningException(_inner) => _inner.fmt(f),
            DeleteCrawlerErrorKind::EntityNotFoundException(_inner) => _inner.fmt(f),
            DeleteCrawlerErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            DeleteCrawlerErrorKind::SchedulerTransitioningException(_inner) => _inner.fmt(f),
            DeleteCrawlerErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteCrawlerError {
    fn code(&self) -> Option<&str> {
        DeleteCrawlerError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteCrawlerError {
    pub fn new(kind: DeleteCrawlerErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteCrawlerErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteCrawlerErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_crawler_running_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteCrawlerErrorKind::CrawlerRunningException(_)
        )
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteCrawlerErrorKind::EntityNotFoundException(_)
        )
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteCrawlerErrorKind::OperationTimeoutException(_)
        )
    }
    pub fn is_scheduler_transitioning_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteCrawlerErrorKind::SchedulerTransitioningException(_)
        )
    }
}
impl std::error::Error for DeleteCrawlerError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteCrawlerErrorKind::CrawlerRunningException(_inner) => Some(_inner),
            DeleteCrawlerErrorKind::EntityNotFoundException(_inner) => Some(_inner),
            DeleteCrawlerErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            DeleteCrawlerErrorKind::SchedulerTransitioningException(_inner) => Some(_inner),
            DeleteCrawlerErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteDatabaseError {
    pub kind: DeleteDatabaseErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteDatabaseErrorKind {
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    EntityNotFoundException(crate::error::EntityNotFoundException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteDatabaseError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteDatabaseErrorKind::ConcurrentModificationException(_inner) => _inner.fmt(f),
            DeleteDatabaseErrorKind::EntityNotFoundException(_inner) => _inner.fmt(f),
            DeleteDatabaseErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            DeleteDatabaseErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            DeleteDatabaseErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            DeleteDatabaseErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteDatabaseError {
    fn code(&self) -> Option<&str> {
        DeleteDatabaseError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteDatabaseError {
    pub fn new(kind: DeleteDatabaseErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteDatabaseErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteDatabaseErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDatabaseErrorKind::ConcurrentModificationException(_)
        )
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDatabaseErrorKind::EntityNotFoundException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDatabaseErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDatabaseErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDatabaseErrorKind::OperationTimeoutException(_)
        )
    }
}
impl std::error::Error for DeleteDatabaseError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteDatabaseErrorKind::ConcurrentModificationException(_inner) => Some(_inner),
            DeleteDatabaseErrorKind::EntityNotFoundException(_inner) => Some(_inner),
            DeleteDatabaseErrorKind::InternalServiceException(_inner) => Some(_inner),
            DeleteDatabaseErrorKind::InvalidInputException(_inner) => Some(_inner),
            DeleteDatabaseErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            DeleteDatabaseErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteDevEndpointError {
    pub kind: DeleteDevEndpointErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteDevEndpointErrorKind {
    EntityNotFoundException(crate::error::EntityNotFoundException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteDevEndpointError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteDevEndpointErrorKind::EntityNotFoundException(_inner) => _inner.fmt(f),
            DeleteDevEndpointErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            DeleteDevEndpointErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            DeleteDevEndpointErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            DeleteDevEndpointErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteDevEndpointError {
    fn code(&self) -> Option<&str> {
        DeleteDevEndpointError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteDevEndpointError {
    pub fn new(kind: DeleteDevEndpointErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteDevEndpointErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteDevEndpointErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDevEndpointErrorKind::EntityNotFoundException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDevEndpointErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDevEndpointErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDevEndpointErrorKind::OperationTimeoutException(_)
        )
    }
}
impl std::error::Error for DeleteDevEndpointError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteDevEndpointErrorKind::EntityNotFoundException(_inner) => Some(_inner),
            DeleteDevEndpointErrorKind::InternalServiceException(_inner) => Some(_inner),
            DeleteDevEndpointErrorKind::InvalidInputException(_inner) => Some(_inner),
            DeleteDevEndpointErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            DeleteDevEndpointErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteJobError {
    pub kind: DeleteJobErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteJobErrorKind {
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteJobError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteJobErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            DeleteJobErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            DeleteJobErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            DeleteJobErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteJobError {
    fn code(&self) -> Option<&str> {
        DeleteJobError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteJobError {
    pub fn new(kind: DeleteJobErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteJobErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteJobErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(&self.kind, DeleteJobErrorKind::InternalServiceException(_))
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(&self.kind, DeleteJobErrorKind::InvalidInputException(_))
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(&self.kind, DeleteJobErrorKind::OperationTimeoutException(_))
    }
}
impl std::error::Error for DeleteJobError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteJobErrorKind::InternalServiceException(_inner) => Some(_inner),
            DeleteJobErrorKind::InvalidInputException(_inner) => Some(_inner),
            DeleteJobErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            DeleteJobErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteMLTransformError {
    pub kind: DeleteMLTransformErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteMLTransformErrorKind {
    EntityNotFoundException(crate::error::EntityNotFoundException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteMLTransformError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteMLTransformErrorKind::EntityNotFoundException(_inner) => _inner.fmt(f),
            DeleteMLTransformErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            DeleteMLTransformErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            DeleteMLTransformErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            DeleteMLTransformErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteMLTransformError {
    fn code(&self) -> Option<&str> {
        DeleteMLTransformError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteMLTransformError {
    pub fn new(kind: DeleteMLTransformErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteMLTransformErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteMLTransformErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteMLTransformErrorKind::EntityNotFoundException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteMLTransformErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteMLTransformErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteMLTransformErrorKind::OperationTimeoutException(_)
        )
    }
}
impl std::error::Error for DeleteMLTransformError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteMLTransformErrorKind::EntityNotFoundException(_inner) => Some(_inner),
            DeleteMLTransformErrorKind::InternalServiceException(_inner) => Some(_inner),
            DeleteMLTransformErrorKind::InvalidInputException(_inner) => Some(_inner),
            DeleteMLTransformErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            DeleteMLTransformErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeletePartitionError {
    pub kind: DeletePartitionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeletePartitionErrorKind {
    EntityNotFoundException(crate::error::EntityNotFoundException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeletePartitionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeletePartitionErrorKind::EntityNotFoundException(_inner) => _inner.fmt(f),
            DeletePartitionErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            DeletePartitionErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            DeletePartitionErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            DeletePartitionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeletePartitionError {
    fn code(&self) -> Option<&str> {
        DeletePartitionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeletePartitionError {
    pub fn new(kind: DeletePartitionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeletePartitionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeletePartitionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeletePartitionErrorKind::EntityNotFoundException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeletePartitionErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeletePartitionErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeletePartitionErrorKind::OperationTimeoutException(_)
        )
    }
}
impl std::error::Error for DeletePartitionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeletePartitionErrorKind::EntityNotFoundException(_inner) => Some(_inner),
            DeletePartitionErrorKind::InternalServiceException(_inner) => Some(_inner),
            DeletePartitionErrorKind::InvalidInputException(_inner) => Some(_inner),
            DeletePartitionErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            DeletePartitionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeletePartitionIndexError {
    pub kind: DeletePartitionIndexErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeletePartitionIndexErrorKind {
    ConflictException(crate::error::ConflictException),
    EntityNotFoundException(crate::error::EntityNotFoundException),
    GlueEncryptionException(crate::error::GlueEncryptionException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeletePartitionIndexError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeletePartitionIndexErrorKind::ConflictException(_inner) => _inner.fmt(f),
            DeletePartitionIndexErrorKind::EntityNotFoundException(_inner) => _inner.fmt(f),
            DeletePartitionIndexErrorKind::GlueEncryptionException(_inner) => _inner.fmt(f),
            DeletePartitionIndexErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            DeletePartitionIndexErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            DeletePartitionIndexErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            DeletePartitionIndexErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeletePartitionIndexError {
    fn code(&self) -> Option<&str> {
        DeletePartitionIndexError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeletePartitionIndexError {
    pub fn new(kind: DeletePartitionIndexErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeletePartitionIndexErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeletePartitionIndexErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeletePartitionIndexErrorKind::ConflictException(_)
        )
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeletePartitionIndexErrorKind::EntityNotFoundException(_)
        )
    }
    pub fn is_glue_encryption_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeletePartitionIndexErrorKind::GlueEncryptionException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeletePartitionIndexErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeletePartitionIndexErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeletePartitionIndexErrorKind::OperationTimeoutException(_)
        )
    }
}
impl std::error::Error for DeletePartitionIndexError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeletePartitionIndexErrorKind::ConflictException(_inner) => Some(_inner),
            DeletePartitionIndexErrorKind::EntityNotFoundException(_inner) => Some(_inner),
            DeletePartitionIndexErrorKind::GlueEncryptionException(_inner) => Some(_inner),
            DeletePartitionIndexErrorKind::InternalServiceException(_inner) => Some(_inner),
            DeletePartitionIndexErrorKind::InvalidInputException(_inner) => Some(_inner),
            DeletePartitionIndexErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            DeletePartitionIndexErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteRegistryError {
    pub kind: DeleteRegistryErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteRegistryErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    EntityNotFoundException(crate::error::EntityNotFoundException),
    InvalidInputException(crate::error::InvalidInputException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteRegistryError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteRegistryErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DeleteRegistryErrorKind::ConcurrentModificationException(_inner) => _inner.fmt(f),
            DeleteRegistryErrorKind::EntityNotFoundException(_inner) => _inner.fmt(f),
            DeleteRegistryErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            DeleteRegistryErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteRegistryError {
    fn code(&self) -> Option<&str> {
        DeleteRegistryError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteRegistryError {
    pub fn new(kind: DeleteRegistryErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteRegistryErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteRegistryErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRegistryErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRegistryErrorKind::ConcurrentModificationException(_)
        )
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRegistryErrorKind::EntityNotFoundException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRegistryErrorKind::InvalidInputException(_)
        )
    }
}
impl std::error::Error for DeleteRegistryError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteRegistryErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DeleteRegistryErrorKind::ConcurrentModificationException(_inner) => Some(_inner),
            DeleteRegistryErrorKind::EntityNotFoundException(_inner) => Some(_inner),
            DeleteRegistryErrorKind::InvalidInputException(_inner) => Some(_inner),
            DeleteRegistryErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteResourcePolicyError {
    pub kind: DeleteResourcePolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteResourcePolicyErrorKind {
    ConditionCheckFailureException(crate::error::ConditionCheckFailureException),
    EntityNotFoundException(crate::error::EntityNotFoundException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteResourcePolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteResourcePolicyErrorKind::ConditionCheckFailureException(_inner) => _inner.fmt(f),
            DeleteResourcePolicyErrorKind::EntityNotFoundException(_inner) => _inner.fmt(f),
            DeleteResourcePolicyErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            DeleteResourcePolicyErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            DeleteResourcePolicyErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            DeleteResourcePolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteResourcePolicyError {
    fn code(&self) -> Option<&str> {
        DeleteResourcePolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteResourcePolicyError {
    pub fn new(kind: DeleteResourcePolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteResourcePolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteResourcePolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_condition_check_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteResourcePolicyErrorKind::ConditionCheckFailureException(_)
        )
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteResourcePolicyErrorKind::EntityNotFoundException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteResourcePolicyErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteResourcePolicyErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteResourcePolicyErrorKind::OperationTimeoutException(_)
        )
    }
}
impl std::error::Error for DeleteResourcePolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteResourcePolicyErrorKind::ConditionCheckFailureException(_inner) => Some(_inner),
            DeleteResourcePolicyErrorKind::EntityNotFoundException(_inner) => Some(_inner),
            DeleteResourcePolicyErrorKind::InternalServiceException(_inner) => Some(_inner),
            DeleteResourcePolicyErrorKind::InvalidInputException(_inner) => Some(_inner),
            DeleteResourcePolicyErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            DeleteResourcePolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteSchemaError {
    pub kind: DeleteSchemaErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteSchemaErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    EntityNotFoundException(crate::error::EntityNotFoundException),
    InvalidInputException(crate::error::InvalidInputException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteSchemaError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteSchemaErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DeleteSchemaErrorKind::ConcurrentModificationException(_inner) => _inner.fmt(f),
            DeleteSchemaErrorKind::EntityNotFoundException(_inner) => _inner.fmt(f),
            DeleteSchemaErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            DeleteSchemaErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteSchemaError {
    fn code(&self) -> Option<&str> {
        DeleteSchemaError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteSchemaError {
    pub fn new(kind: DeleteSchemaErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteSchemaErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteSchemaErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, DeleteSchemaErrorKind::AccessDeniedException(_))
    }
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteSchemaErrorKind::ConcurrentModificationException(_)
        )
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteSchemaErrorKind::EntityNotFoundException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(&self.kind, DeleteSchemaErrorKind::InvalidInputException(_))
    }
}
impl std::error::Error for DeleteSchemaError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteSchemaErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DeleteSchemaErrorKind::ConcurrentModificationException(_inner) => Some(_inner),
            DeleteSchemaErrorKind::EntityNotFoundException(_inner) => Some(_inner),
            DeleteSchemaErrorKind::InvalidInputException(_inner) => Some(_inner),
            DeleteSchemaErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteSchemaVersionsError {
    pub kind: DeleteSchemaVersionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteSchemaVersionsErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    EntityNotFoundException(crate::error::EntityNotFoundException),
    InvalidInputException(crate::error::InvalidInputException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteSchemaVersionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteSchemaVersionsErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DeleteSchemaVersionsErrorKind::ConcurrentModificationException(_inner) => _inner.fmt(f),
            DeleteSchemaVersionsErrorKind::EntityNotFoundException(_inner) => _inner.fmt(f),
            DeleteSchemaVersionsErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            DeleteSchemaVersionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteSchemaVersionsError {
    fn code(&self) -> Option<&str> {
        DeleteSchemaVersionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteSchemaVersionsError {
    pub fn new(kind: DeleteSchemaVersionsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteSchemaVersionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteSchemaVersionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteSchemaVersionsErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteSchemaVersionsErrorKind::ConcurrentModificationException(_)
        )
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteSchemaVersionsErrorKind::EntityNotFoundException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteSchemaVersionsErrorKind::InvalidInputException(_)
        )
    }
}
impl std::error::Error for DeleteSchemaVersionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteSchemaVersionsErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DeleteSchemaVersionsErrorKind::ConcurrentModificationException(_inner) => Some(_inner),
            DeleteSchemaVersionsErrorKind::EntityNotFoundException(_inner) => Some(_inner),
            DeleteSchemaVersionsErrorKind::InvalidInputException(_inner) => Some(_inner),
            DeleteSchemaVersionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteSecurityConfigurationError {
    pub kind: DeleteSecurityConfigurationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteSecurityConfigurationErrorKind {
    EntityNotFoundException(crate::error::EntityNotFoundException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteSecurityConfigurationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteSecurityConfigurationErrorKind::EntityNotFoundException(_inner) => _inner.fmt(f),
            DeleteSecurityConfigurationErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            DeleteSecurityConfigurationErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            DeleteSecurityConfigurationErrorKind::OperationTimeoutException(_inner) => {
                _inner.fmt(f)
            }
            DeleteSecurityConfigurationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteSecurityConfigurationError {
    fn code(&self) -> Option<&str> {
        DeleteSecurityConfigurationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteSecurityConfigurationError {
    pub fn new(kind: DeleteSecurityConfigurationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteSecurityConfigurationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteSecurityConfigurationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteSecurityConfigurationErrorKind::EntityNotFoundException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteSecurityConfigurationErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteSecurityConfigurationErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteSecurityConfigurationErrorKind::OperationTimeoutException(_)
        )
    }
}
impl std::error::Error for DeleteSecurityConfigurationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteSecurityConfigurationErrorKind::EntityNotFoundException(_inner) => Some(_inner),
            DeleteSecurityConfigurationErrorKind::InternalServiceException(_inner) => Some(_inner),
            DeleteSecurityConfigurationErrorKind::InvalidInputException(_inner) => Some(_inner),
            DeleteSecurityConfigurationErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            DeleteSecurityConfigurationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteTableError {
    pub kind: DeleteTableErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteTableErrorKind {
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    EntityNotFoundException(crate::error::EntityNotFoundException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteTableError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteTableErrorKind::ConcurrentModificationException(_inner) => _inner.fmt(f),
            DeleteTableErrorKind::EntityNotFoundException(_inner) => _inner.fmt(f),
            DeleteTableErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            DeleteTableErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            DeleteTableErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            DeleteTableErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteTableError {
    fn code(&self) -> Option<&str> {
        DeleteTableError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteTableError {
    pub fn new(kind: DeleteTableErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteTableErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteTableErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteTableErrorKind::ConcurrentModificationException(_)
        )
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(&self.kind, DeleteTableErrorKind::EntityNotFoundException(_))
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteTableErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(&self.kind, DeleteTableErrorKind::InvalidInputException(_))
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteTableErrorKind::OperationTimeoutException(_)
        )
    }
}
impl std::error::Error for DeleteTableError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteTableErrorKind::ConcurrentModificationException(_inner) => Some(_inner),
            DeleteTableErrorKind::EntityNotFoundException(_inner) => Some(_inner),
            DeleteTableErrorKind::InternalServiceException(_inner) => Some(_inner),
            DeleteTableErrorKind::InvalidInputException(_inner) => Some(_inner),
            DeleteTableErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            DeleteTableErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteTableVersionError {
    pub kind: DeleteTableVersionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteTableVersionErrorKind {
    EntityNotFoundException(crate::error::EntityNotFoundException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteTableVersionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteTableVersionErrorKind::EntityNotFoundException(_inner) => _inner.fmt(f),
            DeleteTableVersionErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            DeleteTableVersionErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            DeleteTableVersionErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            DeleteTableVersionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteTableVersionError {
    fn code(&self) -> Option<&str> {
        DeleteTableVersionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteTableVersionError {
    pub fn new(kind: DeleteTableVersionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteTableVersionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteTableVersionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteTableVersionErrorKind::EntityNotFoundException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteTableVersionErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteTableVersionErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteTableVersionErrorKind::OperationTimeoutException(_)
        )
    }
}
impl std::error::Error for DeleteTableVersionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteTableVersionErrorKind::EntityNotFoundException(_inner) => Some(_inner),
            DeleteTableVersionErrorKind::InternalServiceException(_inner) => Some(_inner),
            DeleteTableVersionErrorKind::InvalidInputException(_inner) => Some(_inner),
            DeleteTableVersionErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            DeleteTableVersionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteTriggerError {
    pub kind: DeleteTriggerErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteTriggerErrorKind {
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteTriggerError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteTriggerErrorKind::ConcurrentModificationException(_inner) => _inner.fmt(f),
            DeleteTriggerErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            DeleteTriggerErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            DeleteTriggerErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            DeleteTriggerErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteTriggerError {
    fn code(&self) -> Option<&str> {
        DeleteTriggerError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteTriggerError {
    pub fn new(kind: DeleteTriggerErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteTriggerErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteTriggerErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteTriggerErrorKind::ConcurrentModificationException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteTriggerErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(&self.kind, DeleteTriggerErrorKind::InvalidInputException(_))
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteTriggerErrorKind::OperationTimeoutException(_)
        )
    }
}
impl std::error::Error for DeleteTriggerError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteTriggerErrorKind::ConcurrentModificationException(_inner) => Some(_inner),
            DeleteTriggerErrorKind::InternalServiceException(_inner) => Some(_inner),
            DeleteTriggerErrorKind::InvalidInputException(_inner) => Some(_inner),
            DeleteTriggerErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            DeleteTriggerErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteUserDefinedFunctionError {
    pub kind: DeleteUserDefinedFunctionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteUserDefinedFunctionErrorKind {
    EntityNotFoundException(crate::error::EntityNotFoundException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteUserDefinedFunctionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteUserDefinedFunctionErrorKind::EntityNotFoundException(_inner) => _inner.fmt(f),
            DeleteUserDefinedFunctionErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            DeleteUserDefinedFunctionErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            DeleteUserDefinedFunctionErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            DeleteUserDefinedFunctionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteUserDefinedFunctionError {
    fn code(&self) -> Option<&str> {
        DeleteUserDefinedFunctionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteUserDefinedFunctionError {
    pub fn new(kind: DeleteUserDefinedFunctionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteUserDefinedFunctionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteUserDefinedFunctionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteUserDefinedFunctionErrorKind::EntityNotFoundException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteUserDefinedFunctionErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteUserDefinedFunctionErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteUserDefinedFunctionErrorKind::OperationTimeoutException(_)
        )
    }
}
impl std::error::Error for DeleteUserDefinedFunctionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteUserDefinedFunctionErrorKind::EntityNotFoundException(_inner) => Some(_inner),
            DeleteUserDefinedFunctionErrorKind::InternalServiceException(_inner) => Some(_inner),
            DeleteUserDefinedFunctionErrorKind::InvalidInputException(_inner) => Some(_inner),
            DeleteUserDefinedFunctionErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            DeleteUserDefinedFunctionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteWorkflowError {
    pub kind: DeleteWorkflowErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteWorkflowErrorKind {
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteWorkflowError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteWorkflowErrorKind::ConcurrentModificationException(_inner) => _inner.fmt(f),
            DeleteWorkflowErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            DeleteWorkflowErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            DeleteWorkflowErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            DeleteWorkflowErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteWorkflowError {
    fn code(&self) -> Option<&str> {
        DeleteWorkflowError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteWorkflowError {
    pub fn new(kind: DeleteWorkflowErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteWorkflowErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteWorkflowErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteWorkflowErrorKind::ConcurrentModificationException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteWorkflowErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteWorkflowErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteWorkflowErrorKind::OperationTimeoutException(_)
        )
    }
}
impl std::error::Error for DeleteWorkflowError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteWorkflowErrorKind::ConcurrentModificationException(_inner) => Some(_inner),
            DeleteWorkflowErrorKind::InternalServiceException(_inner) => Some(_inner),
            DeleteWorkflowErrorKind::InvalidInputException(_inner) => Some(_inner),
            DeleteWorkflowErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            DeleteWorkflowErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetBlueprintError {
    pub kind: GetBlueprintErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetBlueprintErrorKind {
    EntityNotFoundException(crate::error::EntityNotFoundException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetBlueprintError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetBlueprintErrorKind::EntityNotFoundException(_inner) => _inner.fmt(f),
            GetBlueprintErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            GetBlueprintErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            GetBlueprintErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            GetBlueprintErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetBlueprintError {
    fn code(&self) -> Option<&str> {
        GetBlueprintError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetBlueprintError {
    pub fn new(kind: GetBlueprintErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetBlueprintErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetBlueprintErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBlueprintErrorKind::EntityNotFoundException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBlueprintErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(&self.kind, GetBlueprintErrorKind::InvalidInputException(_))
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBlueprintErrorKind::OperationTimeoutException(_)
        )
    }
}
impl std::error::Error for GetBlueprintError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetBlueprintErrorKind::EntityNotFoundException(_inner) => Some(_inner),
            GetBlueprintErrorKind::InternalServiceException(_inner) => Some(_inner),
            GetBlueprintErrorKind::InvalidInputException(_inner) => Some(_inner),
            GetBlueprintErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            GetBlueprintErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetBlueprintRunError {
    pub kind: GetBlueprintRunErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetBlueprintRunErrorKind {
    EntityNotFoundException(crate::error::EntityNotFoundException),
    InternalServiceException(crate::error::InternalServiceException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetBlueprintRunError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetBlueprintRunErrorKind::EntityNotFoundException(_inner) => _inner.fmt(f),
            GetBlueprintRunErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            GetBlueprintRunErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            GetBlueprintRunErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetBlueprintRunError {
    fn code(&self) -> Option<&str> {
        GetBlueprintRunError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetBlueprintRunError {
    pub fn new(kind: GetBlueprintRunErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetBlueprintRunErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetBlueprintRunErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBlueprintRunErrorKind::EntityNotFoundException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBlueprintRunErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBlueprintRunErrorKind::OperationTimeoutException(_)
        )
    }
}
impl std::error::Error for GetBlueprintRunError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetBlueprintRunErrorKind::EntityNotFoundException(_inner) => Some(_inner),
            GetBlueprintRunErrorKind::InternalServiceException(_inner) => Some(_inner),
            GetBlueprintRunErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            GetBlueprintRunErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetBlueprintRunsError {
    pub kind: GetBlueprintRunsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetBlueprintRunsErrorKind {
    EntityNotFoundException(crate::error::EntityNotFoundException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetBlueprintRunsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetBlueprintRunsErrorKind::EntityNotFoundException(_inner) => _inner.fmt(f),
            GetBlueprintRunsErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            GetBlueprintRunsErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            GetBlueprintRunsErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            GetBlueprintRunsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetBlueprintRunsError {
    fn code(&self) -> Option<&str> {
        GetBlueprintRunsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetBlueprintRunsError {
    pub fn new(kind: GetBlueprintRunsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetBlueprintRunsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetBlueprintRunsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBlueprintRunsErrorKind::EntityNotFoundException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBlueprintRunsErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBlueprintRunsErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBlueprintRunsErrorKind::OperationTimeoutException(_)
        )
    }
}
impl std::error::Error for GetBlueprintRunsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetBlueprintRunsErrorKind::EntityNotFoundException(_inner) => Some(_inner),
            GetBlueprintRunsErrorKind::InternalServiceException(_inner) => Some(_inner),
            GetBlueprintRunsErrorKind::InvalidInputException(_inner) => Some(_inner),
            GetBlueprintRunsErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            GetBlueprintRunsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetCatalogImportStatusError {
    pub kind: GetCatalogImportStatusErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetCatalogImportStatusErrorKind {
    InternalServiceException(crate::error::InternalServiceException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetCatalogImportStatusError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetCatalogImportStatusErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            GetCatalogImportStatusErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            GetCatalogImportStatusErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetCatalogImportStatusError {
    fn code(&self) -> Option<&str> {
        GetCatalogImportStatusError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetCatalogImportStatusError {
    pub fn new(kind: GetCatalogImportStatusErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetCatalogImportStatusErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetCatalogImportStatusErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCatalogImportStatusErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCatalogImportStatusErrorKind::OperationTimeoutException(_)
        )
    }
}
impl std::error::Error for GetCatalogImportStatusError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetCatalogImportStatusErrorKind::InternalServiceException(_inner) => Some(_inner),
            GetCatalogImportStatusErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            GetCatalogImportStatusErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetClassifierError {
    pub kind: GetClassifierErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetClassifierErrorKind {
    EntityNotFoundException(crate::error::EntityNotFoundException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetClassifierError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetClassifierErrorKind::EntityNotFoundException(_inner) => _inner.fmt(f),
            GetClassifierErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            GetClassifierErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetClassifierError {
    fn code(&self) -> Option<&str> {
        GetClassifierError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetClassifierError {
    pub fn new(kind: GetClassifierErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetClassifierErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetClassifierErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetClassifierErrorKind::EntityNotFoundException(_)
        )
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetClassifierErrorKind::OperationTimeoutException(_)
        )
    }
}
impl std::error::Error for GetClassifierError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetClassifierErrorKind::EntityNotFoundException(_inner) => Some(_inner),
            GetClassifierErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            GetClassifierErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetClassifiersError {
    pub kind: GetClassifiersErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetClassifiersErrorKind {
    OperationTimeoutException(crate::error::OperationTimeoutException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetClassifiersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetClassifiersErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            GetClassifiersErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetClassifiersError {
    fn code(&self) -> Option<&str> {
        GetClassifiersError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetClassifiersError {
    pub fn new(kind: GetClassifiersErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetClassifiersErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetClassifiersErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetClassifiersErrorKind::OperationTimeoutException(_)
        )
    }
}
impl std::error::Error for GetClassifiersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetClassifiersErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            GetClassifiersErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetColumnStatisticsForPartitionError {
    pub kind: GetColumnStatisticsForPartitionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetColumnStatisticsForPartitionErrorKind {
    EntityNotFoundException(crate::error::EntityNotFoundException),
    GlueEncryptionException(crate::error::GlueEncryptionException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetColumnStatisticsForPartitionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetColumnStatisticsForPartitionErrorKind::EntityNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            GetColumnStatisticsForPartitionErrorKind::GlueEncryptionException(_inner) => {
                _inner.fmt(f)
            }
            GetColumnStatisticsForPartitionErrorKind::InternalServiceException(_inner) => {
                _inner.fmt(f)
            }
            GetColumnStatisticsForPartitionErrorKind::InvalidInputException(_inner) => {
                _inner.fmt(f)
            }
            GetColumnStatisticsForPartitionErrorKind::OperationTimeoutException(_inner) => {
                _inner.fmt(f)
            }
            GetColumnStatisticsForPartitionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetColumnStatisticsForPartitionError {
    fn code(&self) -> Option<&str> {
        GetColumnStatisticsForPartitionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetColumnStatisticsForPartitionError {
    pub fn new(kind: GetColumnStatisticsForPartitionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetColumnStatisticsForPartitionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetColumnStatisticsForPartitionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetColumnStatisticsForPartitionErrorKind::EntityNotFoundException(_)
        )
    }
    pub fn is_glue_encryption_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetColumnStatisticsForPartitionErrorKind::GlueEncryptionException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetColumnStatisticsForPartitionErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetColumnStatisticsForPartitionErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetColumnStatisticsForPartitionErrorKind::OperationTimeoutException(_)
        )
    }
}
impl std::error::Error for GetColumnStatisticsForPartitionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetColumnStatisticsForPartitionErrorKind::EntityNotFoundException(_inner) => {
                Some(_inner)
            }
            GetColumnStatisticsForPartitionErrorKind::GlueEncryptionException(_inner) => {
                Some(_inner)
            }
            GetColumnStatisticsForPartitionErrorKind::InternalServiceException(_inner) => {
                Some(_inner)
            }
            GetColumnStatisticsForPartitionErrorKind::InvalidInputException(_inner) => Some(_inner),
            GetColumnStatisticsForPartitionErrorKind::OperationTimeoutException(_inner) => {
                Some(_inner)
            }
            GetColumnStatisticsForPartitionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetColumnStatisticsForTableError {
    pub kind: GetColumnStatisticsForTableErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetColumnStatisticsForTableErrorKind {
    EntityNotFoundException(crate::error::EntityNotFoundException),
    GlueEncryptionException(crate::error::GlueEncryptionException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetColumnStatisticsForTableError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetColumnStatisticsForTableErrorKind::EntityNotFoundException(_inner) => _inner.fmt(f),
            GetColumnStatisticsForTableErrorKind::GlueEncryptionException(_inner) => _inner.fmt(f),
            GetColumnStatisticsForTableErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            GetColumnStatisticsForTableErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            GetColumnStatisticsForTableErrorKind::OperationTimeoutException(_inner) => {
                _inner.fmt(f)
            }
            GetColumnStatisticsForTableErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetColumnStatisticsForTableError {
    fn code(&self) -> Option<&str> {
        GetColumnStatisticsForTableError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetColumnStatisticsForTableError {
    pub fn new(kind: GetColumnStatisticsForTableErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetColumnStatisticsForTableErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetColumnStatisticsForTableErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetColumnStatisticsForTableErrorKind::EntityNotFoundException(_)
        )
    }
    pub fn is_glue_encryption_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetColumnStatisticsForTableErrorKind::GlueEncryptionException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetColumnStatisticsForTableErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetColumnStatisticsForTableErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetColumnStatisticsForTableErrorKind::OperationTimeoutException(_)
        )
    }
}
impl std::error::Error for GetColumnStatisticsForTableError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetColumnStatisticsForTableErrorKind::EntityNotFoundException(_inner) => Some(_inner),
            GetColumnStatisticsForTableErrorKind::GlueEncryptionException(_inner) => Some(_inner),
            GetColumnStatisticsForTableErrorKind::InternalServiceException(_inner) => Some(_inner),
            GetColumnStatisticsForTableErrorKind::InvalidInputException(_inner) => Some(_inner),
            GetColumnStatisticsForTableErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            GetColumnStatisticsForTableErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetConnectionError {
    pub kind: GetConnectionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetConnectionErrorKind {
    EntityNotFoundException(crate::error::EntityNotFoundException),
    GlueEncryptionException(crate::error::GlueEncryptionException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetConnectionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetConnectionErrorKind::EntityNotFoundException(_inner) => _inner.fmt(f),
            GetConnectionErrorKind::GlueEncryptionException(_inner) => _inner.fmt(f),
            GetConnectionErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            GetConnectionErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            GetConnectionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetConnectionError {
    fn code(&self) -> Option<&str> {
        GetConnectionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetConnectionError {
    pub fn new(kind: GetConnectionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetConnectionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetConnectionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetConnectionErrorKind::EntityNotFoundException(_)
        )
    }
    pub fn is_glue_encryption_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetConnectionErrorKind::GlueEncryptionException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(&self.kind, GetConnectionErrorKind::InvalidInputException(_))
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetConnectionErrorKind::OperationTimeoutException(_)
        )
    }
}
impl std::error::Error for GetConnectionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetConnectionErrorKind::EntityNotFoundException(_inner) => Some(_inner),
            GetConnectionErrorKind::GlueEncryptionException(_inner) => Some(_inner),
            GetConnectionErrorKind::InvalidInputException(_inner) => Some(_inner),
            GetConnectionErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            GetConnectionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetConnectionsError {
    pub kind: GetConnectionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetConnectionsErrorKind {
    EntityNotFoundException(crate::error::EntityNotFoundException),
    GlueEncryptionException(crate::error::GlueEncryptionException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetConnectionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetConnectionsErrorKind::EntityNotFoundException(_inner) => _inner.fmt(f),
            GetConnectionsErrorKind::GlueEncryptionException(_inner) => _inner.fmt(f),
            GetConnectionsErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            GetConnectionsErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            GetConnectionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetConnectionsError {
    fn code(&self) -> Option<&str> {
        GetConnectionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetConnectionsError {
    pub fn new(kind: GetConnectionsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetConnectionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetConnectionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetConnectionsErrorKind::EntityNotFoundException(_)
        )
    }
    pub fn is_glue_encryption_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetConnectionsErrorKind::GlueEncryptionException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetConnectionsErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetConnectionsErrorKind::OperationTimeoutException(_)
        )
    }
}
impl std::error::Error for GetConnectionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetConnectionsErrorKind::EntityNotFoundException(_inner) => Some(_inner),
            GetConnectionsErrorKind::GlueEncryptionException(_inner) => Some(_inner),
            GetConnectionsErrorKind::InvalidInputException(_inner) => Some(_inner),
            GetConnectionsErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            GetConnectionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetCrawlerError {
    pub kind: GetCrawlerErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetCrawlerErrorKind {
    EntityNotFoundException(crate::error::EntityNotFoundException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetCrawlerError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetCrawlerErrorKind::EntityNotFoundException(_inner) => _inner.fmt(f),
            GetCrawlerErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            GetCrawlerErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetCrawlerError {
    fn code(&self) -> Option<&str> {
        GetCrawlerError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetCrawlerError {
    pub fn new(kind: GetCrawlerErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetCrawlerErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetCrawlerErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetCrawlerErrorKind::EntityNotFoundException(_))
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCrawlerErrorKind::OperationTimeoutException(_)
        )
    }
}
impl std::error::Error for GetCrawlerError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetCrawlerErrorKind::EntityNotFoundException(_inner) => Some(_inner),
            GetCrawlerErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            GetCrawlerErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetCrawlerMetricsError {
    pub kind: GetCrawlerMetricsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetCrawlerMetricsErrorKind {
    OperationTimeoutException(crate::error::OperationTimeoutException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetCrawlerMetricsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetCrawlerMetricsErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            GetCrawlerMetricsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetCrawlerMetricsError {
    fn code(&self) -> Option<&str> {
        GetCrawlerMetricsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetCrawlerMetricsError {
    pub fn new(kind: GetCrawlerMetricsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetCrawlerMetricsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetCrawlerMetricsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCrawlerMetricsErrorKind::OperationTimeoutException(_)
        )
    }
}
impl std::error::Error for GetCrawlerMetricsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetCrawlerMetricsErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            GetCrawlerMetricsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetCrawlersError {
    pub kind: GetCrawlersErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetCrawlersErrorKind {
    OperationTimeoutException(crate::error::OperationTimeoutException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetCrawlersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetCrawlersErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            GetCrawlersErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetCrawlersError {
    fn code(&self) -> Option<&str> {
        GetCrawlersError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetCrawlersError {
    pub fn new(kind: GetCrawlersErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetCrawlersErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetCrawlersErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCrawlersErrorKind::OperationTimeoutException(_)
        )
    }
}
impl std::error::Error for GetCrawlersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetCrawlersErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            GetCrawlersErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetDatabaseError {
    pub kind: GetDatabaseErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetDatabaseErrorKind {
    EntityNotFoundException(crate::error::EntityNotFoundException),
    GlueEncryptionException(crate::error::GlueEncryptionException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetDatabaseError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetDatabaseErrorKind::EntityNotFoundException(_inner) => _inner.fmt(f),
            GetDatabaseErrorKind::GlueEncryptionException(_inner) => _inner.fmt(f),
            GetDatabaseErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            GetDatabaseErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            GetDatabaseErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            GetDatabaseErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetDatabaseError {
    fn code(&self) -> Option<&str> {
        GetDatabaseError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetDatabaseError {
    pub fn new(kind: GetDatabaseErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetDatabaseErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetDatabaseErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetDatabaseErrorKind::EntityNotFoundException(_))
    }
    pub fn is_glue_encryption_exception(&self) -> bool {
        matches!(&self.kind, GetDatabaseErrorKind::GlueEncryptionException(_))
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDatabaseErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(&self.kind, GetDatabaseErrorKind::InvalidInputException(_))
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDatabaseErrorKind::OperationTimeoutException(_)
        )
    }
}
impl std::error::Error for GetDatabaseError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetDatabaseErrorKind::EntityNotFoundException(_inner) => Some(_inner),
            GetDatabaseErrorKind::GlueEncryptionException(_inner) => Some(_inner),
            GetDatabaseErrorKind::InternalServiceException(_inner) => Some(_inner),
            GetDatabaseErrorKind::InvalidInputException(_inner) => Some(_inner),
            GetDatabaseErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            GetDatabaseErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetDatabasesError {
    pub kind: GetDatabasesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetDatabasesErrorKind {
    GlueEncryptionException(crate::error::GlueEncryptionException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetDatabasesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetDatabasesErrorKind::GlueEncryptionException(_inner) => _inner.fmt(f),
            GetDatabasesErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            GetDatabasesErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            GetDatabasesErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            GetDatabasesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetDatabasesError {
    fn code(&self) -> Option<&str> {
        GetDatabasesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetDatabasesError {
    pub fn new(kind: GetDatabasesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetDatabasesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetDatabasesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_glue_encryption_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDatabasesErrorKind::GlueEncryptionException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDatabasesErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(&self.kind, GetDatabasesErrorKind::InvalidInputException(_))
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDatabasesErrorKind::OperationTimeoutException(_)
        )
    }
}
impl std::error::Error for GetDatabasesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetDatabasesErrorKind::GlueEncryptionException(_inner) => Some(_inner),
            GetDatabasesErrorKind::InternalServiceException(_inner) => Some(_inner),
            GetDatabasesErrorKind::InvalidInputException(_inner) => Some(_inner),
            GetDatabasesErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            GetDatabasesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetDataCatalogEncryptionSettingsError {
    pub kind: GetDataCatalogEncryptionSettingsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetDataCatalogEncryptionSettingsErrorKind {
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetDataCatalogEncryptionSettingsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetDataCatalogEncryptionSettingsErrorKind::InternalServiceException(_inner) => {
                _inner.fmt(f)
            }
            GetDataCatalogEncryptionSettingsErrorKind::InvalidInputException(_inner) => {
                _inner.fmt(f)
            }
            GetDataCatalogEncryptionSettingsErrorKind::OperationTimeoutException(_inner) => {
                _inner.fmt(f)
            }
            GetDataCatalogEncryptionSettingsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetDataCatalogEncryptionSettingsError {
    fn code(&self) -> Option<&str> {
        GetDataCatalogEncryptionSettingsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetDataCatalogEncryptionSettingsError {
    pub fn new(kind: GetDataCatalogEncryptionSettingsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetDataCatalogEncryptionSettingsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetDataCatalogEncryptionSettingsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDataCatalogEncryptionSettingsErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDataCatalogEncryptionSettingsErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDataCatalogEncryptionSettingsErrorKind::OperationTimeoutException(_)
        )
    }
}
impl std::error::Error for GetDataCatalogEncryptionSettingsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetDataCatalogEncryptionSettingsErrorKind::InternalServiceException(_inner) => {
                Some(_inner)
            }
            GetDataCatalogEncryptionSettingsErrorKind::InvalidInputException(_inner) => {
                Some(_inner)
            }
            GetDataCatalogEncryptionSettingsErrorKind::OperationTimeoutException(_inner) => {
                Some(_inner)
            }
            GetDataCatalogEncryptionSettingsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetDataflowGraphError {
    pub kind: GetDataflowGraphErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetDataflowGraphErrorKind {
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetDataflowGraphError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetDataflowGraphErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            GetDataflowGraphErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            GetDataflowGraphErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            GetDataflowGraphErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetDataflowGraphError {
    fn code(&self) -> Option<&str> {
        GetDataflowGraphError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetDataflowGraphError {
    pub fn new(kind: GetDataflowGraphErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetDataflowGraphErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetDataflowGraphErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDataflowGraphErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDataflowGraphErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDataflowGraphErrorKind::OperationTimeoutException(_)
        )
    }
}
impl std::error::Error for GetDataflowGraphError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetDataflowGraphErrorKind::InternalServiceException(_inner) => Some(_inner),
            GetDataflowGraphErrorKind::InvalidInputException(_inner) => Some(_inner),
            GetDataflowGraphErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            GetDataflowGraphErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetDevEndpointError {
    pub kind: GetDevEndpointErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetDevEndpointErrorKind {
    EntityNotFoundException(crate::error::EntityNotFoundException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetDevEndpointError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetDevEndpointErrorKind::EntityNotFoundException(_inner) => _inner.fmt(f),
            GetDevEndpointErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            GetDevEndpointErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            GetDevEndpointErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            GetDevEndpointErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetDevEndpointError {
    fn code(&self) -> Option<&str> {
        GetDevEndpointError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetDevEndpointError {
    pub fn new(kind: GetDevEndpointErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetDevEndpointErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetDevEndpointErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDevEndpointErrorKind::EntityNotFoundException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDevEndpointErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDevEndpointErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDevEndpointErrorKind::OperationTimeoutException(_)
        )
    }
}
impl std::error::Error for GetDevEndpointError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetDevEndpointErrorKind::EntityNotFoundException(_inner) => Some(_inner),
            GetDevEndpointErrorKind::InternalServiceException(_inner) => Some(_inner),
            GetDevEndpointErrorKind::InvalidInputException(_inner) => Some(_inner),
            GetDevEndpointErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            GetDevEndpointErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetDevEndpointsError {
    pub kind: GetDevEndpointsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetDevEndpointsErrorKind {
    EntityNotFoundException(crate::error::EntityNotFoundException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetDevEndpointsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetDevEndpointsErrorKind::EntityNotFoundException(_inner) => _inner.fmt(f),
            GetDevEndpointsErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            GetDevEndpointsErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            GetDevEndpointsErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            GetDevEndpointsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetDevEndpointsError {
    fn code(&self) -> Option<&str> {
        GetDevEndpointsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetDevEndpointsError {
    pub fn new(kind: GetDevEndpointsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetDevEndpointsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetDevEndpointsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDevEndpointsErrorKind::EntityNotFoundException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDevEndpointsErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDevEndpointsErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDevEndpointsErrorKind::OperationTimeoutException(_)
        )
    }
}
impl std::error::Error for GetDevEndpointsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetDevEndpointsErrorKind::EntityNotFoundException(_inner) => Some(_inner),
            GetDevEndpointsErrorKind::InternalServiceException(_inner) => Some(_inner),
            GetDevEndpointsErrorKind::InvalidInputException(_inner) => Some(_inner),
            GetDevEndpointsErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            GetDevEndpointsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetJobError {
    pub kind: GetJobErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetJobErrorKind {
    EntityNotFoundException(crate::error::EntityNotFoundException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetJobError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetJobErrorKind::EntityNotFoundException(_inner) => _inner.fmt(f),
            GetJobErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            GetJobErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            GetJobErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            GetJobErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetJobError {
    fn code(&self) -> Option<&str> {
        GetJobError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetJobError {
    pub fn new(kind: GetJobErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetJobErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetJobErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetJobErrorKind::EntityNotFoundException(_))
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(&self.kind, GetJobErrorKind::InternalServiceException(_))
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(&self.kind, GetJobErrorKind::InvalidInputException(_))
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(&self.kind, GetJobErrorKind::OperationTimeoutException(_))
    }
}
impl std::error::Error for GetJobError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetJobErrorKind::EntityNotFoundException(_inner) => Some(_inner),
            GetJobErrorKind::InternalServiceException(_inner) => Some(_inner),
            GetJobErrorKind::InvalidInputException(_inner) => Some(_inner),
            GetJobErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            GetJobErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetJobBookmarkError {
    pub kind: GetJobBookmarkErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetJobBookmarkErrorKind {
    EntityNotFoundException(crate::error::EntityNotFoundException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetJobBookmarkError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetJobBookmarkErrorKind::EntityNotFoundException(_inner) => _inner.fmt(f),
            GetJobBookmarkErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            GetJobBookmarkErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            GetJobBookmarkErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            GetJobBookmarkErrorKind::ValidationException(_inner) => _inner.fmt(f),
            GetJobBookmarkErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetJobBookmarkError {
    fn code(&self) -> Option<&str> {
        GetJobBookmarkError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetJobBookmarkError {
    pub fn new(kind: GetJobBookmarkErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetJobBookmarkErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetJobBookmarkErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetJobBookmarkErrorKind::EntityNotFoundException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetJobBookmarkErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetJobBookmarkErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetJobBookmarkErrorKind::OperationTimeoutException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, GetJobBookmarkErrorKind::ValidationException(_))
    }
}
impl std::error::Error for GetJobBookmarkError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetJobBookmarkErrorKind::EntityNotFoundException(_inner) => Some(_inner),
            GetJobBookmarkErrorKind::InternalServiceException(_inner) => Some(_inner),
            GetJobBookmarkErrorKind::InvalidInputException(_inner) => Some(_inner),
            GetJobBookmarkErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            GetJobBookmarkErrorKind::ValidationException(_inner) => Some(_inner),
            GetJobBookmarkErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetJobRunError {
    pub kind: GetJobRunErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetJobRunErrorKind {
    EntityNotFoundException(crate::error::EntityNotFoundException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetJobRunError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetJobRunErrorKind::EntityNotFoundException(_inner) => _inner.fmt(f),
            GetJobRunErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            GetJobRunErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            GetJobRunErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            GetJobRunErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetJobRunError {
    fn code(&self) -> Option<&str> {
        GetJobRunError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetJobRunError {
    pub fn new(kind: GetJobRunErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetJobRunErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetJobRunErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetJobRunErrorKind::EntityNotFoundException(_))
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(&self.kind, GetJobRunErrorKind::InternalServiceException(_))
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(&self.kind, GetJobRunErrorKind::InvalidInputException(_))
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(&self.kind, GetJobRunErrorKind::OperationTimeoutException(_))
    }
}
impl std::error::Error for GetJobRunError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetJobRunErrorKind::EntityNotFoundException(_inner) => Some(_inner),
            GetJobRunErrorKind::InternalServiceException(_inner) => Some(_inner),
            GetJobRunErrorKind::InvalidInputException(_inner) => Some(_inner),
            GetJobRunErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            GetJobRunErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetJobRunsError {
    pub kind: GetJobRunsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetJobRunsErrorKind {
    EntityNotFoundException(crate::error::EntityNotFoundException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetJobRunsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetJobRunsErrorKind::EntityNotFoundException(_inner) => _inner.fmt(f),
            GetJobRunsErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            GetJobRunsErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            GetJobRunsErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            GetJobRunsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetJobRunsError {
    fn code(&self) -> Option<&str> {
        GetJobRunsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetJobRunsError {
    pub fn new(kind: GetJobRunsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetJobRunsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetJobRunsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetJobRunsErrorKind::EntityNotFoundException(_))
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(&self.kind, GetJobRunsErrorKind::InternalServiceException(_))
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(&self.kind, GetJobRunsErrorKind::InvalidInputException(_))
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetJobRunsErrorKind::OperationTimeoutException(_)
        )
    }
}
impl std::error::Error for GetJobRunsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetJobRunsErrorKind::EntityNotFoundException(_inner) => Some(_inner),
            GetJobRunsErrorKind::InternalServiceException(_inner) => Some(_inner),
            GetJobRunsErrorKind::InvalidInputException(_inner) => Some(_inner),
            GetJobRunsErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            GetJobRunsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetJobsError {
    pub kind: GetJobsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetJobsErrorKind {
    EntityNotFoundException(crate::error::EntityNotFoundException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetJobsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetJobsErrorKind::EntityNotFoundException(_inner) => _inner.fmt(f),
            GetJobsErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            GetJobsErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            GetJobsErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            GetJobsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetJobsError {
    fn code(&self) -> Option<&str> {
        GetJobsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetJobsError {
    pub fn new(kind: GetJobsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetJobsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetJobsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetJobsErrorKind::EntityNotFoundException(_))
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(&self.kind, GetJobsErrorKind::InternalServiceException(_))
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(&self.kind, GetJobsErrorKind::InvalidInputException(_))
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(&self.kind, GetJobsErrorKind::OperationTimeoutException(_))
    }
}
impl std::error::Error for GetJobsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetJobsErrorKind::EntityNotFoundException(_inner) => Some(_inner),
            GetJobsErrorKind::InternalServiceException(_inner) => Some(_inner),
            GetJobsErrorKind::InvalidInputException(_inner) => Some(_inner),
            GetJobsErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            GetJobsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetMappingError {
    pub kind: GetMappingErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetMappingErrorKind {
    EntityNotFoundException(crate::error::EntityNotFoundException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetMappingError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetMappingErrorKind::EntityNotFoundException(_inner) => _inner.fmt(f),
            GetMappingErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            GetMappingErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            GetMappingErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            GetMappingErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetMappingError {
    fn code(&self) -> Option<&str> {
        GetMappingError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetMappingError {
    pub fn new(kind: GetMappingErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetMappingErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetMappingErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetMappingErrorKind::EntityNotFoundException(_))
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(&self.kind, GetMappingErrorKind::InternalServiceException(_))
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(&self.kind, GetMappingErrorKind::InvalidInputException(_))
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMappingErrorKind::OperationTimeoutException(_)
        )
    }
}
impl std::error::Error for GetMappingError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetMappingErrorKind::EntityNotFoundException(_inner) => Some(_inner),
            GetMappingErrorKind::InternalServiceException(_inner) => Some(_inner),
            GetMappingErrorKind::InvalidInputException(_inner) => Some(_inner),
            GetMappingErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            GetMappingErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetMLTaskRunError {
    pub kind: GetMLTaskRunErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetMLTaskRunErrorKind {
    EntityNotFoundException(crate::error::EntityNotFoundException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetMLTaskRunError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetMLTaskRunErrorKind::EntityNotFoundException(_inner) => _inner.fmt(f),
            GetMLTaskRunErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            GetMLTaskRunErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            GetMLTaskRunErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            GetMLTaskRunErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetMLTaskRunError {
    fn code(&self) -> Option<&str> {
        GetMLTaskRunError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetMLTaskRunError {
    pub fn new(kind: GetMLTaskRunErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetMLTaskRunErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetMLTaskRunErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMLTaskRunErrorKind::EntityNotFoundException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMLTaskRunErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(&self.kind, GetMLTaskRunErrorKind::InvalidInputException(_))
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMLTaskRunErrorKind::OperationTimeoutException(_)
        )
    }
}
impl std::error::Error for GetMLTaskRunError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetMLTaskRunErrorKind::EntityNotFoundException(_inner) => Some(_inner),
            GetMLTaskRunErrorKind::InternalServiceException(_inner) => Some(_inner),
            GetMLTaskRunErrorKind::InvalidInputException(_inner) => Some(_inner),
            GetMLTaskRunErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            GetMLTaskRunErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetMLTaskRunsError {
    pub kind: GetMLTaskRunsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetMLTaskRunsErrorKind {
    EntityNotFoundException(crate::error::EntityNotFoundException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetMLTaskRunsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetMLTaskRunsErrorKind::EntityNotFoundException(_inner) => _inner.fmt(f),
            GetMLTaskRunsErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            GetMLTaskRunsErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            GetMLTaskRunsErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            GetMLTaskRunsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetMLTaskRunsError {
    fn code(&self) -> Option<&str> {
        GetMLTaskRunsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetMLTaskRunsError {
    pub fn new(kind: GetMLTaskRunsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetMLTaskRunsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetMLTaskRunsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMLTaskRunsErrorKind::EntityNotFoundException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMLTaskRunsErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(&self.kind, GetMLTaskRunsErrorKind::InvalidInputException(_))
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMLTaskRunsErrorKind::OperationTimeoutException(_)
        )
    }
}
impl std::error::Error for GetMLTaskRunsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetMLTaskRunsErrorKind::EntityNotFoundException(_inner) => Some(_inner),
            GetMLTaskRunsErrorKind::InternalServiceException(_inner) => Some(_inner),
            GetMLTaskRunsErrorKind::InvalidInputException(_inner) => Some(_inner),
            GetMLTaskRunsErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            GetMLTaskRunsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetMLTransformError {
    pub kind: GetMLTransformErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetMLTransformErrorKind {
    EntityNotFoundException(crate::error::EntityNotFoundException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetMLTransformError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetMLTransformErrorKind::EntityNotFoundException(_inner) => _inner.fmt(f),
            GetMLTransformErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            GetMLTransformErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            GetMLTransformErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            GetMLTransformErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetMLTransformError {
    fn code(&self) -> Option<&str> {
        GetMLTransformError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetMLTransformError {
    pub fn new(kind: GetMLTransformErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetMLTransformErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetMLTransformErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMLTransformErrorKind::EntityNotFoundException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMLTransformErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMLTransformErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMLTransformErrorKind::OperationTimeoutException(_)
        )
    }
}
impl std::error::Error for GetMLTransformError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetMLTransformErrorKind::EntityNotFoundException(_inner) => Some(_inner),
            GetMLTransformErrorKind::InternalServiceException(_inner) => Some(_inner),
            GetMLTransformErrorKind::InvalidInputException(_inner) => Some(_inner),
            GetMLTransformErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            GetMLTransformErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetMLTransformsError {
    pub kind: GetMLTransformsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetMLTransformsErrorKind {
    EntityNotFoundException(crate::error::EntityNotFoundException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetMLTransformsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetMLTransformsErrorKind::EntityNotFoundException(_inner) => _inner.fmt(f),
            GetMLTransformsErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            GetMLTransformsErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            GetMLTransformsErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            GetMLTransformsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetMLTransformsError {
    fn code(&self) -> Option<&str> {
        GetMLTransformsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetMLTransformsError {
    pub fn new(kind: GetMLTransformsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetMLTransformsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetMLTransformsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMLTransformsErrorKind::EntityNotFoundException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMLTransformsErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMLTransformsErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMLTransformsErrorKind::OperationTimeoutException(_)
        )
    }
}
impl std::error::Error for GetMLTransformsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetMLTransformsErrorKind::EntityNotFoundException(_inner) => Some(_inner),
            GetMLTransformsErrorKind::InternalServiceException(_inner) => Some(_inner),
            GetMLTransformsErrorKind::InvalidInputException(_inner) => Some(_inner),
            GetMLTransformsErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            GetMLTransformsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetPartitionError {
    pub kind: GetPartitionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetPartitionErrorKind {
    EntityNotFoundException(crate::error::EntityNotFoundException),
    GlueEncryptionException(crate::error::GlueEncryptionException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetPartitionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetPartitionErrorKind::EntityNotFoundException(_inner) => _inner.fmt(f),
            GetPartitionErrorKind::GlueEncryptionException(_inner) => _inner.fmt(f),
            GetPartitionErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            GetPartitionErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            GetPartitionErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            GetPartitionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetPartitionError {
    fn code(&self) -> Option<&str> {
        GetPartitionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetPartitionError {
    pub fn new(kind: GetPartitionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetPartitionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetPartitionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPartitionErrorKind::EntityNotFoundException(_)
        )
    }
    pub fn is_glue_encryption_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPartitionErrorKind::GlueEncryptionException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPartitionErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(&self.kind, GetPartitionErrorKind::InvalidInputException(_))
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPartitionErrorKind::OperationTimeoutException(_)
        )
    }
}
impl std::error::Error for GetPartitionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetPartitionErrorKind::EntityNotFoundException(_inner) => Some(_inner),
            GetPartitionErrorKind::GlueEncryptionException(_inner) => Some(_inner),
            GetPartitionErrorKind::InternalServiceException(_inner) => Some(_inner),
            GetPartitionErrorKind::InvalidInputException(_inner) => Some(_inner),
            GetPartitionErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            GetPartitionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetPartitionIndexesError {
    pub kind: GetPartitionIndexesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetPartitionIndexesErrorKind {
    ConflictException(crate::error::ConflictException),
    EntityNotFoundException(crate::error::EntityNotFoundException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetPartitionIndexesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetPartitionIndexesErrorKind::ConflictException(_inner) => _inner.fmt(f),
            GetPartitionIndexesErrorKind::EntityNotFoundException(_inner) => _inner.fmt(f),
            GetPartitionIndexesErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            GetPartitionIndexesErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            GetPartitionIndexesErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            GetPartitionIndexesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetPartitionIndexesError {
    fn code(&self) -> Option<&str> {
        GetPartitionIndexesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetPartitionIndexesError {
    pub fn new(kind: GetPartitionIndexesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetPartitionIndexesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetPartitionIndexesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPartitionIndexesErrorKind::ConflictException(_)
        )
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPartitionIndexesErrorKind::EntityNotFoundException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPartitionIndexesErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPartitionIndexesErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPartitionIndexesErrorKind::OperationTimeoutException(_)
        )
    }
}
impl std::error::Error for GetPartitionIndexesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetPartitionIndexesErrorKind::ConflictException(_inner) => Some(_inner),
            GetPartitionIndexesErrorKind::EntityNotFoundException(_inner) => Some(_inner),
            GetPartitionIndexesErrorKind::InternalServiceException(_inner) => Some(_inner),
            GetPartitionIndexesErrorKind::InvalidInputException(_inner) => Some(_inner),
            GetPartitionIndexesErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            GetPartitionIndexesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetPartitionsError {
    pub kind: GetPartitionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetPartitionsErrorKind {
    EntityNotFoundException(crate::error::EntityNotFoundException),
    GlueEncryptionException(crate::error::GlueEncryptionException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetPartitionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetPartitionsErrorKind::EntityNotFoundException(_inner) => _inner.fmt(f),
            GetPartitionsErrorKind::GlueEncryptionException(_inner) => _inner.fmt(f),
            GetPartitionsErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            GetPartitionsErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            GetPartitionsErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            GetPartitionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetPartitionsError {
    fn code(&self) -> Option<&str> {
        GetPartitionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetPartitionsError {
    pub fn new(kind: GetPartitionsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetPartitionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetPartitionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPartitionsErrorKind::EntityNotFoundException(_)
        )
    }
    pub fn is_glue_encryption_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPartitionsErrorKind::GlueEncryptionException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPartitionsErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(&self.kind, GetPartitionsErrorKind::InvalidInputException(_))
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPartitionsErrorKind::OperationTimeoutException(_)
        )
    }
}
impl std::error::Error for GetPartitionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetPartitionsErrorKind::EntityNotFoundException(_inner) => Some(_inner),
            GetPartitionsErrorKind::GlueEncryptionException(_inner) => Some(_inner),
            GetPartitionsErrorKind::InternalServiceException(_inner) => Some(_inner),
            GetPartitionsErrorKind::InvalidInputException(_inner) => Some(_inner),
            GetPartitionsErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            GetPartitionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetPlanError {
    pub kind: GetPlanErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetPlanErrorKind {
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetPlanError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetPlanErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            GetPlanErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            GetPlanErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            GetPlanErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetPlanError {
    fn code(&self) -> Option<&str> {
        GetPlanError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetPlanError {
    pub fn new(kind: GetPlanErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetPlanErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetPlanErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(&self.kind, GetPlanErrorKind::InternalServiceException(_))
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(&self.kind, GetPlanErrorKind::InvalidInputException(_))
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(&self.kind, GetPlanErrorKind::OperationTimeoutException(_))
    }
}
impl std::error::Error for GetPlanError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetPlanErrorKind::InternalServiceException(_inner) => Some(_inner),
            GetPlanErrorKind::InvalidInputException(_inner) => Some(_inner),
            GetPlanErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            GetPlanErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetRegistryError {
    pub kind: GetRegistryErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetRegistryErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    EntityNotFoundException(crate::error::EntityNotFoundException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetRegistryError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetRegistryErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetRegistryErrorKind::EntityNotFoundException(_inner) => _inner.fmt(f),
            GetRegistryErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            GetRegistryErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            GetRegistryErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetRegistryError {
    fn code(&self) -> Option<&str> {
        GetRegistryError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetRegistryError {
    pub fn new(kind: GetRegistryErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetRegistryErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetRegistryErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, GetRegistryErrorKind::AccessDeniedException(_))
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetRegistryErrorKind::EntityNotFoundException(_))
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRegistryErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(&self.kind, GetRegistryErrorKind::InvalidInputException(_))
    }
}
impl std::error::Error for GetRegistryError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetRegistryErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetRegistryErrorKind::EntityNotFoundException(_inner) => Some(_inner),
            GetRegistryErrorKind::InternalServiceException(_inner) => Some(_inner),
            GetRegistryErrorKind::InvalidInputException(_inner) => Some(_inner),
            GetRegistryErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetResourcePoliciesError {
    pub kind: GetResourcePoliciesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetResourcePoliciesErrorKind {
    GlueEncryptionException(crate::error::GlueEncryptionException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetResourcePoliciesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetResourcePoliciesErrorKind::GlueEncryptionException(_inner) => _inner.fmt(f),
            GetResourcePoliciesErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            GetResourcePoliciesErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            GetResourcePoliciesErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            GetResourcePoliciesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetResourcePoliciesError {
    fn code(&self) -> Option<&str> {
        GetResourcePoliciesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetResourcePoliciesError {
    pub fn new(kind: GetResourcePoliciesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetResourcePoliciesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetResourcePoliciesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_glue_encryption_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetResourcePoliciesErrorKind::GlueEncryptionException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetResourcePoliciesErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetResourcePoliciesErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetResourcePoliciesErrorKind::OperationTimeoutException(_)
        )
    }
}
impl std::error::Error for GetResourcePoliciesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetResourcePoliciesErrorKind::GlueEncryptionException(_inner) => Some(_inner),
            GetResourcePoliciesErrorKind::InternalServiceException(_inner) => Some(_inner),
            GetResourcePoliciesErrorKind::InvalidInputException(_inner) => Some(_inner),
            GetResourcePoliciesErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            GetResourcePoliciesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetResourcePolicyError {
    pub kind: GetResourcePolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetResourcePolicyErrorKind {
    EntityNotFoundException(crate::error::EntityNotFoundException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetResourcePolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetResourcePolicyErrorKind::EntityNotFoundException(_inner) => _inner.fmt(f),
            GetResourcePolicyErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            GetResourcePolicyErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            GetResourcePolicyErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            GetResourcePolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetResourcePolicyError {
    fn code(&self) -> Option<&str> {
        GetResourcePolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetResourcePolicyError {
    pub fn new(kind: GetResourcePolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetResourcePolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetResourcePolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetResourcePolicyErrorKind::EntityNotFoundException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetResourcePolicyErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetResourcePolicyErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetResourcePolicyErrorKind::OperationTimeoutException(_)
        )
    }
}
impl std::error::Error for GetResourcePolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetResourcePolicyErrorKind::EntityNotFoundException(_inner) => Some(_inner),
            GetResourcePolicyErrorKind::InternalServiceException(_inner) => Some(_inner),
            GetResourcePolicyErrorKind::InvalidInputException(_inner) => Some(_inner),
            GetResourcePolicyErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            GetResourcePolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetSchemaError {
    pub kind: GetSchemaErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetSchemaErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    EntityNotFoundException(crate::error::EntityNotFoundException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetSchemaError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetSchemaErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetSchemaErrorKind::EntityNotFoundException(_inner) => _inner.fmt(f),
            GetSchemaErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            GetSchemaErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            GetSchemaErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetSchemaError {
    fn code(&self) -> Option<&str> {
        GetSchemaError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetSchemaError {
    pub fn new(kind: GetSchemaErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetSchemaErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetSchemaErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, GetSchemaErrorKind::AccessDeniedException(_))
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetSchemaErrorKind::EntityNotFoundException(_))
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(&self.kind, GetSchemaErrorKind::InternalServiceException(_))
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(&self.kind, GetSchemaErrorKind::InvalidInputException(_))
    }
}
impl std::error::Error for GetSchemaError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetSchemaErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetSchemaErrorKind::EntityNotFoundException(_inner) => Some(_inner),
            GetSchemaErrorKind::InternalServiceException(_inner) => Some(_inner),
            GetSchemaErrorKind::InvalidInputException(_inner) => Some(_inner),
            GetSchemaErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetSchemaByDefinitionError {
    pub kind: GetSchemaByDefinitionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetSchemaByDefinitionErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    EntityNotFoundException(crate::error::EntityNotFoundException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetSchemaByDefinitionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetSchemaByDefinitionErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetSchemaByDefinitionErrorKind::EntityNotFoundException(_inner) => _inner.fmt(f),
            GetSchemaByDefinitionErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            GetSchemaByDefinitionErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            GetSchemaByDefinitionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetSchemaByDefinitionError {
    fn code(&self) -> Option<&str> {
        GetSchemaByDefinitionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetSchemaByDefinitionError {
    pub fn new(kind: GetSchemaByDefinitionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetSchemaByDefinitionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetSchemaByDefinitionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSchemaByDefinitionErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSchemaByDefinitionErrorKind::EntityNotFoundException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSchemaByDefinitionErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSchemaByDefinitionErrorKind::InvalidInputException(_)
        )
    }
}
impl std::error::Error for GetSchemaByDefinitionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetSchemaByDefinitionErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetSchemaByDefinitionErrorKind::EntityNotFoundException(_inner) => Some(_inner),
            GetSchemaByDefinitionErrorKind::InternalServiceException(_inner) => Some(_inner),
            GetSchemaByDefinitionErrorKind::InvalidInputException(_inner) => Some(_inner),
            GetSchemaByDefinitionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetSchemaVersionError {
    pub kind: GetSchemaVersionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetSchemaVersionErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    EntityNotFoundException(crate::error::EntityNotFoundException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetSchemaVersionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetSchemaVersionErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetSchemaVersionErrorKind::EntityNotFoundException(_inner) => _inner.fmt(f),
            GetSchemaVersionErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            GetSchemaVersionErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            GetSchemaVersionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetSchemaVersionError {
    fn code(&self) -> Option<&str> {
        GetSchemaVersionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetSchemaVersionError {
    pub fn new(kind: GetSchemaVersionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetSchemaVersionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetSchemaVersionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSchemaVersionErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSchemaVersionErrorKind::EntityNotFoundException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSchemaVersionErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSchemaVersionErrorKind::InvalidInputException(_)
        )
    }
}
impl std::error::Error for GetSchemaVersionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetSchemaVersionErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetSchemaVersionErrorKind::EntityNotFoundException(_inner) => Some(_inner),
            GetSchemaVersionErrorKind::InternalServiceException(_inner) => Some(_inner),
            GetSchemaVersionErrorKind::InvalidInputException(_inner) => Some(_inner),
            GetSchemaVersionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetSchemaVersionsDiffError {
    pub kind: GetSchemaVersionsDiffErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetSchemaVersionsDiffErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    EntityNotFoundException(crate::error::EntityNotFoundException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetSchemaVersionsDiffError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetSchemaVersionsDiffErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetSchemaVersionsDiffErrorKind::EntityNotFoundException(_inner) => _inner.fmt(f),
            GetSchemaVersionsDiffErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            GetSchemaVersionsDiffErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            GetSchemaVersionsDiffErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetSchemaVersionsDiffError {
    fn code(&self) -> Option<&str> {
        GetSchemaVersionsDiffError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetSchemaVersionsDiffError {
    pub fn new(kind: GetSchemaVersionsDiffErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetSchemaVersionsDiffErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetSchemaVersionsDiffErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSchemaVersionsDiffErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSchemaVersionsDiffErrorKind::EntityNotFoundException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSchemaVersionsDiffErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSchemaVersionsDiffErrorKind::InvalidInputException(_)
        )
    }
}
impl std::error::Error for GetSchemaVersionsDiffError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetSchemaVersionsDiffErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetSchemaVersionsDiffErrorKind::EntityNotFoundException(_inner) => Some(_inner),
            GetSchemaVersionsDiffErrorKind::InternalServiceException(_inner) => Some(_inner),
            GetSchemaVersionsDiffErrorKind::InvalidInputException(_inner) => Some(_inner),
            GetSchemaVersionsDiffErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetSecurityConfigurationError {
    pub kind: GetSecurityConfigurationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetSecurityConfigurationErrorKind {
    EntityNotFoundException(crate::error::EntityNotFoundException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetSecurityConfigurationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetSecurityConfigurationErrorKind::EntityNotFoundException(_inner) => _inner.fmt(f),
            GetSecurityConfigurationErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            GetSecurityConfigurationErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            GetSecurityConfigurationErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            GetSecurityConfigurationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetSecurityConfigurationError {
    fn code(&self) -> Option<&str> {
        GetSecurityConfigurationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetSecurityConfigurationError {
    pub fn new(kind: GetSecurityConfigurationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetSecurityConfigurationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetSecurityConfigurationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSecurityConfigurationErrorKind::EntityNotFoundException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSecurityConfigurationErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSecurityConfigurationErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSecurityConfigurationErrorKind::OperationTimeoutException(_)
        )
    }
}
impl std::error::Error for GetSecurityConfigurationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetSecurityConfigurationErrorKind::EntityNotFoundException(_inner) => Some(_inner),
            GetSecurityConfigurationErrorKind::InternalServiceException(_inner) => Some(_inner),
            GetSecurityConfigurationErrorKind::InvalidInputException(_inner) => Some(_inner),
            GetSecurityConfigurationErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            GetSecurityConfigurationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetSecurityConfigurationsError {
    pub kind: GetSecurityConfigurationsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetSecurityConfigurationsErrorKind {
    EntityNotFoundException(crate::error::EntityNotFoundException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetSecurityConfigurationsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetSecurityConfigurationsErrorKind::EntityNotFoundException(_inner) => _inner.fmt(f),
            GetSecurityConfigurationsErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            GetSecurityConfigurationsErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            GetSecurityConfigurationsErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            GetSecurityConfigurationsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetSecurityConfigurationsError {
    fn code(&self) -> Option<&str> {
        GetSecurityConfigurationsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetSecurityConfigurationsError {
    pub fn new(kind: GetSecurityConfigurationsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetSecurityConfigurationsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetSecurityConfigurationsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSecurityConfigurationsErrorKind::EntityNotFoundException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSecurityConfigurationsErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSecurityConfigurationsErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSecurityConfigurationsErrorKind::OperationTimeoutException(_)
        )
    }
}
impl std::error::Error for GetSecurityConfigurationsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetSecurityConfigurationsErrorKind::EntityNotFoundException(_inner) => Some(_inner),
            GetSecurityConfigurationsErrorKind::InternalServiceException(_inner) => Some(_inner),
            GetSecurityConfigurationsErrorKind::InvalidInputException(_inner) => Some(_inner),
            GetSecurityConfigurationsErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            GetSecurityConfigurationsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetTableError {
    pub kind: GetTableErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetTableErrorKind {
    EntityNotFoundException(crate::error::EntityNotFoundException),
    GlueEncryptionException(crate::error::GlueEncryptionException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetTableError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetTableErrorKind::EntityNotFoundException(_inner) => _inner.fmt(f),
            GetTableErrorKind::GlueEncryptionException(_inner) => _inner.fmt(f),
            GetTableErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            GetTableErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            GetTableErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            GetTableErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetTableError {
    fn code(&self) -> Option<&str> {
        GetTableError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetTableError {
    pub fn new(kind: GetTableErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetTableErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetTableErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetTableErrorKind::EntityNotFoundException(_))
    }
    pub fn is_glue_encryption_exception(&self) -> bool {
        matches!(&self.kind, GetTableErrorKind::GlueEncryptionException(_))
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(&self.kind, GetTableErrorKind::InternalServiceException(_))
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(&self.kind, GetTableErrorKind::InvalidInputException(_))
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(&self.kind, GetTableErrorKind::OperationTimeoutException(_))
    }
}
impl std::error::Error for GetTableError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetTableErrorKind::EntityNotFoundException(_inner) => Some(_inner),
            GetTableErrorKind::GlueEncryptionException(_inner) => Some(_inner),
            GetTableErrorKind::InternalServiceException(_inner) => Some(_inner),
            GetTableErrorKind::InvalidInputException(_inner) => Some(_inner),
            GetTableErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            GetTableErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetTablesError {
    pub kind: GetTablesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetTablesErrorKind {
    EntityNotFoundException(crate::error::EntityNotFoundException),
    GlueEncryptionException(crate::error::GlueEncryptionException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetTablesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetTablesErrorKind::EntityNotFoundException(_inner) => _inner.fmt(f),
            GetTablesErrorKind::GlueEncryptionException(_inner) => _inner.fmt(f),
            GetTablesErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            GetTablesErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            GetTablesErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            GetTablesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetTablesError {
    fn code(&self) -> Option<&str> {
        GetTablesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetTablesError {
    pub fn new(kind: GetTablesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetTablesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetTablesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetTablesErrorKind::EntityNotFoundException(_))
    }
    pub fn is_glue_encryption_exception(&self) -> bool {
        matches!(&self.kind, GetTablesErrorKind::GlueEncryptionException(_))
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(&self.kind, GetTablesErrorKind::InternalServiceException(_))
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(&self.kind, GetTablesErrorKind::InvalidInputException(_))
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(&self.kind, GetTablesErrorKind::OperationTimeoutException(_))
    }
}
impl std::error::Error for GetTablesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetTablesErrorKind::EntityNotFoundException(_inner) => Some(_inner),
            GetTablesErrorKind::GlueEncryptionException(_inner) => Some(_inner),
            GetTablesErrorKind::InternalServiceException(_inner) => Some(_inner),
            GetTablesErrorKind::InvalidInputException(_inner) => Some(_inner),
            GetTablesErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            GetTablesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetTableVersionError {
    pub kind: GetTableVersionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetTableVersionErrorKind {
    EntityNotFoundException(crate::error::EntityNotFoundException),
    GlueEncryptionException(crate::error::GlueEncryptionException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetTableVersionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetTableVersionErrorKind::EntityNotFoundException(_inner) => _inner.fmt(f),
            GetTableVersionErrorKind::GlueEncryptionException(_inner) => _inner.fmt(f),
            GetTableVersionErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            GetTableVersionErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            GetTableVersionErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            GetTableVersionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetTableVersionError {
    fn code(&self) -> Option<&str> {
        GetTableVersionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetTableVersionError {
    pub fn new(kind: GetTableVersionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetTableVersionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetTableVersionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetTableVersionErrorKind::EntityNotFoundException(_)
        )
    }
    pub fn is_glue_encryption_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetTableVersionErrorKind::GlueEncryptionException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetTableVersionErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetTableVersionErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetTableVersionErrorKind::OperationTimeoutException(_)
        )
    }
}
impl std::error::Error for GetTableVersionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetTableVersionErrorKind::EntityNotFoundException(_inner) => Some(_inner),
            GetTableVersionErrorKind::GlueEncryptionException(_inner) => Some(_inner),
            GetTableVersionErrorKind::InternalServiceException(_inner) => Some(_inner),
            GetTableVersionErrorKind::InvalidInputException(_inner) => Some(_inner),
            GetTableVersionErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            GetTableVersionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetTableVersionsError {
    pub kind: GetTableVersionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetTableVersionsErrorKind {
    EntityNotFoundException(crate::error::EntityNotFoundException),
    GlueEncryptionException(crate::error::GlueEncryptionException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetTableVersionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetTableVersionsErrorKind::EntityNotFoundException(_inner) => _inner.fmt(f),
            GetTableVersionsErrorKind::GlueEncryptionException(_inner) => _inner.fmt(f),
            GetTableVersionsErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            GetTableVersionsErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            GetTableVersionsErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            GetTableVersionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetTableVersionsError {
    fn code(&self) -> Option<&str> {
        GetTableVersionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetTableVersionsError {
    pub fn new(kind: GetTableVersionsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetTableVersionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetTableVersionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetTableVersionsErrorKind::EntityNotFoundException(_)
        )
    }
    pub fn is_glue_encryption_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetTableVersionsErrorKind::GlueEncryptionException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetTableVersionsErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetTableVersionsErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetTableVersionsErrorKind::OperationTimeoutException(_)
        )
    }
}
impl std::error::Error for GetTableVersionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetTableVersionsErrorKind::EntityNotFoundException(_inner) => Some(_inner),
            GetTableVersionsErrorKind::GlueEncryptionException(_inner) => Some(_inner),
            GetTableVersionsErrorKind::InternalServiceException(_inner) => Some(_inner),
            GetTableVersionsErrorKind::InvalidInputException(_inner) => Some(_inner),
            GetTableVersionsErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            GetTableVersionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetTagsError {
    pub kind: GetTagsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetTagsErrorKind {
    EntityNotFoundException(crate::error::EntityNotFoundException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetTagsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetTagsErrorKind::EntityNotFoundException(_inner) => _inner.fmt(f),
            GetTagsErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            GetTagsErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            GetTagsErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            GetTagsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetTagsError {
    fn code(&self) -> Option<&str> {
        GetTagsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetTagsError {
    pub fn new(kind: GetTagsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetTagsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetTagsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetTagsErrorKind::EntityNotFoundException(_))
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(&self.kind, GetTagsErrorKind::InternalServiceException(_))
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(&self.kind, GetTagsErrorKind::InvalidInputException(_))
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(&self.kind, GetTagsErrorKind::OperationTimeoutException(_))
    }
}
impl std::error::Error for GetTagsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetTagsErrorKind::EntityNotFoundException(_inner) => Some(_inner),
            GetTagsErrorKind::InternalServiceException(_inner) => Some(_inner),
            GetTagsErrorKind::InvalidInputException(_inner) => Some(_inner),
            GetTagsErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            GetTagsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetTriggerError {
    pub kind: GetTriggerErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetTriggerErrorKind {
    EntityNotFoundException(crate::error::EntityNotFoundException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetTriggerError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetTriggerErrorKind::EntityNotFoundException(_inner) => _inner.fmt(f),
            GetTriggerErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            GetTriggerErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            GetTriggerErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            GetTriggerErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetTriggerError {
    fn code(&self) -> Option<&str> {
        GetTriggerError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetTriggerError {
    pub fn new(kind: GetTriggerErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetTriggerErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetTriggerErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetTriggerErrorKind::EntityNotFoundException(_))
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(&self.kind, GetTriggerErrorKind::InternalServiceException(_))
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(&self.kind, GetTriggerErrorKind::InvalidInputException(_))
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetTriggerErrorKind::OperationTimeoutException(_)
        )
    }
}
impl std::error::Error for GetTriggerError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetTriggerErrorKind::EntityNotFoundException(_inner) => Some(_inner),
            GetTriggerErrorKind::InternalServiceException(_inner) => Some(_inner),
            GetTriggerErrorKind::InvalidInputException(_inner) => Some(_inner),
            GetTriggerErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            GetTriggerErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetTriggersError {
    pub kind: GetTriggersErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetTriggersErrorKind {
    EntityNotFoundException(crate::error::EntityNotFoundException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetTriggersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetTriggersErrorKind::EntityNotFoundException(_inner) => _inner.fmt(f),
            GetTriggersErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            GetTriggersErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            GetTriggersErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            GetTriggersErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetTriggersError {
    fn code(&self) -> Option<&str> {
        GetTriggersError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetTriggersError {
    pub fn new(kind: GetTriggersErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetTriggersErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetTriggersErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetTriggersErrorKind::EntityNotFoundException(_))
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetTriggersErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(&self.kind, GetTriggersErrorKind::InvalidInputException(_))
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetTriggersErrorKind::OperationTimeoutException(_)
        )
    }
}
impl std::error::Error for GetTriggersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetTriggersErrorKind::EntityNotFoundException(_inner) => Some(_inner),
            GetTriggersErrorKind::InternalServiceException(_inner) => Some(_inner),
            GetTriggersErrorKind::InvalidInputException(_inner) => Some(_inner),
            GetTriggersErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            GetTriggersErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetUserDefinedFunctionError {
    pub kind: GetUserDefinedFunctionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetUserDefinedFunctionErrorKind {
    EntityNotFoundException(crate::error::EntityNotFoundException),
    GlueEncryptionException(crate::error::GlueEncryptionException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetUserDefinedFunctionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetUserDefinedFunctionErrorKind::EntityNotFoundException(_inner) => _inner.fmt(f),
            GetUserDefinedFunctionErrorKind::GlueEncryptionException(_inner) => _inner.fmt(f),
            GetUserDefinedFunctionErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            GetUserDefinedFunctionErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            GetUserDefinedFunctionErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            GetUserDefinedFunctionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetUserDefinedFunctionError {
    fn code(&self) -> Option<&str> {
        GetUserDefinedFunctionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetUserDefinedFunctionError {
    pub fn new(kind: GetUserDefinedFunctionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetUserDefinedFunctionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetUserDefinedFunctionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetUserDefinedFunctionErrorKind::EntityNotFoundException(_)
        )
    }
    pub fn is_glue_encryption_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetUserDefinedFunctionErrorKind::GlueEncryptionException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetUserDefinedFunctionErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetUserDefinedFunctionErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetUserDefinedFunctionErrorKind::OperationTimeoutException(_)
        )
    }
}
impl std::error::Error for GetUserDefinedFunctionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetUserDefinedFunctionErrorKind::EntityNotFoundException(_inner) => Some(_inner),
            GetUserDefinedFunctionErrorKind::GlueEncryptionException(_inner) => Some(_inner),
            GetUserDefinedFunctionErrorKind::InternalServiceException(_inner) => Some(_inner),
            GetUserDefinedFunctionErrorKind::InvalidInputException(_inner) => Some(_inner),
            GetUserDefinedFunctionErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            GetUserDefinedFunctionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetUserDefinedFunctionsError {
    pub kind: GetUserDefinedFunctionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetUserDefinedFunctionsErrorKind {
    EntityNotFoundException(crate::error::EntityNotFoundException),
    GlueEncryptionException(crate::error::GlueEncryptionException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetUserDefinedFunctionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetUserDefinedFunctionsErrorKind::EntityNotFoundException(_inner) => _inner.fmt(f),
            GetUserDefinedFunctionsErrorKind::GlueEncryptionException(_inner) => _inner.fmt(f),
            GetUserDefinedFunctionsErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            GetUserDefinedFunctionsErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            GetUserDefinedFunctionsErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            GetUserDefinedFunctionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetUserDefinedFunctionsError {
    fn code(&self) -> Option<&str> {
        GetUserDefinedFunctionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetUserDefinedFunctionsError {
    pub fn new(kind: GetUserDefinedFunctionsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetUserDefinedFunctionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetUserDefinedFunctionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetUserDefinedFunctionsErrorKind::EntityNotFoundException(_)
        )
    }
    pub fn is_glue_encryption_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetUserDefinedFunctionsErrorKind::GlueEncryptionException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetUserDefinedFunctionsErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetUserDefinedFunctionsErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetUserDefinedFunctionsErrorKind::OperationTimeoutException(_)
        )
    }
}
impl std::error::Error for GetUserDefinedFunctionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetUserDefinedFunctionsErrorKind::EntityNotFoundException(_inner) => Some(_inner),
            GetUserDefinedFunctionsErrorKind::GlueEncryptionException(_inner) => Some(_inner),
            GetUserDefinedFunctionsErrorKind::InternalServiceException(_inner) => Some(_inner),
            GetUserDefinedFunctionsErrorKind::InvalidInputException(_inner) => Some(_inner),
            GetUserDefinedFunctionsErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            GetUserDefinedFunctionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetWorkflowError {
    pub kind: GetWorkflowErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetWorkflowErrorKind {
    EntityNotFoundException(crate::error::EntityNotFoundException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetWorkflowError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetWorkflowErrorKind::EntityNotFoundException(_inner) => _inner.fmt(f),
            GetWorkflowErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            GetWorkflowErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            GetWorkflowErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            GetWorkflowErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetWorkflowError {
    fn code(&self) -> Option<&str> {
        GetWorkflowError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetWorkflowError {
    pub fn new(kind: GetWorkflowErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetWorkflowErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetWorkflowErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetWorkflowErrorKind::EntityNotFoundException(_))
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetWorkflowErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(&self.kind, GetWorkflowErrorKind::InvalidInputException(_))
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetWorkflowErrorKind::OperationTimeoutException(_)
        )
    }
}
impl std::error::Error for GetWorkflowError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetWorkflowErrorKind::EntityNotFoundException(_inner) => Some(_inner),
            GetWorkflowErrorKind::InternalServiceException(_inner) => Some(_inner),
            GetWorkflowErrorKind::InvalidInputException(_inner) => Some(_inner),
            GetWorkflowErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            GetWorkflowErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetWorkflowRunError {
    pub kind: GetWorkflowRunErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetWorkflowRunErrorKind {
    EntityNotFoundException(crate::error::EntityNotFoundException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetWorkflowRunError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetWorkflowRunErrorKind::EntityNotFoundException(_inner) => _inner.fmt(f),
            GetWorkflowRunErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            GetWorkflowRunErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            GetWorkflowRunErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            GetWorkflowRunErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetWorkflowRunError {
    fn code(&self) -> Option<&str> {
        GetWorkflowRunError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetWorkflowRunError {
    pub fn new(kind: GetWorkflowRunErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetWorkflowRunErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetWorkflowRunErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetWorkflowRunErrorKind::EntityNotFoundException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetWorkflowRunErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetWorkflowRunErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetWorkflowRunErrorKind::OperationTimeoutException(_)
        )
    }
}
impl std::error::Error for GetWorkflowRunError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetWorkflowRunErrorKind::EntityNotFoundException(_inner) => Some(_inner),
            GetWorkflowRunErrorKind::InternalServiceException(_inner) => Some(_inner),
            GetWorkflowRunErrorKind::InvalidInputException(_inner) => Some(_inner),
            GetWorkflowRunErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            GetWorkflowRunErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetWorkflowRunPropertiesError {
    pub kind: GetWorkflowRunPropertiesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetWorkflowRunPropertiesErrorKind {
    EntityNotFoundException(crate::error::EntityNotFoundException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetWorkflowRunPropertiesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetWorkflowRunPropertiesErrorKind::EntityNotFoundException(_inner) => _inner.fmt(f),
            GetWorkflowRunPropertiesErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            GetWorkflowRunPropertiesErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            GetWorkflowRunPropertiesErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            GetWorkflowRunPropertiesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetWorkflowRunPropertiesError {
    fn code(&self) -> Option<&str> {
        GetWorkflowRunPropertiesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetWorkflowRunPropertiesError {
    pub fn new(kind: GetWorkflowRunPropertiesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetWorkflowRunPropertiesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetWorkflowRunPropertiesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetWorkflowRunPropertiesErrorKind::EntityNotFoundException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetWorkflowRunPropertiesErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetWorkflowRunPropertiesErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetWorkflowRunPropertiesErrorKind::OperationTimeoutException(_)
        )
    }
}
impl std::error::Error for GetWorkflowRunPropertiesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetWorkflowRunPropertiesErrorKind::EntityNotFoundException(_inner) => Some(_inner),
            GetWorkflowRunPropertiesErrorKind::InternalServiceException(_inner) => Some(_inner),
            GetWorkflowRunPropertiesErrorKind::InvalidInputException(_inner) => Some(_inner),
            GetWorkflowRunPropertiesErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            GetWorkflowRunPropertiesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetWorkflowRunsError {
    pub kind: GetWorkflowRunsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetWorkflowRunsErrorKind {
    EntityNotFoundException(crate::error::EntityNotFoundException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetWorkflowRunsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetWorkflowRunsErrorKind::EntityNotFoundException(_inner) => _inner.fmt(f),
            GetWorkflowRunsErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            GetWorkflowRunsErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            GetWorkflowRunsErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            GetWorkflowRunsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetWorkflowRunsError {
    fn code(&self) -> Option<&str> {
        GetWorkflowRunsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetWorkflowRunsError {
    pub fn new(kind: GetWorkflowRunsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetWorkflowRunsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetWorkflowRunsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetWorkflowRunsErrorKind::EntityNotFoundException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetWorkflowRunsErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetWorkflowRunsErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetWorkflowRunsErrorKind::OperationTimeoutException(_)
        )
    }
}
impl std::error::Error for GetWorkflowRunsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetWorkflowRunsErrorKind::EntityNotFoundException(_inner) => Some(_inner),
            GetWorkflowRunsErrorKind::InternalServiceException(_inner) => Some(_inner),
            GetWorkflowRunsErrorKind::InvalidInputException(_inner) => Some(_inner),
            GetWorkflowRunsErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            GetWorkflowRunsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ImportCatalogToGlueError {
    pub kind: ImportCatalogToGlueErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ImportCatalogToGlueErrorKind {
    InternalServiceException(crate::error::InternalServiceException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ImportCatalogToGlueError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ImportCatalogToGlueErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            ImportCatalogToGlueErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            ImportCatalogToGlueErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ImportCatalogToGlueError {
    fn code(&self) -> Option<&str> {
        ImportCatalogToGlueError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ImportCatalogToGlueError {
    pub fn new(kind: ImportCatalogToGlueErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ImportCatalogToGlueErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ImportCatalogToGlueErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            ImportCatalogToGlueErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            ImportCatalogToGlueErrorKind::OperationTimeoutException(_)
        )
    }
}
impl std::error::Error for ImportCatalogToGlueError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ImportCatalogToGlueErrorKind::InternalServiceException(_inner) => Some(_inner),
            ImportCatalogToGlueErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            ImportCatalogToGlueErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListBlueprintsError {
    pub kind: ListBlueprintsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListBlueprintsErrorKind {
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListBlueprintsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListBlueprintsErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            ListBlueprintsErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            ListBlueprintsErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            ListBlueprintsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListBlueprintsError {
    fn code(&self) -> Option<&str> {
        ListBlueprintsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListBlueprintsError {
    pub fn new(kind: ListBlueprintsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListBlueprintsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListBlueprintsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListBlueprintsErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListBlueprintsErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListBlueprintsErrorKind::OperationTimeoutException(_)
        )
    }
}
impl std::error::Error for ListBlueprintsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListBlueprintsErrorKind::InternalServiceException(_inner) => Some(_inner),
            ListBlueprintsErrorKind::InvalidInputException(_inner) => Some(_inner),
            ListBlueprintsErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            ListBlueprintsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListCrawlersError {
    pub kind: ListCrawlersErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListCrawlersErrorKind {
    OperationTimeoutException(crate::error::OperationTimeoutException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListCrawlersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListCrawlersErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            ListCrawlersErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListCrawlersError {
    fn code(&self) -> Option<&str> {
        ListCrawlersError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListCrawlersError {
    pub fn new(kind: ListCrawlersErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListCrawlersErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListCrawlersErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListCrawlersErrorKind::OperationTimeoutException(_)
        )
    }
}
impl std::error::Error for ListCrawlersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListCrawlersErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            ListCrawlersErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListDevEndpointsError {
    pub kind: ListDevEndpointsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListDevEndpointsErrorKind {
    EntityNotFoundException(crate::error::EntityNotFoundException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListDevEndpointsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListDevEndpointsErrorKind::EntityNotFoundException(_inner) => _inner.fmt(f),
            ListDevEndpointsErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            ListDevEndpointsErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            ListDevEndpointsErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            ListDevEndpointsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListDevEndpointsError {
    fn code(&self) -> Option<&str> {
        ListDevEndpointsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListDevEndpointsError {
    pub fn new(kind: ListDevEndpointsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListDevEndpointsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListDevEndpointsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListDevEndpointsErrorKind::EntityNotFoundException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListDevEndpointsErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListDevEndpointsErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListDevEndpointsErrorKind::OperationTimeoutException(_)
        )
    }
}
impl std::error::Error for ListDevEndpointsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListDevEndpointsErrorKind::EntityNotFoundException(_inner) => Some(_inner),
            ListDevEndpointsErrorKind::InternalServiceException(_inner) => Some(_inner),
            ListDevEndpointsErrorKind::InvalidInputException(_inner) => Some(_inner),
            ListDevEndpointsErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            ListDevEndpointsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListJobsError {
    pub kind: ListJobsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListJobsErrorKind {
    EntityNotFoundException(crate::error::EntityNotFoundException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListJobsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListJobsErrorKind::EntityNotFoundException(_inner) => _inner.fmt(f),
            ListJobsErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            ListJobsErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            ListJobsErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            ListJobsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListJobsError {
    fn code(&self) -> Option<&str> {
        ListJobsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListJobsError {
    pub fn new(kind: ListJobsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListJobsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListJobsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(&self.kind, ListJobsErrorKind::EntityNotFoundException(_))
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(&self.kind, ListJobsErrorKind::InternalServiceException(_))
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(&self.kind, ListJobsErrorKind::InvalidInputException(_))
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(&self.kind, ListJobsErrorKind::OperationTimeoutException(_))
    }
}
impl std::error::Error for ListJobsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListJobsErrorKind::EntityNotFoundException(_inner) => Some(_inner),
            ListJobsErrorKind::InternalServiceException(_inner) => Some(_inner),
            ListJobsErrorKind::InvalidInputException(_inner) => Some(_inner),
            ListJobsErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            ListJobsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListMLTransformsError {
    pub kind: ListMLTransformsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListMLTransformsErrorKind {
    EntityNotFoundException(crate::error::EntityNotFoundException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListMLTransformsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListMLTransformsErrorKind::EntityNotFoundException(_inner) => _inner.fmt(f),
            ListMLTransformsErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            ListMLTransformsErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            ListMLTransformsErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            ListMLTransformsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListMLTransformsError {
    fn code(&self) -> Option<&str> {
        ListMLTransformsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListMLTransformsError {
    pub fn new(kind: ListMLTransformsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListMLTransformsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListMLTransformsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListMLTransformsErrorKind::EntityNotFoundException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListMLTransformsErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListMLTransformsErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListMLTransformsErrorKind::OperationTimeoutException(_)
        )
    }
}
impl std::error::Error for ListMLTransformsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListMLTransformsErrorKind::EntityNotFoundException(_inner) => Some(_inner),
            ListMLTransformsErrorKind::InternalServiceException(_inner) => Some(_inner),
            ListMLTransformsErrorKind::InvalidInputException(_inner) => Some(_inner),
            ListMLTransformsErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            ListMLTransformsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListRegistriesError {
    pub kind: ListRegistriesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListRegistriesErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListRegistriesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListRegistriesErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            ListRegistriesErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            ListRegistriesErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            ListRegistriesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListRegistriesError {
    fn code(&self) -> Option<&str> {
        ListRegistriesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListRegistriesError {
    pub fn new(kind: ListRegistriesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListRegistriesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListRegistriesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListRegistriesErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListRegistriesErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListRegistriesErrorKind::InvalidInputException(_)
        )
    }
}
impl std::error::Error for ListRegistriesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListRegistriesErrorKind::AccessDeniedException(_inner) => Some(_inner),
            ListRegistriesErrorKind::InternalServiceException(_inner) => Some(_inner),
            ListRegistriesErrorKind::InvalidInputException(_inner) => Some(_inner),
            ListRegistriesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListSchemasError {
    pub kind: ListSchemasErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListSchemasErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    EntityNotFoundException(crate::error::EntityNotFoundException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListSchemasError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListSchemasErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            ListSchemasErrorKind::EntityNotFoundException(_inner) => _inner.fmt(f),
            ListSchemasErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            ListSchemasErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            ListSchemasErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListSchemasError {
    fn code(&self) -> Option<&str> {
        ListSchemasError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListSchemasError {
    pub fn new(kind: ListSchemasErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListSchemasErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListSchemasErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, ListSchemasErrorKind::AccessDeniedException(_))
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(&self.kind, ListSchemasErrorKind::EntityNotFoundException(_))
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListSchemasErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(&self.kind, ListSchemasErrorKind::InvalidInputException(_))
    }
}
impl std::error::Error for ListSchemasError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListSchemasErrorKind::AccessDeniedException(_inner) => Some(_inner),
            ListSchemasErrorKind::EntityNotFoundException(_inner) => Some(_inner),
            ListSchemasErrorKind::InternalServiceException(_inner) => Some(_inner),
            ListSchemasErrorKind::InvalidInputException(_inner) => Some(_inner),
            ListSchemasErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListSchemaVersionsError {
    pub kind: ListSchemaVersionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListSchemaVersionsErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    EntityNotFoundException(crate::error::EntityNotFoundException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListSchemaVersionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListSchemaVersionsErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            ListSchemaVersionsErrorKind::EntityNotFoundException(_inner) => _inner.fmt(f),
            ListSchemaVersionsErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            ListSchemaVersionsErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            ListSchemaVersionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListSchemaVersionsError {
    fn code(&self) -> Option<&str> {
        ListSchemaVersionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListSchemaVersionsError {
    pub fn new(kind: ListSchemaVersionsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListSchemaVersionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListSchemaVersionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListSchemaVersionsErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListSchemaVersionsErrorKind::EntityNotFoundException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListSchemaVersionsErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListSchemaVersionsErrorKind::InvalidInputException(_)
        )
    }
}
impl std::error::Error for ListSchemaVersionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListSchemaVersionsErrorKind::AccessDeniedException(_inner) => Some(_inner),
            ListSchemaVersionsErrorKind::EntityNotFoundException(_inner) => Some(_inner),
            ListSchemaVersionsErrorKind::InternalServiceException(_inner) => Some(_inner),
            ListSchemaVersionsErrorKind::InvalidInputException(_inner) => Some(_inner),
            ListSchemaVersionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListTriggersError {
    pub kind: ListTriggersErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListTriggersErrorKind {
    EntityNotFoundException(crate::error::EntityNotFoundException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListTriggersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListTriggersErrorKind::EntityNotFoundException(_inner) => _inner.fmt(f),
            ListTriggersErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            ListTriggersErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            ListTriggersErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            ListTriggersErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListTriggersError {
    fn code(&self) -> Option<&str> {
        ListTriggersError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListTriggersError {
    pub fn new(kind: ListTriggersErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListTriggersErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListTriggersErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTriggersErrorKind::EntityNotFoundException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTriggersErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(&self.kind, ListTriggersErrorKind::InvalidInputException(_))
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTriggersErrorKind::OperationTimeoutException(_)
        )
    }
}
impl std::error::Error for ListTriggersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListTriggersErrorKind::EntityNotFoundException(_inner) => Some(_inner),
            ListTriggersErrorKind::InternalServiceException(_inner) => Some(_inner),
            ListTriggersErrorKind::InvalidInputException(_inner) => Some(_inner),
            ListTriggersErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            ListTriggersErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListWorkflowsError {
    pub kind: ListWorkflowsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListWorkflowsErrorKind {
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListWorkflowsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListWorkflowsErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            ListWorkflowsErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            ListWorkflowsErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            ListWorkflowsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListWorkflowsError {
    fn code(&self) -> Option<&str> {
        ListWorkflowsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListWorkflowsError {
    pub fn new(kind: ListWorkflowsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListWorkflowsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListWorkflowsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListWorkflowsErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(&self.kind, ListWorkflowsErrorKind::InvalidInputException(_))
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListWorkflowsErrorKind::OperationTimeoutException(_)
        )
    }
}
impl std::error::Error for ListWorkflowsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListWorkflowsErrorKind::InternalServiceException(_inner) => Some(_inner),
            ListWorkflowsErrorKind::InvalidInputException(_inner) => Some(_inner),
            ListWorkflowsErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            ListWorkflowsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutDataCatalogEncryptionSettingsError {
    pub kind: PutDataCatalogEncryptionSettingsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutDataCatalogEncryptionSettingsErrorKind {
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutDataCatalogEncryptionSettingsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutDataCatalogEncryptionSettingsErrorKind::InternalServiceException(_inner) => {
                _inner.fmt(f)
            }
            PutDataCatalogEncryptionSettingsErrorKind::InvalidInputException(_inner) => {
                _inner.fmt(f)
            }
            PutDataCatalogEncryptionSettingsErrorKind::OperationTimeoutException(_inner) => {
                _inner.fmt(f)
            }
            PutDataCatalogEncryptionSettingsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutDataCatalogEncryptionSettingsError {
    fn code(&self) -> Option<&str> {
        PutDataCatalogEncryptionSettingsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutDataCatalogEncryptionSettingsError {
    pub fn new(kind: PutDataCatalogEncryptionSettingsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutDataCatalogEncryptionSettingsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutDataCatalogEncryptionSettingsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutDataCatalogEncryptionSettingsErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutDataCatalogEncryptionSettingsErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutDataCatalogEncryptionSettingsErrorKind::OperationTimeoutException(_)
        )
    }
}
impl std::error::Error for PutDataCatalogEncryptionSettingsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutDataCatalogEncryptionSettingsErrorKind::InternalServiceException(_inner) => {
                Some(_inner)
            }
            PutDataCatalogEncryptionSettingsErrorKind::InvalidInputException(_inner) => {
                Some(_inner)
            }
            PutDataCatalogEncryptionSettingsErrorKind::OperationTimeoutException(_inner) => {
                Some(_inner)
            }
            PutDataCatalogEncryptionSettingsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutResourcePolicyError {
    pub kind: PutResourcePolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutResourcePolicyErrorKind {
    ConditionCheckFailureException(crate::error::ConditionCheckFailureException),
    EntityNotFoundException(crate::error::EntityNotFoundException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutResourcePolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutResourcePolicyErrorKind::ConditionCheckFailureException(_inner) => _inner.fmt(f),
            PutResourcePolicyErrorKind::EntityNotFoundException(_inner) => _inner.fmt(f),
            PutResourcePolicyErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            PutResourcePolicyErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            PutResourcePolicyErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            PutResourcePolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutResourcePolicyError {
    fn code(&self) -> Option<&str> {
        PutResourcePolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutResourcePolicyError {
    pub fn new(kind: PutResourcePolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutResourcePolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutResourcePolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_condition_check_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutResourcePolicyErrorKind::ConditionCheckFailureException(_)
        )
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutResourcePolicyErrorKind::EntityNotFoundException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutResourcePolicyErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutResourcePolicyErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutResourcePolicyErrorKind::OperationTimeoutException(_)
        )
    }
}
impl std::error::Error for PutResourcePolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutResourcePolicyErrorKind::ConditionCheckFailureException(_inner) => Some(_inner),
            PutResourcePolicyErrorKind::EntityNotFoundException(_inner) => Some(_inner),
            PutResourcePolicyErrorKind::InternalServiceException(_inner) => Some(_inner),
            PutResourcePolicyErrorKind::InvalidInputException(_inner) => Some(_inner),
            PutResourcePolicyErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            PutResourcePolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutSchemaVersionMetadataError {
    pub kind: PutSchemaVersionMetadataErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutSchemaVersionMetadataErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AlreadyExistsException(crate::error::AlreadyExistsException),
    EntityNotFoundException(crate::error::EntityNotFoundException),
    InvalidInputException(crate::error::InvalidInputException),
    ResourceNumberLimitExceededException(crate::error::ResourceNumberLimitExceededException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutSchemaVersionMetadataError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutSchemaVersionMetadataErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            PutSchemaVersionMetadataErrorKind::AlreadyExistsException(_inner) => _inner.fmt(f),
            PutSchemaVersionMetadataErrorKind::EntityNotFoundException(_inner) => _inner.fmt(f),
            PutSchemaVersionMetadataErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            PutSchemaVersionMetadataErrorKind::ResourceNumberLimitExceededException(_inner) => {
                _inner.fmt(f)
            }
            PutSchemaVersionMetadataErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutSchemaVersionMetadataError {
    fn code(&self) -> Option<&str> {
        PutSchemaVersionMetadataError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutSchemaVersionMetadataError {
    pub fn new(kind: PutSchemaVersionMetadataErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutSchemaVersionMetadataErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutSchemaVersionMetadataErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutSchemaVersionMetadataErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutSchemaVersionMetadataErrorKind::AlreadyExistsException(_)
        )
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutSchemaVersionMetadataErrorKind::EntityNotFoundException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutSchemaVersionMetadataErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_resource_number_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutSchemaVersionMetadataErrorKind::ResourceNumberLimitExceededException(_)
        )
    }
}
impl std::error::Error for PutSchemaVersionMetadataError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutSchemaVersionMetadataErrorKind::AccessDeniedException(_inner) => Some(_inner),
            PutSchemaVersionMetadataErrorKind::AlreadyExistsException(_inner) => Some(_inner),
            PutSchemaVersionMetadataErrorKind::EntityNotFoundException(_inner) => Some(_inner),
            PutSchemaVersionMetadataErrorKind::InvalidInputException(_inner) => Some(_inner),
            PutSchemaVersionMetadataErrorKind::ResourceNumberLimitExceededException(_inner) => {
                Some(_inner)
            }
            PutSchemaVersionMetadataErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutWorkflowRunPropertiesError {
    pub kind: PutWorkflowRunPropertiesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutWorkflowRunPropertiesErrorKind {
    AlreadyExistsException(crate::error::AlreadyExistsException),
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    EntityNotFoundException(crate::error::EntityNotFoundException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    ResourceNumberLimitExceededException(crate::error::ResourceNumberLimitExceededException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutWorkflowRunPropertiesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutWorkflowRunPropertiesErrorKind::AlreadyExistsException(_inner) => _inner.fmt(f),
            PutWorkflowRunPropertiesErrorKind::ConcurrentModificationException(_inner) => {
                _inner.fmt(f)
            }
            PutWorkflowRunPropertiesErrorKind::EntityNotFoundException(_inner) => _inner.fmt(f),
            PutWorkflowRunPropertiesErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            PutWorkflowRunPropertiesErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            PutWorkflowRunPropertiesErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            PutWorkflowRunPropertiesErrorKind::ResourceNumberLimitExceededException(_inner) => {
                _inner.fmt(f)
            }
            PutWorkflowRunPropertiesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutWorkflowRunPropertiesError {
    fn code(&self) -> Option<&str> {
        PutWorkflowRunPropertiesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutWorkflowRunPropertiesError {
    pub fn new(kind: PutWorkflowRunPropertiesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutWorkflowRunPropertiesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutWorkflowRunPropertiesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutWorkflowRunPropertiesErrorKind::AlreadyExistsException(_)
        )
    }
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutWorkflowRunPropertiesErrorKind::ConcurrentModificationException(_)
        )
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutWorkflowRunPropertiesErrorKind::EntityNotFoundException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutWorkflowRunPropertiesErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutWorkflowRunPropertiesErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutWorkflowRunPropertiesErrorKind::OperationTimeoutException(_)
        )
    }
    pub fn is_resource_number_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutWorkflowRunPropertiesErrorKind::ResourceNumberLimitExceededException(_)
        )
    }
}
impl std::error::Error for PutWorkflowRunPropertiesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutWorkflowRunPropertiesErrorKind::AlreadyExistsException(_inner) => Some(_inner),
            PutWorkflowRunPropertiesErrorKind::ConcurrentModificationException(_inner) => {
                Some(_inner)
            }
            PutWorkflowRunPropertiesErrorKind::EntityNotFoundException(_inner) => Some(_inner),
            PutWorkflowRunPropertiesErrorKind::InternalServiceException(_inner) => Some(_inner),
            PutWorkflowRunPropertiesErrorKind::InvalidInputException(_inner) => Some(_inner),
            PutWorkflowRunPropertiesErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            PutWorkflowRunPropertiesErrorKind::ResourceNumberLimitExceededException(_inner) => {
                Some(_inner)
            }
            PutWorkflowRunPropertiesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct QuerySchemaVersionMetadataError {
    pub kind: QuerySchemaVersionMetadataErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum QuerySchemaVersionMetadataErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    EntityNotFoundException(crate::error::EntityNotFoundException),
    InvalidInputException(crate::error::InvalidInputException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for QuerySchemaVersionMetadataError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            QuerySchemaVersionMetadataErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            QuerySchemaVersionMetadataErrorKind::EntityNotFoundException(_inner) => _inner.fmt(f),
            QuerySchemaVersionMetadataErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            QuerySchemaVersionMetadataErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for QuerySchemaVersionMetadataError {
    fn code(&self) -> Option<&str> {
        QuerySchemaVersionMetadataError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl QuerySchemaVersionMetadataError {
    pub fn new(kind: QuerySchemaVersionMetadataErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: QuerySchemaVersionMetadataErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: QuerySchemaVersionMetadataErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            QuerySchemaVersionMetadataErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            QuerySchemaVersionMetadataErrorKind::EntityNotFoundException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            QuerySchemaVersionMetadataErrorKind::InvalidInputException(_)
        )
    }
}
impl std::error::Error for QuerySchemaVersionMetadataError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            QuerySchemaVersionMetadataErrorKind::AccessDeniedException(_inner) => Some(_inner),
            QuerySchemaVersionMetadataErrorKind::EntityNotFoundException(_inner) => Some(_inner),
            QuerySchemaVersionMetadataErrorKind::InvalidInputException(_inner) => Some(_inner),
            QuerySchemaVersionMetadataErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RegisterSchemaVersionError {
    pub kind: RegisterSchemaVersionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RegisterSchemaVersionErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    EntityNotFoundException(crate::error::EntityNotFoundException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    ResourceNumberLimitExceededException(crate::error::ResourceNumberLimitExceededException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RegisterSchemaVersionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RegisterSchemaVersionErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            RegisterSchemaVersionErrorKind::ConcurrentModificationException(_inner) => {
                _inner.fmt(f)
            }
            RegisterSchemaVersionErrorKind::EntityNotFoundException(_inner) => _inner.fmt(f),
            RegisterSchemaVersionErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            RegisterSchemaVersionErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            RegisterSchemaVersionErrorKind::ResourceNumberLimitExceededException(_inner) => {
                _inner.fmt(f)
            }
            RegisterSchemaVersionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RegisterSchemaVersionError {
    fn code(&self) -> Option<&str> {
        RegisterSchemaVersionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RegisterSchemaVersionError {
    pub fn new(kind: RegisterSchemaVersionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RegisterSchemaVersionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RegisterSchemaVersionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            RegisterSchemaVersionErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            RegisterSchemaVersionErrorKind::ConcurrentModificationException(_)
        )
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            RegisterSchemaVersionErrorKind::EntityNotFoundException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            RegisterSchemaVersionErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            RegisterSchemaVersionErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_resource_number_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            RegisterSchemaVersionErrorKind::ResourceNumberLimitExceededException(_)
        )
    }
}
impl std::error::Error for RegisterSchemaVersionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RegisterSchemaVersionErrorKind::AccessDeniedException(_inner) => Some(_inner),
            RegisterSchemaVersionErrorKind::ConcurrentModificationException(_inner) => Some(_inner),
            RegisterSchemaVersionErrorKind::EntityNotFoundException(_inner) => Some(_inner),
            RegisterSchemaVersionErrorKind::InternalServiceException(_inner) => Some(_inner),
            RegisterSchemaVersionErrorKind::InvalidInputException(_inner) => Some(_inner),
            RegisterSchemaVersionErrorKind::ResourceNumberLimitExceededException(_inner) => {
                Some(_inner)
            }
            RegisterSchemaVersionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RemoveSchemaVersionMetadataError {
    pub kind: RemoveSchemaVersionMetadataErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RemoveSchemaVersionMetadataErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    EntityNotFoundException(crate::error::EntityNotFoundException),
    InvalidInputException(crate::error::InvalidInputException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RemoveSchemaVersionMetadataError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RemoveSchemaVersionMetadataErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            RemoveSchemaVersionMetadataErrorKind::EntityNotFoundException(_inner) => _inner.fmt(f),
            RemoveSchemaVersionMetadataErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            RemoveSchemaVersionMetadataErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RemoveSchemaVersionMetadataError {
    fn code(&self) -> Option<&str> {
        RemoveSchemaVersionMetadataError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RemoveSchemaVersionMetadataError {
    pub fn new(kind: RemoveSchemaVersionMetadataErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RemoveSchemaVersionMetadataErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RemoveSchemaVersionMetadataErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            RemoveSchemaVersionMetadataErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            RemoveSchemaVersionMetadataErrorKind::EntityNotFoundException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            RemoveSchemaVersionMetadataErrorKind::InvalidInputException(_)
        )
    }
}
impl std::error::Error for RemoveSchemaVersionMetadataError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RemoveSchemaVersionMetadataErrorKind::AccessDeniedException(_inner) => Some(_inner),
            RemoveSchemaVersionMetadataErrorKind::EntityNotFoundException(_inner) => Some(_inner),
            RemoveSchemaVersionMetadataErrorKind::InvalidInputException(_inner) => Some(_inner),
            RemoveSchemaVersionMetadataErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ResetJobBookmarkError {
    pub kind: ResetJobBookmarkErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ResetJobBookmarkErrorKind {
    EntityNotFoundException(crate::error::EntityNotFoundException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ResetJobBookmarkError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ResetJobBookmarkErrorKind::EntityNotFoundException(_inner) => _inner.fmt(f),
            ResetJobBookmarkErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            ResetJobBookmarkErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            ResetJobBookmarkErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            ResetJobBookmarkErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ResetJobBookmarkError {
    fn code(&self) -> Option<&str> {
        ResetJobBookmarkError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ResetJobBookmarkError {
    pub fn new(kind: ResetJobBookmarkErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ResetJobBookmarkErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ResetJobBookmarkErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ResetJobBookmarkErrorKind::EntityNotFoundException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            ResetJobBookmarkErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            ResetJobBookmarkErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            ResetJobBookmarkErrorKind::OperationTimeoutException(_)
        )
    }
}
impl std::error::Error for ResetJobBookmarkError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ResetJobBookmarkErrorKind::EntityNotFoundException(_inner) => Some(_inner),
            ResetJobBookmarkErrorKind::InternalServiceException(_inner) => Some(_inner),
            ResetJobBookmarkErrorKind::InvalidInputException(_inner) => Some(_inner),
            ResetJobBookmarkErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            ResetJobBookmarkErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ResumeWorkflowRunError {
    pub kind: ResumeWorkflowRunErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ResumeWorkflowRunErrorKind {
    ConcurrentRunsExceededException(crate::error::ConcurrentRunsExceededException),
    EntityNotFoundException(crate::error::EntityNotFoundException),
    IllegalWorkflowStateException(crate::error::IllegalWorkflowStateException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ResumeWorkflowRunError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ResumeWorkflowRunErrorKind::ConcurrentRunsExceededException(_inner) => _inner.fmt(f),
            ResumeWorkflowRunErrorKind::EntityNotFoundException(_inner) => _inner.fmt(f),
            ResumeWorkflowRunErrorKind::IllegalWorkflowStateException(_inner) => _inner.fmt(f),
            ResumeWorkflowRunErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            ResumeWorkflowRunErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            ResumeWorkflowRunErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            ResumeWorkflowRunErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ResumeWorkflowRunError {
    fn code(&self) -> Option<&str> {
        ResumeWorkflowRunError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ResumeWorkflowRunError {
    pub fn new(kind: ResumeWorkflowRunErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ResumeWorkflowRunErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ResumeWorkflowRunErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_concurrent_runs_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            ResumeWorkflowRunErrorKind::ConcurrentRunsExceededException(_)
        )
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ResumeWorkflowRunErrorKind::EntityNotFoundException(_)
        )
    }
    pub fn is_illegal_workflow_state_exception(&self) -> bool {
        matches!(
            &self.kind,
            ResumeWorkflowRunErrorKind::IllegalWorkflowStateException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            ResumeWorkflowRunErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            ResumeWorkflowRunErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            ResumeWorkflowRunErrorKind::OperationTimeoutException(_)
        )
    }
}
impl std::error::Error for ResumeWorkflowRunError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ResumeWorkflowRunErrorKind::ConcurrentRunsExceededException(_inner) => Some(_inner),
            ResumeWorkflowRunErrorKind::EntityNotFoundException(_inner) => Some(_inner),
            ResumeWorkflowRunErrorKind::IllegalWorkflowStateException(_inner) => Some(_inner),
            ResumeWorkflowRunErrorKind::InternalServiceException(_inner) => Some(_inner),
            ResumeWorkflowRunErrorKind::InvalidInputException(_inner) => Some(_inner),
            ResumeWorkflowRunErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            ResumeWorkflowRunErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct SearchTablesError {
    pub kind: SearchTablesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum SearchTablesErrorKind {
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for SearchTablesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            SearchTablesErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            SearchTablesErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            SearchTablesErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            SearchTablesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for SearchTablesError {
    fn code(&self) -> Option<&str> {
        SearchTablesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl SearchTablesError {
    pub fn new(kind: SearchTablesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: SearchTablesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: SearchTablesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            SearchTablesErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(&self.kind, SearchTablesErrorKind::InvalidInputException(_))
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            SearchTablesErrorKind::OperationTimeoutException(_)
        )
    }
}
impl std::error::Error for SearchTablesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            SearchTablesErrorKind::InternalServiceException(_inner) => Some(_inner),
            SearchTablesErrorKind::InvalidInputException(_inner) => Some(_inner),
            SearchTablesErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            SearchTablesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StartBlueprintRunError {
    pub kind: StartBlueprintRunErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StartBlueprintRunErrorKind {
    EntityNotFoundException(crate::error::EntityNotFoundException),
    IllegalBlueprintStateException(crate::error::IllegalBlueprintStateException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    ResourceNumberLimitExceededException(crate::error::ResourceNumberLimitExceededException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StartBlueprintRunError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StartBlueprintRunErrorKind::EntityNotFoundException(_inner) => _inner.fmt(f),
            StartBlueprintRunErrorKind::IllegalBlueprintStateException(_inner) => _inner.fmt(f),
            StartBlueprintRunErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            StartBlueprintRunErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            StartBlueprintRunErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            StartBlueprintRunErrorKind::ResourceNumberLimitExceededException(_inner) => {
                _inner.fmt(f)
            }
            StartBlueprintRunErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for StartBlueprintRunError {
    fn code(&self) -> Option<&str> {
        StartBlueprintRunError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl StartBlueprintRunError {
    pub fn new(kind: StartBlueprintRunErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StartBlueprintRunErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StartBlueprintRunErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartBlueprintRunErrorKind::EntityNotFoundException(_)
        )
    }
    pub fn is_illegal_blueprint_state_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartBlueprintRunErrorKind::IllegalBlueprintStateException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartBlueprintRunErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartBlueprintRunErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartBlueprintRunErrorKind::OperationTimeoutException(_)
        )
    }
    pub fn is_resource_number_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartBlueprintRunErrorKind::ResourceNumberLimitExceededException(_)
        )
    }
}
impl std::error::Error for StartBlueprintRunError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StartBlueprintRunErrorKind::EntityNotFoundException(_inner) => Some(_inner),
            StartBlueprintRunErrorKind::IllegalBlueprintStateException(_inner) => Some(_inner),
            StartBlueprintRunErrorKind::InternalServiceException(_inner) => Some(_inner),
            StartBlueprintRunErrorKind::InvalidInputException(_inner) => Some(_inner),
            StartBlueprintRunErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            StartBlueprintRunErrorKind::ResourceNumberLimitExceededException(_inner) => {
                Some(_inner)
            }
            StartBlueprintRunErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StartCrawlerError {
    pub kind: StartCrawlerErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StartCrawlerErrorKind {
    CrawlerRunningException(crate::error::CrawlerRunningException),
    EntityNotFoundException(crate::error::EntityNotFoundException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StartCrawlerError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StartCrawlerErrorKind::CrawlerRunningException(_inner) => _inner.fmt(f),
            StartCrawlerErrorKind::EntityNotFoundException(_inner) => _inner.fmt(f),
            StartCrawlerErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            StartCrawlerErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for StartCrawlerError {
    fn code(&self) -> Option<&str> {
        StartCrawlerError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl StartCrawlerError {
    pub fn new(kind: StartCrawlerErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StartCrawlerErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StartCrawlerErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_crawler_running_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartCrawlerErrorKind::CrawlerRunningException(_)
        )
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartCrawlerErrorKind::EntityNotFoundException(_)
        )
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartCrawlerErrorKind::OperationTimeoutException(_)
        )
    }
}
impl std::error::Error for StartCrawlerError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StartCrawlerErrorKind::CrawlerRunningException(_inner) => Some(_inner),
            StartCrawlerErrorKind::EntityNotFoundException(_inner) => Some(_inner),
            StartCrawlerErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            StartCrawlerErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StartCrawlerScheduleError {
    pub kind: StartCrawlerScheduleErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StartCrawlerScheduleErrorKind {
    EntityNotFoundException(crate::error::EntityNotFoundException),
    NoScheduleException(crate::error::NoScheduleException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    SchedulerRunningException(crate::error::SchedulerRunningException),
    SchedulerTransitioningException(crate::error::SchedulerTransitioningException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StartCrawlerScheduleError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StartCrawlerScheduleErrorKind::EntityNotFoundException(_inner) => _inner.fmt(f),
            StartCrawlerScheduleErrorKind::NoScheduleException(_inner) => _inner.fmt(f),
            StartCrawlerScheduleErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            StartCrawlerScheduleErrorKind::SchedulerRunningException(_inner) => _inner.fmt(f),
            StartCrawlerScheduleErrorKind::SchedulerTransitioningException(_inner) => _inner.fmt(f),
            StartCrawlerScheduleErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for StartCrawlerScheduleError {
    fn code(&self) -> Option<&str> {
        StartCrawlerScheduleError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl StartCrawlerScheduleError {
    pub fn new(kind: StartCrawlerScheduleErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StartCrawlerScheduleErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StartCrawlerScheduleErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartCrawlerScheduleErrorKind::EntityNotFoundException(_)
        )
    }
    pub fn is_no_schedule_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartCrawlerScheduleErrorKind::NoScheduleException(_)
        )
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartCrawlerScheduleErrorKind::OperationTimeoutException(_)
        )
    }
    pub fn is_scheduler_running_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartCrawlerScheduleErrorKind::SchedulerRunningException(_)
        )
    }
    pub fn is_scheduler_transitioning_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartCrawlerScheduleErrorKind::SchedulerTransitioningException(_)
        )
    }
}
impl std::error::Error for StartCrawlerScheduleError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StartCrawlerScheduleErrorKind::EntityNotFoundException(_inner) => Some(_inner),
            StartCrawlerScheduleErrorKind::NoScheduleException(_inner) => Some(_inner),
            StartCrawlerScheduleErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            StartCrawlerScheduleErrorKind::SchedulerRunningException(_inner) => Some(_inner),
            StartCrawlerScheduleErrorKind::SchedulerTransitioningException(_inner) => Some(_inner),
            StartCrawlerScheduleErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StartExportLabelsTaskRunError {
    pub kind: StartExportLabelsTaskRunErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StartExportLabelsTaskRunErrorKind {
    EntityNotFoundException(crate::error::EntityNotFoundException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StartExportLabelsTaskRunError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StartExportLabelsTaskRunErrorKind::EntityNotFoundException(_inner) => _inner.fmt(f),
            StartExportLabelsTaskRunErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            StartExportLabelsTaskRunErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            StartExportLabelsTaskRunErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            StartExportLabelsTaskRunErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for StartExportLabelsTaskRunError {
    fn code(&self) -> Option<&str> {
        StartExportLabelsTaskRunError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl StartExportLabelsTaskRunError {
    pub fn new(kind: StartExportLabelsTaskRunErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StartExportLabelsTaskRunErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StartExportLabelsTaskRunErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartExportLabelsTaskRunErrorKind::EntityNotFoundException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartExportLabelsTaskRunErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartExportLabelsTaskRunErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartExportLabelsTaskRunErrorKind::OperationTimeoutException(_)
        )
    }
}
impl std::error::Error for StartExportLabelsTaskRunError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StartExportLabelsTaskRunErrorKind::EntityNotFoundException(_inner) => Some(_inner),
            StartExportLabelsTaskRunErrorKind::InternalServiceException(_inner) => Some(_inner),
            StartExportLabelsTaskRunErrorKind::InvalidInputException(_inner) => Some(_inner),
            StartExportLabelsTaskRunErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            StartExportLabelsTaskRunErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StartImportLabelsTaskRunError {
    pub kind: StartImportLabelsTaskRunErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StartImportLabelsTaskRunErrorKind {
    EntityNotFoundException(crate::error::EntityNotFoundException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    ResourceNumberLimitExceededException(crate::error::ResourceNumberLimitExceededException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StartImportLabelsTaskRunError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StartImportLabelsTaskRunErrorKind::EntityNotFoundException(_inner) => _inner.fmt(f),
            StartImportLabelsTaskRunErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            StartImportLabelsTaskRunErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            StartImportLabelsTaskRunErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            StartImportLabelsTaskRunErrorKind::ResourceNumberLimitExceededException(_inner) => {
                _inner.fmt(f)
            }
            StartImportLabelsTaskRunErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for StartImportLabelsTaskRunError {
    fn code(&self) -> Option<&str> {
        StartImportLabelsTaskRunError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl StartImportLabelsTaskRunError {
    pub fn new(kind: StartImportLabelsTaskRunErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StartImportLabelsTaskRunErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StartImportLabelsTaskRunErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartImportLabelsTaskRunErrorKind::EntityNotFoundException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartImportLabelsTaskRunErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartImportLabelsTaskRunErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartImportLabelsTaskRunErrorKind::OperationTimeoutException(_)
        )
    }
    pub fn is_resource_number_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartImportLabelsTaskRunErrorKind::ResourceNumberLimitExceededException(_)
        )
    }
}
impl std::error::Error for StartImportLabelsTaskRunError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StartImportLabelsTaskRunErrorKind::EntityNotFoundException(_inner) => Some(_inner),
            StartImportLabelsTaskRunErrorKind::InternalServiceException(_inner) => Some(_inner),
            StartImportLabelsTaskRunErrorKind::InvalidInputException(_inner) => Some(_inner),
            StartImportLabelsTaskRunErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            StartImportLabelsTaskRunErrorKind::ResourceNumberLimitExceededException(_inner) => {
                Some(_inner)
            }
            StartImportLabelsTaskRunErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StartJobRunError {
    pub kind: StartJobRunErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StartJobRunErrorKind {
    ConcurrentRunsExceededException(crate::error::ConcurrentRunsExceededException),
    EntityNotFoundException(crate::error::EntityNotFoundException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    ResourceNumberLimitExceededException(crate::error::ResourceNumberLimitExceededException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StartJobRunError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StartJobRunErrorKind::ConcurrentRunsExceededException(_inner) => _inner.fmt(f),
            StartJobRunErrorKind::EntityNotFoundException(_inner) => _inner.fmt(f),
            StartJobRunErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            StartJobRunErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            StartJobRunErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            StartJobRunErrorKind::ResourceNumberLimitExceededException(_inner) => _inner.fmt(f),
            StartJobRunErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for StartJobRunError {
    fn code(&self) -> Option<&str> {
        StartJobRunError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl StartJobRunError {
    pub fn new(kind: StartJobRunErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StartJobRunErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StartJobRunErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_concurrent_runs_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartJobRunErrorKind::ConcurrentRunsExceededException(_)
        )
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(&self.kind, StartJobRunErrorKind::EntityNotFoundException(_))
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartJobRunErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(&self.kind, StartJobRunErrorKind::InvalidInputException(_))
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartJobRunErrorKind::OperationTimeoutException(_)
        )
    }
    pub fn is_resource_number_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartJobRunErrorKind::ResourceNumberLimitExceededException(_)
        )
    }
}
impl std::error::Error for StartJobRunError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StartJobRunErrorKind::ConcurrentRunsExceededException(_inner) => Some(_inner),
            StartJobRunErrorKind::EntityNotFoundException(_inner) => Some(_inner),
            StartJobRunErrorKind::InternalServiceException(_inner) => Some(_inner),
            StartJobRunErrorKind::InvalidInputException(_inner) => Some(_inner),
            StartJobRunErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            StartJobRunErrorKind::ResourceNumberLimitExceededException(_inner) => Some(_inner),
            StartJobRunErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StartMLEvaluationTaskRunError {
    pub kind: StartMLEvaluationTaskRunErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StartMLEvaluationTaskRunErrorKind {
    ConcurrentRunsExceededException(crate::error::ConcurrentRunsExceededException),
    EntityNotFoundException(crate::error::EntityNotFoundException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    MlTransformNotReadyException(crate::error::MlTransformNotReadyException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StartMLEvaluationTaskRunError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StartMLEvaluationTaskRunErrorKind::ConcurrentRunsExceededException(_inner) => {
                _inner.fmt(f)
            }
            StartMLEvaluationTaskRunErrorKind::EntityNotFoundException(_inner) => _inner.fmt(f),
            StartMLEvaluationTaskRunErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            StartMLEvaluationTaskRunErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            StartMLEvaluationTaskRunErrorKind::MlTransformNotReadyException(_inner) => {
                _inner.fmt(f)
            }
            StartMLEvaluationTaskRunErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            StartMLEvaluationTaskRunErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for StartMLEvaluationTaskRunError {
    fn code(&self) -> Option<&str> {
        StartMLEvaluationTaskRunError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl StartMLEvaluationTaskRunError {
    pub fn new(kind: StartMLEvaluationTaskRunErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StartMLEvaluationTaskRunErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StartMLEvaluationTaskRunErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_concurrent_runs_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartMLEvaluationTaskRunErrorKind::ConcurrentRunsExceededException(_)
        )
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartMLEvaluationTaskRunErrorKind::EntityNotFoundException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartMLEvaluationTaskRunErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartMLEvaluationTaskRunErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_ml_transform_not_ready_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartMLEvaluationTaskRunErrorKind::MlTransformNotReadyException(_)
        )
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartMLEvaluationTaskRunErrorKind::OperationTimeoutException(_)
        )
    }
}
impl std::error::Error for StartMLEvaluationTaskRunError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StartMLEvaluationTaskRunErrorKind::ConcurrentRunsExceededException(_inner) => {
                Some(_inner)
            }
            StartMLEvaluationTaskRunErrorKind::EntityNotFoundException(_inner) => Some(_inner),
            StartMLEvaluationTaskRunErrorKind::InternalServiceException(_inner) => Some(_inner),
            StartMLEvaluationTaskRunErrorKind::InvalidInputException(_inner) => Some(_inner),
            StartMLEvaluationTaskRunErrorKind::MlTransformNotReadyException(_inner) => Some(_inner),
            StartMLEvaluationTaskRunErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            StartMLEvaluationTaskRunErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StartMLLabelingSetGenerationTaskRunError {
    pub kind: StartMLLabelingSetGenerationTaskRunErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StartMLLabelingSetGenerationTaskRunErrorKind {
    ConcurrentRunsExceededException(crate::error::ConcurrentRunsExceededException),
    EntityNotFoundException(crate::error::EntityNotFoundException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StartMLLabelingSetGenerationTaskRunError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StartMLLabelingSetGenerationTaskRunErrorKind::ConcurrentRunsExceededException(
                _inner,
            ) => _inner.fmt(f),
            StartMLLabelingSetGenerationTaskRunErrorKind::EntityNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            StartMLLabelingSetGenerationTaskRunErrorKind::InternalServiceException(_inner) => {
                _inner.fmt(f)
            }
            StartMLLabelingSetGenerationTaskRunErrorKind::InvalidInputException(_inner) => {
                _inner.fmt(f)
            }
            StartMLLabelingSetGenerationTaskRunErrorKind::OperationTimeoutException(_inner) => {
                _inner.fmt(f)
            }
            StartMLLabelingSetGenerationTaskRunErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for StartMLLabelingSetGenerationTaskRunError {
    fn code(&self) -> Option<&str> {
        StartMLLabelingSetGenerationTaskRunError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl StartMLLabelingSetGenerationTaskRunError {
    pub fn new(
        kind: StartMLLabelingSetGenerationTaskRunErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StartMLLabelingSetGenerationTaskRunErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StartMLLabelingSetGenerationTaskRunErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_concurrent_runs_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartMLLabelingSetGenerationTaskRunErrorKind::ConcurrentRunsExceededException(_)
        )
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartMLLabelingSetGenerationTaskRunErrorKind::EntityNotFoundException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartMLLabelingSetGenerationTaskRunErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartMLLabelingSetGenerationTaskRunErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartMLLabelingSetGenerationTaskRunErrorKind::OperationTimeoutException(_)
        )
    }
}
impl std::error::Error for StartMLLabelingSetGenerationTaskRunError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StartMLLabelingSetGenerationTaskRunErrorKind::ConcurrentRunsExceededException(
                _inner,
            ) => Some(_inner),
            StartMLLabelingSetGenerationTaskRunErrorKind::EntityNotFoundException(_inner) => {
                Some(_inner)
            }
            StartMLLabelingSetGenerationTaskRunErrorKind::InternalServiceException(_inner) => {
                Some(_inner)
            }
            StartMLLabelingSetGenerationTaskRunErrorKind::InvalidInputException(_inner) => {
                Some(_inner)
            }
            StartMLLabelingSetGenerationTaskRunErrorKind::OperationTimeoutException(_inner) => {
                Some(_inner)
            }
            StartMLLabelingSetGenerationTaskRunErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StartTriggerError {
    pub kind: StartTriggerErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StartTriggerErrorKind {
    ConcurrentRunsExceededException(crate::error::ConcurrentRunsExceededException),
    EntityNotFoundException(crate::error::EntityNotFoundException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    ResourceNumberLimitExceededException(crate::error::ResourceNumberLimitExceededException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StartTriggerError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StartTriggerErrorKind::ConcurrentRunsExceededException(_inner) => _inner.fmt(f),
            StartTriggerErrorKind::EntityNotFoundException(_inner) => _inner.fmt(f),
            StartTriggerErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            StartTriggerErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            StartTriggerErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            StartTriggerErrorKind::ResourceNumberLimitExceededException(_inner) => _inner.fmt(f),
            StartTriggerErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for StartTriggerError {
    fn code(&self) -> Option<&str> {
        StartTriggerError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl StartTriggerError {
    pub fn new(kind: StartTriggerErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StartTriggerErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StartTriggerErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_concurrent_runs_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartTriggerErrorKind::ConcurrentRunsExceededException(_)
        )
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartTriggerErrorKind::EntityNotFoundException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartTriggerErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(&self.kind, StartTriggerErrorKind::InvalidInputException(_))
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartTriggerErrorKind::OperationTimeoutException(_)
        )
    }
    pub fn is_resource_number_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartTriggerErrorKind::ResourceNumberLimitExceededException(_)
        )
    }
}
impl std::error::Error for StartTriggerError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StartTriggerErrorKind::ConcurrentRunsExceededException(_inner) => Some(_inner),
            StartTriggerErrorKind::EntityNotFoundException(_inner) => Some(_inner),
            StartTriggerErrorKind::InternalServiceException(_inner) => Some(_inner),
            StartTriggerErrorKind::InvalidInputException(_inner) => Some(_inner),
            StartTriggerErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            StartTriggerErrorKind::ResourceNumberLimitExceededException(_inner) => Some(_inner),
            StartTriggerErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StartWorkflowRunError {
    pub kind: StartWorkflowRunErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StartWorkflowRunErrorKind {
    ConcurrentRunsExceededException(crate::error::ConcurrentRunsExceededException),
    EntityNotFoundException(crate::error::EntityNotFoundException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    ResourceNumberLimitExceededException(crate::error::ResourceNumberLimitExceededException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StartWorkflowRunError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StartWorkflowRunErrorKind::ConcurrentRunsExceededException(_inner) => _inner.fmt(f),
            StartWorkflowRunErrorKind::EntityNotFoundException(_inner) => _inner.fmt(f),
            StartWorkflowRunErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            StartWorkflowRunErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            StartWorkflowRunErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            StartWorkflowRunErrorKind::ResourceNumberLimitExceededException(_inner) => {
                _inner.fmt(f)
            }
            StartWorkflowRunErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for StartWorkflowRunError {
    fn code(&self) -> Option<&str> {
        StartWorkflowRunError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl StartWorkflowRunError {
    pub fn new(kind: StartWorkflowRunErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StartWorkflowRunErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StartWorkflowRunErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_concurrent_runs_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartWorkflowRunErrorKind::ConcurrentRunsExceededException(_)
        )
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartWorkflowRunErrorKind::EntityNotFoundException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartWorkflowRunErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartWorkflowRunErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartWorkflowRunErrorKind::OperationTimeoutException(_)
        )
    }
    pub fn is_resource_number_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartWorkflowRunErrorKind::ResourceNumberLimitExceededException(_)
        )
    }
}
impl std::error::Error for StartWorkflowRunError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StartWorkflowRunErrorKind::ConcurrentRunsExceededException(_inner) => Some(_inner),
            StartWorkflowRunErrorKind::EntityNotFoundException(_inner) => Some(_inner),
            StartWorkflowRunErrorKind::InternalServiceException(_inner) => Some(_inner),
            StartWorkflowRunErrorKind::InvalidInputException(_inner) => Some(_inner),
            StartWorkflowRunErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            StartWorkflowRunErrorKind::ResourceNumberLimitExceededException(_inner) => Some(_inner),
            StartWorkflowRunErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StopCrawlerError {
    pub kind: StopCrawlerErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StopCrawlerErrorKind {
    CrawlerNotRunningException(crate::error::CrawlerNotRunningException),
    CrawlerStoppingException(crate::error::CrawlerStoppingException),
    EntityNotFoundException(crate::error::EntityNotFoundException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StopCrawlerError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StopCrawlerErrorKind::CrawlerNotRunningException(_inner) => _inner.fmt(f),
            StopCrawlerErrorKind::CrawlerStoppingException(_inner) => _inner.fmt(f),
            StopCrawlerErrorKind::EntityNotFoundException(_inner) => _inner.fmt(f),
            StopCrawlerErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            StopCrawlerErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for StopCrawlerError {
    fn code(&self) -> Option<&str> {
        StopCrawlerError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl StopCrawlerError {
    pub fn new(kind: StopCrawlerErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StopCrawlerErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StopCrawlerErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_crawler_not_running_exception(&self) -> bool {
        matches!(
            &self.kind,
            StopCrawlerErrorKind::CrawlerNotRunningException(_)
        )
    }
    pub fn is_crawler_stopping_exception(&self) -> bool {
        matches!(
            &self.kind,
            StopCrawlerErrorKind::CrawlerStoppingException(_)
        )
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(&self.kind, StopCrawlerErrorKind::EntityNotFoundException(_))
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            StopCrawlerErrorKind::OperationTimeoutException(_)
        )
    }
}
impl std::error::Error for StopCrawlerError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StopCrawlerErrorKind::CrawlerNotRunningException(_inner) => Some(_inner),
            StopCrawlerErrorKind::CrawlerStoppingException(_inner) => Some(_inner),
            StopCrawlerErrorKind::EntityNotFoundException(_inner) => Some(_inner),
            StopCrawlerErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            StopCrawlerErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StopCrawlerScheduleError {
    pub kind: StopCrawlerScheduleErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StopCrawlerScheduleErrorKind {
    EntityNotFoundException(crate::error::EntityNotFoundException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    SchedulerNotRunningException(crate::error::SchedulerNotRunningException),
    SchedulerTransitioningException(crate::error::SchedulerTransitioningException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StopCrawlerScheduleError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StopCrawlerScheduleErrorKind::EntityNotFoundException(_inner) => _inner.fmt(f),
            StopCrawlerScheduleErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            StopCrawlerScheduleErrorKind::SchedulerNotRunningException(_inner) => _inner.fmt(f),
            StopCrawlerScheduleErrorKind::SchedulerTransitioningException(_inner) => _inner.fmt(f),
            StopCrawlerScheduleErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for StopCrawlerScheduleError {
    fn code(&self) -> Option<&str> {
        StopCrawlerScheduleError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl StopCrawlerScheduleError {
    pub fn new(kind: StopCrawlerScheduleErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StopCrawlerScheduleErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StopCrawlerScheduleErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            StopCrawlerScheduleErrorKind::EntityNotFoundException(_)
        )
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            StopCrawlerScheduleErrorKind::OperationTimeoutException(_)
        )
    }
    pub fn is_scheduler_not_running_exception(&self) -> bool {
        matches!(
            &self.kind,
            StopCrawlerScheduleErrorKind::SchedulerNotRunningException(_)
        )
    }
    pub fn is_scheduler_transitioning_exception(&self) -> bool {
        matches!(
            &self.kind,
            StopCrawlerScheduleErrorKind::SchedulerTransitioningException(_)
        )
    }
}
impl std::error::Error for StopCrawlerScheduleError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StopCrawlerScheduleErrorKind::EntityNotFoundException(_inner) => Some(_inner),
            StopCrawlerScheduleErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            StopCrawlerScheduleErrorKind::SchedulerNotRunningException(_inner) => Some(_inner),
            StopCrawlerScheduleErrorKind::SchedulerTransitioningException(_inner) => Some(_inner),
            StopCrawlerScheduleErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StopTriggerError {
    pub kind: StopTriggerErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StopTriggerErrorKind {
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    EntityNotFoundException(crate::error::EntityNotFoundException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StopTriggerError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StopTriggerErrorKind::ConcurrentModificationException(_inner) => _inner.fmt(f),
            StopTriggerErrorKind::EntityNotFoundException(_inner) => _inner.fmt(f),
            StopTriggerErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            StopTriggerErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            StopTriggerErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            StopTriggerErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for StopTriggerError {
    fn code(&self) -> Option<&str> {
        StopTriggerError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl StopTriggerError {
    pub fn new(kind: StopTriggerErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StopTriggerErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StopTriggerErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            StopTriggerErrorKind::ConcurrentModificationException(_)
        )
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(&self.kind, StopTriggerErrorKind::EntityNotFoundException(_))
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            StopTriggerErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(&self.kind, StopTriggerErrorKind::InvalidInputException(_))
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            StopTriggerErrorKind::OperationTimeoutException(_)
        )
    }
}
impl std::error::Error for StopTriggerError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StopTriggerErrorKind::ConcurrentModificationException(_inner) => Some(_inner),
            StopTriggerErrorKind::EntityNotFoundException(_inner) => Some(_inner),
            StopTriggerErrorKind::InternalServiceException(_inner) => Some(_inner),
            StopTriggerErrorKind::InvalidInputException(_inner) => Some(_inner),
            StopTriggerErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            StopTriggerErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StopWorkflowRunError {
    pub kind: StopWorkflowRunErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StopWorkflowRunErrorKind {
    EntityNotFoundException(crate::error::EntityNotFoundException),
    IllegalWorkflowStateException(crate::error::IllegalWorkflowStateException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StopWorkflowRunError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StopWorkflowRunErrorKind::EntityNotFoundException(_inner) => _inner.fmt(f),
            StopWorkflowRunErrorKind::IllegalWorkflowStateException(_inner) => _inner.fmt(f),
            StopWorkflowRunErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            StopWorkflowRunErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            StopWorkflowRunErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            StopWorkflowRunErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for StopWorkflowRunError {
    fn code(&self) -> Option<&str> {
        StopWorkflowRunError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl StopWorkflowRunError {
    pub fn new(kind: StopWorkflowRunErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StopWorkflowRunErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StopWorkflowRunErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            StopWorkflowRunErrorKind::EntityNotFoundException(_)
        )
    }
    pub fn is_illegal_workflow_state_exception(&self) -> bool {
        matches!(
            &self.kind,
            StopWorkflowRunErrorKind::IllegalWorkflowStateException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            StopWorkflowRunErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            StopWorkflowRunErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            StopWorkflowRunErrorKind::OperationTimeoutException(_)
        )
    }
}
impl std::error::Error for StopWorkflowRunError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StopWorkflowRunErrorKind::EntityNotFoundException(_inner) => Some(_inner),
            StopWorkflowRunErrorKind::IllegalWorkflowStateException(_inner) => Some(_inner),
            StopWorkflowRunErrorKind::InternalServiceException(_inner) => Some(_inner),
            StopWorkflowRunErrorKind::InvalidInputException(_inner) => Some(_inner),
            StopWorkflowRunErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            StopWorkflowRunErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct TagResourceError {
    pub kind: TagResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum TagResourceErrorKind {
    EntityNotFoundException(crate::error::EntityNotFoundException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for TagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            TagResourceErrorKind::EntityNotFoundException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for TagResourceError {
    fn code(&self) -> Option<&str> {
        TagResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl TagResourceError {
    pub fn new(kind: TagResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: TagResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: TagResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::EntityNotFoundException(_))
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            TagResourceErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::InvalidInputException(_))
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            TagResourceErrorKind::OperationTimeoutException(_)
        )
    }
}
impl std::error::Error for TagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            TagResourceErrorKind::EntityNotFoundException(_inner) => Some(_inner),
            TagResourceErrorKind::InternalServiceException(_inner) => Some(_inner),
            TagResourceErrorKind::InvalidInputException(_inner) => Some(_inner),
            TagResourceErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            TagResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UntagResourceError {
    pub kind: UntagResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UntagResourceErrorKind {
    EntityNotFoundException(crate::error::EntityNotFoundException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UntagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UntagResourceErrorKind::EntityNotFoundException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UntagResourceError {
    fn code(&self) -> Option<&str> {
        UntagResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UntagResourceError {
    pub fn new(kind: UntagResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UntagResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UntagResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagResourceErrorKind::EntityNotFoundException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagResourceErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(&self.kind, UntagResourceErrorKind::InvalidInputException(_))
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagResourceErrorKind::OperationTimeoutException(_)
        )
    }
}
impl std::error::Error for UntagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UntagResourceErrorKind::EntityNotFoundException(_inner) => Some(_inner),
            UntagResourceErrorKind::InternalServiceException(_inner) => Some(_inner),
            UntagResourceErrorKind::InvalidInputException(_inner) => Some(_inner),
            UntagResourceErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            UntagResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateBlueprintError {
    pub kind: UpdateBlueprintErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateBlueprintErrorKind {
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    EntityNotFoundException(crate::error::EntityNotFoundException),
    IllegalBlueprintStateException(crate::error::IllegalBlueprintStateException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateBlueprintError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateBlueprintErrorKind::ConcurrentModificationException(_inner) => _inner.fmt(f),
            UpdateBlueprintErrorKind::EntityNotFoundException(_inner) => _inner.fmt(f),
            UpdateBlueprintErrorKind::IllegalBlueprintStateException(_inner) => _inner.fmt(f),
            UpdateBlueprintErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            UpdateBlueprintErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            UpdateBlueprintErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            UpdateBlueprintErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateBlueprintError {
    fn code(&self) -> Option<&str> {
        UpdateBlueprintError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateBlueprintError {
    pub fn new(kind: UpdateBlueprintErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateBlueprintErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateBlueprintErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateBlueprintErrorKind::ConcurrentModificationException(_)
        )
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateBlueprintErrorKind::EntityNotFoundException(_)
        )
    }
    pub fn is_illegal_blueprint_state_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateBlueprintErrorKind::IllegalBlueprintStateException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateBlueprintErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateBlueprintErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateBlueprintErrorKind::OperationTimeoutException(_)
        )
    }
}
impl std::error::Error for UpdateBlueprintError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateBlueprintErrorKind::ConcurrentModificationException(_inner) => Some(_inner),
            UpdateBlueprintErrorKind::EntityNotFoundException(_inner) => Some(_inner),
            UpdateBlueprintErrorKind::IllegalBlueprintStateException(_inner) => Some(_inner),
            UpdateBlueprintErrorKind::InternalServiceException(_inner) => Some(_inner),
            UpdateBlueprintErrorKind::InvalidInputException(_inner) => Some(_inner),
            UpdateBlueprintErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            UpdateBlueprintErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateClassifierError {
    pub kind: UpdateClassifierErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateClassifierErrorKind {
    EntityNotFoundException(crate::error::EntityNotFoundException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    VersionMismatchException(crate::error::VersionMismatchException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateClassifierError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateClassifierErrorKind::EntityNotFoundException(_inner) => _inner.fmt(f),
            UpdateClassifierErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            UpdateClassifierErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            UpdateClassifierErrorKind::VersionMismatchException(_inner) => _inner.fmt(f),
            UpdateClassifierErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateClassifierError {
    fn code(&self) -> Option<&str> {
        UpdateClassifierError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateClassifierError {
    pub fn new(kind: UpdateClassifierErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateClassifierErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateClassifierErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateClassifierErrorKind::EntityNotFoundException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateClassifierErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateClassifierErrorKind::OperationTimeoutException(_)
        )
    }
    pub fn is_version_mismatch_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateClassifierErrorKind::VersionMismatchException(_)
        )
    }
}
impl std::error::Error for UpdateClassifierError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateClassifierErrorKind::EntityNotFoundException(_inner) => Some(_inner),
            UpdateClassifierErrorKind::InvalidInputException(_inner) => Some(_inner),
            UpdateClassifierErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            UpdateClassifierErrorKind::VersionMismatchException(_inner) => Some(_inner),
            UpdateClassifierErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateColumnStatisticsForPartitionError {
    pub kind: UpdateColumnStatisticsForPartitionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateColumnStatisticsForPartitionErrorKind {
    EntityNotFoundException(crate::error::EntityNotFoundException),
    GlueEncryptionException(crate::error::GlueEncryptionException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateColumnStatisticsForPartitionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateColumnStatisticsForPartitionErrorKind::EntityNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            UpdateColumnStatisticsForPartitionErrorKind::GlueEncryptionException(_inner) => {
                _inner.fmt(f)
            }
            UpdateColumnStatisticsForPartitionErrorKind::InternalServiceException(_inner) => {
                _inner.fmt(f)
            }
            UpdateColumnStatisticsForPartitionErrorKind::InvalidInputException(_inner) => {
                _inner.fmt(f)
            }
            UpdateColumnStatisticsForPartitionErrorKind::OperationTimeoutException(_inner) => {
                _inner.fmt(f)
            }
            UpdateColumnStatisticsForPartitionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateColumnStatisticsForPartitionError {
    fn code(&self) -> Option<&str> {
        UpdateColumnStatisticsForPartitionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateColumnStatisticsForPartitionError {
    pub fn new(
        kind: UpdateColumnStatisticsForPartitionErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateColumnStatisticsForPartitionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateColumnStatisticsForPartitionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateColumnStatisticsForPartitionErrorKind::EntityNotFoundException(_)
        )
    }
    pub fn is_glue_encryption_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateColumnStatisticsForPartitionErrorKind::GlueEncryptionException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateColumnStatisticsForPartitionErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateColumnStatisticsForPartitionErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateColumnStatisticsForPartitionErrorKind::OperationTimeoutException(_)
        )
    }
}
impl std::error::Error for UpdateColumnStatisticsForPartitionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateColumnStatisticsForPartitionErrorKind::EntityNotFoundException(_inner) => {
                Some(_inner)
            }
            UpdateColumnStatisticsForPartitionErrorKind::GlueEncryptionException(_inner) => {
                Some(_inner)
            }
            UpdateColumnStatisticsForPartitionErrorKind::InternalServiceException(_inner) => {
                Some(_inner)
            }
            UpdateColumnStatisticsForPartitionErrorKind::InvalidInputException(_inner) => {
                Some(_inner)
            }
            UpdateColumnStatisticsForPartitionErrorKind::OperationTimeoutException(_inner) => {
                Some(_inner)
            }
            UpdateColumnStatisticsForPartitionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateColumnStatisticsForTableError {
    pub kind: UpdateColumnStatisticsForTableErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateColumnStatisticsForTableErrorKind {
    EntityNotFoundException(crate::error::EntityNotFoundException),
    GlueEncryptionException(crate::error::GlueEncryptionException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateColumnStatisticsForTableError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateColumnStatisticsForTableErrorKind::EntityNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            UpdateColumnStatisticsForTableErrorKind::GlueEncryptionException(_inner) => {
                _inner.fmt(f)
            }
            UpdateColumnStatisticsForTableErrorKind::InternalServiceException(_inner) => {
                _inner.fmt(f)
            }
            UpdateColumnStatisticsForTableErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            UpdateColumnStatisticsForTableErrorKind::OperationTimeoutException(_inner) => {
                _inner.fmt(f)
            }
            UpdateColumnStatisticsForTableErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateColumnStatisticsForTableError {
    fn code(&self) -> Option<&str> {
        UpdateColumnStatisticsForTableError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateColumnStatisticsForTableError {
    pub fn new(kind: UpdateColumnStatisticsForTableErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateColumnStatisticsForTableErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateColumnStatisticsForTableErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateColumnStatisticsForTableErrorKind::EntityNotFoundException(_)
        )
    }
    pub fn is_glue_encryption_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateColumnStatisticsForTableErrorKind::GlueEncryptionException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateColumnStatisticsForTableErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateColumnStatisticsForTableErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateColumnStatisticsForTableErrorKind::OperationTimeoutException(_)
        )
    }
}
impl std::error::Error for UpdateColumnStatisticsForTableError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateColumnStatisticsForTableErrorKind::EntityNotFoundException(_inner) => {
                Some(_inner)
            }
            UpdateColumnStatisticsForTableErrorKind::GlueEncryptionException(_inner) => {
                Some(_inner)
            }
            UpdateColumnStatisticsForTableErrorKind::InternalServiceException(_inner) => {
                Some(_inner)
            }
            UpdateColumnStatisticsForTableErrorKind::InvalidInputException(_inner) => Some(_inner),
            UpdateColumnStatisticsForTableErrorKind::OperationTimeoutException(_inner) => {
                Some(_inner)
            }
            UpdateColumnStatisticsForTableErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateConnectionError {
    pub kind: UpdateConnectionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateConnectionErrorKind {
    EntityNotFoundException(crate::error::EntityNotFoundException),
    GlueEncryptionException(crate::error::GlueEncryptionException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateConnectionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateConnectionErrorKind::EntityNotFoundException(_inner) => _inner.fmt(f),
            UpdateConnectionErrorKind::GlueEncryptionException(_inner) => _inner.fmt(f),
            UpdateConnectionErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            UpdateConnectionErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            UpdateConnectionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateConnectionError {
    fn code(&self) -> Option<&str> {
        UpdateConnectionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateConnectionError {
    pub fn new(kind: UpdateConnectionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateConnectionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateConnectionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateConnectionErrorKind::EntityNotFoundException(_)
        )
    }
    pub fn is_glue_encryption_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateConnectionErrorKind::GlueEncryptionException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateConnectionErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateConnectionErrorKind::OperationTimeoutException(_)
        )
    }
}
impl std::error::Error for UpdateConnectionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateConnectionErrorKind::EntityNotFoundException(_inner) => Some(_inner),
            UpdateConnectionErrorKind::GlueEncryptionException(_inner) => Some(_inner),
            UpdateConnectionErrorKind::InvalidInputException(_inner) => Some(_inner),
            UpdateConnectionErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            UpdateConnectionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateCrawlerError {
    pub kind: UpdateCrawlerErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateCrawlerErrorKind {
    CrawlerRunningException(crate::error::CrawlerRunningException),
    EntityNotFoundException(crate::error::EntityNotFoundException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    VersionMismatchException(crate::error::VersionMismatchException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateCrawlerError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateCrawlerErrorKind::CrawlerRunningException(_inner) => _inner.fmt(f),
            UpdateCrawlerErrorKind::EntityNotFoundException(_inner) => _inner.fmt(f),
            UpdateCrawlerErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            UpdateCrawlerErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            UpdateCrawlerErrorKind::VersionMismatchException(_inner) => _inner.fmt(f),
            UpdateCrawlerErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateCrawlerError {
    fn code(&self) -> Option<&str> {
        UpdateCrawlerError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateCrawlerError {
    pub fn new(kind: UpdateCrawlerErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateCrawlerErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateCrawlerErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_crawler_running_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateCrawlerErrorKind::CrawlerRunningException(_)
        )
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateCrawlerErrorKind::EntityNotFoundException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(&self.kind, UpdateCrawlerErrorKind::InvalidInputException(_))
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateCrawlerErrorKind::OperationTimeoutException(_)
        )
    }
    pub fn is_version_mismatch_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateCrawlerErrorKind::VersionMismatchException(_)
        )
    }
}
impl std::error::Error for UpdateCrawlerError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateCrawlerErrorKind::CrawlerRunningException(_inner) => Some(_inner),
            UpdateCrawlerErrorKind::EntityNotFoundException(_inner) => Some(_inner),
            UpdateCrawlerErrorKind::InvalidInputException(_inner) => Some(_inner),
            UpdateCrawlerErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            UpdateCrawlerErrorKind::VersionMismatchException(_inner) => Some(_inner),
            UpdateCrawlerErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateCrawlerScheduleError {
    pub kind: UpdateCrawlerScheduleErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateCrawlerScheduleErrorKind {
    EntityNotFoundException(crate::error::EntityNotFoundException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    SchedulerTransitioningException(crate::error::SchedulerTransitioningException),
    VersionMismatchException(crate::error::VersionMismatchException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateCrawlerScheduleError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateCrawlerScheduleErrorKind::EntityNotFoundException(_inner) => _inner.fmt(f),
            UpdateCrawlerScheduleErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            UpdateCrawlerScheduleErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            UpdateCrawlerScheduleErrorKind::SchedulerTransitioningException(_inner) => {
                _inner.fmt(f)
            }
            UpdateCrawlerScheduleErrorKind::VersionMismatchException(_inner) => _inner.fmt(f),
            UpdateCrawlerScheduleErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateCrawlerScheduleError {
    fn code(&self) -> Option<&str> {
        UpdateCrawlerScheduleError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateCrawlerScheduleError {
    pub fn new(kind: UpdateCrawlerScheduleErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateCrawlerScheduleErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateCrawlerScheduleErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateCrawlerScheduleErrorKind::EntityNotFoundException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateCrawlerScheduleErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateCrawlerScheduleErrorKind::OperationTimeoutException(_)
        )
    }
    pub fn is_scheduler_transitioning_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateCrawlerScheduleErrorKind::SchedulerTransitioningException(_)
        )
    }
    pub fn is_version_mismatch_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateCrawlerScheduleErrorKind::VersionMismatchException(_)
        )
    }
}
impl std::error::Error for UpdateCrawlerScheduleError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateCrawlerScheduleErrorKind::EntityNotFoundException(_inner) => Some(_inner),
            UpdateCrawlerScheduleErrorKind::InvalidInputException(_inner) => Some(_inner),
            UpdateCrawlerScheduleErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            UpdateCrawlerScheduleErrorKind::SchedulerTransitioningException(_inner) => Some(_inner),
            UpdateCrawlerScheduleErrorKind::VersionMismatchException(_inner) => Some(_inner),
            UpdateCrawlerScheduleErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateDatabaseError {
    pub kind: UpdateDatabaseErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateDatabaseErrorKind {
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    EntityNotFoundException(crate::error::EntityNotFoundException),
    GlueEncryptionException(crate::error::GlueEncryptionException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateDatabaseError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateDatabaseErrorKind::ConcurrentModificationException(_inner) => _inner.fmt(f),
            UpdateDatabaseErrorKind::EntityNotFoundException(_inner) => _inner.fmt(f),
            UpdateDatabaseErrorKind::GlueEncryptionException(_inner) => _inner.fmt(f),
            UpdateDatabaseErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            UpdateDatabaseErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            UpdateDatabaseErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            UpdateDatabaseErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateDatabaseError {
    fn code(&self) -> Option<&str> {
        UpdateDatabaseError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateDatabaseError {
    pub fn new(kind: UpdateDatabaseErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateDatabaseErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateDatabaseErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDatabaseErrorKind::ConcurrentModificationException(_)
        )
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDatabaseErrorKind::EntityNotFoundException(_)
        )
    }
    pub fn is_glue_encryption_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDatabaseErrorKind::GlueEncryptionException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDatabaseErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDatabaseErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDatabaseErrorKind::OperationTimeoutException(_)
        )
    }
}
impl std::error::Error for UpdateDatabaseError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateDatabaseErrorKind::ConcurrentModificationException(_inner) => Some(_inner),
            UpdateDatabaseErrorKind::EntityNotFoundException(_inner) => Some(_inner),
            UpdateDatabaseErrorKind::GlueEncryptionException(_inner) => Some(_inner),
            UpdateDatabaseErrorKind::InternalServiceException(_inner) => Some(_inner),
            UpdateDatabaseErrorKind::InvalidInputException(_inner) => Some(_inner),
            UpdateDatabaseErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            UpdateDatabaseErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateDevEndpointError {
    pub kind: UpdateDevEndpointErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateDevEndpointErrorKind {
    EntityNotFoundException(crate::error::EntityNotFoundException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateDevEndpointError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateDevEndpointErrorKind::EntityNotFoundException(_inner) => _inner.fmt(f),
            UpdateDevEndpointErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            UpdateDevEndpointErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            UpdateDevEndpointErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            UpdateDevEndpointErrorKind::ValidationException(_inner) => _inner.fmt(f),
            UpdateDevEndpointErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateDevEndpointError {
    fn code(&self) -> Option<&str> {
        UpdateDevEndpointError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateDevEndpointError {
    pub fn new(kind: UpdateDevEndpointErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateDevEndpointErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateDevEndpointErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDevEndpointErrorKind::EntityNotFoundException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDevEndpointErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDevEndpointErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDevEndpointErrorKind::OperationTimeoutException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDevEndpointErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for UpdateDevEndpointError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateDevEndpointErrorKind::EntityNotFoundException(_inner) => Some(_inner),
            UpdateDevEndpointErrorKind::InternalServiceException(_inner) => Some(_inner),
            UpdateDevEndpointErrorKind::InvalidInputException(_inner) => Some(_inner),
            UpdateDevEndpointErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            UpdateDevEndpointErrorKind::ValidationException(_inner) => Some(_inner),
            UpdateDevEndpointErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateJobError {
    pub kind: UpdateJobErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateJobErrorKind {
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    EntityNotFoundException(crate::error::EntityNotFoundException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateJobError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateJobErrorKind::ConcurrentModificationException(_inner) => _inner.fmt(f),
            UpdateJobErrorKind::EntityNotFoundException(_inner) => _inner.fmt(f),
            UpdateJobErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            UpdateJobErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            UpdateJobErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            UpdateJobErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateJobError {
    fn code(&self) -> Option<&str> {
        UpdateJobError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateJobError {
    pub fn new(kind: UpdateJobErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateJobErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateJobErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateJobErrorKind::ConcurrentModificationException(_)
        )
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(&self.kind, UpdateJobErrorKind::EntityNotFoundException(_))
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(&self.kind, UpdateJobErrorKind::InternalServiceException(_))
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(&self.kind, UpdateJobErrorKind::InvalidInputException(_))
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(&self.kind, UpdateJobErrorKind::OperationTimeoutException(_))
    }
}
impl std::error::Error for UpdateJobError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateJobErrorKind::ConcurrentModificationException(_inner) => Some(_inner),
            UpdateJobErrorKind::EntityNotFoundException(_inner) => Some(_inner),
            UpdateJobErrorKind::InternalServiceException(_inner) => Some(_inner),
            UpdateJobErrorKind::InvalidInputException(_inner) => Some(_inner),
            UpdateJobErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            UpdateJobErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateMLTransformError {
    pub kind: UpdateMLTransformErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateMLTransformErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    EntityNotFoundException(crate::error::EntityNotFoundException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateMLTransformError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateMLTransformErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            UpdateMLTransformErrorKind::EntityNotFoundException(_inner) => _inner.fmt(f),
            UpdateMLTransformErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            UpdateMLTransformErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            UpdateMLTransformErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            UpdateMLTransformErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateMLTransformError {
    fn code(&self) -> Option<&str> {
        UpdateMLTransformError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateMLTransformError {
    pub fn new(kind: UpdateMLTransformErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateMLTransformErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateMLTransformErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateMLTransformErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateMLTransformErrorKind::EntityNotFoundException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateMLTransformErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateMLTransformErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateMLTransformErrorKind::OperationTimeoutException(_)
        )
    }
}
impl std::error::Error for UpdateMLTransformError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateMLTransformErrorKind::AccessDeniedException(_inner) => Some(_inner),
            UpdateMLTransformErrorKind::EntityNotFoundException(_inner) => Some(_inner),
            UpdateMLTransformErrorKind::InternalServiceException(_inner) => Some(_inner),
            UpdateMLTransformErrorKind::InvalidInputException(_inner) => Some(_inner),
            UpdateMLTransformErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            UpdateMLTransformErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdatePartitionError {
    pub kind: UpdatePartitionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdatePartitionErrorKind {
    EntityNotFoundException(crate::error::EntityNotFoundException),
    GlueEncryptionException(crate::error::GlueEncryptionException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdatePartitionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdatePartitionErrorKind::EntityNotFoundException(_inner) => _inner.fmt(f),
            UpdatePartitionErrorKind::GlueEncryptionException(_inner) => _inner.fmt(f),
            UpdatePartitionErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            UpdatePartitionErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            UpdatePartitionErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            UpdatePartitionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdatePartitionError {
    fn code(&self) -> Option<&str> {
        UpdatePartitionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdatePartitionError {
    pub fn new(kind: UpdatePartitionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdatePartitionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdatePartitionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePartitionErrorKind::EntityNotFoundException(_)
        )
    }
    pub fn is_glue_encryption_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePartitionErrorKind::GlueEncryptionException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePartitionErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePartitionErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePartitionErrorKind::OperationTimeoutException(_)
        )
    }
}
impl std::error::Error for UpdatePartitionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdatePartitionErrorKind::EntityNotFoundException(_inner) => Some(_inner),
            UpdatePartitionErrorKind::GlueEncryptionException(_inner) => Some(_inner),
            UpdatePartitionErrorKind::InternalServiceException(_inner) => Some(_inner),
            UpdatePartitionErrorKind::InvalidInputException(_inner) => Some(_inner),
            UpdatePartitionErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            UpdatePartitionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateRegistryError {
    pub kind: UpdateRegistryErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateRegistryErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    EntityNotFoundException(crate::error::EntityNotFoundException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateRegistryError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateRegistryErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            UpdateRegistryErrorKind::ConcurrentModificationException(_inner) => _inner.fmt(f),
            UpdateRegistryErrorKind::EntityNotFoundException(_inner) => _inner.fmt(f),
            UpdateRegistryErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            UpdateRegistryErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            UpdateRegistryErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateRegistryError {
    fn code(&self) -> Option<&str> {
        UpdateRegistryError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateRegistryError {
    pub fn new(kind: UpdateRegistryErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateRegistryErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateRegistryErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRegistryErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRegistryErrorKind::ConcurrentModificationException(_)
        )
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRegistryErrorKind::EntityNotFoundException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRegistryErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRegistryErrorKind::InvalidInputException(_)
        )
    }
}
impl std::error::Error for UpdateRegistryError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateRegistryErrorKind::AccessDeniedException(_inner) => Some(_inner),
            UpdateRegistryErrorKind::ConcurrentModificationException(_inner) => Some(_inner),
            UpdateRegistryErrorKind::EntityNotFoundException(_inner) => Some(_inner),
            UpdateRegistryErrorKind::InternalServiceException(_inner) => Some(_inner),
            UpdateRegistryErrorKind::InvalidInputException(_inner) => Some(_inner),
            UpdateRegistryErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateSchemaError {
    pub kind: UpdateSchemaErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateSchemaErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    EntityNotFoundException(crate::error::EntityNotFoundException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateSchemaError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateSchemaErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            UpdateSchemaErrorKind::ConcurrentModificationException(_inner) => _inner.fmt(f),
            UpdateSchemaErrorKind::EntityNotFoundException(_inner) => _inner.fmt(f),
            UpdateSchemaErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            UpdateSchemaErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            UpdateSchemaErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateSchemaError {
    fn code(&self) -> Option<&str> {
        UpdateSchemaError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateSchemaError {
    pub fn new(kind: UpdateSchemaErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateSchemaErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateSchemaErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, UpdateSchemaErrorKind::AccessDeniedException(_))
    }
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateSchemaErrorKind::ConcurrentModificationException(_)
        )
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateSchemaErrorKind::EntityNotFoundException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateSchemaErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(&self.kind, UpdateSchemaErrorKind::InvalidInputException(_))
    }
}
impl std::error::Error for UpdateSchemaError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateSchemaErrorKind::AccessDeniedException(_inner) => Some(_inner),
            UpdateSchemaErrorKind::ConcurrentModificationException(_inner) => Some(_inner),
            UpdateSchemaErrorKind::EntityNotFoundException(_inner) => Some(_inner),
            UpdateSchemaErrorKind::InternalServiceException(_inner) => Some(_inner),
            UpdateSchemaErrorKind::InvalidInputException(_inner) => Some(_inner),
            UpdateSchemaErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateTableError {
    pub kind: UpdateTableErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateTableErrorKind {
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    EntityNotFoundException(crate::error::EntityNotFoundException),
    GlueEncryptionException(crate::error::GlueEncryptionException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    ResourceNumberLimitExceededException(crate::error::ResourceNumberLimitExceededException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateTableError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateTableErrorKind::ConcurrentModificationException(_inner) => _inner.fmt(f),
            UpdateTableErrorKind::EntityNotFoundException(_inner) => _inner.fmt(f),
            UpdateTableErrorKind::GlueEncryptionException(_inner) => _inner.fmt(f),
            UpdateTableErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            UpdateTableErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            UpdateTableErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            UpdateTableErrorKind::ResourceNumberLimitExceededException(_inner) => _inner.fmt(f),
            UpdateTableErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateTableError {
    fn code(&self) -> Option<&str> {
        UpdateTableError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateTableError {
    pub fn new(kind: UpdateTableErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateTableErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateTableErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateTableErrorKind::ConcurrentModificationException(_)
        )
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(&self.kind, UpdateTableErrorKind::EntityNotFoundException(_))
    }
    pub fn is_glue_encryption_exception(&self) -> bool {
        matches!(&self.kind, UpdateTableErrorKind::GlueEncryptionException(_))
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateTableErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(&self.kind, UpdateTableErrorKind::InvalidInputException(_))
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateTableErrorKind::OperationTimeoutException(_)
        )
    }
    pub fn is_resource_number_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateTableErrorKind::ResourceNumberLimitExceededException(_)
        )
    }
}
impl std::error::Error for UpdateTableError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateTableErrorKind::ConcurrentModificationException(_inner) => Some(_inner),
            UpdateTableErrorKind::EntityNotFoundException(_inner) => Some(_inner),
            UpdateTableErrorKind::GlueEncryptionException(_inner) => Some(_inner),
            UpdateTableErrorKind::InternalServiceException(_inner) => Some(_inner),
            UpdateTableErrorKind::InvalidInputException(_inner) => Some(_inner),
            UpdateTableErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            UpdateTableErrorKind::ResourceNumberLimitExceededException(_inner) => Some(_inner),
            UpdateTableErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateTriggerError {
    pub kind: UpdateTriggerErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateTriggerErrorKind {
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    EntityNotFoundException(crate::error::EntityNotFoundException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateTriggerError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateTriggerErrorKind::ConcurrentModificationException(_inner) => _inner.fmt(f),
            UpdateTriggerErrorKind::EntityNotFoundException(_inner) => _inner.fmt(f),
            UpdateTriggerErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            UpdateTriggerErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            UpdateTriggerErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            UpdateTriggerErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateTriggerError {
    fn code(&self) -> Option<&str> {
        UpdateTriggerError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateTriggerError {
    pub fn new(kind: UpdateTriggerErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateTriggerErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateTriggerErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateTriggerErrorKind::ConcurrentModificationException(_)
        )
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateTriggerErrorKind::EntityNotFoundException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateTriggerErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(&self.kind, UpdateTriggerErrorKind::InvalidInputException(_))
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateTriggerErrorKind::OperationTimeoutException(_)
        )
    }
}
impl std::error::Error for UpdateTriggerError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateTriggerErrorKind::ConcurrentModificationException(_inner) => Some(_inner),
            UpdateTriggerErrorKind::EntityNotFoundException(_inner) => Some(_inner),
            UpdateTriggerErrorKind::InternalServiceException(_inner) => Some(_inner),
            UpdateTriggerErrorKind::InvalidInputException(_inner) => Some(_inner),
            UpdateTriggerErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            UpdateTriggerErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateUserDefinedFunctionError {
    pub kind: UpdateUserDefinedFunctionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateUserDefinedFunctionErrorKind {
    EntityNotFoundException(crate::error::EntityNotFoundException),
    GlueEncryptionException(crate::error::GlueEncryptionException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateUserDefinedFunctionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateUserDefinedFunctionErrorKind::EntityNotFoundException(_inner) => _inner.fmt(f),
            UpdateUserDefinedFunctionErrorKind::GlueEncryptionException(_inner) => _inner.fmt(f),
            UpdateUserDefinedFunctionErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            UpdateUserDefinedFunctionErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            UpdateUserDefinedFunctionErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            UpdateUserDefinedFunctionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateUserDefinedFunctionError {
    fn code(&self) -> Option<&str> {
        UpdateUserDefinedFunctionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateUserDefinedFunctionError {
    pub fn new(kind: UpdateUserDefinedFunctionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateUserDefinedFunctionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateUserDefinedFunctionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateUserDefinedFunctionErrorKind::EntityNotFoundException(_)
        )
    }
    pub fn is_glue_encryption_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateUserDefinedFunctionErrorKind::GlueEncryptionException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateUserDefinedFunctionErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateUserDefinedFunctionErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateUserDefinedFunctionErrorKind::OperationTimeoutException(_)
        )
    }
}
impl std::error::Error for UpdateUserDefinedFunctionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateUserDefinedFunctionErrorKind::EntityNotFoundException(_inner) => Some(_inner),
            UpdateUserDefinedFunctionErrorKind::GlueEncryptionException(_inner) => Some(_inner),
            UpdateUserDefinedFunctionErrorKind::InternalServiceException(_inner) => Some(_inner),
            UpdateUserDefinedFunctionErrorKind::InvalidInputException(_inner) => Some(_inner),
            UpdateUserDefinedFunctionErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            UpdateUserDefinedFunctionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateWorkflowError {
    pub kind: UpdateWorkflowErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateWorkflowErrorKind {
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    EntityNotFoundException(crate::error::EntityNotFoundException),
    InternalServiceException(crate::error::InternalServiceException),
    InvalidInputException(crate::error::InvalidInputException),
    OperationTimeoutException(crate::error::OperationTimeoutException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateWorkflowError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateWorkflowErrorKind::ConcurrentModificationException(_inner) => _inner.fmt(f),
            UpdateWorkflowErrorKind::EntityNotFoundException(_inner) => _inner.fmt(f),
            UpdateWorkflowErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            UpdateWorkflowErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            UpdateWorkflowErrorKind::OperationTimeoutException(_inner) => _inner.fmt(f),
            UpdateWorkflowErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateWorkflowError {
    fn code(&self) -> Option<&str> {
        UpdateWorkflowError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateWorkflowError {
    pub fn new(kind: UpdateWorkflowErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateWorkflowErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateWorkflowErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateWorkflowErrorKind::ConcurrentModificationException(_)
        )
    }
    pub fn is_entity_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateWorkflowErrorKind::EntityNotFoundException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateWorkflowErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateWorkflowErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_operation_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateWorkflowErrorKind::OperationTimeoutException(_)
        )
    }
}
impl std::error::Error for UpdateWorkflowError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateWorkflowErrorKind::ConcurrentModificationException(_inner) => Some(_inner),
            UpdateWorkflowErrorKind::EntityNotFoundException(_inner) => Some(_inner),
            UpdateWorkflowErrorKind::InternalServiceException(_inner) => Some(_inner),
            UpdateWorkflowErrorKind::InvalidInputException(_inner) => Some(_inner),
            UpdateWorkflowErrorKind::OperationTimeoutException(_inner) => Some(_inner),
            UpdateWorkflowErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// <p>The operation timed out.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct OperationTimeoutException {
    /// <p>A message describing the problem.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for OperationTimeoutException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("OperationTimeoutException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl OperationTimeoutException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for OperationTimeoutException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "OperationTimeoutException")?;
        if let Some(inner_1) = &self.message {
            write!(f, ": {}", inner_1)?;
        }
        Ok(())
    }
}
impl std::error::Error for OperationTimeoutException {}
/// See [`OperationTimeoutException`](crate::error::OperationTimeoutException)
pub mod operation_timeout_exception {
    /// A builder for [`OperationTimeoutException`](crate::error::OperationTimeoutException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A message describing the problem.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`OperationTimeoutException`](crate::error::OperationTimeoutException)
        pub fn build(self) -> crate::error::OperationTimeoutException {
            crate::error::OperationTimeoutException {
                message: self.message,
            }
        }
    }
}
impl OperationTimeoutException {
    /// Creates a new builder-style object to manufacture [`OperationTimeoutException`](crate::error::OperationTimeoutException)
    pub fn builder() -> crate::error::operation_timeout_exception::Builder {
        crate::error::operation_timeout_exception::Builder::default()
    }
}

/// <p>The input provided was not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidInputException {
    /// <p>A message describing the problem.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidInputException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidInputException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidInputException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidInputException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidInputException")?;
        if let Some(inner_2) = &self.message {
            write!(f, ": {}", inner_2)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidInputException {}
/// See [`InvalidInputException`](crate::error::InvalidInputException)
pub mod invalid_input_exception {
    /// A builder for [`InvalidInputException`](crate::error::InvalidInputException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A message describing the problem.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidInputException`](crate::error::InvalidInputException)
        pub fn build(self) -> crate::error::InvalidInputException {
            crate::error::InvalidInputException {
                message: self.message,
            }
        }
    }
}
impl InvalidInputException {
    /// Creates a new builder-style object to manufacture [`InvalidInputException`](crate::error::InvalidInputException)
    pub fn builder() -> crate::error::invalid_input_exception::Builder {
        crate::error::invalid_input_exception::Builder::default()
    }
}

/// <p>An internal service error occurred.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InternalServiceException {
    /// <p>A message describing the problem.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InternalServiceException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InternalServiceException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InternalServiceException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InternalServiceException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InternalServiceException")?;
        if let Some(inner_3) = &self.message {
            write!(f, ": {}", inner_3)?;
        }
        Ok(())
    }
}
impl std::error::Error for InternalServiceException {}
/// See [`InternalServiceException`](crate::error::InternalServiceException)
pub mod internal_service_exception {
    /// A builder for [`InternalServiceException`](crate::error::InternalServiceException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A message describing the problem.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InternalServiceException`](crate::error::InternalServiceException)
        pub fn build(self) -> crate::error::InternalServiceException {
            crate::error::InternalServiceException {
                message: self.message,
            }
        }
    }
}
impl InternalServiceException {
    /// Creates a new builder-style object to manufacture [`InternalServiceException`](crate::error::InternalServiceException)
    pub fn builder() -> crate::error::internal_service_exception::Builder {
        crate::error::internal_service_exception::Builder::default()
    }
}

/// <p>A specified entity does not exist</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EntityNotFoundException {
    /// <p>A message describing the problem.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for EntityNotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EntityNotFoundException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl EntityNotFoundException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for EntityNotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "EntityNotFoundException")?;
        if let Some(inner_4) = &self.message {
            write!(f, ": {}", inner_4)?;
        }
        Ok(())
    }
}
impl std::error::Error for EntityNotFoundException {}
/// See [`EntityNotFoundException`](crate::error::EntityNotFoundException)
pub mod entity_not_found_exception {
    /// A builder for [`EntityNotFoundException`](crate::error::EntityNotFoundException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A message describing the problem.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`EntityNotFoundException`](crate::error::EntityNotFoundException)
        pub fn build(self) -> crate::error::EntityNotFoundException {
            crate::error::EntityNotFoundException {
                message: self.message,
            }
        }
    }
}
impl EntityNotFoundException {
    /// Creates a new builder-style object to manufacture [`EntityNotFoundException`](crate::error::EntityNotFoundException)
    pub fn builder() -> crate::error::entity_not_found_exception::Builder {
        crate::error::entity_not_found_exception::Builder::default()
    }
}

/// <p>Two processes are trying to modify a resource simultaneously.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ConcurrentModificationException {
    /// <p>A message describing the problem.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ConcurrentModificationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ConcurrentModificationException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ConcurrentModificationException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ConcurrentModificationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ConcurrentModificationException")?;
        if let Some(inner_5) = &self.message {
            write!(f, ": {}", inner_5)?;
        }
        Ok(())
    }
}
impl std::error::Error for ConcurrentModificationException {}
/// See [`ConcurrentModificationException`](crate::error::ConcurrentModificationException)
pub mod concurrent_modification_exception {
    /// A builder for [`ConcurrentModificationException`](crate::error::ConcurrentModificationException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A message describing the problem.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ConcurrentModificationException`](crate::error::ConcurrentModificationException)
        pub fn build(self) -> crate::error::ConcurrentModificationException {
            crate::error::ConcurrentModificationException {
                message: self.message,
            }
        }
    }
}
impl ConcurrentModificationException {
    /// Creates a new builder-style object to manufacture [`ConcurrentModificationException`](crate::error::ConcurrentModificationException)
    pub fn builder() -> crate::error::concurrent_modification_exception::Builder {
        crate::error::concurrent_modification_exception::Builder::default()
    }
}

/// <p>An encryption operation failed.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GlueEncryptionException {
    /// <p>A message describing the problem.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GlueEncryptionException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GlueEncryptionException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl GlueEncryptionException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for GlueEncryptionException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "GlueEncryptionException")?;
        if let Some(inner_6) = &self.message {
            write!(f, ": {}", inner_6)?;
        }
        Ok(())
    }
}
impl std::error::Error for GlueEncryptionException {}
/// See [`GlueEncryptionException`](crate::error::GlueEncryptionException)
pub mod glue_encryption_exception {
    /// A builder for [`GlueEncryptionException`](crate::error::GlueEncryptionException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A message describing the problem.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`GlueEncryptionException`](crate::error::GlueEncryptionException)
        pub fn build(self) -> crate::error::GlueEncryptionException {
            crate::error::GlueEncryptionException {
                message: self.message,
            }
        }
    }
}
impl GlueEncryptionException {
    /// Creates a new builder-style object to manufacture [`GlueEncryptionException`](crate::error::GlueEncryptionException)
    pub fn builder() -> crate::error::glue_encryption_exception::Builder {
        crate::error::glue_encryption_exception::Builder::default()
    }
}

/// <p>A resource numerical limit was exceeded.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceNumberLimitExceededException {
    /// <p>A message describing the problem.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ResourceNumberLimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceNumberLimitExceededException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ResourceNumberLimitExceededException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ResourceNumberLimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResourceNumberLimitExceededException")?;
        if let Some(inner_7) = &self.message {
            write!(f, ": {}", inner_7)?;
        }
        Ok(())
    }
}
impl std::error::Error for ResourceNumberLimitExceededException {}
/// See [`ResourceNumberLimitExceededException`](crate::error::ResourceNumberLimitExceededException)
pub mod resource_number_limit_exceeded_exception {
    /// A builder for [`ResourceNumberLimitExceededException`](crate::error::ResourceNumberLimitExceededException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A message describing the problem.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceNumberLimitExceededException`](crate::error::ResourceNumberLimitExceededException)
        pub fn build(self) -> crate::error::ResourceNumberLimitExceededException {
            crate::error::ResourceNumberLimitExceededException {
                message: self.message,
            }
        }
    }
}
impl ResourceNumberLimitExceededException {
    /// Creates a new builder-style object to manufacture [`ResourceNumberLimitExceededException`](crate::error::ResourceNumberLimitExceededException)
    pub fn builder() -> crate::error::resource_number_limit_exceeded_exception::Builder {
        crate::error::resource_number_limit_exceeded_exception::Builder::default()
    }
}

/// <p>Access to a resource was denied.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AccessDeniedException {
    /// <p>A message describing the problem.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AccessDeniedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AccessDeniedException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl AccessDeniedException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for AccessDeniedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "AccessDeniedException")?;
        if let Some(inner_8) = &self.message {
            write!(f, ": {}", inner_8)?;
        }
        Ok(())
    }
}
impl std::error::Error for AccessDeniedException {}
/// See [`AccessDeniedException`](crate::error::AccessDeniedException)
pub mod access_denied_exception {
    /// A builder for [`AccessDeniedException`](crate::error::AccessDeniedException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A message describing the problem.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`AccessDeniedException`](crate::error::AccessDeniedException)
        pub fn build(self) -> crate::error::AccessDeniedException {
            crate::error::AccessDeniedException {
                message: self.message,
            }
        }
    }
}
impl AccessDeniedException {
    /// Creates a new builder-style object to manufacture [`AccessDeniedException`](crate::error::AccessDeniedException)
    pub fn builder() -> crate::error::access_denied_exception::Builder {
        crate::error::access_denied_exception::Builder::default()
    }
}

/// <p>A value could not be validated.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ValidationException {
    /// <p>A message describing the problem.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ValidationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ValidationException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ValidationException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ValidationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ValidationException")?;
        if let Some(inner_9) = &self.message {
            write!(f, ": {}", inner_9)?;
        }
        Ok(())
    }
}
impl std::error::Error for ValidationException {}
/// See [`ValidationException`](crate::error::ValidationException)
pub mod validation_exception {
    /// A builder for [`ValidationException`](crate::error::ValidationException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A message describing the problem.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ValidationException`](crate::error::ValidationException)
        pub fn build(self) -> crate::error::ValidationException {
            crate::error::ValidationException {
                message: self.message,
            }
        }
    }
}
impl ValidationException {
    /// Creates a new builder-style object to manufacture [`ValidationException`](crate::error::ValidationException)
    pub fn builder() -> crate::error::validation_exception::Builder {
        crate::error::validation_exception::Builder::default()
    }
}

/// <p>There was a version conflict.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct VersionMismatchException {
    /// <p>A message describing the problem.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for VersionMismatchException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("VersionMismatchException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl VersionMismatchException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for VersionMismatchException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "VersionMismatchException")?;
        if let Some(inner_10) = &self.message {
            write!(f, ": {}", inner_10)?;
        }
        Ok(())
    }
}
impl std::error::Error for VersionMismatchException {}
/// See [`VersionMismatchException`](crate::error::VersionMismatchException)
pub mod version_mismatch_exception {
    /// A builder for [`VersionMismatchException`](crate::error::VersionMismatchException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A message describing the problem.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`VersionMismatchException`](crate::error::VersionMismatchException)
        pub fn build(self) -> crate::error::VersionMismatchException {
            crate::error::VersionMismatchException {
                message: self.message,
            }
        }
    }
}
impl VersionMismatchException {
    /// Creates a new builder-style object to manufacture [`VersionMismatchException`](crate::error::VersionMismatchException)
    pub fn builder() -> crate::error::version_mismatch_exception::Builder {
        crate::error::version_mismatch_exception::Builder::default()
    }
}

/// <p>The specified scheduler is transitioning.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SchedulerTransitioningException {
    /// <p>A message describing the problem.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for SchedulerTransitioningException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SchedulerTransitioningException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl SchedulerTransitioningException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for SchedulerTransitioningException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SchedulerTransitioningException")?;
        if let Some(inner_11) = &self.message {
            write!(f, ": {}", inner_11)?;
        }
        Ok(())
    }
}
impl std::error::Error for SchedulerTransitioningException {}
/// See [`SchedulerTransitioningException`](crate::error::SchedulerTransitioningException)
pub mod scheduler_transitioning_exception {
    /// A builder for [`SchedulerTransitioningException`](crate::error::SchedulerTransitioningException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A message describing the problem.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`SchedulerTransitioningException`](crate::error::SchedulerTransitioningException)
        pub fn build(self) -> crate::error::SchedulerTransitioningException {
            crate::error::SchedulerTransitioningException {
                message: self.message,
            }
        }
    }
}
impl SchedulerTransitioningException {
    /// Creates a new builder-style object to manufacture [`SchedulerTransitioningException`](crate::error::SchedulerTransitioningException)
    pub fn builder() -> crate::error::scheduler_transitioning_exception::Builder {
        crate::error::scheduler_transitioning_exception::Builder::default()
    }
}

/// <p>The operation cannot be performed because the crawler is already running.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CrawlerRunningException {
    /// <p>A message describing the problem.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CrawlerRunningException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CrawlerRunningException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl CrawlerRunningException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CrawlerRunningException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CrawlerRunningException")?;
        if let Some(inner_12) = &self.message {
            write!(f, ": {}", inner_12)?;
        }
        Ok(())
    }
}
impl std::error::Error for CrawlerRunningException {}
/// See [`CrawlerRunningException`](crate::error::CrawlerRunningException)
pub mod crawler_running_exception {
    /// A builder for [`CrawlerRunningException`](crate::error::CrawlerRunningException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A message describing the problem.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`CrawlerRunningException`](crate::error::CrawlerRunningException)
        pub fn build(self) -> crate::error::CrawlerRunningException {
            crate::error::CrawlerRunningException {
                message: self.message,
            }
        }
    }
}
impl CrawlerRunningException {
    /// Creates a new builder-style object to manufacture [`CrawlerRunningException`](crate::error::CrawlerRunningException)
    pub fn builder() -> crate::error::crawler_running_exception::Builder {
        crate::error::crawler_running_exception::Builder::default()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct IllegalBlueprintStateException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for IllegalBlueprintStateException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("IllegalBlueprintStateException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl IllegalBlueprintStateException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for IllegalBlueprintStateException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "IllegalBlueprintStateException")?;
        if let Some(inner_13) = &self.message {
            write!(f, ": {}", inner_13)?;
        }
        Ok(())
    }
}
impl std::error::Error for IllegalBlueprintStateException {}
/// See [`IllegalBlueprintStateException`](crate::error::IllegalBlueprintStateException)
pub mod illegal_blueprint_state_exception {
    /// A builder for [`IllegalBlueprintStateException`](crate::error::IllegalBlueprintStateException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`IllegalBlueprintStateException`](crate::error::IllegalBlueprintStateException)
        pub fn build(self) -> crate::error::IllegalBlueprintStateException {
            crate::error::IllegalBlueprintStateException {
                message: self.message,
            }
        }
    }
}
impl IllegalBlueprintStateException {
    /// Creates a new builder-style object to manufacture [`IllegalBlueprintStateException`](crate::error::IllegalBlueprintStateException)
    pub fn builder() -> crate::error::illegal_blueprint_state_exception::Builder {
        crate::error::illegal_blueprint_state_exception::Builder::default()
    }
}

/// <p>The workflow is in an invalid state to perform a requested operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct IllegalWorkflowStateException {
    /// <p>A message describing the problem.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for IllegalWorkflowStateException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("IllegalWorkflowStateException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl IllegalWorkflowStateException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for IllegalWorkflowStateException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "IllegalWorkflowStateException")?;
        if let Some(inner_14) = &self.message {
            write!(f, ": {}", inner_14)?;
        }
        Ok(())
    }
}
impl std::error::Error for IllegalWorkflowStateException {}
/// See [`IllegalWorkflowStateException`](crate::error::IllegalWorkflowStateException)
pub mod illegal_workflow_state_exception {
    /// A builder for [`IllegalWorkflowStateException`](crate::error::IllegalWorkflowStateException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A message describing the problem.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`IllegalWorkflowStateException`](crate::error::IllegalWorkflowStateException)
        pub fn build(self) -> crate::error::IllegalWorkflowStateException {
            crate::error::IllegalWorkflowStateException {
                message: self.message,
            }
        }
    }
}
impl IllegalWorkflowStateException {
    /// Creates a new builder-style object to manufacture [`IllegalWorkflowStateException`](crate::error::IllegalWorkflowStateException)
    pub fn builder() -> crate::error::illegal_workflow_state_exception::Builder {
        crate::error::illegal_workflow_state_exception::Builder::default()
    }
}

/// <p>The specified scheduler is not running.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SchedulerNotRunningException {
    /// <p>A message describing the problem.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for SchedulerNotRunningException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SchedulerNotRunningException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl SchedulerNotRunningException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for SchedulerNotRunningException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SchedulerNotRunningException")?;
        if let Some(inner_15) = &self.message {
            write!(f, ": {}", inner_15)?;
        }
        Ok(())
    }
}
impl std::error::Error for SchedulerNotRunningException {}
/// See [`SchedulerNotRunningException`](crate::error::SchedulerNotRunningException)
pub mod scheduler_not_running_exception {
    /// A builder for [`SchedulerNotRunningException`](crate::error::SchedulerNotRunningException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A message describing the problem.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`SchedulerNotRunningException`](crate::error::SchedulerNotRunningException)
        pub fn build(self) -> crate::error::SchedulerNotRunningException {
            crate::error::SchedulerNotRunningException {
                message: self.message,
            }
        }
    }
}
impl SchedulerNotRunningException {
    /// Creates a new builder-style object to manufacture [`SchedulerNotRunningException`](crate::error::SchedulerNotRunningException)
    pub fn builder() -> crate::error::scheduler_not_running_exception::Builder {
        crate::error::scheduler_not_running_exception::Builder::default()
    }
}

/// <p>The specified crawler is stopping.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CrawlerStoppingException {
    /// <p>A message describing the problem.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CrawlerStoppingException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CrawlerStoppingException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl CrawlerStoppingException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CrawlerStoppingException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CrawlerStoppingException")?;
        if let Some(inner_16) = &self.message {
            write!(f, ": {}", inner_16)?;
        }
        Ok(())
    }
}
impl std::error::Error for CrawlerStoppingException {}
/// See [`CrawlerStoppingException`](crate::error::CrawlerStoppingException)
pub mod crawler_stopping_exception {
    /// A builder for [`CrawlerStoppingException`](crate::error::CrawlerStoppingException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A message describing the problem.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`CrawlerStoppingException`](crate::error::CrawlerStoppingException)
        pub fn build(self) -> crate::error::CrawlerStoppingException {
            crate::error::CrawlerStoppingException {
                message: self.message,
            }
        }
    }
}
impl CrawlerStoppingException {
    /// Creates a new builder-style object to manufacture [`CrawlerStoppingException`](crate::error::CrawlerStoppingException)
    pub fn builder() -> crate::error::crawler_stopping_exception::Builder {
        crate::error::crawler_stopping_exception::Builder::default()
    }
}

/// <p>The specified crawler is not running.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CrawlerNotRunningException {
    /// <p>A message describing the problem.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CrawlerNotRunningException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CrawlerNotRunningException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl CrawlerNotRunningException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CrawlerNotRunningException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CrawlerNotRunningException")?;
        if let Some(inner_17) = &self.message {
            write!(f, ": {}", inner_17)?;
        }
        Ok(())
    }
}
impl std::error::Error for CrawlerNotRunningException {}
/// See [`CrawlerNotRunningException`](crate::error::CrawlerNotRunningException)
pub mod crawler_not_running_exception {
    /// A builder for [`CrawlerNotRunningException`](crate::error::CrawlerNotRunningException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A message describing the problem.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`CrawlerNotRunningException`](crate::error::CrawlerNotRunningException)
        pub fn build(self) -> crate::error::CrawlerNotRunningException {
            crate::error::CrawlerNotRunningException {
                message: self.message,
            }
        }
    }
}
impl CrawlerNotRunningException {
    /// Creates a new builder-style object to manufacture [`CrawlerNotRunningException`](crate::error::CrawlerNotRunningException)
    pub fn builder() -> crate::error::crawler_not_running_exception::Builder {
        crate::error::crawler_not_running_exception::Builder::default()
    }
}

/// <p>Too many jobs are being run concurrently.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ConcurrentRunsExceededException {
    /// <p>A message describing the problem.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ConcurrentRunsExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ConcurrentRunsExceededException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ConcurrentRunsExceededException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ConcurrentRunsExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ConcurrentRunsExceededException")?;
        if let Some(inner_18) = &self.message {
            write!(f, ": {}", inner_18)?;
        }
        Ok(())
    }
}
impl std::error::Error for ConcurrentRunsExceededException {}
/// See [`ConcurrentRunsExceededException`](crate::error::ConcurrentRunsExceededException)
pub mod concurrent_runs_exceeded_exception {
    /// A builder for [`ConcurrentRunsExceededException`](crate::error::ConcurrentRunsExceededException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A message describing the problem.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ConcurrentRunsExceededException`](crate::error::ConcurrentRunsExceededException)
        pub fn build(self) -> crate::error::ConcurrentRunsExceededException {
            crate::error::ConcurrentRunsExceededException {
                message: self.message,
            }
        }
    }
}
impl ConcurrentRunsExceededException {
    /// Creates a new builder-style object to manufacture [`ConcurrentRunsExceededException`](crate::error::ConcurrentRunsExceededException)
    pub fn builder() -> crate::error::concurrent_runs_exceeded_exception::Builder {
        crate::error::concurrent_runs_exceeded_exception::Builder::default()
    }
}

/// <p>The machine learning transform is not ready to run.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MlTransformNotReadyException {
    /// <p>A message describing the problem.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for MlTransformNotReadyException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MlTransformNotReadyException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl MlTransformNotReadyException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for MlTransformNotReadyException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "MlTransformNotReadyException [MLTransformNotReadyException]"
        )?;
        if let Some(inner_19) = &self.message {
            write!(f, ": {}", inner_19)?;
        }
        Ok(())
    }
}
impl std::error::Error for MlTransformNotReadyException {}
/// See [`MlTransformNotReadyException`](crate::error::MlTransformNotReadyException)
pub mod ml_transform_not_ready_exception {
    /// A builder for [`MlTransformNotReadyException`](crate::error::MlTransformNotReadyException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A message describing the problem.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`MlTransformNotReadyException`](crate::error::MlTransformNotReadyException)
        pub fn build(self) -> crate::error::MlTransformNotReadyException {
            crate::error::MlTransformNotReadyException {
                message: self.message,
            }
        }
    }
}
impl MlTransformNotReadyException {
    /// Creates a new builder-style object to manufacture [`MlTransformNotReadyException`](crate::error::MlTransformNotReadyException)
    pub fn builder() -> crate::error::ml_transform_not_ready_exception::Builder {
        crate::error::ml_transform_not_ready_exception::Builder::default()
    }
}

/// <p>The specified scheduler is already running.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SchedulerRunningException {
    /// <p>A message describing the problem.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for SchedulerRunningException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SchedulerRunningException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl SchedulerRunningException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for SchedulerRunningException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SchedulerRunningException")?;
        if let Some(inner_20) = &self.message {
            write!(f, ": {}", inner_20)?;
        }
        Ok(())
    }
}
impl std::error::Error for SchedulerRunningException {}
/// See [`SchedulerRunningException`](crate::error::SchedulerRunningException)
pub mod scheduler_running_exception {
    /// A builder for [`SchedulerRunningException`](crate::error::SchedulerRunningException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A message describing the problem.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`SchedulerRunningException`](crate::error::SchedulerRunningException)
        pub fn build(self) -> crate::error::SchedulerRunningException {
            crate::error::SchedulerRunningException {
                message: self.message,
            }
        }
    }
}
impl SchedulerRunningException {
    /// Creates a new builder-style object to manufacture [`SchedulerRunningException`](crate::error::SchedulerRunningException)
    pub fn builder() -> crate::error::scheduler_running_exception::Builder {
        crate::error::scheduler_running_exception::Builder::default()
    }
}

/// <p>There is no applicable schedule.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NoScheduleException {
    /// <p>A message describing the problem.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for NoScheduleException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NoScheduleException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl NoScheduleException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for NoScheduleException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "NoScheduleException")?;
        if let Some(inner_21) = &self.message {
            write!(f, ": {}", inner_21)?;
        }
        Ok(())
    }
}
impl std::error::Error for NoScheduleException {}
/// See [`NoScheduleException`](crate::error::NoScheduleException)
pub mod no_schedule_exception {
    /// A builder for [`NoScheduleException`](crate::error::NoScheduleException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A message describing the problem.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`NoScheduleException`](crate::error::NoScheduleException)
        pub fn build(self) -> crate::error::NoScheduleException {
            crate::error::NoScheduleException {
                message: self.message,
            }
        }
    }
}
impl NoScheduleException {
    /// Creates a new builder-style object to manufacture [`NoScheduleException`](crate::error::NoScheduleException)
    pub fn builder() -> crate::error::no_schedule_exception::Builder {
        crate::error::no_schedule_exception::Builder::default()
    }
}

/// <p>A resource to be created or added already exists.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AlreadyExistsException {
    /// <p>A message describing the problem.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AlreadyExistsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AlreadyExistsException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl AlreadyExistsException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for AlreadyExistsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "AlreadyExistsException")?;
        if let Some(inner_22) = &self.message {
            write!(f, ": {}", inner_22)?;
        }
        Ok(())
    }
}
impl std::error::Error for AlreadyExistsException {}
/// See [`AlreadyExistsException`](crate::error::AlreadyExistsException)
pub mod already_exists_exception {
    /// A builder for [`AlreadyExistsException`](crate::error::AlreadyExistsException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A message describing the problem.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`AlreadyExistsException`](crate::error::AlreadyExistsException)
        pub fn build(self) -> crate::error::AlreadyExistsException {
            crate::error::AlreadyExistsException {
                message: self.message,
            }
        }
    }
}
impl AlreadyExistsException {
    /// Creates a new builder-style object to manufacture [`AlreadyExistsException`](crate::error::AlreadyExistsException)
    pub fn builder() -> crate::error::already_exists_exception::Builder {
        crate::error::already_exists_exception::Builder::default()
    }
}

/// <p>A specified condition was not satisfied.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ConditionCheckFailureException {
    /// <p>A message describing the problem.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ConditionCheckFailureException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ConditionCheckFailureException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ConditionCheckFailureException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ConditionCheckFailureException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ConditionCheckFailureException")?;
        if let Some(inner_23) = &self.message {
            write!(f, ": {}", inner_23)?;
        }
        Ok(())
    }
}
impl std::error::Error for ConditionCheckFailureException {}
/// See [`ConditionCheckFailureException`](crate::error::ConditionCheckFailureException)
pub mod condition_check_failure_exception {
    /// A builder for [`ConditionCheckFailureException`](crate::error::ConditionCheckFailureException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A message describing the problem.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ConditionCheckFailureException`](crate::error::ConditionCheckFailureException)
        pub fn build(self) -> crate::error::ConditionCheckFailureException {
            crate::error::ConditionCheckFailureException {
                message: self.message,
            }
        }
    }
}
impl ConditionCheckFailureException {
    /// Creates a new builder-style object to manufacture [`ConditionCheckFailureException`](crate::error::ConditionCheckFailureException)
    pub fn builder() -> crate::error::condition_check_failure_exception::Builder {
        crate::error::condition_check_failure_exception::Builder::default()
    }
}

/// <p>The <code>CreatePartitions</code> API was called on a table that has indexes enabled.  </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ConflictException {
    /// <p>A message describing the problem.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ConflictException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ConflictException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ConflictException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ConflictException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ConflictException")?;
        if let Some(inner_24) = &self.message {
            write!(f, ": {}", inner_24)?;
        }
        Ok(())
    }
}
impl std::error::Error for ConflictException {}
/// See [`ConflictException`](crate::error::ConflictException)
pub mod conflict_exception {
    /// A builder for [`ConflictException`](crate::error::ConflictException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A message describing the problem.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ConflictException`](crate::error::ConflictException)
        pub fn build(self) -> crate::error::ConflictException {
            crate::error::ConflictException {
                message: self.message,
            }
        }
    }
}
impl ConflictException {
    /// Creates a new builder-style object to manufacture [`ConflictException`](crate::error::ConflictException)
    pub fn builder() -> crate::error::conflict_exception::Builder {
        crate::error::conflict_exception::Builder::default()
    }
}

/// <p>The same unique identifier was associated with two different records.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct IdempotentParameterMismatchException {
    /// <p>A message describing the problem.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for IdempotentParameterMismatchException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("IdempotentParameterMismatchException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl IdempotentParameterMismatchException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for IdempotentParameterMismatchException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "IdempotentParameterMismatchException")?;
        if let Some(inner_25) = &self.message {
            write!(f, ": {}", inner_25)?;
        }
        Ok(())
    }
}
impl std::error::Error for IdempotentParameterMismatchException {}
/// See [`IdempotentParameterMismatchException`](crate::error::IdempotentParameterMismatchException)
pub mod idempotent_parameter_mismatch_exception {
    /// A builder for [`IdempotentParameterMismatchException`](crate::error::IdempotentParameterMismatchException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A message describing the problem.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`IdempotentParameterMismatchException`](crate::error::IdempotentParameterMismatchException)
        pub fn build(self) -> crate::error::IdempotentParameterMismatchException {
            crate::error::IdempotentParameterMismatchException {
                message: self.message,
            }
        }
    }
}
impl IdempotentParameterMismatchException {
    /// Creates a new builder-style object to manufacture [`IdempotentParameterMismatchException`](crate::error::IdempotentParameterMismatchException)
    pub fn builder() -> crate::error::idempotent_parameter_mismatch_exception::Builder {
        crate::error::idempotent_parameter_mismatch_exception::Builder::default()
    }
}
