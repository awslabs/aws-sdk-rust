// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>A structure used to create or update a user-defined function.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UserDefinedFunctionInput {
    /// <p>The name of the function.</p>
    #[doc(hidden)]
    pub function_name: std::option::Option<std::string::String>,
    /// <p>The Java class that contains the function code.</p>
    #[doc(hidden)]
    pub class_name: std::option::Option<std::string::String>,
    /// <p>The owner of the function.</p>
    #[doc(hidden)]
    pub owner_name: std::option::Option<std::string::String>,
    /// <p>The owner type.</p>
    #[doc(hidden)]
    pub owner_type: std::option::Option<crate::model::PrincipalType>,
    /// <p>The resource URIs for the function.</p>
    #[doc(hidden)]
    pub resource_uris: std::option::Option<std::vec::Vec<crate::model::ResourceUri>>,
}
impl UserDefinedFunctionInput {
    /// <p>The name of the function.</p>
    pub fn function_name(&self) -> std::option::Option<&str> {
        self.function_name.as_deref()
    }
    /// <p>The Java class that contains the function code.</p>
    pub fn class_name(&self) -> std::option::Option<&str> {
        self.class_name.as_deref()
    }
    /// <p>The owner of the function.</p>
    pub fn owner_name(&self) -> std::option::Option<&str> {
        self.owner_name.as_deref()
    }
    /// <p>The owner type.</p>
    pub fn owner_type(&self) -> std::option::Option<&crate::model::PrincipalType> {
        self.owner_type.as_ref()
    }
    /// <p>The resource URIs for the function.</p>
    pub fn resource_uris(&self) -> std::option::Option<&[crate::model::ResourceUri]> {
        self.resource_uris.as_deref()
    }
}
/// See [`UserDefinedFunctionInput`](crate::model::UserDefinedFunctionInput).
pub mod user_defined_function_input {

    /// A builder for [`UserDefinedFunctionInput`](crate::model::UserDefinedFunctionInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) function_name: std::option::Option<std::string::String>,
        pub(crate) class_name: std::option::Option<std::string::String>,
        pub(crate) owner_name: std::option::Option<std::string::String>,
        pub(crate) owner_type: std::option::Option<crate::model::PrincipalType>,
        pub(crate) resource_uris: std::option::Option<std::vec::Vec<crate::model::ResourceUri>>,
    }
    impl Builder {
        /// <p>The name of the function.</p>
        pub fn function_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.function_name = Some(input.into());
            self
        }
        /// <p>The name of the function.</p>
        pub fn set_function_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.function_name = input;
            self
        }
        /// <p>The Java class that contains the function code.</p>
        pub fn class_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.class_name = Some(input.into());
            self
        }
        /// <p>The Java class that contains the function code.</p>
        pub fn set_class_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.class_name = input;
            self
        }
        /// <p>The owner of the function.</p>
        pub fn owner_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.owner_name = Some(input.into());
            self
        }
        /// <p>The owner of the function.</p>
        pub fn set_owner_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.owner_name = input;
            self
        }
        /// <p>The owner type.</p>
        pub fn owner_type(mut self, input: crate::model::PrincipalType) -> Self {
            self.owner_type = Some(input);
            self
        }
        /// <p>The owner type.</p>
        pub fn set_owner_type(
            mut self,
            input: std::option::Option<crate::model::PrincipalType>,
        ) -> Self {
            self.owner_type = input;
            self
        }
        /// Appends an item to `resource_uris`.
        ///
        /// To override the contents of this collection use [`set_resource_uris`](Self::set_resource_uris).
        ///
        /// <p>The resource URIs for the function.</p>
        pub fn resource_uris(mut self, input: crate::model::ResourceUri) -> Self {
            let mut v = self.resource_uris.unwrap_or_default();
            v.push(input);
            self.resource_uris = Some(v);
            self
        }
        /// <p>The resource URIs for the function.</p>
        pub fn set_resource_uris(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ResourceUri>>,
        ) -> Self {
            self.resource_uris = input;
            self
        }
        /// Consumes the builder and constructs a [`UserDefinedFunctionInput`](crate::model::UserDefinedFunctionInput).
        pub fn build(self) -> crate::model::UserDefinedFunctionInput {
            crate::model::UserDefinedFunctionInput {
                function_name: self.function_name,
                class_name: self.class_name,
                owner_name: self.owner_name,
                owner_type: self.owner_type,
                resource_uris: self.resource_uris,
            }
        }
    }
}
impl UserDefinedFunctionInput {
    /// Creates a new builder-style object to manufacture [`UserDefinedFunctionInput`](crate::model::UserDefinedFunctionInput).
    pub fn builder() -> crate::model::user_defined_function_input::Builder {
        crate::model::user_defined_function_input::Builder::default()
    }
}

/// <p>The URIs for function resources.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ResourceUri {
    /// <p>The type of the resource.</p>
    #[doc(hidden)]
    pub resource_type: std::option::Option<crate::model::ResourceType>,
    /// <p>The URI for accessing the resource.</p>
    #[doc(hidden)]
    pub uri: std::option::Option<std::string::String>,
}
impl ResourceUri {
    /// <p>The type of the resource.</p>
    pub fn resource_type(&self) -> std::option::Option<&crate::model::ResourceType> {
        self.resource_type.as_ref()
    }
    /// <p>The URI for accessing the resource.</p>
    pub fn uri(&self) -> std::option::Option<&str> {
        self.uri.as_deref()
    }
}
/// See [`ResourceUri`](crate::model::ResourceUri).
pub mod resource_uri {

    /// A builder for [`ResourceUri`](crate::model::ResourceUri).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_type: std::option::Option<crate::model::ResourceType>,
        pub(crate) uri: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The type of the resource.</p>
        pub fn resource_type(mut self, input: crate::model::ResourceType) -> Self {
            self.resource_type = Some(input);
            self
        }
        /// <p>The type of the resource.</p>
        pub fn set_resource_type(
            mut self,
            input: std::option::Option<crate::model::ResourceType>,
        ) -> Self {
            self.resource_type = input;
            self
        }
        /// <p>The URI for accessing the resource.</p>
        pub fn uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.uri = Some(input.into());
            self
        }
        /// <p>The URI for accessing the resource.</p>
        pub fn set_uri(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.uri = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceUri`](crate::model::ResourceUri).
        pub fn build(self) -> crate::model::ResourceUri {
            crate::model::ResourceUri {
                resource_type: self.resource_type,
                uri: self.uri,
            }
        }
    }
}
impl ResourceUri {
    /// Creates a new builder-style object to manufacture [`ResourceUri`](crate::model::ResourceUri).
    pub fn builder() -> crate::model::resource_uri::Builder {
        crate::model::resource_uri::Builder::default()
    }
}

/// When writing a match expression against `ResourceType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let resourcetype = unimplemented!();
/// match resourcetype {
///     ResourceType::Archive => { /* ... */ },
///     ResourceType::File => { /* ... */ },
///     ResourceType::Jar => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `resourcetype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ResourceType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ResourceType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ResourceType::NewFeature` is defined.
/// Specifically, when `resourcetype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ResourceType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ResourceType {
    #[allow(missing_docs)] // documentation missing in model
    Archive,
    #[allow(missing_docs)] // documentation missing in model
    File,
    #[allow(missing_docs)] // documentation missing in model
    Jar,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ResourceType {
    fn from(s: &str) -> Self {
        match s {
            "ARCHIVE" => ResourceType::Archive,
            "FILE" => ResourceType::File,
            "JAR" => ResourceType::Jar,
            other => ResourceType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ResourceType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ResourceType::from(s))
    }
}
impl ResourceType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ResourceType::Archive => "ARCHIVE",
            ResourceType::File => "FILE",
            ResourceType::Jar => "JAR",
            ResourceType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ARCHIVE", "FILE", "JAR"]
    }
}
impl AsRef<str> for ResourceType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `PrincipalType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let principaltype = unimplemented!();
/// match principaltype {
///     PrincipalType::Group => { /* ... */ },
///     PrincipalType::Role => { /* ... */ },
///     PrincipalType::User => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `principaltype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `PrincipalType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `PrincipalType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `PrincipalType::NewFeature` is defined.
/// Specifically, when `principaltype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `PrincipalType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum PrincipalType {
    #[allow(missing_docs)] // documentation missing in model
    Group,
    #[allow(missing_docs)] // documentation missing in model
    Role,
    #[allow(missing_docs)] // documentation missing in model
    User,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for PrincipalType {
    fn from(s: &str) -> Self {
        match s {
            "GROUP" => PrincipalType::Group,
            "ROLE" => PrincipalType::Role,
            "USER" => PrincipalType::User,
            other => PrincipalType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for PrincipalType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(PrincipalType::from(s))
    }
}
impl PrincipalType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            PrincipalType::Group => "GROUP",
            PrincipalType::Role => "ROLE",
            PrincipalType::User => "USER",
            PrincipalType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["GROUP", "ROLE", "USER"]
    }
}
impl AsRef<str> for PrincipalType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Information about a specific trigger.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Trigger {
    /// <p>The name of the trigger.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The name of the workflow associated with the trigger.</p>
    #[doc(hidden)]
    pub workflow_name: std::option::Option<std::string::String>,
    /// <p>Reserved for future use.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The type of trigger that this is.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::TriggerType>,
    /// <p>The current state of the trigger.</p>
    #[doc(hidden)]
    pub state: std::option::Option<crate::model::TriggerState>,
    /// <p>A description of this trigger.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>A <code>cron</code> expression used to specify the schedule (see <a href="https://docs.aws.amazon.com/glue/latest/dg/monitor-data-warehouse-schedule.html">Time-Based Schedules for Jobs and Crawlers</a>. For example, to run something every day at 12:15 UTC, you would specify: <code>cron(15 12 * * ? *)</code>.</p>
    #[doc(hidden)]
    pub schedule: std::option::Option<std::string::String>,
    /// <p>The actions initiated by this trigger.</p>
    #[doc(hidden)]
    pub actions: std::option::Option<std::vec::Vec<crate::model::Action>>,
    /// <p>The predicate of this trigger, which defines when it will fire.</p>
    #[doc(hidden)]
    pub predicate: std::option::Option<crate::model::Predicate>,
    /// <p>Batch condition that must be met (specified number of events received or batch time window expired) before EventBridge event trigger fires.</p>
    #[doc(hidden)]
    pub event_batching_condition: std::option::Option<crate::model::EventBatchingCondition>,
}
impl Trigger {
    /// <p>The name of the trigger.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The name of the workflow associated with the trigger.</p>
    pub fn workflow_name(&self) -> std::option::Option<&str> {
        self.workflow_name.as_deref()
    }
    /// <p>Reserved for future use.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The type of trigger that this is.</p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::TriggerType> {
        self.r#type.as_ref()
    }
    /// <p>The current state of the trigger.</p>
    pub fn state(&self) -> std::option::Option<&crate::model::TriggerState> {
        self.state.as_ref()
    }
    /// <p>A description of this trigger.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>A <code>cron</code> expression used to specify the schedule (see <a href="https://docs.aws.amazon.com/glue/latest/dg/monitor-data-warehouse-schedule.html">Time-Based Schedules for Jobs and Crawlers</a>. For example, to run something every day at 12:15 UTC, you would specify: <code>cron(15 12 * * ? *)</code>.</p>
    pub fn schedule(&self) -> std::option::Option<&str> {
        self.schedule.as_deref()
    }
    /// <p>The actions initiated by this trigger.</p>
    pub fn actions(&self) -> std::option::Option<&[crate::model::Action]> {
        self.actions.as_deref()
    }
    /// <p>The predicate of this trigger, which defines when it will fire.</p>
    pub fn predicate(&self) -> std::option::Option<&crate::model::Predicate> {
        self.predicate.as_ref()
    }
    /// <p>Batch condition that must be met (specified number of events received or batch time window expired) before EventBridge event trigger fires.</p>
    pub fn event_batching_condition(
        &self,
    ) -> std::option::Option<&crate::model::EventBatchingCondition> {
        self.event_batching_condition.as_ref()
    }
}
/// See [`Trigger`](crate::model::Trigger).
pub mod trigger {

    /// A builder for [`Trigger`](crate::model::Trigger).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) workflow_name: std::option::Option<std::string::String>,
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<crate::model::TriggerType>,
        pub(crate) state: std::option::Option<crate::model::TriggerState>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) schedule: std::option::Option<std::string::String>,
        pub(crate) actions: std::option::Option<std::vec::Vec<crate::model::Action>>,
        pub(crate) predicate: std::option::Option<crate::model::Predicate>,
        pub(crate) event_batching_condition:
            std::option::Option<crate::model::EventBatchingCondition>,
    }
    impl Builder {
        /// <p>The name of the trigger.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the trigger.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The name of the workflow associated with the trigger.</p>
        pub fn workflow_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.workflow_name = Some(input.into());
            self
        }
        /// <p>The name of the workflow associated with the trigger.</p>
        pub fn set_workflow_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.workflow_name = input;
            self
        }
        /// <p>Reserved for future use.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>Reserved for future use.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The type of trigger that this is.</p>
        pub fn r#type(mut self, input: crate::model::TriggerType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The type of trigger that this is.</p>
        pub fn set_type(mut self, input: std::option::Option<crate::model::TriggerType>) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The current state of the trigger.</p>
        pub fn state(mut self, input: crate::model::TriggerState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The current state of the trigger.</p>
        pub fn set_state(mut self, input: std::option::Option<crate::model::TriggerState>) -> Self {
            self.state = input;
            self
        }
        /// <p>A description of this trigger.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A description of this trigger.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>A <code>cron</code> expression used to specify the schedule (see <a href="https://docs.aws.amazon.com/glue/latest/dg/monitor-data-warehouse-schedule.html">Time-Based Schedules for Jobs and Crawlers</a>. For example, to run something every day at 12:15 UTC, you would specify: <code>cron(15 12 * * ? *)</code>.</p>
        pub fn schedule(mut self, input: impl Into<std::string::String>) -> Self {
            self.schedule = Some(input.into());
            self
        }
        /// <p>A <code>cron</code> expression used to specify the schedule (see <a href="https://docs.aws.amazon.com/glue/latest/dg/monitor-data-warehouse-schedule.html">Time-Based Schedules for Jobs and Crawlers</a>. For example, to run something every day at 12:15 UTC, you would specify: <code>cron(15 12 * * ? *)</code>.</p>
        pub fn set_schedule(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.schedule = input;
            self
        }
        /// Appends an item to `actions`.
        ///
        /// To override the contents of this collection use [`set_actions`](Self::set_actions).
        ///
        /// <p>The actions initiated by this trigger.</p>
        pub fn actions(mut self, input: crate::model::Action) -> Self {
            let mut v = self.actions.unwrap_or_default();
            v.push(input);
            self.actions = Some(v);
            self
        }
        /// <p>The actions initiated by this trigger.</p>
        pub fn set_actions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Action>>,
        ) -> Self {
            self.actions = input;
            self
        }
        /// <p>The predicate of this trigger, which defines when it will fire.</p>
        pub fn predicate(mut self, input: crate::model::Predicate) -> Self {
            self.predicate = Some(input);
            self
        }
        /// <p>The predicate of this trigger, which defines when it will fire.</p>
        pub fn set_predicate(
            mut self,
            input: std::option::Option<crate::model::Predicate>,
        ) -> Self {
            self.predicate = input;
            self
        }
        /// <p>Batch condition that must be met (specified number of events received or batch time window expired) before EventBridge event trigger fires.</p>
        pub fn event_batching_condition(
            mut self,
            input: crate::model::EventBatchingCondition,
        ) -> Self {
            self.event_batching_condition = Some(input);
            self
        }
        /// <p>Batch condition that must be met (specified number of events received or batch time window expired) before EventBridge event trigger fires.</p>
        pub fn set_event_batching_condition(
            mut self,
            input: std::option::Option<crate::model::EventBatchingCondition>,
        ) -> Self {
            self.event_batching_condition = input;
            self
        }
        /// Consumes the builder and constructs a [`Trigger`](crate::model::Trigger).
        pub fn build(self) -> crate::model::Trigger {
            crate::model::Trigger {
                name: self.name,
                workflow_name: self.workflow_name,
                id: self.id,
                r#type: self.r#type,
                state: self.state,
                description: self.description,
                schedule: self.schedule,
                actions: self.actions,
                predicate: self.predicate,
                event_batching_condition: self.event_batching_condition,
            }
        }
    }
}
impl Trigger {
    /// Creates a new builder-style object to manufacture [`Trigger`](crate::model::Trigger).
    pub fn builder() -> crate::model::trigger::Builder {
        crate::model::trigger::Builder::default()
    }
}

/// <p>Batch condition that must be met (specified number of events received or batch time window expired) before EventBridge event trigger fires.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct EventBatchingCondition {
    /// <p>Number of events that must be received from Amazon EventBridge before EventBridge event trigger fires.</p>
    #[doc(hidden)]
    pub batch_size: i32,
    /// <p>Window of time in seconds after which EventBridge event trigger fires. Window starts when first event is received.</p>
    #[doc(hidden)]
    pub batch_window: std::option::Option<i32>,
}
impl EventBatchingCondition {
    /// <p>Number of events that must be received from Amazon EventBridge before EventBridge event trigger fires.</p>
    pub fn batch_size(&self) -> i32 {
        self.batch_size
    }
    /// <p>Window of time in seconds after which EventBridge event trigger fires. Window starts when first event is received.</p>
    pub fn batch_window(&self) -> std::option::Option<i32> {
        self.batch_window
    }
}
/// See [`EventBatchingCondition`](crate::model::EventBatchingCondition).
pub mod event_batching_condition {

    /// A builder for [`EventBatchingCondition`](crate::model::EventBatchingCondition).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) batch_size: std::option::Option<i32>,
        pub(crate) batch_window: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>Number of events that must be received from Amazon EventBridge before EventBridge event trigger fires.</p>
        pub fn batch_size(mut self, input: i32) -> Self {
            self.batch_size = Some(input);
            self
        }
        /// <p>Number of events that must be received from Amazon EventBridge before EventBridge event trigger fires.</p>
        pub fn set_batch_size(mut self, input: std::option::Option<i32>) -> Self {
            self.batch_size = input;
            self
        }
        /// <p>Window of time in seconds after which EventBridge event trigger fires. Window starts when first event is received.</p>
        pub fn batch_window(mut self, input: i32) -> Self {
            self.batch_window = Some(input);
            self
        }
        /// <p>Window of time in seconds after which EventBridge event trigger fires. Window starts when first event is received.</p>
        pub fn set_batch_window(mut self, input: std::option::Option<i32>) -> Self {
            self.batch_window = input;
            self
        }
        /// Consumes the builder and constructs a [`EventBatchingCondition`](crate::model::EventBatchingCondition).
        pub fn build(self) -> crate::model::EventBatchingCondition {
            crate::model::EventBatchingCondition {
                batch_size: self.batch_size.unwrap_or_default(),
                batch_window: self.batch_window,
            }
        }
    }
}
impl EventBatchingCondition {
    /// Creates a new builder-style object to manufacture [`EventBatchingCondition`](crate::model::EventBatchingCondition).
    pub fn builder() -> crate::model::event_batching_condition::Builder {
        crate::model::event_batching_condition::Builder::default()
    }
}

/// <p>Defines the predicate of the trigger, which determines when it fires.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Predicate {
    /// <p>An optional field if only one condition is listed. If multiple conditions are listed, then this field is required.</p>
    #[doc(hidden)]
    pub logical: std::option::Option<crate::model::Logical>,
    /// <p>A list of the conditions that determine when the trigger will fire.</p>
    #[doc(hidden)]
    pub conditions: std::option::Option<std::vec::Vec<crate::model::Condition>>,
}
impl Predicate {
    /// <p>An optional field if only one condition is listed. If multiple conditions are listed, then this field is required.</p>
    pub fn logical(&self) -> std::option::Option<&crate::model::Logical> {
        self.logical.as_ref()
    }
    /// <p>A list of the conditions that determine when the trigger will fire.</p>
    pub fn conditions(&self) -> std::option::Option<&[crate::model::Condition]> {
        self.conditions.as_deref()
    }
}
/// See [`Predicate`](crate::model::Predicate).
pub mod predicate {

    /// A builder for [`Predicate`](crate::model::Predicate).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) logical: std::option::Option<crate::model::Logical>,
        pub(crate) conditions: std::option::Option<std::vec::Vec<crate::model::Condition>>,
    }
    impl Builder {
        /// <p>An optional field if only one condition is listed. If multiple conditions are listed, then this field is required.</p>
        pub fn logical(mut self, input: crate::model::Logical) -> Self {
            self.logical = Some(input);
            self
        }
        /// <p>An optional field if only one condition is listed. If multiple conditions are listed, then this field is required.</p>
        pub fn set_logical(mut self, input: std::option::Option<crate::model::Logical>) -> Self {
            self.logical = input;
            self
        }
        /// Appends an item to `conditions`.
        ///
        /// To override the contents of this collection use [`set_conditions`](Self::set_conditions).
        ///
        /// <p>A list of the conditions that determine when the trigger will fire.</p>
        pub fn conditions(mut self, input: crate::model::Condition) -> Self {
            let mut v = self.conditions.unwrap_or_default();
            v.push(input);
            self.conditions = Some(v);
            self
        }
        /// <p>A list of the conditions that determine when the trigger will fire.</p>
        pub fn set_conditions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Condition>>,
        ) -> Self {
            self.conditions = input;
            self
        }
        /// Consumes the builder and constructs a [`Predicate`](crate::model::Predicate).
        pub fn build(self) -> crate::model::Predicate {
            crate::model::Predicate {
                logical: self.logical,
                conditions: self.conditions,
            }
        }
    }
}
impl Predicate {
    /// Creates a new builder-style object to manufacture [`Predicate`](crate::model::Predicate).
    pub fn builder() -> crate::model::predicate::Builder {
        crate::model::predicate::Builder::default()
    }
}

/// <p>Defines a condition under which a trigger fires.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Condition {
    /// <p>A logical operator.</p>
    #[doc(hidden)]
    pub logical_operator: std::option::Option<crate::model::LogicalOperator>,
    /// <p>The name of the job whose <code>JobRuns</code> this condition applies to, and on which this trigger waits.</p>
    #[doc(hidden)]
    pub job_name: std::option::Option<std::string::String>,
    /// <p>The condition state. Currently, the only job states that a trigger can listen for are <code>SUCCEEDED</code>, <code>STOPPED</code>, <code>FAILED</code>, and <code>TIMEOUT</code>. The only crawler states that a trigger can listen for are <code>SUCCEEDED</code>, <code>FAILED</code>, and <code>CANCELLED</code>.</p>
    #[doc(hidden)]
    pub state: std::option::Option<crate::model::JobRunState>,
    /// <p>The name of the crawler to which this condition applies.</p>
    #[doc(hidden)]
    pub crawler_name: std::option::Option<std::string::String>,
    /// <p>The state of the crawler to which this condition applies.</p>
    #[doc(hidden)]
    pub crawl_state: std::option::Option<crate::model::CrawlState>,
}
impl Condition {
    /// <p>A logical operator.</p>
    pub fn logical_operator(&self) -> std::option::Option<&crate::model::LogicalOperator> {
        self.logical_operator.as_ref()
    }
    /// <p>The name of the job whose <code>JobRuns</code> this condition applies to, and on which this trigger waits.</p>
    pub fn job_name(&self) -> std::option::Option<&str> {
        self.job_name.as_deref()
    }
    /// <p>The condition state. Currently, the only job states that a trigger can listen for are <code>SUCCEEDED</code>, <code>STOPPED</code>, <code>FAILED</code>, and <code>TIMEOUT</code>. The only crawler states that a trigger can listen for are <code>SUCCEEDED</code>, <code>FAILED</code>, and <code>CANCELLED</code>.</p>
    pub fn state(&self) -> std::option::Option<&crate::model::JobRunState> {
        self.state.as_ref()
    }
    /// <p>The name of the crawler to which this condition applies.</p>
    pub fn crawler_name(&self) -> std::option::Option<&str> {
        self.crawler_name.as_deref()
    }
    /// <p>The state of the crawler to which this condition applies.</p>
    pub fn crawl_state(&self) -> std::option::Option<&crate::model::CrawlState> {
        self.crawl_state.as_ref()
    }
}
/// See [`Condition`](crate::model::Condition).
pub mod condition {

    /// A builder for [`Condition`](crate::model::Condition).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) logical_operator: std::option::Option<crate::model::LogicalOperator>,
        pub(crate) job_name: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<crate::model::JobRunState>,
        pub(crate) crawler_name: std::option::Option<std::string::String>,
        pub(crate) crawl_state: std::option::Option<crate::model::CrawlState>,
    }
    impl Builder {
        /// <p>A logical operator.</p>
        pub fn logical_operator(mut self, input: crate::model::LogicalOperator) -> Self {
            self.logical_operator = Some(input);
            self
        }
        /// <p>A logical operator.</p>
        pub fn set_logical_operator(
            mut self,
            input: std::option::Option<crate::model::LogicalOperator>,
        ) -> Self {
            self.logical_operator = input;
            self
        }
        /// <p>The name of the job whose <code>JobRuns</code> this condition applies to, and on which this trigger waits.</p>
        pub fn job_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_name = Some(input.into());
            self
        }
        /// <p>The name of the job whose <code>JobRuns</code> this condition applies to, and on which this trigger waits.</p>
        pub fn set_job_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_name = input;
            self
        }
        /// <p>The condition state. Currently, the only job states that a trigger can listen for are <code>SUCCEEDED</code>, <code>STOPPED</code>, <code>FAILED</code>, and <code>TIMEOUT</code>. The only crawler states that a trigger can listen for are <code>SUCCEEDED</code>, <code>FAILED</code>, and <code>CANCELLED</code>.</p>
        pub fn state(mut self, input: crate::model::JobRunState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The condition state. Currently, the only job states that a trigger can listen for are <code>SUCCEEDED</code>, <code>STOPPED</code>, <code>FAILED</code>, and <code>TIMEOUT</code>. The only crawler states that a trigger can listen for are <code>SUCCEEDED</code>, <code>FAILED</code>, and <code>CANCELLED</code>.</p>
        pub fn set_state(mut self, input: std::option::Option<crate::model::JobRunState>) -> Self {
            self.state = input;
            self
        }
        /// <p>The name of the crawler to which this condition applies.</p>
        pub fn crawler_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.crawler_name = Some(input.into());
            self
        }
        /// <p>The name of the crawler to which this condition applies.</p>
        pub fn set_crawler_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.crawler_name = input;
            self
        }
        /// <p>The state of the crawler to which this condition applies.</p>
        pub fn crawl_state(mut self, input: crate::model::CrawlState) -> Self {
            self.crawl_state = Some(input);
            self
        }
        /// <p>The state of the crawler to which this condition applies.</p>
        pub fn set_crawl_state(
            mut self,
            input: std::option::Option<crate::model::CrawlState>,
        ) -> Self {
            self.crawl_state = input;
            self
        }
        /// Consumes the builder and constructs a [`Condition`](crate::model::Condition).
        pub fn build(self) -> crate::model::Condition {
            crate::model::Condition {
                logical_operator: self.logical_operator,
                job_name: self.job_name,
                state: self.state,
                crawler_name: self.crawler_name,
                crawl_state: self.crawl_state,
            }
        }
    }
}
impl Condition {
    /// Creates a new builder-style object to manufacture [`Condition`](crate::model::Condition).
    pub fn builder() -> crate::model::condition::Builder {
        crate::model::condition::Builder::default()
    }
}

/// When writing a match expression against `CrawlState`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let crawlstate = unimplemented!();
/// match crawlstate {
///     CrawlState::Cancelled => { /* ... */ },
///     CrawlState::Cancelling => { /* ... */ },
///     CrawlState::Error => { /* ... */ },
///     CrawlState::Failed => { /* ... */ },
///     CrawlState::Running => { /* ... */ },
///     CrawlState::Succeeded => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `crawlstate` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `CrawlState::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `CrawlState::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `CrawlState::NewFeature` is defined.
/// Specifically, when `crawlstate` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `CrawlState::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum CrawlState {
    #[allow(missing_docs)] // documentation missing in model
    Cancelled,
    #[allow(missing_docs)] // documentation missing in model
    Cancelling,
    #[allow(missing_docs)] // documentation missing in model
    Error,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    Running,
    #[allow(missing_docs)] // documentation missing in model
    Succeeded,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for CrawlState {
    fn from(s: &str) -> Self {
        match s {
            "CANCELLED" => CrawlState::Cancelled,
            "CANCELLING" => CrawlState::Cancelling,
            "ERROR" => CrawlState::Error,
            "FAILED" => CrawlState::Failed,
            "RUNNING" => CrawlState::Running,
            "SUCCEEDED" => CrawlState::Succeeded,
            other => CrawlState::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for CrawlState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(CrawlState::from(s))
    }
}
impl CrawlState {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            CrawlState::Cancelled => "CANCELLED",
            CrawlState::Cancelling => "CANCELLING",
            CrawlState::Error => "ERROR",
            CrawlState::Failed => "FAILED",
            CrawlState::Running => "RUNNING",
            CrawlState::Succeeded => "SUCCEEDED",
            CrawlState::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "CANCELLED",
            "CANCELLING",
            "ERROR",
            "FAILED",
            "RUNNING",
            "SUCCEEDED",
        ]
    }
}
impl AsRef<str> for CrawlState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `JobRunState`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let jobrunstate = unimplemented!();
/// match jobrunstate {
///     JobRunState::Error => { /* ... */ },
///     JobRunState::Failed => { /* ... */ },
///     JobRunState::Running => { /* ... */ },
///     JobRunState::Starting => { /* ... */ },
///     JobRunState::Stopped => { /* ... */ },
///     JobRunState::Stopping => { /* ... */ },
///     JobRunState::Succeeded => { /* ... */ },
///     JobRunState::Timeout => { /* ... */ },
///     JobRunState::Waiting => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `jobrunstate` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `JobRunState::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `JobRunState::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `JobRunState::NewFeature` is defined.
/// Specifically, when `jobrunstate` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `JobRunState::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum JobRunState {
    #[allow(missing_docs)] // documentation missing in model
    Error,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    Running,
    #[allow(missing_docs)] // documentation missing in model
    Starting,
    #[allow(missing_docs)] // documentation missing in model
    Stopped,
    #[allow(missing_docs)] // documentation missing in model
    Stopping,
    #[allow(missing_docs)] // documentation missing in model
    Succeeded,
    #[allow(missing_docs)] // documentation missing in model
    Timeout,
    #[allow(missing_docs)] // documentation missing in model
    Waiting,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for JobRunState {
    fn from(s: &str) -> Self {
        match s {
            "ERROR" => JobRunState::Error,
            "FAILED" => JobRunState::Failed,
            "RUNNING" => JobRunState::Running,
            "STARTING" => JobRunState::Starting,
            "STOPPED" => JobRunState::Stopped,
            "STOPPING" => JobRunState::Stopping,
            "SUCCEEDED" => JobRunState::Succeeded,
            "TIMEOUT" => JobRunState::Timeout,
            "WAITING" => JobRunState::Waiting,
            other => JobRunState::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for JobRunState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(JobRunState::from(s))
    }
}
impl JobRunState {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            JobRunState::Error => "ERROR",
            JobRunState::Failed => "FAILED",
            JobRunState::Running => "RUNNING",
            JobRunState::Starting => "STARTING",
            JobRunState::Stopped => "STOPPED",
            JobRunState::Stopping => "STOPPING",
            JobRunState::Succeeded => "SUCCEEDED",
            JobRunState::Timeout => "TIMEOUT",
            JobRunState::Waiting => "WAITING",
            JobRunState::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "ERROR",
            "FAILED",
            "RUNNING",
            "STARTING",
            "STOPPED",
            "STOPPING",
            "SUCCEEDED",
            "TIMEOUT",
            "WAITING",
        ]
    }
}
impl AsRef<str> for JobRunState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `LogicalOperator`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let logicaloperator = unimplemented!();
/// match logicaloperator {
///     LogicalOperator::Equals => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `logicaloperator` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `LogicalOperator::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `LogicalOperator::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `LogicalOperator::NewFeature` is defined.
/// Specifically, when `logicaloperator` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `LogicalOperator::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum LogicalOperator {
    #[allow(missing_docs)] // documentation missing in model
    Equals,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for LogicalOperator {
    fn from(s: &str) -> Self {
        match s {
            "EQUALS" => LogicalOperator::Equals,
            other => LogicalOperator::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for LogicalOperator {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(LogicalOperator::from(s))
    }
}
impl LogicalOperator {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            LogicalOperator::Equals => "EQUALS",
            LogicalOperator::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["EQUALS"]
    }
}
impl AsRef<str> for LogicalOperator {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `Logical`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let logical = unimplemented!();
/// match logical {
///     Logical::And => { /* ... */ },
///     Logical::Any => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `logical` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `Logical::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `Logical::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `Logical::NewFeature` is defined.
/// Specifically, when `logical` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `Logical::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Logical {
    #[allow(missing_docs)] // documentation missing in model
    And,
    #[allow(missing_docs)] // documentation missing in model
    Any,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for Logical {
    fn from(s: &str) -> Self {
        match s {
            "AND" => Logical::And,
            "ANY" => Logical::Any,
            other => Logical::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for Logical {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(Logical::from(s))
    }
}
impl Logical {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            Logical::And => "AND",
            Logical::Any => "ANY",
            Logical::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["AND", "ANY"]
    }
}
impl AsRef<str> for Logical {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Defines an action to be initiated by a trigger.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Action {
    /// <p>The name of a job to be run.</p>
    #[doc(hidden)]
    pub job_name: std::option::Option<std::string::String>,
    /// <p>The job arguments used when this trigger fires. For this job run, they replace the default arguments set in the job definition itself.</p>
    /// <p>You can specify arguments here that your own job-execution script consumes, as well as arguments that Glue itself consumes.</p>
    /// <p>For information about how to specify and consume your own Job arguments, see the <a href="https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-python-calling.html">Calling Glue APIs in Python</a> topic in the developer guide.</p>
    /// <p>For information about the key-value pairs that Glue consumes to set up your job, see the <a href="https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-etl-glue-arguments.html">Special Parameters Used by Glue</a> topic in the developer guide.</p>
    #[doc(hidden)]
    pub arguments:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The <code>JobRun</code> timeout in minutes. This is the maximum time that a job run can consume resources before it is terminated and enters <code>TIMEOUT</code> status. The default is 2,880 minutes (48 hours). This overrides the timeout value set in the parent job.</p>
    #[doc(hidden)]
    pub timeout: std::option::Option<i32>,
    /// <p>The name of the <code>SecurityConfiguration</code> structure to be used with this action.</p>
    #[doc(hidden)]
    pub security_configuration: std::option::Option<std::string::String>,
    /// <p>Specifies configuration properties of a job run notification.</p>
    #[doc(hidden)]
    pub notification_property: std::option::Option<crate::model::NotificationProperty>,
    /// <p>The name of the crawler to be used with this action.</p>
    #[doc(hidden)]
    pub crawler_name: std::option::Option<std::string::String>,
}
impl Action {
    /// <p>The name of a job to be run.</p>
    pub fn job_name(&self) -> std::option::Option<&str> {
        self.job_name.as_deref()
    }
    /// <p>The job arguments used when this trigger fires. For this job run, they replace the default arguments set in the job definition itself.</p>
    /// <p>You can specify arguments here that your own job-execution script consumes, as well as arguments that Glue itself consumes.</p>
    /// <p>For information about how to specify and consume your own Job arguments, see the <a href="https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-python-calling.html">Calling Glue APIs in Python</a> topic in the developer guide.</p>
    /// <p>For information about the key-value pairs that Glue consumes to set up your job, see the <a href="https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-etl-glue-arguments.html">Special Parameters Used by Glue</a> topic in the developer guide.</p>
    pub fn arguments(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.arguments.as_ref()
    }
    /// <p>The <code>JobRun</code> timeout in minutes. This is the maximum time that a job run can consume resources before it is terminated and enters <code>TIMEOUT</code> status. The default is 2,880 minutes (48 hours). This overrides the timeout value set in the parent job.</p>
    pub fn timeout(&self) -> std::option::Option<i32> {
        self.timeout
    }
    /// <p>The name of the <code>SecurityConfiguration</code> structure to be used with this action.</p>
    pub fn security_configuration(&self) -> std::option::Option<&str> {
        self.security_configuration.as_deref()
    }
    /// <p>Specifies configuration properties of a job run notification.</p>
    pub fn notification_property(
        &self,
    ) -> std::option::Option<&crate::model::NotificationProperty> {
        self.notification_property.as_ref()
    }
    /// <p>The name of the crawler to be used with this action.</p>
    pub fn crawler_name(&self) -> std::option::Option<&str> {
        self.crawler_name.as_deref()
    }
}
/// See [`Action`](crate::model::Action).
pub mod action {

    /// A builder for [`Action`](crate::model::Action).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) job_name: std::option::Option<std::string::String>,
        pub(crate) arguments: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) timeout: std::option::Option<i32>,
        pub(crate) security_configuration: std::option::Option<std::string::String>,
        pub(crate) notification_property: std::option::Option<crate::model::NotificationProperty>,
        pub(crate) crawler_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of a job to be run.</p>
        pub fn job_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_name = Some(input.into());
            self
        }
        /// <p>The name of a job to be run.</p>
        pub fn set_job_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_name = input;
            self
        }
        /// Adds a key-value pair to `arguments`.
        ///
        /// To override the contents of this collection use [`set_arguments`](Self::set_arguments).
        ///
        /// <p>The job arguments used when this trigger fires. For this job run, they replace the default arguments set in the job definition itself.</p>
        /// <p>You can specify arguments here that your own job-execution script consumes, as well as arguments that Glue itself consumes.</p>
        /// <p>For information about how to specify and consume your own Job arguments, see the <a href="https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-python-calling.html">Calling Glue APIs in Python</a> topic in the developer guide.</p>
        /// <p>For information about the key-value pairs that Glue consumes to set up your job, see the <a href="https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-etl-glue-arguments.html">Special Parameters Used by Glue</a> topic in the developer guide.</p>
        pub fn arguments(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.arguments.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.arguments = Some(hash_map);
            self
        }
        /// <p>The job arguments used when this trigger fires. For this job run, they replace the default arguments set in the job definition itself.</p>
        /// <p>You can specify arguments here that your own job-execution script consumes, as well as arguments that Glue itself consumes.</p>
        /// <p>For information about how to specify and consume your own Job arguments, see the <a href="https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-python-calling.html">Calling Glue APIs in Python</a> topic in the developer guide.</p>
        /// <p>For information about the key-value pairs that Glue consumes to set up your job, see the <a href="https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-etl-glue-arguments.html">Special Parameters Used by Glue</a> topic in the developer guide.</p>
        pub fn set_arguments(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.arguments = input;
            self
        }
        /// <p>The <code>JobRun</code> timeout in minutes. This is the maximum time that a job run can consume resources before it is terminated and enters <code>TIMEOUT</code> status. The default is 2,880 minutes (48 hours). This overrides the timeout value set in the parent job.</p>
        pub fn timeout(mut self, input: i32) -> Self {
            self.timeout = Some(input);
            self
        }
        /// <p>The <code>JobRun</code> timeout in minutes. This is the maximum time that a job run can consume resources before it is terminated and enters <code>TIMEOUT</code> status. The default is 2,880 minutes (48 hours). This overrides the timeout value set in the parent job.</p>
        pub fn set_timeout(mut self, input: std::option::Option<i32>) -> Self {
            self.timeout = input;
            self
        }
        /// <p>The name of the <code>SecurityConfiguration</code> structure to be used with this action.</p>
        pub fn security_configuration(mut self, input: impl Into<std::string::String>) -> Self {
            self.security_configuration = Some(input.into());
            self
        }
        /// <p>The name of the <code>SecurityConfiguration</code> structure to be used with this action.</p>
        pub fn set_security_configuration(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.security_configuration = input;
            self
        }
        /// <p>Specifies configuration properties of a job run notification.</p>
        pub fn notification_property(mut self, input: crate::model::NotificationProperty) -> Self {
            self.notification_property = Some(input);
            self
        }
        /// <p>Specifies configuration properties of a job run notification.</p>
        pub fn set_notification_property(
            mut self,
            input: std::option::Option<crate::model::NotificationProperty>,
        ) -> Self {
            self.notification_property = input;
            self
        }
        /// <p>The name of the crawler to be used with this action.</p>
        pub fn crawler_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.crawler_name = Some(input.into());
            self
        }
        /// <p>The name of the crawler to be used with this action.</p>
        pub fn set_crawler_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.crawler_name = input;
            self
        }
        /// Consumes the builder and constructs a [`Action`](crate::model::Action).
        pub fn build(self) -> crate::model::Action {
            crate::model::Action {
                job_name: self.job_name,
                arguments: self.arguments,
                timeout: self.timeout,
                security_configuration: self.security_configuration,
                notification_property: self.notification_property,
                crawler_name: self.crawler_name,
            }
        }
    }
}
impl Action {
    /// Creates a new builder-style object to manufacture [`Action`](crate::model::Action).
    pub fn builder() -> crate::model::action::Builder {
        crate::model::action::Builder::default()
    }
}

/// <p>Specifies configuration properties of a notification.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct NotificationProperty {
    /// <p>After a job run starts, the number of minutes to wait before sending a job run delay notification.</p>
    #[doc(hidden)]
    pub notify_delay_after: std::option::Option<i32>,
}
impl NotificationProperty {
    /// <p>After a job run starts, the number of minutes to wait before sending a job run delay notification.</p>
    pub fn notify_delay_after(&self) -> std::option::Option<i32> {
        self.notify_delay_after
    }
}
/// See [`NotificationProperty`](crate::model::NotificationProperty).
pub mod notification_property {

    /// A builder for [`NotificationProperty`](crate::model::NotificationProperty).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) notify_delay_after: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>After a job run starts, the number of minutes to wait before sending a job run delay notification.</p>
        pub fn notify_delay_after(mut self, input: i32) -> Self {
            self.notify_delay_after = Some(input);
            self
        }
        /// <p>After a job run starts, the number of minutes to wait before sending a job run delay notification.</p>
        pub fn set_notify_delay_after(mut self, input: std::option::Option<i32>) -> Self {
            self.notify_delay_after = input;
            self
        }
        /// Consumes the builder and constructs a [`NotificationProperty`](crate::model::NotificationProperty).
        pub fn build(self) -> crate::model::NotificationProperty {
            crate::model::NotificationProperty {
                notify_delay_after: self.notify_delay_after,
            }
        }
    }
}
impl NotificationProperty {
    /// Creates a new builder-style object to manufacture [`NotificationProperty`](crate::model::NotificationProperty).
    pub fn builder() -> crate::model::notification_property::Builder {
        crate::model::notification_property::Builder::default()
    }
}

/// When writing a match expression against `TriggerState`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let triggerstate = unimplemented!();
/// match triggerstate {
///     TriggerState::Activated => { /* ... */ },
///     TriggerState::Activating => { /* ... */ },
///     TriggerState::Created => { /* ... */ },
///     TriggerState::Creating => { /* ... */ },
///     TriggerState::Deactivated => { /* ... */ },
///     TriggerState::Deactivating => { /* ... */ },
///     TriggerState::Deleting => { /* ... */ },
///     TriggerState::Updating => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `triggerstate` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `TriggerState::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `TriggerState::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `TriggerState::NewFeature` is defined.
/// Specifically, when `triggerstate` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `TriggerState::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TriggerState {
    #[allow(missing_docs)] // documentation missing in model
    Activated,
    #[allow(missing_docs)] // documentation missing in model
    Activating,
    #[allow(missing_docs)] // documentation missing in model
    Created,
    #[allow(missing_docs)] // documentation missing in model
    Creating,
    #[allow(missing_docs)] // documentation missing in model
    Deactivated,
    #[allow(missing_docs)] // documentation missing in model
    Deactivating,
    #[allow(missing_docs)] // documentation missing in model
    Deleting,
    #[allow(missing_docs)] // documentation missing in model
    Updating,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for TriggerState {
    fn from(s: &str) -> Self {
        match s {
            "ACTIVATED" => TriggerState::Activated,
            "ACTIVATING" => TriggerState::Activating,
            "CREATED" => TriggerState::Created,
            "CREATING" => TriggerState::Creating,
            "DEACTIVATED" => TriggerState::Deactivated,
            "DEACTIVATING" => TriggerState::Deactivating,
            "DELETING" => TriggerState::Deleting,
            "UPDATING" => TriggerState::Updating,
            other => TriggerState::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for TriggerState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TriggerState::from(s))
    }
}
impl TriggerState {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            TriggerState::Activated => "ACTIVATED",
            TriggerState::Activating => "ACTIVATING",
            TriggerState::Created => "CREATED",
            TriggerState::Creating => "CREATING",
            TriggerState::Deactivated => "DEACTIVATED",
            TriggerState::Deactivating => "DEACTIVATING",
            TriggerState::Deleting => "DELETING",
            TriggerState::Updating => "UPDATING",
            TriggerState::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "ACTIVATED",
            "ACTIVATING",
            "CREATED",
            "CREATING",
            "DEACTIVATED",
            "DEACTIVATING",
            "DELETING",
            "UPDATING",
        ]
    }
}
impl AsRef<str> for TriggerState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `TriggerType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let triggertype = unimplemented!();
/// match triggertype {
///     TriggerType::Conditional => { /* ... */ },
///     TriggerType::Event => { /* ... */ },
///     TriggerType::OnDemand => { /* ... */ },
///     TriggerType::Scheduled => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `triggertype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `TriggerType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `TriggerType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `TriggerType::NewFeature` is defined.
/// Specifically, when `triggertype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `TriggerType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TriggerType {
    #[allow(missing_docs)] // documentation missing in model
    Conditional,
    #[allow(missing_docs)] // documentation missing in model
    Event,
    #[allow(missing_docs)] // documentation missing in model
    OnDemand,
    #[allow(missing_docs)] // documentation missing in model
    Scheduled,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for TriggerType {
    fn from(s: &str) -> Self {
        match s {
            "CONDITIONAL" => TriggerType::Conditional,
            "EVENT" => TriggerType::Event,
            "ON_DEMAND" => TriggerType::OnDemand,
            "SCHEDULED" => TriggerType::Scheduled,
            other => TriggerType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for TriggerType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TriggerType::from(s))
    }
}
impl TriggerType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            TriggerType::Conditional => "CONDITIONAL",
            TriggerType::Event => "EVENT",
            TriggerType::OnDemand => "ON_DEMAND",
            TriggerType::Scheduled => "SCHEDULED",
            TriggerType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["CONDITIONAL", "EVENT", "ON_DEMAND", "SCHEDULED"]
    }
}
impl AsRef<str> for TriggerType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A structure used to provide information used to update a trigger. This object updates the previous trigger definition by overwriting it completely.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TriggerUpdate {
    /// <p>Reserved for future use.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>A description of this trigger.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>A <code>cron</code> expression used to specify the schedule (see <a href="https://docs.aws.amazon.com/glue/latest/dg/monitor-data-warehouse-schedule.html">Time-Based Schedules for Jobs and Crawlers</a>. For example, to run something every day at 12:15 UTC, you would specify: <code>cron(15 12 * * ? *)</code>.</p>
    #[doc(hidden)]
    pub schedule: std::option::Option<std::string::String>,
    /// <p>The actions initiated by this trigger.</p>
    #[doc(hidden)]
    pub actions: std::option::Option<std::vec::Vec<crate::model::Action>>,
    /// <p>The predicate of this trigger, which defines when it will fire.</p>
    #[doc(hidden)]
    pub predicate: std::option::Option<crate::model::Predicate>,
    /// <p>Batch condition that must be met (specified number of events received or batch time window expired) before EventBridge event trigger fires.</p>
    #[doc(hidden)]
    pub event_batching_condition: std::option::Option<crate::model::EventBatchingCondition>,
}
impl TriggerUpdate {
    /// <p>Reserved for future use.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>A description of this trigger.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>A <code>cron</code> expression used to specify the schedule (see <a href="https://docs.aws.amazon.com/glue/latest/dg/monitor-data-warehouse-schedule.html">Time-Based Schedules for Jobs and Crawlers</a>. For example, to run something every day at 12:15 UTC, you would specify: <code>cron(15 12 * * ? *)</code>.</p>
    pub fn schedule(&self) -> std::option::Option<&str> {
        self.schedule.as_deref()
    }
    /// <p>The actions initiated by this trigger.</p>
    pub fn actions(&self) -> std::option::Option<&[crate::model::Action]> {
        self.actions.as_deref()
    }
    /// <p>The predicate of this trigger, which defines when it will fire.</p>
    pub fn predicate(&self) -> std::option::Option<&crate::model::Predicate> {
        self.predicate.as_ref()
    }
    /// <p>Batch condition that must be met (specified number of events received or batch time window expired) before EventBridge event trigger fires.</p>
    pub fn event_batching_condition(
        &self,
    ) -> std::option::Option<&crate::model::EventBatchingCondition> {
        self.event_batching_condition.as_ref()
    }
}
/// See [`TriggerUpdate`](crate::model::TriggerUpdate).
pub mod trigger_update {

    /// A builder for [`TriggerUpdate`](crate::model::TriggerUpdate).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) schedule: std::option::Option<std::string::String>,
        pub(crate) actions: std::option::Option<std::vec::Vec<crate::model::Action>>,
        pub(crate) predicate: std::option::Option<crate::model::Predicate>,
        pub(crate) event_batching_condition:
            std::option::Option<crate::model::EventBatchingCondition>,
    }
    impl Builder {
        /// <p>Reserved for future use.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>Reserved for future use.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>A description of this trigger.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A description of this trigger.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>A <code>cron</code> expression used to specify the schedule (see <a href="https://docs.aws.amazon.com/glue/latest/dg/monitor-data-warehouse-schedule.html">Time-Based Schedules for Jobs and Crawlers</a>. For example, to run something every day at 12:15 UTC, you would specify: <code>cron(15 12 * * ? *)</code>.</p>
        pub fn schedule(mut self, input: impl Into<std::string::String>) -> Self {
            self.schedule = Some(input.into());
            self
        }
        /// <p>A <code>cron</code> expression used to specify the schedule (see <a href="https://docs.aws.amazon.com/glue/latest/dg/monitor-data-warehouse-schedule.html">Time-Based Schedules for Jobs and Crawlers</a>. For example, to run something every day at 12:15 UTC, you would specify: <code>cron(15 12 * * ? *)</code>.</p>
        pub fn set_schedule(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.schedule = input;
            self
        }
        /// Appends an item to `actions`.
        ///
        /// To override the contents of this collection use [`set_actions`](Self::set_actions).
        ///
        /// <p>The actions initiated by this trigger.</p>
        pub fn actions(mut self, input: crate::model::Action) -> Self {
            let mut v = self.actions.unwrap_or_default();
            v.push(input);
            self.actions = Some(v);
            self
        }
        /// <p>The actions initiated by this trigger.</p>
        pub fn set_actions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Action>>,
        ) -> Self {
            self.actions = input;
            self
        }
        /// <p>The predicate of this trigger, which defines when it will fire.</p>
        pub fn predicate(mut self, input: crate::model::Predicate) -> Self {
            self.predicate = Some(input);
            self
        }
        /// <p>The predicate of this trigger, which defines when it will fire.</p>
        pub fn set_predicate(
            mut self,
            input: std::option::Option<crate::model::Predicate>,
        ) -> Self {
            self.predicate = input;
            self
        }
        /// <p>Batch condition that must be met (specified number of events received or batch time window expired) before EventBridge event trigger fires.</p>
        pub fn event_batching_condition(
            mut self,
            input: crate::model::EventBatchingCondition,
        ) -> Self {
            self.event_batching_condition = Some(input);
            self
        }
        /// <p>Batch condition that must be met (specified number of events received or batch time window expired) before EventBridge event trigger fires.</p>
        pub fn set_event_batching_condition(
            mut self,
            input: std::option::Option<crate::model::EventBatchingCondition>,
        ) -> Self {
            self.event_batching_condition = input;
            self
        }
        /// Consumes the builder and constructs a [`TriggerUpdate`](crate::model::TriggerUpdate).
        pub fn build(self) -> crate::model::TriggerUpdate {
            crate::model::TriggerUpdate {
                name: self.name,
                description: self.description,
                schedule: self.schedule,
                actions: self.actions,
                predicate: self.predicate,
                event_batching_condition: self.event_batching_condition,
            }
        }
    }
}
impl TriggerUpdate {
    /// Creates a new builder-style object to manufacture [`TriggerUpdate`](crate::model::TriggerUpdate).
    pub fn builder() -> crate::model::trigger_update::Builder {
        crate::model::trigger_update::Builder::default()
    }
}

/// <p>A structure used to define a table.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TableInput {
    /// <p>The table name. For Hive compatibility, this is folded to lowercase when it is stored.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>A description of the table.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The table owner.</p>
    #[doc(hidden)]
    pub owner: std::option::Option<std::string::String>,
    /// <p>The last time that the table was accessed.</p>
    #[doc(hidden)]
    pub last_access_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The last time that column statistics were computed for this table.</p>
    #[doc(hidden)]
    pub last_analyzed_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The retention time for this table.</p>
    #[doc(hidden)]
    pub retention: i32,
    /// <p>A storage descriptor containing information about the physical storage of this table.</p>
    #[doc(hidden)]
    pub storage_descriptor: std::option::Option<crate::model::StorageDescriptor>,
    /// <p>A list of columns by which the table is partitioned. Only primitive types are supported as partition keys.</p>
    /// <p>When you create a table used by Amazon Athena, and you do not specify any <code>partitionKeys</code>, you must at least set the value of <code>partitionKeys</code> to an empty list. For example:</p>
    /// <p> <code>"PartitionKeys": []</code> </p>
    #[doc(hidden)]
    pub partition_keys: std::option::Option<std::vec::Vec<crate::model::Column>>,
    /// <p>If the table is a view, the original text of the view; otherwise <code>null</code>.</p>
    #[doc(hidden)]
    pub view_original_text: std::option::Option<std::string::String>,
    /// <p>If the table is a view, the expanded text of the view; otherwise <code>null</code>.</p>
    #[doc(hidden)]
    pub view_expanded_text: std::option::Option<std::string::String>,
    /// <p>The type of this table (<code>EXTERNAL_TABLE</code>, <code>VIRTUAL_VIEW</code>, etc.).</p>
    #[doc(hidden)]
    pub table_type: std::option::Option<std::string::String>,
    /// <p>These key-value pairs define properties associated with the table.</p>
    #[doc(hidden)]
    pub parameters:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>A <code>TableIdentifier</code> structure that describes a target table for resource linking.</p>
    #[doc(hidden)]
    pub target_table: std::option::Option<crate::model::TableIdentifier>,
}
impl TableInput {
    /// <p>The table name. For Hive compatibility, this is folded to lowercase when it is stored.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>A description of the table.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The table owner.</p>
    pub fn owner(&self) -> std::option::Option<&str> {
        self.owner.as_deref()
    }
    /// <p>The last time that the table was accessed.</p>
    pub fn last_access_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_access_time.as_ref()
    }
    /// <p>The last time that column statistics were computed for this table.</p>
    pub fn last_analyzed_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_analyzed_time.as_ref()
    }
    /// <p>The retention time for this table.</p>
    pub fn retention(&self) -> i32 {
        self.retention
    }
    /// <p>A storage descriptor containing information about the physical storage of this table.</p>
    pub fn storage_descriptor(&self) -> std::option::Option<&crate::model::StorageDescriptor> {
        self.storage_descriptor.as_ref()
    }
    /// <p>A list of columns by which the table is partitioned. Only primitive types are supported as partition keys.</p>
    /// <p>When you create a table used by Amazon Athena, and you do not specify any <code>partitionKeys</code>, you must at least set the value of <code>partitionKeys</code> to an empty list. For example:</p>
    /// <p> <code>"PartitionKeys": []</code> </p>
    pub fn partition_keys(&self) -> std::option::Option<&[crate::model::Column]> {
        self.partition_keys.as_deref()
    }
    /// <p>If the table is a view, the original text of the view; otherwise <code>null</code>.</p>
    pub fn view_original_text(&self) -> std::option::Option<&str> {
        self.view_original_text.as_deref()
    }
    /// <p>If the table is a view, the expanded text of the view; otherwise <code>null</code>.</p>
    pub fn view_expanded_text(&self) -> std::option::Option<&str> {
        self.view_expanded_text.as_deref()
    }
    /// <p>The type of this table (<code>EXTERNAL_TABLE</code>, <code>VIRTUAL_VIEW</code>, etc.).</p>
    pub fn table_type(&self) -> std::option::Option<&str> {
        self.table_type.as_deref()
    }
    /// <p>These key-value pairs define properties associated with the table.</p>
    pub fn parameters(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.parameters.as_ref()
    }
    /// <p>A <code>TableIdentifier</code> structure that describes a target table for resource linking.</p>
    pub fn target_table(&self) -> std::option::Option<&crate::model::TableIdentifier> {
        self.target_table.as_ref()
    }
}
/// See [`TableInput`](crate::model::TableInput).
pub mod table_input {

    /// A builder for [`TableInput`](crate::model::TableInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) owner: std::option::Option<std::string::String>,
        pub(crate) last_access_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_analyzed_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) retention: std::option::Option<i32>,
        pub(crate) storage_descriptor: std::option::Option<crate::model::StorageDescriptor>,
        pub(crate) partition_keys: std::option::Option<std::vec::Vec<crate::model::Column>>,
        pub(crate) view_original_text: std::option::Option<std::string::String>,
        pub(crate) view_expanded_text: std::option::Option<std::string::String>,
        pub(crate) table_type: std::option::Option<std::string::String>,
        pub(crate) parameters: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) target_table: std::option::Option<crate::model::TableIdentifier>,
    }
    impl Builder {
        /// <p>The table name. For Hive compatibility, this is folded to lowercase when it is stored.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The table name. For Hive compatibility, this is folded to lowercase when it is stored.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>A description of the table.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A description of the table.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The table owner.</p>
        pub fn owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.owner = Some(input.into());
            self
        }
        /// <p>The table owner.</p>
        pub fn set_owner(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.owner = input;
            self
        }
        /// <p>The last time that the table was accessed.</p>
        pub fn last_access_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_access_time = Some(input);
            self
        }
        /// <p>The last time that the table was accessed.</p>
        pub fn set_last_access_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_access_time = input;
            self
        }
        /// <p>The last time that column statistics were computed for this table.</p>
        pub fn last_analyzed_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_analyzed_time = Some(input);
            self
        }
        /// <p>The last time that column statistics were computed for this table.</p>
        pub fn set_last_analyzed_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_analyzed_time = input;
            self
        }
        /// <p>The retention time for this table.</p>
        pub fn retention(mut self, input: i32) -> Self {
            self.retention = Some(input);
            self
        }
        /// <p>The retention time for this table.</p>
        pub fn set_retention(mut self, input: std::option::Option<i32>) -> Self {
            self.retention = input;
            self
        }
        /// <p>A storage descriptor containing information about the physical storage of this table.</p>
        pub fn storage_descriptor(mut self, input: crate::model::StorageDescriptor) -> Self {
            self.storage_descriptor = Some(input);
            self
        }
        /// <p>A storage descriptor containing information about the physical storage of this table.</p>
        pub fn set_storage_descriptor(
            mut self,
            input: std::option::Option<crate::model::StorageDescriptor>,
        ) -> Self {
            self.storage_descriptor = input;
            self
        }
        /// Appends an item to `partition_keys`.
        ///
        /// To override the contents of this collection use [`set_partition_keys`](Self::set_partition_keys).
        ///
        /// <p>A list of columns by which the table is partitioned. Only primitive types are supported as partition keys.</p>
        /// <p>When you create a table used by Amazon Athena, and you do not specify any <code>partitionKeys</code>, you must at least set the value of <code>partitionKeys</code> to an empty list. For example:</p>
        /// <p> <code>"PartitionKeys": []</code> </p>
        pub fn partition_keys(mut self, input: crate::model::Column) -> Self {
            let mut v = self.partition_keys.unwrap_or_default();
            v.push(input);
            self.partition_keys = Some(v);
            self
        }
        /// <p>A list of columns by which the table is partitioned. Only primitive types are supported as partition keys.</p>
        /// <p>When you create a table used by Amazon Athena, and you do not specify any <code>partitionKeys</code>, you must at least set the value of <code>partitionKeys</code> to an empty list. For example:</p>
        /// <p> <code>"PartitionKeys": []</code> </p>
        pub fn set_partition_keys(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Column>>,
        ) -> Self {
            self.partition_keys = input;
            self
        }
        /// <p>If the table is a view, the original text of the view; otherwise <code>null</code>.</p>
        pub fn view_original_text(mut self, input: impl Into<std::string::String>) -> Self {
            self.view_original_text = Some(input.into());
            self
        }
        /// <p>If the table is a view, the original text of the view; otherwise <code>null</code>.</p>
        pub fn set_view_original_text(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.view_original_text = input;
            self
        }
        /// <p>If the table is a view, the expanded text of the view; otherwise <code>null</code>.</p>
        pub fn view_expanded_text(mut self, input: impl Into<std::string::String>) -> Self {
            self.view_expanded_text = Some(input.into());
            self
        }
        /// <p>If the table is a view, the expanded text of the view; otherwise <code>null</code>.</p>
        pub fn set_view_expanded_text(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.view_expanded_text = input;
            self
        }
        /// <p>The type of this table (<code>EXTERNAL_TABLE</code>, <code>VIRTUAL_VIEW</code>, etc.).</p>
        pub fn table_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.table_type = Some(input.into());
            self
        }
        /// <p>The type of this table (<code>EXTERNAL_TABLE</code>, <code>VIRTUAL_VIEW</code>, etc.).</p>
        pub fn set_table_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.table_type = input;
            self
        }
        /// Adds a key-value pair to `parameters`.
        ///
        /// To override the contents of this collection use [`set_parameters`](Self::set_parameters).
        ///
        /// <p>These key-value pairs define properties associated with the table.</p>
        pub fn parameters(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.parameters.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.parameters = Some(hash_map);
            self
        }
        /// <p>These key-value pairs define properties associated with the table.</p>
        pub fn set_parameters(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.parameters = input;
            self
        }
        /// <p>A <code>TableIdentifier</code> structure that describes a target table for resource linking.</p>
        pub fn target_table(mut self, input: crate::model::TableIdentifier) -> Self {
            self.target_table = Some(input);
            self
        }
        /// <p>A <code>TableIdentifier</code> structure that describes a target table for resource linking.</p>
        pub fn set_target_table(
            mut self,
            input: std::option::Option<crate::model::TableIdentifier>,
        ) -> Self {
            self.target_table = input;
            self
        }
        /// Consumes the builder and constructs a [`TableInput`](crate::model::TableInput).
        pub fn build(self) -> crate::model::TableInput {
            crate::model::TableInput {
                name: self.name,
                description: self.description,
                owner: self.owner,
                last_access_time: self.last_access_time,
                last_analyzed_time: self.last_analyzed_time,
                retention: self.retention.unwrap_or_default(),
                storage_descriptor: self.storage_descriptor,
                partition_keys: self.partition_keys,
                view_original_text: self.view_original_text,
                view_expanded_text: self.view_expanded_text,
                table_type: self.table_type,
                parameters: self.parameters,
                target_table: self.target_table,
            }
        }
    }
}
impl TableInput {
    /// Creates a new builder-style object to manufacture [`TableInput`](crate::model::TableInput).
    pub fn builder() -> crate::model::table_input::Builder {
        crate::model::table_input::Builder::default()
    }
}

/// <p>A structure that describes a target table for resource linking.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TableIdentifier {
    /// <p>The ID of the Data Catalog in which the table resides.</p>
    #[doc(hidden)]
    pub catalog_id: std::option::Option<std::string::String>,
    /// <p>The name of the catalog database that contains the target table.</p>
    #[doc(hidden)]
    pub database_name: std::option::Option<std::string::String>,
    /// <p>The name of the target table.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
}
impl TableIdentifier {
    /// <p>The ID of the Data Catalog in which the table resides.</p>
    pub fn catalog_id(&self) -> std::option::Option<&str> {
        self.catalog_id.as_deref()
    }
    /// <p>The name of the catalog database that contains the target table.</p>
    pub fn database_name(&self) -> std::option::Option<&str> {
        self.database_name.as_deref()
    }
    /// <p>The name of the target table.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
}
/// See [`TableIdentifier`](crate::model::TableIdentifier).
pub mod table_identifier {

    /// A builder for [`TableIdentifier`](crate::model::TableIdentifier).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) catalog_id: std::option::Option<std::string::String>,
        pub(crate) database_name: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the Data Catalog in which the table resides.</p>
        pub fn catalog_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.catalog_id = Some(input.into());
            self
        }
        /// <p>The ID of the Data Catalog in which the table resides.</p>
        pub fn set_catalog_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.catalog_id = input;
            self
        }
        /// <p>The name of the catalog database that contains the target table.</p>
        pub fn database_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.database_name = Some(input.into());
            self
        }
        /// <p>The name of the catalog database that contains the target table.</p>
        pub fn set_database_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.database_name = input;
            self
        }
        /// <p>The name of the target table.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the target table.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Consumes the builder and constructs a [`TableIdentifier`](crate::model::TableIdentifier).
        pub fn build(self) -> crate::model::TableIdentifier {
            crate::model::TableIdentifier {
                catalog_id: self.catalog_id,
                database_name: self.database_name,
                name: self.name,
            }
        }
    }
}
impl TableIdentifier {
    /// Creates a new builder-style object to manufacture [`TableIdentifier`](crate::model::TableIdentifier).
    pub fn builder() -> crate::model::table_identifier::Builder {
        crate::model::table_identifier::Builder::default()
    }
}

/// <p>A column in a <code>Table</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Column {
    /// <p>The name of the <code>Column</code>.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The data type of the <code>Column</code>.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<std::string::String>,
    /// <p>A free-form text comment.</p>
    #[doc(hidden)]
    pub comment: std::option::Option<std::string::String>,
    /// <p>These key-value pairs define properties associated with the column.</p>
    #[doc(hidden)]
    pub parameters:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl Column {
    /// <p>The name of the <code>Column</code>.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The data type of the <code>Column</code>.</p>
    pub fn r#type(&self) -> std::option::Option<&str> {
        self.r#type.as_deref()
    }
    /// <p>A free-form text comment.</p>
    pub fn comment(&self) -> std::option::Option<&str> {
        self.comment.as_deref()
    }
    /// <p>These key-value pairs define properties associated with the column.</p>
    pub fn parameters(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.parameters.as_ref()
    }
}
/// See [`Column`](crate::model::Column).
pub mod column {

    /// A builder for [`Column`](crate::model::Column).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) comment: std::option::Option<std::string::String>,
        pub(crate) parameters: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The name of the <code>Column</code>.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the <code>Column</code>.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The data type of the <code>Column</code>.</p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        /// <p>The data type of the <code>Column</code>.</p>
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// <p>A free-form text comment.</p>
        pub fn comment(mut self, input: impl Into<std::string::String>) -> Self {
            self.comment = Some(input.into());
            self
        }
        /// <p>A free-form text comment.</p>
        pub fn set_comment(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.comment = input;
            self
        }
        /// Adds a key-value pair to `parameters`.
        ///
        /// To override the contents of this collection use [`set_parameters`](Self::set_parameters).
        ///
        /// <p>These key-value pairs define properties associated with the column.</p>
        pub fn parameters(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.parameters.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.parameters = Some(hash_map);
            self
        }
        /// <p>These key-value pairs define properties associated with the column.</p>
        pub fn set_parameters(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.parameters = input;
            self
        }
        /// Consumes the builder and constructs a [`Column`](crate::model::Column).
        pub fn build(self) -> crate::model::Column {
            crate::model::Column {
                name: self.name,
                r#type: self.r#type,
                comment: self.comment,
                parameters: self.parameters,
            }
        }
    }
}
impl Column {
    /// Creates a new builder-style object to manufacture [`Column`](crate::model::Column).
    pub fn builder() -> crate::model::column::Builder {
        crate::model::column::Builder::default()
    }
}

/// <p>Describes the physical storage of table data.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct StorageDescriptor {
    /// <p>A list of the <code>Columns</code> in the table.</p>
    #[doc(hidden)]
    pub columns: std::option::Option<std::vec::Vec<crate::model::Column>>,
    /// <p>The physical location of the table. By default, this takes the form of the warehouse location, followed by the database location in the warehouse, followed by the table name.</p>
    #[doc(hidden)]
    pub location: std::option::Option<std::string::String>,
    /// <p>A list of locations that point to the path where a Delta table is located.</p>
    #[doc(hidden)]
    pub additional_locations: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The input format: <code>SequenceFileInputFormat</code> (binary), or <code>TextInputFormat</code>, or a custom format.</p>
    #[doc(hidden)]
    pub input_format: std::option::Option<std::string::String>,
    /// <p>The output format: <code>SequenceFileOutputFormat</code> (binary), or <code>IgnoreKeyTextOutputFormat</code>, or a custom format.</p>
    #[doc(hidden)]
    pub output_format: std::option::Option<std::string::String>,
    /// <p> <code>True</code> if the data in the table is compressed, or <code>False</code> if not.</p>
    #[doc(hidden)]
    pub compressed: bool,
    /// <p>Must be specified if the table contains any dimension columns.</p>
    #[doc(hidden)]
    pub number_of_buckets: i32,
    /// <p>The serialization/deserialization (SerDe) information.</p>
    #[doc(hidden)]
    pub serde_info: std::option::Option<crate::model::SerDeInfo>,
    /// <p>A list of reducer grouping columns, clustering columns, and bucketing columns in the table.</p>
    #[doc(hidden)]
    pub bucket_columns: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A list specifying the sort order of each bucket in the table.</p>
    #[doc(hidden)]
    pub sort_columns: std::option::Option<std::vec::Vec<crate::model::Order>>,
    /// <p>The user-supplied properties in key-value form.</p>
    #[doc(hidden)]
    pub parameters:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The information about values that appear frequently in a column (skewed values).</p>
    #[doc(hidden)]
    pub skewed_info: std::option::Option<crate::model::SkewedInfo>,
    /// <p> <code>True</code> if the table data is stored in subdirectories, or <code>False</code> if not.</p>
    #[doc(hidden)]
    pub stored_as_sub_directories: bool,
    /// <p>An object that references a schema stored in the Glue Schema Registry.</p>
    /// <p>When creating a table, you can pass an empty list of columns for the schema, and instead use a schema reference.</p>
    #[doc(hidden)]
    pub schema_reference: std::option::Option<crate::model::SchemaReference>,
}
impl StorageDescriptor {
    /// <p>A list of the <code>Columns</code> in the table.</p>
    pub fn columns(&self) -> std::option::Option<&[crate::model::Column]> {
        self.columns.as_deref()
    }
    /// <p>The physical location of the table. By default, this takes the form of the warehouse location, followed by the database location in the warehouse, followed by the table name.</p>
    pub fn location(&self) -> std::option::Option<&str> {
        self.location.as_deref()
    }
    /// <p>A list of locations that point to the path where a Delta table is located.</p>
    pub fn additional_locations(&self) -> std::option::Option<&[std::string::String]> {
        self.additional_locations.as_deref()
    }
    /// <p>The input format: <code>SequenceFileInputFormat</code> (binary), or <code>TextInputFormat</code>, or a custom format.</p>
    pub fn input_format(&self) -> std::option::Option<&str> {
        self.input_format.as_deref()
    }
    /// <p>The output format: <code>SequenceFileOutputFormat</code> (binary), or <code>IgnoreKeyTextOutputFormat</code>, or a custom format.</p>
    pub fn output_format(&self) -> std::option::Option<&str> {
        self.output_format.as_deref()
    }
    /// <p> <code>True</code> if the data in the table is compressed, or <code>False</code> if not.</p>
    pub fn compressed(&self) -> bool {
        self.compressed
    }
    /// <p>Must be specified if the table contains any dimension columns.</p>
    pub fn number_of_buckets(&self) -> i32 {
        self.number_of_buckets
    }
    /// <p>The serialization/deserialization (SerDe) information.</p>
    pub fn serde_info(&self) -> std::option::Option<&crate::model::SerDeInfo> {
        self.serde_info.as_ref()
    }
    /// <p>A list of reducer grouping columns, clustering columns, and bucketing columns in the table.</p>
    pub fn bucket_columns(&self) -> std::option::Option<&[std::string::String]> {
        self.bucket_columns.as_deref()
    }
    /// <p>A list specifying the sort order of each bucket in the table.</p>
    pub fn sort_columns(&self) -> std::option::Option<&[crate::model::Order]> {
        self.sort_columns.as_deref()
    }
    /// <p>The user-supplied properties in key-value form.</p>
    pub fn parameters(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.parameters.as_ref()
    }
    /// <p>The information about values that appear frequently in a column (skewed values).</p>
    pub fn skewed_info(&self) -> std::option::Option<&crate::model::SkewedInfo> {
        self.skewed_info.as_ref()
    }
    /// <p> <code>True</code> if the table data is stored in subdirectories, or <code>False</code> if not.</p>
    pub fn stored_as_sub_directories(&self) -> bool {
        self.stored_as_sub_directories
    }
    /// <p>An object that references a schema stored in the Glue Schema Registry.</p>
    /// <p>When creating a table, you can pass an empty list of columns for the schema, and instead use a schema reference.</p>
    pub fn schema_reference(&self) -> std::option::Option<&crate::model::SchemaReference> {
        self.schema_reference.as_ref()
    }
}
/// See [`StorageDescriptor`](crate::model::StorageDescriptor).
pub mod storage_descriptor {

    /// A builder for [`StorageDescriptor`](crate::model::StorageDescriptor).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) columns: std::option::Option<std::vec::Vec<crate::model::Column>>,
        pub(crate) location: std::option::Option<std::string::String>,
        pub(crate) additional_locations: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) input_format: std::option::Option<std::string::String>,
        pub(crate) output_format: std::option::Option<std::string::String>,
        pub(crate) compressed: std::option::Option<bool>,
        pub(crate) number_of_buckets: std::option::Option<i32>,
        pub(crate) serde_info: std::option::Option<crate::model::SerDeInfo>,
        pub(crate) bucket_columns: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) sort_columns: std::option::Option<std::vec::Vec<crate::model::Order>>,
        pub(crate) parameters: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) skewed_info: std::option::Option<crate::model::SkewedInfo>,
        pub(crate) stored_as_sub_directories: std::option::Option<bool>,
        pub(crate) schema_reference: std::option::Option<crate::model::SchemaReference>,
    }
    impl Builder {
        /// Appends an item to `columns`.
        ///
        /// To override the contents of this collection use [`set_columns`](Self::set_columns).
        ///
        /// <p>A list of the <code>Columns</code> in the table.</p>
        pub fn columns(mut self, input: crate::model::Column) -> Self {
            let mut v = self.columns.unwrap_or_default();
            v.push(input);
            self.columns = Some(v);
            self
        }
        /// <p>A list of the <code>Columns</code> in the table.</p>
        pub fn set_columns(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Column>>,
        ) -> Self {
            self.columns = input;
            self
        }
        /// <p>The physical location of the table. By default, this takes the form of the warehouse location, followed by the database location in the warehouse, followed by the table name.</p>
        pub fn location(mut self, input: impl Into<std::string::String>) -> Self {
            self.location = Some(input.into());
            self
        }
        /// <p>The physical location of the table. By default, this takes the form of the warehouse location, followed by the database location in the warehouse, followed by the table name.</p>
        pub fn set_location(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.location = input;
            self
        }
        /// Appends an item to `additional_locations`.
        ///
        /// To override the contents of this collection use [`set_additional_locations`](Self::set_additional_locations).
        ///
        /// <p>A list of locations that point to the path where a Delta table is located.</p>
        pub fn additional_locations(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.additional_locations.unwrap_or_default();
            v.push(input.into());
            self.additional_locations = Some(v);
            self
        }
        /// <p>A list of locations that point to the path where a Delta table is located.</p>
        pub fn set_additional_locations(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.additional_locations = input;
            self
        }
        /// <p>The input format: <code>SequenceFileInputFormat</code> (binary), or <code>TextInputFormat</code>, or a custom format.</p>
        pub fn input_format(mut self, input: impl Into<std::string::String>) -> Self {
            self.input_format = Some(input.into());
            self
        }
        /// <p>The input format: <code>SequenceFileInputFormat</code> (binary), or <code>TextInputFormat</code>, or a custom format.</p>
        pub fn set_input_format(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.input_format = input;
            self
        }
        /// <p>The output format: <code>SequenceFileOutputFormat</code> (binary), or <code>IgnoreKeyTextOutputFormat</code>, or a custom format.</p>
        pub fn output_format(mut self, input: impl Into<std::string::String>) -> Self {
            self.output_format = Some(input.into());
            self
        }
        /// <p>The output format: <code>SequenceFileOutputFormat</code> (binary), or <code>IgnoreKeyTextOutputFormat</code>, or a custom format.</p>
        pub fn set_output_format(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.output_format = input;
            self
        }
        /// <p> <code>True</code> if the data in the table is compressed, or <code>False</code> if not.</p>
        pub fn compressed(mut self, input: bool) -> Self {
            self.compressed = Some(input);
            self
        }
        /// <p> <code>True</code> if the data in the table is compressed, or <code>False</code> if not.</p>
        pub fn set_compressed(mut self, input: std::option::Option<bool>) -> Self {
            self.compressed = input;
            self
        }
        /// <p>Must be specified if the table contains any dimension columns.</p>
        pub fn number_of_buckets(mut self, input: i32) -> Self {
            self.number_of_buckets = Some(input);
            self
        }
        /// <p>Must be specified if the table contains any dimension columns.</p>
        pub fn set_number_of_buckets(mut self, input: std::option::Option<i32>) -> Self {
            self.number_of_buckets = input;
            self
        }
        /// <p>The serialization/deserialization (SerDe) information.</p>
        pub fn serde_info(mut self, input: crate::model::SerDeInfo) -> Self {
            self.serde_info = Some(input);
            self
        }
        /// <p>The serialization/deserialization (SerDe) information.</p>
        pub fn set_serde_info(
            mut self,
            input: std::option::Option<crate::model::SerDeInfo>,
        ) -> Self {
            self.serde_info = input;
            self
        }
        /// Appends an item to `bucket_columns`.
        ///
        /// To override the contents of this collection use [`set_bucket_columns`](Self::set_bucket_columns).
        ///
        /// <p>A list of reducer grouping columns, clustering columns, and bucketing columns in the table.</p>
        pub fn bucket_columns(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.bucket_columns.unwrap_or_default();
            v.push(input.into());
            self.bucket_columns = Some(v);
            self
        }
        /// <p>A list of reducer grouping columns, clustering columns, and bucketing columns in the table.</p>
        pub fn set_bucket_columns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.bucket_columns = input;
            self
        }
        /// Appends an item to `sort_columns`.
        ///
        /// To override the contents of this collection use [`set_sort_columns`](Self::set_sort_columns).
        ///
        /// <p>A list specifying the sort order of each bucket in the table.</p>
        pub fn sort_columns(mut self, input: crate::model::Order) -> Self {
            let mut v = self.sort_columns.unwrap_or_default();
            v.push(input);
            self.sort_columns = Some(v);
            self
        }
        /// <p>A list specifying the sort order of each bucket in the table.</p>
        pub fn set_sort_columns(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Order>>,
        ) -> Self {
            self.sort_columns = input;
            self
        }
        /// Adds a key-value pair to `parameters`.
        ///
        /// To override the contents of this collection use [`set_parameters`](Self::set_parameters).
        ///
        /// <p>The user-supplied properties in key-value form.</p>
        pub fn parameters(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.parameters.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.parameters = Some(hash_map);
            self
        }
        /// <p>The user-supplied properties in key-value form.</p>
        pub fn set_parameters(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.parameters = input;
            self
        }
        /// <p>The information about values that appear frequently in a column (skewed values).</p>
        pub fn skewed_info(mut self, input: crate::model::SkewedInfo) -> Self {
            self.skewed_info = Some(input);
            self
        }
        /// <p>The information about values that appear frequently in a column (skewed values).</p>
        pub fn set_skewed_info(
            mut self,
            input: std::option::Option<crate::model::SkewedInfo>,
        ) -> Self {
            self.skewed_info = input;
            self
        }
        /// <p> <code>True</code> if the table data is stored in subdirectories, or <code>False</code> if not.</p>
        pub fn stored_as_sub_directories(mut self, input: bool) -> Self {
            self.stored_as_sub_directories = Some(input);
            self
        }
        /// <p> <code>True</code> if the table data is stored in subdirectories, or <code>False</code> if not.</p>
        pub fn set_stored_as_sub_directories(mut self, input: std::option::Option<bool>) -> Self {
            self.stored_as_sub_directories = input;
            self
        }
        /// <p>An object that references a schema stored in the Glue Schema Registry.</p>
        /// <p>When creating a table, you can pass an empty list of columns for the schema, and instead use a schema reference.</p>
        pub fn schema_reference(mut self, input: crate::model::SchemaReference) -> Self {
            self.schema_reference = Some(input);
            self
        }
        /// <p>An object that references a schema stored in the Glue Schema Registry.</p>
        /// <p>When creating a table, you can pass an empty list of columns for the schema, and instead use a schema reference.</p>
        pub fn set_schema_reference(
            mut self,
            input: std::option::Option<crate::model::SchemaReference>,
        ) -> Self {
            self.schema_reference = input;
            self
        }
        /// Consumes the builder and constructs a [`StorageDescriptor`](crate::model::StorageDescriptor).
        pub fn build(self) -> crate::model::StorageDescriptor {
            crate::model::StorageDescriptor {
                columns: self.columns,
                location: self.location,
                additional_locations: self.additional_locations,
                input_format: self.input_format,
                output_format: self.output_format,
                compressed: self.compressed.unwrap_or_default(),
                number_of_buckets: self.number_of_buckets.unwrap_or_default(),
                serde_info: self.serde_info,
                bucket_columns: self.bucket_columns,
                sort_columns: self.sort_columns,
                parameters: self.parameters,
                skewed_info: self.skewed_info,
                stored_as_sub_directories: self.stored_as_sub_directories.unwrap_or_default(),
                schema_reference: self.schema_reference,
            }
        }
    }
}
impl StorageDescriptor {
    /// Creates a new builder-style object to manufacture [`StorageDescriptor`](crate::model::StorageDescriptor).
    pub fn builder() -> crate::model::storage_descriptor::Builder {
        crate::model::storage_descriptor::Builder::default()
    }
}

/// <p>An object that references a schema stored in the Glue Schema Registry.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SchemaReference {
    /// <p>A structure that contains schema identity fields. Either this or the <code>SchemaVersionId</code> has to be provided.</p>
    #[doc(hidden)]
    pub schema_id: std::option::Option<crate::model::SchemaId>,
    /// <p>The unique ID assigned to a version of the schema. Either this or the <code>SchemaId</code> has to be provided.</p>
    #[doc(hidden)]
    pub schema_version_id: std::option::Option<std::string::String>,
    /// <p>The version number of the schema.</p>
    #[doc(hidden)]
    pub schema_version_number: std::option::Option<i64>,
}
impl SchemaReference {
    /// <p>A structure that contains schema identity fields. Either this or the <code>SchemaVersionId</code> has to be provided.</p>
    pub fn schema_id(&self) -> std::option::Option<&crate::model::SchemaId> {
        self.schema_id.as_ref()
    }
    /// <p>The unique ID assigned to a version of the schema. Either this or the <code>SchemaId</code> has to be provided.</p>
    pub fn schema_version_id(&self) -> std::option::Option<&str> {
        self.schema_version_id.as_deref()
    }
    /// <p>The version number of the schema.</p>
    pub fn schema_version_number(&self) -> std::option::Option<i64> {
        self.schema_version_number
    }
}
/// See [`SchemaReference`](crate::model::SchemaReference).
pub mod schema_reference {

    /// A builder for [`SchemaReference`](crate::model::SchemaReference).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) schema_id: std::option::Option<crate::model::SchemaId>,
        pub(crate) schema_version_id: std::option::Option<std::string::String>,
        pub(crate) schema_version_number: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>A structure that contains schema identity fields. Either this or the <code>SchemaVersionId</code> has to be provided.</p>
        pub fn schema_id(mut self, input: crate::model::SchemaId) -> Self {
            self.schema_id = Some(input);
            self
        }
        /// <p>A structure that contains schema identity fields. Either this or the <code>SchemaVersionId</code> has to be provided.</p>
        pub fn set_schema_id(mut self, input: std::option::Option<crate::model::SchemaId>) -> Self {
            self.schema_id = input;
            self
        }
        /// <p>The unique ID assigned to a version of the schema. Either this or the <code>SchemaId</code> has to be provided.</p>
        pub fn schema_version_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.schema_version_id = Some(input.into());
            self
        }
        /// <p>The unique ID assigned to a version of the schema. Either this or the <code>SchemaId</code> has to be provided.</p>
        pub fn set_schema_version_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.schema_version_id = input;
            self
        }
        /// <p>The version number of the schema.</p>
        pub fn schema_version_number(mut self, input: i64) -> Self {
            self.schema_version_number = Some(input);
            self
        }
        /// <p>The version number of the schema.</p>
        pub fn set_schema_version_number(mut self, input: std::option::Option<i64>) -> Self {
            self.schema_version_number = input;
            self
        }
        /// Consumes the builder and constructs a [`SchemaReference`](crate::model::SchemaReference).
        pub fn build(self) -> crate::model::SchemaReference {
            crate::model::SchemaReference {
                schema_id: self.schema_id,
                schema_version_id: self.schema_version_id,
                schema_version_number: self.schema_version_number,
            }
        }
    }
}
impl SchemaReference {
    /// Creates a new builder-style object to manufacture [`SchemaReference`](crate::model::SchemaReference).
    pub fn builder() -> crate::model::schema_reference::Builder {
        crate::model::schema_reference::Builder::default()
    }
}

/// <p>The unique ID of the schema in the Glue schema registry.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SchemaId {
    /// <p>The Amazon Resource Name (ARN) of the schema. One of <code>SchemaArn</code> or <code>SchemaName</code> has to be provided.</p>
    #[doc(hidden)]
    pub schema_arn: std::option::Option<std::string::String>,
    /// <p>The name of the schema. One of <code>SchemaArn</code> or <code>SchemaName</code> has to be provided.</p>
    #[doc(hidden)]
    pub schema_name: std::option::Option<std::string::String>,
    /// <p>The name of the schema registry that contains the schema.</p>
    #[doc(hidden)]
    pub registry_name: std::option::Option<std::string::String>,
}
impl SchemaId {
    /// <p>The Amazon Resource Name (ARN) of the schema. One of <code>SchemaArn</code> or <code>SchemaName</code> has to be provided.</p>
    pub fn schema_arn(&self) -> std::option::Option<&str> {
        self.schema_arn.as_deref()
    }
    /// <p>The name of the schema. One of <code>SchemaArn</code> or <code>SchemaName</code> has to be provided.</p>
    pub fn schema_name(&self) -> std::option::Option<&str> {
        self.schema_name.as_deref()
    }
    /// <p>The name of the schema registry that contains the schema.</p>
    pub fn registry_name(&self) -> std::option::Option<&str> {
        self.registry_name.as_deref()
    }
}
/// See [`SchemaId`](crate::model::SchemaId).
pub mod schema_id {

    /// A builder for [`SchemaId`](crate::model::SchemaId).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) schema_arn: std::option::Option<std::string::String>,
        pub(crate) schema_name: std::option::Option<std::string::String>,
        pub(crate) registry_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the schema. One of <code>SchemaArn</code> or <code>SchemaName</code> has to be provided.</p>
        pub fn schema_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.schema_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the schema. One of <code>SchemaArn</code> or <code>SchemaName</code> has to be provided.</p>
        pub fn set_schema_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.schema_arn = input;
            self
        }
        /// <p>The name of the schema. One of <code>SchemaArn</code> or <code>SchemaName</code> has to be provided.</p>
        pub fn schema_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.schema_name = Some(input.into());
            self
        }
        /// <p>The name of the schema. One of <code>SchemaArn</code> or <code>SchemaName</code> has to be provided.</p>
        pub fn set_schema_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.schema_name = input;
            self
        }
        /// <p>The name of the schema registry that contains the schema.</p>
        pub fn registry_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.registry_name = Some(input.into());
            self
        }
        /// <p>The name of the schema registry that contains the schema.</p>
        pub fn set_registry_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.registry_name = input;
            self
        }
        /// Consumes the builder and constructs a [`SchemaId`](crate::model::SchemaId).
        pub fn build(self) -> crate::model::SchemaId {
            crate::model::SchemaId {
                schema_arn: self.schema_arn,
                schema_name: self.schema_name,
                registry_name: self.registry_name,
            }
        }
    }
}
impl SchemaId {
    /// Creates a new builder-style object to manufacture [`SchemaId`](crate::model::SchemaId).
    pub fn builder() -> crate::model::schema_id::Builder {
        crate::model::schema_id::Builder::default()
    }
}

/// <p>Specifies skewed values in a table. Skewed values are those that occur with very high frequency.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SkewedInfo {
    /// <p>A list of names of columns that contain skewed values.</p>
    #[doc(hidden)]
    pub skewed_column_names: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A list of values that appear so frequently as to be considered skewed.</p>
    #[doc(hidden)]
    pub skewed_column_values: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A mapping of skewed values to the columns that contain them.</p>
    #[doc(hidden)]
    pub skewed_column_value_location_maps:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl SkewedInfo {
    /// <p>A list of names of columns that contain skewed values.</p>
    pub fn skewed_column_names(&self) -> std::option::Option<&[std::string::String]> {
        self.skewed_column_names.as_deref()
    }
    /// <p>A list of values that appear so frequently as to be considered skewed.</p>
    pub fn skewed_column_values(&self) -> std::option::Option<&[std::string::String]> {
        self.skewed_column_values.as_deref()
    }
    /// <p>A mapping of skewed values to the columns that contain them.</p>
    pub fn skewed_column_value_location_maps(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.skewed_column_value_location_maps.as_ref()
    }
}
/// See [`SkewedInfo`](crate::model::SkewedInfo).
pub mod skewed_info {

    /// A builder for [`SkewedInfo`](crate::model::SkewedInfo).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) skewed_column_names: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) skewed_column_values: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) skewed_column_value_location_maps: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// Appends an item to `skewed_column_names`.
        ///
        /// To override the contents of this collection use [`set_skewed_column_names`](Self::set_skewed_column_names).
        ///
        /// <p>A list of names of columns that contain skewed values.</p>
        pub fn skewed_column_names(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.skewed_column_names.unwrap_or_default();
            v.push(input.into());
            self.skewed_column_names = Some(v);
            self
        }
        /// <p>A list of names of columns that contain skewed values.</p>
        pub fn set_skewed_column_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.skewed_column_names = input;
            self
        }
        /// Appends an item to `skewed_column_values`.
        ///
        /// To override the contents of this collection use [`set_skewed_column_values`](Self::set_skewed_column_values).
        ///
        /// <p>A list of values that appear so frequently as to be considered skewed.</p>
        pub fn skewed_column_values(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.skewed_column_values.unwrap_or_default();
            v.push(input.into());
            self.skewed_column_values = Some(v);
            self
        }
        /// <p>A list of values that appear so frequently as to be considered skewed.</p>
        pub fn set_skewed_column_values(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.skewed_column_values = input;
            self
        }
        /// Adds a key-value pair to `skewed_column_value_location_maps`.
        ///
        /// To override the contents of this collection use [`set_skewed_column_value_location_maps`](Self::set_skewed_column_value_location_maps).
        ///
        /// <p>A mapping of skewed values to the columns that contain them.</p>
        pub fn skewed_column_value_location_maps(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.skewed_column_value_location_maps.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.skewed_column_value_location_maps = Some(hash_map);
            self
        }
        /// <p>A mapping of skewed values to the columns that contain them.</p>
        pub fn set_skewed_column_value_location_maps(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.skewed_column_value_location_maps = input;
            self
        }
        /// Consumes the builder and constructs a [`SkewedInfo`](crate::model::SkewedInfo).
        pub fn build(self) -> crate::model::SkewedInfo {
            crate::model::SkewedInfo {
                skewed_column_names: self.skewed_column_names,
                skewed_column_values: self.skewed_column_values,
                skewed_column_value_location_maps: self.skewed_column_value_location_maps,
            }
        }
    }
}
impl SkewedInfo {
    /// Creates a new builder-style object to manufacture [`SkewedInfo`](crate::model::SkewedInfo).
    pub fn builder() -> crate::model::skewed_info::Builder {
        crate::model::skewed_info::Builder::default()
    }
}

/// <p>Specifies the sort order of a sorted column.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Order {
    /// <p>The name of the column.</p>
    #[doc(hidden)]
    pub column: std::option::Option<std::string::String>,
    /// <p>Indicates that the column is sorted in ascending order (<code>== 1</code>), or in descending order (<code>==0</code>).</p>
    #[doc(hidden)]
    pub sort_order: i32,
}
impl Order {
    /// <p>The name of the column.</p>
    pub fn column(&self) -> std::option::Option<&str> {
        self.column.as_deref()
    }
    /// <p>Indicates that the column is sorted in ascending order (<code>== 1</code>), or in descending order (<code>==0</code>).</p>
    pub fn sort_order(&self) -> i32 {
        self.sort_order
    }
}
/// See [`Order`](crate::model::Order).
pub mod order {

    /// A builder for [`Order`](crate::model::Order).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) column: std::option::Option<std::string::String>,
        pub(crate) sort_order: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The name of the column.</p>
        pub fn column(mut self, input: impl Into<std::string::String>) -> Self {
            self.column = Some(input.into());
            self
        }
        /// <p>The name of the column.</p>
        pub fn set_column(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.column = input;
            self
        }
        /// <p>Indicates that the column is sorted in ascending order (<code>== 1</code>), or in descending order (<code>==0</code>).</p>
        pub fn sort_order(mut self, input: i32) -> Self {
            self.sort_order = Some(input);
            self
        }
        /// <p>Indicates that the column is sorted in ascending order (<code>== 1</code>), or in descending order (<code>==0</code>).</p>
        pub fn set_sort_order(mut self, input: std::option::Option<i32>) -> Self {
            self.sort_order = input;
            self
        }
        /// Consumes the builder and constructs a [`Order`](crate::model::Order).
        pub fn build(self) -> crate::model::Order {
            crate::model::Order {
                column: self.column,
                sort_order: self.sort_order.unwrap_or_default(),
            }
        }
    }
}
impl Order {
    /// Creates a new builder-style object to manufacture [`Order`](crate::model::Order).
    pub fn builder() -> crate::model::order::Builder {
        crate::model::order::Builder::default()
    }
}

/// <p>Information about a serialization/deserialization program (SerDe) that serves as an extractor and loader.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SerDeInfo {
    /// <p>Name of the SerDe.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>Usually the class that implements the SerDe. An example is <code>org.apache.hadoop.hive.serde2.columnar.ColumnarSerDe</code>.</p>
    #[doc(hidden)]
    pub serialization_library: std::option::Option<std::string::String>,
    /// <p>These key-value pairs define initialization parameters for the SerDe.</p>
    #[doc(hidden)]
    pub parameters:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl SerDeInfo {
    /// <p>Name of the SerDe.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>Usually the class that implements the SerDe. An example is <code>org.apache.hadoop.hive.serde2.columnar.ColumnarSerDe</code>.</p>
    pub fn serialization_library(&self) -> std::option::Option<&str> {
        self.serialization_library.as_deref()
    }
    /// <p>These key-value pairs define initialization parameters for the SerDe.</p>
    pub fn parameters(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.parameters.as_ref()
    }
}
/// See [`SerDeInfo`](crate::model::SerDeInfo).
pub mod ser_de_info {

    /// A builder for [`SerDeInfo`](crate::model::SerDeInfo).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) serialization_library: std::option::Option<std::string::String>,
        pub(crate) parameters: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>Name of the SerDe.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>Name of the SerDe.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>Usually the class that implements the SerDe. An example is <code>org.apache.hadoop.hive.serde2.columnar.ColumnarSerDe</code>.</p>
        pub fn serialization_library(mut self, input: impl Into<std::string::String>) -> Self {
            self.serialization_library = Some(input.into());
            self
        }
        /// <p>Usually the class that implements the SerDe. An example is <code>org.apache.hadoop.hive.serde2.columnar.ColumnarSerDe</code>.</p>
        pub fn set_serialization_library(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.serialization_library = input;
            self
        }
        /// Adds a key-value pair to `parameters`.
        ///
        /// To override the contents of this collection use [`set_parameters`](Self::set_parameters).
        ///
        /// <p>These key-value pairs define initialization parameters for the SerDe.</p>
        pub fn parameters(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.parameters.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.parameters = Some(hash_map);
            self
        }
        /// <p>These key-value pairs define initialization parameters for the SerDe.</p>
        pub fn set_parameters(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.parameters = input;
            self
        }
        /// Consumes the builder and constructs a [`SerDeInfo`](crate::model::SerDeInfo).
        pub fn build(self) -> crate::model::SerDeInfo {
            crate::model::SerDeInfo {
                name: self.name,
                serialization_library: self.serialization_library,
                parameters: self.parameters,
            }
        }
    }
}
impl SerDeInfo {
    /// Creates a new builder-style object to manufacture [`SerDeInfo`](crate::model::SerDeInfo).
    pub fn builder() -> crate::model::ser_de_info::Builder {
        crate::model::ser_de_info::Builder::default()
    }
}

/// When writing a match expression against `SourceControlAuthStrategy`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let sourcecontrolauthstrategy = unimplemented!();
/// match sourcecontrolauthstrategy {
///     SourceControlAuthStrategy::AwsSecretsManager => { /* ... */ },
///     SourceControlAuthStrategy::PersonalAccessToken => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `sourcecontrolauthstrategy` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `SourceControlAuthStrategy::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `SourceControlAuthStrategy::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `SourceControlAuthStrategy::NewFeature` is defined.
/// Specifically, when `sourcecontrolauthstrategy` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `SourceControlAuthStrategy::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SourceControlAuthStrategy {
    #[allow(missing_docs)] // documentation missing in model
    AwsSecretsManager,
    #[allow(missing_docs)] // documentation missing in model
    PersonalAccessToken,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for SourceControlAuthStrategy {
    fn from(s: &str) -> Self {
        match s {
            "AWS_SECRETS_MANAGER" => SourceControlAuthStrategy::AwsSecretsManager,
            "PERSONAL_ACCESS_TOKEN" => SourceControlAuthStrategy::PersonalAccessToken,
            other => SourceControlAuthStrategy::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for SourceControlAuthStrategy {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SourceControlAuthStrategy::from(s))
    }
}
impl SourceControlAuthStrategy {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            SourceControlAuthStrategy::AwsSecretsManager => "AWS_SECRETS_MANAGER",
            SourceControlAuthStrategy::PersonalAccessToken => "PERSONAL_ACCESS_TOKEN",
            SourceControlAuthStrategy::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["AWS_SECRETS_MANAGER", "PERSONAL_ACCESS_TOKEN"]
    }
}
impl AsRef<str> for SourceControlAuthStrategy {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `SourceControlProvider`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let sourcecontrolprovider = unimplemented!();
/// match sourcecontrolprovider {
///     SourceControlProvider::AwsCodeCommit => { /* ... */ },
///     SourceControlProvider::Github => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `sourcecontrolprovider` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `SourceControlProvider::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `SourceControlProvider::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `SourceControlProvider::NewFeature` is defined.
/// Specifically, when `sourcecontrolprovider` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `SourceControlProvider::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SourceControlProvider {
    #[allow(missing_docs)] // documentation missing in model
    AwsCodeCommit,
    #[allow(missing_docs)] // documentation missing in model
    Github,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for SourceControlProvider {
    fn from(s: &str) -> Self {
        match s {
            "AWS_CODE_COMMIT" => SourceControlProvider::AwsCodeCommit,
            "GITHUB" => SourceControlProvider::Github,
            other => {
                SourceControlProvider::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for SourceControlProvider {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SourceControlProvider::from(s))
    }
}
impl SourceControlProvider {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            SourceControlProvider::AwsCodeCommit => "AWS_CODE_COMMIT",
            SourceControlProvider::Github => "GITHUB",
            SourceControlProvider::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["AWS_CODE_COMMIT", "GITHUB"]
    }
}
impl AsRef<str> for SourceControlProvider {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `Compatibility`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let compatibility = unimplemented!();
/// match compatibility {
///     Compatibility::Backward => { /* ... */ },
///     Compatibility::BackwardAll => { /* ... */ },
///     Compatibility::Disabled => { /* ... */ },
///     Compatibility::Forward => { /* ... */ },
///     Compatibility::ForwardAll => { /* ... */ },
///     Compatibility::Full => { /* ... */ },
///     Compatibility::FullAll => { /* ... */ },
///     Compatibility::None => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `compatibility` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `Compatibility::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `Compatibility::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `Compatibility::NewFeature` is defined.
/// Specifically, when `compatibility` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `Compatibility::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Compatibility {
    #[allow(missing_docs)] // documentation missing in model
    Backward,
    #[allow(missing_docs)] // documentation missing in model
    BackwardAll,
    #[allow(missing_docs)] // documentation missing in model
    Disabled,
    #[allow(missing_docs)] // documentation missing in model
    Forward,
    #[allow(missing_docs)] // documentation missing in model
    ForwardAll,
    #[allow(missing_docs)] // documentation missing in model
    Full,
    #[allow(missing_docs)] // documentation missing in model
    FullAll,
    #[allow(missing_docs)] // documentation missing in model
    None,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for Compatibility {
    fn from(s: &str) -> Self {
        match s {
            "BACKWARD" => Compatibility::Backward,
            "BACKWARD_ALL" => Compatibility::BackwardAll,
            "DISABLED" => Compatibility::Disabled,
            "FORWARD" => Compatibility::Forward,
            "FORWARD_ALL" => Compatibility::ForwardAll,
            "FULL" => Compatibility::Full,
            "FULL_ALL" => Compatibility::FullAll,
            "NONE" => Compatibility::None,
            other => Compatibility::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for Compatibility {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(Compatibility::from(s))
    }
}
impl Compatibility {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            Compatibility::Backward => "BACKWARD",
            Compatibility::BackwardAll => "BACKWARD_ALL",
            Compatibility::Disabled => "DISABLED",
            Compatibility::Forward => "FORWARD",
            Compatibility::ForwardAll => "FORWARD_ALL",
            Compatibility::Full => "FULL",
            Compatibility::FullAll => "FULL_ALL",
            Compatibility::None => "NONE",
            Compatibility::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "BACKWARD",
            "BACKWARD_ALL",
            "DISABLED",
            "FORWARD",
            "FORWARD_ALL",
            "FULL",
            "FULL_ALL",
            "NONE",
        ]
    }
}
impl AsRef<str> for Compatibility {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A structure containing the schema version information.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SchemaVersionNumber {
    /// <p>The latest version available for the schema.</p>
    #[doc(hidden)]
    pub latest_version: bool,
    /// <p>The version number of the schema.</p>
    #[doc(hidden)]
    pub version_number: i64,
}
impl SchemaVersionNumber {
    /// <p>The latest version available for the schema.</p>
    pub fn latest_version(&self) -> bool {
        self.latest_version
    }
    /// <p>The version number of the schema.</p>
    pub fn version_number(&self) -> i64 {
        self.version_number
    }
}
/// See [`SchemaVersionNumber`](crate::model::SchemaVersionNumber).
pub mod schema_version_number {

    /// A builder for [`SchemaVersionNumber`](crate::model::SchemaVersionNumber).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) latest_version: std::option::Option<bool>,
        pub(crate) version_number: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>The latest version available for the schema.</p>
        pub fn latest_version(mut self, input: bool) -> Self {
            self.latest_version = Some(input);
            self
        }
        /// <p>The latest version available for the schema.</p>
        pub fn set_latest_version(mut self, input: std::option::Option<bool>) -> Self {
            self.latest_version = input;
            self
        }
        /// <p>The version number of the schema.</p>
        pub fn version_number(mut self, input: i64) -> Self {
            self.version_number = Some(input);
            self
        }
        /// <p>The version number of the schema.</p>
        pub fn set_version_number(mut self, input: std::option::Option<i64>) -> Self {
            self.version_number = input;
            self
        }
        /// Consumes the builder and constructs a [`SchemaVersionNumber`](crate::model::SchemaVersionNumber).
        pub fn build(self) -> crate::model::SchemaVersionNumber {
            crate::model::SchemaVersionNumber {
                latest_version: self.latest_version.unwrap_or_default(),
                version_number: self.version_number.unwrap_or_default(),
            }
        }
    }
}
impl SchemaVersionNumber {
    /// Creates a new builder-style object to manufacture [`SchemaVersionNumber`](crate::model::SchemaVersionNumber).
    pub fn builder() -> crate::model::schema_version_number::Builder {
        crate::model::schema_version_number::Builder::default()
    }
}

/// <p>A wrapper structure that may contain the registry name and Amazon Resource Name (ARN).</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RegistryId {
    /// <p>Name of the registry. Used only for lookup. One of <code>RegistryArn</code> or <code>RegistryName</code> has to be provided. </p>
    #[doc(hidden)]
    pub registry_name: std::option::Option<std::string::String>,
    /// <p>Arn of the registry to be updated. One of <code>RegistryArn</code> or <code>RegistryName</code> has to be provided.</p>
    #[doc(hidden)]
    pub registry_arn: std::option::Option<std::string::String>,
}
impl RegistryId {
    /// <p>Name of the registry. Used only for lookup. One of <code>RegistryArn</code> or <code>RegistryName</code> has to be provided. </p>
    pub fn registry_name(&self) -> std::option::Option<&str> {
        self.registry_name.as_deref()
    }
    /// <p>Arn of the registry to be updated. One of <code>RegistryArn</code> or <code>RegistryName</code> has to be provided.</p>
    pub fn registry_arn(&self) -> std::option::Option<&str> {
        self.registry_arn.as_deref()
    }
}
/// See [`RegistryId`](crate::model::RegistryId).
pub mod registry_id {

    /// A builder for [`RegistryId`](crate::model::RegistryId).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) registry_name: std::option::Option<std::string::String>,
        pub(crate) registry_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Name of the registry. Used only for lookup. One of <code>RegistryArn</code> or <code>RegistryName</code> has to be provided. </p>
        pub fn registry_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.registry_name = Some(input.into());
            self
        }
        /// <p>Name of the registry. Used only for lookup. One of <code>RegistryArn</code> or <code>RegistryName</code> has to be provided. </p>
        pub fn set_registry_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.registry_name = input;
            self
        }
        /// <p>Arn of the registry to be updated. One of <code>RegistryArn</code> or <code>RegistryName</code> has to be provided.</p>
        pub fn registry_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.registry_arn = Some(input.into());
            self
        }
        /// <p>Arn of the registry to be updated. One of <code>RegistryArn</code> or <code>RegistryName</code> has to be provided.</p>
        pub fn set_registry_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.registry_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`RegistryId`](crate::model::RegistryId).
        pub fn build(self) -> crate::model::RegistryId {
            crate::model::RegistryId {
                registry_name: self.registry_name,
                registry_arn: self.registry_arn,
            }
        }
    }
}
impl RegistryId {
    /// Creates a new builder-style object to manufacture [`RegistryId`](crate::model::RegistryId).
    pub fn builder() -> crate::model::registry_id::Builder {
        crate::model::registry_id::Builder::default()
    }
}

/// <p>The structure used to create and update a partition.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PartitionInput {
    /// <p>The values of the partition. Although this parameter is not required by the SDK, you must specify this parameter for a valid input.</p>
    /// <p>The values for the keys for the new partition must be passed as an array of String objects that must be ordered in the same order as the partition keys appearing in the Amazon S3 prefix. Otherwise Glue will add the values to the wrong keys.</p>
    #[doc(hidden)]
    pub values: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The last time at which the partition was accessed.</p>
    #[doc(hidden)]
    pub last_access_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Provides information about the physical location where the partition is stored.</p>
    #[doc(hidden)]
    pub storage_descriptor: std::option::Option<crate::model::StorageDescriptor>,
    /// <p>These key-value pairs define partition parameters.</p>
    #[doc(hidden)]
    pub parameters:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The last time at which column statistics were computed for this partition.</p>
    #[doc(hidden)]
    pub last_analyzed_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl PartitionInput {
    /// <p>The values of the partition. Although this parameter is not required by the SDK, you must specify this parameter for a valid input.</p>
    /// <p>The values for the keys for the new partition must be passed as an array of String objects that must be ordered in the same order as the partition keys appearing in the Amazon S3 prefix. Otherwise Glue will add the values to the wrong keys.</p>
    pub fn values(&self) -> std::option::Option<&[std::string::String]> {
        self.values.as_deref()
    }
    /// <p>The last time at which the partition was accessed.</p>
    pub fn last_access_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_access_time.as_ref()
    }
    /// <p>Provides information about the physical location where the partition is stored.</p>
    pub fn storage_descriptor(&self) -> std::option::Option<&crate::model::StorageDescriptor> {
        self.storage_descriptor.as_ref()
    }
    /// <p>These key-value pairs define partition parameters.</p>
    pub fn parameters(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.parameters.as_ref()
    }
    /// <p>The last time at which column statistics were computed for this partition.</p>
    pub fn last_analyzed_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_analyzed_time.as_ref()
    }
}
/// See [`PartitionInput`](crate::model::PartitionInput).
pub mod partition_input {

    /// A builder for [`PartitionInput`](crate::model::PartitionInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) values: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) last_access_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) storage_descriptor: std::option::Option<crate::model::StorageDescriptor>,
        pub(crate) parameters: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) last_analyzed_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// Appends an item to `values`.
        ///
        /// To override the contents of this collection use [`set_values`](Self::set_values).
        ///
        /// <p>The values of the partition. Although this parameter is not required by the SDK, you must specify this parameter for a valid input.</p>
        /// <p>The values for the keys for the new partition must be passed as an array of String objects that must be ordered in the same order as the partition keys appearing in the Amazon S3 prefix. Otherwise Glue will add the values to the wrong keys.</p>
        pub fn values(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.values.unwrap_or_default();
            v.push(input.into());
            self.values = Some(v);
            self
        }
        /// <p>The values of the partition. Although this parameter is not required by the SDK, you must specify this parameter for a valid input.</p>
        /// <p>The values for the keys for the new partition must be passed as an array of String objects that must be ordered in the same order as the partition keys appearing in the Amazon S3 prefix. Otherwise Glue will add the values to the wrong keys.</p>
        pub fn set_values(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.values = input;
            self
        }
        /// <p>The last time at which the partition was accessed.</p>
        pub fn last_access_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_access_time = Some(input);
            self
        }
        /// <p>The last time at which the partition was accessed.</p>
        pub fn set_last_access_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_access_time = input;
            self
        }
        /// <p>Provides information about the physical location where the partition is stored.</p>
        pub fn storage_descriptor(mut self, input: crate::model::StorageDescriptor) -> Self {
            self.storage_descriptor = Some(input);
            self
        }
        /// <p>Provides information about the physical location where the partition is stored.</p>
        pub fn set_storage_descriptor(
            mut self,
            input: std::option::Option<crate::model::StorageDescriptor>,
        ) -> Self {
            self.storage_descriptor = input;
            self
        }
        /// Adds a key-value pair to `parameters`.
        ///
        /// To override the contents of this collection use [`set_parameters`](Self::set_parameters).
        ///
        /// <p>These key-value pairs define partition parameters.</p>
        pub fn parameters(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.parameters.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.parameters = Some(hash_map);
            self
        }
        /// <p>These key-value pairs define partition parameters.</p>
        pub fn set_parameters(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.parameters = input;
            self
        }
        /// <p>The last time at which column statistics were computed for this partition.</p>
        pub fn last_analyzed_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_analyzed_time = Some(input);
            self
        }
        /// <p>The last time at which column statistics were computed for this partition.</p>
        pub fn set_last_analyzed_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_analyzed_time = input;
            self
        }
        /// Consumes the builder and constructs a [`PartitionInput`](crate::model::PartitionInput).
        pub fn build(self) -> crate::model::PartitionInput {
            crate::model::PartitionInput {
                values: self.values,
                last_access_time: self.last_access_time,
                storage_descriptor: self.storage_descriptor,
                parameters: self.parameters,
                last_analyzed_time: self.last_analyzed_time,
            }
        }
    }
}
impl PartitionInput {
    /// Creates a new builder-style object to manufacture [`PartitionInput`](crate::model::PartitionInput).
    pub fn builder() -> crate::model::partition_input::Builder {
        crate::model::partition_input::Builder::default()
    }
}

/// When writing a match expression against `WorkerType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let workertype = unimplemented!();
/// match workertype {
///     WorkerType::G025X => { /* ... */ },
///     WorkerType::G1X => { /* ... */ },
///     WorkerType::G2X => { /* ... */ },
///     WorkerType::Standard => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `workertype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `WorkerType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `WorkerType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `WorkerType::NewFeature` is defined.
/// Specifically, when `workertype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `WorkerType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum WorkerType {
    #[allow(missing_docs)] // documentation missing in model
    G025X,
    #[allow(missing_docs)] // documentation missing in model
    G1X,
    #[allow(missing_docs)] // documentation missing in model
    G2X,
    #[allow(missing_docs)] // documentation missing in model
    Standard,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for WorkerType {
    fn from(s: &str) -> Self {
        match s {
            "G.025X" => WorkerType::G025X,
            "G.1X" => WorkerType::G1X,
            "G.2X" => WorkerType::G2X,
            "Standard" => WorkerType::Standard,
            other => WorkerType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for WorkerType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(WorkerType::from(s))
    }
}
impl WorkerType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            WorkerType::G025X => "G.025X",
            WorkerType::G1X => "G.1X",
            WorkerType::G2X => "G.2X",
            WorkerType::Standard => "Standard",
            WorkerType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["G.025X", "G.1X", "G.2X", "Standard"]
    }
}
impl AsRef<str> for WorkerType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The algorithm-specific parameters that are associated with the machine learning transform.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TransformParameters {
    /// <p>The type of machine learning transform.</p>
    /// <p>For information about the types of machine learning transforms, see <a href="https://docs.aws.amazon.com/glue/latest/dg/add-job-machine-learning-transform.html">Creating Machine Learning Transforms</a>.</p>
    #[doc(hidden)]
    pub transform_type: std::option::Option<crate::model::TransformType>,
    /// <p>The parameters for the find matches algorithm.</p>
    #[doc(hidden)]
    pub find_matches_parameters: std::option::Option<crate::model::FindMatchesParameters>,
}
impl TransformParameters {
    /// <p>The type of machine learning transform.</p>
    /// <p>For information about the types of machine learning transforms, see <a href="https://docs.aws.amazon.com/glue/latest/dg/add-job-machine-learning-transform.html">Creating Machine Learning Transforms</a>.</p>
    pub fn transform_type(&self) -> std::option::Option<&crate::model::TransformType> {
        self.transform_type.as_ref()
    }
    /// <p>The parameters for the find matches algorithm.</p>
    pub fn find_matches_parameters(
        &self,
    ) -> std::option::Option<&crate::model::FindMatchesParameters> {
        self.find_matches_parameters.as_ref()
    }
}
/// See [`TransformParameters`](crate::model::TransformParameters).
pub mod transform_parameters {

    /// A builder for [`TransformParameters`](crate::model::TransformParameters).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) transform_type: std::option::Option<crate::model::TransformType>,
        pub(crate) find_matches_parameters:
            std::option::Option<crate::model::FindMatchesParameters>,
    }
    impl Builder {
        /// <p>The type of machine learning transform.</p>
        /// <p>For information about the types of machine learning transforms, see <a href="https://docs.aws.amazon.com/glue/latest/dg/add-job-machine-learning-transform.html">Creating Machine Learning Transforms</a>.</p>
        pub fn transform_type(mut self, input: crate::model::TransformType) -> Self {
            self.transform_type = Some(input);
            self
        }
        /// <p>The type of machine learning transform.</p>
        /// <p>For information about the types of machine learning transforms, see <a href="https://docs.aws.amazon.com/glue/latest/dg/add-job-machine-learning-transform.html">Creating Machine Learning Transforms</a>.</p>
        pub fn set_transform_type(
            mut self,
            input: std::option::Option<crate::model::TransformType>,
        ) -> Self {
            self.transform_type = input;
            self
        }
        /// <p>The parameters for the find matches algorithm.</p>
        pub fn find_matches_parameters(
            mut self,
            input: crate::model::FindMatchesParameters,
        ) -> Self {
            self.find_matches_parameters = Some(input);
            self
        }
        /// <p>The parameters for the find matches algorithm.</p>
        pub fn set_find_matches_parameters(
            mut self,
            input: std::option::Option<crate::model::FindMatchesParameters>,
        ) -> Self {
            self.find_matches_parameters = input;
            self
        }
        /// Consumes the builder and constructs a [`TransformParameters`](crate::model::TransformParameters).
        pub fn build(self) -> crate::model::TransformParameters {
            crate::model::TransformParameters {
                transform_type: self.transform_type,
                find_matches_parameters: self.find_matches_parameters,
            }
        }
    }
}
impl TransformParameters {
    /// Creates a new builder-style object to manufacture [`TransformParameters`](crate::model::TransformParameters).
    pub fn builder() -> crate::model::transform_parameters::Builder {
        crate::model::transform_parameters::Builder::default()
    }
}

/// <p>The parameters to configure the find matches transform.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FindMatchesParameters {
    /// <p>The name of a column that uniquely identifies rows in the source table. Used to help identify matching records.</p>
    #[doc(hidden)]
    pub primary_key_column_name: std::option::Option<std::string::String>,
    /// <p>The value selected when tuning your transform for a balance between precision and recall. A value of 0.5 means no preference; a value of 1.0 means a bias purely for precision, and a value of 0.0 means a bias for recall. Because this is a tradeoff, choosing values close to 1.0 means very low recall, and choosing values close to 0.0 results in very low precision.</p>
    /// <p>The precision metric indicates how often your model is correct when it predicts a match. </p>
    /// <p>The recall metric indicates that for an actual match, how often your model predicts the match.</p>
    #[doc(hidden)]
    pub precision_recall_tradeoff: std::option::Option<f64>,
    /// <p>The value that is selected when tuning your transform for a balance between accuracy and cost. A value of 0.5 means that the system balances accuracy and cost concerns. A value of 1.0 means a bias purely for accuracy, which typically results in a higher cost, sometimes substantially higher. A value of 0.0 means a bias purely for cost, which results in a less accurate <code>FindMatches</code> transform, sometimes with unacceptable accuracy.</p>
    /// <p>Accuracy measures how well the transform finds true positives and true negatives. Increasing accuracy requires more machine resources and cost. But it also results in increased recall. </p>
    /// <p>Cost measures how many compute resources, and thus money, are consumed to run the transform.</p>
    #[doc(hidden)]
    pub accuracy_cost_tradeoff: std::option::Option<f64>,
    /// <p>The value to switch on or off to force the output to match the provided labels from users. If the value is <code>True</code>, the <code>find matches</code> transform forces the output to match the provided labels. The results override the normal conflation results. If the value is <code>False</code>, the <code>find matches</code> transform does not ensure all the labels provided are respected, and the results rely on the trained model.</p>
    /// <p>Note that setting this value to true may increase the conflation execution time.</p>
    #[doc(hidden)]
    pub enforce_provided_labels: std::option::Option<bool>,
}
impl FindMatchesParameters {
    /// <p>The name of a column that uniquely identifies rows in the source table. Used to help identify matching records.</p>
    pub fn primary_key_column_name(&self) -> std::option::Option<&str> {
        self.primary_key_column_name.as_deref()
    }
    /// <p>The value selected when tuning your transform for a balance between precision and recall. A value of 0.5 means no preference; a value of 1.0 means a bias purely for precision, and a value of 0.0 means a bias for recall. Because this is a tradeoff, choosing values close to 1.0 means very low recall, and choosing values close to 0.0 results in very low precision.</p>
    /// <p>The precision metric indicates how often your model is correct when it predicts a match. </p>
    /// <p>The recall metric indicates that for an actual match, how often your model predicts the match.</p>
    pub fn precision_recall_tradeoff(&self) -> std::option::Option<f64> {
        self.precision_recall_tradeoff
    }
    /// <p>The value that is selected when tuning your transform for a balance between accuracy and cost. A value of 0.5 means that the system balances accuracy and cost concerns. A value of 1.0 means a bias purely for accuracy, which typically results in a higher cost, sometimes substantially higher. A value of 0.0 means a bias purely for cost, which results in a less accurate <code>FindMatches</code> transform, sometimes with unacceptable accuracy.</p>
    /// <p>Accuracy measures how well the transform finds true positives and true negatives. Increasing accuracy requires more machine resources and cost. But it also results in increased recall. </p>
    /// <p>Cost measures how many compute resources, and thus money, are consumed to run the transform.</p>
    pub fn accuracy_cost_tradeoff(&self) -> std::option::Option<f64> {
        self.accuracy_cost_tradeoff
    }
    /// <p>The value to switch on or off to force the output to match the provided labels from users. If the value is <code>True</code>, the <code>find matches</code> transform forces the output to match the provided labels. The results override the normal conflation results. If the value is <code>False</code>, the <code>find matches</code> transform does not ensure all the labels provided are respected, and the results rely on the trained model.</p>
    /// <p>Note that setting this value to true may increase the conflation execution time.</p>
    pub fn enforce_provided_labels(&self) -> std::option::Option<bool> {
        self.enforce_provided_labels
    }
}
/// See [`FindMatchesParameters`](crate::model::FindMatchesParameters).
pub mod find_matches_parameters {

    /// A builder for [`FindMatchesParameters`](crate::model::FindMatchesParameters).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) primary_key_column_name: std::option::Option<std::string::String>,
        pub(crate) precision_recall_tradeoff: std::option::Option<f64>,
        pub(crate) accuracy_cost_tradeoff: std::option::Option<f64>,
        pub(crate) enforce_provided_labels: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The name of a column that uniquely identifies rows in the source table. Used to help identify matching records.</p>
        pub fn primary_key_column_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.primary_key_column_name = Some(input.into());
            self
        }
        /// <p>The name of a column that uniquely identifies rows in the source table. Used to help identify matching records.</p>
        pub fn set_primary_key_column_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.primary_key_column_name = input;
            self
        }
        /// <p>The value selected when tuning your transform for a balance between precision and recall. A value of 0.5 means no preference; a value of 1.0 means a bias purely for precision, and a value of 0.0 means a bias for recall. Because this is a tradeoff, choosing values close to 1.0 means very low recall, and choosing values close to 0.0 results in very low precision.</p>
        /// <p>The precision metric indicates how often your model is correct when it predicts a match. </p>
        /// <p>The recall metric indicates that for an actual match, how often your model predicts the match.</p>
        pub fn precision_recall_tradeoff(mut self, input: f64) -> Self {
            self.precision_recall_tradeoff = Some(input);
            self
        }
        /// <p>The value selected when tuning your transform for a balance between precision and recall. A value of 0.5 means no preference; a value of 1.0 means a bias purely for precision, and a value of 0.0 means a bias for recall. Because this is a tradeoff, choosing values close to 1.0 means very low recall, and choosing values close to 0.0 results in very low precision.</p>
        /// <p>The precision metric indicates how often your model is correct when it predicts a match. </p>
        /// <p>The recall metric indicates that for an actual match, how often your model predicts the match.</p>
        pub fn set_precision_recall_tradeoff(mut self, input: std::option::Option<f64>) -> Self {
            self.precision_recall_tradeoff = input;
            self
        }
        /// <p>The value that is selected when tuning your transform for a balance between accuracy and cost. A value of 0.5 means that the system balances accuracy and cost concerns. A value of 1.0 means a bias purely for accuracy, which typically results in a higher cost, sometimes substantially higher. A value of 0.0 means a bias purely for cost, which results in a less accurate <code>FindMatches</code> transform, sometimes with unacceptable accuracy.</p>
        /// <p>Accuracy measures how well the transform finds true positives and true negatives. Increasing accuracy requires more machine resources and cost. But it also results in increased recall. </p>
        /// <p>Cost measures how many compute resources, and thus money, are consumed to run the transform.</p>
        pub fn accuracy_cost_tradeoff(mut self, input: f64) -> Self {
            self.accuracy_cost_tradeoff = Some(input);
            self
        }
        /// <p>The value that is selected when tuning your transform for a balance between accuracy and cost. A value of 0.5 means that the system balances accuracy and cost concerns. A value of 1.0 means a bias purely for accuracy, which typically results in a higher cost, sometimes substantially higher. A value of 0.0 means a bias purely for cost, which results in a less accurate <code>FindMatches</code> transform, sometimes with unacceptable accuracy.</p>
        /// <p>Accuracy measures how well the transform finds true positives and true negatives. Increasing accuracy requires more machine resources and cost. But it also results in increased recall. </p>
        /// <p>Cost measures how many compute resources, and thus money, are consumed to run the transform.</p>
        pub fn set_accuracy_cost_tradeoff(mut self, input: std::option::Option<f64>) -> Self {
            self.accuracy_cost_tradeoff = input;
            self
        }
        /// <p>The value to switch on or off to force the output to match the provided labels from users. If the value is <code>True</code>, the <code>find matches</code> transform forces the output to match the provided labels. The results override the normal conflation results. If the value is <code>False</code>, the <code>find matches</code> transform does not ensure all the labels provided are respected, and the results rely on the trained model.</p>
        /// <p>Note that setting this value to true may increase the conflation execution time.</p>
        pub fn enforce_provided_labels(mut self, input: bool) -> Self {
            self.enforce_provided_labels = Some(input);
            self
        }
        /// <p>The value to switch on or off to force the output to match the provided labels from users. If the value is <code>True</code>, the <code>find matches</code> transform forces the output to match the provided labels. The results override the normal conflation results. If the value is <code>False</code>, the <code>find matches</code> transform does not ensure all the labels provided are respected, and the results rely on the trained model.</p>
        /// <p>Note that setting this value to true may increase the conflation execution time.</p>
        pub fn set_enforce_provided_labels(mut self, input: std::option::Option<bool>) -> Self {
            self.enforce_provided_labels = input;
            self
        }
        /// Consumes the builder and constructs a [`FindMatchesParameters`](crate::model::FindMatchesParameters).
        pub fn build(self) -> crate::model::FindMatchesParameters {
            crate::model::FindMatchesParameters {
                primary_key_column_name: self.primary_key_column_name,
                precision_recall_tradeoff: self.precision_recall_tradeoff,
                accuracy_cost_tradeoff: self.accuracy_cost_tradeoff,
                enforce_provided_labels: self.enforce_provided_labels,
            }
        }
    }
}
impl FindMatchesParameters {
    /// Creates a new builder-style object to manufacture [`FindMatchesParameters`](crate::model::FindMatchesParameters).
    pub fn builder() -> crate::model::find_matches_parameters::Builder {
        crate::model::find_matches_parameters::Builder::default()
    }
}

/// When writing a match expression against `TransformType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let transformtype = unimplemented!();
/// match transformtype {
///     TransformType::FindMatches => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `transformtype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `TransformType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `TransformType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `TransformType::NewFeature` is defined.
/// Specifically, when `transformtype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `TransformType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TransformType {
    #[allow(missing_docs)] // documentation missing in model
    FindMatches,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for TransformType {
    fn from(s: &str) -> Self {
        match s {
            "FIND_MATCHES" => TransformType::FindMatches,
            other => TransformType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for TransformType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TransformType::from(s))
    }
}
impl TransformType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            TransformType::FindMatches => "FIND_MATCHES",
            TransformType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["FIND_MATCHES"]
    }
}
impl AsRef<str> for TransformType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Specifies information used to update an existing job definition. The previous job definition is completely overwritten by this information.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct JobUpdate {
    /// <p>Description of the job being defined.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>This field is reserved for future use.</p>
    #[doc(hidden)]
    pub log_uri: std::option::Option<std::string::String>,
    /// <p>The name or Amazon Resource Name (ARN) of the IAM role associated with this job (required).</p>
    #[doc(hidden)]
    pub role: std::option::Option<std::string::String>,
    /// <p>An <code>ExecutionProperty</code> specifying the maximum number of concurrent runs allowed for this job.</p>
    #[doc(hidden)]
    pub execution_property: std::option::Option<crate::model::ExecutionProperty>,
    /// <p>The <code>JobCommand</code> that runs this job (required).</p>
    #[doc(hidden)]
    pub command: std::option::Option<crate::model::JobCommand>,
    /// <p>The default arguments for this job.</p>
    /// <p>You can specify arguments here that your own job-execution script consumes, as well as arguments that Glue itself consumes.</p>
    /// <p>For information about how to specify and consume your own Job arguments, see the <a href="https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-python-calling.html">Calling Glue APIs in Python</a> topic in the developer guide.</p>
    /// <p>For information about the key-value pairs that Glue consumes to set up your job, see the <a href="https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-etl-glue-arguments.html">Special Parameters Used by Glue</a> topic in the developer guide.</p>
    #[doc(hidden)]
    pub default_arguments:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>Non-overridable arguments for this job, specified as name-value pairs.</p>
    #[doc(hidden)]
    pub non_overridable_arguments:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The connections used for this job.</p>
    #[doc(hidden)]
    pub connections: std::option::Option<crate::model::ConnectionsList>,
    /// <p>The maximum number of times to retry this job if it fails.</p>
    #[doc(hidden)]
    pub max_retries: i32,
    /// <p>This field is deprecated. Use <code>MaxCapacity</code> instead.</p>
    /// <p>The number of Glue data processing units (DPUs) to allocate to this job. You can allocate a minimum of 2 DPUs; the default is 10. A DPU is a relative measure of processing power that consists of 4 vCPUs of compute capacity and 16 GB of memory. For more information, see the <a href="https://aws.amazon.com/glue/pricing/">Glue pricing page</a>.</p>
    #[deprecated(note = "This property is deprecated, use MaxCapacity instead.")]
    #[doc(hidden)]
    pub allocated_capacity: i32,
    /// <p>The job timeout in minutes. This is the maximum time that a job run can consume resources before it is terminated and enters <code>TIMEOUT</code> status. The default is 2,880 minutes (48 hours).</p>
    #[doc(hidden)]
    pub timeout: std::option::Option<i32>,
    /// <p>For Glue version 1.0 or earlier jobs, using the standard worker type, the number of Glue data processing units (DPUs) that can be allocated when this job runs. A DPU is a relative measure of processing power that consists of 4 vCPUs of compute capacity and 16 GB of memory. For more information, see the <a href="https://aws.amazon.com/glue/pricing/">Glue pricing page</a>.</p>
    /// <p>Do not set <code>Max Capacity</code> if using <code>WorkerType</code> and <code>NumberOfWorkers</code>.</p>
    /// <p>The value that can be allocated for <code>MaxCapacity</code> depends on whether you are running a Python shell job or an Apache Spark ETL job:</p>
    /// <ul>
    /// <li> <p>When you specify a Python shell job (<code>JobCommand.Name</code>="pythonshell"), you can allocate either 0.0625 or 1 DPU. The default is 0.0625 DPU.</p> </li>
    /// <li> <p>When you specify an Apache Spark ETL job (<code>JobCommand.Name</code>="glueetl") or Apache Spark streaming ETL job (<code>JobCommand.Name</code>="gluestreaming"), you can allocate a minimum of 2 DPUs. The default is 10 DPUs. This job type cannot have a fractional DPU allocation.</p> </li>
    /// </ul>
    /// <p>For Glue version 2.0 jobs, you cannot instead specify a <code>Maximum capacity</code>. Instead, you should specify a <code>Worker type</code> and the <code>Number of workers</code>.</p>
    #[doc(hidden)]
    pub max_capacity: std::option::Option<f64>,
    /// <p>The type of predefined worker that is allocated when a job runs. Accepts a value of Standard, G.1X, G.2X, or G.025X.</p>
    /// <ul>
    /// <li> <p>For the <code>Standard</code> worker type, each worker provides 4 vCPU, 16 GB of memory and a 50GB disk, and 2 executors per worker.</p> </li>
    /// <li> <p>For the <code>G.1X</code> worker type, each worker maps to 1 DPU (4 vCPU, 16 GB of memory, 64 GB disk), and provides 1 executor per worker. We recommend this worker type for memory-intensive jobs.</p> </li>
    /// <li> <p>For the <code>G.2X</code> worker type, each worker maps to 2 DPU (8 vCPU, 32 GB of memory, 128 GB disk), and provides 1 executor per worker. We recommend this worker type for memory-intensive jobs.</p> </li>
    /// <li> <p>For the <code>G.025X</code> worker type, each worker maps to 0.25 DPU (2 vCPU, 4 GB of memory, 64 GB disk), and provides 1 executor per worker. We recommend this worker type for low volume streaming jobs. This worker type is only available for Glue version 3.0 streaming jobs.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub worker_type: std::option::Option<crate::model::WorkerType>,
    /// <p>The number of workers of a defined <code>workerType</code> that are allocated when a job runs.</p>
    #[doc(hidden)]
    pub number_of_workers: std::option::Option<i32>,
    /// <p>The name of the <code>SecurityConfiguration</code> structure to be used with this job.</p>
    #[doc(hidden)]
    pub security_configuration: std::option::Option<std::string::String>,
    /// <p>Specifies the configuration properties of a job notification.</p>
    #[doc(hidden)]
    pub notification_property: std::option::Option<crate::model::NotificationProperty>,
    /// <p>Glue version determines the versions of Apache Spark and Python that Glue supports. The Python version indicates the version supported for jobs of type Spark. </p>
    /// <p>For more information about the available Glue versions and corresponding Spark and Python versions, see <a href="https://docs.aws.amazon.com/glue/latest/dg/add-job.html">Glue version</a> in the developer guide.</p>
    #[doc(hidden)]
    pub glue_version: std::option::Option<std::string::String>,
    /// <p>The representation of a directed acyclic graph on which both the Glue Studio visual component and Glue Studio code generation is based.</p>
    #[doc(hidden)]
    pub code_gen_configuration_nodes: std::option::Option<
        std::collections::HashMap<std::string::String, crate::model::CodeGenConfigurationNode>,
    >,
    /// <p>Indicates whether the job is run with a standard or flexible execution class. The standard execution-class is ideal for time-sensitive workloads that require fast job startup and dedicated resources.</p>
    /// <p>The flexible execution class is appropriate for time-insensitive jobs whose start and completion times may vary. </p>
    /// <p>Only jobs with Glue version 3.0 and above and command type <code>glueetl</code> will be allowed to set <code>ExecutionClass</code> to <code>FLEX</code>. The flexible execution class is available for Spark jobs.</p>
    #[doc(hidden)]
    pub execution_class: std::option::Option<crate::model::ExecutionClass>,
    /// <p>The details for a source control configuration for a job, allowing synchronization of job artifacts to or from a remote repository.</p>
    #[doc(hidden)]
    pub source_control_details: std::option::Option<crate::model::SourceControlDetails>,
}
impl JobUpdate {
    /// <p>Description of the job being defined.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>This field is reserved for future use.</p>
    pub fn log_uri(&self) -> std::option::Option<&str> {
        self.log_uri.as_deref()
    }
    /// <p>The name or Amazon Resource Name (ARN) of the IAM role associated with this job (required).</p>
    pub fn role(&self) -> std::option::Option<&str> {
        self.role.as_deref()
    }
    /// <p>An <code>ExecutionProperty</code> specifying the maximum number of concurrent runs allowed for this job.</p>
    pub fn execution_property(&self) -> std::option::Option<&crate::model::ExecutionProperty> {
        self.execution_property.as_ref()
    }
    /// <p>The <code>JobCommand</code> that runs this job (required).</p>
    pub fn command(&self) -> std::option::Option<&crate::model::JobCommand> {
        self.command.as_ref()
    }
    /// <p>The default arguments for this job.</p>
    /// <p>You can specify arguments here that your own job-execution script consumes, as well as arguments that Glue itself consumes.</p>
    /// <p>For information about how to specify and consume your own Job arguments, see the <a href="https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-python-calling.html">Calling Glue APIs in Python</a> topic in the developer guide.</p>
    /// <p>For information about the key-value pairs that Glue consumes to set up your job, see the <a href="https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-etl-glue-arguments.html">Special Parameters Used by Glue</a> topic in the developer guide.</p>
    pub fn default_arguments(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.default_arguments.as_ref()
    }
    /// <p>Non-overridable arguments for this job, specified as name-value pairs.</p>
    pub fn non_overridable_arguments(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.non_overridable_arguments.as_ref()
    }
    /// <p>The connections used for this job.</p>
    pub fn connections(&self) -> std::option::Option<&crate::model::ConnectionsList> {
        self.connections.as_ref()
    }
    /// <p>The maximum number of times to retry this job if it fails.</p>
    pub fn max_retries(&self) -> i32 {
        self.max_retries
    }
    /// <p>This field is deprecated. Use <code>MaxCapacity</code> instead.</p>
    /// <p>The number of Glue data processing units (DPUs) to allocate to this job. You can allocate a minimum of 2 DPUs; the default is 10. A DPU is a relative measure of processing power that consists of 4 vCPUs of compute capacity and 16 GB of memory. For more information, see the <a href="https://aws.amazon.com/glue/pricing/">Glue pricing page</a>.</p>
    #[deprecated(note = "This property is deprecated, use MaxCapacity instead.")]
    pub fn allocated_capacity(&self) -> i32 {
        self.allocated_capacity
    }
    /// <p>The job timeout in minutes. This is the maximum time that a job run can consume resources before it is terminated and enters <code>TIMEOUT</code> status. The default is 2,880 minutes (48 hours).</p>
    pub fn timeout(&self) -> std::option::Option<i32> {
        self.timeout
    }
    /// <p>For Glue version 1.0 or earlier jobs, using the standard worker type, the number of Glue data processing units (DPUs) that can be allocated when this job runs. A DPU is a relative measure of processing power that consists of 4 vCPUs of compute capacity and 16 GB of memory. For more information, see the <a href="https://aws.amazon.com/glue/pricing/">Glue pricing page</a>.</p>
    /// <p>Do not set <code>Max Capacity</code> if using <code>WorkerType</code> and <code>NumberOfWorkers</code>.</p>
    /// <p>The value that can be allocated for <code>MaxCapacity</code> depends on whether you are running a Python shell job or an Apache Spark ETL job:</p>
    /// <ul>
    /// <li> <p>When you specify a Python shell job (<code>JobCommand.Name</code>="pythonshell"), you can allocate either 0.0625 or 1 DPU. The default is 0.0625 DPU.</p> </li>
    /// <li> <p>When you specify an Apache Spark ETL job (<code>JobCommand.Name</code>="glueetl") or Apache Spark streaming ETL job (<code>JobCommand.Name</code>="gluestreaming"), you can allocate a minimum of 2 DPUs. The default is 10 DPUs. This job type cannot have a fractional DPU allocation.</p> </li>
    /// </ul>
    /// <p>For Glue version 2.0 jobs, you cannot instead specify a <code>Maximum capacity</code>. Instead, you should specify a <code>Worker type</code> and the <code>Number of workers</code>.</p>
    pub fn max_capacity(&self) -> std::option::Option<f64> {
        self.max_capacity
    }
    /// <p>The type of predefined worker that is allocated when a job runs. Accepts a value of Standard, G.1X, G.2X, or G.025X.</p>
    /// <ul>
    /// <li> <p>For the <code>Standard</code> worker type, each worker provides 4 vCPU, 16 GB of memory and a 50GB disk, and 2 executors per worker.</p> </li>
    /// <li> <p>For the <code>G.1X</code> worker type, each worker maps to 1 DPU (4 vCPU, 16 GB of memory, 64 GB disk), and provides 1 executor per worker. We recommend this worker type for memory-intensive jobs.</p> </li>
    /// <li> <p>For the <code>G.2X</code> worker type, each worker maps to 2 DPU (8 vCPU, 32 GB of memory, 128 GB disk), and provides 1 executor per worker. We recommend this worker type for memory-intensive jobs.</p> </li>
    /// <li> <p>For the <code>G.025X</code> worker type, each worker maps to 0.25 DPU (2 vCPU, 4 GB of memory, 64 GB disk), and provides 1 executor per worker. We recommend this worker type for low volume streaming jobs. This worker type is only available for Glue version 3.0 streaming jobs.</p> </li>
    /// </ul>
    pub fn worker_type(&self) -> std::option::Option<&crate::model::WorkerType> {
        self.worker_type.as_ref()
    }
    /// <p>The number of workers of a defined <code>workerType</code> that are allocated when a job runs.</p>
    pub fn number_of_workers(&self) -> std::option::Option<i32> {
        self.number_of_workers
    }
    /// <p>The name of the <code>SecurityConfiguration</code> structure to be used with this job.</p>
    pub fn security_configuration(&self) -> std::option::Option<&str> {
        self.security_configuration.as_deref()
    }
    /// <p>Specifies the configuration properties of a job notification.</p>
    pub fn notification_property(
        &self,
    ) -> std::option::Option<&crate::model::NotificationProperty> {
        self.notification_property.as_ref()
    }
    /// <p>Glue version determines the versions of Apache Spark and Python that Glue supports. The Python version indicates the version supported for jobs of type Spark. </p>
    /// <p>For more information about the available Glue versions and corresponding Spark and Python versions, see <a href="https://docs.aws.amazon.com/glue/latest/dg/add-job.html">Glue version</a> in the developer guide.</p>
    pub fn glue_version(&self) -> std::option::Option<&str> {
        self.glue_version.as_deref()
    }
    /// <p>The representation of a directed acyclic graph on which both the Glue Studio visual component and Glue Studio code generation is based.</p>
    pub fn code_gen_configuration_nodes(
        &self,
    ) -> std::option::Option<
        &std::collections::HashMap<std::string::String, crate::model::CodeGenConfigurationNode>,
    > {
        self.code_gen_configuration_nodes.as_ref()
    }
    /// <p>Indicates whether the job is run with a standard or flexible execution class. The standard execution-class is ideal for time-sensitive workloads that require fast job startup and dedicated resources.</p>
    /// <p>The flexible execution class is appropriate for time-insensitive jobs whose start and completion times may vary. </p>
    /// <p>Only jobs with Glue version 3.0 and above and command type <code>glueetl</code> will be allowed to set <code>ExecutionClass</code> to <code>FLEX</code>. The flexible execution class is available for Spark jobs.</p>
    pub fn execution_class(&self) -> std::option::Option<&crate::model::ExecutionClass> {
        self.execution_class.as_ref()
    }
    /// <p>The details for a source control configuration for a job, allowing synchronization of job artifacts to or from a remote repository.</p>
    pub fn source_control_details(
        &self,
    ) -> std::option::Option<&crate::model::SourceControlDetails> {
        self.source_control_details.as_ref()
    }
}
impl std::fmt::Debug for JobUpdate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("JobUpdate");
        formatter.field("description", &self.description);
        formatter.field("log_uri", &self.log_uri);
        formatter.field("role", &self.role);
        formatter.field("execution_property", &self.execution_property);
        formatter.field("command", &self.command);
        formatter.field("default_arguments", &self.default_arguments);
        formatter.field("non_overridable_arguments", &self.non_overridable_arguments);
        formatter.field("connections", &self.connections);
        formatter.field("max_retries", &self.max_retries);
        formatter.field("allocated_capacity", &self.allocated_capacity);
        formatter.field("timeout", &self.timeout);
        formatter.field("max_capacity", &self.max_capacity);
        formatter.field("worker_type", &self.worker_type);
        formatter.field("number_of_workers", &self.number_of_workers);
        formatter.field("security_configuration", &self.security_configuration);
        formatter.field("notification_property", &self.notification_property);
        formatter.field("glue_version", &self.glue_version);
        formatter.field(
            "code_gen_configuration_nodes",
            &"*** Sensitive Data Redacted ***",
        );
        formatter.field("execution_class", &self.execution_class);
        formatter.field("source_control_details", &self.source_control_details);
        formatter.finish()
    }
}
/// See [`JobUpdate`](crate::model::JobUpdate).
pub mod job_update {

    /// A builder for [`JobUpdate`](crate::model::JobUpdate).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) log_uri: std::option::Option<std::string::String>,
        pub(crate) role: std::option::Option<std::string::String>,
        pub(crate) execution_property: std::option::Option<crate::model::ExecutionProperty>,
        pub(crate) command: std::option::Option<crate::model::JobCommand>,
        pub(crate) default_arguments: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) non_overridable_arguments: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) connections: std::option::Option<crate::model::ConnectionsList>,
        pub(crate) max_retries: std::option::Option<i32>,
        pub(crate) allocated_capacity: std::option::Option<i32>,
        pub(crate) timeout: std::option::Option<i32>,
        pub(crate) max_capacity: std::option::Option<f64>,
        pub(crate) worker_type: std::option::Option<crate::model::WorkerType>,
        pub(crate) number_of_workers: std::option::Option<i32>,
        pub(crate) security_configuration: std::option::Option<std::string::String>,
        pub(crate) notification_property: std::option::Option<crate::model::NotificationProperty>,
        pub(crate) glue_version: std::option::Option<std::string::String>,
        pub(crate) code_gen_configuration_nodes: std::option::Option<
            std::collections::HashMap<std::string::String, crate::model::CodeGenConfigurationNode>,
        >,
        pub(crate) execution_class: std::option::Option<crate::model::ExecutionClass>,
        pub(crate) source_control_details: std::option::Option<crate::model::SourceControlDetails>,
    }
    impl Builder {
        /// <p>Description of the job being defined.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>Description of the job being defined.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>This field is reserved for future use.</p>
        pub fn log_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.log_uri = Some(input.into());
            self
        }
        /// <p>This field is reserved for future use.</p>
        pub fn set_log_uri(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.log_uri = input;
            self
        }
        /// <p>The name or Amazon Resource Name (ARN) of the IAM role associated with this job (required).</p>
        pub fn role(mut self, input: impl Into<std::string::String>) -> Self {
            self.role = Some(input.into());
            self
        }
        /// <p>The name or Amazon Resource Name (ARN) of the IAM role associated with this job (required).</p>
        pub fn set_role(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.role = input;
            self
        }
        /// <p>An <code>ExecutionProperty</code> specifying the maximum number of concurrent runs allowed for this job.</p>
        pub fn execution_property(mut self, input: crate::model::ExecutionProperty) -> Self {
            self.execution_property = Some(input);
            self
        }
        /// <p>An <code>ExecutionProperty</code> specifying the maximum number of concurrent runs allowed for this job.</p>
        pub fn set_execution_property(
            mut self,
            input: std::option::Option<crate::model::ExecutionProperty>,
        ) -> Self {
            self.execution_property = input;
            self
        }
        /// <p>The <code>JobCommand</code> that runs this job (required).</p>
        pub fn command(mut self, input: crate::model::JobCommand) -> Self {
            self.command = Some(input);
            self
        }
        /// <p>The <code>JobCommand</code> that runs this job (required).</p>
        pub fn set_command(mut self, input: std::option::Option<crate::model::JobCommand>) -> Self {
            self.command = input;
            self
        }
        /// Adds a key-value pair to `default_arguments`.
        ///
        /// To override the contents of this collection use [`set_default_arguments`](Self::set_default_arguments).
        ///
        /// <p>The default arguments for this job.</p>
        /// <p>You can specify arguments here that your own job-execution script consumes, as well as arguments that Glue itself consumes.</p>
        /// <p>For information about how to specify and consume your own Job arguments, see the <a href="https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-python-calling.html">Calling Glue APIs in Python</a> topic in the developer guide.</p>
        /// <p>For information about the key-value pairs that Glue consumes to set up your job, see the <a href="https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-etl-glue-arguments.html">Special Parameters Used by Glue</a> topic in the developer guide.</p>
        pub fn default_arguments(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.default_arguments.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.default_arguments = Some(hash_map);
            self
        }
        /// <p>The default arguments for this job.</p>
        /// <p>You can specify arguments here that your own job-execution script consumes, as well as arguments that Glue itself consumes.</p>
        /// <p>For information about how to specify and consume your own Job arguments, see the <a href="https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-python-calling.html">Calling Glue APIs in Python</a> topic in the developer guide.</p>
        /// <p>For information about the key-value pairs that Glue consumes to set up your job, see the <a href="https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-etl-glue-arguments.html">Special Parameters Used by Glue</a> topic in the developer guide.</p>
        pub fn set_default_arguments(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.default_arguments = input;
            self
        }
        /// Adds a key-value pair to `non_overridable_arguments`.
        ///
        /// To override the contents of this collection use [`set_non_overridable_arguments`](Self::set_non_overridable_arguments).
        ///
        /// <p>Non-overridable arguments for this job, specified as name-value pairs.</p>
        pub fn non_overridable_arguments(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.non_overridable_arguments.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.non_overridable_arguments = Some(hash_map);
            self
        }
        /// <p>Non-overridable arguments for this job, specified as name-value pairs.</p>
        pub fn set_non_overridable_arguments(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.non_overridable_arguments = input;
            self
        }
        /// <p>The connections used for this job.</p>
        pub fn connections(mut self, input: crate::model::ConnectionsList) -> Self {
            self.connections = Some(input);
            self
        }
        /// <p>The connections used for this job.</p>
        pub fn set_connections(
            mut self,
            input: std::option::Option<crate::model::ConnectionsList>,
        ) -> Self {
            self.connections = input;
            self
        }
        /// <p>The maximum number of times to retry this job if it fails.</p>
        pub fn max_retries(mut self, input: i32) -> Self {
            self.max_retries = Some(input);
            self
        }
        /// <p>The maximum number of times to retry this job if it fails.</p>
        pub fn set_max_retries(mut self, input: std::option::Option<i32>) -> Self {
            self.max_retries = input;
            self
        }
        /// <p>This field is deprecated. Use <code>MaxCapacity</code> instead.</p>
        /// <p>The number of Glue data processing units (DPUs) to allocate to this job. You can allocate a minimum of 2 DPUs; the default is 10. A DPU is a relative measure of processing power that consists of 4 vCPUs of compute capacity and 16 GB of memory. For more information, see the <a href="https://aws.amazon.com/glue/pricing/">Glue pricing page</a>.</p>
        #[deprecated(note = "This property is deprecated, use MaxCapacity instead.")]
        pub fn allocated_capacity(mut self, input: i32) -> Self {
            self.allocated_capacity = Some(input);
            self
        }
        /// <p>This field is deprecated. Use <code>MaxCapacity</code> instead.</p>
        /// <p>The number of Glue data processing units (DPUs) to allocate to this job. You can allocate a minimum of 2 DPUs; the default is 10. A DPU is a relative measure of processing power that consists of 4 vCPUs of compute capacity and 16 GB of memory. For more information, see the <a href="https://aws.amazon.com/glue/pricing/">Glue pricing page</a>.</p>
        #[deprecated(note = "This property is deprecated, use MaxCapacity instead.")]
        pub fn set_allocated_capacity(mut self, input: std::option::Option<i32>) -> Self {
            self.allocated_capacity = input;
            self
        }
        /// <p>The job timeout in minutes. This is the maximum time that a job run can consume resources before it is terminated and enters <code>TIMEOUT</code> status. The default is 2,880 minutes (48 hours).</p>
        pub fn timeout(mut self, input: i32) -> Self {
            self.timeout = Some(input);
            self
        }
        /// <p>The job timeout in minutes. This is the maximum time that a job run can consume resources before it is terminated and enters <code>TIMEOUT</code> status. The default is 2,880 minutes (48 hours).</p>
        pub fn set_timeout(mut self, input: std::option::Option<i32>) -> Self {
            self.timeout = input;
            self
        }
        /// <p>For Glue version 1.0 or earlier jobs, using the standard worker type, the number of Glue data processing units (DPUs) that can be allocated when this job runs. A DPU is a relative measure of processing power that consists of 4 vCPUs of compute capacity and 16 GB of memory. For more information, see the <a href="https://aws.amazon.com/glue/pricing/">Glue pricing page</a>.</p>
        /// <p>Do not set <code>Max Capacity</code> if using <code>WorkerType</code> and <code>NumberOfWorkers</code>.</p>
        /// <p>The value that can be allocated for <code>MaxCapacity</code> depends on whether you are running a Python shell job or an Apache Spark ETL job:</p>
        /// <ul>
        /// <li> <p>When you specify a Python shell job (<code>JobCommand.Name</code>="pythonshell"), you can allocate either 0.0625 or 1 DPU. The default is 0.0625 DPU.</p> </li>
        /// <li> <p>When you specify an Apache Spark ETL job (<code>JobCommand.Name</code>="glueetl") or Apache Spark streaming ETL job (<code>JobCommand.Name</code>="gluestreaming"), you can allocate a minimum of 2 DPUs. The default is 10 DPUs. This job type cannot have a fractional DPU allocation.</p> </li>
        /// </ul>
        /// <p>For Glue version 2.0 jobs, you cannot instead specify a <code>Maximum capacity</code>. Instead, you should specify a <code>Worker type</code> and the <code>Number of workers</code>.</p>
        pub fn max_capacity(mut self, input: f64) -> Self {
            self.max_capacity = Some(input);
            self
        }
        /// <p>For Glue version 1.0 or earlier jobs, using the standard worker type, the number of Glue data processing units (DPUs) that can be allocated when this job runs. A DPU is a relative measure of processing power that consists of 4 vCPUs of compute capacity and 16 GB of memory. For more information, see the <a href="https://aws.amazon.com/glue/pricing/">Glue pricing page</a>.</p>
        /// <p>Do not set <code>Max Capacity</code> if using <code>WorkerType</code> and <code>NumberOfWorkers</code>.</p>
        /// <p>The value that can be allocated for <code>MaxCapacity</code> depends on whether you are running a Python shell job or an Apache Spark ETL job:</p>
        /// <ul>
        /// <li> <p>When you specify a Python shell job (<code>JobCommand.Name</code>="pythonshell"), you can allocate either 0.0625 or 1 DPU. The default is 0.0625 DPU.</p> </li>
        /// <li> <p>When you specify an Apache Spark ETL job (<code>JobCommand.Name</code>="glueetl") or Apache Spark streaming ETL job (<code>JobCommand.Name</code>="gluestreaming"), you can allocate a minimum of 2 DPUs. The default is 10 DPUs. This job type cannot have a fractional DPU allocation.</p> </li>
        /// </ul>
        /// <p>For Glue version 2.0 jobs, you cannot instead specify a <code>Maximum capacity</code>. Instead, you should specify a <code>Worker type</code> and the <code>Number of workers</code>.</p>
        pub fn set_max_capacity(mut self, input: std::option::Option<f64>) -> Self {
            self.max_capacity = input;
            self
        }
        /// <p>The type of predefined worker that is allocated when a job runs. Accepts a value of Standard, G.1X, G.2X, or G.025X.</p>
        /// <ul>
        /// <li> <p>For the <code>Standard</code> worker type, each worker provides 4 vCPU, 16 GB of memory and a 50GB disk, and 2 executors per worker.</p> </li>
        /// <li> <p>For the <code>G.1X</code> worker type, each worker maps to 1 DPU (4 vCPU, 16 GB of memory, 64 GB disk), and provides 1 executor per worker. We recommend this worker type for memory-intensive jobs.</p> </li>
        /// <li> <p>For the <code>G.2X</code> worker type, each worker maps to 2 DPU (8 vCPU, 32 GB of memory, 128 GB disk), and provides 1 executor per worker. We recommend this worker type for memory-intensive jobs.</p> </li>
        /// <li> <p>For the <code>G.025X</code> worker type, each worker maps to 0.25 DPU (2 vCPU, 4 GB of memory, 64 GB disk), and provides 1 executor per worker. We recommend this worker type for low volume streaming jobs. This worker type is only available for Glue version 3.0 streaming jobs.</p> </li>
        /// </ul>
        pub fn worker_type(mut self, input: crate::model::WorkerType) -> Self {
            self.worker_type = Some(input);
            self
        }
        /// <p>The type of predefined worker that is allocated when a job runs. Accepts a value of Standard, G.1X, G.2X, or G.025X.</p>
        /// <ul>
        /// <li> <p>For the <code>Standard</code> worker type, each worker provides 4 vCPU, 16 GB of memory and a 50GB disk, and 2 executors per worker.</p> </li>
        /// <li> <p>For the <code>G.1X</code> worker type, each worker maps to 1 DPU (4 vCPU, 16 GB of memory, 64 GB disk), and provides 1 executor per worker. We recommend this worker type for memory-intensive jobs.</p> </li>
        /// <li> <p>For the <code>G.2X</code> worker type, each worker maps to 2 DPU (8 vCPU, 32 GB of memory, 128 GB disk), and provides 1 executor per worker. We recommend this worker type for memory-intensive jobs.</p> </li>
        /// <li> <p>For the <code>G.025X</code> worker type, each worker maps to 0.25 DPU (2 vCPU, 4 GB of memory, 64 GB disk), and provides 1 executor per worker. We recommend this worker type for low volume streaming jobs. This worker type is only available for Glue version 3.0 streaming jobs.</p> </li>
        /// </ul>
        pub fn set_worker_type(
            mut self,
            input: std::option::Option<crate::model::WorkerType>,
        ) -> Self {
            self.worker_type = input;
            self
        }
        /// <p>The number of workers of a defined <code>workerType</code> that are allocated when a job runs.</p>
        pub fn number_of_workers(mut self, input: i32) -> Self {
            self.number_of_workers = Some(input);
            self
        }
        /// <p>The number of workers of a defined <code>workerType</code> that are allocated when a job runs.</p>
        pub fn set_number_of_workers(mut self, input: std::option::Option<i32>) -> Self {
            self.number_of_workers = input;
            self
        }
        /// <p>The name of the <code>SecurityConfiguration</code> structure to be used with this job.</p>
        pub fn security_configuration(mut self, input: impl Into<std::string::String>) -> Self {
            self.security_configuration = Some(input.into());
            self
        }
        /// <p>The name of the <code>SecurityConfiguration</code> structure to be used with this job.</p>
        pub fn set_security_configuration(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.security_configuration = input;
            self
        }
        /// <p>Specifies the configuration properties of a job notification.</p>
        pub fn notification_property(mut self, input: crate::model::NotificationProperty) -> Self {
            self.notification_property = Some(input);
            self
        }
        /// <p>Specifies the configuration properties of a job notification.</p>
        pub fn set_notification_property(
            mut self,
            input: std::option::Option<crate::model::NotificationProperty>,
        ) -> Self {
            self.notification_property = input;
            self
        }
        /// <p>Glue version determines the versions of Apache Spark and Python that Glue supports. The Python version indicates the version supported for jobs of type Spark. </p>
        /// <p>For more information about the available Glue versions and corresponding Spark and Python versions, see <a href="https://docs.aws.amazon.com/glue/latest/dg/add-job.html">Glue version</a> in the developer guide.</p>
        pub fn glue_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.glue_version = Some(input.into());
            self
        }
        /// <p>Glue version determines the versions of Apache Spark and Python that Glue supports. The Python version indicates the version supported for jobs of type Spark. </p>
        /// <p>For more information about the available Glue versions and corresponding Spark and Python versions, see <a href="https://docs.aws.amazon.com/glue/latest/dg/add-job.html">Glue version</a> in the developer guide.</p>
        pub fn set_glue_version(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.glue_version = input;
            self
        }
        /// Adds a key-value pair to `code_gen_configuration_nodes`.
        ///
        /// To override the contents of this collection use [`set_code_gen_configuration_nodes`](Self::set_code_gen_configuration_nodes).
        ///
        /// <p>The representation of a directed acyclic graph on which both the Glue Studio visual component and Glue Studio code generation is based.</p>
        pub fn code_gen_configuration_nodes(
            mut self,
            k: impl Into<std::string::String>,
            v: crate::model::CodeGenConfigurationNode,
        ) -> Self {
            let mut hash_map = self.code_gen_configuration_nodes.unwrap_or_default();
            hash_map.insert(k.into(), v);
            self.code_gen_configuration_nodes = Some(hash_map);
            self
        }
        /// <p>The representation of a directed acyclic graph on which both the Glue Studio visual component and Glue Studio code generation is based.</p>
        pub fn set_code_gen_configuration_nodes(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<
                    std::string::String,
                    crate::model::CodeGenConfigurationNode,
                >,
            >,
        ) -> Self {
            self.code_gen_configuration_nodes = input;
            self
        }
        /// <p>Indicates whether the job is run with a standard or flexible execution class. The standard execution-class is ideal for time-sensitive workloads that require fast job startup and dedicated resources.</p>
        /// <p>The flexible execution class is appropriate for time-insensitive jobs whose start and completion times may vary. </p>
        /// <p>Only jobs with Glue version 3.0 and above and command type <code>glueetl</code> will be allowed to set <code>ExecutionClass</code> to <code>FLEX</code>. The flexible execution class is available for Spark jobs.</p>
        pub fn execution_class(mut self, input: crate::model::ExecutionClass) -> Self {
            self.execution_class = Some(input);
            self
        }
        /// <p>Indicates whether the job is run with a standard or flexible execution class. The standard execution-class is ideal for time-sensitive workloads that require fast job startup and dedicated resources.</p>
        /// <p>The flexible execution class is appropriate for time-insensitive jobs whose start and completion times may vary. </p>
        /// <p>Only jobs with Glue version 3.0 and above and command type <code>glueetl</code> will be allowed to set <code>ExecutionClass</code> to <code>FLEX</code>. The flexible execution class is available for Spark jobs.</p>
        pub fn set_execution_class(
            mut self,
            input: std::option::Option<crate::model::ExecutionClass>,
        ) -> Self {
            self.execution_class = input;
            self
        }
        /// <p>The details for a source control configuration for a job, allowing synchronization of job artifacts to or from a remote repository.</p>
        pub fn source_control_details(mut self, input: crate::model::SourceControlDetails) -> Self {
            self.source_control_details = Some(input);
            self
        }
        /// <p>The details for a source control configuration for a job, allowing synchronization of job artifacts to or from a remote repository.</p>
        pub fn set_source_control_details(
            mut self,
            input: std::option::Option<crate::model::SourceControlDetails>,
        ) -> Self {
            self.source_control_details = input;
            self
        }
        /// Consumes the builder and constructs a [`JobUpdate`](crate::model::JobUpdate).
        pub fn build(self) -> crate::model::JobUpdate {
            crate::model::JobUpdate {
                description: self.description,
                log_uri: self.log_uri,
                role: self.role,
                execution_property: self.execution_property,
                command: self.command,
                default_arguments: self.default_arguments,
                non_overridable_arguments: self.non_overridable_arguments,
                connections: self.connections,
                max_retries: self.max_retries.unwrap_or_default(),
                allocated_capacity: self.allocated_capacity.unwrap_or_default(),
                timeout: self.timeout,
                max_capacity: self.max_capacity,
                worker_type: self.worker_type,
                number_of_workers: self.number_of_workers,
                security_configuration: self.security_configuration,
                notification_property: self.notification_property,
                glue_version: self.glue_version,
                code_gen_configuration_nodes: self.code_gen_configuration_nodes,
                execution_class: self.execution_class,
                source_control_details: self.source_control_details,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("description", &self.description);
            formatter.field("log_uri", &self.log_uri);
            formatter.field("role", &self.role);
            formatter.field("execution_property", &self.execution_property);
            formatter.field("command", &self.command);
            formatter.field("default_arguments", &self.default_arguments);
            formatter.field("non_overridable_arguments", &self.non_overridable_arguments);
            formatter.field("connections", &self.connections);
            formatter.field("max_retries", &self.max_retries);
            formatter.field("allocated_capacity", &self.allocated_capacity);
            formatter.field("timeout", &self.timeout);
            formatter.field("max_capacity", &self.max_capacity);
            formatter.field("worker_type", &self.worker_type);
            formatter.field("number_of_workers", &self.number_of_workers);
            formatter.field("security_configuration", &self.security_configuration);
            formatter.field("notification_property", &self.notification_property);
            formatter.field("glue_version", &self.glue_version);
            formatter.field(
                "code_gen_configuration_nodes",
                &"*** Sensitive Data Redacted ***",
            );
            formatter.field("execution_class", &self.execution_class);
            formatter.field("source_control_details", &self.source_control_details);
            formatter.finish()
        }
    }
}
impl JobUpdate {
    /// Creates a new builder-style object to manufacture [`JobUpdate`](crate::model::JobUpdate).
    pub fn builder() -> crate::model::job_update::Builder {
        crate::model::job_update::Builder::default()
    }
}

/// <p>The details for a source control configuration for a job, allowing synchronization of job artifacts to or from a remote repository.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SourceControlDetails {
    /// <p>The provider for the remote repository.</p>
    #[doc(hidden)]
    pub provider: std::option::Option<crate::model::SourceControlProvider>,
    /// <p>The name of the remote repository that contains the job artifacts.</p>
    #[doc(hidden)]
    pub repository: std::option::Option<std::string::String>,
    /// <p>The owner of the remote repository that contains the job artifacts.</p>
    #[doc(hidden)]
    pub owner: std::option::Option<std::string::String>,
    /// <p>An optional branch in the remote repository.</p>
    #[doc(hidden)]
    pub branch: std::option::Option<std::string::String>,
    /// <p>An optional folder in the remote repository.</p>
    #[doc(hidden)]
    pub folder: std::option::Option<std::string::String>,
    /// <p>The last commit ID for a commit in the remote repository.</p>
    #[doc(hidden)]
    pub last_commit_id: std::option::Option<std::string::String>,
    /// <p>The type of authentication, which can be an authentication token stored in Amazon Web Services Secrets Manager, or a personal access token.</p>
    #[doc(hidden)]
    pub auth_strategy: std::option::Option<crate::model::SourceControlAuthStrategy>,
    /// <p>The value of an authorization token.</p>
    #[doc(hidden)]
    pub auth_token: std::option::Option<std::string::String>,
}
impl SourceControlDetails {
    /// <p>The provider for the remote repository.</p>
    pub fn provider(&self) -> std::option::Option<&crate::model::SourceControlProvider> {
        self.provider.as_ref()
    }
    /// <p>The name of the remote repository that contains the job artifacts.</p>
    pub fn repository(&self) -> std::option::Option<&str> {
        self.repository.as_deref()
    }
    /// <p>The owner of the remote repository that contains the job artifacts.</p>
    pub fn owner(&self) -> std::option::Option<&str> {
        self.owner.as_deref()
    }
    /// <p>An optional branch in the remote repository.</p>
    pub fn branch(&self) -> std::option::Option<&str> {
        self.branch.as_deref()
    }
    /// <p>An optional folder in the remote repository.</p>
    pub fn folder(&self) -> std::option::Option<&str> {
        self.folder.as_deref()
    }
    /// <p>The last commit ID for a commit in the remote repository.</p>
    pub fn last_commit_id(&self) -> std::option::Option<&str> {
        self.last_commit_id.as_deref()
    }
    /// <p>The type of authentication, which can be an authentication token stored in Amazon Web Services Secrets Manager, or a personal access token.</p>
    pub fn auth_strategy(&self) -> std::option::Option<&crate::model::SourceControlAuthStrategy> {
        self.auth_strategy.as_ref()
    }
    /// <p>The value of an authorization token.</p>
    pub fn auth_token(&self) -> std::option::Option<&str> {
        self.auth_token.as_deref()
    }
}
/// See [`SourceControlDetails`](crate::model::SourceControlDetails).
pub mod source_control_details {

    /// A builder for [`SourceControlDetails`](crate::model::SourceControlDetails).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) provider: std::option::Option<crate::model::SourceControlProvider>,
        pub(crate) repository: std::option::Option<std::string::String>,
        pub(crate) owner: std::option::Option<std::string::String>,
        pub(crate) branch: std::option::Option<std::string::String>,
        pub(crate) folder: std::option::Option<std::string::String>,
        pub(crate) last_commit_id: std::option::Option<std::string::String>,
        pub(crate) auth_strategy: std::option::Option<crate::model::SourceControlAuthStrategy>,
        pub(crate) auth_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The provider for the remote repository.</p>
        pub fn provider(mut self, input: crate::model::SourceControlProvider) -> Self {
            self.provider = Some(input);
            self
        }
        /// <p>The provider for the remote repository.</p>
        pub fn set_provider(
            mut self,
            input: std::option::Option<crate::model::SourceControlProvider>,
        ) -> Self {
            self.provider = input;
            self
        }
        /// <p>The name of the remote repository that contains the job artifacts.</p>
        pub fn repository(mut self, input: impl Into<std::string::String>) -> Self {
            self.repository = Some(input.into());
            self
        }
        /// <p>The name of the remote repository that contains the job artifacts.</p>
        pub fn set_repository(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.repository = input;
            self
        }
        /// <p>The owner of the remote repository that contains the job artifacts.</p>
        pub fn owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.owner = Some(input.into());
            self
        }
        /// <p>The owner of the remote repository that contains the job artifacts.</p>
        pub fn set_owner(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.owner = input;
            self
        }
        /// <p>An optional branch in the remote repository.</p>
        pub fn branch(mut self, input: impl Into<std::string::String>) -> Self {
            self.branch = Some(input.into());
            self
        }
        /// <p>An optional branch in the remote repository.</p>
        pub fn set_branch(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.branch = input;
            self
        }
        /// <p>An optional folder in the remote repository.</p>
        pub fn folder(mut self, input: impl Into<std::string::String>) -> Self {
            self.folder = Some(input.into());
            self
        }
        /// <p>An optional folder in the remote repository.</p>
        pub fn set_folder(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.folder = input;
            self
        }
        /// <p>The last commit ID for a commit in the remote repository.</p>
        pub fn last_commit_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_commit_id = Some(input.into());
            self
        }
        /// <p>The last commit ID for a commit in the remote repository.</p>
        pub fn set_last_commit_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.last_commit_id = input;
            self
        }
        /// <p>The type of authentication, which can be an authentication token stored in Amazon Web Services Secrets Manager, or a personal access token.</p>
        pub fn auth_strategy(mut self, input: crate::model::SourceControlAuthStrategy) -> Self {
            self.auth_strategy = Some(input);
            self
        }
        /// <p>The type of authentication, which can be an authentication token stored in Amazon Web Services Secrets Manager, or a personal access token.</p>
        pub fn set_auth_strategy(
            mut self,
            input: std::option::Option<crate::model::SourceControlAuthStrategy>,
        ) -> Self {
            self.auth_strategy = input;
            self
        }
        /// <p>The value of an authorization token.</p>
        pub fn auth_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.auth_token = Some(input.into());
            self
        }
        /// <p>The value of an authorization token.</p>
        pub fn set_auth_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.auth_token = input;
            self
        }
        /// Consumes the builder and constructs a [`SourceControlDetails`](crate::model::SourceControlDetails).
        pub fn build(self) -> crate::model::SourceControlDetails {
            crate::model::SourceControlDetails {
                provider: self.provider,
                repository: self.repository,
                owner: self.owner,
                branch: self.branch,
                folder: self.folder,
                last_commit_id: self.last_commit_id,
                auth_strategy: self.auth_strategy,
                auth_token: self.auth_token,
            }
        }
    }
}
impl SourceControlDetails {
    /// Creates a new builder-style object to manufacture [`SourceControlDetails`](crate::model::SourceControlDetails).
    pub fn builder() -> crate::model::source_control_details::Builder {
        crate::model::source_control_details::Builder::default()
    }
}

/// When writing a match expression against `ExecutionClass`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let executionclass = unimplemented!();
/// match executionclass {
///     ExecutionClass::Flex => { /* ... */ },
///     ExecutionClass::Standard => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `executionclass` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ExecutionClass::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ExecutionClass::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ExecutionClass::NewFeature` is defined.
/// Specifically, when `executionclass` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ExecutionClass::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ExecutionClass {
    #[allow(missing_docs)] // documentation missing in model
    Flex,
    #[allow(missing_docs)] // documentation missing in model
    Standard,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ExecutionClass {
    fn from(s: &str) -> Self {
        match s {
            "FLEX" => ExecutionClass::Flex,
            "STANDARD" => ExecutionClass::Standard,
            other => ExecutionClass::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ExecutionClass {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ExecutionClass::from(s))
    }
}
impl ExecutionClass {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ExecutionClass::Flex => "FLEX",
            ExecutionClass::Standard => "STANDARD",
            ExecutionClass::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["FLEX", "STANDARD"]
    }
}
impl AsRef<str> for ExecutionClass {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p> <code>CodeGenConfigurationNode</code> enumerates all valid Node types. One and only one of its member variables can be populated.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CodeGenConfigurationNode {
    /// <p>Specifies a connector to an Amazon Athena data source.</p>
    #[doc(hidden)]
    pub athena_connector_source: std::option::Option<crate::model::AthenaConnectorSource>,
    /// <p>Specifies a connector to a JDBC data source.</p>
    #[doc(hidden)]
    pub jdbc_connector_source: std::option::Option<crate::model::JdbcConnectorSource>,
    /// <p>Specifies a connector to an Apache Spark data source.</p>
    #[doc(hidden)]
    pub spark_connector_source: std::option::Option<crate::model::SparkConnectorSource>,
    /// <p>Specifies a data store in the Glue Data Catalog.</p>
    #[doc(hidden)]
    pub catalog_source: std::option::Option<crate::model::CatalogSource>,
    /// <p>Specifies an Amazon Redshift data store.</p>
    #[doc(hidden)]
    pub redshift_source: std::option::Option<crate::model::RedshiftSource>,
    /// <p>Specifies an Amazon S3 data store in the Glue Data Catalog.</p>
    #[doc(hidden)]
    pub s3_catalog_source: std::option::Option<crate::model::S3CatalogSource>,
    /// <p>Specifies a command-separated value (CSV) data store stored in Amazon S3.</p>
    #[doc(hidden)]
    pub s3_csv_source: std::option::Option<crate::model::S3CsvSource>,
    /// <p>Specifies a JSON data store stored in Amazon S3.</p>
    #[doc(hidden)]
    pub s3_json_source: std::option::Option<crate::model::S3JsonSource>,
    /// <p>Specifies an Apache Parquet data store stored in Amazon S3.</p>
    #[doc(hidden)]
    pub s3_parquet_source: std::option::Option<crate::model::S3ParquetSource>,
    /// <p>Specifies a Relational database data source in the Glue Data Catalog.</p>
    #[doc(hidden)]
    pub relational_catalog_source: std::option::Option<crate::model::RelationalCatalogSource>,
    /// <p>Specifies a DynamoDB data source in the Glue Data Catalog.</p>
    #[doc(hidden)]
    pub dynamo_db_catalog_source: std::option::Option<crate::model::DynamoDbCatalogSource>,
    /// <p>Specifies a data target that writes to Amazon S3 in Apache Parquet columnar storage.</p>
    #[doc(hidden)]
    pub jdbc_connector_target: std::option::Option<crate::model::JdbcConnectorTarget>,
    /// <p>Specifies a target that uses an Apache Spark connector.</p>
    #[doc(hidden)]
    pub spark_connector_target: std::option::Option<crate::model::SparkConnectorTarget>,
    /// <p>Specifies a target that uses a Glue Data Catalog table.</p>
    #[doc(hidden)]
    pub catalog_target: std::option::Option<crate::model::BasicCatalogTarget>,
    /// <p>Specifies a target that uses Amazon Redshift.</p>
    #[doc(hidden)]
    pub redshift_target: std::option::Option<crate::model::RedshiftTarget>,
    /// <p>Specifies a data target that writes to Amazon S3 using the Glue Data Catalog.</p>
    #[doc(hidden)]
    pub s3_catalog_target: std::option::Option<crate::model::S3CatalogTarget>,
    /// <p>Specifies a data target that writes to Amazon S3 in Apache Parquet columnar storage.</p>
    #[doc(hidden)]
    pub s3_glue_parquet_target: std::option::Option<crate::model::S3GlueParquetTarget>,
    /// <p>Specifies a data target that writes to Amazon S3.</p>
    #[doc(hidden)]
    pub s3_direct_target: std::option::Option<crate::model::S3DirectTarget>,
    /// <p>Specifies a transform that maps data property keys in the data source to data property keys in the data target. You can rename keys, modify the data types for keys, and choose which keys to drop from the dataset.</p>
    #[doc(hidden)]
    pub apply_mapping: std::option::Option<crate::model::ApplyMapping>,
    /// <p>Specifies a transform that chooses the data property keys that you want to keep.</p>
    #[doc(hidden)]
    pub select_fields: std::option::Option<crate::model::SelectFields>,
    /// <p>Specifies a transform that chooses the data property keys that you want to drop.</p>
    #[doc(hidden)]
    pub drop_fields: std::option::Option<crate::model::DropFields>,
    /// <p>Specifies a transform that renames a single data property key.</p>
    #[doc(hidden)]
    pub rename_field: std::option::Option<crate::model::RenameField>,
    /// <p>Specifies a transform that writes samples of the data to an Amazon S3 bucket.</p>
    #[doc(hidden)]
    pub spigot: std::option::Option<crate::model::Spigot>,
    /// <p>Specifies a transform that joins two datasets into one dataset using a comparison phrase on the specified data property keys. You can use inner, outer, left, right, left semi, and left anti joins.</p>
    #[doc(hidden)]
    pub join: std::option::Option<crate::model::Join>,
    /// <p>Specifies a transform that splits data property keys into two <code>DynamicFrames</code>. The output is a collection of <code>DynamicFrames</code>: one with selected data property keys, and one with the remaining data property keys.</p>
    #[doc(hidden)]
    pub split_fields: std::option::Option<crate::model::SplitFields>,
    /// <p>Specifies a transform that chooses one <code>DynamicFrame</code> from a collection of <code>DynamicFrames</code>. The output is the selected <code>DynamicFrame</code> </p>
    #[doc(hidden)]
    pub select_from_collection: std::option::Option<crate::model::SelectFromCollection>,
    /// <p>Specifies a transform that locates records in the dataset that have missing values and adds a new field with a value determined by imputation. The input data set is used to train the machine learning model that determines what the missing value should be.</p>
    #[doc(hidden)]
    pub fill_missing_values: std::option::Option<crate::model::FillMissingValues>,
    /// <p>Specifies a transform that splits a dataset into two, based on a filter condition.</p>
    #[doc(hidden)]
    pub filter: std::option::Option<crate::model::Filter>,
    /// <p>Specifies a transform that uses custom code you provide to perform the data transformation. The output is a collection of DynamicFrames.</p>
    #[doc(hidden)]
    pub custom_code: std::option::Option<crate::model::CustomCode>,
    /// <p>Specifies a transform where you enter a SQL query using Spark SQL syntax to transform the data. The output is a single <code>DynamicFrame</code>.</p>
    #[doc(hidden)]
    pub spark_sql: std::option::Option<crate::model::SparkSql>,
    /// <p>Specifies a direct Amazon Kinesis data source.</p>
    #[doc(hidden)]
    pub direct_kinesis_source: std::option::Option<crate::model::DirectKinesisSource>,
    /// <p>Specifies an Apache Kafka data store.</p>
    #[doc(hidden)]
    pub direct_kafka_source: std::option::Option<crate::model::DirectKafkaSource>,
    /// <p>Specifies a Kinesis data source in the Glue Data Catalog.</p>
    #[doc(hidden)]
    pub catalog_kinesis_source: std::option::Option<crate::model::CatalogKinesisSource>,
    /// <p>Specifies an Apache Kafka data store in the Data Catalog.</p>
    #[doc(hidden)]
    pub catalog_kafka_source: std::option::Option<crate::model::CatalogKafkaSource>,
    /// <p>Specifies a transform that removes columns from the dataset if all values in the column are 'null'. By default, Glue Studio will recognize null objects, but some values such as empty strings, strings that are "null", -1 integers or other placeholders such as zeros, are not automatically recognized as nulls.</p>
    #[doc(hidden)]
    pub drop_null_fields: std::option::Option<crate::model::DropNullFields>,
    /// <p>Specifies a transform that merges a <code>DynamicFrame</code> with a staging <code>DynamicFrame</code> based on the specified primary keys to identify records. Duplicate records (records with the same primary keys) are not de-duplicated. </p>
    #[doc(hidden)]
    pub merge: std::option::Option<crate::model::Merge>,
    /// <p>Specifies a transform that combines the rows from two or more datasets into a single result.</p>
    #[doc(hidden)]
    pub union: std::option::Option<crate::model::Union>,
    /// <p>Specifies a transform that identifies, removes or masks PII data.</p>
    #[doc(hidden)]
    pub pii_detection: std::option::Option<crate::model::PiiDetection>,
    /// <p>Specifies a transform that groups rows by chosen fields and computes the aggregated value by specified function.</p>
    #[doc(hidden)]
    pub aggregate: std::option::Option<crate::model::Aggregate>,
    /// <p>Specifies a transform that removes rows of repeating data from a data set.</p>
    #[doc(hidden)]
    pub drop_duplicates: std::option::Option<crate::model::DropDuplicates>,
    /// <p>Specifies a data target that writes to a goverened catalog.</p>
    #[doc(hidden)]
    pub governed_catalog_target: std::option::Option<crate::model::GovernedCatalogTarget>,
    /// <p>Specifies a data source in a goverened Data Catalog.</p>
    #[doc(hidden)]
    pub governed_catalog_source: std::option::Option<crate::model::GovernedCatalogSource>,
    /// <p>Specifies a Microsoft SQL server data source in the Glue Data Catalog.</p>
    #[doc(hidden)]
    pub microsoft_sql_server_catalog_source:
        std::option::Option<crate::model::MicrosoftSqlServerCatalogSource>,
    /// <p>Specifies a MySQL data source in the Glue Data Catalog.</p>
    #[doc(hidden)]
    pub my_sql_catalog_source: std::option::Option<crate::model::MySqlCatalogSource>,
    /// <p>Specifies an Oracle data source in the Glue Data Catalog.</p>
    #[doc(hidden)]
    pub oracle_sql_catalog_source: std::option::Option<crate::model::OracleSqlCatalogSource>,
    /// <p>Specifies a PostgresSQL data source in the Glue Data Catalog.</p>
    #[doc(hidden)]
    pub postgre_sql_catalog_source: std::option::Option<crate::model::PostgreSqlCatalogSource>,
    /// <p>Specifies a target that uses Microsoft SQL.</p>
    #[doc(hidden)]
    pub microsoft_sql_server_catalog_target:
        std::option::Option<crate::model::MicrosoftSqlServerCatalogTarget>,
    /// <p>Specifies a target that uses MySQL.</p>
    #[doc(hidden)]
    pub my_sql_catalog_target: std::option::Option<crate::model::MySqlCatalogTarget>,
    /// <p>Specifies a target that uses Oracle SQL.</p>
    #[doc(hidden)]
    pub oracle_sql_catalog_target: std::option::Option<crate::model::OracleSqlCatalogTarget>,
    /// <p>Specifies a target that uses Postgres SQL.</p>
    #[doc(hidden)]
    pub postgre_sql_catalog_target: std::option::Option<crate::model::PostgreSqlCatalogTarget>,
    /// <p>Specifies a custom visual transform created by a user.</p>
    #[doc(hidden)]
    pub dynamic_transform: std::option::Option<crate::model::DynamicTransform>,
    /// <p>Specifies your data quality evaluation criteria.</p>
    #[doc(hidden)]
    pub evaluate_data_quality: std::option::Option<crate::model::EvaluateDataQuality>,
    /// <p>Specifies a Hudi data source that is registered in the Glue Data Catalog. The Hudi data source must be stored in Amazon S3.</p>
    #[doc(hidden)]
    pub s3_catalog_hudi_source: std::option::Option<crate::model::S3CatalogHudiSource>,
    /// <p>Specifies a Hudi data source that is registered in the Glue Data Catalog.</p>
    #[doc(hidden)]
    pub catalog_hudi_source: std::option::Option<crate::model::CatalogHudiSource>,
    /// <p>Specifies a Hudi data source stored in Amazon S3.</p>
    #[doc(hidden)]
    pub s3_hudi_source: std::option::Option<crate::model::S3HudiSource>,
    /// <p>Specifies a target that writes to a Hudi data source in the Glue Data Catalog.</p>
    #[doc(hidden)]
    pub s3_hudi_catalog_target: std::option::Option<crate::model::S3HudiCatalogTarget>,
    /// <p>Specifies a target that writes to a Hudi data source in Amazon S3.</p>
    #[doc(hidden)]
    pub s3_hudi_direct_target: std::option::Option<crate::model::S3HudiDirectTarget>,
}
impl CodeGenConfigurationNode {
    /// <p>Specifies a connector to an Amazon Athena data source.</p>
    pub fn athena_connector_source(
        &self,
    ) -> std::option::Option<&crate::model::AthenaConnectorSource> {
        self.athena_connector_source.as_ref()
    }
    /// <p>Specifies a connector to a JDBC data source.</p>
    pub fn jdbc_connector_source(&self) -> std::option::Option<&crate::model::JdbcConnectorSource> {
        self.jdbc_connector_source.as_ref()
    }
    /// <p>Specifies a connector to an Apache Spark data source.</p>
    pub fn spark_connector_source(
        &self,
    ) -> std::option::Option<&crate::model::SparkConnectorSource> {
        self.spark_connector_source.as_ref()
    }
    /// <p>Specifies a data store in the Glue Data Catalog.</p>
    pub fn catalog_source(&self) -> std::option::Option<&crate::model::CatalogSource> {
        self.catalog_source.as_ref()
    }
    /// <p>Specifies an Amazon Redshift data store.</p>
    pub fn redshift_source(&self) -> std::option::Option<&crate::model::RedshiftSource> {
        self.redshift_source.as_ref()
    }
    /// <p>Specifies an Amazon S3 data store in the Glue Data Catalog.</p>
    pub fn s3_catalog_source(&self) -> std::option::Option<&crate::model::S3CatalogSource> {
        self.s3_catalog_source.as_ref()
    }
    /// <p>Specifies a command-separated value (CSV) data store stored in Amazon S3.</p>
    pub fn s3_csv_source(&self) -> std::option::Option<&crate::model::S3CsvSource> {
        self.s3_csv_source.as_ref()
    }
    /// <p>Specifies a JSON data store stored in Amazon S3.</p>
    pub fn s3_json_source(&self) -> std::option::Option<&crate::model::S3JsonSource> {
        self.s3_json_source.as_ref()
    }
    /// <p>Specifies an Apache Parquet data store stored in Amazon S3.</p>
    pub fn s3_parquet_source(&self) -> std::option::Option<&crate::model::S3ParquetSource> {
        self.s3_parquet_source.as_ref()
    }
    /// <p>Specifies a Relational database data source in the Glue Data Catalog.</p>
    pub fn relational_catalog_source(
        &self,
    ) -> std::option::Option<&crate::model::RelationalCatalogSource> {
        self.relational_catalog_source.as_ref()
    }
    /// <p>Specifies a DynamoDB data source in the Glue Data Catalog.</p>
    pub fn dynamo_db_catalog_source(
        &self,
    ) -> std::option::Option<&crate::model::DynamoDbCatalogSource> {
        self.dynamo_db_catalog_source.as_ref()
    }
    /// <p>Specifies a data target that writes to Amazon S3 in Apache Parquet columnar storage.</p>
    pub fn jdbc_connector_target(&self) -> std::option::Option<&crate::model::JdbcConnectorTarget> {
        self.jdbc_connector_target.as_ref()
    }
    /// <p>Specifies a target that uses an Apache Spark connector.</p>
    pub fn spark_connector_target(
        &self,
    ) -> std::option::Option<&crate::model::SparkConnectorTarget> {
        self.spark_connector_target.as_ref()
    }
    /// <p>Specifies a target that uses a Glue Data Catalog table.</p>
    pub fn catalog_target(&self) -> std::option::Option<&crate::model::BasicCatalogTarget> {
        self.catalog_target.as_ref()
    }
    /// <p>Specifies a target that uses Amazon Redshift.</p>
    pub fn redshift_target(&self) -> std::option::Option<&crate::model::RedshiftTarget> {
        self.redshift_target.as_ref()
    }
    /// <p>Specifies a data target that writes to Amazon S3 using the Glue Data Catalog.</p>
    pub fn s3_catalog_target(&self) -> std::option::Option<&crate::model::S3CatalogTarget> {
        self.s3_catalog_target.as_ref()
    }
    /// <p>Specifies a data target that writes to Amazon S3 in Apache Parquet columnar storage.</p>
    pub fn s3_glue_parquet_target(
        &self,
    ) -> std::option::Option<&crate::model::S3GlueParquetTarget> {
        self.s3_glue_parquet_target.as_ref()
    }
    /// <p>Specifies a data target that writes to Amazon S3.</p>
    pub fn s3_direct_target(&self) -> std::option::Option<&crate::model::S3DirectTarget> {
        self.s3_direct_target.as_ref()
    }
    /// <p>Specifies a transform that maps data property keys in the data source to data property keys in the data target. You can rename keys, modify the data types for keys, and choose which keys to drop from the dataset.</p>
    pub fn apply_mapping(&self) -> std::option::Option<&crate::model::ApplyMapping> {
        self.apply_mapping.as_ref()
    }
    /// <p>Specifies a transform that chooses the data property keys that you want to keep.</p>
    pub fn select_fields(&self) -> std::option::Option<&crate::model::SelectFields> {
        self.select_fields.as_ref()
    }
    /// <p>Specifies a transform that chooses the data property keys that you want to drop.</p>
    pub fn drop_fields(&self) -> std::option::Option<&crate::model::DropFields> {
        self.drop_fields.as_ref()
    }
    /// <p>Specifies a transform that renames a single data property key.</p>
    pub fn rename_field(&self) -> std::option::Option<&crate::model::RenameField> {
        self.rename_field.as_ref()
    }
    /// <p>Specifies a transform that writes samples of the data to an Amazon S3 bucket.</p>
    pub fn spigot(&self) -> std::option::Option<&crate::model::Spigot> {
        self.spigot.as_ref()
    }
    /// <p>Specifies a transform that joins two datasets into one dataset using a comparison phrase on the specified data property keys. You can use inner, outer, left, right, left semi, and left anti joins.</p>
    pub fn join(&self) -> std::option::Option<&crate::model::Join> {
        self.join.as_ref()
    }
    /// <p>Specifies a transform that splits data property keys into two <code>DynamicFrames</code>. The output is a collection of <code>DynamicFrames</code>: one with selected data property keys, and one with the remaining data property keys.</p>
    pub fn split_fields(&self) -> std::option::Option<&crate::model::SplitFields> {
        self.split_fields.as_ref()
    }
    /// <p>Specifies a transform that chooses one <code>DynamicFrame</code> from a collection of <code>DynamicFrames</code>. The output is the selected <code>DynamicFrame</code> </p>
    pub fn select_from_collection(
        &self,
    ) -> std::option::Option<&crate::model::SelectFromCollection> {
        self.select_from_collection.as_ref()
    }
    /// <p>Specifies a transform that locates records in the dataset that have missing values and adds a new field with a value determined by imputation. The input data set is used to train the machine learning model that determines what the missing value should be.</p>
    pub fn fill_missing_values(&self) -> std::option::Option<&crate::model::FillMissingValues> {
        self.fill_missing_values.as_ref()
    }
    /// <p>Specifies a transform that splits a dataset into two, based on a filter condition.</p>
    pub fn filter(&self) -> std::option::Option<&crate::model::Filter> {
        self.filter.as_ref()
    }
    /// <p>Specifies a transform that uses custom code you provide to perform the data transformation. The output is a collection of DynamicFrames.</p>
    pub fn custom_code(&self) -> std::option::Option<&crate::model::CustomCode> {
        self.custom_code.as_ref()
    }
    /// <p>Specifies a transform where you enter a SQL query using Spark SQL syntax to transform the data. The output is a single <code>DynamicFrame</code>.</p>
    pub fn spark_sql(&self) -> std::option::Option<&crate::model::SparkSql> {
        self.spark_sql.as_ref()
    }
    /// <p>Specifies a direct Amazon Kinesis data source.</p>
    pub fn direct_kinesis_source(&self) -> std::option::Option<&crate::model::DirectKinesisSource> {
        self.direct_kinesis_source.as_ref()
    }
    /// <p>Specifies an Apache Kafka data store.</p>
    pub fn direct_kafka_source(&self) -> std::option::Option<&crate::model::DirectKafkaSource> {
        self.direct_kafka_source.as_ref()
    }
    /// <p>Specifies a Kinesis data source in the Glue Data Catalog.</p>
    pub fn catalog_kinesis_source(
        &self,
    ) -> std::option::Option<&crate::model::CatalogKinesisSource> {
        self.catalog_kinesis_source.as_ref()
    }
    /// <p>Specifies an Apache Kafka data store in the Data Catalog.</p>
    pub fn catalog_kafka_source(&self) -> std::option::Option<&crate::model::CatalogKafkaSource> {
        self.catalog_kafka_source.as_ref()
    }
    /// <p>Specifies a transform that removes columns from the dataset if all values in the column are 'null'. By default, Glue Studio will recognize null objects, but some values such as empty strings, strings that are "null", -1 integers or other placeholders such as zeros, are not automatically recognized as nulls.</p>
    pub fn drop_null_fields(&self) -> std::option::Option<&crate::model::DropNullFields> {
        self.drop_null_fields.as_ref()
    }
    /// <p>Specifies a transform that merges a <code>DynamicFrame</code> with a staging <code>DynamicFrame</code> based on the specified primary keys to identify records. Duplicate records (records with the same primary keys) are not de-duplicated. </p>
    pub fn merge(&self) -> std::option::Option<&crate::model::Merge> {
        self.merge.as_ref()
    }
    /// <p>Specifies a transform that combines the rows from two or more datasets into a single result.</p>
    pub fn union(&self) -> std::option::Option<&crate::model::Union> {
        self.union.as_ref()
    }
    /// <p>Specifies a transform that identifies, removes or masks PII data.</p>
    pub fn pii_detection(&self) -> std::option::Option<&crate::model::PiiDetection> {
        self.pii_detection.as_ref()
    }
    /// <p>Specifies a transform that groups rows by chosen fields and computes the aggregated value by specified function.</p>
    pub fn aggregate(&self) -> std::option::Option<&crate::model::Aggregate> {
        self.aggregate.as_ref()
    }
    /// <p>Specifies a transform that removes rows of repeating data from a data set.</p>
    pub fn drop_duplicates(&self) -> std::option::Option<&crate::model::DropDuplicates> {
        self.drop_duplicates.as_ref()
    }
    /// <p>Specifies a data target that writes to a goverened catalog.</p>
    pub fn governed_catalog_target(
        &self,
    ) -> std::option::Option<&crate::model::GovernedCatalogTarget> {
        self.governed_catalog_target.as_ref()
    }
    /// <p>Specifies a data source in a goverened Data Catalog.</p>
    pub fn governed_catalog_source(
        &self,
    ) -> std::option::Option<&crate::model::GovernedCatalogSource> {
        self.governed_catalog_source.as_ref()
    }
    /// <p>Specifies a Microsoft SQL server data source in the Glue Data Catalog.</p>
    pub fn microsoft_sql_server_catalog_source(
        &self,
    ) -> std::option::Option<&crate::model::MicrosoftSqlServerCatalogSource> {
        self.microsoft_sql_server_catalog_source.as_ref()
    }
    /// <p>Specifies a MySQL data source in the Glue Data Catalog.</p>
    pub fn my_sql_catalog_source(&self) -> std::option::Option<&crate::model::MySqlCatalogSource> {
        self.my_sql_catalog_source.as_ref()
    }
    /// <p>Specifies an Oracle data source in the Glue Data Catalog.</p>
    pub fn oracle_sql_catalog_source(
        &self,
    ) -> std::option::Option<&crate::model::OracleSqlCatalogSource> {
        self.oracle_sql_catalog_source.as_ref()
    }
    /// <p>Specifies a PostgresSQL data source in the Glue Data Catalog.</p>
    pub fn postgre_sql_catalog_source(
        &self,
    ) -> std::option::Option<&crate::model::PostgreSqlCatalogSource> {
        self.postgre_sql_catalog_source.as_ref()
    }
    /// <p>Specifies a target that uses Microsoft SQL.</p>
    pub fn microsoft_sql_server_catalog_target(
        &self,
    ) -> std::option::Option<&crate::model::MicrosoftSqlServerCatalogTarget> {
        self.microsoft_sql_server_catalog_target.as_ref()
    }
    /// <p>Specifies a target that uses MySQL.</p>
    pub fn my_sql_catalog_target(&self) -> std::option::Option<&crate::model::MySqlCatalogTarget> {
        self.my_sql_catalog_target.as_ref()
    }
    /// <p>Specifies a target that uses Oracle SQL.</p>
    pub fn oracle_sql_catalog_target(
        &self,
    ) -> std::option::Option<&crate::model::OracleSqlCatalogTarget> {
        self.oracle_sql_catalog_target.as_ref()
    }
    /// <p>Specifies a target that uses Postgres SQL.</p>
    pub fn postgre_sql_catalog_target(
        &self,
    ) -> std::option::Option<&crate::model::PostgreSqlCatalogTarget> {
        self.postgre_sql_catalog_target.as_ref()
    }
    /// <p>Specifies a custom visual transform created by a user.</p>
    pub fn dynamic_transform(&self) -> std::option::Option<&crate::model::DynamicTransform> {
        self.dynamic_transform.as_ref()
    }
    /// <p>Specifies your data quality evaluation criteria.</p>
    pub fn evaluate_data_quality(&self) -> std::option::Option<&crate::model::EvaluateDataQuality> {
        self.evaluate_data_quality.as_ref()
    }
    /// <p>Specifies a Hudi data source that is registered in the Glue Data Catalog. The Hudi data source must be stored in Amazon S3.</p>
    pub fn s3_catalog_hudi_source(
        &self,
    ) -> std::option::Option<&crate::model::S3CatalogHudiSource> {
        self.s3_catalog_hudi_source.as_ref()
    }
    /// <p>Specifies a Hudi data source that is registered in the Glue Data Catalog.</p>
    pub fn catalog_hudi_source(&self) -> std::option::Option<&crate::model::CatalogHudiSource> {
        self.catalog_hudi_source.as_ref()
    }
    /// <p>Specifies a Hudi data source stored in Amazon S3.</p>
    pub fn s3_hudi_source(&self) -> std::option::Option<&crate::model::S3HudiSource> {
        self.s3_hudi_source.as_ref()
    }
    /// <p>Specifies a target that writes to a Hudi data source in the Glue Data Catalog.</p>
    pub fn s3_hudi_catalog_target(
        &self,
    ) -> std::option::Option<&crate::model::S3HudiCatalogTarget> {
        self.s3_hudi_catalog_target.as_ref()
    }
    /// <p>Specifies a target that writes to a Hudi data source in Amazon S3.</p>
    pub fn s3_hudi_direct_target(&self) -> std::option::Option<&crate::model::S3HudiDirectTarget> {
        self.s3_hudi_direct_target.as_ref()
    }
}
/// See [`CodeGenConfigurationNode`](crate::model::CodeGenConfigurationNode).
pub mod code_gen_configuration_node {

    /// A builder for [`CodeGenConfigurationNode`](crate::model::CodeGenConfigurationNode).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) athena_connector_source:
            std::option::Option<crate::model::AthenaConnectorSource>,
        pub(crate) jdbc_connector_source: std::option::Option<crate::model::JdbcConnectorSource>,
        pub(crate) spark_connector_source: std::option::Option<crate::model::SparkConnectorSource>,
        pub(crate) catalog_source: std::option::Option<crate::model::CatalogSource>,
        pub(crate) redshift_source: std::option::Option<crate::model::RedshiftSource>,
        pub(crate) s3_catalog_source: std::option::Option<crate::model::S3CatalogSource>,
        pub(crate) s3_csv_source: std::option::Option<crate::model::S3CsvSource>,
        pub(crate) s3_json_source: std::option::Option<crate::model::S3JsonSource>,
        pub(crate) s3_parquet_source: std::option::Option<crate::model::S3ParquetSource>,
        pub(crate) relational_catalog_source:
            std::option::Option<crate::model::RelationalCatalogSource>,
        pub(crate) dynamo_db_catalog_source:
            std::option::Option<crate::model::DynamoDbCatalogSource>,
        pub(crate) jdbc_connector_target: std::option::Option<crate::model::JdbcConnectorTarget>,
        pub(crate) spark_connector_target: std::option::Option<crate::model::SparkConnectorTarget>,
        pub(crate) catalog_target: std::option::Option<crate::model::BasicCatalogTarget>,
        pub(crate) redshift_target: std::option::Option<crate::model::RedshiftTarget>,
        pub(crate) s3_catalog_target: std::option::Option<crate::model::S3CatalogTarget>,
        pub(crate) s3_glue_parquet_target: std::option::Option<crate::model::S3GlueParquetTarget>,
        pub(crate) s3_direct_target: std::option::Option<crate::model::S3DirectTarget>,
        pub(crate) apply_mapping: std::option::Option<crate::model::ApplyMapping>,
        pub(crate) select_fields: std::option::Option<crate::model::SelectFields>,
        pub(crate) drop_fields: std::option::Option<crate::model::DropFields>,
        pub(crate) rename_field: std::option::Option<crate::model::RenameField>,
        pub(crate) spigot: std::option::Option<crate::model::Spigot>,
        pub(crate) join: std::option::Option<crate::model::Join>,
        pub(crate) split_fields: std::option::Option<crate::model::SplitFields>,
        pub(crate) select_from_collection: std::option::Option<crate::model::SelectFromCollection>,
        pub(crate) fill_missing_values: std::option::Option<crate::model::FillMissingValues>,
        pub(crate) filter: std::option::Option<crate::model::Filter>,
        pub(crate) custom_code: std::option::Option<crate::model::CustomCode>,
        pub(crate) spark_sql: std::option::Option<crate::model::SparkSql>,
        pub(crate) direct_kinesis_source: std::option::Option<crate::model::DirectKinesisSource>,
        pub(crate) direct_kafka_source: std::option::Option<crate::model::DirectKafkaSource>,
        pub(crate) catalog_kinesis_source: std::option::Option<crate::model::CatalogKinesisSource>,
        pub(crate) catalog_kafka_source: std::option::Option<crate::model::CatalogKafkaSource>,
        pub(crate) drop_null_fields: std::option::Option<crate::model::DropNullFields>,
        pub(crate) merge: std::option::Option<crate::model::Merge>,
        pub(crate) union: std::option::Option<crate::model::Union>,
        pub(crate) pii_detection: std::option::Option<crate::model::PiiDetection>,
        pub(crate) aggregate: std::option::Option<crate::model::Aggregate>,
        pub(crate) drop_duplicates: std::option::Option<crate::model::DropDuplicates>,
        pub(crate) governed_catalog_target:
            std::option::Option<crate::model::GovernedCatalogTarget>,
        pub(crate) governed_catalog_source:
            std::option::Option<crate::model::GovernedCatalogSource>,
        pub(crate) microsoft_sql_server_catalog_source:
            std::option::Option<crate::model::MicrosoftSqlServerCatalogSource>,
        pub(crate) my_sql_catalog_source: std::option::Option<crate::model::MySqlCatalogSource>,
        pub(crate) oracle_sql_catalog_source:
            std::option::Option<crate::model::OracleSqlCatalogSource>,
        pub(crate) postgre_sql_catalog_source:
            std::option::Option<crate::model::PostgreSqlCatalogSource>,
        pub(crate) microsoft_sql_server_catalog_target:
            std::option::Option<crate::model::MicrosoftSqlServerCatalogTarget>,
        pub(crate) my_sql_catalog_target: std::option::Option<crate::model::MySqlCatalogTarget>,
        pub(crate) oracle_sql_catalog_target:
            std::option::Option<crate::model::OracleSqlCatalogTarget>,
        pub(crate) postgre_sql_catalog_target:
            std::option::Option<crate::model::PostgreSqlCatalogTarget>,
        pub(crate) dynamic_transform: std::option::Option<crate::model::DynamicTransform>,
        pub(crate) evaluate_data_quality: std::option::Option<crate::model::EvaluateDataQuality>,
        pub(crate) s3_catalog_hudi_source: std::option::Option<crate::model::S3CatalogHudiSource>,
        pub(crate) catalog_hudi_source: std::option::Option<crate::model::CatalogHudiSource>,
        pub(crate) s3_hudi_source: std::option::Option<crate::model::S3HudiSource>,
        pub(crate) s3_hudi_catalog_target: std::option::Option<crate::model::S3HudiCatalogTarget>,
        pub(crate) s3_hudi_direct_target: std::option::Option<crate::model::S3HudiDirectTarget>,
    }
    impl Builder {
        /// <p>Specifies a connector to an Amazon Athena data source.</p>
        pub fn athena_connector_source(
            mut self,
            input: crate::model::AthenaConnectorSource,
        ) -> Self {
            self.athena_connector_source = Some(input);
            self
        }
        /// <p>Specifies a connector to an Amazon Athena data source.</p>
        pub fn set_athena_connector_source(
            mut self,
            input: std::option::Option<crate::model::AthenaConnectorSource>,
        ) -> Self {
            self.athena_connector_source = input;
            self
        }
        /// <p>Specifies a connector to a JDBC data source.</p>
        pub fn jdbc_connector_source(mut self, input: crate::model::JdbcConnectorSource) -> Self {
            self.jdbc_connector_source = Some(input);
            self
        }
        /// <p>Specifies a connector to a JDBC data source.</p>
        pub fn set_jdbc_connector_source(
            mut self,
            input: std::option::Option<crate::model::JdbcConnectorSource>,
        ) -> Self {
            self.jdbc_connector_source = input;
            self
        }
        /// <p>Specifies a connector to an Apache Spark data source.</p>
        pub fn spark_connector_source(mut self, input: crate::model::SparkConnectorSource) -> Self {
            self.spark_connector_source = Some(input);
            self
        }
        /// <p>Specifies a connector to an Apache Spark data source.</p>
        pub fn set_spark_connector_source(
            mut self,
            input: std::option::Option<crate::model::SparkConnectorSource>,
        ) -> Self {
            self.spark_connector_source = input;
            self
        }
        /// <p>Specifies a data store in the Glue Data Catalog.</p>
        pub fn catalog_source(mut self, input: crate::model::CatalogSource) -> Self {
            self.catalog_source = Some(input);
            self
        }
        /// <p>Specifies a data store in the Glue Data Catalog.</p>
        pub fn set_catalog_source(
            mut self,
            input: std::option::Option<crate::model::CatalogSource>,
        ) -> Self {
            self.catalog_source = input;
            self
        }
        /// <p>Specifies an Amazon Redshift data store.</p>
        pub fn redshift_source(mut self, input: crate::model::RedshiftSource) -> Self {
            self.redshift_source = Some(input);
            self
        }
        /// <p>Specifies an Amazon Redshift data store.</p>
        pub fn set_redshift_source(
            mut self,
            input: std::option::Option<crate::model::RedshiftSource>,
        ) -> Self {
            self.redshift_source = input;
            self
        }
        /// <p>Specifies an Amazon S3 data store in the Glue Data Catalog.</p>
        pub fn s3_catalog_source(mut self, input: crate::model::S3CatalogSource) -> Self {
            self.s3_catalog_source = Some(input);
            self
        }
        /// <p>Specifies an Amazon S3 data store in the Glue Data Catalog.</p>
        pub fn set_s3_catalog_source(
            mut self,
            input: std::option::Option<crate::model::S3CatalogSource>,
        ) -> Self {
            self.s3_catalog_source = input;
            self
        }
        /// <p>Specifies a command-separated value (CSV) data store stored in Amazon S3.</p>
        pub fn s3_csv_source(mut self, input: crate::model::S3CsvSource) -> Self {
            self.s3_csv_source = Some(input);
            self
        }
        /// <p>Specifies a command-separated value (CSV) data store stored in Amazon S3.</p>
        pub fn set_s3_csv_source(
            mut self,
            input: std::option::Option<crate::model::S3CsvSource>,
        ) -> Self {
            self.s3_csv_source = input;
            self
        }
        /// <p>Specifies a JSON data store stored in Amazon S3.</p>
        pub fn s3_json_source(mut self, input: crate::model::S3JsonSource) -> Self {
            self.s3_json_source = Some(input);
            self
        }
        /// <p>Specifies a JSON data store stored in Amazon S3.</p>
        pub fn set_s3_json_source(
            mut self,
            input: std::option::Option<crate::model::S3JsonSource>,
        ) -> Self {
            self.s3_json_source = input;
            self
        }
        /// <p>Specifies an Apache Parquet data store stored in Amazon S3.</p>
        pub fn s3_parquet_source(mut self, input: crate::model::S3ParquetSource) -> Self {
            self.s3_parquet_source = Some(input);
            self
        }
        /// <p>Specifies an Apache Parquet data store stored in Amazon S3.</p>
        pub fn set_s3_parquet_source(
            mut self,
            input: std::option::Option<crate::model::S3ParquetSource>,
        ) -> Self {
            self.s3_parquet_source = input;
            self
        }
        /// <p>Specifies a Relational database data source in the Glue Data Catalog.</p>
        pub fn relational_catalog_source(
            mut self,
            input: crate::model::RelationalCatalogSource,
        ) -> Self {
            self.relational_catalog_source = Some(input);
            self
        }
        /// <p>Specifies a Relational database data source in the Glue Data Catalog.</p>
        pub fn set_relational_catalog_source(
            mut self,
            input: std::option::Option<crate::model::RelationalCatalogSource>,
        ) -> Self {
            self.relational_catalog_source = input;
            self
        }
        /// <p>Specifies a DynamoDB data source in the Glue Data Catalog.</p>
        pub fn dynamo_db_catalog_source(
            mut self,
            input: crate::model::DynamoDbCatalogSource,
        ) -> Self {
            self.dynamo_db_catalog_source = Some(input);
            self
        }
        /// <p>Specifies a DynamoDB data source in the Glue Data Catalog.</p>
        pub fn set_dynamo_db_catalog_source(
            mut self,
            input: std::option::Option<crate::model::DynamoDbCatalogSource>,
        ) -> Self {
            self.dynamo_db_catalog_source = input;
            self
        }
        /// <p>Specifies a data target that writes to Amazon S3 in Apache Parquet columnar storage.</p>
        pub fn jdbc_connector_target(mut self, input: crate::model::JdbcConnectorTarget) -> Self {
            self.jdbc_connector_target = Some(input);
            self
        }
        /// <p>Specifies a data target that writes to Amazon S3 in Apache Parquet columnar storage.</p>
        pub fn set_jdbc_connector_target(
            mut self,
            input: std::option::Option<crate::model::JdbcConnectorTarget>,
        ) -> Self {
            self.jdbc_connector_target = input;
            self
        }
        /// <p>Specifies a target that uses an Apache Spark connector.</p>
        pub fn spark_connector_target(mut self, input: crate::model::SparkConnectorTarget) -> Self {
            self.spark_connector_target = Some(input);
            self
        }
        /// <p>Specifies a target that uses an Apache Spark connector.</p>
        pub fn set_spark_connector_target(
            mut self,
            input: std::option::Option<crate::model::SparkConnectorTarget>,
        ) -> Self {
            self.spark_connector_target = input;
            self
        }
        /// <p>Specifies a target that uses a Glue Data Catalog table.</p>
        pub fn catalog_target(mut self, input: crate::model::BasicCatalogTarget) -> Self {
            self.catalog_target = Some(input);
            self
        }
        /// <p>Specifies a target that uses a Glue Data Catalog table.</p>
        pub fn set_catalog_target(
            mut self,
            input: std::option::Option<crate::model::BasicCatalogTarget>,
        ) -> Self {
            self.catalog_target = input;
            self
        }
        /// <p>Specifies a target that uses Amazon Redshift.</p>
        pub fn redshift_target(mut self, input: crate::model::RedshiftTarget) -> Self {
            self.redshift_target = Some(input);
            self
        }
        /// <p>Specifies a target that uses Amazon Redshift.</p>
        pub fn set_redshift_target(
            mut self,
            input: std::option::Option<crate::model::RedshiftTarget>,
        ) -> Self {
            self.redshift_target = input;
            self
        }
        /// <p>Specifies a data target that writes to Amazon S3 using the Glue Data Catalog.</p>
        pub fn s3_catalog_target(mut self, input: crate::model::S3CatalogTarget) -> Self {
            self.s3_catalog_target = Some(input);
            self
        }
        /// <p>Specifies a data target that writes to Amazon S3 using the Glue Data Catalog.</p>
        pub fn set_s3_catalog_target(
            mut self,
            input: std::option::Option<crate::model::S3CatalogTarget>,
        ) -> Self {
            self.s3_catalog_target = input;
            self
        }
        /// <p>Specifies a data target that writes to Amazon S3 in Apache Parquet columnar storage.</p>
        pub fn s3_glue_parquet_target(mut self, input: crate::model::S3GlueParquetTarget) -> Self {
            self.s3_glue_parquet_target = Some(input);
            self
        }
        /// <p>Specifies a data target that writes to Amazon S3 in Apache Parquet columnar storage.</p>
        pub fn set_s3_glue_parquet_target(
            mut self,
            input: std::option::Option<crate::model::S3GlueParquetTarget>,
        ) -> Self {
            self.s3_glue_parquet_target = input;
            self
        }
        /// <p>Specifies a data target that writes to Amazon S3.</p>
        pub fn s3_direct_target(mut self, input: crate::model::S3DirectTarget) -> Self {
            self.s3_direct_target = Some(input);
            self
        }
        /// <p>Specifies a data target that writes to Amazon S3.</p>
        pub fn set_s3_direct_target(
            mut self,
            input: std::option::Option<crate::model::S3DirectTarget>,
        ) -> Self {
            self.s3_direct_target = input;
            self
        }
        /// <p>Specifies a transform that maps data property keys in the data source to data property keys in the data target. You can rename keys, modify the data types for keys, and choose which keys to drop from the dataset.</p>
        pub fn apply_mapping(mut self, input: crate::model::ApplyMapping) -> Self {
            self.apply_mapping = Some(input);
            self
        }
        /// <p>Specifies a transform that maps data property keys in the data source to data property keys in the data target. You can rename keys, modify the data types for keys, and choose which keys to drop from the dataset.</p>
        pub fn set_apply_mapping(
            mut self,
            input: std::option::Option<crate::model::ApplyMapping>,
        ) -> Self {
            self.apply_mapping = input;
            self
        }
        /// <p>Specifies a transform that chooses the data property keys that you want to keep.</p>
        pub fn select_fields(mut self, input: crate::model::SelectFields) -> Self {
            self.select_fields = Some(input);
            self
        }
        /// <p>Specifies a transform that chooses the data property keys that you want to keep.</p>
        pub fn set_select_fields(
            mut self,
            input: std::option::Option<crate::model::SelectFields>,
        ) -> Self {
            self.select_fields = input;
            self
        }
        /// <p>Specifies a transform that chooses the data property keys that you want to drop.</p>
        pub fn drop_fields(mut self, input: crate::model::DropFields) -> Self {
            self.drop_fields = Some(input);
            self
        }
        /// <p>Specifies a transform that chooses the data property keys that you want to drop.</p>
        pub fn set_drop_fields(
            mut self,
            input: std::option::Option<crate::model::DropFields>,
        ) -> Self {
            self.drop_fields = input;
            self
        }
        /// <p>Specifies a transform that renames a single data property key.</p>
        pub fn rename_field(mut self, input: crate::model::RenameField) -> Self {
            self.rename_field = Some(input);
            self
        }
        /// <p>Specifies a transform that renames a single data property key.</p>
        pub fn set_rename_field(
            mut self,
            input: std::option::Option<crate::model::RenameField>,
        ) -> Self {
            self.rename_field = input;
            self
        }
        /// <p>Specifies a transform that writes samples of the data to an Amazon S3 bucket.</p>
        pub fn spigot(mut self, input: crate::model::Spigot) -> Self {
            self.spigot = Some(input);
            self
        }
        /// <p>Specifies a transform that writes samples of the data to an Amazon S3 bucket.</p>
        pub fn set_spigot(mut self, input: std::option::Option<crate::model::Spigot>) -> Self {
            self.spigot = input;
            self
        }
        /// <p>Specifies a transform that joins two datasets into one dataset using a comparison phrase on the specified data property keys. You can use inner, outer, left, right, left semi, and left anti joins.</p>
        pub fn join(mut self, input: crate::model::Join) -> Self {
            self.join = Some(input);
            self
        }
        /// <p>Specifies a transform that joins two datasets into one dataset using a comparison phrase on the specified data property keys. You can use inner, outer, left, right, left semi, and left anti joins.</p>
        pub fn set_join(mut self, input: std::option::Option<crate::model::Join>) -> Self {
            self.join = input;
            self
        }
        /// <p>Specifies a transform that splits data property keys into two <code>DynamicFrames</code>. The output is a collection of <code>DynamicFrames</code>: one with selected data property keys, and one with the remaining data property keys.</p>
        pub fn split_fields(mut self, input: crate::model::SplitFields) -> Self {
            self.split_fields = Some(input);
            self
        }
        /// <p>Specifies a transform that splits data property keys into two <code>DynamicFrames</code>. The output is a collection of <code>DynamicFrames</code>: one with selected data property keys, and one with the remaining data property keys.</p>
        pub fn set_split_fields(
            mut self,
            input: std::option::Option<crate::model::SplitFields>,
        ) -> Self {
            self.split_fields = input;
            self
        }
        /// <p>Specifies a transform that chooses one <code>DynamicFrame</code> from a collection of <code>DynamicFrames</code>. The output is the selected <code>DynamicFrame</code> </p>
        pub fn select_from_collection(mut self, input: crate::model::SelectFromCollection) -> Self {
            self.select_from_collection = Some(input);
            self
        }
        /// <p>Specifies a transform that chooses one <code>DynamicFrame</code> from a collection of <code>DynamicFrames</code>. The output is the selected <code>DynamicFrame</code> </p>
        pub fn set_select_from_collection(
            mut self,
            input: std::option::Option<crate::model::SelectFromCollection>,
        ) -> Self {
            self.select_from_collection = input;
            self
        }
        /// <p>Specifies a transform that locates records in the dataset that have missing values and adds a new field with a value determined by imputation. The input data set is used to train the machine learning model that determines what the missing value should be.</p>
        pub fn fill_missing_values(mut self, input: crate::model::FillMissingValues) -> Self {
            self.fill_missing_values = Some(input);
            self
        }
        /// <p>Specifies a transform that locates records in the dataset that have missing values and adds a new field with a value determined by imputation. The input data set is used to train the machine learning model that determines what the missing value should be.</p>
        pub fn set_fill_missing_values(
            mut self,
            input: std::option::Option<crate::model::FillMissingValues>,
        ) -> Self {
            self.fill_missing_values = input;
            self
        }
        /// <p>Specifies a transform that splits a dataset into two, based on a filter condition.</p>
        pub fn filter(mut self, input: crate::model::Filter) -> Self {
            self.filter = Some(input);
            self
        }
        /// <p>Specifies a transform that splits a dataset into two, based on a filter condition.</p>
        pub fn set_filter(mut self, input: std::option::Option<crate::model::Filter>) -> Self {
            self.filter = input;
            self
        }
        /// <p>Specifies a transform that uses custom code you provide to perform the data transformation. The output is a collection of DynamicFrames.</p>
        pub fn custom_code(mut self, input: crate::model::CustomCode) -> Self {
            self.custom_code = Some(input);
            self
        }
        /// <p>Specifies a transform that uses custom code you provide to perform the data transformation. The output is a collection of DynamicFrames.</p>
        pub fn set_custom_code(
            mut self,
            input: std::option::Option<crate::model::CustomCode>,
        ) -> Self {
            self.custom_code = input;
            self
        }
        /// <p>Specifies a transform where you enter a SQL query using Spark SQL syntax to transform the data. The output is a single <code>DynamicFrame</code>.</p>
        pub fn spark_sql(mut self, input: crate::model::SparkSql) -> Self {
            self.spark_sql = Some(input);
            self
        }
        /// <p>Specifies a transform where you enter a SQL query using Spark SQL syntax to transform the data. The output is a single <code>DynamicFrame</code>.</p>
        pub fn set_spark_sql(mut self, input: std::option::Option<crate::model::SparkSql>) -> Self {
            self.spark_sql = input;
            self
        }
        /// <p>Specifies a direct Amazon Kinesis data source.</p>
        pub fn direct_kinesis_source(mut self, input: crate::model::DirectKinesisSource) -> Self {
            self.direct_kinesis_source = Some(input);
            self
        }
        /// <p>Specifies a direct Amazon Kinesis data source.</p>
        pub fn set_direct_kinesis_source(
            mut self,
            input: std::option::Option<crate::model::DirectKinesisSource>,
        ) -> Self {
            self.direct_kinesis_source = input;
            self
        }
        /// <p>Specifies an Apache Kafka data store.</p>
        pub fn direct_kafka_source(mut self, input: crate::model::DirectKafkaSource) -> Self {
            self.direct_kafka_source = Some(input);
            self
        }
        /// <p>Specifies an Apache Kafka data store.</p>
        pub fn set_direct_kafka_source(
            mut self,
            input: std::option::Option<crate::model::DirectKafkaSource>,
        ) -> Self {
            self.direct_kafka_source = input;
            self
        }
        /// <p>Specifies a Kinesis data source in the Glue Data Catalog.</p>
        pub fn catalog_kinesis_source(mut self, input: crate::model::CatalogKinesisSource) -> Self {
            self.catalog_kinesis_source = Some(input);
            self
        }
        /// <p>Specifies a Kinesis data source in the Glue Data Catalog.</p>
        pub fn set_catalog_kinesis_source(
            mut self,
            input: std::option::Option<crate::model::CatalogKinesisSource>,
        ) -> Self {
            self.catalog_kinesis_source = input;
            self
        }
        /// <p>Specifies an Apache Kafka data store in the Data Catalog.</p>
        pub fn catalog_kafka_source(mut self, input: crate::model::CatalogKafkaSource) -> Self {
            self.catalog_kafka_source = Some(input);
            self
        }
        /// <p>Specifies an Apache Kafka data store in the Data Catalog.</p>
        pub fn set_catalog_kafka_source(
            mut self,
            input: std::option::Option<crate::model::CatalogKafkaSource>,
        ) -> Self {
            self.catalog_kafka_source = input;
            self
        }
        /// <p>Specifies a transform that removes columns from the dataset if all values in the column are 'null'. By default, Glue Studio will recognize null objects, but some values such as empty strings, strings that are "null", -1 integers or other placeholders such as zeros, are not automatically recognized as nulls.</p>
        pub fn drop_null_fields(mut self, input: crate::model::DropNullFields) -> Self {
            self.drop_null_fields = Some(input);
            self
        }
        /// <p>Specifies a transform that removes columns from the dataset if all values in the column are 'null'. By default, Glue Studio will recognize null objects, but some values such as empty strings, strings that are "null", -1 integers or other placeholders such as zeros, are not automatically recognized as nulls.</p>
        pub fn set_drop_null_fields(
            mut self,
            input: std::option::Option<crate::model::DropNullFields>,
        ) -> Self {
            self.drop_null_fields = input;
            self
        }
        /// <p>Specifies a transform that merges a <code>DynamicFrame</code> with a staging <code>DynamicFrame</code> based on the specified primary keys to identify records. Duplicate records (records with the same primary keys) are not de-duplicated. </p>
        pub fn merge(mut self, input: crate::model::Merge) -> Self {
            self.merge = Some(input);
            self
        }
        /// <p>Specifies a transform that merges a <code>DynamicFrame</code> with a staging <code>DynamicFrame</code> based on the specified primary keys to identify records. Duplicate records (records with the same primary keys) are not de-duplicated. </p>
        pub fn set_merge(mut self, input: std::option::Option<crate::model::Merge>) -> Self {
            self.merge = input;
            self
        }
        /// <p>Specifies a transform that combines the rows from two or more datasets into a single result.</p>
        pub fn union(mut self, input: crate::model::Union) -> Self {
            self.union = Some(input);
            self
        }
        /// <p>Specifies a transform that combines the rows from two or more datasets into a single result.</p>
        pub fn set_union(mut self, input: std::option::Option<crate::model::Union>) -> Self {
            self.union = input;
            self
        }
        /// <p>Specifies a transform that identifies, removes or masks PII data.</p>
        pub fn pii_detection(mut self, input: crate::model::PiiDetection) -> Self {
            self.pii_detection = Some(input);
            self
        }
        /// <p>Specifies a transform that identifies, removes or masks PII data.</p>
        pub fn set_pii_detection(
            mut self,
            input: std::option::Option<crate::model::PiiDetection>,
        ) -> Self {
            self.pii_detection = input;
            self
        }
        /// <p>Specifies a transform that groups rows by chosen fields and computes the aggregated value by specified function.</p>
        pub fn aggregate(mut self, input: crate::model::Aggregate) -> Self {
            self.aggregate = Some(input);
            self
        }
        /// <p>Specifies a transform that groups rows by chosen fields and computes the aggregated value by specified function.</p>
        pub fn set_aggregate(
            mut self,
            input: std::option::Option<crate::model::Aggregate>,
        ) -> Self {
            self.aggregate = input;
            self
        }
        /// <p>Specifies a transform that removes rows of repeating data from a data set.</p>
        pub fn drop_duplicates(mut self, input: crate::model::DropDuplicates) -> Self {
            self.drop_duplicates = Some(input);
            self
        }
        /// <p>Specifies a transform that removes rows of repeating data from a data set.</p>
        pub fn set_drop_duplicates(
            mut self,
            input: std::option::Option<crate::model::DropDuplicates>,
        ) -> Self {
            self.drop_duplicates = input;
            self
        }
        /// <p>Specifies a data target that writes to a goverened catalog.</p>
        pub fn governed_catalog_target(
            mut self,
            input: crate::model::GovernedCatalogTarget,
        ) -> Self {
            self.governed_catalog_target = Some(input);
            self
        }
        /// <p>Specifies a data target that writes to a goverened catalog.</p>
        pub fn set_governed_catalog_target(
            mut self,
            input: std::option::Option<crate::model::GovernedCatalogTarget>,
        ) -> Self {
            self.governed_catalog_target = input;
            self
        }
        /// <p>Specifies a data source in a goverened Data Catalog.</p>
        pub fn governed_catalog_source(
            mut self,
            input: crate::model::GovernedCatalogSource,
        ) -> Self {
            self.governed_catalog_source = Some(input);
            self
        }
        /// <p>Specifies a data source in a goverened Data Catalog.</p>
        pub fn set_governed_catalog_source(
            mut self,
            input: std::option::Option<crate::model::GovernedCatalogSource>,
        ) -> Self {
            self.governed_catalog_source = input;
            self
        }
        /// <p>Specifies a Microsoft SQL server data source in the Glue Data Catalog.</p>
        pub fn microsoft_sql_server_catalog_source(
            mut self,
            input: crate::model::MicrosoftSqlServerCatalogSource,
        ) -> Self {
            self.microsoft_sql_server_catalog_source = Some(input);
            self
        }
        /// <p>Specifies a Microsoft SQL server data source in the Glue Data Catalog.</p>
        pub fn set_microsoft_sql_server_catalog_source(
            mut self,
            input: std::option::Option<crate::model::MicrosoftSqlServerCatalogSource>,
        ) -> Self {
            self.microsoft_sql_server_catalog_source = input;
            self
        }
        /// <p>Specifies a MySQL data source in the Glue Data Catalog.</p>
        pub fn my_sql_catalog_source(mut self, input: crate::model::MySqlCatalogSource) -> Self {
            self.my_sql_catalog_source = Some(input);
            self
        }
        /// <p>Specifies a MySQL data source in the Glue Data Catalog.</p>
        pub fn set_my_sql_catalog_source(
            mut self,
            input: std::option::Option<crate::model::MySqlCatalogSource>,
        ) -> Self {
            self.my_sql_catalog_source = input;
            self
        }
        /// <p>Specifies an Oracle data source in the Glue Data Catalog.</p>
        pub fn oracle_sql_catalog_source(
            mut self,
            input: crate::model::OracleSqlCatalogSource,
        ) -> Self {
            self.oracle_sql_catalog_source = Some(input);
            self
        }
        /// <p>Specifies an Oracle data source in the Glue Data Catalog.</p>
        pub fn set_oracle_sql_catalog_source(
            mut self,
            input: std::option::Option<crate::model::OracleSqlCatalogSource>,
        ) -> Self {
            self.oracle_sql_catalog_source = input;
            self
        }
        /// <p>Specifies a PostgresSQL data source in the Glue Data Catalog.</p>
        pub fn postgre_sql_catalog_source(
            mut self,
            input: crate::model::PostgreSqlCatalogSource,
        ) -> Self {
            self.postgre_sql_catalog_source = Some(input);
            self
        }
        /// <p>Specifies a PostgresSQL data source in the Glue Data Catalog.</p>
        pub fn set_postgre_sql_catalog_source(
            mut self,
            input: std::option::Option<crate::model::PostgreSqlCatalogSource>,
        ) -> Self {
            self.postgre_sql_catalog_source = input;
            self
        }
        /// <p>Specifies a target that uses Microsoft SQL.</p>
        pub fn microsoft_sql_server_catalog_target(
            mut self,
            input: crate::model::MicrosoftSqlServerCatalogTarget,
        ) -> Self {
            self.microsoft_sql_server_catalog_target = Some(input);
            self
        }
        /// <p>Specifies a target that uses Microsoft SQL.</p>
        pub fn set_microsoft_sql_server_catalog_target(
            mut self,
            input: std::option::Option<crate::model::MicrosoftSqlServerCatalogTarget>,
        ) -> Self {
            self.microsoft_sql_server_catalog_target = input;
            self
        }
        /// <p>Specifies a target that uses MySQL.</p>
        pub fn my_sql_catalog_target(mut self, input: crate::model::MySqlCatalogTarget) -> Self {
            self.my_sql_catalog_target = Some(input);
            self
        }
        /// <p>Specifies a target that uses MySQL.</p>
        pub fn set_my_sql_catalog_target(
            mut self,
            input: std::option::Option<crate::model::MySqlCatalogTarget>,
        ) -> Self {
            self.my_sql_catalog_target = input;
            self
        }
        /// <p>Specifies a target that uses Oracle SQL.</p>
        pub fn oracle_sql_catalog_target(
            mut self,
            input: crate::model::OracleSqlCatalogTarget,
        ) -> Self {
            self.oracle_sql_catalog_target = Some(input);
            self
        }
        /// <p>Specifies a target that uses Oracle SQL.</p>
        pub fn set_oracle_sql_catalog_target(
            mut self,
            input: std::option::Option<crate::model::OracleSqlCatalogTarget>,
        ) -> Self {
            self.oracle_sql_catalog_target = input;
            self
        }
        /// <p>Specifies a target that uses Postgres SQL.</p>
        pub fn postgre_sql_catalog_target(
            mut self,
            input: crate::model::PostgreSqlCatalogTarget,
        ) -> Self {
            self.postgre_sql_catalog_target = Some(input);
            self
        }
        /// <p>Specifies a target that uses Postgres SQL.</p>
        pub fn set_postgre_sql_catalog_target(
            mut self,
            input: std::option::Option<crate::model::PostgreSqlCatalogTarget>,
        ) -> Self {
            self.postgre_sql_catalog_target = input;
            self
        }
        /// <p>Specifies a custom visual transform created by a user.</p>
        pub fn dynamic_transform(mut self, input: crate::model::DynamicTransform) -> Self {
            self.dynamic_transform = Some(input);
            self
        }
        /// <p>Specifies a custom visual transform created by a user.</p>
        pub fn set_dynamic_transform(
            mut self,
            input: std::option::Option<crate::model::DynamicTransform>,
        ) -> Self {
            self.dynamic_transform = input;
            self
        }
        /// <p>Specifies your data quality evaluation criteria.</p>
        pub fn evaluate_data_quality(mut self, input: crate::model::EvaluateDataQuality) -> Self {
            self.evaluate_data_quality = Some(input);
            self
        }
        /// <p>Specifies your data quality evaluation criteria.</p>
        pub fn set_evaluate_data_quality(
            mut self,
            input: std::option::Option<crate::model::EvaluateDataQuality>,
        ) -> Self {
            self.evaluate_data_quality = input;
            self
        }
        /// <p>Specifies a Hudi data source that is registered in the Glue Data Catalog. The Hudi data source must be stored in Amazon S3.</p>
        pub fn s3_catalog_hudi_source(mut self, input: crate::model::S3CatalogHudiSource) -> Self {
            self.s3_catalog_hudi_source = Some(input);
            self
        }
        /// <p>Specifies a Hudi data source that is registered in the Glue Data Catalog. The Hudi data source must be stored in Amazon S3.</p>
        pub fn set_s3_catalog_hudi_source(
            mut self,
            input: std::option::Option<crate::model::S3CatalogHudiSource>,
        ) -> Self {
            self.s3_catalog_hudi_source = input;
            self
        }
        /// <p>Specifies a Hudi data source that is registered in the Glue Data Catalog.</p>
        pub fn catalog_hudi_source(mut self, input: crate::model::CatalogHudiSource) -> Self {
            self.catalog_hudi_source = Some(input);
            self
        }
        /// <p>Specifies a Hudi data source that is registered in the Glue Data Catalog.</p>
        pub fn set_catalog_hudi_source(
            mut self,
            input: std::option::Option<crate::model::CatalogHudiSource>,
        ) -> Self {
            self.catalog_hudi_source = input;
            self
        }
        /// <p>Specifies a Hudi data source stored in Amazon S3.</p>
        pub fn s3_hudi_source(mut self, input: crate::model::S3HudiSource) -> Self {
            self.s3_hudi_source = Some(input);
            self
        }
        /// <p>Specifies a Hudi data source stored in Amazon S3.</p>
        pub fn set_s3_hudi_source(
            mut self,
            input: std::option::Option<crate::model::S3HudiSource>,
        ) -> Self {
            self.s3_hudi_source = input;
            self
        }
        /// <p>Specifies a target that writes to a Hudi data source in the Glue Data Catalog.</p>
        pub fn s3_hudi_catalog_target(mut self, input: crate::model::S3HudiCatalogTarget) -> Self {
            self.s3_hudi_catalog_target = Some(input);
            self
        }
        /// <p>Specifies a target that writes to a Hudi data source in the Glue Data Catalog.</p>
        pub fn set_s3_hudi_catalog_target(
            mut self,
            input: std::option::Option<crate::model::S3HudiCatalogTarget>,
        ) -> Self {
            self.s3_hudi_catalog_target = input;
            self
        }
        /// <p>Specifies a target that writes to a Hudi data source in Amazon S3.</p>
        pub fn s3_hudi_direct_target(mut self, input: crate::model::S3HudiDirectTarget) -> Self {
            self.s3_hudi_direct_target = Some(input);
            self
        }
        /// <p>Specifies a target that writes to a Hudi data source in Amazon S3.</p>
        pub fn set_s3_hudi_direct_target(
            mut self,
            input: std::option::Option<crate::model::S3HudiDirectTarget>,
        ) -> Self {
            self.s3_hudi_direct_target = input;
            self
        }
        /// Consumes the builder and constructs a [`CodeGenConfigurationNode`](crate::model::CodeGenConfigurationNode).
        pub fn build(self) -> crate::model::CodeGenConfigurationNode {
            crate::model::CodeGenConfigurationNode {
                athena_connector_source: self.athena_connector_source,
                jdbc_connector_source: self.jdbc_connector_source,
                spark_connector_source: self.spark_connector_source,
                catalog_source: self.catalog_source,
                redshift_source: self.redshift_source,
                s3_catalog_source: self.s3_catalog_source,
                s3_csv_source: self.s3_csv_source,
                s3_json_source: self.s3_json_source,
                s3_parquet_source: self.s3_parquet_source,
                relational_catalog_source: self.relational_catalog_source,
                dynamo_db_catalog_source: self.dynamo_db_catalog_source,
                jdbc_connector_target: self.jdbc_connector_target,
                spark_connector_target: self.spark_connector_target,
                catalog_target: self.catalog_target,
                redshift_target: self.redshift_target,
                s3_catalog_target: self.s3_catalog_target,
                s3_glue_parquet_target: self.s3_glue_parquet_target,
                s3_direct_target: self.s3_direct_target,
                apply_mapping: self.apply_mapping,
                select_fields: self.select_fields,
                drop_fields: self.drop_fields,
                rename_field: self.rename_field,
                spigot: self.spigot,
                join: self.join,
                split_fields: self.split_fields,
                select_from_collection: self.select_from_collection,
                fill_missing_values: self.fill_missing_values,
                filter: self.filter,
                custom_code: self.custom_code,
                spark_sql: self.spark_sql,
                direct_kinesis_source: self.direct_kinesis_source,
                direct_kafka_source: self.direct_kafka_source,
                catalog_kinesis_source: self.catalog_kinesis_source,
                catalog_kafka_source: self.catalog_kafka_source,
                drop_null_fields: self.drop_null_fields,
                merge: self.merge,
                union: self.union,
                pii_detection: self.pii_detection,
                aggregate: self.aggregate,
                drop_duplicates: self.drop_duplicates,
                governed_catalog_target: self.governed_catalog_target,
                governed_catalog_source: self.governed_catalog_source,
                microsoft_sql_server_catalog_source: self.microsoft_sql_server_catalog_source,
                my_sql_catalog_source: self.my_sql_catalog_source,
                oracle_sql_catalog_source: self.oracle_sql_catalog_source,
                postgre_sql_catalog_source: self.postgre_sql_catalog_source,
                microsoft_sql_server_catalog_target: self.microsoft_sql_server_catalog_target,
                my_sql_catalog_target: self.my_sql_catalog_target,
                oracle_sql_catalog_target: self.oracle_sql_catalog_target,
                postgre_sql_catalog_target: self.postgre_sql_catalog_target,
                dynamic_transform: self.dynamic_transform,
                evaluate_data_quality: self.evaluate_data_quality,
                s3_catalog_hudi_source: self.s3_catalog_hudi_source,
                catalog_hudi_source: self.catalog_hudi_source,
                s3_hudi_source: self.s3_hudi_source,
                s3_hudi_catalog_target: self.s3_hudi_catalog_target,
                s3_hudi_direct_target: self.s3_hudi_direct_target,
            }
        }
    }
}
impl CodeGenConfigurationNode {
    /// Creates a new builder-style object to manufacture [`CodeGenConfigurationNode`](crate::model::CodeGenConfigurationNode).
    pub fn builder() -> crate::model::code_gen_configuration_node::Builder {
        crate::model::code_gen_configuration_node::Builder::default()
    }
}

/// <p>Specifies a target that writes to a Hudi data source in Amazon S3.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct S3HudiDirectTarget {
    /// <p>The name of the data target.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The nodes that are inputs to the data target.</p>
    #[doc(hidden)]
    pub inputs: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The Amazon S3 path of your Hudi data source to write to.</p>
    #[doc(hidden)]
    pub path: std::option::Option<std::string::String>,
    /// <p>Specifies how the data is compressed. This is generally not necessary if the data has a standard file extension. Possible values are <code>"gzip"</code> and <code>"bzip"</code>).</p>
    #[doc(hidden)]
    pub compression: std::option::Option<crate::model::HudiTargetCompressionType>,
    /// <p>Specifies native partitioning using a sequence of keys.</p>
    #[doc(hidden)]
    pub partition_keys: std::option::Option<std::vec::Vec<std::vec::Vec<std::string::String>>>,
    /// <p>Specifies the data output format for the target.</p>
    #[doc(hidden)]
    pub format: std::option::Option<crate::model::TargetFormat>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub additional_options:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>A policy that specifies update behavior for the crawler.</p>
    #[doc(hidden)]
    pub schema_change_policy: std::option::Option<crate::model::DirectSchemaChangePolicy>,
}
impl S3HudiDirectTarget {
    /// <p>The name of the data target.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The nodes that are inputs to the data target.</p>
    pub fn inputs(&self) -> std::option::Option<&[std::string::String]> {
        self.inputs.as_deref()
    }
    /// <p>The Amazon S3 path of your Hudi data source to write to.</p>
    pub fn path(&self) -> std::option::Option<&str> {
        self.path.as_deref()
    }
    /// <p>Specifies how the data is compressed. This is generally not necessary if the data has a standard file extension. Possible values are <code>"gzip"</code> and <code>"bzip"</code>).</p>
    pub fn compression(&self) -> std::option::Option<&crate::model::HudiTargetCompressionType> {
        self.compression.as_ref()
    }
    /// <p>Specifies native partitioning using a sequence of keys.</p>
    pub fn partition_keys(&self) -> std::option::Option<&[std::vec::Vec<std::string::String>]> {
        self.partition_keys.as_deref()
    }
    /// <p>Specifies the data output format for the target.</p>
    pub fn format(&self) -> std::option::Option<&crate::model::TargetFormat> {
        self.format.as_ref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn additional_options(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.additional_options.as_ref()
    }
    /// <p>A policy that specifies update behavior for the crawler.</p>
    pub fn schema_change_policy(
        &self,
    ) -> std::option::Option<&crate::model::DirectSchemaChangePolicy> {
        self.schema_change_policy.as_ref()
    }
}
/// See [`S3HudiDirectTarget`](crate::model::S3HudiDirectTarget).
pub mod s3_hudi_direct_target {

    /// A builder for [`S3HudiDirectTarget`](crate::model::S3HudiDirectTarget).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) inputs: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) path: std::option::Option<std::string::String>,
        pub(crate) compression: std::option::Option<crate::model::HudiTargetCompressionType>,
        pub(crate) partition_keys:
            std::option::Option<std::vec::Vec<std::vec::Vec<std::string::String>>>,
        pub(crate) format: std::option::Option<crate::model::TargetFormat>,
        pub(crate) additional_options: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) schema_change_policy:
            std::option::Option<crate::model::DirectSchemaChangePolicy>,
    }
    impl Builder {
        /// <p>The name of the data target.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the data target.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Appends an item to `inputs`.
        ///
        /// To override the contents of this collection use [`set_inputs`](Self::set_inputs).
        ///
        /// <p>The nodes that are inputs to the data target.</p>
        pub fn inputs(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.inputs.unwrap_or_default();
            v.push(input.into());
            self.inputs = Some(v);
            self
        }
        /// <p>The nodes that are inputs to the data target.</p>
        pub fn set_inputs(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inputs = input;
            self
        }
        /// <p>The Amazon S3 path of your Hudi data source to write to.</p>
        pub fn path(mut self, input: impl Into<std::string::String>) -> Self {
            self.path = Some(input.into());
            self
        }
        /// <p>The Amazon S3 path of your Hudi data source to write to.</p>
        pub fn set_path(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.path = input;
            self
        }
        /// <p>Specifies how the data is compressed. This is generally not necessary if the data has a standard file extension. Possible values are <code>"gzip"</code> and <code>"bzip"</code>).</p>
        pub fn compression(mut self, input: crate::model::HudiTargetCompressionType) -> Self {
            self.compression = Some(input);
            self
        }
        /// <p>Specifies how the data is compressed. This is generally not necessary if the data has a standard file extension. Possible values are <code>"gzip"</code> and <code>"bzip"</code>).</p>
        pub fn set_compression(
            mut self,
            input: std::option::Option<crate::model::HudiTargetCompressionType>,
        ) -> Self {
            self.compression = input;
            self
        }
        /// Appends an item to `partition_keys`.
        ///
        /// To override the contents of this collection use [`set_partition_keys`](Self::set_partition_keys).
        ///
        /// <p>Specifies native partitioning using a sequence of keys.</p>
        pub fn partition_keys(mut self, input: std::vec::Vec<std::string::String>) -> Self {
            let mut v = self.partition_keys.unwrap_or_default();
            v.push(input);
            self.partition_keys = Some(v);
            self
        }
        /// <p>Specifies native partitioning using a sequence of keys.</p>
        pub fn set_partition_keys(
            mut self,
            input: std::option::Option<std::vec::Vec<std::vec::Vec<std::string::String>>>,
        ) -> Self {
            self.partition_keys = input;
            self
        }
        /// <p>Specifies the data output format for the target.</p>
        pub fn format(mut self, input: crate::model::TargetFormat) -> Self {
            self.format = Some(input);
            self
        }
        /// <p>Specifies the data output format for the target.</p>
        pub fn set_format(
            mut self,
            input: std::option::Option<crate::model::TargetFormat>,
        ) -> Self {
            self.format = input;
            self
        }
        /// Adds a key-value pair to `additional_options`.
        ///
        /// To override the contents of this collection use [`set_additional_options`](Self::set_additional_options).
        ///
        pub fn additional_options(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.additional_options.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.additional_options = Some(hash_map);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_additional_options(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.additional_options = input;
            self
        }
        /// <p>A policy that specifies update behavior for the crawler.</p>
        pub fn schema_change_policy(
            mut self,
            input: crate::model::DirectSchemaChangePolicy,
        ) -> Self {
            self.schema_change_policy = Some(input);
            self
        }
        /// <p>A policy that specifies update behavior for the crawler.</p>
        pub fn set_schema_change_policy(
            mut self,
            input: std::option::Option<crate::model::DirectSchemaChangePolicy>,
        ) -> Self {
            self.schema_change_policy = input;
            self
        }
        /// Consumes the builder and constructs a [`S3HudiDirectTarget`](crate::model::S3HudiDirectTarget).
        pub fn build(self) -> crate::model::S3HudiDirectTarget {
            crate::model::S3HudiDirectTarget {
                name: self.name,
                inputs: self.inputs,
                path: self.path,
                compression: self.compression,
                partition_keys: self.partition_keys,
                format: self.format,
                additional_options: self.additional_options,
                schema_change_policy: self.schema_change_policy,
            }
        }
    }
}
impl S3HudiDirectTarget {
    /// Creates a new builder-style object to manufacture [`S3HudiDirectTarget`](crate::model::S3HudiDirectTarget).
    pub fn builder() -> crate::model::s3_hudi_direct_target::Builder {
        crate::model::s3_hudi_direct_target::Builder::default()
    }
}

/// <p>A policy that specifies update behavior for the crawler.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DirectSchemaChangePolicy {
    /// <p>Whether to use the specified update behavior when the crawler finds a changed schema.</p>
    #[doc(hidden)]
    pub enable_update_catalog: std::option::Option<bool>,
    /// <p>The update behavior when the crawler finds a changed schema.</p>
    #[doc(hidden)]
    pub update_behavior: std::option::Option<crate::model::UpdateCatalogBehavior>,
    /// <p>Specifies the table in the database that the schema change policy applies to.</p>
    #[doc(hidden)]
    pub table: std::option::Option<std::string::String>,
    /// <p>Specifies the database that the schema change policy applies to.</p>
    #[doc(hidden)]
    pub database: std::option::Option<std::string::String>,
}
impl DirectSchemaChangePolicy {
    /// <p>Whether to use the specified update behavior when the crawler finds a changed schema.</p>
    pub fn enable_update_catalog(&self) -> std::option::Option<bool> {
        self.enable_update_catalog
    }
    /// <p>The update behavior when the crawler finds a changed schema.</p>
    pub fn update_behavior(&self) -> std::option::Option<&crate::model::UpdateCatalogBehavior> {
        self.update_behavior.as_ref()
    }
    /// <p>Specifies the table in the database that the schema change policy applies to.</p>
    pub fn table(&self) -> std::option::Option<&str> {
        self.table.as_deref()
    }
    /// <p>Specifies the database that the schema change policy applies to.</p>
    pub fn database(&self) -> std::option::Option<&str> {
        self.database.as_deref()
    }
}
/// See [`DirectSchemaChangePolicy`](crate::model::DirectSchemaChangePolicy).
pub mod direct_schema_change_policy {

    /// A builder for [`DirectSchemaChangePolicy`](crate::model::DirectSchemaChangePolicy).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) enable_update_catalog: std::option::Option<bool>,
        pub(crate) update_behavior: std::option::Option<crate::model::UpdateCatalogBehavior>,
        pub(crate) table: std::option::Option<std::string::String>,
        pub(crate) database: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Whether to use the specified update behavior when the crawler finds a changed schema.</p>
        pub fn enable_update_catalog(mut self, input: bool) -> Self {
            self.enable_update_catalog = Some(input);
            self
        }
        /// <p>Whether to use the specified update behavior when the crawler finds a changed schema.</p>
        pub fn set_enable_update_catalog(mut self, input: std::option::Option<bool>) -> Self {
            self.enable_update_catalog = input;
            self
        }
        /// <p>The update behavior when the crawler finds a changed schema.</p>
        pub fn update_behavior(mut self, input: crate::model::UpdateCatalogBehavior) -> Self {
            self.update_behavior = Some(input);
            self
        }
        /// <p>The update behavior when the crawler finds a changed schema.</p>
        pub fn set_update_behavior(
            mut self,
            input: std::option::Option<crate::model::UpdateCatalogBehavior>,
        ) -> Self {
            self.update_behavior = input;
            self
        }
        /// <p>Specifies the table in the database that the schema change policy applies to.</p>
        pub fn table(mut self, input: impl Into<std::string::String>) -> Self {
            self.table = Some(input.into());
            self
        }
        /// <p>Specifies the table in the database that the schema change policy applies to.</p>
        pub fn set_table(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.table = input;
            self
        }
        /// <p>Specifies the database that the schema change policy applies to.</p>
        pub fn database(mut self, input: impl Into<std::string::String>) -> Self {
            self.database = Some(input.into());
            self
        }
        /// <p>Specifies the database that the schema change policy applies to.</p>
        pub fn set_database(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.database = input;
            self
        }
        /// Consumes the builder and constructs a [`DirectSchemaChangePolicy`](crate::model::DirectSchemaChangePolicy).
        pub fn build(self) -> crate::model::DirectSchemaChangePolicy {
            crate::model::DirectSchemaChangePolicy {
                enable_update_catalog: self.enable_update_catalog,
                update_behavior: self.update_behavior,
                table: self.table,
                database: self.database,
            }
        }
    }
}
impl DirectSchemaChangePolicy {
    /// Creates a new builder-style object to manufacture [`DirectSchemaChangePolicy`](crate::model::DirectSchemaChangePolicy).
    pub fn builder() -> crate::model::direct_schema_change_policy::Builder {
        crate::model::direct_schema_change_policy::Builder::default()
    }
}

/// When writing a match expression against `UpdateCatalogBehavior`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let updatecatalogbehavior = unimplemented!();
/// match updatecatalogbehavior {
///     UpdateCatalogBehavior::Log => { /* ... */ },
///     UpdateCatalogBehavior::UpdateInDatabase => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `updatecatalogbehavior` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `UpdateCatalogBehavior::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `UpdateCatalogBehavior::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `UpdateCatalogBehavior::NewFeature` is defined.
/// Specifically, when `updatecatalogbehavior` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `UpdateCatalogBehavior::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum UpdateCatalogBehavior {
    #[allow(missing_docs)] // documentation missing in model
    Log,
    #[allow(missing_docs)] // documentation missing in model
    UpdateInDatabase,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for UpdateCatalogBehavior {
    fn from(s: &str) -> Self {
        match s {
            "LOG" => UpdateCatalogBehavior::Log,
            "UPDATE_IN_DATABASE" => UpdateCatalogBehavior::UpdateInDatabase,
            other => {
                UpdateCatalogBehavior::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for UpdateCatalogBehavior {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(UpdateCatalogBehavior::from(s))
    }
}
impl UpdateCatalogBehavior {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            UpdateCatalogBehavior::Log => "LOG",
            UpdateCatalogBehavior::UpdateInDatabase => "UPDATE_IN_DATABASE",
            UpdateCatalogBehavior::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["LOG", "UPDATE_IN_DATABASE"]
    }
}
impl AsRef<str> for UpdateCatalogBehavior {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `TargetFormat`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let targetformat = unimplemented!();
/// match targetformat {
///     TargetFormat::Avro => { /* ... */ },
///     TargetFormat::Csv => { /* ... */ },
///     TargetFormat::Hudi => { /* ... */ },
///     TargetFormat::Json => { /* ... */ },
///     TargetFormat::Orc => { /* ... */ },
///     TargetFormat::Parquet => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `targetformat` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `TargetFormat::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `TargetFormat::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `TargetFormat::NewFeature` is defined.
/// Specifically, when `targetformat` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `TargetFormat::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TargetFormat {
    #[allow(missing_docs)] // documentation missing in model
    Avro,
    #[allow(missing_docs)] // documentation missing in model
    Csv,
    #[allow(missing_docs)] // documentation missing in model
    Hudi,
    #[allow(missing_docs)] // documentation missing in model
    Json,
    #[allow(missing_docs)] // documentation missing in model
    Orc,
    #[allow(missing_docs)] // documentation missing in model
    Parquet,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for TargetFormat {
    fn from(s: &str) -> Self {
        match s {
            "avro" => TargetFormat::Avro,
            "csv" => TargetFormat::Csv,
            "hudi" => TargetFormat::Hudi,
            "json" => TargetFormat::Json,
            "orc" => TargetFormat::Orc,
            "parquet" => TargetFormat::Parquet,
            other => TargetFormat::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for TargetFormat {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TargetFormat::from(s))
    }
}
impl TargetFormat {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            TargetFormat::Avro => "avro",
            TargetFormat::Csv => "csv",
            TargetFormat::Hudi => "hudi",
            TargetFormat::Json => "json",
            TargetFormat::Orc => "orc",
            TargetFormat::Parquet => "parquet",
            TargetFormat::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["avro", "csv", "hudi", "json", "orc", "parquet"]
    }
}
impl AsRef<str> for TargetFormat {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `HudiTargetCompressionType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let huditargetcompressiontype = unimplemented!();
/// match huditargetcompressiontype {
///     HudiTargetCompressionType::Gzip => { /* ... */ },
///     HudiTargetCompressionType::Lzo => { /* ... */ },
///     HudiTargetCompressionType::Snappy => { /* ... */ },
///     HudiTargetCompressionType::Uncompressed => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `huditargetcompressiontype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `HudiTargetCompressionType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `HudiTargetCompressionType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `HudiTargetCompressionType::NewFeature` is defined.
/// Specifically, when `huditargetcompressiontype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `HudiTargetCompressionType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum HudiTargetCompressionType {
    #[allow(missing_docs)] // documentation missing in model
    Gzip,
    #[allow(missing_docs)] // documentation missing in model
    Lzo,
    #[allow(missing_docs)] // documentation missing in model
    Snappy,
    #[allow(missing_docs)] // documentation missing in model
    Uncompressed,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for HudiTargetCompressionType {
    fn from(s: &str) -> Self {
        match s {
            "gzip" => HudiTargetCompressionType::Gzip,
            "lzo" => HudiTargetCompressionType::Lzo,
            "snappy" => HudiTargetCompressionType::Snappy,
            "uncompressed" => HudiTargetCompressionType::Uncompressed,
            other => HudiTargetCompressionType::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for HudiTargetCompressionType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(HudiTargetCompressionType::from(s))
    }
}
impl HudiTargetCompressionType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            HudiTargetCompressionType::Gzip => "gzip",
            HudiTargetCompressionType::Lzo => "lzo",
            HudiTargetCompressionType::Snappy => "snappy",
            HudiTargetCompressionType::Uncompressed => "uncompressed",
            HudiTargetCompressionType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["gzip", "lzo", "snappy", "uncompressed"]
    }
}
impl AsRef<str> for HudiTargetCompressionType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Specifies a target that writes to a Hudi data source in the Glue Data Catalog.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct S3HudiCatalogTarget {
    /// <p>The name of the data target.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The nodes that are inputs to the data target.</p>
    #[doc(hidden)]
    pub inputs: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Specifies native partitioning using a sequence of keys.</p>
    #[doc(hidden)]
    pub partition_keys: std::option::Option<std::vec::Vec<std::vec::Vec<std::string::String>>>,
    /// <p>The name of the table in the database to write to.</p>
    #[doc(hidden)]
    pub table: std::option::Option<std::string::String>,
    /// <p>The name of the database to write to.</p>
    #[doc(hidden)]
    pub database: std::option::Option<std::string::String>,
    /// <p>Specifies additional connection options for the connector.</p>
    #[doc(hidden)]
    pub additional_options:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>A policy that specifies update behavior for the crawler.</p>
    #[doc(hidden)]
    pub schema_change_policy: std::option::Option<crate::model::CatalogSchemaChangePolicy>,
}
impl S3HudiCatalogTarget {
    /// <p>The name of the data target.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The nodes that are inputs to the data target.</p>
    pub fn inputs(&self) -> std::option::Option<&[std::string::String]> {
        self.inputs.as_deref()
    }
    /// <p>Specifies native partitioning using a sequence of keys.</p>
    pub fn partition_keys(&self) -> std::option::Option<&[std::vec::Vec<std::string::String>]> {
        self.partition_keys.as_deref()
    }
    /// <p>The name of the table in the database to write to.</p>
    pub fn table(&self) -> std::option::Option<&str> {
        self.table.as_deref()
    }
    /// <p>The name of the database to write to.</p>
    pub fn database(&self) -> std::option::Option<&str> {
        self.database.as_deref()
    }
    /// <p>Specifies additional connection options for the connector.</p>
    pub fn additional_options(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.additional_options.as_ref()
    }
    /// <p>A policy that specifies update behavior for the crawler.</p>
    pub fn schema_change_policy(
        &self,
    ) -> std::option::Option<&crate::model::CatalogSchemaChangePolicy> {
        self.schema_change_policy.as_ref()
    }
}
/// See [`S3HudiCatalogTarget`](crate::model::S3HudiCatalogTarget).
pub mod s3_hudi_catalog_target {

    /// A builder for [`S3HudiCatalogTarget`](crate::model::S3HudiCatalogTarget).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) inputs: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) partition_keys:
            std::option::Option<std::vec::Vec<std::vec::Vec<std::string::String>>>,
        pub(crate) table: std::option::Option<std::string::String>,
        pub(crate) database: std::option::Option<std::string::String>,
        pub(crate) additional_options: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) schema_change_policy:
            std::option::Option<crate::model::CatalogSchemaChangePolicy>,
    }
    impl Builder {
        /// <p>The name of the data target.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the data target.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Appends an item to `inputs`.
        ///
        /// To override the contents of this collection use [`set_inputs`](Self::set_inputs).
        ///
        /// <p>The nodes that are inputs to the data target.</p>
        pub fn inputs(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.inputs.unwrap_or_default();
            v.push(input.into());
            self.inputs = Some(v);
            self
        }
        /// <p>The nodes that are inputs to the data target.</p>
        pub fn set_inputs(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inputs = input;
            self
        }
        /// Appends an item to `partition_keys`.
        ///
        /// To override the contents of this collection use [`set_partition_keys`](Self::set_partition_keys).
        ///
        /// <p>Specifies native partitioning using a sequence of keys.</p>
        pub fn partition_keys(mut self, input: std::vec::Vec<std::string::String>) -> Self {
            let mut v = self.partition_keys.unwrap_or_default();
            v.push(input);
            self.partition_keys = Some(v);
            self
        }
        /// <p>Specifies native partitioning using a sequence of keys.</p>
        pub fn set_partition_keys(
            mut self,
            input: std::option::Option<std::vec::Vec<std::vec::Vec<std::string::String>>>,
        ) -> Self {
            self.partition_keys = input;
            self
        }
        /// <p>The name of the table in the database to write to.</p>
        pub fn table(mut self, input: impl Into<std::string::String>) -> Self {
            self.table = Some(input.into());
            self
        }
        /// <p>The name of the table in the database to write to.</p>
        pub fn set_table(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.table = input;
            self
        }
        /// <p>The name of the database to write to.</p>
        pub fn database(mut self, input: impl Into<std::string::String>) -> Self {
            self.database = Some(input.into());
            self
        }
        /// <p>The name of the database to write to.</p>
        pub fn set_database(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.database = input;
            self
        }
        /// Adds a key-value pair to `additional_options`.
        ///
        /// To override the contents of this collection use [`set_additional_options`](Self::set_additional_options).
        ///
        /// <p>Specifies additional connection options for the connector.</p>
        pub fn additional_options(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.additional_options.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.additional_options = Some(hash_map);
            self
        }
        /// <p>Specifies additional connection options for the connector.</p>
        pub fn set_additional_options(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.additional_options = input;
            self
        }
        /// <p>A policy that specifies update behavior for the crawler.</p>
        pub fn schema_change_policy(
            mut self,
            input: crate::model::CatalogSchemaChangePolicy,
        ) -> Self {
            self.schema_change_policy = Some(input);
            self
        }
        /// <p>A policy that specifies update behavior for the crawler.</p>
        pub fn set_schema_change_policy(
            mut self,
            input: std::option::Option<crate::model::CatalogSchemaChangePolicy>,
        ) -> Self {
            self.schema_change_policy = input;
            self
        }
        /// Consumes the builder and constructs a [`S3HudiCatalogTarget`](crate::model::S3HudiCatalogTarget).
        pub fn build(self) -> crate::model::S3HudiCatalogTarget {
            crate::model::S3HudiCatalogTarget {
                name: self.name,
                inputs: self.inputs,
                partition_keys: self.partition_keys,
                table: self.table,
                database: self.database,
                additional_options: self.additional_options,
                schema_change_policy: self.schema_change_policy,
            }
        }
    }
}
impl S3HudiCatalogTarget {
    /// Creates a new builder-style object to manufacture [`S3HudiCatalogTarget`](crate::model::S3HudiCatalogTarget).
    pub fn builder() -> crate::model::s3_hudi_catalog_target::Builder {
        crate::model::s3_hudi_catalog_target::Builder::default()
    }
}

/// <p>A policy that specifies update behavior for the crawler.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CatalogSchemaChangePolicy {
    /// <p>Whether to use the specified update behavior when the crawler finds a changed schema.</p>
    #[doc(hidden)]
    pub enable_update_catalog: std::option::Option<bool>,
    /// <p>The update behavior when the crawler finds a changed schema.</p>
    #[doc(hidden)]
    pub update_behavior: std::option::Option<crate::model::UpdateCatalogBehavior>,
}
impl CatalogSchemaChangePolicy {
    /// <p>Whether to use the specified update behavior when the crawler finds a changed schema.</p>
    pub fn enable_update_catalog(&self) -> std::option::Option<bool> {
        self.enable_update_catalog
    }
    /// <p>The update behavior when the crawler finds a changed schema.</p>
    pub fn update_behavior(&self) -> std::option::Option<&crate::model::UpdateCatalogBehavior> {
        self.update_behavior.as_ref()
    }
}
/// See [`CatalogSchemaChangePolicy`](crate::model::CatalogSchemaChangePolicy).
pub mod catalog_schema_change_policy {

    /// A builder for [`CatalogSchemaChangePolicy`](crate::model::CatalogSchemaChangePolicy).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) enable_update_catalog: std::option::Option<bool>,
        pub(crate) update_behavior: std::option::Option<crate::model::UpdateCatalogBehavior>,
    }
    impl Builder {
        /// <p>Whether to use the specified update behavior when the crawler finds a changed schema.</p>
        pub fn enable_update_catalog(mut self, input: bool) -> Self {
            self.enable_update_catalog = Some(input);
            self
        }
        /// <p>Whether to use the specified update behavior when the crawler finds a changed schema.</p>
        pub fn set_enable_update_catalog(mut self, input: std::option::Option<bool>) -> Self {
            self.enable_update_catalog = input;
            self
        }
        /// <p>The update behavior when the crawler finds a changed schema.</p>
        pub fn update_behavior(mut self, input: crate::model::UpdateCatalogBehavior) -> Self {
            self.update_behavior = Some(input);
            self
        }
        /// <p>The update behavior when the crawler finds a changed schema.</p>
        pub fn set_update_behavior(
            mut self,
            input: std::option::Option<crate::model::UpdateCatalogBehavior>,
        ) -> Self {
            self.update_behavior = input;
            self
        }
        /// Consumes the builder and constructs a [`CatalogSchemaChangePolicy`](crate::model::CatalogSchemaChangePolicy).
        pub fn build(self) -> crate::model::CatalogSchemaChangePolicy {
            crate::model::CatalogSchemaChangePolicy {
                enable_update_catalog: self.enable_update_catalog,
                update_behavior: self.update_behavior,
            }
        }
    }
}
impl CatalogSchemaChangePolicy {
    /// Creates a new builder-style object to manufacture [`CatalogSchemaChangePolicy`](crate::model::CatalogSchemaChangePolicy).
    pub fn builder() -> crate::model::catalog_schema_change_policy::Builder {
        crate::model::catalog_schema_change_policy::Builder::default()
    }
}

/// <p>Specifies a Hudi data source stored in Amazon S3.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct S3HudiSource {
    /// <p>The name of the Hudi source.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>A list of the Amazon S3 paths to read from.</p>
    #[doc(hidden)]
    pub paths: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Specifies additional connection options.</p>
    #[doc(hidden)]
    pub additional_hudi_options:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>Specifies additional connection options for the Amazon S3 data store.</p>
    #[doc(hidden)]
    pub additional_options: std::option::Option<crate::model::S3DirectSourceAdditionalOptions>,
    /// <p>Specifies the data schema for the Hudi source.</p>
    #[doc(hidden)]
    pub output_schemas: std::option::Option<std::vec::Vec<crate::model::GlueSchema>>,
}
impl S3HudiSource {
    /// <p>The name of the Hudi source.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>A list of the Amazon S3 paths to read from.</p>
    pub fn paths(&self) -> std::option::Option<&[std::string::String]> {
        self.paths.as_deref()
    }
    /// <p>Specifies additional connection options.</p>
    pub fn additional_hudi_options(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.additional_hudi_options.as_ref()
    }
    /// <p>Specifies additional connection options for the Amazon S3 data store.</p>
    pub fn additional_options(
        &self,
    ) -> std::option::Option<&crate::model::S3DirectSourceAdditionalOptions> {
        self.additional_options.as_ref()
    }
    /// <p>Specifies the data schema for the Hudi source.</p>
    pub fn output_schemas(&self) -> std::option::Option<&[crate::model::GlueSchema]> {
        self.output_schemas.as_deref()
    }
}
/// See [`S3HudiSource`](crate::model::S3HudiSource).
pub mod s3_hudi_source {

    /// A builder for [`S3HudiSource`](crate::model::S3HudiSource).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) paths: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) additional_hudi_options: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) additional_options:
            std::option::Option<crate::model::S3DirectSourceAdditionalOptions>,
        pub(crate) output_schemas: std::option::Option<std::vec::Vec<crate::model::GlueSchema>>,
    }
    impl Builder {
        /// <p>The name of the Hudi source.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the Hudi source.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Appends an item to `paths`.
        ///
        /// To override the contents of this collection use [`set_paths`](Self::set_paths).
        ///
        /// <p>A list of the Amazon S3 paths to read from.</p>
        pub fn paths(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.paths.unwrap_or_default();
            v.push(input.into());
            self.paths = Some(v);
            self
        }
        /// <p>A list of the Amazon S3 paths to read from.</p>
        pub fn set_paths(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.paths = input;
            self
        }
        /// Adds a key-value pair to `additional_hudi_options`.
        ///
        /// To override the contents of this collection use [`set_additional_hudi_options`](Self::set_additional_hudi_options).
        ///
        /// <p>Specifies additional connection options.</p>
        pub fn additional_hudi_options(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.additional_hudi_options.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.additional_hudi_options = Some(hash_map);
            self
        }
        /// <p>Specifies additional connection options.</p>
        pub fn set_additional_hudi_options(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.additional_hudi_options = input;
            self
        }
        /// <p>Specifies additional connection options for the Amazon S3 data store.</p>
        pub fn additional_options(
            mut self,
            input: crate::model::S3DirectSourceAdditionalOptions,
        ) -> Self {
            self.additional_options = Some(input);
            self
        }
        /// <p>Specifies additional connection options for the Amazon S3 data store.</p>
        pub fn set_additional_options(
            mut self,
            input: std::option::Option<crate::model::S3DirectSourceAdditionalOptions>,
        ) -> Self {
            self.additional_options = input;
            self
        }
        /// Appends an item to `output_schemas`.
        ///
        /// To override the contents of this collection use [`set_output_schemas`](Self::set_output_schemas).
        ///
        /// <p>Specifies the data schema for the Hudi source.</p>
        pub fn output_schemas(mut self, input: crate::model::GlueSchema) -> Self {
            let mut v = self.output_schemas.unwrap_or_default();
            v.push(input);
            self.output_schemas = Some(v);
            self
        }
        /// <p>Specifies the data schema for the Hudi source.</p>
        pub fn set_output_schemas(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::GlueSchema>>,
        ) -> Self {
            self.output_schemas = input;
            self
        }
        /// Consumes the builder and constructs a [`S3HudiSource`](crate::model::S3HudiSource).
        pub fn build(self) -> crate::model::S3HudiSource {
            crate::model::S3HudiSource {
                name: self.name,
                paths: self.paths,
                additional_hudi_options: self.additional_hudi_options,
                additional_options: self.additional_options,
                output_schemas: self.output_schemas,
            }
        }
    }
}
impl S3HudiSource {
    /// Creates a new builder-style object to manufacture [`S3HudiSource`](crate::model::S3HudiSource).
    pub fn builder() -> crate::model::s3_hudi_source::Builder {
        crate::model::s3_hudi_source::Builder::default()
    }
}

/// <p>Specifies a user-defined schema when a schema cannot be determined by Glue.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GlueSchema {
    /// <p>Specifies the column definitions that make up a Glue schema.</p>
    #[doc(hidden)]
    pub columns: std::option::Option<std::vec::Vec<crate::model::GlueStudioSchemaColumn>>,
}
impl GlueSchema {
    /// <p>Specifies the column definitions that make up a Glue schema.</p>
    pub fn columns(&self) -> std::option::Option<&[crate::model::GlueStudioSchemaColumn]> {
        self.columns.as_deref()
    }
}
/// See [`GlueSchema`](crate::model::GlueSchema).
pub mod glue_schema {

    /// A builder for [`GlueSchema`](crate::model::GlueSchema).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) columns:
            std::option::Option<std::vec::Vec<crate::model::GlueStudioSchemaColumn>>,
    }
    impl Builder {
        /// Appends an item to `columns`.
        ///
        /// To override the contents of this collection use [`set_columns`](Self::set_columns).
        ///
        /// <p>Specifies the column definitions that make up a Glue schema.</p>
        pub fn columns(mut self, input: crate::model::GlueStudioSchemaColumn) -> Self {
            let mut v = self.columns.unwrap_or_default();
            v.push(input);
            self.columns = Some(v);
            self
        }
        /// <p>Specifies the column definitions that make up a Glue schema.</p>
        pub fn set_columns(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::GlueStudioSchemaColumn>>,
        ) -> Self {
            self.columns = input;
            self
        }
        /// Consumes the builder and constructs a [`GlueSchema`](crate::model::GlueSchema).
        pub fn build(self) -> crate::model::GlueSchema {
            crate::model::GlueSchema {
                columns: self.columns,
            }
        }
    }
}
impl GlueSchema {
    /// Creates a new builder-style object to manufacture [`GlueSchema`](crate::model::GlueSchema).
    pub fn builder() -> crate::model::glue_schema::Builder {
        crate::model::glue_schema::Builder::default()
    }
}

/// <p>Specifies a single column in a Glue schema definition.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GlueStudioSchemaColumn {
    /// <p>The name of the column in the Glue Studio schema.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The hive type for this column in the Glue Studio schema.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<std::string::String>,
}
impl GlueStudioSchemaColumn {
    /// <p>The name of the column in the Glue Studio schema.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The hive type for this column in the Glue Studio schema.</p>
    pub fn r#type(&self) -> std::option::Option<&str> {
        self.r#type.as_deref()
    }
}
/// See [`GlueStudioSchemaColumn`](crate::model::GlueStudioSchemaColumn).
pub mod glue_studio_schema_column {

    /// A builder for [`GlueStudioSchemaColumn`](crate::model::GlueStudioSchemaColumn).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the column in the Glue Studio schema.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the column in the Glue Studio schema.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The hive type for this column in the Glue Studio schema.</p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        /// <p>The hive type for this column in the Glue Studio schema.</p>
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// Consumes the builder and constructs a [`GlueStudioSchemaColumn`](crate::model::GlueStudioSchemaColumn).
        pub fn build(self) -> crate::model::GlueStudioSchemaColumn {
            crate::model::GlueStudioSchemaColumn {
                name: self.name,
                r#type: self.r#type,
            }
        }
    }
}
impl GlueStudioSchemaColumn {
    /// Creates a new builder-style object to manufacture [`GlueStudioSchemaColumn`](crate::model::GlueStudioSchemaColumn).
    pub fn builder() -> crate::model::glue_studio_schema_column::Builder {
        crate::model::glue_studio_schema_column::Builder::default()
    }
}

/// <p>Specifies additional connection options for the Amazon S3 data store.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct S3DirectSourceAdditionalOptions {
    /// <p>Sets the upper limit for the target size of the dataset in bytes that will be processed.</p>
    #[doc(hidden)]
    pub bounded_size: std::option::Option<i64>,
    /// <p>Sets the upper limit for the target number of files that will be processed.</p>
    #[doc(hidden)]
    pub bounded_files: std::option::Option<i64>,
    /// <p>Sets option to enable a sample path.</p>
    #[doc(hidden)]
    pub enable_sample_path: std::option::Option<bool>,
    /// <p>If enabled, specifies the sample path.</p>
    #[doc(hidden)]
    pub sample_path: std::option::Option<std::string::String>,
}
impl S3DirectSourceAdditionalOptions {
    /// <p>Sets the upper limit for the target size of the dataset in bytes that will be processed.</p>
    pub fn bounded_size(&self) -> std::option::Option<i64> {
        self.bounded_size
    }
    /// <p>Sets the upper limit for the target number of files that will be processed.</p>
    pub fn bounded_files(&self) -> std::option::Option<i64> {
        self.bounded_files
    }
    /// <p>Sets option to enable a sample path.</p>
    pub fn enable_sample_path(&self) -> std::option::Option<bool> {
        self.enable_sample_path
    }
    /// <p>If enabled, specifies the sample path.</p>
    pub fn sample_path(&self) -> std::option::Option<&str> {
        self.sample_path.as_deref()
    }
}
/// See [`S3DirectSourceAdditionalOptions`](crate::model::S3DirectSourceAdditionalOptions).
pub mod s3_direct_source_additional_options {

    /// A builder for [`S3DirectSourceAdditionalOptions`](crate::model::S3DirectSourceAdditionalOptions).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bounded_size: std::option::Option<i64>,
        pub(crate) bounded_files: std::option::Option<i64>,
        pub(crate) enable_sample_path: std::option::Option<bool>,
        pub(crate) sample_path: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Sets the upper limit for the target size of the dataset in bytes that will be processed.</p>
        pub fn bounded_size(mut self, input: i64) -> Self {
            self.bounded_size = Some(input);
            self
        }
        /// <p>Sets the upper limit for the target size of the dataset in bytes that will be processed.</p>
        pub fn set_bounded_size(mut self, input: std::option::Option<i64>) -> Self {
            self.bounded_size = input;
            self
        }
        /// <p>Sets the upper limit for the target number of files that will be processed.</p>
        pub fn bounded_files(mut self, input: i64) -> Self {
            self.bounded_files = Some(input);
            self
        }
        /// <p>Sets the upper limit for the target number of files that will be processed.</p>
        pub fn set_bounded_files(mut self, input: std::option::Option<i64>) -> Self {
            self.bounded_files = input;
            self
        }
        /// <p>Sets option to enable a sample path.</p>
        pub fn enable_sample_path(mut self, input: bool) -> Self {
            self.enable_sample_path = Some(input);
            self
        }
        /// <p>Sets option to enable a sample path.</p>
        pub fn set_enable_sample_path(mut self, input: std::option::Option<bool>) -> Self {
            self.enable_sample_path = input;
            self
        }
        /// <p>If enabled, specifies the sample path.</p>
        pub fn sample_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.sample_path = Some(input.into());
            self
        }
        /// <p>If enabled, specifies the sample path.</p>
        pub fn set_sample_path(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.sample_path = input;
            self
        }
        /// Consumes the builder and constructs a [`S3DirectSourceAdditionalOptions`](crate::model::S3DirectSourceAdditionalOptions).
        pub fn build(self) -> crate::model::S3DirectSourceAdditionalOptions {
            crate::model::S3DirectSourceAdditionalOptions {
                bounded_size: self.bounded_size,
                bounded_files: self.bounded_files,
                enable_sample_path: self.enable_sample_path,
                sample_path: self.sample_path,
            }
        }
    }
}
impl S3DirectSourceAdditionalOptions {
    /// Creates a new builder-style object to manufacture [`S3DirectSourceAdditionalOptions`](crate::model::S3DirectSourceAdditionalOptions).
    pub fn builder() -> crate::model::s3_direct_source_additional_options::Builder {
        crate::model::s3_direct_source_additional_options::Builder::default()
    }
}

/// <p>Specifies a Hudi data source that is registered in the Glue Data Catalog.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CatalogHudiSource {
    /// <p>The name of the Hudi data source.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The name of the database to read from.</p>
    #[doc(hidden)]
    pub database: std::option::Option<std::string::String>,
    /// <p>The name of the table in the database to read from.</p>
    #[doc(hidden)]
    pub table: std::option::Option<std::string::String>,
    /// <p>Specifies additional connection options.</p>
    #[doc(hidden)]
    pub additional_hudi_options:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>Specifies the data schema for the Hudi source.</p>
    #[doc(hidden)]
    pub output_schemas: std::option::Option<std::vec::Vec<crate::model::GlueSchema>>,
}
impl CatalogHudiSource {
    /// <p>The name of the Hudi data source.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The name of the database to read from.</p>
    pub fn database(&self) -> std::option::Option<&str> {
        self.database.as_deref()
    }
    /// <p>The name of the table in the database to read from.</p>
    pub fn table(&self) -> std::option::Option<&str> {
        self.table.as_deref()
    }
    /// <p>Specifies additional connection options.</p>
    pub fn additional_hudi_options(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.additional_hudi_options.as_ref()
    }
    /// <p>Specifies the data schema for the Hudi source.</p>
    pub fn output_schemas(&self) -> std::option::Option<&[crate::model::GlueSchema]> {
        self.output_schemas.as_deref()
    }
}
/// See [`CatalogHudiSource`](crate::model::CatalogHudiSource).
pub mod catalog_hudi_source {

    /// A builder for [`CatalogHudiSource`](crate::model::CatalogHudiSource).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) database: std::option::Option<std::string::String>,
        pub(crate) table: std::option::Option<std::string::String>,
        pub(crate) additional_hudi_options: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) output_schemas: std::option::Option<std::vec::Vec<crate::model::GlueSchema>>,
    }
    impl Builder {
        /// <p>The name of the Hudi data source.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the Hudi data source.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The name of the database to read from.</p>
        pub fn database(mut self, input: impl Into<std::string::String>) -> Self {
            self.database = Some(input.into());
            self
        }
        /// <p>The name of the database to read from.</p>
        pub fn set_database(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.database = input;
            self
        }
        /// <p>The name of the table in the database to read from.</p>
        pub fn table(mut self, input: impl Into<std::string::String>) -> Self {
            self.table = Some(input.into());
            self
        }
        /// <p>The name of the table in the database to read from.</p>
        pub fn set_table(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.table = input;
            self
        }
        /// Adds a key-value pair to `additional_hudi_options`.
        ///
        /// To override the contents of this collection use [`set_additional_hudi_options`](Self::set_additional_hudi_options).
        ///
        /// <p>Specifies additional connection options.</p>
        pub fn additional_hudi_options(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.additional_hudi_options.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.additional_hudi_options = Some(hash_map);
            self
        }
        /// <p>Specifies additional connection options.</p>
        pub fn set_additional_hudi_options(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.additional_hudi_options = input;
            self
        }
        /// Appends an item to `output_schemas`.
        ///
        /// To override the contents of this collection use [`set_output_schemas`](Self::set_output_schemas).
        ///
        /// <p>Specifies the data schema for the Hudi source.</p>
        pub fn output_schemas(mut self, input: crate::model::GlueSchema) -> Self {
            let mut v = self.output_schemas.unwrap_or_default();
            v.push(input);
            self.output_schemas = Some(v);
            self
        }
        /// <p>Specifies the data schema for the Hudi source.</p>
        pub fn set_output_schemas(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::GlueSchema>>,
        ) -> Self {
            self.output_schemas = input;
            self
        }
        /// Consumes the builder and constructs a [`CatalogHudiSource`](crate::model::CatalogHudiSource).
        pub fn build(self) -> crate::model::CatalogHudiSource {
            crate::model::CatalogHudiSource {
                name: self.name,
                database: self.database,
                table: self.table,
                additional_hudi_options: self.additional_hudi_options,
                output_schemas: self.output_schemas,
            }
        }
    }
}
impl CatalogHudiSource {
    /// Creates a new builder-style object to manufacture [`CatalogHudiSource`](crate::model::CatalogHudiSource).
    pub fn builder() -> crate::model::catalog_hudi_source::Builder {
        crate::model::catalog_hudi_source::Builder::default()
    }
}

/// <p>Specifies a Hudi data source that is registered in the Glue Data Catalog. The Hudi data source must be stored in Amazon S3.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct S3CatalogHudiSource {
    /// <p>The name of the Hudi data source.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The name of the database to read from.</p>
    #[doc(hidden)]
    pub database: std::option::Option<std::string::String>,
    /// <p>The name of the table in the database to read from.</p>
    #[doc(hidden)]
    pub table: std::option::Option<std::string::String>,
    /// <p>Specifies additional connection options.</p>
    #[doc(hidden)]
    pub additional_hudi_options:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>Specifies the data schema for the Hudi source.</p>
    #[doc(hidden)]
    pub output_schemas: std::option::Option<std::vec::Vec<crate::model::GlueSchema>>,
}
impl S3CatalogHudiSource {
    /// <p>The name of the Hudi data source.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The name of the database to read from.</p>
    pub fn database(&self) -> std::option::Option<&str> {
        self.database.as_deref()
    }
    /// <p>The name of the table in the database to read from.</p>
    pub fn table(&self) -> std::option::Option<&str> {
        self.table.as_deref()
    }
    /// <p>Specifies additional connection options.</p>
    pub fn additional_hudi_options(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.additional_hudi_options.as_ref()
    }
    /// <p>Specifies the data schema for the Hudi source.</p>
    pub fn output_schemas(&self) -> std::option::Option<&[crate::model::GlueSchema]> {
        self.output_schemas.as_deref()
    }
}
/// See [`S3CatalogHudiSource`](crate::model::S3CatalogHudiSource).
pub mod s3_catalog_hudi_source {

    /// A builder for [`S3CatalogHudiSource`](crate::model::S3CatalogHudiSource).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) database: std::option::Option<std::string::String>,
        pub(crate) table: std::option::Option<std::string::String>,
        pub(crate) additional_hudi_options: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) output_schemas: std::option::Option<std::vec::Vec<crate::model::GlueSchema>>,
    }
    impl Builder {
        /// <p>The name of the Hudi data source.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the Hudi data source.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The name of the database to read from.</p>
        pub fn database(mut self, input: impl Into<std::string::String>) -> Self {
            self.database = Some(input.into());
            self
        }
        /// <p>The name of the database to read from.</p>
        pub fn set_database(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.database = input;
            self
        }
        /// <p>The name of the table in the database to read from.</p>
        pub fn table(mut self, input: impl Into<std::string::String>) -> Self {
            self.table = Some(input.into());
            self
        }
        /// <p>The name of the table in the database to read from.</p>
        pub fn set_table(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.table = input;
            self
        }
        /// Adds a key-value pair to `additional_hudi_options`.
        ///
        /// To override the contents of this collection use [`set_additional_hudi_options`](Self::set_additional_hudi_options).
        ///
        /// <p>Specifies additional connection options.</p>
        pub fn additional_hudi_options(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.additional_hudi_options.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.additional_hudi_options = Some(hash_map);
            self
        }
        /// <p>Specifies additional connection options.</p>
        pub fn set_additional_hudi_options(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.additional_hudi_options = input;
            self
        }
        /// Appends an item to `output_schemas`.
        ///
        /// To override the contents of this collection use [`set_output_schemas`](Self::set_output_schemas).
        ///
        /// <p>Specifies the data schema for the Hudi source.</p>
        pub fn output_schemas(mut self, input: crate::model::GlueSchema) -> Self {
            let mut v = self.output_schemas.unwrap_or_default();
            v.push(input);
            self.output_schemas = Some(v);
            self
        }
        /// <p>Specifies the data schema for the Hudi source.</p>
        pub fn set_output_schemas(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::GlueSchema>>,
        ) -> Self {
            self.output_schemas = input;
            self
        }
        /// Consumes the builder and constructs a [`S3CatalogHudiSource`](crate::model::S3CatalogHudiSource).
        pub fn build(self) -> crate::model::S3CatalogHudiSource {
            crate::model::S3CatalogHudiSource {
                name: self.name,
                database: self.database,
                table: self.table,
                additional_hudi_options: self.additional_hudi_options,
                output_schemas: self.output_schemas,
            }
        }
    }
}
impl S3CatalogHudiSource {
    /// Creates a new builder-style object to manufacture [`S3CatalogHudiSource`](crate::model::S3CatalogHudiSource).
    pub fn builder() -> crate::model::s3_catalog_hudi_source::Builder {
        crate::model::s3_catalog_hudi_source::Builder::default()
    }
}

/// <p>Specifies your data quality evaluation criteria.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct EvaluateDataQuality {
    /// <p>The name of the data quality evaluation.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The inputs of your data quality evaluation.</p>
    #[doc(hidden)]
    pub inputs: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The ruleset for your data quality evaluation.</p>
    #[doc(hidden)]
    pub ruleset: std::option::Option<std::string::String>,
    /// <p>The output of your data quality evaluation.</p>
    #[doc(hidden)]
    pub output: std::option::Option<crate::model::DqTransformOutput>,
    /// <p>Options to configure how your results are published.</p>
    #[doc(hidden)]
    pub publishing_options: std::option::Option<crate::model::DqResultsPublishingOptions>,
    /// <p>Options to configure how your job will stop if your data quality evaluation fails.</p>
    #[doc(hidden)]
    pub stop_job_on_failure_options: std::option::Option<crate::model::DqStopJobOnFailureOptions>,
}
impl EvaluateDataQuality {
    /// <p>The name of the data quality evaluation.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The inputs of your data quality evaluation.</p>
    pub fn inputs(&self) -> std::option::Option<&[std::string::String]> {
        self.inputs.as_deref()
    }
    /// <p>The ruleset for your data quality evaluation.</p>
    pub fn ruleset(&self) -> std::option::Option<&str> {
        self.ruleset.as_deref()
    }
    /// <p>The output of your data quality evaluation.</p>
    pub fn output(&self) -> std::option::Option<&crate::model::DqTransformOutput> {
        self.output.as_ref()
    }
    /// <p>Options to configure how your results are published.</p>
    pub fn publishing_options(
        &self,
    ) -> std::option::Option<&crate::model::DqResultsPublishingOptions> {
        self.publishing_options.as_ref()
    }
    /// <p>Options to configure how your job will stop if your data quality evaluation fails.</p>
    pub fn stop_job_on_failure_options(
        &self,
    ) -> std::option::Option<&crate::model::DqStopJobOnFailureOptions> {
        self.stop_job_on_failure_options.as_ref()
    }
}
/// See [`EvaluateDataQuality`](crate::model::EvaluateDataQuality).
pub mod evaluate_data_quality {

    /// A builder for [`EvaluateDataQuality`](crate::model::EvaluateDataQuality).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) inputs: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) ruleset: std::option::Option<std::string::String>,
        pub(crate) output: std::option::Option<crate::model::DqTransformOutput>,
        pub(crate) publishing_options:
            std::option::Option<crate::model::DqResultsPublishingOptions>,
        pub(crate) stop_job_on_failure_options:
            std::option::Option<crate::model::DqStopJobOnFailureOptions>,
    }
    impl Builder {
        /// <p>The name of the data quality evaluation.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the data quality evaluation.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Appends an item to `inputs`.
        ///
        /// To override the contents of this collection use [`set_inputs`](Self::set_inputs).
        ///
        /// <p>The inputs of your data quality evaluation.</p>
        pub fn inputs(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.inputs.unwrap_or_default();
            v.push(input.into());
            self.inputs = Some(v);
            self
        }
        /// <p>The inputs of your data quality evaluation.</p>
        pub fn set_inputs(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inputs = input;
            self
        }
        /// <p>The ruleset for your data quality evaluation.</p>
        pub fn ruleset(mut self, input: impl Into<std::string::String>) -> Self {
            self.ruleset = Some(input.into());
            self
        }
        /// <p>The ruleset for your data quality evaluation.</p>
        pub fn set_ruleset(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.ruleset = input;
            self
        }
        /// <p>The output of your data quality evaluation.</p>
        pub fn output(mut self, input: crate::model::DqTransformOutput) -> Self {
            self.output = Some(input);
            self
        }
        /// <p>The output of your data quality evaluation.</p>
        pub fn set_output(
            mut self,
            input: std::option::Option<crate::model::DqTransformOutput>,
        ) -> Self {
            self.output = input;
            self
        }
        /// <p>Options to configure how your results are published.</p>
        pub fn publishing_options(
            mut self,
            input: crate::model::DqResultsPublishingOptions,
        ) -> Self {
            self.publishing_options = Some(input);
            self
        }
        /// <p>Options to configure how your results are published.</p>
        pub fn set_publishing_options(
            mut self,
            input: std::option::Option<crate::model::DqResultsPublishingOptions>,
        ) -> Self {
            self.publishing_options = input;
            self
        }
        /// <p>Options to configure how your job will stop if your data quality evaluation fails.</p>
        pub fn stop_job_on_failure_options(
            mut self,
            input: crate::model::DqStopJobOnFailureOptions,
        ) -> Self {
            self.stop_job_on_failure_options = Some(input);
            self
        }
        /// <p>Options to configure how your job will stop if your data quality evaluation fails.</p>
        pub fn set_stop_job_on_failure_options(
            mut self,
            input: std::option::Option<crate::model::DqStopJobOnFailureOptions>,
        ) -> Self {
            self.stop_job_on_failure_options = input;
            self
        }
        /// Consumes the builder and constructs a [`EvaluateDataQuality`](crate::model::EvaluateDataQuality).
        pub fn build(self) -> crate::model::EvaluateDataQuality {
            crate::model::EvaluateDataQuality {
                name: self.name,
                inputs: self.inputs,
                ruleset: self.ruleset,
                output: self.output,
                publishing_options: self.publishing_options,
                stop_job_on_failure_options: self.stop_job_on_failure_options,
            }
        }
    }
}
impl EvaluateDataQuality {
    /// Creates a new builder-style object to manufacture [`EvaluateDataQuality`](crate::model::EvaluateDataQuality).
    pub fn builder() -> crate::model::evaluate_data_quality::Builder {
        crate::model::evaluate_data_quality::Builder::default()
    }
}

/// <p>Options to configure how your job will stop if your data quality evaluation fails.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DqStopJobOnFailureOptions {
    /// <p>When to stop job if your data quality evaluation fails. Options are Immediate or AfterDataLoad.</p>
    #[doc(hidden)]
    pub stop_job_on_failure_timing: std::option::Option<crate::model::DqStopJobOnFailureTiming>,
}
impl DqStopJobOnFailureOptions {
    /// <p>When to stop job if your data quality evaluation fails. Options are Immediate or AfterDataLoad.</p>
    pub fn stop_job_on_failure_timing(
        &self,
    ) -> std::option::Option<&crate::model::DqStopJobOnFailureTiming> {
        self.stop_job_on_failure_timing.as_ref()
    }
}
/// See [`DqStopJobOnFailureOptions`](crate::model::DqStopJobOnFailureOptions).
pub mod dq_stop_job_on_failure_options {

    /// A builder for [`DqStopJobOnFailureOptions`](crate::model::DqStopJobOnFailureOptions).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) stop_job_on_failure_timing:
            std::option::Option<crate::model::DqStopJobOnFailureTiming>,
    }
    impl Builder {
        /// <p>When to stop job if your data quality evaluation fails. Options are Immediate or AfterDataLoad.</p>
        pub fn stop_job_on_failure_timing(
            mut self,
            input: crate::model::DqStopJobOnFailureTiming,
        ) -> Self {
            self.stop_job_on_failure_timing = Some(input);
            self
        }
        /// <p>When to stop job if your data quality evaluation fails. Options are Immediate or AfterDataLoad.</p>
        pub fn set_stop_job_on_failure_timing(
            mut self,
            input: std::option::Option<crate::model::DqStopJobOnFailureTiming>,
        ) -> Self {
            self.stop_job_on_failure_timing = input;
            self
        }
        /// Consumes the builder and constructs a [`DqStopJobOnFailureOptions`](crate::model::DqStopJobOnFailureOptions).
        pub fn build(self) -> crate::model::DqStopJobOnFailureOptions {
            crate::model::DqStopJobOnFailureOptions {
                stop_job_on_failure_timing: self.stop_job_on_failure_timing,
            }
        }
    }
}
impl DqStopJobOnFailureOptions {
    /// Creates a new builder-style object to manufacture [`DqStopJobOnFailureOptions`](crate::model::DqStopJobOnFailureOptions).
    pub fn builder() -> crate::model::dq_stop_job_on_failure_options::Builder {
        crate::model::dq_stop_job_on_failure_options::Builder::default()
    }
}

/// When writing a match expression against `DqStopJobOnFailureTiming`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let dqstopjobonfailuretiming = unimplemented!();
/// match dqstopjobonfailuretiming {
///     DqStopJobOnFailureTiming::AfterDataLoad => { /* ... */ },
///     DqStopJobOnFailureTiming::Immediate => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `dqstopjobonfailuretiming` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `DqStopJobOnFailureTiming::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `DqStopJobOnFailureTiming::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `DqStopJobOnFailureTiming::NewFeature` is defined.
/// Specifically, when `dqstopjobonfailuretiming` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `DqStopJobOnFailureTiming::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DqStopJobOnFailureTiming {
    #[allow(missing_docs)] // documentation missing in model
    AfterDataLoad,
    #[allow(missing_docs)] // documentation missing in model
    Immediate,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for DqStopJobOnFailureTiming {
    fn from(s: &str) -> Self {
        match s {
            "AfterDataLoad" => DqStopJobOnFailureTiming::AfterDataLoad,
            "Immediate" => DqStopJobOnFailureTiming::Immediate,
            other => DqStopJobOnFailureTiming::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for DqStopJobOnFailureTiming {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DqStopJobOnFailureTiming::from(s))
    }
}
impl DqStopJobOnFailureTiming {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            DqStopJobOnFailureTiming::AfterDataLoad => "AfterDataLoad",
            DqStopJobOnFailureTiming::Immediate => "Immediate",
            DqStopJobOnFailureTiming::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["AfterDataLoad", "Immediate"]
    }
}
impl AsRef<str> for DqStopJobOnFailureTiming {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Options to configure how your data quality evaluation results are published.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DqResultsPublishingOptions {
    /// <p>The context of the evaluation.</p>
    #[doc(hidden)]
    pub evaluation_context: std::option::Option<std::string::String>,
    /// <p>The Amazon S3 prefix prepended to the results.</p>
    #[doc(hidden)]
    pub results_s3_prefix: std::option::Option<std::string::String>,
    /// <p>Enable metrics for your data quality results.</p>
    #[doc(hidden)]
    pub cloud_watch_metrics_enabled: std::option::Option<bool>,
    /// <p>Enable publishing for your data quality results.</p>
    #[doc(hidden)]
    pub results_publishing_enabled: std::option::Option<bool>,
}
impl DqResultsPublishingOptions {
    /// <p>The context of the evaluation.</p>
    pub fn evaluation_context(&self) -> std::option::Option<&str> {
        self.evaluation_context.as_deref()
    }
    /// <p>The Amazon S3 prefix prepended to the results.</p>
    pub fn results_s3_prefix(&self) -> std::option::Option<&str> {
        self.results_s3_prefix.as_deref()
    }
    /// <p>Enable metrics for your data quality results.</p>
    pub fn cloud_watch_metrics_enabled(&self) -> std::option::Option<bool> {
        self.cloud_watch_metrics_enabled
    }
    /// <p>Enable publishing for your data quality results.</p>
    pub fn results_publishing_enabled(&self) -> std::option::Option<bool> {
        self.results_publishing_enabled
    }
}
/// See [`DqResultsPublishingOptions`](crate::model::DqResultsPublishingOptions).
pub mod dq_results_publishing_options {

    /// A builder for [`DqResultsPublishingOptions`](crate::model::DqResultsPublishingOptions).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) evaluation_context: std::option::Option<std::string::String>,
        pub(crate) results_s3_prefix: std::option::Option<std::string::String>,
        pub(crate) cloud_watch_metrics_enabled: std::option::Option<bool>,
        pub(crate) results_publishing_enabled: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The context of the evaluation.</p>
        pub fn evaluation_context(mut self, input: impl Into<std::string::String>) -> Self {
            self.evaluation_context = Some(input.into());
            self
        }
        /// <p>The context of the evaluation.</p>
        pub fn set_evaluation_context(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.evaluation_context = input;
            self
        }
        /// <p>The Amazon S3 prefix prepended to the results.</p>
        pub fn results_s3_prefix(mut self, input: impl Into<std::string::String>) -> Self {
            self.results_s3_prefix = Some(input.into());
            self
        }
        /// <p>The Amazon S3 prefix prepended to the results.</p>
        pub fn set_results_s3_prefix(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.results_s3_prefix = input;
            self
        }
        /// <p>Enable metrics for your data quality results.</p>
        pub fn cloud_watch_metrics_enabled(mut self, input: bool) -> Self {
            self.cloud_watch_metrics_enabled = Some(input);
            self
        }
        /// <p>Enable metrics for your data quality results.</p>
        pub fn set_cloud_watch_metrics_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.cloud_watch_metrics_enabled = input;
            self
        }
        /// <p>Enable publishing for your data quality results.</p>
        pub fn results_publishing_enabled(mut self, input: bool) -> Self {
            self.results_publishing_enabled = Some(input);
            self
        }
        /// <p>Enable publishing for your data quality results.</p>
        pub fn set_results_publishing_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.results_publishing_enabled = input;
            self
        }
        /// Consumes the builder and constructs a [`DqResultsPublishingOptions`](crate::model::DqResultsPublishingOptions).
        pub fn build(self) -> crate::model::DqResultsPublishingOptions {
            crate::model::DqResultsPublishingOptions {
                evaluation_context: self.evaluation_context,
                results_s3_prefix: self.results_s3_prefix,
                cloud_watch_metrics_enabled: self.cloud_watch_metrics_enabled,
                results_publishing_enabled: self.results_publishing_enabled,
            }
        }
    }
}
impl DqResultsPublishingOptions {
    /// Creates a new builder-style object to manufacture [`DqResultsPublishingOptions`](crate::model::DqResultsPublishingOptions).
    pub fn builder() -> crate::model::dq_results_publishing_options::Builder {
        crate::model::dq_results_publishing_options::Builder::default()
    }
}

/// When writing a match expression against `DqTransformOutput`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let dqtransformoutput = unimplemented!();
/// match dqtransformoutput {
///     DqTransformOutput::EvaluationResults => { /* ... */ },
///     DqTransformOutput::PrimaryInput => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `dqtransformoutput` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `DqTransformOutput::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `DqTransformOutput::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `DqTransformOutput::NewFeature` is defined.
/// Specifically, when `dqtransformoutput` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `DqTransformOutput::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DqTransformOutput {
    #[allow(missing_docs)] // documentation missing in model
    EvaluationResults,
    #[allow(missing_docs)] // documentation missing in model
    PrimaryInput,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for DqTransformOutput {
    fn from(s: &str) -> Self {
        match s {
            "EvaluationResults" => DqTransformOutput::EvaluationResults,
            "PrimaryInput" => DqTransformOutput::PrimaryInput,
            other => {
                DqTransformOutput::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for DqTransformOutput {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DqTransformOutput::from(s))
    }
}
impl DqTransformOutput {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            DqTransformOutput::EvaluationResults => "EvaluationResults",
            DqTransformOutput::PrimaryInput => "PrimaryInput",
            DqTransformOutput::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["EvaluationResults", "PrimaryInput"]
    }
}
impl AsRef<str> for DqTransformOutput {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Specifies the set of parameters needed to perform the dynamic transform.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DynamicTransform {
    /// <p>Specifies the name of the dynamic transform.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>Specifies the name of the dynamic transform as it appears in the Glue Studio visual editor.</p>
    #[doc(hidden)]
    pub transform_name: std::option::Option<std::string::String>,
    /// <p>Specifies the inputs for the dynamic transform that are required.</p>
    #[doc(hidden)]
    pub inputs: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Specifies the parameters of the dynamic transform.</p>
    #[doc(hidden)]
    pub parameters: std::option::Option<std::vec::Vec<crate::model::TransformConfigParameter>>,
    /// <p>Specifies the name of the function of the dynamic transform.</p>
    #[doc(hidden)]
    pub function_name: std::option::Option<std::string::String>,
    /// <p>Specifies the path of the dynamic transform source and config files.</p>
    #[doc(hidden)]
    pub path: std::option::Option<std::string::String>,
    /// <p>This field is not used and will be deprecated in future release.</p>
    #[doc(hidden)]
    pub version: std::option::Option<std::string::String>,
}
impl DynamicTransform {
    /// <p>Specifies the name of the dynamic transform.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>Specifies the name of the dynamic transform as it appears in the Glue Studio visual editor.</p>
    pub fn transform_name(&self) -> std::option::Option<&str> {
        self.transform_name.as_deref()
    }
    /// <p>Specifies the inputs for the dynamic transform that are required.</p>
    pub fn inputs(&self) -> std::option::Option<&[std::string::String]> {
        self.inputs.as_deref()
    }
    /// <p>Specifies the parameters of the dynamic transform.</p>
    pub fn parameters(&self) -> std::option::Option<&[crate::model::TransformConfigParameter]> {
        self.parameters.as_deref()
    }
    /// <p>Specifies the name of the function of the dynamic transform.</p>
    pub fn function_name(&self) -> std::option::Option<&str> {
        self.function_name.as_deref()
    }
    /// <p>Specifies the path of the dynamic transform source and config files.</p>
    pub fn path(&self) -> std::option::Option<&str> {
        self.path.as_deref()
    }
    /// <p>This field is not used and will be deprecated in future release.</p>
    pub fn version(&self) -> std::option::Option<&str> {
        self.version.as_deref()
    }
}
/// See [`DynamicTransform`](crate::model::DynamicTransform).
pub mod dynamic_transform {

    /// A builder for [`DynamicTransform`](crate::model::DynamicTransform).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) transform_name: std::option::Option<std::string::String>,
        pub(crate) inputs: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) parameters:
            std::option::Option<std::vec::Vec<crate::model::TransformConfigParameter>>,
        pub(crate) function_name: std::option::Option<std::string::String>,
        pub(crate) path: std::option::Option<std::string::String>,
        pub(crate) version: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Specifies the name of the dynamic transform.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>Specifies the name of the dynamic transform.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>Specifies the name of the dynamic transform as it appears in the Glue Studio visual editor.</p>
        pub fn transform_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.transform_name = Some(input.into());
            self
        }
        /// <p>Specifies the name of the dynamic transform as it appears in the Glue Studio visual editor.</p>
        pub fn set_transform_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.transform_name = input;
            self
        }
        /// Appends an item to `inputs`.
        ///
        /// To override the contents of this collection use [`set_inputs`](Self::set_inputs).
        ///
        /// <p>Specifies the inputs for the dynamic transform that are required.</p>
        pub fn inputs(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.inputs.unwrap_or_default();
            v.push(input.into());
            self.inputs = Some(v);
            self
        }
        /// <p>Specifies the inputs for the dynamic transform that are required.</p>
        pub fn set_inputs(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inputs = input;
            self
        }
        /// Appends an item to `parameters`.
        ///
        /// To override the contents of this collection use [`set_parameters`](Self::set_parameters).
        ///
        /// <p>Specifies the parameters of the dynamic transform.</p>
        pub fn parameters(mut self, input: crate::model::TransformConfigParameter) -> Self {
            let mut v = self.parameters.unwrap_or_default();
            v.push(input);
            self.parameters = Some(v);
            self
        }
        /// <p>Specifies the parameters of the dynamic transform.</p>
        pub fn set_parameters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TransformConfigParameter>>,
        ) -> Self {
            self.parameters = input;
            self
        }
        /// <p>Specifies the name of the function of the dynamic transform.</p>
        pub fn function_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.function_name = Some(input.into());
            self
        }
        /// <p>Specifies the name of the function of the dynamic transform.</p>
        pub fn set_function_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.function_name = input;
            self
        }
        /// <p>Specifies the path of the dynamic transform source and config files.</p>
        pub fn path(mut self, input: impl Into<std::string::String>) -> Self {
            self.path = Some(input.into());
            self
        }
        /// <p>Specifies the path of the dynamic transform source and config files.</p>
        pub fn set_path(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.path = input;
            self
        }
        /// <p>This field is not used and will be deprecated in future release.</p>
        pub fn version(mut self, input: impl Into<std::string::String>) -> Self {
            self.version = Some(input.into());
            self
        }
        /// <p>This field is not used and will be deprecated in future release.</p>
        pub fn set_version(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.version = input;
            self
        }
        /// Consumes the builder and constructs a [`DynamicTransform`](crate::model::DynamicTransform).
        pub fn build(self) -> crate::model::DynamicTransform {
            crate::model::DynamicTransform {
                name: self.name,
                transform_name: self.transform_name,
                inputs: self.inputs,
                parameters: self.parameters,
                function_name: self.function_name,
                path: self.path,
                version: self.version,
            }
        }
    }
}
impl DynamicTransform {
    /// Creates a new builder-style object to manufacture [`DynamicTransform`](crate::model::DynamicTransform).
    pub fn builder() -> crate::model::dynamic_transform::Builder {
        crate::model::dynamic_transform::Builder::default()
    }
}

/// <p>Specifies the parameters in the config file of the dynamic transform.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TransformConfigParameter {
    /// <p>Specifies the name of the parameter in the config file of the dynamic transform.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>Specifies the parameter type in the config file of the dynamic transform.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::ParamType>,
    /// <p>Specifies the validation rule in the config file of the dynamic transform.</p>
    #[doc(hidden)]
    pub validation_rule: std::option::Option<std::string::String>,
    /// <p>Specifies the validation message in the config file of the dynamic transform.</p>
    #[doc(hidden)]
    pub validation_message: std::option::Option<std::string::String>,
    /// <p>Specifies the value of the parameter in the config file of the dynamic transform.</p>
    #[doc(hidden)]
    pub value: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Specifies the list type of the parameter in the config file of the dynamic transform.</p>
    #[doc(hidden)]
    pub list_type: std::option::Option<crate::model::ParamType>,
    /// <p>Specifies whether the parameter is optional or not in the config file of the dynamic transform.</p>
    #[doc(hidden)]
    pub is_optional: std::option::Option<bool>,
}
impl TransformConfigParameter {
    /// <p>Specifies the name of the parameter in the config file of the dynamic transform.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>Specifies the parameter type in the config file of the dynamic transform.</p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::ParamType> {
        self.r#type.as_ref()
    }
    /// <p>Specifies the validation rule in the config file of the dynamic transform.</p>
    pub fn validation_rule(&self) -> std::option::Option<&str> {
        self.validation_rule.as_deref()
    }
    /// <p>Specifies the validation message in the config file of the dynamic transform.</p>
    pub fn validation_message(&self) -> std::option::Option<&str> {
        self.validation_message.as_deref()
    }
    /// <p>Specifies the value of the parameter in the config file of the dynamic transform.</p>
    pub fn value(&self) -> std::option::Option<&[std::string::String]> {
        self.value.as_deref()
    }
    /// <p>Specifies the list type of the parameter in the config file of the dynamic transform.</p>
    pub fn list_type(&self) -> std::option::Option<&crate::model::ParamType> {
        self.list_type.as_ref()
    }
    /// <p>Specifies whether the parameter is optional or not in the config file of the dynamic transform.</p>
    pub fn is_optional(&self) -> std::option::Option<bool> {
        self.is_optional
    }
}
/// See [`TransformConfigParameter`](crate::model::TransformConfigParameter).
pub mod transform_config_parameter {

    /// A builder for [`TransformConfigParameter`](crate::model::TransformConfigParameter).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<crate::model::ParamType>,
        pub(crate) validation_rule: std::option::Option<std::string::String>,
        pub(crate) validation_message: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) list_type: std::option::Option<crate::model::ParamType>,
        pub(crate) is_optional: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>Specifies the name of the parameter in the config file of the dynamic transform.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>Specifies the name of the parameter in the config file of the dynamic transform.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>Specifies the parameter type in the config file of the dynamic transform.</p>
        pub fn r#type(mut self, input: crate::model::ParamType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>Specifies the parameter type in the config file of the dynamic transform.</p>
        pub fn set_type(mut self, input: std::option::Option<crate::model::ParamType>) -> Self {
            self.r#type = input;
            self
        }
        /// <p>Specifies the validation rule in the config file of the dynamic transform.</p>
        pub fn validation_rule(mut self, input: impl Into<std::string::String>) -> Self {
            self.validation_rule = Some(input.into());
            self
        }
        /// <p>Specifies the validation rule in the config file of the dynamic transform.</p>
        pub fn set_validation_rule(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.validation_rule = input;
            self
        }
        /// <p>Specifies the validation message in the config file of the dynamic transform.</p>
        pub fn validation_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.validation_message = Some(input.into());
            self
        }
        /// <p>Specifies the validation message in the config file of the dynamic transform.</p>
        pub fn set_validation_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.validation_message = input;
            self
        }
        /// Appends an item to `value`.
        ///
        /// To override the contents of this collection use [`set_value`](Self::set_value).
        ///
        /// <p>Specifies the value of the parameter in the config file of the dynamic transform.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.value.unwrap_or_default();
            v.push(input.into());
            self.value = Some(v);
            self
        }
        /// <p>Specifies the value of the parameter in the config file of the dynamic transform.</p>
        pub fn set_value(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.value = input;
            self
        }
        /// <p>Specifies the list type of the parameter in the config file of the dynamic transform.</p>
        pub fn list_type(mut self, input: crate::model::ParamType) -> Self {
            self.list_type = Some(input);
            self
        }
        /// <p>Specifies the list type of the parameter in the config file of the dynamic transform.</p>
        pub fn set_list_type(
            mut self,
            input: std::option::Option<crate::model::ParamType>,
        ) -> Self {
            self.list_type = input;
            self
        }
        /// <p>Specifies whether the parameter is optional or not in the config file of the dynamic transform.</p>
        pub fn is_optional(mut self, input: bool) -> Self {
            self.is_optional = Some(input);
            self
        }
        /// <p>Specifies whether the parameter is optional or not in the config file of the dynamic transform.</p>
        pub fn set_is_optional(mut self, input: std::option::Option<bool>) -> Self {
            self.is_optional = input;
            self
        }
        /// Consumes the builder and constructs a [`TransformConfigParameter`](crate::model::TransformConfigParameter).
        pub fn build(self) -> crate::model::TransformConfigParameter {
            crate::model::TransformConfigParameter {
                name: self.name,
                r#type: self.r#type,
                validation_rule: self.validation_rule,
                validation_message: self.validation_message,
                value: self.value,
                list_type: self.list_type,
                is_optional: self.is_optional,
            }
        }
    }
}
impl TransformConfigParameter {
    /// Creates a new builder-style object to manufacture [`TransformConfigParameter`](crate::model::TransformConfigParameter).
    pub fn builder() -> crate::model::transform_config_parameter::Builder {
        crate::model::transform_config_parameter::Builder::default()
    }
}

/// When writing a match expression against `ParamType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let paramtype = unimplemented!();
/// match paramtype {
///     ParamType::Bool => { /* ... */ },
///     ParamType::Complex => { /* ... */ },
///     ParamType::Float => { /* ... */ },
///     ParamType::Int => { /* ... */ },
///     ParamType::List => { /* ... */ },
///     ParamType::Null => { /* ... */ },
///     ParamType::Str => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `paramtype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ParamType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ParamType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ParamType::NewFeature` is defined.
/// Specifically, when `paramtype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ParamType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ParamType {
    #[allow(missing_docs)] // documentation missing in model
    Bool,
    #[allow(missing_docs)] // documentation missing in model
    Complex,
    #[allow(missing_docs)] // documentation missing in model
    Float,
    #[allow(missing_docs)] // documentation missing in model
    Int,
    #[allow(missing_docs)] // documentation missing in model
    List,
    #[allow(missing_docs)] // documentation missing in model
    Null,
    #[allow(missing_docs)] // documentation missing in model
    Str,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ParamType {
    fn from(s: &str) -> Self {
        match s {
            "bool" => ParamType::Bool,
            "complex" => ParamType::Complex,
            "float" => ParamType::Float,
            "int" => ParamType::Int,
            "list" => ParamType::List,
            "null" => ParamType::Null,
            "str" => ParamType::Str,
            other => ParamType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ParamType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ParamType::from(s))
    }
}
impl ParamType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ParamType::Bool => "bool",
            ParamType::Complex => "complex",
            ParamType::Float => "float",
            ParamType::Int => "int",
            ParamType::List => "list",
            ParamType::Null => "null",
            ParamType::Str => "str",
            ParamType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["bool", "complex", "float", "int", "list", "null", "str"]
    }
}
impl AsRef<str> for ParamType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Specifies a target that uses Postgres SQL.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PostgreSqlCatalogTarget {
    /// <p>The name of the data target.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The nodes that are inputs to the data target.</p>
    #[doc(hidden)]
    pub inputs: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The name of the database to write to.</p>
    #[doc(hidden)]
    pub database: std::option::Option<std::string::String>,
    /// <p>The name of the table in the database to write to.</p>
    #[doc(hidden)]
    pub table: std::option::Option<std::string::String>,
}
impl PostgreSqlCatalogTarget {
    /// <p>The name of the data target.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The nodes that are inputs to the data target.</p>
    pub fn inputs(&self) -> std::option::Option<&[std::string::String]> {
        self.inputs.as_deref()
    }
    /// <p>The name of the database to write to.</p>
    pub fn database(&self) -> std::option::Option<&str> {
        self.database.as_deref()
    }
    /// <p>The name of the table in the database to write to.</p>
    pub fn table(&self) -> std::option::Option<&str> {
        self.table.as_deref()
    }
}
/// See [`PostgreSqlCatalogTarget`](crate::model::PostgreSqlCatalogTarget).
pub mod postgre_sql_catalog_target {

    /// A builder for [`PostgreSqlCatalogTarget`](crate::model::PostgreSqlCatalogTarget).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) inputs: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) database: std::option::Option<std::string::String>,
        pub(crate) table: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the data target.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the data target.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Appends an item to `inputs`.
        ///
        /// To override the contents of this collection use [`set_inputs`](Self::set_inputs).
        ///
        /// <p>The nodes that are inputs to the data target.</p>
        pub fn inputs(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.inputs.unwrap_or_default();
            v.push(input.into());
            self.inputs = Some(v);
            self
        }
        /// <p>The nodes that are inputs to the data target.</p>
        pub fn set_inputs(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inputs = input;
            self
        }
        /// <p>The name of the database to write to.</p>
        pub fn database(mut self, input: impl Into<std::string::String>) -> Self {
            self.database = Some(input.into());
            self
        }
        /// <p>The name of the database to write to.</p>
        pub fn set_database(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.database = input;
            self
        }
        /// <p>The name of the table in the database to write to.</p>
        pub fn table(mut self, input: impl Into<std::string::String>) -> Self {
            self.table = Some(input.into());
            self
        }
        /// <p>The name of the table in the database to write to.</p>
        pub fn set_table(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.table = input;
            self
        }
        /// Consumes the builder and constructs a [`PostgreSqlCatalogTarget`](crate::model::PostgreSqlCatalogTarget).
        pub fn build(self) -> crate::model::PostgreSqlCatalogTarget {
            crate::model::PostgreSqlCatalogTarget {
                name: self.name,
                inputs: self.inputs,
                database: self.database,
                table: self.table,
            }
        }
    }
}
impl PostgreSqlCatalogTarget {
    /// Creates a new builder-style object to manufacture [`PostgreSqlCatalogTarget`](crate::model::PostgreSqlCatalogTarget).
    pub fn builder() -> crate::model::postgre_sql_catalog_target::Builder {
        crate::model::postgre_sql_catalog_target::Builder::default()
    }
}

/// <p>Specifies a target that uses Oracle SQL.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct OracleSqlCatalogTarget {
    /// <p>The name of the data target.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The nodes that are inputs to the data target.</p>
    #[doc(hidden)]
    pub inputs: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The name of the database to write to.</p>
    #[doc(hidden)]
    pub database: std::option::Option<std::string::String>,
    /// <p>The name of the table in the database to write to.</p>
    #[doc(hidden)]
    pub table: std::option::Option<std::string::String>,
}
impl OracleSqlCatalogTarget {
    /// <p>The name of the data target.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The nodes that are inputs to the data target.</p>
    pub fn inputs(&self) -> std::option::Option<&[std::string::String]> {
        self.inputs.as_deref()
    }
    /// <p>The name of the database to write to.</p>
    pub fn database(&self) -> std::option::Option<&str> {
        self.database.as_deref()
    }
    /// <p>The name of the table in the database to write to.</p>
    pub fn table(&self) -> std::option::Option<&str> {
        self.table.as_deref()
    }
}
/// See [`OracleSqlCatalogTarget`](crate::model::OracleSqlCatalogTarget).
pub mod oracle_sql_catalog_target {

    /// A builder for [`OracleSqlCatalogTarget`](crate::model::OracleSqlCatalogTarget).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) inputs: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) database: std::option::Option<std::string::String>,
        pub(crate) table: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the data target.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the data target.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Appends an item to `inputs`.
        ///
        /// To override the contents of this collection use [`set_inputs`](Self::set_inputs).
        ///
        /// <p>The nodes that are inputs to the data target.</p>
        pub fn inputs(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.inputs.unwrap_or_default();
            v.push(input.into());
            self.inputs = Some(v);
            self
        }
        /// <p>The nodes that are inputs to the data target.</p>
        pub fn set_inputs(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inputs = input;
            self
        }
        /// <p>The name of the database to write to.</p>
        pub fn database(mut self, input: impl Into<std::string::String>) -> Self {
            self.database = Some(input.into());
            self
        }
        /// <p>The name of the database to write to.</p>
        pub fn set_database(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.database = input;
            self
        }
        /// <p>The name of the table in the database to write to.</p>
        pub fn table(mut self, input: impl Into<std::string::String>) -> Self {
            self.table = Some(input.into());
            self
        }
        /// <p>The name of the table in the database to write to.</p>
        pub fn set_table(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.table = input;
            self
        }
        /// Consumes the builder and constructs a [`OracleSqlCatalogTarget`](crate::model::OracleSqlCatalogTarget).
        pub fn build(self) -> crate::model::OracleSqlCatalogTarget {
            crate::model::OracleSqlCatalogTarget {
                name: self.name,
                inputs: self.inputs,
                database: self.database,
                table: self.table,
            }
        }
    }
}
impl OracleSqlCatalogTarget {
    /// Creates a new builder-style object to manufacture [`OracleSqlCatalogTarget`](crate::model::OracleSqlCatalogTarget).
    pub fn builder() -> crate::model::oracle_sql_catalog_target::Builder {
        crate::model::oracle_sql_catalog_target::Builder::default()
    }
}

/// <p>Specifies a target that uses MySQL.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct MySqlCatalogTarget {
    /// <p>The name of the data target.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The nodes that are inputs to the data target.</p>
    #[doc(hidden)]
    pub inputs: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The name of the database to write to.</p>
    #[doc(hidden)]
    pub database: std::option::Option<std::string::String>,
    /// <p>The name of the table in the database to write to.</p>
    #[doc(hidden)]
    pub table: std::option::Option<std::string::String>,
}
impl MySqlCatalogTarget {
    /// <p>The name of the data target.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The nodes that are inputs to the data target.</p>
    pub fn inputs(&self) -> std::option::Option<&[std::string::String]> {
        self.inputs.as_deref()
    }
    /// <p>The name of the database to write to.</p>
    pub fn database(&self) -> std::option::Option<&str> {
        self.database.as_deref()
    }
    /// <p>The name of the table in the database to write to.</p>
    pub fn table(&self) -> std::option::Option<&str> {
        self.table.as_deref()
    }
}
/// See [`MySqlCatalogTarget`](crate::model::MySqlCatalogTarget).
pub mod my_sql_catalog_target {

    /// A builder for [`MySqlCatalogTarget`](crate::model::MySqlCatalogTarget).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) inputs: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) database: std::option::Option<std::string::String>,
        pub(crate) table: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the data target.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the data target.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Appends an item to `inputs`.
        ///
        /// To override the contents of this collection use [`set_inputs`](Self::set_inputs).
        ///
        /// <p>The nodes that are inputs to the data target.</p>
        pub fn inputs(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.inputs.unwrap_or_default();
            v.push(input.into());
            self.inputs = Some(v);
            self
        }
        /// <p>The nodes that are inputs to the data target.</p>
        pub fn set_inputs(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inputs = input;
            self
        }
        /// <p>The name of the database to write to.</p>
        pub fn database(mut self, input: impl Into<std::string::String>) -> Self {
            self.database = Some(input.into());
            self
        }
        /// <p>The name of the database to write to.</p>
        pub fn set_database(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.database = input;
            self
        }
        /// <p>The name of the table in the database to write to.</p>
        pub fn table(mut self, input: impl Into<std::string::String>) -> Self {
            self.table = Some(input.into());
            self
        }
        /// <p>The name of the table in the database to write to.</p>
        pub fn set_table(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.table = input;
            self
        }
        /// Consumes the builder and constructs a [`MySqlCatalogTarget`](crate::model::MySqlCatalogTarget).
        pub fn build(self) -> crate::model::MySqlCatalogTarget {
            crate::model::MySqlCatalogTarget {
                name: self.name,
                inputs: self.inputs,
                database: self.database,
                table: self.table,
            }
        }
    }
}
impl MySqlCatalogTarget {
    /// Creates a new builder-style object to manufacture [`MySqlCatalogTarget`](crate::model::MySqlCatalogTarget).
    pub fn builder() -> crate::model::my_sql_catalog_target::Builder {
        crate::model::my_sql_catalog_target::Builder::default()
    }
}

/// <p>Specifies a target that uses Microsoft SQL.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct MicrosoftSqlServerCatalogTarget {
    /// <p>The name of the data target.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The nodes that are inputs to the data target.</p>
    #[doc(hidden)]
    pub inputs: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The name of the database to write to.</p>
    #[doc(hidden)]
    pub database: std::option::Option<std::string::String>,
    /// <p>The name of the table in the database to write to.</p>
    #[doc(hidden)]
    pub table: std::option::Option<std::string::String>,
}
impl MicrosoftSqlServerCatalogTarget {
    /// <p>The name of the data target.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The nodes that are inputs to the data target.</p>
    pub fn inputs(&self) -> std::option::Option<&[std::string::String]> {
        self.inputs.as_deref()
    }
    /// <p>The name of the database to write to.</p>
    pub fn database(&self) -> std::option::Option<&str> {
        self.database.as_deref()
    }
    /// <p>The name of the table in the database to write to.</p>
    pub fn table(&self) -> std::option::Option<&str> {
        self.table.as_deref()
    }
}
/// See [`MicrosoftSqlServerCatalogTarget`](crate::model::MicrosoftSqlServerCatalogTarget).
pub mod microsoft_sql_server_catalog_target {

    /// A builder for [`MicrosoftSqlServerCatalogTarget`](crate::model::MicrosoftSqlServerCatalogTarget).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) inputs: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) database: std::option::Option<std::string::String>,
        pub(crate) table: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the data target.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the data target.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Appends an item to `inputs`.
        ///
        /// To override the contents of this collection use [`set_inputs`](Self::set_inputs).
        ///
        /// <p>The nodes that are inputs to the data target.</p>
        pub fn inputs(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.inputs.unwrap_or_default();
            v.push(input.into());
            self.inputs = Some(v);
            self
        }
        /// <p>The nodes that are inputs to the data target.</p>
        pub fn set_inputs(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inputs = input;
            self
        }
        /// <p>The name of the database to write to.</p>
        pub fn database(mut self, input: impl Into<std::string::String>) -> Self {
            self.database = Some(input.into());
            self
        }
        /// <p>The name of the database to write to.</p>
        pub fn set_database(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.database = input;
            self
        }
        /// <p>The name of the table in the database to write to.</p>
        pub fn table(mut self, input: impl Into<std::string::String>) -> Self {
            self.table = Some(input.into());
            self
        }
        /// <p>The name of the table in the database to write to.</p>
        pub fn set_table(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.table = input;
            self
        }
        /// Consumes the builder and constructs a [`MicrosoftSqlServerCatalogTarget`](crate::model::MicrosoftSqlServerCatalogTarget).
        pub fn build(self) -> crate::model::MicrosoftSqlServerCatalogTarget {
            crate::model::MicrosoftSqlServerCatalogTarget {
                name: self.name,
                inputs: self.inputs,
                database: self.database,
                table: self.table,
            }
        }
    }
}
impl MicrosoftSqlServerCatalogTarget {
    /// Creates a new builder-style object to manufacture [`MicrosoftSqlServerCatalogTarget`](crate::model::MicrosoftSqlServerCatalogTarget).
    pub fn builder() -> crate::model::microsoft_sql_server_catalog_target::Builder {
        crate::model::microsoft_sql_server_catalog_target::Builder::default()
    }
}

/// <p>Specifies a PostgresSQL data source in the Glue Data Catalog.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PostgreSqlCatalogSource {
    /// <p>The name of the data source.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The name of the database to read from.</p>
    #[doc(hidden)]
    pub database: std::option::Option<std::string::String>,
    /// <p>The name of the table in the database to read from.</p>
    #[doc(hidden)]
    pub table: std::option::Option<std::string::String>,
}
impl PostgreSqlCatalogSource {
    /// <p>The name of the data source.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The name of the database to read from.</p>
    pub fn database(&self) -> std::option::Option<&str> {
        self.database.as_deref()
    }
    /// <p>The name of the table in the database to read from.</p>
    pub fn table(&self) -> std::option::Option<&str> {
        self.table.as_deref()
    }
}
/// See [`PostgreSqlCatalogSource`](crate::model::PostgreSqlCatalogSource).
pub mod postgre_sql_catalog_source {

    /// A builder for [`PostgreSqlCatalogSource`](crate::model::PostgreSqlCatalogSource).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) database: std::option::Option<std::string::String>,
        pub(crate) table: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the data source.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the data source.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The name of the database to read from.</p>
        pub fn database(mut self, input: impl Into<std::string::String>) -> Self {
            self.database = Some(input.into());
            self
        }
        /// <p>The name of the database to read from.</p>
        pub fn set_database(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.database = input;
            self
        }
        /// <p>The name of the table in the database to read from.</p>
        pub fn table(mut self, input: impl Into<std::string::String>) -> Self {
            self.table = Some(input.into());
            self
        }
        /// <p>The name of the table in the database to read from.</p>
        pub fn set_table(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.table = input;
            self
        }
        /// Consumes the builder and constructs a [`PostgreSqlCatalogSource`](crate::model::PostgreSqlCatalogSource).
        pub fn build(self) -> crate::model::PostgreSqlCatalogSource {
            crate::model::PostgreSqlCatalogSource {
                name: self.name,
                database: self.database,
                table: self.table,
            }
        }
    }
}
impl PostgreSqlCatalogSource {
    /// Creates a new builder-style object to manufacture [`PostgreSqlCatalogSource`](crate::model::PostgreSqlCatalogSource).
    pub fn builder() -> crate::model::postgre_sql_catalog_source::Builder {
        crate::model::postgre_sql_catalog_source::Builder::default()
    }
}

/// <p>Specifies an Oracle data source in the Glue Data Catalog.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct OracleSqlCatalogSource {
    /// <p>The name of the data source.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The name of the database to read from.</p>
    #[doc(hidden)]
    pub database: std::option::Option<std::string::String>,
    /// <p>The name of the table in the database to read from.</p>
    #[doc(hidden)]
    pub table: std::option::Option<std::string::String>,
}
impl OracleSqlCatalogSource {
    /// <p>The name of the data source.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The name of the database to read from.</p>
    pub fn database(&self) -> std::option::Option<&str> {
        self.database.as_deref()
    }
    /// <p>The name of the table in the database to read from.</p>
    pub fn table(&self) -> std::option::Option<&str> {
        self.table.as_deref()
    }
}
/// See [`OracleSqlCatalogSource`](crate::model::OracleSqlCatalogSource).
pub mod oracle_sql_catalog_source {

    /// A builder for [`OracleSqlCatalogSource`](crate::model::OracleSqlCatalogSource).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) database: std::option::Option<std::string::String>,
        pub(crate) table: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the data source.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the data source.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The name of the database to read from.</p>
        pub fn database(mut self, input: impl Into<std::string::String>) -> Self {
            self.database = Some(input.into());
            self
        }
        /// <p>The name of the database to read from.</p>
        pub fn set_database(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.database = input;
            self
        }
        /// <p>The name of the table in the database to read from.</p>
        pub fn table(mut self, input: impl Into<std::string::String>) -> Self {
            self.table = Some(input.into());
            self
        }
        /// <p>The name of the table in the database to read from.</p>
        pub fn set_table(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.table = input;
            self
        }
        /// Consumes the builder and constructs a [`OracleSqlCatalogSource`](crate::model::OracleSqlCatalogSource).
        pub fn build(self) -> crate::model::OracleSqlCatalogSource {
            crate::model::OracleSqlCatalogSource {
                name: self.name,
                database: self.database,
                table: self.table,
            }
        }
    }
}
impl OracleSqlCatalogSource {
    /// Creates a new builder-style object to manufacture [`OracleSqlCatalogSource`](crate::model::OracleSqlCatalogSource).
    pub fn builder() -> crate::model::oracle_sql_catalog_source::Builder {
        crate::model::oracle_sql_catalog_source::Builder::default()
    }
}

/// <p>Specifies a MySQL data source in the Glue Data Catalog.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct MySqlCatalogSource {
    /// <p>The name of the data source.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The name of the database to read from.</p>
    #[doc(hidden)]
    pub database: std::option::Option<std::string::String>,
    /// <p>The name of the table in the database to read from.</p>
    #[doc(hidden)]
    pub table: std::option::Option<std::string::String>,
}
impl MySqlCatalogSource {
    /// <p>The name of the data source.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The name of the database to read from.</p>
    pub fn database(&self) -> std::option::Option<&str> {
        self.database.as_deref()
    }
    /// <p>The name of the table in the database to read from.</p>
    pub fn table(&self) -> std::option::Option<&str> {
        self.table.as_deref()
    }
}
/// See [`MySqlCatalogSource`](crate::model::MySqlCatalogSource).
pub mod my_sql_catalog_source {

    /// A builder for [`MySqlCatalogSource`](crate::model::MySqlCatalogSource).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) database: std::option::Option<std::string::String>,
        pub(crate) table: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the data source.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the data source.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The name of the database to read from.</p>
        pub fn database(mut self, input: impl Into<std::string::String>) -> Self {
            self.database = Some(input.into());
            self
        }
        /// <p>The name of the database to read from.</p>
        pub fn set_database(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.database = input;
            self
        }
        /// <p>The name of the table in the database to read from.</p>
        pub fn table(mut self, input: impl Into<std::string::String>) -> Self {
            self.table = Some(input.into());
            self
        }
        /// <p>The name of the table in the database to read from.</p>
        pub fn set_table(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.table = input;
            self
        }
        /// Consumes the builder and constructs a [`MySqlCatalogSource`](crate::model::MySqlCatalogSource).
        pub fn build(self) -> crate::model::MySqlCatalogSource {
            crate::model::MySqlCatalogSource {
                name: self.name,
                database: self.database,
                table: self.table,
            }
        }
    }
}
impl MySqlCatalogSource {
    /// Creates a new builder-style object to manufacture [`MySqlCatalogSource`](crate::model::MySqlCatalogSource).
    pub fn builder() -> crate::model::my_sql_catalog_source::Builder {
        crate::model::my_sql_catalog_source::Builder::default()
    }
}

/// <p>Specifies a Microsoft SQL server data source in the Glue Data Catalog.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct MicrosoftSqlServerCatalogSource {
    /// <p>The name of the data source.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The name of the database to read from.</p>
    #[doc(hidden)]
    pub database: std::option::Option<std::string::String>,
    /// <p>The name of the table in the database to read from.</p>
    #[doc(hidden)]
    pub table: std::option::Option<std::string::String>,
}
impl MicrosoftSqlServerCatalogSource {
    /// <p>The name of the data source.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The name of the database to read from.</p>
    pub fn database(&self) -> std::option::Option<&str> {
        self.database.as_deref()
    }
    /// <p>The name of the table in the database to read from.</p>
    pub fn table(&self) -> std::option::Option<&str> {
        self.table.as_deref()
    }
}
/// See [`MicrosoftSqlServerCatalogSource`](crate::model::MicrosoftSqlServerCatalogSource).
pub mod microsoft_sql_server_catalog_source {

    /// A builder for [`MicrosoftSqlServerCatalogSource`](crate::model::MicrosoftSqlServerCatalogSource).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) database: std::option::Option<std::string::String>,
        pub(crate) table: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the data source.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the data source.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The name of the database to read from.</p>
        pub fn database(mut self, input: impl Into<std::string::String>) -> Self {
            self.database = Some(input.into());
            self
        }
        /// <p>The name of the database to read from.</p>
        pub fn set_database(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.database = input;
            self
        }
        /// <p>The name of the table in the database to read from.</p>
        pub fn table(mut self, input: impl Into<std::string::String>) -> Self {
            self.table = Some(input.into());
            self
        }
        /// <p>The name of the table in the database to read from.</p>
        pub fn set_table(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.table = input;
            self
        }
        /// Consumes the builder and constructs a [`MicrosoftSqlServerCatalogSource`](crate::model::MicrosoftSqlServerCatalogSource).
        pub fn build(self) -> crate::model::MicrosoftSqlServerCatalogSource {
            crate::model::MicrosoftSqlServerCatalogSource {
                name: self.name,
                database: self.database,
                table: self.table,
            }
        }
    }
}
impl MicrosoftSqlServerCatalogSource {
    /// Creates a new builder-style object to manufacture [`MicrosoftSqlServerCatalogSource`](crate::model::MicrosoftSqlServerCatalogSource).
    pub fn builder() -> crate::model::microsoft_sql_server_catalog_source::Builder {
        crate::model::microsoft_sql_server_catalog_source::Builder::default()
    }
}

/// <p>Specifies the data store in the governed Glue Data Catalog.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GovernedCatalogSource {
    /// <p>The name of the data store.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The database to read from.</p>
    #[doc(hidden)]
    pub database: std::option::Option<std::string::String>,
    /// <p>The database table to read from.</p>
    #[doc(hidden)]
    pub table: std::option::Option<std::string::String>,
    /// <p>Partitions satisfying this predicate are deleted. Files within the retention period in these partitions are not deleted. Set to <code>""</code> – empty by default.</p>
    #[doc(hidden)]
    pub partition_predicate: std::option::Option<std::string::String>,
    /// <p>Specifies additional connection options.</p>
    #[doc(hidden)]
    pub additional_options: std::option::Option<crate::model::S3SourceAdditionalOptions>,
}
impl GovernedCatalogSource {
    /// <p>The name of the data store.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The database to read from.</p>
    pub fn database(&self) -> std::option::Option<&str> {
        self.database.as_deref()
    }
    /// <p>The database table to read from.</p>
    pub fn table(&self) -> std::option::Option<&str> {
        self.table.as_deref()
    }
    /// <p>Partitions satisfying this predicate are deleted. Files within the retention period in these partitions are not deleted. Set to <code>""</code> – empty by default.</p>
    pub fn partition_predicate(&self) -> std::option::Option<&str> {
        self.partition_predicate.as_deref()
    }
    /// <p>Specifies additional connection options.</p>
    pub fn additional_options(
        &self,
    ) -> std::option::Option<&crate::model::S3SourceAdditionalOptions> {
        self.additional_options.as_ref()
    }
}
/// See [`GovernedCatalogSource`](crate::model::GovernedCatalogSource).
pub mod governed_catalog_source {

    /// A builder for [`GovernedCatalogSource`](crate::model::GovernedCatalogSource).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) database: std::option::Option<std::string::String>,
        pub(crate) table: std::option::Option<std::string::String>,
        pub(crate) partition_predicate: std::option::Option<std::string::String>,
        pub(crate) additional_options: std::option::Option<crate::model::S3SourceAdditionalOptions>,
    }
    impl Builder {
        /// <p>The name of the data store.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the data store.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The database to read from.</p>
        pub fn database(mut self, input: impl Into<std::string::String>) -> Self {
            self.database = Some(input.into());
            self
        }
        /// <p>The database to read from.</p>
        pub fn set_database(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.database = input;
            self
        }
        /// <p>The database table to read from.</p>
        pub fn table(mut self, input: impl Into<std::string::String>) -> Self {
            self.table = Some(input.into());
            self
        }
        /// <p>The database table to read from.</p>
        pub fn set_table(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.table = input;
            self
        }
        /// <p>Partitions satisfying this predicate are deleted. Files within the retention period in these partitions are not deleted. Set to <code>""</code> – empty by default.</p>
        pub fn partition_predicate(mut self, input: impl Into<std::string::String>) -> Self {
            self.partition_predicate = Some(input.into());
            self
        }
        /// <p>Partitions satisfying this predicate are deleted. Files within the retention period in these partitions are not deleted. Set to <code>""</code> – empty by default.</p>
        pub fn set_partition_predicate(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.partition_predicate = input;
            self
        }
        /// <p>Specifies additional connection options.</p>
        pub fn additional_options(
            mut self,
            input: crate::model::S3SourceAdditionalOptions,
        ) -> Self {
            self.additional_options = Some(input);
            self
        }
        /// <p>Specifies additional connection options.</p>
        pub fn set_additional_options(
            mut self,
            input: std::option::Option<crate::model::S3SourceAdditionalOptions>,
        ) -> Self {
            self.additional_options = input;
            self
        }
        /// Consumes the builder and constructs a [`GovernedCatalogSource`](crate::model::GovernedCatalogSource).
        pub fn build(self) -> crate::model::GovernedCatalogSource {
            crate::model::GovernedCatalogSource {
                name: self.name,
                database: self.database,
                table: self.table,
                partition_predicate: self.partition_predicate,
                additional_options: self.additional_options,
            }
        }
    }
}
impl GovernedCatalogSource {
    /// Creates a new builder-style object to manufacture [`GovernedCatalogSource`](crate::model::GovernedCatalogSource).
    pub fn builder() -> crate::model::governed_catalog_source::Builder {
        crate::model::governed_catalog_source::Builder::default()
    }
}

/// <p>Specifies additional connection options for the Amazon S3 data store.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct S3SourceAdditionalOptions {
    /// <p>Sets the upper limit for the target size of the dataset in bytes that will be processed.</p>
    #[doc(hidden)]
    pub bounded_size: std::option::Option<i64>,
    /// <p>Sets the upper limit for the target number of files that will be processed.</p>
    #[doc(hidden)]
    pub bounded_files: std::option::Option<i64>,
}
impl S3SourceAdditionalOptions {
    /// <p>Sets the upper limit for the target size of the dataset in bytes that will be processed.</p>
    pub fn bounded_size(&self) -> std::option::Option<i64> {
        self.bounded_size
    }
    /// <p>Sets the upper limit for the target number of files that will be processed.</p>
    pub fn bounded_files(&self) -> std::option::Option<i64> {
        self.bounded_files
    }
}
/// See [`S3SourceAdditionalOptions`](crate::model::S3SourceAdditionalOptions).
pub mod s3_source_additional_options {

    /// A builder for [`S3SourceAdditionalOptions`](crate::model::S3SourceAdditionalOptions).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bounded_size: std::option::Option<i64>,
        pub(crate) bounded_files: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>Sets the upper limit for the target size of the dataset in bytes that will be processed.</p>
        pub fn bounded_size(mut self, input: i64) -> Self {
            self.bounded_size = Some(input);
            self
        }
        /// <p>Sets the upper limit for the target size of the dataset in bytes that will be processed.</p>
        pub fn set_bounded_size(mut self, input: std::option::Option<i64>) -> Self {
            self.bounded_size = input;
            self
        }
        /// <p>Sets the upper limit for the target number of files that will be processed.</p>
        pub fn bounded_files(mut self, input: i64) -> Self {
            self.bounded_files = Some(input);
            self
        }
        /// <p>Sets the upper limit for the target number of files that will be processed.</p>
        pub fn set_bounded_files(mut self, input: std::option::Option<i64>) -> Self {
            self.bounded_files = input;
            self
        }
        /// Consumes the builder and constructs a [`S3SourceAdditionalOptions`](crate::model::S3SourceAdditionalOptions).
        pub fn build(self) -> crate::model::S3SourceAdditionalOptions {
            crate::model::S3SourceAdditionalOptions {
                bounded_size: self.bounded_size,
                bounded_files: self.bounded_files,
            }
        }
    }
}
impl S3SourceAdditionalOptions {
    /// Creates a new builder-style object to manufacture [`S3SourceAdditionalOptions`](crate::model::S3SourceAdditionalOptions).
    pub fn builder() -> crate::model::s3_source_additional_options::Builder {
        crate::model::s3_source_additional_options::Builder::default()
    }
}

/// <p>Specifies a data target that writes to Amazon S3 using the Glue Data Catalog.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GovernedCatalogTarget {
    /// <p>The name of the data target.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The nodes that are inputs to the data target.</p>
    #[doc(hidden)]
    pub inputs: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Specifies native partitioning using a sequence of keys.</p>
    #[doc(hidden)]
    pub partition_keys: std::option::Option<std::vec::Vec<std::vec::Vec<std::string::String>>>,
    /// <p>The name of the table in the database to write to.</p>
    #[doc(hidden)]
    pub table: std::option::Option<std::string::String>,
    /// <p>The name of the database to write to.</p>
    #[doc(hidden)]
    pub database: std::option::Option<std::string::String>,
    /// <p>A policy that specifies update behavior for the governed catalog.</p>
    #[doc(hidden)]
    pub schema_change_policy: std::option::Option<crate::model::CatalogSchemaChangePolicy>,
}
impl GovernedCatalogTarget {
    /// <p>The name of the data target.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The nodes that are inputs to the data target.</p>
    pub fn inputs(&self) -> std::option::Option<&[std::string::String]> {
        self.inputs.as_deref()
    }
    /// <p>Specifies native partitioning using a sequence of keys.</p>
    pub fn partition_keys(&self) -> std::option::Option<&[std::vec::Vec<std::string::String>]> {
        self.partition_keys.as_deref()
    }
    /// <p>The name of the table in the database to write to.</p>
    pub fn table(&self) -> std::option::Option<&str> {
        self.table.as_deref()
    }
    /// <p>The name of the database to write to.</p>
    pub fn database(&self) -> std::option::Option<&str> {
        self.database.as_deref()
    }
    /// <p>A policy that specifies update behavior for the governed catalog.</p>
    pub fn schema_change_policy(
        &self,
    ) -> std::option::Option<&crate::model::CatalogSchemaChangePolicy> {
        self.schema_change_policy.as_ref()
    }
}
/// See [`GovernedCatalogTarget`](crate::model::GovernedCatalogTarget).
pub mod governed_catalog_target {

    /// A builder for [`GovernedCatalogTarget`](crate::model::GovernedCatalogTarget).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) inputs: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) partition_keys:
            std::option::Option<std::vec::Vec<std::vec::Vec<std::string::String>>>,
        pub(crate) table: std::option::Option<std::string::String>,
        pub(crate) database: std::option::Option<std::string::String>,
        pub(crate) schema_change_policy:
            std::option::Option<crate::model::CatalogSchemaChangePolicy>,
    }
    impl Builder {
        /// <p>The name of the data target.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the data target.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Appends an item to `inputs`.
        ///
        /// To override the contents of this collection use [`set_inputs`](Self::set_inputs).
        ///
        /// <p>The nodes that are inputs to the data target.</p>
        pub fn inputs(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.inputs.unwrap_or_default();
            v.push(input.into());
            self.inputs = Some(v);
            self
        }
        /// <p>The nodes that are inputs to the data target.</p>
        pub fn set_inputs(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inputs = input;
            self
        }
        /// Appends an item to `partition_keys`.
        ///
        /// To override the contents of this collection use [`set_partition_keys`](Self::set_partition_keys).
        ///
        /// <p>Specifies native partitioning using a sequence of keys.</p>
        pub fn partition_keys(mut self, input: std::vec::Vec<std::string::String>) -> Self {
            let mut v = self.partition_keys.unwrap_or_default();
            v.push(input);
            self.partition_keys = Some(v);
            self
        }
        /// <p>Specifies native partitioning using a sequence of keys.</p>
        pub fn set_partition_keys(
            mut self,
            input: std::option::Option<std::vec::Vec<std::vec::Vec<std::string::String>>>,
        ) -> Self {
            self.partition_keys = input;
            self
        }
        /// <p>The name of the table in the database to write to.</p>
        pub fn table(mut self, input: impl Into<std::string::String>) -> Self {
            self.table = Some(input.into());
            self
        }
        /// <p>The name of the table in the database to write to.</p>
        pub fn set_table(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.table = input;
            self
        }
        /// <p>The name of the database to write to.</p>
        pub fn database(mut self, input: impl Into<std::string::String>) -> Self {
            self.database = Some(input.into());
            self
        }
        /// <p>The name of the database to write to.</p>
        pub fn set_database(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.database = input;
            self
        }
        /// <p>A policy that specifies update behavior for the governed catalog.</p>
        pub fn schema_change_policy(
            mut self,
            input: crate::model::CatalogSchemaChangePolicy,
        ) -> Self {
            self.schema_change_policy = Some(input);
            self
        }
        /// <p>A policy that specifies update behavior for the governed catalog.</p>
        pub fn set_schema_change_policy(
            mut self,
            input: std::option::Option<crate::model::CatalogSchemaChangePolicy>,
        ) -> Self {
            self.schema_change_policy = input;
            self
        }
        /// Consumes the builder and constructs a [`GovernedCatalogTarget`](crate::model::GovernedCatalogTarget).
        pub fn build(self) -> crate::model::GovernedCatalogTarget {
            crate::model::GovernedCatalogTarget {
                name: self.name,
                inputs: self.inputs,
                partition_keys: self.partition_keys,
                table: self.table,
                database: self.database,
                schema_change_policy: self.schema_change_policy,
            }
        }
    }
}
impl GovernedCatalogTarget {
    /// Creates a new builder-style object to manufacture [`GovernedCatalogTarget`](crate::model::GovernedCatalogTarget).
    pub fn builder() -> crate::model::governed_catalog_target::Builder {
        crate::model::governed_catalog_target::Builder::default()
    }
}

/// <p>Specifies a transform that removes rows of repeating data from a data set. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DropDuplicates {
    /// <p>The name of the transform node.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The data inputs identified by their node names.</p>
    #[doc(hidden)]
    pub inputs: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The name of the columns to be merged or removed if repeating.</p>
    #[doc(hidden)]
    pub columns: std::option::Option<std::vec::Vec<std::vec::Vec<std::string::String>>>,
}
impl DropDuplicates {
    /// <p>The name of the transform node.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The data inputs identified by their node names.</p>
    pub fn inputs(&self) -> std::option::Option<&[std::string::String]> {
        self.inputs.as_deref()
    }
    /// <p>The name of the columns to be merged or removed if repeating.</p>
    pub fn columns(&self) -> std::option::Option<&[std::vec::Vec<std::string::String>]> {
        self.columns.as_deref()
    }
}
/// See [`DropDuplicates`](crate::model::DropDuplicates).
pub mod drop_duplicates {

    /// A builder for [`DropDuplicates`](crate::model::DropDuplicates).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) inputs: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) columns: std::option::Option<std::vec::Vec<std::vec::Vec<std::string::String>>>,
    }
    impl Builder {
        /// <p>The name of the transform node.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the transform node.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Appends an item to `inputs`.
        ///
        /// To override the contents of this collection use [`set_inputs`](Self::set_inputs).
        ///
        /// <p>The data inputs identified by their node names.</p>
        pub fn inputs(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.inputs.unwrap_or_default();
            v.push(input.into());
            self.inputs = Some(v);
            self
        }
        /// <p>The data inputs identified by their node names.</p>
        pub fn set_inputs(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inputs = input;
            self
        }
        /// Appends an item to `columns`.
        ///
        /// To override the contents of this collection use [`set_columns`](Self::set_columns).
        ///
        /// <p>The name of the columns to be merged or removed if repeating.</p>
        pub fn columns(mut self, input: std::vec::Vec<std::string::String>) -> Self {
            let mut v = self.columns.unwrap_or_default();
            v.push(input);
            self.columns = Some(v);
            self
        }
        /// <p>The name of the columns to be merged or removed if repeating.</p>
        pub fn set_columns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::vec::Vec<std::string::String>>>,
        ) -> Self {
            self.columns = input;
            self
        }
        /// Consumes the builder and constructs a [`DropDuplicates`](crate::model::DropDuplicates).
        pub fn build(self) -> crate::model::DropDuplicates {
            crate::model::DropDuplicates {
                name: self.name,
                inputs: self.inputs,
                columns: self.columns,
            }
        }
    }
}
impl DropDuplicates {
    /// Creates a new builder-style object to manufacture [`DropDuplicates`](crate::model::DropDuplicates).
    pub fn builder() -> crate::model::drop_duplicates::Builder {
        crate::model::drop_duplicates::Builder::default()
    }
}

/// <p>Specifies a transform that groups rows by chosen fields and computes the aggregated value by specified function.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Aggregate {
    /// <p>The name of the transform node.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>Specifies the fields and rows to use as inputs for the aggregate transform.</p>
    #[doc(hidden)]
    pub inputs: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Specifies the fields to group by.</p>
    #[doc(hidden)]
    pub groups: std::option::Option<std::vec::Vec<std::vec::Vec<std::string::String>>>,
    /// <p>Specifies the aggregate functions to be performed on specified fields. </p>
    #[doc(hidden)]
    pub aggs: std::option::Option<std::vec::Vec<crate::model::AggregateOperation>>,
}
impl Aggregate {
    /// <p>The name of the transform node.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>Specifies the fields and rows to use as inputs for the aggregate transform.</p>
    pub fn inputs(&self) -> std::option::Option<&[std::string::String]> {
        self.inputs.as_deref()
    }
    /// <p>Specifies the fields to group by.</p>
    pub fn groups(&self) -> std::option::Option<&[std::vec::Vec<std::string::String>]> {
        self.groups.as_deref()
    }
    /// <p>Specifies the aggregate functions to be performed on specified fields. </p>
    pub fn aggs(&self) -> std::option::Option<&[crate::model::AggregateOperation]> {
        self.aggs.as_deref()
    }
}
/// See [`Aggregate`](crate::model::Aggregate).
pub mod aggregate {

    /// A builder for [`Aggregate`](crate::model::Aggregate).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) inputs: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) groups: std::option::Option<std::vec::Vec<std::vec::Vec<std::string::String>>>,
        pub(crate) aggs: std::option::Option<std::vec::Vec<crate::model::AggregateOperation>>,
    }
    impl Builder {
        /// <p>The name of the transform node.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the transform node.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Appends an item to `inputs`.
        ///
        /// To override the contents of this collection use [`set_inputs`](Self::set_inputs).
        ///
        /// <p>Specifies the fields and rows to use as inputs for the aggregate transform.</p>
        pub fn inputs(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.inputs.unwrap_or_default();
            v.push(input.into());
            self.inputs = Some(v);
            self
        }
        /// <p>Specifies the fields and rows to use as inputs for the aggregate transform.</p>
        pub fn set_inputs(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inputs = input;
            self
        }
        /// Appends an item to `groups`.
        ///
        /// To override the contents of this collection use [`set_groups`](Self::set_groups).
        ///
        /// <p>Specifies the fields to group by.</p>
        pub fn groups(mut self, input: std::vec::Vec<std::string::String>) -> Self {
            let mut v = self.groups.unwrap_or_default();
            v.push(input);
            self.groups = Some(v);
            self
        }
        /// <p>Specifies the fields to group by.</p>
        pub fn set_groups(
            mut self,
            input: std::option::Option<std::vec::Vec<std::vec::Vec<std::string::String>>>,
        ) -> Self {
            self.groups = input;
            self
        }
        /// Appends an item to `aggs`.
        ///
        /// To override the contents of this collection use [`set_aggs`](Self::set_aggs).
        ///
        /// <p>Specifies the aggregate functions to be performed on specified fields. </p>
        pub fn aggs(mut self, input: crate::model::AggregateOperation) -> Self {
            let mut v = self.aggs.unwrap_or_default();
            v.push(input);
            self.aggs = Some(v);
            self
        }
        /// <p>Specifies the aggregate functions to be performed on specified fields. </p>
        pub fn set_aggs(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AggregateOperation>>,
        ) -> Self {
            self.aggs = input;
            self
        }
        /// Consumes the builder and constructs a [`Aggregate`](crate::model::Aggregate).
        pub fn build(self) -> crate::model::Aggregate {
            crate::model::Aggregate {
                name: self.name,
                inputs: self.inputs,
                groups: self.groups,
                aggs: self.aggs,
            }
        }
    }
}
impl Aggregate {
    /// Creates a new builder-style object to manufacture [`Aggregate`](crate::model::Aggregate).
    pub fn builder() -> crate::model::aggregate::Builder {
        crate::model::aggregate::Builder::default()
    }
}

/// <p>Specifies the set of parameters needed to perform aggregation in the aggregate transform.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AggregateOperation {
    /// <p>Specifies the column on the data set on which the aggregation function will be applied.</p>
    #[doc(hidden)]
    pub column: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Specifies the aggregation function to apply.</p>
    /// <p>Possible aggregation functions include: avg countDistinct, count, first, last, kurtosis, max, min, skewness, stddev_samp, stddev_pop, sum, sumDistinct, var_samp, var_pop</p>
    #[doc(hidden)]
    pub agg_func: std::option::Option<crate::model::AggFunction>,
}
impl AggregateOperation {
    /// <p>Specifies the column on the data set on which the aggregation function will be applied.</p>
    pub fn column(&self) -> std::option::Option<&[std::string::String]> {
        self.column.as_deref()
    }
    /// <p>Specifies the aggregation function to apply.</p>
    /// <p>Possible aggregation functions include: avg countDistinct, count, first, last, kurtosis, max, min, skewness, stddev_samp, stddev_pop, sum, sumDistinct, var_samp, var_pop</p>
    pub fn agg_func(&self) -> std::option::Option<&crate::model::AggFunction> {
        self.agg_func.as_ref()
    }
}
/// See [`AggregateOperation`](crate::model::AggregateOperation).
pub mod aggregate_operation {

    /// A builder for [`AggregateOperation`](crate::model::AggregateOperation).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) column: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) agg_func: std::option::Option<crate::model::AggFunction>,
    }
    impl Builder {
        /// Appends an item to `column`.
        ///
        /// To override the contents of this collection use [`set_column`](Self::set_column).
        ///
        /// <p>Specifies the column on the data set on which the aggregation function will be applied.</p>
        pub fn column(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.column.unwrap_or_default();
            v.push(input.into());
            self.column = Some(v);
            self
        }
        /// <p>Specifies the column on the data set on which the aggregation function will be applied.</p>
        pub fn set_column(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.column = input;
            self
        }
        /// <p>Specifies the aggregation function to apply.</p>
        /// <p>Possible aggregation functions include: avg countDistinct, count, first, last, kurtosis, max, min, skewness, stddev_samp, stddev_pop, sum, sumDistinct, var_samp, var_pop</p>
        pub fn agg_func(mut self, input: crate::model::AggFunction) -> Self {
            self.agg_func = Some(input);
            self
        }
        /// <p>Specifies the aggregation function to apply.</p>
        /// <p>Possible aggregation functions include: avg countDistinct, count, first, last, kurtosis, max, min, skewness, stddev_samp, stddev_pop, sum, sumDistinct, var_samp, var_pop</p>
        pub fn set_agg_func(
            mut self,
            input: std::option::Option<crate::model::AggFunction>,
        ) -> Self {
            self.agg_func = input;
            self
        }
        /// Consumes the builder and constructs a [`AggregateOperation`](crate::model::AggregateOperation).
        pub fn build(self) -> crate::model::AggregateOperation {
            crate::model::AggregateOperation {
                column: self.column,
                agg_func: self.agg_func,
            }
        }
    }
}
impl AggregateOperation {
    /// Creates a new builder-style object to manufacture [`AggregateOperation`](crate::model::AggregateOperation).
    pub fn builder() -> crate::model::aggregate_operation::Builder {
        crate::model::aggregate_operation::Builder::default()
    }
}

/// When writing a match expression against `AggFunction`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let aggfunction = unimplemented!();
/// match aggfunction {
///     AggFunction::Avg => { /* ... */ },
///     AggFunction::Count => { /* ... */ },
///     AggFunction::CountDistinct => { /* ... */ },
///     AggFunction::First => { /* ... */ },
///     AggFunction::Kurtosis => { /* ... */ },
///     AggFunction::Last => { /* ... */ },
///     AggFunction::Max => { /* ... */ },
///     AggFunction::Min => { /* ... */ },
///     AggFunction::Skewness => { /* ... */ },
///     AggFunction::StddevPop => { /* ... */ },
///     AggFunction::StddevSamp => { /* ... */ },
///     AggFunction::Sum => { /* ... */ },
///     AggFunction::SumDistinct => { /* ... */ },
///     AggFunction::VarPop => { /* ... */ },
///     AggFunction::VarSamp => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `aggfunction` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `AggFunction::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `AggFunction::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `AggFunction::NewFeature` is defined.
/// Specifically, when `aggfunction` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `AggFunction::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AggFunction {
    #[allow(missing_docs)] // documentation missing in model
    Avg,
    #[allow(missing_docs)] // documentation missing in model
    Count,
    #[allow(missing_docs)] // documentation missing in model
    CountDistinct,
    #[allow(missing_docs)] // documentation missing in model
    First,
    #[allow(missing_docs)] // documentation missing in model
    Kurtosis,
    #[allow(missing_docs)] // documentation missing in model
    Last,
    #[allow(missing_docs)] // documentation missing in model
    Max,
    #[allow(missing_docs)] // documentation missing in model
    Min,
    #[allow(missing_docs)] // documentation missing in model
    Skewness,
    #[allow(missing_docs)] // documentation missing in model
    StddevPop,
    #[allow(missing_docs)] // documentation missing in model
    StddevSamp,
    #[allow(missing_docs)] // documentation missing in model
    Sum,
    #[allow(missing_docs)] // documentation missing in model
    SumDistinct,
    #[allow(missing_docs)] // documentation missing in model
    VarPop,
    #[allow(missing_docs)] // documentation missing in model
    VarSamp,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for AggFunction {
    fn from(s: &str) -> Self {
        match s {
            "avg" => AggFunction::Avg,
            "count" => AggFunction::Count,
            "countDistinct" => AggFunction::CountDistinct,
            "first" => AggFunction::First,
            "kurtosis" => AggFunction::Kurtosis,
            "last" => AggFunction::Last,
            "max" => AggFunction::Max,
            "min" => AggFunction::Min,
            "skewness" => AggFunction::Skewness,
            "stddev_pop" => AggFunction::StddevPop,
            "stddev_samp" => AggFunction::StddevSamp,
            "sum" => AggFunction::Sum,
            "sumDistinct" => AggFunction::SumDistinct,
            "var_pop" => AggFunction::VarPop,
            "var_samp" => AggFunction::VarSamp,
            other => AggFunction::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for AggFunction {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AggFunction::from(s))
    }
}
impl AggFunction {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            AggFunction::Avg => "avg",
            AggFunction::Count => "count",
            AggFunction::CountDistinct => "countDistinct",
            AggFunction::First => "first",
            AggFunction::Kurtosis => "kurtosis",
            AggFunction::Last => "last",
            AggFunction::Max => "max",
            AggFunction::Min => "min",
            AggFunction::Skewness => "skewness",
            AggFunction::StddevPop => "stddev_pop",
            AggFunction::StddevSamp => "stddev_samp",
            AggFunction::Sum => "sum",
            AggFunction::SumDistinct => "sumDistinct",
            AggFunction::VarPop => "var_pop",
            AggFunction::VarSamp => "var_samp",
            AggFunction::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "avg",
            "count",
            "countDistinct",
            "first",
            "kurtosis",
            "last",
            "max",
            "min",
            "skewness",
            "stddev_pop",
            "stddev_samp",
            "sum",
            "sumDistinct",
            "var_pop",
            "var_samp",
        ]
    }
}
impl AsRef<str> for AggFunction {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Specifies a transform that identifies, removes or masks PII data.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PiiDetection {
    /// <p>The name of the transform node.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The node ID inputs to the transform.</p>
    #[doc(hidden)]
    pub inputs: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Indicates the type of PIIDetection transform. </p>
    #[doc(hidden)]
    pub pii_type: std::option::Option<crate::model::PiiType>,
    /// <p>Indicates the types of entities the PIIDetection transform will identify as PII data. </p>
    /// <p> PII type entities include: PERSON_NAME, DATE, USA_SNN, EMAIL, USA_ITIN, USA_PASSPORT_NUMBER, PHONE_NUMBER, BANK_ACCOUNT, IP_ADDRESS, MAC_ADDRESS, USA_CPT_CODE, USA_HCPCS_CODE, USA_NATIONAL_DRUG_CODE, USA_MEDICARE_BENEFICIARY_IDENTIFIER, USA_HEALTH_INSURANCE_CLAIM_NUMBER,CREDIT_CARD,USA_NATIONAL_PROVIDER_IDENTIFIER,USA_DEA_NUMBER,USA_DRIVING_LICENSE </p>
    #[doc(hidden)]
    pub entity_types_to_detect: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Indicates the output column name that will contain any entity type detected in that row. </p>
    #[doc(hidden)]
    pub output_column_name: std::option::Option<std::string::String>,
    /// <p>Indicates the fraction of the data to sample when scanning for PII entities. </p>
    #[doc(hidden)]
    pub sample_fraction: std::option::Option<f64>,
    /// <p>Indicates the fraction of the data that must be met in order for a column to be identified as PII data. </p>
    #[doc(hidden)]
    pub threshold_fraction: std::option::Option<f64>,
    /// <p>Indicates the value that will replace the detected entity. </p>
    #[doc(hidden)]
    pub mask_value: std::option::Option<std::string::String>,
}
impl PiiDetection {
    /// <p>The name of the transform node.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The node ID inputs to the transform.</p>
    pub fn inputs(&self) -> std::option::Option<&[std::string::String]> {
        self.inputs.as_deref()
    }
    /// <p>Indicates the type of PIIDetection transform. </p>
    pub fn pii_type(&self) -> std::option::Option<&crate::model::PiiType> {
        self.pii_type.as_ref()
    }
    /// <p>Indicates the types of entities the PIIDetection transform will identify as PII data. </p>
    /// <p> PII type entities include: PERSON_NAME, DATE, USA_SNN, EMAIL, USA_ITIN, USA_PASSPORT_NUMBER, PHONE_NUMBER, BANK_ACCOUNT, IP_ADDRESS, MAC_ADDRESS, USA_CPT_CODE, USA_HCPCS_CODE, USA_NATIONAL_DRUG_CODE, USA_MEDICARE_BENEFICIARY_IDENTIFIER, USA_HEALTH_INSURANCE_CLAIM_NUMBER,CREDIT_CARD,USA_NATIONAL_PROVIDER_IDENTIFIER,USA_DEA_NUMBER,USA_DRIVING_LICENSE </p>
    pub fn entity_types_to_detect(&self) -> std::option::Option<&[std::string::String]> {
        self.entity_types_to_detect.as_deref()
    }
    /// <p>Indicates the output column name that will contain any entity type detected in that row. </p>
    pub fn output_column_name(&self) -> std::option::Option<&str> {
        self.output_column_name.as_deref()
    }
    /// <p>Indicates the fraction of the data to sample when scanning for PII entities. </p>
    pub fn sample_fraction(&self) -> std::option::Option<f64> {
        self.sample_fraction
    }
    /// <p>Indicates the fraction of the data that must be met in order for a column to be identified as PII data. </p>
    pub fn threshold_fraction(&self) -> std::option::Option<f64> {
        self.threshold_fraction
    }
    /// <p>Indicates the value that will replace the detected entity. </p>
    pub fn mask_value(&self) -> std::option::Option<&str> {
        self.mask_value.as_deref()
    }
}
/// See [`PiiDetection`](crate::model::PiiDetection).
pub mod pii_detection {

    /// A builder for [`PiiDetection`](crate::model::PiiDetection).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) inputs: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) pii_type: std::option::Option<crate::model::PiiType>,
        pub(crate) entity_types_to_detect: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) output_column_name: std::option::Option<std::string::String>,
        pub(crate) sample_fraction: std::option::Option<f64>,
        pub(crate) threshold_fraction: std::option::Option<f64>,
        pub(crate) mask_value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the transform node.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the transform node.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Appends an item to `inputs`.
        ///
        /// To override the contents of this collection use [`set_inputs`](Self::set_inputs).
        ///
        /// <p>The node ID inputs to the transform.</p>
        pub fn inputs(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.inputs.unwrap_or_default();
            v.push(input.into());
            self.inputs = Some(v);
            self
        }
        /// <p>The node ID inputs to the transform.</p>
        pub fn set_inputs(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inputs = input;
            self
        }
        /// <p>Indicates the type of PIIDetection transform. </p>
        pub fn pii_type(mut self, input: crate::model::PiiType) -> Self {
            self.pii_type = Some(input);
            self
        }
        /// <p>Indicates the type of PIIDetection transform. </p>
        pub fn set_pii_type(mut self, input: std::option::Option<crate::model::PiiType>) -> Self {
            self.pii_type = input;
            self
        }
        /// Appends an item to `entity_types_to_detect`.
        ///
        /// To override the contents of this collection use [`set_entity_types_to_detect`](Self::set_entity_types_to_detect).
        ///
        /// <p>Indicates the types of entities the PIIDetection transform will identify as PII data. </p>
        /// <p> PII type entities include: PERSON_NAME, DATE, USA_SNN, EMAIL, USA_ITIN, USA_PASSPORT_NUMBER, PHONE_NUMBER, BANK_ACCOUNT, IP_ADDRESS, MAC_ADDRESS, USA_CPT_CODE, USA_HCPCS_CODE, USA_NATIONAL_DRUG_CODE, USA_MEDICARE_BENEFICIARY_IDENTIFIER, USA_HEALTH_INSURANCE_CLAIM_NUMBER,CREDIT_CARD,USA_NATIONAL_PROVIDER_IDENTIFIER,USA_DEA_NUMBER,USA_DRIVING_LICENSE </p>
        pub fn entity_types_to_detect(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.entity_types_to_detect.unwrap_or_default();
            v.push(input.into());
            self.entity_types_to_detect = Some(v);
            self
        }
        /// <p>Indicates the types of entities the PIIDetection transform will identify as PII data. </p>
        /// <p> PII type entities include: PERSON_NAME, DATE, USA_SNN, EMAIL, USA_ITIN, USA_PASSPORT_NUMBER, PHONE_NUMBER, BANK_ACCOUNT, IP_ADDRESS, MAC_ADDRESS, USA_CPT_CODE, USA_HCPCS_CODE, USA_NATIONAL_DRUG_CODE, USA_MEDICARE_BENEFICIARY_IDENTIFIER, USA_HEALTH_INSURANCE_CLAIM_NUMBER,CREDIT_CARD,USA_NATIONAL_PROVIDER_IDENTIFIER,USA_DEA_NUMBER,USA_DRIVING_LICENSE </p>
        pub fn set_entity_types_to_detect(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.entity_types_to_detect = input;
            self
        }
        /// <p>Indicates the output column name that will contain any entity type detected in that row. </p>
        pub fn output_column_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.output_column_name = Some(input.into());
            self
        }
        /// <p>Indicates the output column name that will contain any entity type detected in that row. </p>
        pub fn set_output_column_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.output_column_name = input;
            self
        }
        /// <p>Indicates the fraction of the data to sample when scanning for PII entities. </p>
        pub fn sample_fraction(mut self, input: f64) -> Self {
            self.sample_fraction = Some(input);
            self
        }
        /// <p>Indicates the fraction of the data to sample when scanning for PII entities. </p>
        pub fn set_sample_fraction(mut self, input: std::option::Option<f64>) -> Self {
            self.sample_fraction = input;
            self
        }
        /// <p>Indicates the fraction of the data that must be met in order for a column to be identified as PII data. </p>
        pub fn threshold_fraction(mut self, input: f64) -> Self {
            self.threshold_fraction = Some(input);
            self
        }
        /// <p>Indicates the fraction of the data that must be met in order for a column to be identified as PII data. </p>
        pub fn set_threshold_fraction(mut self, input: std::option::Option<f64>) -> Self {
            self.threshold_fraction = input;
            self
        }
        /// <p>Indicates the value that will replace the detected entity. </p>
        pub fn mask_value(mut self, input: impl Into<std::string::String>) -> Self {
            self.mask_value = Some(input.into());
            self
        }
        /// <p>Indicates the value that will replace the detected entity. </p>
        pub fn set_mask_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.mask_value = input;
            self
        }
        /// Consumes the builder and constructs a [`PiiDetection`](crate::model::PiiDetection).
        pub fn build(self) -> crate::model::PiiDetection {
            crate::model::PiiDetection {
                name: self.name,
                inputs: self.inputs,
                pii_type: self.pii_type,
                entity_types_to_detect: self.entity_types_to_detect,
                output_column_name: self.output_column_name,
                sample_fraction: self.sample_fraction,
                threshold_fraction: self.threshold_fraction,
                mask_value: self.mask_value,
            }
        }
    }
}
impl PiiDetection {
    /// Creates a new builder-style object to manufacture [`PiiDetection`](crate::model::PiiDetection).
    pub fn builder() -> crate::model::pii_detection::Builder {
        crate::model::pii_detection::Builder::default()
    }
}

/// When writing a match expression against `PiiType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let piitype = unimplemented!();
/// match piitype {
///     PiiType::ColumnAudit => { /* ... */ },
///     PiiType::ColumnMasking => { /* ... */ },
///     PiiType::RowAudit => { /* ... */ },
///     PiiType::RowMasking => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `piitype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `PiiType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `PiiType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `PiiType::NewFeature` is defined.
/// Specifically, when `piitype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `PiiType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum PiiType {
    #[allow(missing_docs)] // documentation missing in model
    ColumnAudit,
    #[allow(missing_docs)] // documentation missing in model
    ColumnMasking,
    #[allow(missing_docs)] // documentation missing in model
    RowAudit,
    #[allow(missing_docs)] // documentation missing in model
    RowMasking,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for PiiType {
    fn from(s: &str) -> Self {
        match s {
            "ColumnAudit" => PiiType::ColumnAudit,
            "ColumnMasking" => PiiType::ColumnMasking,
            "RowAudit" => PiiType::RowAudit,
            "RowMasking" => PiiType::RowMasking,
            other => PiiType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for PiiType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(PiiType::from(s))
    }
}
impl PiiType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            PiiType::ColumnAudit => "ColumnAudit",
            PiiType::ColumnMasking => "ColumnMasking",
            PiiType::RowAudit => "RowAudit",
            PiiType::RowMasking => "RowMasking",
            PiiType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ColumnAudit", "ColumnMasking", "RowAudit", "RowMasking"]
    }
}
impl AsRef<str> for PiiType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Specifies a transform that combines the rows from two or more datasets into a single result.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Union {
    /// <p>The name of the transform node.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The node ID inputs to the transform.</p>
    #[doc(hidden)]
    pub inputs: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Indicates the type of Union transform. </p>
    /// <p>Specify <code>ALL</code> to join all rows from data sources to the resulting DynamicFrame. The resulting union does not remove duplicate rows.</p>
    /// <p>Specify <code>DISTINCT</code> to remove duplicate rows in the resulting DynamicFrame.</p>
    #[doc(hidden)]
    pub union_type: std::option::Option<crate::model::UnionType>,
}
impl Union {
    /// <p>The name of the transform node.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The node ID inputs to the transform.</p>
    pub fn inputs(&self) -> std::option::Option<&[std::string::String]> {
        self.inputs.as_deref()
    }
    /// <p>Indicates the type of Union transform. </p>
    /// <p>Specify <code>ALL</code> to join all rows from data sources to the resulting DynamicFrame. The resulting union does not remove duplicate rows.</p>
    /// <p>Specify <code>DISTINCT</code> to remove duplicate rows in the resulting DynamicFrame.</p>
    pub fn union_type(&self) -> std::option::Option<&crate::model::UnionType> {
        self.union_type.as_ref()
    }
}
/// See [`Union`](crate::model::Union).
pub mod union {

    /// A builder for [`Union`](crate::model::Union).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) inputs: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) union_type: std::option::Option<crate::model::UnionType>,
    }
    impl Builder {
        /// <p>The name of the transform node.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the transform node.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Appends an item to `inputs`.
        ///
        /// To override the contents of this collection use [`set_inputs`](Self::set_inputs).
        ///
        /// <p>The node ID inputs to the transform.</p>
        pub fn inputs(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.inputs.unwrap_or_default();
            v.push(input.into());
            self.inputs = Some(v);
            self
        }
        /// <p>The node ID inputs to the transform.</p>
        pub fn set_inputs(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inputs = input;
            self
        }
        /// <p>Indicates the type of Union transform. </p>
        /// <p>Specify <code>ALL</code> to join all rows from data sources to the resulting DynamicFrame. The resulting union does not remove duplicate rows.</p>
        /// <p>Specify <code>DISTINCT</code> to remove duplicate rows in the resulting DynamicFrame.</p>
        pub fn union_type(mut self, input: crate::model::UnionType) -> Self {
            self.union_type = Some(input);
            self
        }
        /// <p>Indicates the type of Union transform. </p>
        /// <p>Specify <code>ALL</code> to join all rows from data sources to the resulting DynamicFrame. The resulting union does not remove duplicate rows.</p>
        /// <p>Specify <code>DISTINCT</code> to remove duplicate rows in the resulting DynamicFrame.</p>
        pub fn set_union_type(
            mut self,
            input: std::option::Option<crate::model::UnionType>,
        ) -> Self {
            self.union_type = input;
            self
        }
        /// Consumes the builder and constructs a [`Union`](crate::model::Union).
        pub fn build(self) -> crate::model::Union {
            crate::model::Union {
                name: self.name,
                inputs: self.inputs,
                union_type: self.union_type,
            }
        }
    }
}
impl Union {
    /// Creates a new builder-style object to manufacture [`Union`](crate::model::Union).
    pub fn builder() -> crate::model::union::Builder {
        crate::model::union::Builder::default()
    }
}

/// When writing a match expression against `UnionType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let uniontype = unimplemented!();
/// match uniontype {
///     UnionType::All => { /* ... */ },
///     UnionType::Distinct => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `uniontype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `UnionType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `UnionType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `UnionType::NewFeature` is defined.
/// Specifically, when `uniontype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `UnionType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum UnionType {
    #[allow(missing_docs)] // documentation missing in model
    All,
    #[allow(missing_docs)] // documentation missing in model
    Distinct,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for UnionType {
    fn from(s: &str) -> Self {
        match s {
            "ALL" => UnionType::All,
            "DISTINCT" => UnionType::Distinct,
            other => UnionType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for UnionType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(UnionType::from(s))
    }
}
impl UnionType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            UnionType::All => "ALL",
            UnionType::Distinct => "DISTINCT",
            UnionType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ALL", "DISTINCT"]
    }
}
impl AsRef<str> for UnionType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Specifies a transform that merges a <code>DynamicFrame</code> with a staging <code>DynamicFrame</code> based on the specified primary keys to identify records. Duplicate records (records with the same primary keys) are not de-duplicated. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Merge {
    /// <p>The name of the transform node.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The data inputs identified by their node names.</p>
    #[doc(hidden)]
    pub inputs: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The source <code>DynamicFrame</code> that will be merged with a staging <code>DynamicFrame</code>.</p>
    #[doc(hidden)]
    pub source: std::option::Option<std::string::String>,
    /// <p>The list of primary key fields to match records from the source and staging dynamic frames.</p>
    #[doc(hidden)]
    pub primary_keys: std::option::Option<std::vec::Vec<std::vec::Vec<std::string::String>>>,
}
impl Merge {
    /// <p>The name of the transform node.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The data inputs identified by their node names.</p>
    pub fn inputs(&self) -> std::option::Option<&[std::string::String]> {
        self.inputs.as_deref()
    }
    /// <p>The source <code>DynamicFrame</code> that will be merged with a staging <code>DynamicFrame</code>.</p>
    pub fn source(&self) -> std::option::Option<&str> {
        self.source.as_deref()
    }
    /// <p>The list of primary key fields to match records from the source and staging dynamic frames.</p>
    pub fn primary_keys(&self) -> std::option::Option<&[std::vec::Vec<std::string::String>]> {
        self.primary_keys.as_deref()
    }
}
/// See [`Merge`](crate::model::Merge).
pub mod merge {

    /// A builder for [`Merge`](crate::model::Merge).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) inputs: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) source: std::option::Option<std::string::String>,
        pub(crate) primary_keys:
            std::option::Option<std::vec::Vec<std::vec::Vec<std::string::String>>>,
    }
    impl Builder {
        /// <p>The name of the transform node.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the transform node.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Appends an item to `inputs`.
        ///
        /// To override the contents of this collection use [`set_inputs`](Self::set_inputs).
        ///
        /// <p>The data inputs identified by their node names.</p>
        pub fn inputs(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.inputs.unwrap_or_default();
            v.push(input.into());
            self.inputs = Some(v);
            self
        }
        /// <p>The data inputs identified by their node names.</p>
        pub fn set_inputs(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inputs = input;
            self
        }
        /// <p>The source <code>DynamicFrame</code> that will be merged with a staging <code>DynamicFrame</code>.</p>
        pub fn source(mut self, input: impl Into<std::string::String>) -> Self {
            self.source = Some(input.into());
            self
        }
        /// <p>The source <code>DynamicFrame</code> that will be merged with a staging <code>DynamicFrame</code>.</p>
        pub fn set_source(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.source = input;
            self
        }
        /// Appends an item to `primary_keys`.
        ///
        /// To override the contents of this collection use [`set_primary_keys`](Self::set_primary_keys).
        ///
        /// <p>The list of primary key fields to match records from the source and staging dynamic frames.</p>
        pub fn primary_keys(mut self, input: std::vec::Vec<std::string::String>) -> Self {
            let mut v = self.primary_keys.unwrap_or_default();
            v.push(input);
            self.primary_keys = Some(v);
            self
        }
        /// <p>The list of primary key fields to match records from the source and staging dynamic frames.</p>
        pub fn set_primary_keys(
            mut self,
            input: std::option::Option<std::vec::Vec<std::vec::Vec<std::string::String>>>,
        ) -> Self {
            self.primary_keys = input;
            self
        }
        /// Consumes the builder and constructs a [`Merge`](crate::model::Merge).
        pub fn build(self) -> crate::model::Merge {
            crate::model::Merge {
                name: self.name,
                inputs: self.inputs,
                source: self.source,
                primary_keys: self.primary_keys,
            }
        }
    }
}
impl Merge {
    /// Creates a new builder-style object to manufacture [`Merge`](crate::model::Merge).
    pub fn builder() -> crate::model::merge::Builder {
        crate::model::merge::Builder::default()
    }
}

/// <p>Specifies a transform that removes columns from the dataset if all values in the column are 'null'. By default, Glue Studio will recognize null objects, but some values such as empty strings, strings that are "null", -1 integers or other placeholders such as zeros, are not automatically recognized as nulls.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DropNullFields {
    /// <p>The name of the transform node.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The data inputs identified by their node names.</p>
    #[doc(hidden)]
    pub inputs: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A structure that represents whether certain values are recognized as null values for removal.</p>
    #[doc(hidden)]
    pub null_check_box_list: std::option::Option<crate::model::NullCheckBoxList>,
    /// <p>A structure that specifies a list of NullValueField structures that represent a custom null value such as zero or other value being used as a null placeholder unique to the dataset.</p>
    /// <p>The <code>DropNullFields</code> transform removes custom null values only if both the value of the null placeholder and the datatype match the data.</p>
    #[doc(hidden)]
    pub null_text_list: std::option::Option<std::vec::Vec<crate::model::NullValueField>>,
}
impl DropNullFields {
    /// <p>The name of the transform node.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The data inputs identified by their node names.</p>
    pub fn inputs(&self) -> std::option::Option<&[std::string::String]> {
        self.inputs.as_deref()
    }
    /// <p>A structure that represents whether certain values are recognized as null values for removal.</p>
    pub fn null_check_box_list(&self) -> std::option::Option<&crate::model::NullCheckBoxList> {
        self.null_check_box_list.as_ref()
    }
    /// <p>A structure that specifies a list of NullValueField structures that represent a custom null value such as zero or other value being used as a null placeholder unique to the dataset.</p>
    /// <p>The <code>DropNullFields</code> transform removes custom null values only if both the value of the null placeholder and the datatype match the data.</p>
    pub fn null_text_list(&self) -> std::option::Option<&[crate::model::NullValueField]> {
        self.null_text_list.as_deref()
    }
}
/// See [`DropNullFields`](crate::model::DropNullFields).
pub mod drop_null_fields {

    /// A builder for [`DropNullFields`](crate::model::DropNullFields).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) inputs: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) null_check_box_list: std::option::Option<crate::model::NullCheckBoxList>,
        pub(crate) null_text_list: std::option::Option<std::vec::Vec<crate::model::NullValueField>>,
    }
    impl Builder {
        /// <p>The name of the transform node.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the transform node.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Appends an item to `inputs`.
        ///
        /// To override the contents of this collection use [`set_inputs`](Self::set_inputs).
        ///
        /// <p>The data inputs identified by their node names.</p>
        pub fn inputs(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.inputs.unwrap_or_default();
            v.push(input.into());
            self.inputs = Some(v);
            self
        }
        /// <p>The data inputs identified by their node names.</p>
        pub fn set_inputs(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inputs = input;
            self
        }
        /// <p>A structure that represents whether certain values are recognized as null values for removal.</p>
        pub fn null_check_box_list(mut self, input: crate::model::NullCheckBoxList) -> Self {
            self.null_check_box_list = Some(input);
            self
        }
        /// <p>A structure that represents whether certain values are recognized as null values for removal.</p>
        pub fn set_null_check_box_list(
            mut self,
            input: std::option::Option<crate::model::NullCheckBoxList>,
        ) -> Self {
            self.null_check_box_list = input;
            self
        }
        /// Appends an item to `null_text_list`.
        ///
        /// To override the contents of this collection use [`set_null_text_list`](Self::set_null_text_list).
        ///
        /// <p>A structure that specifies a list of NullValueField structures that represent a custom null value such as zero or other value being used as a null placeholder unique to the dataset.</p>
        /// <p>The <code>DropNullFields</code> transform removes custom null values only if both the value of the null placeholder and the datatype match the data.</p>
        pub fn null_text_list(mut self, input: crate::model::NullValueField) -> Self {
            let mut v = self.null_text_list.unwrap_or_default();
            v.push(input);
            self.null_text_list = Some(v);
            self
        }
        /// <p>A structure that specifies a list of NullValueField structures that represent a custom null value such as zero or other value being used as a null placeholder unique to the dataset.</p>
        /// <p>The <code>DropNullFields</code> transform removes custom null values only if both the value of the null placeholder and the datatype match the data.</p>
        pub fn set_null_text_list(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::NullValueField>>,
        ) -> Self {
            self.null_text_list = input;
            self
        }
        /// Consumes the builder and constructs a [`DropNullFields`](crate::model::DropNullFields).
        pub fn build(self) -> crate::model::DropNullFields {
            crate::model::DropNullFields {
                name: self.name,
                inputs: self.inputs,
                null_check_box_list: self.null_check_box_list,
                null_text_list: self.null_text_list,
            }
        }
    }
}
impl DropNullFields {
    /// Creates a new builder-style object to manufacture [`DropNullFields`](crate::model::DropNullFields).
    pub fn builder() -> crate::model::drop_null_fields::Builder {
        crate::model::drop_null_fields::Builder::default()
    }
}

/// <p>Represents a custom null value such as a zeros or other value being used as a null placeholder unique to the dataset.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct NullValueField {
    /// <p>The value of the null placeholder.</p>
    #[doc(hidden)]
    pub value: std::option::Option<std::string::String>,
    /// <p>The datatype of the value.</p>
    #[doc(hidden)]
    pub datatype: std::option::Option<crate::model::Datatype>,
}
impl NullValueField {
    /// <p>The value of the null placeholder.</p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
    /// <p>The datatype of the value.</p>
    pub fn datatype(&self) -> std::option::Option<&crate::model::Datatype> {
        self.datatype.as_ref()
    }
}
/// See [`NullValueField`](crate::model::NullValueField).
pub mod null_value_field {

    /// A builder for [`NullValueField`](crate::model::NullValueField).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) value: std::option::Option<std::string::String>,
        pub(crate) datatype: std::option::Option<crate::model::Datatype>,
    }
    impl Builder {
        /// <p>The value of the null placeholder.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>The value of the null placeholder.</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// <p>The datatype of the value.</p>
        pub fn datatype(mut self, input: crate::model::Datatype) -> Self {
            self.datatype = Some(input);
            self
        }
        /// <p>The datatype of the value.</p>
        pub fn set_datatype(mut self, input: std::option::Option<crate::model::Datatype>) -> Self {
            self.datatype = input;
            self
        }
        /// Consumes the builder and constructs a [`NullValueField`](crate::model::NullValueField).
        pub fn build(self) -> crate::model::NullValueField {
            crate::model::NullValueField {
                value: self.value,
                datatype: self.datatype,
            }
        }
    }
}
impl NullValueField {
    /// Creates a new builder-style object to manufacture [`NullValueField`](crate::model::NullValueField).
    pub fn builder() -> crate::model::null_value_field::Builder {
        crate::model::null_value_field::Builder::default()
    }
}

/// <p>A structure representing the datatype of the value.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Datatype {
    /// <p>The datatype of the value.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>A label assigned to the datatype.</p>
    #[doc(hidden)]
    pub label: std::option::Option<std::string::String>,
}
impl Datatype {
    /// <p>The datatype of the value.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>A label assigned to the datatype.</p>
    pub fn label(&self) -> std::option::Option<&str> {
        self.label.as_deref()
    }
}
/// See [`Datatype`](crate::model::Datatype).
pub mod datatype {

    /// A builder for [`Datatype`](crate::model::Datatype).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) label: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The datatype of the value.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The datatype of the value.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>A label assigned to the datatype.</p>
        pub fn label(mut self, input: impl Into<std::string::String>) -> Self {
            self.label = Some(input.into());
            self
        }
        /// <p>A label assigned to the datatype.</p>
        pub fn set_label(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.label = input;
            self
        }
        /// Consumes the builder and constructs a [`Datatype`](crate::model::Datatype).
        pub fn build(self) -> crate::model::Datatype {
            crate::model::Datatype {
                id: self.id,
                label: self.label,
            }
        }
    }
}
impl Datatype {
    /// Creates a new builder-style object to manufacture [`Datatype`](crate::model::Datatype).
    pub fn builder() -> crate::model::datatype::Builder {
        crate::model::datatype::Builder::default()
    }
}

/// <p>Represents whether certain values are recognized as null values for removal.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct NullCheckBoxList {
    /// <p>Specifies that an empty string is considered as a null value.</p>
    #[doc(hidden)]
    pub is_empty: std::option::Option<bool>,
    /// <p>Specifies that a value spelling out the word 'null' is considered as a null value.</p>
    #[doc(hidden)]
    pub is_null_string: std::option::Option<bool>,
    /// <p>Specifies that an integer value of -1 is considered as a null value.</p>
    #[doc(hidden)]
    pub is_neg_one: std::option::Option<bool>,
}
impl NullCheckBoxList {
    /// <p>Specifies that an empty string is considered as a null value.</p>
    pub fn is_empty(&self) -> std::option::Option<bool> {
        self.is_empty
    }
    /// <p>Specifies that a value spelling out the word 'null' is considered as a null value.</p>
    pub fn is_null_string(&self) -> std::option::Option<bool> {
        self.is_null_string
    }
    /// <p>Specifies that an integer value of -1 is considered as a null value.</p>
    pub fn is_neg_one(&self) -> std::option::Option<bool> {
        self.is_neg_one
    }
}
/// See [`NullCheckBoxList`](crate::model::NullCheckBoxList).
pub mod null_check_box_list {

    /// A builder for [`NullCheckBoxList`](crate::model::NullCheckBoxList).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) is_empty: std::option::Option<bool>,
        pub(crate) is_null_string: std::option::Option<bool>,
        pub(crate) is_neg_one: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>Specifies that an empty string is considered as a null value.</p>
        pub fn is_empty(mut self, input: bool) -> Self {
            self.is_empty = Some(input);
            self
        }
        /// <p>Specifies that an empty string is considered as a null value.</p>
        pub fn set_is_empty(mut self, input: std::option::Option<bool>) -> Self {
            self.is_empty = input;
            self
        }
        /// <p>Specifies that a value spelling out the word 'null' is considered as a null value.</p>
        pub fn is_null_string(mut self, input: bool) -> Self {
            self.is_null_string = Some(input);
            self
        }
        /// <p>Specifies that a value spelling out the word 'null' is considered as a null value.</p>
        pub fn set_is_null_string(mut self, input: std::option::Option<bool>) -> Self {
            self.is_null_string = input;
            self
        }
        /// <p>Specifies that an integer value of -1 is considered as a null value.</p>
        pub fn is_neg_one(mut self, input: bool) -> Self {
            self.is_neg_one = Some(input);
            self
        }
        /// <p>Specifies that an integer value of -1 is considered as a null value.</p>
        pub fn set_is_neg_one(mut self, input: std::option::Option<bool>) -> Self {
            self.is_neg_one = input;
            self
        }
        /// Consumes the builder and constructs a [`NullCheckBoxList`](crate::model::NullCheckBoxList).
        pub fn build(self) -> crate::model::NullCheckBoxList {
            crate::model::NullCheckBoxList {
                is_empty: self.is_empty,
                is_null_string: self.is_null_string,
                is_neg_one: self.is_neg_one,
            }
        }
    }
}
impl NullCheckBoxList {
    /// Creates a new builder-style object to manufacture [`NullCheckBoxList`](crate::model::NullCheckBoxList).
    pub fn builder() -> crate::model::null_check_box_list::Builder {
        crate::model::null_check_box_list::Builder::default()
    }
}

/// <p>Specifies an Apache Kafka data store in the Data Catalog.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CatalogKafkaSource {
    /// <p>The name of the data store.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The amount of time to spend processing each micro batch.</p>
    #[doc(hidden)]
    pub window_size: std::option::Option<i32>,
    /// <p>Whether to automatically determine the schema from the incoming data.</p>
    #[doc(hidden)]
    pub detect_schema: std::option::Option<bool>,
    /// <p>The name of the table in the database to read from.</p>
    #[doc(hidden)]
    pub table: std::option::Option<std::string::String>,
    /// <p>The name of the database to read from.</p>
    #[doc(hidden)]
    pub database: std::option::Option<std::string::String>,
    /// <p>Specifies the streaming options.</p>
    #[doc(hidden)]
    pub streaming_options: std::option::Option<crate::model::KafkaStreamingSourceOptions>,
    /// <p>Specifies options related to data preview for viewing a sample of your data.</p>
    #[doc(hidden)]
    pub data_preview_options: std::option::Option<crate::model::StreamingDataPreviewOptions>,
}
impl CatalogKafkaSource {
    /// <p>The name of the data store.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The amount of time to spend processing each micro batch.</p>
    pub fn window_size(&self) -> std::option::Option<i32> {
        self.window_size
    }
    /// <p>Whether to automatically determine the schema from the incoming data.</p>
    pub fn detect_schema(&self) -> std::option::Option<bool> {
        self.detect_schema
    }
    /// <p>The name of the table in the database to read from.</p>
    pub fn table(&self) -> std::option::Option<&str> {
        self.table.as_deref()
    }
    /// <p>The name of the database to read from.</p>
    pub fn database(&self) -> std::option::Option<&str> {
        self.database.as_deref()
    }
    /// <p>Specifies the streaming options.</p>
    pub fn streaming_options(
        &self,
    ) -> std::option::Option<&crate::model::KafkaStreamingSourceOptions> {
        self.streaming_options.as_ref()
    }
    /// <p>Specifies options related to data preview for viewing a sample of your data.</p>
    pub fn data_preview_options(
        &self,
    ) -> std::option::Option<&crate::model::StreamingDataPreviewOptions> {
        self.data_preview_options.as_ref()
    }
}
/// See [`CatalogKafkaSource`](crate::model::CatalogKafkaSource).
pub mod catalog_kafka_source {

    /// A builder for [`CatalogKafkaSource`](crate::model::CatalogKafkaSource).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) window_size: std::option::Option<i32>,
        pub(crate) detect_schema: std::option::Option<bool>,
        pub(crate) table: std::option::Option<std::string::String>,
        pub(crate) database: std::option::Option<std::string::String>,
        pub(crate) streaming_options:
            std::option::Option<crate::model::KafkaStreamingSourceOptions>,
        pub(crate) data_preview_options:
            std::option::Option<crate::model::StreamingDataPreviewOptions>,
    }
    impl Builder {
        /// <p>The name of the data store.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the data store.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The amount of time to spend processing each micro batch.</p>
        pub fn window_size(mut self, input: i32) -> Self {
            self.window_size = Some(input);
            self
        }
        /// <p>The amount of time to spend processing each micro batch.</p>
        pub fn set_window_size(mut self, input: std::option::Option<i32>) -> Self {
            self.window_size = input;
            self
        }
        /// <p>Whether to automatically determine the schema from the incoming data.</p>
        pub fn detect_schema(mut self, input: bool) -> Self {
            self.detect_schema = Some(input);
            self
        }
        /// <p>Whether to automatically determine the schema from the incoming data.</p>
        pub fn set_detect_schema(mut self, input: std::option::Option<bool>) -> Self {
            self.detect_schema = input;
            self
        }
        /// <p>The name of the table in the database to read from.</p>
        pub fn table(mut self, input: impl Into<std::string::String>) -> Self {
            self.table = Some(input.into());
            self
        }
        /// <p>The name of the table in the database to read from.</p>
        pub fn set_table(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.table = input;
            self
        }
        /// <p>The name of the database to read from.</p>
        pub fn database(mut self, input: impl Into<std::string::String>) -> Self {
            self.database = Some(input.into());
            self
        }
        /// <p>The name of the database to read from.</p>
        pub fn set_database(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.database = input;
            self
        }
        /// <p>Specifies the streaming options.</p>
        pub fn streaming_options(
            mut self,
            input: crate::model::KafkaStreamingSourceOptions,
        ) -> Self {
            self.streaming_options = Some(input);
            self
        }
        /// <p>Specifies the streaming options.</p>
        pub fn set_streaming_options(
            mut self,
            input: std::option::Option<crate::model::KafkaStreamingSourceOptions>,
        ) -> Self {
            self.streaming_options = input;
            self
        }
        /// <p>Specifies options related to data preview for viewing a sample of your data.</p>
        pub fn data_preview_options(
            mut self,
            input: crate::model::StreamingDataPreviewOptions,
        ) -> Self {
            self.data_preview_options = Some(input);
            self
        }
        /// <p>Specifies options related to data preview for viewing a sample of your data.</p>
        pub fn set_data_preview_options(
            mut self,
            input: std::option::Option<crate::model::StreamingDataPreviewOptions>,
        ) -> Self {
            self.data_preview_options = input;
            self
        }
        /// Consumes the builder and constructs a [`CatalogKafkaSource`](crate::model::CatalogKafkaSource).
        pub fn build(self) -> crate::model::CatalogKafkaSource {
            crate::model::CatalogKafkaSource {
                name: self.name,
                window_size: self.window_size,
                detect_schema: self.detect_schema,
                table: self.table,
                database: self.database,
                streaming_options: self.streaming_options,
                data_preview_options: self.data_preview_options,
            }
        }
    }
}
impl CatalogKafkaSource {
    /// Creates a new builder-style object to manufacture [`CatalogKafkaSource`](crate::model::CatalogKafkaSource).
    pub fn builder() -> crate::model::catalog_kafka_source::Builder {
        crate::model::catalog_kafka_source::Builder::default()
    }
}

/// <p>Specifies options related to data preview for viewing a sample of your data.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct StreamingDataPreviewOptions {
    /// <p>The polling time in milliseconds.</p>
    #[doc(hidden)]
    pub polling_time: std::option::Option<i64>,
    /// <p>The limit to the number of records polled.</p>
    #[doc(hidden)]
    pub record_polling_limit: std::option::Option<i64>,
}
impl StreamingDataPreviewOptions {
    /// <p>The polling time in milliseconds.</p>
    pub fn polling_time(&self) -> std::option::Option<i64> {
        self.polling_time
    }
    /// <p>The limit to the number of records polled.</p>
    pub fn record_polling_limit(&self) -> std::option::Option<i64> {
        self.record_polling_limit
    }
}
/// See [`StreamingDataPreviewOptions`](crate::model::StreamingDataPreviewOptions).
pub mod streaming_data_preview_options {

    /// A builder for [`StreamingDataPreviewOptions`](crate::model::StreamingDataPreviewOptions).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) polling_time: std::option::Option<i64>,
        pub(crate) record_polling_limit: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>The polling time in milliseconds.</p>
        pub fn polling_time(mut self, input: i64) -> Self {
            self.polling_time = Some(input);
            self
        }
        /// <p>The polling time in milliseconds.</p>
        pub fn set_polling_time(mut self, input: std::option::Option<i64>) -> Self {
            self.polling_time = input;
            self
        }
        /// <p>The limit to the number of records polled.</p>
        pub fn record_polling_limit(mut self, input: i64) -> Self {
            self.record_polling_limit = Some(input);
            self
        }
        /// <p>The limit to the number of records polled.</p>
        pub fn set_record_polling_limit(mut self, input: std::option::Option<i64>) -> Self {
            self.record_polling_limit = input;
            self
        }
        /// Consumes the builder and constructs a [`StreamingDataPreviewOptions`](crate::model::StreamingDataPreviewOptions).
        pub fn build(self) -> crate::model::StreamingDataPreviewOptions {
            crate::model::StreamingDataPreviewOptions {
                polling_time: self.polling_time,
                record_polling_limit: self.record_polling_limit,
            }
        }
    }
}
impl StreamingDataPreviewOptions {
    /// Creates a new builder-style object to manufacture [`StreamingDataPreviewOptions`](crate::model::StreamingDataPreviewOptions).
    pub fn builder() -> crate::model::streaming_data_preview_options::Builder {
        crate::model::streaming_data_preview_options::Builder::default()
    }
}

/// <p>Additional options for streaming.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct KafkaStreamingSourceOptions {
    /// <p>A list of bootstrap server URLs, for example, as <code>b-1.vpc-test-2.o4q88o.c6.kafka.us-east-1.amazonaws.com:9094</code>. This option must be specified in the API call or defined in the table metadata in the Data Catalog.</p>
    #[doc(hidden)]
    pub bootstrap_servers: std::option::Option<std::string::String>,
    /// <p>The protocol used to communicate with brokers. The possible values are <code>"SSL"</code> or <code>"PLAINTEXT"</code>.</p>
    #[doc(hidden)]
    pub security_protocol: std::option::Option<std::string::String>,
    /// <p>The name of the connection.</p>
    #[doc(hidden)]
    pub connection_name: std::option::Option<std::string::String>,
    /// <p>The topic name as specified in Apache Kafka. You must specify at least one of <code>"topicName"</code>, <code>"assign"</code> or <code>"subscribePattern"</code>.</p>
    #[doc(hidden)]
    pub topic_name: std::option::Option<std::string::String>,
    /// <p>The specific <code>TopicPartitions</code> to consume. You must specify at least one of <code>"topicName"</code>, <code>"assign"</code> or <code>"subscribePattern"</code>.</p>
    #[doc(hidden)]
    pub assign: std::option::Option<std::string::String>,
    /// <p>A Java regex string that identifies the topic list to subscribe to. You must specify at least one of <code>"topicName"</code>, <code>"assign"</code> or <code>"subscribePattern"</code>.</p>
    #[doc(hidden)]
    pub subscribe_pattern: std::option::Option<std::string::String>,
    /// <p>An optional classification.</p>
    #[doc(hidden)]
    pub classification: std::option::Option<std::string::String>,
    /// <p>Specifies the delimiter character.</p>
    #[doc(hidden)]
    pub delimiter: std::option::Option<std::string::String>,
    /// <p>The starting position in the Kafka topic to read data from. The possible values are <code>"earliest"</code> or <code>"latest"</code>. The default value is <code>"latest"</code>.</p>
    #[doc(hidden)]
    pub starting_offsets: std::option::Option<std::string::String>,
    /// <p>The end point when a batch query is ended. Possible values are either <code>"latest"</code> or a JSON string that specifies an ending offset for each <code>TopicPartition</code>.</p>
    #[doc(hidden)]
    pub ending_offsets: std::option::Option<std::string::String>,
    /// <p>The timeout in milliseconds to poll data from Kafka in Spark job executors. The default value is <code>512</code>.</p>
    #[doc(hidden)]
    pub poll_timeout_ms: std::option::Option<i64>,
    /// <p>The number of times to retry before failing to fetch Kafka offsets. The default value is <code>3</code>.</p>
    #[doc(hidden)]
    pub num_retries: std::option::Option<i32>,
    /// <p>The time in milliseconds to wait before retrying to fetch Kafka offsets. The default value is <code>10</code>.</p>
    #[doc(hidden)]
    pub retry_interval_ms: std::option::Option<i64>,
    /// <p>The rate limit on the maximum number of offsets that are processed per trigger interval. The specified total number of offsets is proportionally split across <code>topicPartitions</code> of different volumes. The default value is null, which means that the consumer reads all offsets until the known latest offset.</p>
    #[doc(hidden)]
    pub max_offsets_per_trigger: std::option::Option<i64>,
    /// <p>The desired minimum number of partitions to read from Kafka. The default value is null, which means that the number of spark partitions is equal to the number of Kafka partitions.</p>
    #[doc(hidden)]
    pub min_partitions: std::option::Option<i32>,
}
impl KafkaStreamingSourceOptions {
    /// <p>A list of bootstrap server URLs, for example, as <code>b-1.vpc-test-2.o4q88o.c6.kafka.us-east-1.amazonaws.com:9094</code>. This option must be specified in the API call or defined in the table metadata in the Data Catalog.</p>
    pub fn bootstrap_servers(&self) -> std::option::Option<&str> {
        self.bootstrap_servers.as_deref()
    }
    /// <p>The protocol used to communicate with brokers. The possible values are <code>"SSL"</code> or <code>"PLAINTEXT"</code>.</p>
    pub fn security_protocol(&self) -> std::option::Option<&str> {
        self.security_protocol.as_deref()
    }
    /// <p>The name of the connection.</p>
    pub fn connection_name(&self) -> std::option::Option<&str> {
        self.connection_name.as_deref()
    }
    /// <p>The topic name as specified in Apache Kafka. You must specify at least one of <code>"topicName"</code>, <code>"assign"</code> or <code>"subscribePattern"</code>.</p>
    pub fn topic_name(&self) -> std::option::Option<&str> {
        self.topic_name.as_deref()
    }
    /// <p>The specific <code>TopicPartitions</code> to consume. You must specify at least one of <code>"topicName"</code>, <code>"assign"</code> or <code>"subscribePattern"</code>.</p>
    pub fn assign(&self) -> std::option::Option<&str> {
        self.assign.as_deref()
    }
    /// <p>A Java regex string that identifies the topic list to subscribe to. You must specify at least one of <code>"topicName"</code>, <code>"assign"</code> or <code>"subscribePattern"</code>.</p>
    pub fn subscribe_pattern(&self) -> std::option::Option<&str> {
        self.subscribe_pattern.as_deref()
    }
    /// <p>An optional classification.</p>
    pub fn classification(&self) -> std::option::Option<&str> {
        self.classification.as_deref()
    }
    /// <p>Specifies the delimiter character.</p>
    pub fn delimiter(&self) -> std::option::Option<&str> {
        self.delimiter.as_deref()
    }
    /// <p>The starting position in the Kafka topic to read data from. The possible values are <code>"earliest"</code> or <code>"latest"</code>. The default value is <code>"latest"</code>.</p>
    pub fn starting_offsets(&self) -> std::option::Option<&str> {
        self.starting_offsets.as_deref()
    }
    /// <p>The end point when a batch query is ended. Possible values are either <code>"latest"</code> or a JSON string that specifies an ending offset for each <code>TopicPartition</code>.</p>
    pub fn ending_offsets(&self) -> std::option::Option<&str> {
        self.ending_offsets.as_deref()
    }
    /// <p>The timeout in milliseconds to poll data from Kafka in Spark job executors. The default value is <code>512</code>.</p>
    pub fn poll_timeout_ms(&self) -> std::option::Option<i64> {
        self.poll_timeout_ms
    }
    /// <p>The number of times to retry before failing to fetch Kafka offsets. The default value is <code>3</code>.</p>
    pub fn num_retries(&self) -> std::option::Option<i32> {
        self.num_retries
    }
    /// <p>The time in milliseconds to wait before retrying to fetch Kafka offsets. The default value is <code>10</code>.</p>
    pub fn retry_interval_ms(&self) -> std::option::Option<i64> {
        self.retry_interval_ms
    }
    /// <p>The rate limit on the maximum number of offsets that are processed per trigger interval. The specified total number of offsets is proportionally split across <code>topicPartitions</code> of different volumes. The default value is null, which means that the consumer reads all offsets until the known latest offset.</p>
    pub fn max_offsets_per_trigger(&self) -> std::option::Option<i64> {
        self.max_offsets_per_trigger
    }
    /// <p>The desired minimum number of partitions to read from Kafka. The default value is null, which means that the number of spark partitions is equal to the number of Kafka partitions.</p>
    pub fn min_partitions(&self) -> std::option::Option<i32> {
        self.min_partitions
    }
}
/// See [`KafkaStreamingSourceOptions`](crate::model::KafkaStreamingSourceOptions).
pub mod kafka_streaming_source_options {

    /// A builder for [`KafkaStreamingSourceOptions`](crate::model::KafkaStreamingSourceOptions).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bootstrap_servers: std::option::Option<std::string::String>,
        pub(crate) security_protocol: std::option::Option<std::string::String>,
        pub(crate) connection_name: std::option::Option<std::string::String>,
        pub(crate) topic_name: std::option::Option<std::string::String>,
        pub(crate) assign: std::option::Option<std::string::String>,
        pub(crate) subscribe_pattern: std::option::Option<std::string::String>,
        pub(crate) classification: std::option::Option<std::string::String>,
        pub(crate) delimiter: std::option::Option<std::string::String>,
        pub(crate) starting_offsets: std::option::Option<std::string::String>,
        pub(crate) ending_offsets: std::option::Option<std::string::String>,
        pub(crate) poll_timeout_ms: std::option::Option<i64>,
        pub(crate) num_retries: std::option::Option<i32>,
        pub(crate) retry_interval_ms: std::option::Option<i64>,
        pub(crate) max_offsets_per_trigger: std::option::Option<i64>,
        pub(crate) min_partitions: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>A list of bootstrap server URLs, for example, as <code>b-1.vpc-test-2.o4q88o.c6.kafka.us-east-1.amazonaws.com:9094</code>. This option must be specified in the API call or defined in the table metadata in the Data Catalog.</p>
        pub fn bootstrap_servers(mut self, input: impl Into<std::string::String>) -> Self {
            self.bootstrap_servers = Some(input.into());
            self
        }
        /// <p>A list of bootstrap server URLs, for example, as <code>b-1.vpc-test-2.o4q88o.c6.kafka.us-east-1.amazonaws.com:9094</code>. This option must be specified in the API call or defined in the table metadata in the Data Catalog.</p>
        pub fn set_bootstrap_servers(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.bootstrap_servers = input;
            self
        }
        /// <p>The protocol used to communicate with brokers. The possible values are <code>"SSL"</code> or <code>"PLAINTEXT"</code>.</p>
        pub fn security_protocol(mut self, input: impl Into<std::string::String>) -> Self {
            self.security_protocol = Some(input.into());
            self
        }
        /// <p>The protocol used to communicate with brokers. The possible values are <code>"SSL"</code> or <code>"PLAINTEXT"</code>.</p>
        pub fn set_security_protocol(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.security_protocol = input;
            self
        }
        /// <p>The name of the connection.</p>
        pub fn connection_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.connection_name = Some(input.into());
            self
        }
        /// <p>The name of the connection.</p>
        pub fn set_connection_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.connection_name = input;
            self
        }
        /// <p>The topic name as specified in Apache Kafka. You must specify at least one of <code>"topicName"</code>, <code>"assign"</code> or <code>"subscribePattern"</code>.</p>
        pub fn topic_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.topic_name = Some(input.into());
            self
        }
        /// <p>The topic name as specified in Apache Kafka. You must specify at least one of <code>"topicName"</code>, <code>"assign"</code> or <code>"subscribePattern"</code>.</p>
        pub fn set_topic_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.topic_name = input;
            self
        }
        /// <p>The specific <code>TopicPartitions</code> to consume. You must specify at least one of <code>"topicName"</code>, <code>"assign"</code> or <code>"subscribePattern"</code>.</p>
        pub fn assign(mut self, input: impl Into<std::string::String>) -> Self {
            self.assign = Some(input.into());
            self
        }
        /// <p>The specific <code>TopicPartitions</code> to consume. You must specify at least one of <code>"topicName"</code>, <code>"assign"</code> or <code>"subscribePattern"</code>.</p>
        pub fn set_assign(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.assign = input;
            self
        }
        /// <p>A Java regex string that identifies the topic list to subscribe to. You must specify at least one of <code>"topicName"</code>, <code>"assign"</code> or <code>"subscribePattern"</code>.</p>
        pub fn subscribe_pattern(mut self, input: impl Into<std::string::String>) -> Self {
            self.subscribe_pattern = Some(input.into());
            self
        }
        /// <p>A Java regex string that identifies the topic list to subscribe to. You must specify at least one of <code>"topicName"</code>, <code>"assign"</code> or <code>"subscribePattern"</code>.</p>
        pub fn set_subscribe_pattern(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.subscribe_pattern = input;
            self
        }
        /// <p>An optional classification.</p>
        pub fn classification(mut self, input: impl Into<std::string::String>) -> Self {
            self.classification = Some(input.into());
            self
        }
        /// <p>An optional classification.</p>
        pub fn set_classification(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.classification = input;
            self
        }
        /// <p>Specifies the delimiter character.</p>
        pub fn delimiter(mut self, input: impl Into<std::string::String>) -> Self {
            self.delimiter = Some(input.into());
            self
        }
        /// <p>Specifies the delimiter character.</p>
        pub fn set_delimiter(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.delimiter = input;
            self
        }
        /// <p>The starting position in the Kafka topic to read data from. The possible values are <code>"earliest"</code> or <code>"latest"</code>. The default value is <code>"latest"</code>.</p>
        pub fn starting_offsets(mut self, input: impl Into<std::string::String>) -> Self {
            self.starting_offsets = Some(input.into());
            self
        }
        /// <p>The starting position in the Kafka topic to read data from. The possible values are <code>"earliest"</code> or <code>"latest"</code>. The default value is <code>"latest"</code>.</p>
        pub fn set_starting_offsets(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.starting_offsets = input;
            self
        }
        /// <p>The end point when a batch query is ended. Possible values are either <code>"latest"</code> or a JSON string that specifies an ending offset for each <code>TopicPartition</code>.</p>
        pub fn ending_offsets(mut self, input: impl Into<std::string::String>) -> Self {
            self.ending_offsets = Some(input.into());
            self
        }
        /// <p>The end point when a batch query is ended. Possible values are either <code>"latest"</code> or a JSON string that specifies an ending offset for each <code>TopicPartition</code>.</p>
        pub fn set_ending_offsets(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.ending_offsets = input;
            self
        }
        /// <p>The timeout in milliseconds to poll data from Kafka in Spark job executors. The default value is <code>512</code>.</p>
        pub fn poll_timeout_ms(mut self, input: i64) -> Self {
            self.poll_timeout_ms = Some(input);
            self
        }
        /// <p>The timeout in milliseconds to poll data from Kafka in Spark job executors. The default value is <code>512</code>.</p>
        pub fn set_poll_timeout_ms(mut self, input: std::option::Option<i64>) -> Self {
            self.poll_timeout_ms = input;
            self
        }
        /// <p>The number of times to retry before failing to fetch Kafka offsets. The default value is <code>3</code>.</p>
        pub fn num_retries(mut self, input: i32) -> Self {
            self.num_retries = Some(input);
            self
        }
        /// <p>The number of times to retry before failing to fetch Kafka offsets. The default value is <code>3</code>.</p>
        pub fn set_num_retries(mut self, input: std::option::Option<i32>) -> Self {
            self.num_retries = input;
            self
        }
        /// <p>The time in milliseconds to wait before retrying to fetch Kafka offsets. The default value is <code>10</code>.</p>
        pub fn retry_interval_ms(mut self, input: i64) -> Self {
            self.retry_interval_ms = Some(input);
            self
        }
        /// <p>The time in milliseconds to wait before retrying to fetch Kafka offsets. The default value is <code>10</code>.</p>
        pub fn set_retry_interval_ms(mut self, input: std::option::Option<i64>) -> Self {
            self.retry_interval_ms = input;
            self
        }
        /// <p>The rate limit on the maximum number of offsets that are processed per trigger interval. The specified total number of offsets is proportionally split across <code>topicPartitions</code> of different volumes. The default value is null, which means that the consumer reads all offsets until the known latest offset.</p>
        pub fn max_offsets_per_trigger(mut self, input: i64) -> Self {
            self.max_offsets_per_trigger = Some(input);
            self
        }
        /// <p>The rate limit on the maximum number of offsets that are processed per trigger interval. The specified total number of offsets is proportionally split across <code>topicPartitions</code> of different volumes. The default value is null, which means that the consumer reads all offsets until the known latest offset.</p>
        pub fn set_max_offsets_per_trigger(mut self, input: std::option::Option<i64>) -> Self {
            self.max_offsets_per_trigger = input;
            self
        }
        /// <p>The desired minimum number of partitions to read from Kafka. The default value is null, which means that the number of spark partitions is equal to the number of Kafka partitions.</p>
        pub fn min_partitions(mut self, input: i32) -> Self {
            self.min_partitions = Some(input);
            self
        }
        /// <p>The desired minimum number of partitions to read from Kafka. The default value is null, which means that the number of spark partitions is equal to the number of Kafka partitions.</p>
        pub fn set_min_partitions(mut self, input: std::option::Option<i32>) -> Self {
            self.min_partitions = input;
            self
        }
        /// Consumes the builder and constructs a [`KafkaStreamingSourceOptions`](crate::model::KafkaStreamingSourceOptions).
        pub fn build(self) -> crate::model::KafkaStreamingSourceOptions {
            crate::model::KafkaStreamingSourceOptions {
                bootstrap_servers: self.bootstrap_servers,
                security_protocol: self.security_protocol,
                connection_name: self.connection_name,
                topic_name: self.topic_name,
                assign: self.assign,
                subscribe_pattern: self.subscribe_pattern,
                classification: self.classification,
                delimiter: self.delimiter,
                starting_offsets: self.starting_offsets,
                ending_offsets: self.ending_offsets,
                poll_timeout_ms: self.poll_timeout_ms,
                num_retries: self.num_retries,
                retry_interval_ms: self.retry_interval_ms,
                max_offsets_per_trigger: self.max_offsets_per_trigger,
                min_partitions: self.min_partitions,
            }
        }
    }
}
impl KafkaStreamingSourceOptions {
    /// Creates a new builder-style object to manufacture [`KafkaStreamingSourceOptions`](crate::model::KafkaStreamingSourceOptions).
    pub fn builder() -> crate::model::kafka_streaming_source_options::Builder {
        crate::model::kafka_streaming_source_options::Builder::default()
    }
}

/// <p>Specifies a Kinesis data source in the Glue Data Catalog.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CatalogKinesisSource {
    /// <p>The name of the data source.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The amount of time to spend processing each micro batch.</p>
    #[doc(hidden)]
    pub window_size: std::option::Option<i32>,
    /// <p>Whether to automatically determine the schema from the incoming data.</p>
    #[doc(hidden)]
    pub detect_schema: std::option::Option<bool>,
    /// <p>The name of the table in the database to read from.</p>
    #[doc(hidden)]
    pub table: std::option::Option<std::string::String>,
    /// <p>The name of the database to read from.</p>
    #[doc(hidden)]
    pub database: std::option::Option<std::string::String>,
    /// <p>Additional options for the Kinesis streaming data source.</p>
    #[doc(hidden)]
    pub streaming_options: std::option::Option<crate::model::KinesisStreamingSourceOptions>,
    /// <p>Additional options for data preview.</p>
    #[doc(hidden)]
    pub data_preview_options: std::option::Option<crate::model::StreamingDataPreviewOptions>,
}
impl CatalogKinesisSource {
    /// <p>The name of the data source.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The amount of time to spend processing each micro batch.</p>
    pub fn window_size(&self) -> std::option::Option<i32> {
        self.window_size
    }
    /// <p>Whether to automatically determine the schema from the incoming data.</p>
    pub fn detect_schema(&self) -> std::option::Option<bool> {
        self.detect_schema
    }
    /// <p>The name of the table in the database to read from.</p>
    pub fn table(&self) -> std::option::Option<&str> {
        self.table.as_deref()
    }
    /// <p>The name of the database to read from.</p>
    pub fn database(&self) -> std::option::Option<&str> {
        self.database.as_deref()
    }
    /// <p>Additional options for the Kinesis streaming data source.</p>
    pub fn streaming_options(
        &self,
    ) -> std::option::Option<&crate::model::KinesisStreamingSourceOptions> {
        self.streaming_options.as_ref()
    }
    /// <p>Additional options for data preview.</p>
    pub fn data_preview_options(
        &self,
    ) -> std::option::Option<&crate::model::StreamingDataPreviewOptions> {
        self.data_preview_options.as_ref()
    }
}
/// See [`CatalogKinesisSource`](crate::model::CatalogKinesisSource).
pub mod catalog_kinesis_source {

    /// A builder for [`CatalogKinesisSource`](crate::model::CatalogKinesisSource).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) window_size: std::option::Option<i32>,
        pub(crate) detect_schema: std::option::Option<bool>,
        pub(crate) table: std::option::Option<std::string::String>,
        pub(crate) database: std::option::Option<std::string::String>,
        pub(crate) streaming_options:
            std::option::Option<crate::model::KinesisStreamingSourceOptions>,
        pub(crate) data_preview_options:
            std::option::Option<crate::model::StreamingDataPreviewOptions>,
    }
    impl Builder {
        /// <p>The name of the data source.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the data source.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The amount of time to spend processing each micro batch.</p>
        pub fn window_size(mut self, input: i32) -> Self {
            self.window_size = Some(input);
            self
        }
        /// <p>The amount of time to spend processing each micro batch.</p>
        pub fn set_window_size(mut self, input: std::option::Option<i32>) -> Self {
            self.window_size = input;
            self
        }
        /// <p>Whether to automatically determine the schema from the incoming data.</p>
        pub fn detect_schema(mut self, input: bool) -> Self {
            self.detect_schema = Some(input);
            self
        }
        /// <p>Whether to automatically determine the schema from the incoming data.</p>
        pub fn set_detect_schema(mut self, input: std::option::Option<bool>) -> Self {
            self.detect_schema = input;
            self
        }
        /// <p>The name of the table in the database to read from.</p>
        pub fn table(mut self, input: impl Into<std::string::String>) -> Self {
            self.table = Some(input.into());
            self
        }
        /// <p>The name of the table in the database to read from.</p>
        pub fn set_table(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.table = input;
            self
        }
        /// <p>The name of the database to read from.</p>
        pub fn database(mut self, input: impl Into<std::string::String>) -> Self {
            self.database = Some(input.into());
            self
        }
        /// <p>The name of the database to read from.</p>
        pub fn set_database(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.database = input;
            self
        }
        /// <p>Additional options for the Kinesis streaming data source.</p>
        pub fn streaming_options(
            mut self,
            input: crate::model::KinesisStreamingSourceOptions,
        ) -> Self {
            self.streaming_options = Some(input);
            self
        }
        /// <p>Additional options for the Kinesis streaming data source.</p>
        pub fn set_streaming_options(
            mut self,
            input: std::option::Option<crate::model::KinesisStreamingSourceOptions>,
        ) -> Self {
            self.streaming_options = input;
            self
        }
        /// <p>Additional options for data preview.</p>
        pub fn data_preview_options(
            mut self,
            input: crate::model::StreamingDataPreviewOptions,
        ) -> Self {
            self.data_preview_options = Some(input);
            self
        }
        /// <p>Additional options for data preview.</p>
        pub fn set_data_preview_options(
            mut self,
            input: std::option::Option<crate::model::StreamingDataPreviewOptions>,
        ) -> Self {
            self.data_preview_options = input;
            self
        }
        /// Consumes the builder and constructs a [`CatalogKinesisSource`](crate::model::CatalogKinesisSource).
        pub fn build(self) -> crate::model::CatalogKinesisSource {
            crate::model::CatalogKinesisSource {
                name: self.name,
                window_size: self.window_size,
                detect_schema: self.detect_schema,
                table: self.table,
                database: self.database,
                streaming_options: self.streaming_options,
                data_preview_options: self.data_preview_options,
            }
        }
    }
}
impl CatalogKinesisSource {
    /// Creates a new builder-style object to manufacture [`CatalogKinesisSource`](crate::model::CatalogKinesisSource).
    pub fn builder() -> crate::model::catalog_kinesis_source::Builder {
        crate::model::catalog_kinesis_source::Builder::default()
    }
}

/// <p>Additional options for the Amazon Kinesis streaming data source.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct KinesisStreamingSourceOptions {
    /// <p>The URL of the Kinesis endpoint.</p>
    #[doc(hidden)]
    pub endpoint_url: std::option::Option<std::string::String>,
    /// <p>The name of the Kinesis data stream.</p>
    #[doc(hidden)]
    pub stream_name: std::option::Option<std::string::String>,
    /// <p>An optional classification.</p>
    #[doc(hidden)]
    pub classification: std::option::Option<std::string::String>,
    /// <p>Specifies the delimiter character.</p>
    #[doc(hidden)]
    pub delimiter: std::option::Option<std::string::String>,
    /// <p>The starting position in the Kinesis data stream to read data from. The possible values are <code>"latest"</code>, <code>"trim_horizon"</code>, or <code>"earliest"</code>. The default value is <code>"latest"</code>.</p>
    #[doc(hidden)]
    pub starting_position: std::option::Option<crate::model::StartingPosition>,
    /// <p>The maximum time spent in the job executor to fetch a record from the Kinesis data stream per shard, specified in milliseconds (ms). The default value is <code>1000</code>.</p>
    #[doc(hidden)]
    pub max_fetch_time_in_ms: std::option::Option<i64>,
    /// <p>The maximum number of records to fetch per shard in the Kinesis data stream. The default value is <code>100000</code>.</p>
    #[doc(hidden)]
    pub max_fetch_records_per_shard: std::option::Option<i64>,
    /// <p>The maximum number of records to fetch from the Kinesis data stream in each getRecords operation. The default value is <code>10000</code>.</p>
    #[doc(hidden)]
    pub max_record_per_read: std::option::Option<i64>,
    /// <p>Adds a time delay between two consecutive getRecords operations. The default value is <code>"False"</code>. This option is only configurable for Glue version 2.0 and above.</p>
    #[doc(hidden)]
    pub add_idle_time_between_reads: std::option::Option<bool>,
    /// <p>The minimum time delay between two consecutive getRecords operations, specified in ms. The default value is <code>1000</code>. This option is only configurable for Glue version 2.0 and above.</p>
    #[doc(hidden)]
    pub idle_time_between_reads_in_ms: std::option::Option<i64>,
    /// <p>The minimum time interval between two ListShards API calls for your script to consider resharding. The default value is <code>1s</code>.</p>
    #[doc(hidden)]
    pub describe_shard_interval: std::option::Option<i64>,
    /// <p>The maximum number of retries for Kinesis Data Streams API requests. The default value is <code>3</code>.</p>
    #[doc(hidden)]
    pub num_retries: std::option::Option<i32>,
    /// <p>The cool-off time period (specified in ms) before retrying the Kinesis Data Streams API call. The default value is <code>1000</code>.</p>
    #[doc(hidden)]
    pub retry_interval_ms: std::option::Option<i64>,
    /// <p>The maximum cool-off time period (specified in ms) between two retries of a Kinesis Data Streams API call. The default value is <code>10000</code>.</p>
    #[doc(hidden)]
    pub max_retry_interval_ms: std::option::Option<i64>,
    /// <p>Avoids creating an empty microbatch job by checking for unread data in the Kinesis data stream before the batch is started. The default value is <code>"False"</code>.</p>
    #[doc(hidden)]
    pub avoid_empty_batches: std::option::Option<bool>,
    /// <p>The Amazon Resource Name (ARN) of the Kinesis data stream.</p>
    #[doc(hidden)]
    pub stream_arn: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the role to assume using AWS Security Token Service (AWS STS). This role must have permissions for describe or read record operations for the Kinesis data stream. You must use this parameter when accessing a data stream in a different account. Used in conjunction with <code>"awsSTSSessionName"</code>.</p>
    #[doc(hidden)]
    pub role_arn: std::option::Option<std::string::String>,
    /// <p>An identifier for the session assuming the role using AWS STS. You must use this parameter when accessing a data stream in a different account. Used in conjunction with <code>"awsSTSRoleARN"</code>.</p>
    #[doc(hidden)]
    pub role_session_name: std::option::Option<std::string::String>,
}
impl KinesisStreamingSourceOptions {
    /// <p>The URL of the Kinesis endpoint.</p>
    pub fn endpoint_url(&self) -> std::option::Option<&str> {
        self.endpoint_url.as_deref()
    }
    /// <p>The name of the Kinesis data stream.</p>
    pub fn stream_name(&self) -> std::option::Option<&str> {
        self.stream_name.as_deref()
    }
    /// <p>An optional classification.</p>
    pub fn classification(&self) -> std::option::Option<&str> {
        self.classification.as_deref()
    }
    /// <p>Specifies the delimiter character.</p>
    pub fn delimiter(&self) -> std::option::Option<&str> {
        self.delimiter.as_deref()
    }
    /// <p>The starting position in the Kinesis data stream to read data from. The possible values are <code>"latest"</code>, <code>"trim_horizon"</code>, or <code>"earliest"</code>. The default value is <code>"latest"</code>.</p>
    pub fn starting_position(&self) -> std::option::Option<&crate::model::StartingPosition> {
        self.starting_position.as_ref()
    }
    /// <p>The maximum time spent in the job executor to fetch a record from the Kinesis data stream per shard, specified in milliseconds (ms). The default value is <code>1000</code>.</p>
    pub fn max_fetch_time_in_ms(&self) -> std::option::Option<i64> {
        self.max_fetch_time_in_ms
    }
    /// <p>The maximum number of records to fetch per shard in the Kinesis data stream. The default value is <code>100000</code>.</p>
    pub fn max_fetch_records_per_shard(&self) -> std::option::Option<i64> {
        self.max_fetch_records_per_shard
    }
    /// <p>The maximum number of records to fetch from the Kinesis data stream in each getRecords operation. The default value is <code>10000</code>.</p>
    pub fn max_record_per_read(&self) -> std::option::Option<i64> {
        self.max_record_per_read
    }
    /// <p>Adds a time delay between two consecutive getRecords operations. The default value is <code>"False"</code>. This option is only configurable for Glue version 2.0 and above.</p>
    pub fn add_idle_time_between_reads(&self) -> std::option::Option<bool> {
        self.add_idle_time_between_reads
    }
    /// <p>The minimum time delay between two consecutive getRecords operations, specified in ms. The default value is <code>1000</code>. This option is only configurable for Glue version 2.0 and above.</p>
    pub fn idle_time_between_reads_in_ms(&self) -> std::option::Option<i64> {
        self.idle_time_between_reads_in_ms
    }
    /// <p>The minimum time interval between two ListShards API calls for your script to consider resharding. The default value is <code>1s</code>.</p>
    pub fn describe_shard_interval(&self) -> std::option::Option<i64> {
        self.describe_shard_interval
    }
    /// <p>The maximum number of retries for Kinesis Data Streams API requests. The default value is <code>3</code>.</p>
    pub fn num_retries(&self) -> std::option::Option<i32> {
        self.num_retries
    }
    /// <p>The cool-off time period (specified in ms) before retrying the Kinesis Data Streams API call. The default value is <code>1000</code>.</p>
    pub fn retry_interval_ms(&self) -> std::option::Option<i64> {
        self.retry_interval_ms
    }
    /// <p>The maximum cool-off time period (specified in ms) between two retries of a Kinesis Data Streams API call. The default value is <code>10000</code>.</p>
    pub fn max_retry_interval_ms(&self) -> std::option::Option<i64> {
        self.max_retry_interval_ms
    }
    /// <p>Avoids creating an empty microbatch job by checking for unread data in the Kinesis data stream before the batch is started. The default value is <code>"False"</code>.</p>
    pub fn avoid_empty_batches(&self) -> std::option::Option<bool> {
        self.avoid_empty_batches
    }
    /// <p>The Amazon Resource Name (ARN) of the Kinesis data stream.</p>
    pub fn stream_arn(&self) -> std::option::Option<&str> {
        self.stream_arn.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the role to assume using AWS Security Token Service (AWS STS). This role must have permissions for describe or read record operations for the Kinesis data stream. You must use this parameter when accessing a data stream in a different account. Used in conjunction with <code>"awsSTSSessionName"</code>.</p>
    pub fn role_arn(&self) -> std::option::Option<&str> {
        self.role_arn.as_deref()
    }
    /// <p>An identifier for the session assuming the role using AWS STS. You must use this parameter when accessing a data stream in a different account. Used in conjunction with <code>"awsSTSRoleARN"</code>.</p>
    pub fn role_session_name(&self) -> std::option::Option<&str> {
        self.role_session_name.as_deref()
    }
}
/// See [`KinesisStreamingSourceOptions`](crate::model::KinesisStreamingSourceOptions).
pub mod kinesis_streaming_source_options {

    /// A builder for [`KinesisStreamingSourceOptions`](crate::model::KinesisStreamingSourceOptions).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) endpoint_url: std::option::Option<std::string::String>,
        pub(crate) stream_name: std::option::Option<std::string::String>,
        pub(crate) classification: std::option::Option<std::string::String>,
        pub(crate) delimiter: std::option::Option<std::string::String>,
        pub(crate) starting_position: std::option::Option<crate::model::StartingPosition>,
        pub(crate) max_fetch_time_in_ms: std::option::Option<i64>,
        pub(crate) max_fetch_records_per_shard: std::option::Option<i64>,
        pub(crate) max_record_per_read: std::option::Option<i64>,
        pub(crate) add_idle_time_between_reads: std::option::Option<bool>,
        pub(crate) idle_time_between_reads_in_ms: std::option::Option<i64>,
        pub(crate) describe_shard_interval: std::option::Option<i64>,
        pub(crate) num_retries: std::option::Option<i32>,
        pub(crate) retry_interval_ms: std::option::Option<i64>,
        pub(crate) max_retry_interval_ms: std::option::Option<i64>,
        pub(crate) avoid_empty_batches: std::option::Option<bool>,
        pub(crate) stream_arn: std::option::Option<std::string::String>,
        pub(crate) role_arn: std::option::Option<std::string::String>,
        pub(crate) role_session_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The URL of the Kinesis endpoint.</p>
        pub fn endpoint_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.endpoint_url = Some(input.into());
            self
        }
        /// <p>The URL of the Kinesis endpoint.</p>
        pub fn set_endpoint_url(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.endpoint_url = input;
            self
        }
        /// <p>The name of the Kinesis data stream.</p>
        pub fn stream_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.stream_name = Some(input.into());
            self
        }
        /// <p>The name of the Kinesis data stream.</p>
        pub fn set_stream_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.stream_name = input;
            self
        }
        /// <p>An optional classification.</p>
        pub fn classification(mut self, input: impl Into<std::string::String>) -> Self {
            self.classification = Some(input.into());
            self
        }
        /// <p>An optional classification.</p>
        pub fn set_classification(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.classification = input;
            self
        }
        /// <p>Specifies the delimiter character.</p>
        pub fn delimiter(mut self, input: impl Into<std::string::String>) -> Self {
            self.delimiter = Some(input.into());
            self
        }
        /// <p>Specifies the delimiter character.</p>
        pub fn set_delimiter(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.delimiter = input;
            self
        }
        /// <p>The starting position in the Kinesis data stream to read data from. The possible values are <code>"latest"</code>, <code>"trim_horizon"</code>, or <code>"earliest"</code>. The default value is <code>"latest"</code>.</p>
        pub fn starting_position(mut self, input: crate::model::StartingPosition) -> Self {
            self.starting_position = Some(input);
            self
        }
        /// <p>The starting position in the Kinesis data stream to read data from. The possible values are <code>"latest"</code>, <code>"trim_horizon"</code>, or <code>"earliest"</code>. The default value is <code>"latest"</code>.</p>
        pub fn set_starting_position(
            mut self,
            input: std::option::Option<crate::model::StartingPosition>,
        ) -> Self {
            self.starting_position = input;
            self
        }
        /// <p>The maximum time spent in the job executor to fetch a record from the Kinesis data stream per shard, specified in milliseconds (ms). The default value is <code>1000</code>.</p>
        pub fn max_fetch_time_in_ms(mut self, input: i64) -> Self {
            self.max_fetch_time_in_ms = Some(input);
            self
        }
        /// <p>The maximum time spent in the job executor to fetch a record from the Kinesis data stream per shard, specified in milliseconds (ms). The default value is <code>1000</code>.</p>
        pub fn set_max_fetch_time_in_ms(mut self, input: std::option::Option<i64>) -> Self {
            self.max_fetch_time_in_ms = input;
            self
        }
        /// <p>The maximum number of records to fetch per shard in the Kinesis data stream. The default value is <code>100000</code>.</p>
        pub fn max_fetch_records_per_shard(mut self, input: i64) -> Self {
            self.max_fetch_records_per_shard = Some(input);
            self
        }
        /// <p>The maximum number of records to fetch per shard in the Kinesis data stream. The default value is <code>100000</code>.</p>
        pub fn set_max_fetch_records_per_shard(mut self, input: std::option::Option<i64>) -> Self {
            self.max_fetch_records_per_shard = input;
            self
        }
        /// <p>The maximum number of records to fetch from the Kinesis data stream in each getRecords operation. The default value is <code>10000</code>.</p>
        pub fn max_record_per_read(mut self, input: i64) -> Self {
            self.max_record_per_read = Some(input);
            self
        }
        /// <p>The maximum number of records to fetch from the Kinesis data stream in each getRecords operation. The default value is <code>10000</code>.</p>
        pub fn set_max_record_per_read(mut self, input: std::option::Option<i64>) -> Self {
            self.max_record_per_read = input;
            self
        }
        /// <p>Adds a time delay between two consecutive getRecords operations. The default value is <code>"False"</code>. This option is only configurable for Glue version 2.0 and above.</p>
        pub fn add_idle_time_between_reads(mut self, input: bool) -> Self {
            self.add_idle_time_between_reads = Some(input);
            self
        }
        /// <p>Adds a time delay between two consecutive getRecords operations. The default value is <code>"False"</code>. This option is only configurable for Glue version 2.0 and above.</p>
        pub fn set_add_idle_time_between_reads(mut self, input: std::option::Option<bool>) -> Self {
            self.add_idle_time_between_reads = input;
            self
        }
        /// <p>The minimum time delay between two consecutive getRecords operations, specified in ms. The default value is <code>1000</code>. This option is only configurable for Glue version 2.0 and above.</p>
        pub fn idle_time_between_reads_in_ms(mut self, input: i64) -> Self {
            self.idle_time_between_reads_in_ms = Some(input);
            self
        }
        /// <p>The minimum time delay between two consecutive getRecords operations, specified in ms. The default value is <code>1000</code>. This option is only configurable for Glue version 2.0 and above.</p>
        pub fn set_idle_time_between_reads_in_ms(
            mut self,
            input: std::option::Option<i64>,
        ) -> Self {
            self.idle_time_between_reads_in_ms = input;
            self
        }
        /// <p>The minimum time interval between two ListShards API calls for your script to consider resharding. The default value is <code>1s</code>.</p>
        pub fn describe_shard_interval(mut self, input: i64) -> Self {
            self.describe_shard_interval = Some(input);
            self
        }
        /// <p>The minimum time interval between two ListShards API calls for your script to consider resharding. The default value is <code>1s</code>.</p>
        pub fn set_describe_shard_interval(mut self, input: std::option::Option<i64>) -> Self {
            self.describe_shard_interval = input;
            self
        }
        /// <p>The maximum number of retries for Kinesis Data Streams API requests. The default value is <code>3</code>.</p>
        pub fn num_retries(mut self, input: i32) -> Self {
            self.num_retries = Some(input);
            self
        }
        /// <p>The maximum number of retries for Kinesis Data Streams API requests. The default value is <code>3</code>.</p>
        pub fn set_num_retries(mut self, input: std::option::Option<i32>) -> Self {
            self.num_retries = input;
            self
        }
        /// <p>The cool-off time period (specified in ms) before retrying the Kinesis Data Streams API call. The default value is <code>1000</code>.</p>
        pub fn retry_interval_ms(mut self, input: i64) -> Self {
            self.retry_interval_ms = Some(input);
            self
        }
        /// <p>The cool-off time period (specified in ms) before retrying the Kinesis Data Streams API call. The default value is <code>1000</code>.</p>
        pub fn set_retry_interval_ms(mut self, input: std::option::Option<i64>) -> Self {
            self.retry_interval_ms = input;
            self
        }
        /// <p>The maximum cool-off time period (specified in ms) between two retries of a Kinesis Data Streams API call. The default value is <code>10000</code>.</p>
        pub fn max_retry_interval_ms(mut self, input: i64) -> Self {
            self.max_retry_interval_ms = Some(input);
            self
        }
        /// <p>The maximum cool-off time period (specified in ms) between two retries of a Kinesis Data Streams API call. The default value is <code>10000</code>.</p>
        pub fn set_max_retry_interval_ms(mut self, input: std::option::Option<i64>) -> Self {
            self.max_retry_interval_ms = input;
            self
        }
        /// <p>Avoids creating an empty microbatch job by checking for unread data in the Kinesis data stream before the batch is started. The default value is <code>"False"</code>.</p>
        pub fn avoid_empty_batches(mut self, input: bool) -> Self {
            self.avoid_empty_batches = Some(input);
            self
        }
        /// <p>Avoids creating an empty microbatch job by checking for unread data in the Kinesis data stream before the batch is started. The default value is <code>"False"</code>.</p>
        pub fn set_avoid_empty_batches(mut self, input: std::option::Option<bool>) -> Self {
            self.avoid_empty_batches = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the Kinesis data stream.</p>
        pub fn stream_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.stream_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the Kinesis data stream.</p>
        pub fn set_stream_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.stream_arn = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the role to assume using AWS Security Token Service (AWS STS). This role must have permissions for describe or read record operations for the Kinesis data stream. You must use this parameter when accessing a data stream in a different account. Used in conjunction with <code>"awsSTSSessionName"</code>.</p>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.role_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the role to assume using AWS Security Token Service (AWS STS). This role must have permissions for describe or read record operations for the Kinesis data stream. You must use this parameter when accessing a data stream in a different account. Used in conjunction with <code>"awsSTSSessionName"</code>.</p>
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.role_arn = input;
            self
        }
        /// <p>An identifier for the session assuming the role using AWS STS. You must use this parameter when accessing a data stream in a different account. Used in conjunction with <code>"awsSTSRoleARN"</code>.</p>
        pub fn role_session_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.role_session_name = Some(input.into());
            self
        }
        /// <p>An identifier for the session assuming the role using AWS STS. You must use this parameter when accessing a data stream in a different account. Used in conjunction with <code>"awsSTSRoleARN"</code>.</p>
        pub fn set_role_session_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.role_session_name = input;
            self
        }
        /// Consumes the builder and constructs a [`KinesisStreamingSourceOptions`](crate::model::KinesisStreamingSourceOptions).
        pub fn build(self) -> crate::model::KinesisStreamingSourceOptions {
            crate::model::KinesisStreamingSourceOptions {
                endpoint_url: self.endpoint_url,
                stream_name: self.stream_name,
                classification: self.classification,
                delimiter: self.delimiter,
                starting_position: self.starting_position,
                max_fetch_time_in_ms: self.max_fetch_time_in_ms,
                max_fetch_records_per_shard: self.max_fetch_records_per_shard,
                max_record_per_read: self.max_record_per_read,
                add_idle_time_between_reads: self.add_idle_time_between_reads,
                idle_time_between_reads_in_ms: self.idle_time_between_reads_in_ms,
                describe_shard_interval: self.describe_shard_interval,
                num_retries: self.num_retries,
                retry_interval_ms: self.retry_interval_ms,
                max_retry_interval_ms: self.max_retry_interval_ms,
                avoid_empty_batches: self.avoid_empty_batches,
                stream_arn: self.stream_arn,
                role_arn: self.role_arn,
                role_session_name: self.role_session_name,
            }
        }
    }
}
impl KinesisStreamingSourceOptions {
    /// Creates a new builder-style object to manufacture [`KinesisStreamingSourceOptions`](crate::model::KinesisStreamingSourceOptions).
    pub fn builder() -> crate::model::kinesis_streaming_source_options::Builder {
        crate::model::kinesis_streaming_source_options::Builder::default()
    }
}

/// When writing a match expression against `StartingPosition`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let startingposition = unimplemented!();
/// match startingposition {
///     StartingPosition::Earliest => { /* ... */ },
///     StartingPosition::Latest => { /* ... */ },
///     StartingPosition::TrimHorizon => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `startingposition` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `StartingPosition::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `StartingPosition::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `StartingPosition::NewFeature` is defined.
/// Specifically, when `startingposition` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `StartingPosition::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum StartingPosition {
    #[allow(missing_docs)] // documentation missing in model
    Earliest,
    #[allow(missing_docs)] // documentation missing in model
    Latest,
    #[allow(missing_docs)] // documentation missing in model
    TrimHorizon,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for StartingPosition {
    fn from(s: &str) -> Self {
        match s {
            "earliest" => StartingPosition::Earliest,
            "latest" => StartingPosition::Latest,
            "trim_horizon" => StartingPosition::TrimHorizon,
            other => StartingPosition::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for StartingPosition {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(StartingPosition::from(s))
    }
}
impl StartingPosition {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            StartingPosition::Earliest => "earliest",
            StartingPosition::Latest => "latest",
            StartingPosition::TrimHorizon => "trim_horizon",
            StartingPosition::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["earliest", "latest", "trim_horizon"]
    }
}
impl AsRef<str> for StartingPosition {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Specifies an Apache Kafka data store.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DirectKafkaSource {
    /// <p>The name of the data store.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>Specifies the streaming options.</p>
    #[doc(hidden)]
    pub streaming_options: std::option::Option<crate::model::KafkaStreamingSourceOptions>,
    /// <p>The amount of time to spend processing each micro batch.</p>
    #[doc(hidden)]
    pub window_size: std::option::Option<i32>,
    /// <p>Whether to automatically determine the schema from the incoming data.</p>
    #[doc(hidden)]
    pub detect_schema: std::option::Option<bool>,
    /// <p>Specifies options related to data preview for viewing a sample of your data.</p>
    #[doc(hidden)]
    pub data_preview_options: std::option::Option<crate::model::StreamingDataPreviewOptions>,
}
impl DirectKafkaSource {
    /// <p>The name of the data store.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>Specifies the streaming options.</p>
    pub fn streaming_options(
        &self,
    ) -> std::option::Option<&crate::model::KafkaStreamingSourceOptions> {
        self.streaming_options.as_ref()
    }
    /// <p>The amount of time to spend processing each micro batch.</p>
    pub fn window_size(&self) -> std::option::Option<i32> {
        self.window_size
    }
    /// <p>Whether to automatically determine the schema from the incoming data.</p>
    pub fn detect_schema(&self) -> std::option::Option<bool> {
        self.detect_schema
    }
    /// <p>Specifies options related to data preview for viewing a sample of your data.</p>
    pub fn data_preview_options(
        &self,
    ) -> std::option::Option<&crate::model::StreamingDataPreviewOptions> {
        self.data_preview_options.as_ref()
    }
}
/// See [`DirectKafkaSource`](crate::model::DirectKafkaSource).
pub mod direct_kafka_source {

    /// A builder for [`DirectKafkaSource`](crate::model::DirectKafkaSource).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) streaming_options:
            std::option::Option<crate::model::KafkaStreamingSourceOptions>,
        pub(crate) window_size: std::option::Option<i32>,
        pub(crate) detect_schema: std::option::Option<bool>,
        pub(crate) data_preview_options:
            std::option::Option<crate::model::StreamingDataPreviewOptions>,
    }
    impl Builder {
        /// <p>The name of the data store.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the data store.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>Specifies the streaming options.</p>
        pub fn streaming_options(
            mut self,
            input: crate::model::KafkaStreamingSourceOptions,
        ) -> Self {
            self.streaming_options = Some(input);
            self
        }
        /// <p>Specifies the streaming options.</p>
        pub fn set_streaming_options(
            mut self,
            input: std::option::Option<crate::model::KafkaStreamingSourceOptions>,
        ) -> Self {
            self.streaming_options = input;
            self
        }
        /// <p>The amount of time to spend processing each micro batch.</p>
        pub fn window_size(mut self, input: i32) -> Self {
            self.window_size = Some(input);
            self
        }
        /// <p>The amount of time to spend processing each micro batch.</p>
        pub fn set_window_size(mut self, input: std::option::Option<i32>) -> Self {
            self.window_size = input;
            self
        }
        /// <p>Whether to automatically determine the schema from the incoming data.</p>
        pub fn detect_schema(mut self, input: bool) -> Self {
            self.detect_schema = Some(input);
            self
        }
        /// <p>Whether to automatically determine the schema from the incoming data.</p>
        pub fn set_detect_schema(mut self, input: std::option::Option<bool>) -> Self {
            self.detect_schema = input;
            self
        }
        /// <p>Specifies options related to data preview for viewing a sample of your data.</p>
        pub fn data_preview_options(
            mut self,
            input: crate::model::StreamingDataPreviewOptions,
        ) -> Self {
            self.data_preview_options = Some(input);
            self
        }
        /// <p>Specifies options related to data preview for viewing a sample of your data.</p>
        pub fn set_data_preview_options(
            mut self,
            input: std::option::Option<crate::model::StreamingDataPreviewOptions>,
        ) -> Self {
            self.data_preview_options = input;
            self
        }
        /// Consumes the builder and constructs a [`DirectKafkaSource`](crate::model::DirectKafkaSource).
        pub fn build(self) -> crate::model::DirectKafkaSource {
            crate::model::DirectKafkaSource {
                name: self.name,
                streaming_options: self.streaming_options,
                window_size: self.window_size,
                detect_schema: self.detect_schema,
                data_preview_options: self.data_preview_options,
            }
        }
    }
}
impl DirectKafkaSource {
    /// Creates a new builder-style object to manufacture [`DirectKafkaSource`](crate::model::DirectKafkaSource).
    pub fn builder() -> crate::model::direct_kafka_source::Builder {
        crate::model::direct_kafka_source::Builder::default()
    }
}

/// <p>Specifies a direct Amazon Kinesis data source.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DirectKinesisSource {
    /// <p>The name of the data source.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The amount of time to spend processing each micro batch.</p>
    #[doc(hidden)]
    pub window_size: std::option::Option<i32>,
    /// <p>Whether to automatically determine the schema from the incoming data.</p>
    #[doc(hidden)]
    pub detect_schema: std::option::Option<bool>,
    /// <p>Additional options for the Kinesis streaming data source.</p>
    #[doc(hidden)]
    pub streaming_options: std::option::Option<crate::model::KinesisStreamingSourceOptions>,
    /// <p>Additional options for data preview.</p>
    #[doc(hidden)]
    pub data_preview_options: std::option::Option<crate::model::StreamingDataPreviewOptions>,
}
impl DirectKinesisSource {
    /// <p>The name of the data source.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The amount of time to spend processing each micro batch.</p>
    pub fn window_size(&self) -> std::option::Option<i32> {
        self.window_size
    }
    /// <p>Whether to automatically determine the schema from the incoming data.</p>
    pub fn detect_schema(&self) -> std::option::Option<bool> {
        self.detect_schema
    }
    /// <p>Additional options for the Kinesis streaming data source.</p>
    pub fn streaming_options(
        &self,
    ) -> std::option::Option<&crate::model::KinesisStreamingSourceOptions> {
        self.streaming_options.as_ref()
    }
    /// <p>Additional options for data preview.</p>
    pub fn data_preview_options(
        &self,
    ) -> std::option::Option<&crate::model::StreamingDataPreviewOptions> {
        self.data_preview_options.as_ref()
    }
}
/// See [`DirectKinesisSource`](crate::model::DirectKinesisSource).
pub mod direct_kinesis_source {

    /// A builder for [`DirectKinesisSource`](crate::model::DirectKinesisSource).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) window_size: std::option::Option<i32>,
        pub(crate) detect_schema: std::option::Option<bool>,
        pub(crate) streaming_options:
            std::option::Option<crate::model::KinesisStreamingSourceOptions>,
        pub(crate) data_preview_options:
            std::option::Option<crate::model::StreamingDataPreviewOptions>,
    }
    impl Builder {
        /// <p>The name of the data source.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the data source.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The amount of time to spend processing each micro batch.</p>
        pub fn window_size(mut self, input: i32) -> Self {
            self.window_size = Some(input);
            self
        }
        /// <p>The amount of time to spend processing each micro batch.</p>
        pub fn set_window_size(mut self, input: std::option::Option<i32>) -> Self {
            self.window_size = input;
            self
        }
        /// <p>Whether to automatically determine the schema from the incoming data.</p>
        pub fn detect_schema(mut self, input: bool) -> Self {
            self.detect_schema = Some(input);
            self
        }
        /// <p>Whether to automatically determine the schema from the incoming data.</p>
        pub fn set_detect_schema(mut self, input: std::option::Option<bool>) -> Self {
            self.detect_schema = input;
            self
        }
        /// <p>Additional options for the Kinesis streaming data source.</p>
        pub fn streaming_options(
            mut self,
            input: crate::model::KinesisStreamingSourceOptions,
        ) -> Self {
            self.streaming_options = Some(input);
            self
        }
        /// <p>Additional options for the Kinesis streaming data source.</p>
        pub fn set_streaming_options(
            mut self,
            input: std::option::Option<crate::model::KinesisStreamingSourceOptions>,
        ) -> Self {
            self.streaming_options = input;
            self
        }
        /// <p>Additional options for data preview.</p>
        pub fn data_preview_options(
            mut self,
            input: crate::model::StreamingDataPreviewOptions,
        ) -> Self {
            self.data_preview_options = Some(input);
            self
        }
        /// <p>Additional options for data preview.</p>
        pub fn set_data_preview_options(
            mut self,
            input: std::option::Option<crate::model::StreamingDataPreviewOptions>,
        ) -> Self {
            self.data_preview_options = input;
            self
        }
        /// Consumes the builder and constructs a [`DirectKinesisSource`](crate::model::DirectKinesisSource).
        pub fn build(self) -> crate::model::DirectKinesisSource {
            crate::model::DirectKinesisSource {
                name: self.name,
                window_size: self.window_size,
                detect_schema: self.detect_schema,
                streaming_options: self.streaming_options,
                data_preview_options: self.data_preview_options,
            }
        }
    }
}
impl DirectKinesisSource {
    /// Creates a new builder-style object to manufacture [`DirectKinesisSource`](crate::model::DirectKinesisSource).
    pub fn builder() -> crate::model::direct_kinesis_source::Builder {
        crate::model::direct_kinesis_source::Builder::default()
    }
}

/// <p>Specifies a transform where you enter a SQL query using Spark SQL syntax to transform the data. The output is a single <code>DynamicFrame</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SparkSql {
    /// <p>The name of the transform node.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The data inputs identified by their node names. You can associate a table name with each input node to use in the SQL query. The name you choose must meet the Spark SQL naming restrictions.</p>
    #[doc(hidden)]
    pub inputs: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A SQL query that must use Spark SQL syntax and return a single data set.</p>
    #[doc(hidden)]
    pub sql_query: std::option::Option<std::string::String>,
    /// <p>A list of aliases. An alias allows you to specify what name to use in the SQL for a given input. For example, you have a datasource named "MyDataSource". If you specify <code>From</code> as MyDataSource, and <code>Alias</code> as SqlName, then in your SQL you can do:</p>
    /// <p> <code>select * from SqlName</code> </p>
    /// <p>and that gets data from MyDataSource.</p>
    #[doc(hidden)]
    pub sql_aliases: std::option::Option<std::vec::Vec<crate::model::SqlAlias>>,
    /// <p>Specifies the data schema for the SparkSQL transform.</p>
    #[doc(hidden)]
    pub output_schemas: std::option::Option<std::vec::Vec<crate::model::GlueSchema>>,
}
impl SparkSql {
    /// <p>The name of the transform node.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The data inputs identified by their node names. You can associate a table name with each input node to use in the SQL query. The name you choose must meet the Spark SQL naming restrictions.</p>
    pub fn inputs(&self) -> std::option::Option<&[std::string::String]> {
        self.inputs.as_deref()
    }
    /// <p>A SQL query that must use Spark SQL syntax and return a single data set.</p>
    pub fn sql_query(&self) -> std::option::Option<&str> {
        self.sql_query.as_deref()
    }
    /// <p>A list of aliases. An alias allows you to specify what name to use in the SQL for a given input. For example, you have a datasource named "MyDataSource". If you specify <code>From</code> as MyDataSource, and <code>Alias</code> as SqlName, then in your SQL you can do:</p>
    /// <p> <code>select * from SqlName</code> </p>
    /// <p>and that gets data from MyDataSource.</p>
    pub fn sql_aliases(&self) -> std::option::Option<&[crate::model::SqlAlias]> {
        self.sql_aliases.as_deref()
    }
    /// <p>Specifies the data schema for the SparkSQL transform.</p>
    pub fn output_schemas(&self) -> std::option::Option<&[crate::model::GlueSchema]> {
        self.output_schemas.as_deref()
    }
}
/// See [`SparkSql`](crate::model::SparkSql).
pub mod spark_sql {

    /// A builder for [`SparkSql`](crate::model::SparkSql).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) inputs: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) sql_query: std::option::Option<std::string::String>,
        pub(crate) sql_aliases: std::option::Option<std::vec::Vec<crate::model::SqlAlias>>,
        pub(crate) output_schemas: std::option::Option<std::vec::Vec<crate::model::GlueSchema>>,
    }
    impl Builder {
        /// <p>The name of the transform node.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the transform node.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Appends an item to `inputs`.
        ///
        /// To override the contents of this collection use [`set_inputs`](Self::set_inputs).
        ///
        /// <p>The data inputs identified by their node names. You can associate a table name with each input node to use in the SQL query. The name you choose must meet the Spark SQL naming restrictions.</p>
        pub fn inputs(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.inputs.unwrap_or_default();
            v.push(input.into());
            self.inputs = Some(v);
            self
        }
        /// <p>The data inputs identified by their node names. You can associate a table name with each input node to use in the SQL query. The name you choose must meet the Spark SQL naming restrictions.</p>
        pub fn set_inputs(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inputs = input;
            self
        }
        /// <p>A SQL query that must use Spark SQL syntax and return a single data set.</p>
        pub fn sql_query(mut self, input: impl Into<std::string::String>) -> Self {
            self.sql_query = Some(input.into());
            self
        }
        /// <p>A SQL query that must use Spark SQL syntax and return a single data set.</p>
        pub fn set_sql_query(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.sql_query = input;
            self
        }
        /// Appends an item to `sql_aliases`.
        ///
        /// To override the contents of this collection use [`set_sql_aliases`](Self::set_sql_aliases).
        ///
        /// <p>A list of aliases. An alias allows you to specify what name to use in the SQL for a given input. For example, you have a datasource named "MyDataSource". If you specify <code>From</code> as MyDataSource, and <code>Alias</code> as SqlName, then in your SQL you can do:</p>
        /// <p> <code>select * from SqlName</code> </p>
        /// <p>and that gets data from MyDataSource.</p>
        pub fn sql_aliases(mut self, input: crate::model::SqlAlias) -> Self {
            let mut v = self.sql_aliases.unwrap_or_default();
            v.push(input);
            self.sql_aliases = Some(v);
            self
        }
        /// <p>A list of aliases. An alias allows you to specify what name to use in the SQL for a given input. For example, you have a datasource named "MyDataSource". If you specify <code>From</code> as MyDataSource, and <code>Alias</code> as SqlName, then in your SQL you can do:</p>
        /// <p> <code>select * from SqlName</code> </p>
        /// <p>and that gets data from MyDataSource.</p>
        pub fn set_sql_aliases(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::SqlAlias>>,
        ) -> Self {
            self.sql_aliases = input;
            self
        }
        /// Appends an item to `output_schemas`.
        ///
        /// To override the contents of this collection use [`set_output_schemas`](Self::set_output_schemas).
        ///
        /// <p>Specifies the data schema for the SparkSQL transform.</p>
        pub fn output_schemas(mut self, input: crate::model::GlueSchema) -> Self {
            let mut v = self.output_schemas.unwrap_or_default();
            v.push(input);
            self.output_schemas = Some(v);
            self
        }
        /// <p>Specifies the data schema for the SparkSQL transform.</p>
        pub fn set_output_schemas(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::GlueSchema>>,
        ) -> Self {
            self.output_schemas = input;
            self
        }
        /// Consumes the builder and constructs a [`SparkSql`](crate::model::SparkSql).
        pub fn build(self) -> crate::model::SparkSql {
            crate::model::SparkSql {
                name: self.name,
                inputs: self.inputs,
                sql_query: self.sql_query,
                sql_aliases: self.sql_aliases,
                output_schemas: self.output_schemas,
            }
        }
    }
}
impl SparkSql {
    /// Creates a new builder-style object to manufacture [`SparkSql`](crate::model::SparkSql).
    pub fn builder() -> crate::model::spark_sql::Builder {
        crate::model::spark_sql::Builder::default()
    }
}

/// <p>Represents a single entry in the list of values for <code>SqlAliases</code>. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SqlAlias {
    /// <p>A table, or a column in a table.</p>
    #[doc(hidden)]
    pub from: std::option::Option<std::string::String>,
    /// <p>A temporary name given to a table, or a column in a table.</p>
    #[doc(hidden)]
    pub alias: std::option::Option<std::string::String>,
}
impl SqlAlias {
    /// <p>A table, or a column in a table.</p>
    pub fn from(&self) -> std::option::Option<&str> {
        self.from.as_deref()
    }
    /// <p>A temporary name given to a table, or a column in a table.</p>
    pub fn alias(&self) -> std::option::Option<&str> {
        self.alias.as_deref()
    }
}
/// See [`SqlAlias`](crate::model::SqlAlias).
pub mod sql_alias {

    /// A builder for [`SqlAlias`](crate::model::SqlAlias).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) from: std::option::Option<std::string::String>,
        pub(crate) alias: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A table, or a column in a table.</p>
        pub fn from(mut self, input: impl Into<std::string::String>) -> Self {
            self.from = Some(input.into());
            self
        }
        /// <p>A table, or a column in a table.</p>
        pub fn set_from(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.from = input;
            self
        }
        /// <p>A temporary name given to a table, or a column in a table.</p>
        pub fn alias(mut self, input: impl Into<std::string::String>) -> Self {
            self.alias = Some(input.into());
            self
        }
        /// <p>A temporary name given to a table, or a column in a table.</p>
        pub fn set_alias(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.alias = input;
            self
        }
        /// Consumes the builder and constructs a [`SqlAlias`](crate::model::SqlAlias).
        pub fn build(self) -> crate::model::SqlAlias {
            crate::model::SqlAlias {
                from: self.from,
                alias: self.alias,
            }
        }
    }
}
impl SqlAlias {
    /// Creates a new builder-style object to manufacture [`SqlAlias`](crate::model::SqlAlias).
    pub fn builder() -> crate::model::sql_alias::Builder {
        crate::model::sql_alias::Builder::default()
    }
}

/// <p>Specifies a transform that uses custom code you provide to perform the data transformation. The output is a collection of DynamicFrames.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CustomCode {
    /// <p>The name of the transform node.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The data inputs identified by their node names.</p>
    #[doc(hidden)]
    pub inputs: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The custom code that is used to perform the data transformation.</p>
    #[doc(hidden)]
    pub code: std::option::Option<std::string::String>,
    /// <p>The name defined for the custom code node class.</p>
    #[doc(hidden)]
    pub class_name: std::option::Option<std::string::String>,
    /// <p>Specifies the data schema for the custom code transform.</p>
    #[doc(hidden)]
    pub output_schemas: std::option::Option<std::vec::Vec<crate::model::GlueSchema>>,
}
impl CustomCode {
    /// <p>The name of the transform node.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The data inputs identified by their node names.</p>
    pub fn inputs(&self) -> std::option::Option<&[std::string::String]> {
        self.inputs.as_deref()
    }
    /// <p>The custom code that is used to perform the data transformation.</p>
    pub fn code(&self) -> std::option::Option<&str> {
        self.code.as_deref()
    }
    /// <p>The name defined for the custom code node class.</p>
    pub fn class_name(&self) -> std::option::Option<&str> {
        self.class_name.as_deref()
    }
    /// <p>Specifies the data schema for the custom code transform.</p>
    pub fn output_schemas(&self) -> std::option::Option<&[crate::model::GlueSchema]> {
        self.output_schemas.as_deref()
    }
}
/// See [`CustomCode`](crate::model::CustomCode).
pub mod custom_code {

    /// A builder for [`CustomCode`](crate::model::CustomCode).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) inputs: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) code: std::option::Option<std::string::String>,
        pub(crate) class_name: std::option::Option<std::string::String>,
        pub(crate) output_schemas: std::option::Option<std::vec::Vec<crate::model::GlueSchema>>,
    }
    impl Builder {
        /// <p>The name of the transform node.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the transform node.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Appends an item to `inputs`.
        ///
        /// To override the contents of this collection use [`set_inputs`](Self::set_inputs).
        ///
        /// <p>The data inputs identified by their node names.</p>
        pub fn inputs(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.inputs.unwrap_or_default();
            v.push(input.into());
            self.inputs = Some(v);
            self
        }
        /// <p>The data inputs identified by their node names.</p>
        pub fn set_inputs(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inputs = input;
            self
        }
        /// <p>The custom code that is used to perform the data transformation.</p>
        pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
            self.code = Some(input.into());
            self
        }
        /// <p>The custom code that is used to perform the data transformation.</p>
        pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.code = input;
            self
        }
        /// <p>The name defined for the custom code node class.</p>
        pub fn class_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.class_name = Some(input.into());
            self
        }
        /// <p>The name defined for the custom code node class.</p>
        pub fn set_class_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.class_name = input;
            self
        }
        /// Appends an item to `output_schemas`.
        ///
        /// To override the contents of this collection use [`set_output_schemas`](Self::set_output_schemas).
        ///
        /// <p>Specifies the data schema for the custom code transform.</p>
        pub fn output_schemas(mut self, input: crate::model::GlueSchema) -> Self {
            let mut v = self.output_schemas.unwrap_or_default();
            v.push(input);
            self.output_schemas = Some(v);
            self
        }
        /// <p>Specifies the data schema for the custom code transform.</p>
        pub fn set_output_schemas(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::GlueSchema>>,
        ) -> Self {
            self.output_schemas = input;
            self
        }
        /// Consumes the builder and constructs a [`CustomCode`](crate::model::CustomCode).
        pub fn build(self) -> crate::model::CustomCode {
            crate::model::CustomCode {
                name: self.name,
                inputs: self.inputs,
                code: self.code,
                class_name: self.class_name,
                output_schemas: self.output_schemas,
            }
        }
    }
}
impl CustomCode {
    /// Creates a new builder-style object to manufacture [`CustomCode`](crate::model::CustomCode).
    pub fn builder() -> crate::model::custom_code::Builder {
        crate::model::custom_code::Builder::default()
    }
}

/// <p>Specifies a transform that splits a dataset into two, based on a filter condition.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Filter {
    /// <p>The name of the transform node.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The data inputs identified by their node names.</p>
    #[doc(hidden)]
    pub inputs: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The operator used to filter rows by comparing the key value to a specified value.</p>
    #[doc(hidden)]
    pub logical_operator: std::option::Option<crate::model::FilterLogicalOperator>,
    /// <p>Specifies a filter expression.</p>
    #[doc(hidden)]
    pub filters: std::option::Option<std::vec::Vec<crate::model::FilterExpression>>,
}
impl Filter {
    /// <p>The name of the transform node.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The data inputs identified by their node names.</p>
    pub fn inputs(&self) -> std::option::Option<&[std::string::String]> {
        self.inputs.as_deref()
    }
    /// <p>The operator used to filter rows by comparing the key value to a specified value.</p>
    pub fn logical_operator(&self) -> std::option::Option<&crate::model::FilterLogicalOperator> {
        self.logical_operator.as_ref()
    }
    /// <p>Specifies a filter expression.</p>
    pub fn filters(&self) -> std::option::Option<&[crate::model::FilterExpression]> {
        self.filters.as_deref()
    }
}
/// See [`Filter`](crate::model::Filter).
pub mod filter {

    /// A builder for [`Filter`](crate::model::Filter).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) inputs: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) logical_operator: std::option::Option<crate::model::FilterLogicalOperator>,
        pub(crate) filters: std::option::Option<std::vec::Vec<crate::model::FilterExpression>>,
    }
    impl Builder {
        /// <p>The name of the transform node.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the transform node.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Appends an item to `inputs`.
        ///
        /// To override the contents of this collection use [`set_inputs`](Self::set_inputs).
        ///
        /// <p>The data inputs identified by their node names.</p>
        pub fn inputs(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.inputs.unwrap_or_default();
            v.push(input.into());
            self.inputs = Some(v);
            self
        }
        /// <p>The data inputs identified by their node names.</p>
        pub fn set_inputs(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inputs = input;
            self
        }
        /// <p>The operator used to filter rows by comparing the key value to a specified value.</p>
        pub fn logical_operator(mut self, input: crate::model::FilterLogicalOperator) -> Self {
            self.logical_operator = Some(input);
            self
        }
        /// <p>The operator used to filter rows by comparing the key value to a specified value.</p>
        pub fn set_logical_operator(
            mut self,
            input: std::option::Option<crate::model::FilterLogicalOperator>,
        ) -> Self {
            self.logical_operator = input;
            self
        }
        /// Appends an item to `filters`.
        ///
        /// To override the contents of this collection use [`set_filters`](Self::set_filters).
        ///
        /// <p>Specifies a filter expression.</p>
        pub fn filters(mut self, input: crate::model::FilterExpression) -> Self {
            let mut v = self.filters.unwrap_or_default();
            v.push(input);
            self.filters = Some(v);
            self
        }
        /// <p>Specifies a filter expression.</p>
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::FilterExpression>>,
        ) -> Self {
            self.filters = input;
            self
        }
        /// Consumes the builder and constructs a [`Filter`](crate::model::Filter).
        pub fn build(self) -> crate::model::Filter {
            crate::model::Filter {
                name: self.name,
                inputs: self.inputs,
                logical_operator: self.logical_operator,
                filters: self.filters,
            }
        }
    }
}
impl Filter {
    /// Creates a new builder-style object to manufacture [`Filter`](crate::model::Filter).
    pub fn builder() -> crate::model::filter::Builder {
        crate::model::filter::Builder::default()
    }
}

/// <p>Specifies a filter expression.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FilterExpression {
    /// <p>The type of operation to perform in the expression.</p>
    #[doc(hidden)]
    pub operation: std::option::Option<crate::model::FilterOperation>,
    /// <p>Whether the expression is to be negated.</p>
    #[doc(hidden)]
    pub negated: std::option::Option<bool>,
    /// <p>A list of filter values.</p>
    #[doc(hidden)]
    pub values: std::option::Option<std::vec::Vec<crate::model::FilterValue>>,
}
impl FilterExpression {
    /// <p>The type of operation to perform in the expression.</p>
    pub fn operation(&self) -> std::option::Option<&crate::model::FilterOperation> {
        self.operation.as_ref()
    }
    /// <p>Whether the expression is to be negated.</p>
    pub fn negated(&self) -> std::option::Option<bool> {
        self.negated
    }
    /// <p>A list of filter values.</p>
    pub fn values(&self) -> std::option::Option<&[crate::model::FilterValue]> {
        self.values.as_deref()
    }
}
/// See [`FilterExpression`](crate::model::FilterExpression).
pub mod filter_expression {

    /// A builder for [`FilterExpression`](crate::model::FilterExpression).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) operation: std::option::Option<crate::model::FilterOperation>,
        pub(crate) negated: std::option::Option<bool>,
        pub(crate) values: std::option::Option<std::vec::Vec<crate::model::FilterValue>>,
    }
    impl Builder {
        /// <p>The type of operation to perform in the expression.</p>
        pub fn operation(mut self, input: crate::model::FilterOperation) -> Self {
            self.operation = Some(input);
            self
        }
        /// <p>The type of operation to perform in the expression.</p>
        pub fn set_operation(
            mut self,
            input: std::option::Option<crate::model::FilterOperation>,
        ) -> Self {
            self.operation = input;
            self
        }
        /// <p>Whether the expression is to be negated.</p>
        pub fn negated(mut self, input: bool) -> Self {
            self.negated = Some(input);
            self
        }
        /// <p>Whether the expression is to be negated.</p>
        pub fn set_negated(mut self, input: std::option::Option<bool>) -> Self {
            self.negated = input;
            self
        }
        /// Appends an item to `values`.
        ///
        /// To override the contents of this collection use [`set_values`](Self::set_values).
        ///
        /// <p>A list of filter values.</p>
        pub fn values(mut self, input: crate::model::FilterValue) -> Self {
            let mut v = self.values.unwrap_or_default();
            v.push(input);
            self.values = Some(v);
            self
        }
        /// <p>A list of filter values.</p>
        pub fn set_values(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::FilterValue>>,
        ) -> Self {
            self.values = input;
            self
        }
        /// Consumes the builder and constructs a [`FilterExpression`](crate::model::FilterExpression).
        pub fn build(self) -> crate::model::FilterExpression {
            crate::model::FilterExpression {
                operation: self.operation,
                negated: self.negated,
                values: self.values,
            }
        }
    }
}
impl FilterExpression {
    /// Creates a new builder-style object to manufacture [`FilterExpression`](crate::model::FilterExpression).
    pub fn builder() -> crate::model::filter_expression::Builder {
        crate::model::filter_expression::Builder::default()
    }
}

/// <p>Represents a single entry in the list of values for a <code>FilterExpression</code>. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FilterValue {
    /// <p>The type of filter value.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::FilterValueType>,
    /// <p>The value to be associated.</p>
    #[doc(hidden)]
    pub value: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl FilterValue {
    /// <p>The type of filter value.</p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::FilterValueType> {
        self.r#type.as_ref()
    }
    /// <p>The value to be associated.</p>
    pub fn value(&self) -> std::option::Option<&[std::string::String]> {
        self.value.as_deref()
    }
}
/// See [`FilterValue`](crate::model::FilterValue).
pub mod filter_value {

    /// A builder for [`FilterValue`](crate::model::FilterValue).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<crate::model::FilterValueType>,
        pub(crate) value: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The type of filter value.</p>
        pub fn r#type(mut self, input: crate::model::FilterValueType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The type of filter value.</p>
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::FilterValueType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// Appends an item to `value`.
        ///
        /// To override the contents of this collection use [`set_value`](Self::set_value).
        ///
        /// <p>The value to be associated.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.value.unwrap_or_default();
            v.push(input.into());
            self.value = Some(v);
            self
        }
        /// <p>The value to be associated.</p>
        pub fn set_value(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`FilterValue`](crate::model::FilterValue).
        pub fn build(self) -> crate::model::FilterValue {
            crate::model::FilterValue {
                r#type: self.r#type,
                value: self.value,
            }
        }
    }
}
impl FilterValue {
    /// Creates a new builder-style object to manufacture [`FilterValue`](crate::model::FilterValue).
    pub fn builder() -> crate::model::filter_value::Builder {
        crate::model::filter_value::Builder::default()
    }
}

/// When writing a match expression against `FilterValueType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let filtervaluetype = unimplemented!();
/// match filtervaluetype {
///     FilterValueType::Columnextracted => { /* ... */ },
///     FilterValueType::Constant => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `filtervaluetype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `FilterValueType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `FilterValueType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `FilterValueType::NewFeature` is defined.
/// Specifically, when `filtervaluetype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `FilterValueType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum FilterValueType {
    #[allow(missing_docs)] // documentation missing in model
    Columnextracted,
    #[allow(missing_docs)] // documentation missing in model
    Constant,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for FilterValueType {
    fn from(s: &str) -> Self {
        match s {
            "COLUMNEXTRACTED" => FilterValueType::Columnextracted,
            "CONSTANT" => FilterValueType::Constant,
            other => FilterValueType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for FilterValueType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(FilterValueType::from(s))
    }
}
impl FilterValueType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            FilterValueType::Columnextracted => "COLUMNEXTRACTED",
            FilterValueType::Constant => "CONSTANT",
            FilterValueType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["COLUMNEXTRACTED", "CONSTANT"]
    }
}
impl AsRef<str> for FilterValueType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `FilterOperation`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let filteroperation = unimplemented!();
/// match filteroperation {
///     FilterOperation::Eq => { /* ... */ },
///     FilterOperation::Gt => { /* ... */ },
///     FilterOperation::Gte => { /* ... */ },
///     FilterOperation::Isnull => { /* ... */ },
///     FilterOperation::Lt => { /* ... */ },
///     FilterOperation::Lte => { /* ... */ },
///     FilterOperation::Regex => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `filteroperation` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `FilterOperation::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `FilterOperation::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `FilterOperation::NewFeature` is defined.
/// Specifically, when `filteroperation` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `FilterOperation::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum FilterOperation {
    #[allow(missing_docs)] // documentation missing in model
    Eq,
    #[allow(missing_docs)] // documentation missing in model
    Gt,
    #[allow(missing_docs)] // documentation missing in model
    Gte,
    #[allow(missing_docs)] // documentation missing in model
    Isnull,
    #[allow(missing_docs)] // documentation missing in model
    Lt,
    #[allow(missing_docs)] // documentation missing in model
    Lte,
    #[allow(missing_docs)] // documentation missing in model
    Regex,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for FilterOperation {
    fn from(s: &str) -> Self {
        match s {
            "EQ" => FilterOperation::Eq,
            "GT" => FilterOperation::Gt,
            "GTE" => FilterOperation::Gte,
            "ISNULL" => FilterOperation::Isnull,
            "LT" => FilterOperation::Lt,
            "LTE" => FilterOperation::Lte,
            "REGEX" => FilterOperation::Regex,
            other => FilterOperation::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for FilterOperation {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(FilterOperation::from(s))
    }
}
impl FilterOperation {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            FilterOperation::Eq => "EQ",
            FilterOperation::Gt => "GT",
            FilterOperation::Gte => "GTE",
            FilterOperation::Isnull => "ISNULL",
            FilterOperation::Lt => "LT",
            FilterOperation::Lte => "LTE",
            FilterOperation::Regex => "REGEX",
            FilterOperation::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["EQ", "GT", "GTE", "ISNULL", "LT", "LTE", "REGEX"]
    }
}
impl AsRef<str> for FilterOperation {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `FilterLogicalOperator`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let filterlogicaloperator = unimplemented!();
/// match filterlogicaloperator {
///     FilterLogicalOperator::And => { /* ... */ },
///     FilterLogicalOperator::Or => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `filterlogicaloperator` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `FilterLogicalOperator::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `FilterLogicalOperator::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `FilterLogicalOperator::NewFeature` is defined.
/// Specifically, when `filterlogicaloperator` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `FilterLogicalOperator::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum FilterLogicalOperator {
    #[allow(missing_docs)] // documentation missing in model
    And,
    #[allow(missing_docs)] // documentation missing in model
    Or,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for FilterLogicalOperator {
    fn from(s: &str) -> Self {
        match s {
            "AND" => FilterLogicalOperator::And,
            "OR" => FilterLogicalOperator::Or,
            other => {
                FilterLogicalOperator::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for FilterLogicalOperator {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(FilterLogicalOperator::from(s))
    }
}
impl FilterLogicalOperator {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            FilterLogicalOperator::And => "AND",
            FilterLogicalOperator::Or => "OR",
            FilterLogicalOperator::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["AND", "OR"]
    }
}
impl AsRef<str> for FilterLogicalOperator {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Specifies a transform that locates records in the dataset that have missing values and adds a new field with a value determined by imputation. The input data set is used to train the machine learning model that determines what the missing value should be.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FillMissingValues {
    /// <p>The name of the transform node.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The data inputs identified by their node names.</p>
    #[doc(hidden)]
    pub inputs: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A JSON path to a variable in the data structure for the dataset that is imputed.</p>
    #[doc(hidden)]
    pub imputed_path: std::option::Option<std::string::String>,
    /// <p>A JSON path to a variable in the data structure for the dataset that is filled.</p>
    #[doc(hidden)]
    pub filled_path: std::option::Option<std::string::String>,
}
impl FillMissingValues {
    /// <p>The name of the transform node.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The data inputs identified by their node names.</p>
    pub fn inputs(&self) -> std::option::Option<&[std::string::String]> {
        self.inputs.as_deref()
    }
    /// <p>A JSON path to a variable in the data structure for the dataset that is imputed.</p>
    pub fn imputed_path(&self) -> std::option::Option<&str> {
        self.imputed_path.as_deref()
    }
    /// <p>A JSON path to a variable in the data structure for the dataset that is filled.</p>
    pub fn filled_path(&self) -> std::option::Option<&str> {
        self.filled_path.as_deref()
    }
}
/// See [`FillMissingValues`](crate::model::FillMissingValues).
pub mod fill_missing_values {

    /// A builder for [`FillMissingValues`](crate::model::FillMissingValues).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) inputs: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) imputed_path: std::option::Option<std::string::String>,
        pub(crate) filled_path: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the transform node.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the transform node.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Appends an item to `inputs`.
        ///
        /// To override the contents of this collection use [`set_inputs`](Self::set_inputs).
        ///
        /// <p>The data inputs identified by their node names.</p>
        pub fn inputs(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.inputs.unwrap_or_default();
            v.push(input.into());
            self.inputs = Some(v);
            self
        }
        /// <p>The data inputs identified by their node names.</p>
        pub fn set_inputs(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inputs = input;
            self
        }
        /// <p>A JSON path to a variable in the data structure for the dataset that is imputed.</p>
        pub fn imputed_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.imputed_path = Some(input.into());
            self
        }
        /// <p>A JSON path to a variable in the data structure for the dataset that is imputed.</p>
        pub fn set_imputed_path(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.imputed_path = input;
            self
        }
        /// <p>A JSON path to a variable in the data structure for the dataset that is filled.</p>
        pub fn filled_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.filled_path = Some(input.into());
            self
        }
        /// <p>A JSON path to a variable in the data structure for the dataset that is filled.</p>
        pub fn set_filled_path(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.filled_path = input;
            self
        }
        /// Consumes the builder and constructs a [`FillMissingValues`](crate::model::FillMissingValues).
        pub fn build(self) -> crate::model::FillMissingValues {
            crate::model::FillMissingValues {
                name: self.name,
                inputs: self.inputs,
                imputed_path: self.imputed_path,
                filled_path: self.filled_path,
            }
        }
    }
}
impl FillMissingValues {
    /// Creates a new builder-style object to manufacture [`FillMissingValues`](crate::model::FillMissingValues).
    pub fn builder() -> crate::model::fill_missing_values::Builder {
        crate::model::fill_missing_values::Builder::default()
    }
}

/// <p>Specifies a transform that chooses one <code>DynamicFrame</code> from a collection of <code>DynamicFrames</code>. The output is the selected <code>DynamicFrame</code> </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SelectFromCollection {
    /// <p>The name of the transform node.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The data inputs identified by their node names.</p>
    #[doc(hidden)]
    pub inputs: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The index for the DynamicFrame to be selected.</p>
    #[doc(hidden)]
    pub index: i32,
}
impl SelectFromCollection {
    /// <p>The name of the transform node.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The data inputs identified by their node names.</p>
    pub fn inputs(&self) -> std::option::Option<&[std::string::String]> {
        self.inputs.as_deref()
    }
    /// <p>The index for the DynamicFrame to be selected.</p>
    pub fn index(&self) -> i32 {
        self.index
    }
}
/// See [`SelectFromCollection`](crate::model::SelectFromCollection).
pub mod select_from_collection {

    /// A builder for [`SelectFromCollection`](crate::model::SelectFromCollection).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) inputs: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) index: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The name of the transform node.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the transform node.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Appends an item to `inputs`.
        ///
        /// To override the contents of this collection use [`set_inputs`](Self::set_inputs).
        ///
        /// <p>The data inputs identified by their node names.</p>
        pub fn inputs(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.inputs.unwrap_or_default();
            v.push(input.into());
            self.inputs = Some(v);
            self
        }
        /// <p>The data inputs identified by their node names.</p>
        pub fn set_inputs(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inputs = input;
            self
        }
        /// <p>The index for the DynamicFrame to be selected.</p>
        pub fn index(mut self, input: i32) -> Self {
            self.index = Some(input);
            self
        }
        /// <p>The index for the DynamicFrame to be selected.</p>
        pub fn set_index(mut self, input: std::option::Option<i32>) -> Self {
            self.index = input;
            self
        }
        /// Consumes the builder and constructs a [`SelectFromCollection`](crate::model::SelectFromCollection).
        pub fn build(self) -> crate::model::SelectFromCollection {
            crate::model::SelectFromCollection {
                name: self.name,
                inputs: self.inputs,
                index: self.index.unwrap_or_default(),
            }
        }
    }
}
impl SelectFromCollection {
    /// Creates a new builder-style object to manufacture [`SelectFromCollection`](crate::model::SelectFromCollection).
    pub fn builder() -> crate::model::select_from_collection::Builder {
        crate::model::select_from_collection::Builder::default()
    }
}

/// <p>Specifies a transform that splits data property keys into two <code>DynamicFrames</code>. The output is a collection of <code>DynamicFrames</code>: one with selected data property keys, and one with the remaining data property keys.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SplitFields {
    /// <p>The name of the transform node.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The data inputs identified by their node names.</p>
    #[doc(hidden)]
    pub inputs: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A JSON path to a variable in the data structure.</p>
    #[doc(hidden)]
    pub paths: std::option::Option<std::vec::Vec<std::vec::Vec<std::string::String>>>,
}
impl SplitFields {
    /// <p>The name of the transform node.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The data inputs identified by their node names.</p>
    pub fn inputs(&self) -> std::option::Option<&[std::string::String]> {
        self.inputs.as_deref()
    }
    /// <p>A JSON path to a variable in the data structure.</p>
    pub fn paths(&self) -> std::option::Option<&[std::vec::Vec<std::string::String>]> {
        self.paths.as_deref()
    }
}
/// See [`SplitFields`](crate::model::SplitFields).
pub mod split_fields {

    /// A builder for [`SplitFields`](crate::model::SplitFields).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) inputs: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) paths: std::option::Option<std::vec::Vec<std::vec::Vec<std::string::String>>>,
    }
    impl Builder {
        /// <p>The name of the transform node.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the transform node.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Appends an item to `inputs`.
        ///
        /// To override the contents of this collection use [`set_inputs`](Self::set_inputs).
        ///
        /// <p>The data inputs identified by their node names.</p>
        pub fn inputs(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.inputs.unwrap_or_default();
            v.push(input.into());
            self.inputs = Some(v);
            self
        }
        /// <p>The data inputs identified by their node names.</p>
        pub fn set_inputs(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inputs = input;
            self
        }
        /// Appends an item to `paths`.
        ///
        /// To override the contents of this collection use [`set_paths`](Self::set_paths).
        ///
        /// <p>A JSON path to a variable in the data structure.</p>
        pub fn paths(mut self, input: std::vec::Vec<std::string::String>) -> Self {
            let mut v = self.paths.unwrap_or_default();
            v.push(input);
            self.paths = Some(v);
            self
        }
        /// <p>A JSON path to a variable in the data structure.</p>
        pub fn set_paths(
            mut self,
            input: std::option::Option<std::vec::Vec<std::vec::Vec<std::string::String>>>,
        ) -> Self {
            self.paths = input;
            self
        }
        /// Consumes the builder and constructs a [`SplitFields`](crate::model::SplitFields).
        pub fn build(self) -> crate::model::SplitFields {
            crate::model::SplitFields {
                name: self.name,
                inputs: self.inputs,
                paths: self.paths,
            }
        }
    }
}
impl SplitFields {
    /// Creates a new builder-style object to manufacture [`SplitFields`](crate::model::SplitFields).
    pub fn builder() -> crate::model::split_fields::Builder {
        crate::model::split_fields::Builder::default()
    }
}

/// <p>Specifies a transform that joins two datasets into one dataset using a comparison phrase on the specified data property keys. You can use inner, outer, left, right, left semi, and left anti joins.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Join {
    /// <p>The name of the transform node.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The data inputs identified by their node names.</p>
    #[doc(hidden)]
    pub inputs: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Specifies the type of join to be performed on the datasets.</p>
    #[doc(hidden)]
    pub join_type: std::option::Option<crate::model::JoinType>,
    /// <p>A list of the two columns to be joined.</p>
    #[doc(hidden)]
    pub columns: std::option::Option<std::vec::Vec<crate::model::JoinColumn>>,
}
impl Join {
    /// <p>The name of the transform node.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The data inputs identified by their node names.</p>
    pub fn inputs(&self) -> std::option::Option<&[std::string::String]> {
        self.inputs.as_deref()
    }
    /// <p>Specifies the type of join to be performed on the datasets.</p>
    pub fn join_type(&self) -> std::option::Option<&crate::model::JoinType> {
        self.join_type.as_ref()
    }
    /// <p>A list of the two columns to be joined.</p>
    pub fn columns(&self) -> std::option::Option<&[crate::model::JoinColumn]> {
        self.columns.as_deref()
    }
}
/// See [`Join`](crate::model::Join).
pub mod join {

    /// A builder for [`Join`](crate::model::Join).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) inputs: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) join_type: std::option::Option<crate::model::JoinType>,
        pub(crate) columns: std::option::Option<std::vec::Vec<crate::model::JoinColumn>>,
    }
    impl Builder {
        /// <p>The name of the transform node.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the transform node.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Appends an item to `inputs`.
        ///
        /// To override the contents of this collection use [`set_inputs`](Self::set_inputs).
        ///
        /// <p>The data inputs identified by their node names.</p>
        pub fn inputs(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.inputs.unwrap_or_default();
            v.push(input.into());
            self.inputs = Some(v);
            self
        }
        /// <p>The data inputs identified by their node names.</p>
        pub fn set_inputs(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inputs = input;
            self
        }
        /// <p>Specifies the type of join to be performed on the datasets.</p>
        pub fn join_type(mut self, input: crate::model::JoinType) -> Self {
            self.join_type = Some(input);
            self
        }
        /// <p>Specifies the type of join to be performed on the datasets.</p>
        pub fn set_join_type(mut self, input: std::option::Option<crate::model::JoinType>) -> Self {
            self.join_type = input;
            self
        }
        /// Appends an item to `columns`.
        ///
        /// To override the contents of this collection use [`set_columns`](Self::set_columns).
        ///
        /// <p>A list of the two columns to be joined.</p>
        pub fn columns(mut self, input: crate::model::JoinColumn) -> Self {
            let mut v = self.columns.unwrap_or_default();
            v.push(input);
            self.columns = Some(v);
            self
        }
        /// <p>A list of the two columns to be joined.</p>
        pub fn set_columns(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::JoinColumn>>,
        ) -> Self {
            self.columns = input;
            self
        }
        /// Consumes the builder and constructs a [`Join`](crate::model::Join).
        pub fn build(self) -> crate::model::Join {
            crate::model::Join {
                name: self.name,
                inputs: self.inputs,
                join_type: self.join_type,
                columns: self.columns,
            }
        }
    }
}
impl Join {
    /// Creates a new builder-style object to manufacture [`Join`](crate::model::Join).
    pub fn builder() -> crate::model::join::Builder {
        crate::model::join::Builder::default()
    }
}

/// <p>Specifies a column to be joined.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct JoinColumn {
    /// <p>The column to be joined.</p>
    #[doc(hidden)]
    pub from: std::option::Option<std::string::String>,
    /// <p>The key of the column to be joined.</p>
    #[doc(hidden)]
    pub keys: std::option::Option<std::vec::Vec<std::vec::Vec<std::string::String>>>,
}
impl JoinColumn {
    /// <p>The column to be joined.</p>
    pub fn from(&self) -> std::option::Option<&str> {
        self.from.as_deref()
    }
    /// <p>The key of the column to be joined.</p>
    pub fn keys(&self) -> std::option::Option<&[std::vec::Vec<std::string::String>]> {
        self.keys.as_deref()
    }
}
/// See [`JoinColumn`](crate::model::JoinColumn).
pub mod join_column {

    /// A builder for [`JoinColumn`](crate::model::JoinColumn).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) from: std::option::Option<std::string::String>,
        pub(crate) keys: std::option::Option<std::vec::Vec<std::vec::Vec<std::string::String>>>,
    }
    impl Builder {
        /// <p>The column to be joined.</p>
        pub fn from(mut self, input: impl Into<std::string::String>) -> Self {
            self.from = Some(input.into());
            self
        }
        /// <p>The column to be joined.</p>
        pub fn set_from(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.from = input;
            self
        }
        /// Appends an item to `keys`.
        ///
        /// To override the contents of this collection use [`set_keys`](Self::set_keys).
        ///
        /// <p>The key of the column to be joined.</p>
        pub fn keys(mut self, input: std::vec::Vec<std::string::String>) -> Self {
            let mut v = self.keys.unwrap_or_default();
            v.push(input);
            self.keys = Some(v);
            self
        }
        /// <p>The key of the column to be joined.</p>
        pub fn set_keys(
            mut self,
            input: std::option::Option<std::vec::Vec<std::vec::Vec<std::string::String>>>,
        ) -> Self {
            self.keys = input;
            self
        }
        /// Consumes the builder and constructs a [`JoinColumn`](crate::model::JoinColumn).
        pub fn build(self) -> crate::model::JoinColumn {
            crate::model::JoinColumn {
                from: self.from,
                keys: self.keys,
            }
        }
    }
}
impl JoinColumn {
    /// Creates a new builder-style object to manufacture [`JoinColumn`](crate::model::JoinColumn).
    pub fn builder() -> crate::model::join_column::Builder {
        crate::model::join_column::Builder::default()
    }
}

/// When writing a match expression against `JoinType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let jointype = unimplemented!();
/// match jointype {
///     JoinType::Equijoin => { /* ... */ },
///     JoinType::Left => { /* ... */ },
///     JoinType::LeftAnti => { /* ... */ },
///     JoinType::LeftSemi => { /* ... */ },
///     JoinType::Outer => { /* ... */ },
///     JoinType::Right => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `jointype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `JoinType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `JoinType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `JoinType::NewFeature` is defined.
/// Specifically, when `jointype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `JoinType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum JoinType {
    #[allow(missing_docs)] // documentation missing in model
    Equijoin,
    #[allow(missing_docs)] // documentation missing in model
    Left,
    #[allow(missing_docs)] // documentation missing in model
    LeftAnti,
    #[allow(missing_docs)] // documentation missing in model
    LeftSemi,
    #[allow(missing_docs)] // documentation missing in model
    Outer,
    #[allow(missing_docs)] // documentation missing in model
    Right,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for JoinType {
    fn from(s: &str) -> Self {
        match s {
            "equijoin" => JoinType::Equijoin,
            "left" => JoinType::Left,
            "leftanti" => JoinType::LeftAnti,
            "leftsemi" => JoinType::LeftSemi,
            "outer" => JoinType::Outer,
            "right" => JoinType::Right,
            other => JoinType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for JoinType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(JoinType::from(s))
    }
}
impl JoinType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            JoinType::Equijoin => "equijoin",
            JoinType::Left => "left",
            JoinType::LeftAnti => "leftanti",
            JoinType::LeftSemi => "leftsemi",
            JoinType::Outer => "outer",
            JoinType::Right => "right",
            JoinType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["equijoin", "left", "leftanti", "leftsemi", "outer", "right"]
    }
}
impl AsRef<str> for JoinType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Specifies a transform that writes samples of the data to an Amazon S3 bucket.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Spigot {
    /// <p>The name of the transform node.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The data inputs identified by their node names.</p>
    #[doc(hidden)]
    pub inputs: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A path in Amazon S3 where the transform will write a subset of records from the dataset to a JSON file in an Amazon S3 bucket.</p>
    #[doc(hidden)]
    pub path: std::option::Option<std::string::String>,
    /// <p>Specifies a number of records to write starting from the beginning of the dataset.</p>
    #[doc(hidden)]
    pub topk: std::option::Option<i32>,
    /// <p>The probability (a decimal value with a maximum value of 1) of picking any given record. A value of 1 indicates that each row read from the dataset should be included in the sample output.</p>
    #[doc(hidden)]
    pub prob: std::option::Option<f64>,
}
impl Spigot {
    /// <p>The name of the transform node.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The data inputs identified by their node names.</p>
    pub fn inputs(&self) -> std::option::Option<&[std::string::String]> {
        self.inputs.as_deref()
    }
    /// <p>A path in Amazon S3 where the transform will write a subset of records from the dataset to a JSON file in an Amazon S3 bucket.</p>
    pub fn path(&self) -> std::option::Option<&str> {
        self.path.as_deref()
    }
    /// <p>Specifies a number of records to write starting from the beginning of the dataset.</p>
    pub fn topk(&self) -> std::option::Option<i32> {
        self.topk
    }
    /// <p>The probability (a decimal value with a maximum value of 1) of picking any given record. A value of 1 indicates that each row read from the dataset should be included in the sample output.</p>
    pub fn prob(&self) -> std::option::Option<f64> {
        self.prob
    }
}
/// See [`Spigot`](crate::model::Spigot).
pub mod spigot {

    /// A builder for [`Spigot`](crate::model::Spigot).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) inputs: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) path: std::option::Option<std::string::String>,
        pub(crate) topk: std::option::Option<i32>,
        pub(crate) prob: std::option::Option<f64>,
    }
    impl Builder {
        /// <p>The name of the transform node.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the transform node.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Appends an item to `inputs`.
        ///
        /// To override the contents of this collection use [`set_inputs`](Self::set_inputs).
        ///
        /// <p>The data inputs identified by their node names.</p>
        pub fn inputs(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.inputs.unwrap_or_default();
            v.push(input.into());
            self.inputs = Some(v);
            self
        }
        /// <p>The data inputs identified by their node names.</p>
        pub fn set_inputs(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inputs = input;
            self
        }
        /// <p>A path in Amazon S3 where the transform will write a subset of records from the dataset to a JSON file in an Amazon S3 bucket.</p>
        pub fn path(mut self, input: impl Into<std::string::String>) -> Self {
            self.path = Some(input.into());
            self
        }
        /// <p>A path in Amazon S3 where the transform will write a subset of records from the dataset to a JSON file in an Amazon S3 bucket.</p>
        pub fn set_path(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.path = input;
            self
        }
        /// <p>Specifies a number of records to write starting from the beginning of the dataset.</p>
        pub fn topk(mut self, input: i32) -> Self {
            self.topk = Some(input);
            self
        }
        /// <p>Specifies a number of records to write starting from the beginning of the dataset.</p>
        pub fn set_topk(mut self, input: std::option::Option<i32>) -> Self {
            self.topk = input;
            self
        }
        /// <p>The probability (a decimal value with a maximum value of 1) of picking any given record. A value of 1 indicates that each row read from the dataset should be included in the sample output.</p>
        pub fn prob(mut self, input: f64) -> Self {
            self.prob = Some(input);
            self
        }
        /// <p>The probability (a decimal value with a maximum value of 1) of picking any given record. A value of 1 indicates that each row read from the dataset should be included in the sample output.</p>
        pub fn set_prob(mut self, input: std::option::Option<f64>) -> Self {
            self.prob = input;
            self
        }
        /// Consumes the builder and constructs a [`Spigot`](crate::model::Spigot).
        pub fn build(self) -> crate::model::Spigot {
            crate::model::Spigot {
                name: self.name,
                inputs: self.inputs,
                path: self.path,
                topk: self.topk,
                prob: self.prob,
            }
        }
    }
}
impl Spigot {
    /// Creates a new builder-style object to manufacture [`Spigot`](crate::model::Spigot).
    pub fn builder() -> crate::model::spigot::Builder {
        crate::model::spigot::Builder::default()
    }
}

/// <p>Specifies a transform that renames a single data property key.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RenameField {
    /// <p>The name of the transform node.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The data inputs identified by their node names.</p>
    #[doc(hidden)]
    pub inputs: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A JSON path to a variable in the data structure for the source data.</p>
    #[doc(hidden)]
    pub source_path: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A JSON path to a variable in the data structure for the target data.</p>
    #[doc(hidden)]
    pub target_path: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl RenameField {
    /// <p>The name of the transform node.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The data inputs identified by their node names.</p>
    pub fn inputs(&self) -> std::option::Option<&[std::string::String]> {
        self.inputs.as_deref()
    }
    /// <p>A JSON path to a variable in the data structure for the source data.</p>
    pub fn source_path(&self) -> std::option::Option<&[std::string::String]> {
        self.source_path.as_deref()
    }
    /// <p>A JSON path to a variable in the data structure for the target data.</p>
    pub fn target_path(&self) -> std::option::Option<&[std::string::String]> {
        self.target_path.as_deref()
    }
}
/// See [`RenameField`](crate::model::RenameField).
pub mod rename_field {

    /// A builder for [`RenameField`](crate::model::RenameField).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) inputs: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) source_path: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) target_path: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The name of the transform node.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the transform node.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Appends an item to `inputs`.
        ///
        /// To override the contents of this collection use [`set_inputs`](Self::set_inputs).
        ///
        /// <p>The data inputs identified by their node names.</p>
        pub fn inputs(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.inputs.unwrap_or_default();
            v.push(input.into());
            self.inputs = Some(v);
            self
        }
        /// <p>The data inputs identified by their node names.</p>
        pub fn set_inputs(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inputs = input;
            self
        }
        /// Appends an item to `source_path`.
        ///
        /// To override the contents of this collection use [`set_source_path`](Self::set_source_path).
        ///
        /// <p>A JSON path to a variable in the data structure for the source data.</p>
        pub fn source_path(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.source_path.unwrap_or_default();
            v.push(input.into());
            self.source_path = Some(v);
            self
        }
        /// <p>A JSON path to a variable in the data structure for the source data.</p>
        pub fn set_source_path(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.source_path = input;
            self
        }
        /// Appends an item to `target_path`.
        ///
        /// To override the contents of this collection use [`set_target_path`](Self::set_target_path).
        ///
        /// <p>A JSON path to a variable in the data structure for the target data.</p>
        pub fn target_path(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.target_path.unwrap_or_default();
            v.push(input.into());
            self.target_path = Some(v);
            self
        }
        /// <p>A JSON path to a variable in the data structure for the target data.</p>
        pub fn set_target_path(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.target_path = input;
            self
        }
        /// Consumes the builder and constructs a [`RenameField`](crate::model::RenameField).
        pub fn build(self) -> crate::model::RenameField {
            crate::model::RenameField {
                name: self.name,
                inputs: self.inputs,
                source_path: self.source_path,
                target_path: self.target_path,
            }
        }
    }
}
impl RenameField {
    /// Creates a new builder-style object to manufacture [`RenameField`](crate::model::RenameField).
    pub fn builder() -> crate::model::rename_field::Builder {
        crate::model::rename_field::Builder::default()
    }
}

/// <p>Specifies a transform that chooses the data property keys that you want to drop.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DropFields {
    /// <p>The name of the transform node.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The data inputs identified by their node names.</p>
    #[doc(hidden)]
    pub inputs: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A JSON path to a variable in the data structure.</p>
    #[doc(hidden)]
    pub paths: std::option::Option<std::vec::Vec<std::vec::Vec<std::string::String>>>,
}
impl DropFields {
    /// <p>The name of the transform node.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The data inputs identified by their node names.</p>
    pub fn inputs(&self) -> std::option::Option<&[std::string::String]> {
        self.inputs.as_deref()
    }
    /// <p>A JSON path to a variable in the data structure.</p>
    pub fn paths(&self) -> std::option::Option<&[std::vec::Vec<std::string::String>]> {
        self.paths.as_deref()
    }
}
/// See [`DropFields`](crate::model::DropFields).
pub mod drop_fields {

    /// A builder for [`DropFields`](crate::model::DropFields).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) inputs: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) paths: std::option::Option<std::vec::Vec<std::vec::Vec<std::string::String>>>,
    }
    impl Builder {
        /// <p>The name of the transform node.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the transform node.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Appends an item to `inputs`.
        ///
        /// To override the contents of this collection use [`set_inputs`](Self::set_inputs).
        ///
        /// <p>The data inputs identified by their node names.</p>
        pub fn inputs(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.inputs.unwrap_or_default();
            v.push(input.into());
            self.inputs = Some(v);
            self
        }
        /// <p>The data inputs identified by their node names.</p>
        pub fn set_inputs(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inputs = input;
            self
        }
        /// Appends an item to `paths`.
        ///
        /// To override the contents of this collection use [`set_paths`](Self::set_paths).
        ///
        /// <p>A JSON path to a variable in the data structure.</p>
        pub fn paths(mut self, input: std::vec::Vec<std::string::String>) -> Self {
            let mut v = self.paths.unwrap_or_default();
            v.push(input);
            self.paths = Some(v);
            self
        }
        /// <p>A JSON path to a variable in the data structure.</p>
        pub fn set_paths(
            mut self,
            input: std::option::Option<std::vec::Vec<std::vec::Vec<std::string::String>>>,
        ) -> Self {
            self.paths = input;
            self
        }
        /// Consumes the builder and constructs a [`DropFields`](crate::model::DropFields).
        pub fn build(self) -> crate::model::DropFields {
            crate::model::DropFields {
                name: self.name,
                inputs: self.inputs,
                paths: self.paths,
            }
        }
    }
}
impl DropFields {
    /// Creates a new builder-style object to manufacture [`DropFields`](crate::model::DropFields).
    pub fn builder() -> crate::model::drop_fields::Builder {
        crate::model::drop_fields::Builder::default()
    }
}

/// <p>Specifies a transform that chooses the data property keys that you want to keep.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SelectFields {
    /// <p>The name of the transform node.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The data inputs identified by their node names.</p>
    #[doc(hidden)]
    pub inputs: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A JSON path to a variable in the data structure.</p>
    #[doc(hidden)]
    pub paths: std::option::Option<std::vec::Vec<std::vec::Vec<std::string::String>>>,
}
impl SelectFields {
    /// <p>The name of the transform node.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The data inputs identified by their node names.</p>
    pub fn inputs(&self) -> std::option::Option<&[std::string::String]> {
        self.inputs.as_deref()
    }
    /// <p>A JSON path to a variable in the data structure.</p>
    pub fn paths(&self) -> std::option::Option<&[std::vec::Vec<std::string::String>]> {
        self.paths.as_deref()
    }
}
/// See [`SelectFields`](crate::model::SelectFields).
pub mod select_fields {

    /// A builder for [`SelectFields`](crate::model::SelectFields).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) inputs: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) paths: std::option::Option<std::vec::Vec<std::vec::Vec<std::string::String>>>,
    }
    impl Builder {
        /// <p>The name of the transform node.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the transform node.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Appends an item to `inputs`.
        ///
        /// To override the contents of this collection use [`set_inputs`](Self::set_inputs).
        ///
        /// <p>The data inputs identified by their node names.</p>
        pub fn inputs(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.inputs.unwrap_or_default();
            v.push(input.into());
            self.inputs = Some(v);
            self
        }
        /// <p>The data inputs identified by their node names.</p>
        pub fn set_inputs(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inputs = input;
            self
        }
        /// Appends an item to `paths`.
        ///
        /// To override the contents of this collection use [`set_paths`](Self::set_paths).
        ///
        /// <p>A JSON path to a variable in the data structure.</p>
        pub fn paths(mut self, input: std::vec::Vec<std::string::String>) -> Self {
            let mut v = self.paths.unwrap_or_default();
            v.push(input);
            self.paths = Some(v);
            self
        }
        /// <p>A JSON path to a variable in the data structure.</p>
        pub fn set_paths(
            mut self,
            input: std::option::Option<std::vec::Vec<std::vec::Vec<std::string::String>>>,
        ) -> Self {
            self.paths = input;
            self
        }
        /// Consumes the builder and constructs a [`SelectFields`](crate::model::SelectFields).
        pub fn build(self) -> crate::model::SelectFields {
            crate::model::SelectFields {
                name: self.name,
                inputs: self.inputs,
                paths: self.paths,
            }
        }
    }
}
impl SelectFields {
    /// Creates a new builder-style object to manufacture [`SelectFields`](crate::model::SelectFields).
    pub fn builder() -> crate::model::select_fields::Builder {
        crate::model::select_fields::Builder::default()
    }
}

/// <p>Specifies a transform that maps data property keys in the data source to data property keys in the data target. You can rename keys, modify the data types for keys, and choose which keys to drop from the dataset.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ApplyMapping {
    /// <p>The name of the transform node.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The data inputs identified by their node names.</p>
    #[doc(hidden)]
    pub inputs: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Specifies the mapping of data property keys in the data source to data property keys in the data target.</p>
    #[doc(hidden)]
    pub mapping: std::option::Option<std::vec::Vec<crate::model::Mapping>>,
}
impl ApplyMapping {
    /// <p>The name of the transform node.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The data inputs identified by their node names.</p>
    pub fn inputs(&self) -> std::option::Option<&[std::string::String]> {
        self.inputs.as_deref()
    }
    /// <p>Specifies the mapping of data property keys in the data source to data property keys in the data target.</p>
    pub fn mapping(&self) -> std::option::Option<&[crate::model::Mapping]> {
        self.mapping.as_deref()
    }
}
/// See [`ApplyMapping`](crate::model::ApplyMapping).
pub mod apply_mapping {

    /// A builder for [`ApplyMapping`](crate::model::ApplyMapping).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) inputs: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) mapping: std::option::Option<std::vec::Vec<crate::model::Mapping>>,
    }
    impl Builder {
        /// <p>The name of the transform node.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the transform node.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Appends an item to `inputs`.
        ///
        /// To override the contents of this collection use [`set_inputs`](Self::set_inputs).
        ///
        /// <p>The data inputs identified by their node names.</p>
        pub fn inputs(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.inputs.unwrap_or_default();
            v.push(input.into());
            self.inputs = Some(v);
            self
        }
        /// <p>The data inputs identified by their node names.</p>
        pub fn set_inputs(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inputs = input;
            self
        }
        /// Appends an item to `mapping`.
        ///
        /// To override the contents of this collection use [`set_mapping`](Self::set_mapping).
        ///
        /// <p>Specifies the mapping of data property keys in the data source to data property keys in the data target.</p>
        pub fn mapping(mut self, input: crate::model::Mapping) -> Self {
            let mut v = self.mapping.unwrap_or_default();
            v.push(input);
            self.mapping = Some(v);
            self
        }
        /// <p>Specifies the mapping of data property keys in the data source to data property keys in the data target.</p>
        pub fn set_mapping(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Mapping>>,
        ) -> Self {
            self.mapping = input;
            self
        }
        /// Consumes the builder and constructs a [`ApplyMapping`](crate::model::ApplyMapping).
        pub fn build(self) -> crate::model::ApplyMapping {
            crate::model::ApplyMapping {
                name: self.name,
                inputs: self.inputs,
                mapping: self.mapping,
            }
        }
    }
}
impl ApplyMapping {
    /// Creates a new builder-style object to manufacture [`ApplyMapping`](crate::model::ApplyMapping).
    pub fn builder() -> crate::model::apply_mapping::Builder {
        crate::model::apply_mapping::Builder::default()
    }
}

/// <p>Specifies the mapping of data property keys.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Mapping {
    /// <p>After the apply mapping, what the name of the column should be. Can be the same as <code>FromPath</code>.</p>
    #[doc(hidden)]
    pub to_key: std::option::Option<std::string::String>,
    /// <p>The table or column to be modified.</p>
    #[doc(hidden)]
    pub from_path: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The type of the data to be modified.</p>
    #[doc(hidden)]
    pub from_type: std::option::Option<std::string::String>,
    /// <p>The data type that the data is to be modified to.</p>
    #[doc(hidden)]
    pub to_type: std::option::Option<std::string::String>,
    /// <p>If true, then the column is removed.</p>
    #[doc(hidden)]
    pub dropped: std::option::Option<bool>,
    /// <p>Only applicable to nested data structures. If you want to change the parent structure, but also one of its children, you can fill out this data strucutre. It is also <code>Mapping</code>, but its <code>FromPath</code> will be the parent's <code>FromPath</code> plus the <code>FromPath</code> from this structure.</p>
    /// <p>For the children part, suppose you have the structure:</p>
    /// <p> <code>{ "FromPath": "OuterStructure", "ToKey": "OuterStructure", "ToType": "Struct", "Dropped": false, "Chidlren": [{ "FromPath": "inner", "ToKey": "inner", "ToType": "Double", "Dropped": false, }] }</code> </p>
    /// <p>You can specify a <code>Mapping</code> that looks like:</p>
    /// <p> <code>{ "FromPath": "OuterStructure", "ToKey": "OuterStructure", "ToType": "Struct", "Dropped": false, "Chidlren": [{ "FromPath": "inner", "ToKey": "inner", "ToType": "Double", "Dropped": false, }] }</code> </p>
    #[doc(hidden)]
    pub children: std::option::Option<std::vec::Vec<crate::model::Mapping>>,
}
impl Mapping {
    /// <p>After the apply mapping, what the name of the column should be. Can be the same as <code>FromPath</code>.</p>
    pub fn to_key(&self) -> std::option::Option<&str> {
        self.to_key.as_deref()
    }
    /// <p>The table or column to be modified.</p>
    pub fn from_path(&self) -> std::option::Option<&[std::string::String]> {
        self.from_path.as_deref()
    }
    /// <p>The type of the data to be modified.</p>
    pub fn from_type(&self) -> std::option::Option<&str> {
        self.from_type.as_deref()
    }
    /// <p>The data type that the data is to be modified to.</p>
    pub fn to_type(&self) -> std::option::Option<&str> {
        self.to_type.as_deref()
    }
    /// <p>If true, then the column is removed.</p>
    pub fn dropped(&self) -> std::option::Option<bool> {
        self.dropped
    }
    /// <p>Only applicable to nested data structures. If you want to change the parent structure, but also one of its children, you can fill out this data strucutre. It is also <code>Mapping</code>, but its <code>FromPath</code> will be the parent's <code>FromPath</code> plus the <code>FromPath</code> from this structure.</p>
    /// <p>For the children part, suppose you have the structure:</p>
    /// <p> <code>{ "FromPath": "OuterStructure", "ToKey": "OuterStructure", "ToType": "Struct", "Dropped": false, "Chidlren": [{ "FromPath": "inner", "ToKey": "inner", "ToType": "Double", "Dropped": false, }] }</code> </p>
    /// <p>You can specify a <code>Mapping</code> that looks like:</p>
    /// <p> <code>{ "FromPath": "OuterStructure", "ToKey": "OuterStructure", "ToType": "Struct", "Dropped": false, "Chidlren": [{ "FromPath": "inner", "ToKey": "inner", "ToType": "Double", "Dropped": false, }] }</code> </p>
    pub fn children(&self) -> std::option::Option<&[crate::model::Mapping]> {
        self.children.as_deref()
    }
}
/// See [`Mapping`](crate::model::Mapping).
pub mod mapping {

    /// A builder for [`Mapping`](crate::model::Mapping).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) to_key: std::option::Option<std::string::String>,
        pub(crate) from_path: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) from_type: std::option::Option<std::string::String>,
        pub(crate) to_type: std::option::Option<std::string::String>,
        pub(crate) dropped: std::option::Option<bool>,
        pub(crate) children: std::option::Option<std::vec::Vec<crate::model::Mapping>>,
    }
    impl Builder {
        /// <p>After the apply mapping, what the name of the column should be. Can be the same as <code>FromPath</code>.</p>
        pub fn to_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.to_key = Some(input.into());
            self
        }
        /// <p>After the apply mapping, what the name of the column should be. Can be the same as <code>FromPath</code>.</p>
        pub fn set_to_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.to_key = input;
            self
        }
        /// Appends an item to `from_path`.
        ///
        /// To override the contents of this collection use [`set_from_path`](Self::set_from_path).
        ///
        /// <p>The table or column to be modified.</p>
        pub fn from_path(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.from_path.unwrap_or_default();
            v.push(input.into());
            self.from_path = Some(v);
            self
        }
        /// <p>The table or column to be modified.</p>
        pub fn set_from_path(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.from_path = input;
            self
        }
        /// <p>The type of the data to be modified.</p>
        pub fn from_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.from_type = Some(input.into());
            self
        }
        /// <p>The type of the data to be modified.</p>
        pub fn set_from_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.from_type = input;
            self
        }
        /// <p>The data type that the data is to be modified to.</p>
        pub fn to_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.to_type = Some(input.into());
            self
        }
        /// <p>The data type that the data is to be modified to.</p>
        pub fn set_to_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.to_type = input;
            self
        }
        /// <p>If true, then the column is removed.</p>
        pub fn dropped(mut self, input: bool) -> Self {
            self.dropped = Some(input);
            self
        }
        /// <p>If true, then the column is removed.</p>
        pub fn set_dropped(mut self, input: std::option::Option<bool>) -> Self {
            self.dropped = input;
            self
        }
        /// Appends an item to `children`.
        ///
        /// To override the contents of this collection use [`set_children`](Self::set_children).
        ///
        /// <p>Only applicable to nested data structures. If you want to change the parent structure, but also one of its children, you can fill out this data strucutre. It is also <code>Mapping</code>, but its <code>FromPath</code> will be the parent's <code>FromPath</code> plus the <code>FromPath</code> from this structure.</p>
        /// <p>For the children part, suppose you have the structure:</p>
        /// <p> <code>{ "FromPath": "OuterStructure", "ToKey": "OuterStructure", "ToType": "Struct", "Dropped": false, "Chidlren": [{ "FromPath": "inner", "ToKey": "inner", "ToType": "Double", "Dropped": false, }] }</code> </p>
        /// <p>You can specify a <code>Mapping</code> that looks like:</p>
        /// <p> <code>{ "FromPath": "OuterStructure", "ToKey": "OuterStructure", "ToType": "Struct", "Dropped": false, "Chidlren": [{ "FromPath": "inner", "ToKey": "inner", "ToType": "Double", "Dropped": false, }] }</code> </p>
        pub fn children(mut self, input: crate::model::Mapping) -> Self {
            let mut v = self.children.unwrap_or_default();
            v.push(input);
            self.children = Some(v);
            self
        }
        /// <p>Only applicable to nested data structures. If you want to change the parent structure, but also one of its children, you can fill out this data strucutre. It is also <code>Mapping</code>, but its <code>FromPath</code> will be the parent's <code>FromPath</code> plus the <code>FromPath</code> from this structure.</p>
        /// <p>For the children part, suppose you have the structure:</p>
        /// <p> <code>{ "FromPath": "OuterStructure", "ToKey": "OuterStructure", "ToType": "Struct", "Dropped": false, "Chidlren": [{ "FromPath": "inner", "ToKey": "inner", "ToType": "Double", "Dropped": false, }] }</code> </p>
        /// <p>You can specify a <code>Mapping</code> that looks like:</p>
        /// <p> <code>{ "FromPath": "OuterStructure", "ToKey": "OuterStructure", "ToType": "Struct", "Dropped": false, "Chidlren": [{ "FromPath": "inner", "ToKey": "inner", "ToType": "Double", "Dropped": false, }] }</code> </p>
        pub fn set_children(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Mapping>>,
        ) -> Self {
            self.children = input;
            self
        }
        /// Consumes the builder and constructs a [`Mapping`](crate::model::Mapping).
        pub fn build(self) -> crate::model::Mapping {
            crate::model::Mapping {
                to_key: self.to_key,
                from_path: self.from_path,
                from_type: self.from_type,
                to_type: self.to_type,
                dropped: self.dropped,
                children: self.children,
            }
        }
    }
}
impl Mapping {
    /// Creates a new builder-style object to manufacture [`Mapping`](crate::model::Mapping).
    pub fn builder() -> crate::model::mapping::Builder {
        crate::model::mapping::Builder::default()
    }
}

/// <p>Specifies a data target that writes to Amazon S3.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct S3DirectTarget {
    /// <p>The name of the data target.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The nodes that are inputs to the data target.</p>
    #[doc(hidden)]
    pub inputs: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Specifies native partitioning using a sequence of keys.</p>
    #[doc(hidden)]
    pub partition_keys: std::option::Option<std::vec::Vec<std::vec::Vec<std::string::String>>>,
    /// <p>A single Amazon S3 path to write to.</p>
    #[doc(hidden)]
    pub path: std::option::Option<std::string::String>,
    /// <p>Specifies how the data is compressed. This is generally not necessary if the data has a standard file extension. Possible values are <code>"gzip"</code> and <code>"bzip"</code>).</p>
    #[doc(hidden)]
    pub compression: std::option::Option<std::string::String>,
    /// <p>Specifies the data output format for the target.</p>
    #[doc(hidden)]
    pub format: std::option::Option<crate::model::TargetFormat>,
    /// <p>A policy that specifies update behavior for the crawler.</p>
    #[doc(hidden)]
    pub schema_change_policy: std::option::Option<crate::model::DirectSchemaChangePolicy>,
}
impl S3DirectTarget {
    /// <p>The name of the data target.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The nodes that are inputs to the data target.</p>
    pub fn inputs(&self) -> std::option::Option<&[std::string::String]> {
        self.inputs.as_deref()
    }
    /// <p>Specifies native partitioning using a sequence of keys.</p>
    pub fn partition_keys(&self) -> std::option::Option<&[std::vec::Vec<std::string::String>]> {
        self.partition_keys.as_deref()
    }
    /// <p>A single Amazon S3 path to write to.</p>
    pub fn path(&self) -> std::option::Option<&str> {
        self.path.as_deref()
    }
    /// <p>Specifies how the data is compressed. This is generally not necessary if the data has a standard file extension. Possible values are <code>"gzip"</code> and <code>"bzip"</code>).</p>
    pub fn compression(&self) -> std::option::Option<&str> {
        self.compression.as_deref()
    }
    /// <p>Specifies the data output format for the target.</p>
    pub fn format(&self) -> std::option::Option<&crate::model::TargetFormat> {
        self.format.as_ref()
    }
    /// <p>A policy that specifies update behavior for the crawler.</p>
    pub fn schema_change_policy(
        &self,
    ) -> std::option::Option<&crate::model::DirectSchemaChangePolicy> {
        self.schema_change_policy.as_ref()
    }
}
/// See [`S3DirectTarget`](crate::model::S3DirectTarget).
pub mod s3_direct_target {

    /// A builder for [`S3DirectTarget`](crate::model::S3DirectTarget).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) inputs: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) partition_keys:
            std::option::Option<std::vec::Vec<std::vec::Vec<std::string::String>>>,
        pub(crate) path: std::option::Option<std::string::String>,
        pub(crate) compression: std::option::Option<std::string::String>,
        pub(crate) format: std::option::Option<crate::model::TargetFormat>,
        pub(crate) schema_change_policy:
            std::option::Option<crate::model::DirectSchemaChangePolicy>,
    }
    impl Builder {
        /// <p>The name of the data target.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the data target.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Appends an item to `inputs`.
        ///
        /// To override the contents of this collection use [`set_inputs`](Self::set_inputs).
        ///
        /// <p>The nodes that are inputs to the data target.</p>
        pub fn inputs(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.inputs.unwrap_or_default();
            v.push(input.into());
            self.inputs = Some(v);
            self
        }
        /// <p>The nodes that are inputs to the data target.</p>
        pub fn set_inputs(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inputs = input;
            self
        }
        /// Appends an item to `partition_keys`.
        ///
        /// To override the contents of this collection use [`set_partition_keys`](Self::set_partition_keys).
        ///
        /// <p>Specifies native partitioning using a sequence of keys.</p>
        pub fn partition_keys(mut self, input: std::vec::Vec<std::string::String>) -> Self {
            let mut v = self.partition_keys.unwrap_or_default();
            v.push(input);
            self.partition_keys = Some(v);
            self
        }
        /// <p>Specifies native partitioning using a sequence of keys.</p>
        pub fn set_partition_keys(
            mut self,
            input: std::option::Option<std::vec::Vec<std::vec::Vec<std::string::String>>>,
        ) -> Self {
            self.partition_keys = input;
            self
        }
        /// <p>A single Amazon S3 path to write to.</p>
        pub fn path(mut self, input: impl Into<std::string::String>) -> Self {
            self.path = Some(input.into());
            self
        }
        /// <p>A single Amazon S3 path to write to.</p>
        pub fn set_path(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.path = input;
            self
        }
        /// <p>Specifies how the data is compressed. This is generally not necessary if the data has a standard file extension. Possible values are <code>"gzip"</code> and <code>"bzip"</code>).</p>
        pub fn compression(mut self, input: impl Into<std::string::String>) -> Self {
            self.compression = Some(input.into());
            self
        }
        /// <p>Specifies how the data is compressed. This is generally not necessary if the data has a standard file extension. Possible values are <code>"gzip"</code> and <code>"bzip"</code>).</p>
        pub fn set_compression(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.compression = input;
            self
        }
        /// <p>Specifies the data output format for the target.</p>
        pub fn format(mut self, input: crate::model::TargetFormat) -> Self {
            self.format = Some(input);
            self
        }
        /// <p>Specifies the data output format for the target.</p>
        pub fn set_format(
            mut self,
            input: std::option::Option<crate::model::TargetFormat>,
        ) -> Self {
            self.format = input;
            self
        }
        /// <p>A policy that specifies update behavior for the crawler.</p>
        pub fn schema_change_policy(
            mut self,
            input: crate::model::DirectSchemaChangePolicy,
        ) -> Self {
            self.schema_change_policy = Some(input);
            self
        }
        /// <p>A policy that specifies update behavior for the crawler.</p>
        pub fn set_schema_change_policy(
            mut self,
            input: std::option::Option<crate::model::DirectSchemaChangePolicy>,
        ) -> Self {
            self.schema_change_policy = input;
            self
        }
        /// Consumes the builder and constructs a [`S3DirectTarget`](crate::model::S3DirectTarget).
        pub fn build(self) -> crate::model::S3DirectTarget {
            crate::model::S3DirectTarget {
                name: self.name,
                inputs: self.inputs,
                partition_keys: self.partition_keys,
                path: self.path,
                compression: self.compression,
                format: self.format,
                schema_change_policy: self.schema_change_policy,
            }
        }
    }
}
impl S3DirectTarget {
    /// Creates a new builder-style object to manufacture [`S3DirectTarget`](crate::model::S3DirectTarget).
    pub fn builder() -> crate::model::s3_direct_target::Builder {
        crate::model::s3_direct_target::Builder::default()
    }
}

/// <p>Specifies a data target that writes to Amazon S3 in Apache Parquet columnar storage.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct S3GlueParquetTarget {
    /// <p>The name of the data target.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The nodes that are inputs to the data target.</p>
    #[doc(hidden)]
    pub inputs: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Specifies native partitioning using a sequence of keys.</p>
    #[doc(hidden)]
    pub partition_keys: std::option::Option<std::vec::Vec<std::vec::Vec<std::string::String>>>,
    /// <p>A single Amazon S3 path to write to.</p>
    #[doc(hidden)]
    pub path: std::option::Option<std::string::String>,
    /// <p>Specifies how the data is compressed. This is generally not necessary if the data has a standard file extension. Possible values are <code>"gzip"</code> and <code>"bzip"</code>).</p>
    #[doc(hidden)]
    pub compression: std::option::Option<crate::model::ParquetCompressionType>,
    /// <p>A policy that specifies update behavior for the crawler.</p>
    #[doc(hidden)]
    pub schema_change_policy: std::option::Option<crate::model::DirectSchemaChangePolicy>,
}
impl S3GlueParquetTarget {
    /// <p>The name of the data target.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The nodes that are inputs to the data target.</p>
    pub fn inputs(&self) -> std::option::Option<&[std::string::String]> {
        self.inputs.as_deref()
    }
    /// <p>Specifies native partitioning using a sequence of keys.</p>
    pub fn partition_keys(&self) -> std::option::Option<&[std::vec::Vec<std::string::String>]> {
        self.partition_keys.as_deref()
    }
    /// <p>A single Amazon S3 path to write to.</p>
    pub fn path(&self) -> std::option::Option<&str> {
        self.path.as_deref()
    }
    /// <p>Specifies how the data is compressed. This is generally not necessary if the data has a standard file extension. Possible values are <code>"gzip"</code> and <code>"bzip"</code>).</p>
    pub fn compression(&self) -> std::option::Option<&crate::model::ParquetCompressionType> {
        self.compression.as_ref()
    }
    /// <p>A policy that specifies update behavior for the crawler.</p>
    pub fn schema_change_policy(
        &self,
    ) -> std::option::Option<&crate::model::DirectSchemaChangePolicy> {
        self.schema_change_policy.as_ref()
    }
}
/// See [`S3GlueParquetTarget`](crate::model::S3GlueParquetTarget).
pub mod s3_glue_parquet_target {

    /// A builder for [`S3GlueParquetTarget`](crate::model::S3GlueParquetTarget).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) inputs: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) partition_keys:
            std::option::Option<std::vec::Vec<std::vec::Vec<std::string::String>>>,
        pub(crate) path: std::option::Option<std::string::String>,
        pub(crate) compression: std::option::Option<crate::model::ParquetCompressionType>,
        pub(crate) schema_change_policy:
            std::option::Option<crate::model::DirectSchemaChangePolicy>,
    }
    impl Builder {
        /// <p>The name of the data target.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the data target.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Appends an item to `inputs`.
        ///
        /// To override the contents of this collection use [`set_inputs`](Self::set_inputs).
        ///
        /// <p>The nodes that are inputs to the data target.</p>
        pub fn inputs(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.inputs.unwrap_or_default();
            v.push(input.into());
            self.inputs = Some(v);
            self
        }
        /// <p>The nodes that are inputs to the data target.</p>
        pub fn set_inputs(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inputs = input;
            self
        }
        /// Appends an item to `partition_keys`.
        ///
        /// To override the contents of this collection use [`set_partition_keys`](Self::set_partition_keys).
        ///
        /// <p>Specifies native partitioning using a sequence of keys.</p>
        pub fn partition_keys(mut self, input: std::vec::Vec<std::string::String>) -> Self {
            let mut v = self.partition_keys.unwrap_or_default();
            v.push(input);
            self.partition_keys = Some(v);
            self
        }
        /// <p>Specifies native partitioning using a sequence of keys.</p>
        pub fn set_partition_keys(
            mut self,
            input: std::option::Option<std::vec::Vec<std::vec::Vec<std::string::String>>>,
        ) -> Self {
            self.partition_keys = input;
            self
        }
        /// <p>A single Amazon S3 path to write to.</p>
        pub fn path(mut self, input: impl Into<std::string::String>) -> Self {
            self.path = Some(input.into());
            self
        }
        /// <p>A single Amazon S3 path to write to.</p>
        pub fn set_path(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.path = input;
            self
        }
        /// <p>Specifies how the data is compressed. This is generally not necessary if the data has a standard file extension. Possible values are <code>"gzip"</code> and <code>"bzip"</code>).</p>
        pub fn compression(mut self, input: crate::model::ParquetCompressionType) -> Self {
            self.compression = Some(input);
            self
        }
        /// <p>Specifies how the data is compressed. This is generally not necessary if the data has a standard file extension. Possible values are <code>"gzip"</code> and <code>"bzip"</code>).</p>
        pub fn set_compression(
            mut self,
            input: std::option::Option<crate::model::ParquetCompressionType>,
        ) -> Self {
            self.compression = input;
            self
        }
        /// <p>A policy that specifies update behavior for the crawler.</p>
        pub fn schema_change_policy(
            mut self,
            input: crate::model::DirectSchemaChangePolicy,
        ) -> Self {
            self.schema_change_policy = Some(input);
            self
        }
        /// <p>A policy that specifies update behavior for the crawler.</p>
        pub fn set_schema_change_policy(
            mut self,
            input: std::option::Option<crate::model::DirectSchemaChangePolicy>,
        ) -> Self {
            self.schema_change_policy = input;
            self
        }
        /// Consumes the builder and constructs a [`S3GlueParquetTarget`](crate::model::S3GlueParquetTarget).
        pub fn build(self) -> crate::model::S3GlueParquetTarget {
            crate::model::S3GlueParquetTarget {
                name: self.name,
                inputs: self.inputs,
                partition_keys: self.partition_keys,
                path: self.path,
                compression: self.compression,
                schema_change_policy: self.schema_change_policy,
            }
        }
    }
}
impl S3GlueParquetTarget {
    /// Creates a new builder-style object to manufacture [`S3GlueParquetTarget`](crate::model::S3GlueParquetTarget).
    pub fn builder() -> crate::model::s3_glue_parquet_target::Builder {
        crate::model::s3_glue_parquet_target::Builder::default()
    }
}

/// When writing a match expression against `ParquetCompressionType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let parquetcompressiontype = unimplemented!();
/// match parquetcompressiontype {
///     ParquetCompressionType::Gzip => { /* ... */ },
///     ParquetCompressionType::Lzo => { /* ... */ },
///     ParquetCompressionType::None => { /* ... */ },
///     ParquetCompressionType::Snappy => { /* ... */ },
///     ParquetCompressionType::Uncompressed => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `parquetcompressiontype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ParquetCompressionType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ParquetCompressionType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ParquetCompressionType::NewFeature` is defined.
/// Specifically, when `parquetcompressiontype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ParquetCompressionType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ParquetCompressionType {
    #[allow(missing_docs)] // documentation missing in model
    Gzip,
    #[allow(missing_docs)] // documentation missing in model
    Lzo,
    #[allow(missing_docs)] // documentation missing in model
    None,
    #[allow(missing_docs)] // documentation missing in model
    Snappy,
    #[allow(missing_docs)] // documentation missing in model
    Uncompressed,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ParquetCompressionType {
    fn from(s: &str) -> Self {
        match s {
            "gzip" => ParquetCompressionType::Gzip,
            "lzo" => ParquetCompressionType::Lzo,
            "none" => ParquetCompressionType::None,
            "snappy" => ParquetCompressionType::Snappy,
            "uncompressed" => ParquetCompressionType::Uncompressed,
            other => {
                ParquetCompressionType::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for ParquetCompressionType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ParquetCompressionType::from(s))
    }
}
impl ParquetCompressionType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ParquetCompressionType::Gzip => "gzip",
            ParquetCompressionType::Lzo => "lzo",
            ParquetCompressionType::None => "none",
            ParquetCompressionType::Snappy => "snappy",
            ParquetCompressionType::Uncompressed => "uncompressed",
            ParquetCompressionType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["gzip", "lzo", "none", "snappy", "uncompressed"]
    }
}
impl AsRef<str> for ParquetCompressionType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Specifies a data target that writes to Amazon S3 using the Glue Data Catalog.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct S3CatalogTarget {
    /// <p>The name of the data target.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The nodes that are inputs to the data target.</p>
    #[doc(hidden)]
    pub inputs: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Specifies native partitioning using a sequence of keys.</p>
    #[doc(hidden)]
    pub partition_keys: std::option::Option<std::vec::Vec<std::vec::Vec<std::string::String>>>,
    /// <p>The name of the table in the database to write to.</p>
    #[doc(hidden)]
    pub table: std::option::Option<std::string::String>,
    /// <p>The name of the database to write to.</p>
    #[doc(hidden)]
    pub database: std::option::Option<std::string::String>,
    /// <p>A policy that specifies update behavior for the crawler.</p>
    #[doc(hidden)]
    pub schema_change_policy: std::option::Option<crate::model::CatalogSchemaChangePolicy>,
}
impl S3CatalogTarget {
    /// <p>The name of the data target.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The nodes that are inputs to the data target.</p>
    pub fn inputs(&self) -> std::option::Option<&[std::string::String]> {
        self.inputs.as_deref()
    }
    /// <p>Specifies native partitioning using a sequence of keys.</p>
    pub fn partition_keys(&self) -> std::option::Option<&[std::vec::Vec<std::string::String>]> {
        self.partition_keys.as_deref()
    }
    /// <p>The name of the table in the database to write to.</p>
    pub fn table(&self) -> std::option::Option<&str> {
        self.table.as_deref()
    }
    /// <p>The name of the database to write to.</p>
    pub fn database(&self) -> std::option::Option<&str> {
        self.database.as_deref()
    }
    /// <p>A policy that specifies update behavior for the crawler.</p>
    pub fn schema_change_policy(
        &self,
    ) -> std::option::Option<&crate::model::CatalogSchemaChangePolicy> {
        self.schema_change_policy.as_ref()
    }
}
/// See [`S3CatalogTarget`](crate::model::S3CatalogTarget).
pub mod s3_catalog_target {

    /// A builder for [`S3CatalogTarget`](crate::model::S3CatalogTarget).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) inputs: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) partition_keys:
            std::option::Option<std::vec::Vec<std::vec::Vec<std::string::String>>>,
        pub(crate) table: std::option::Option<std::string::String>,
        pub(crate) database: std::option::Option<std::string::String>,
        pub(crate) schema_change_policy:
            std::option::Option<crate::model::CatalogSchemaChangePolicy>,
    }
    impl Builder {
        /// <p>The name of the data target.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the data target.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Appends an item to `inputs`.
        ///
        /// To override the contents of this collection use [`set_inputs`](Self::set_inputs).
        ///
        /// <p>The nodes that are inputs to the data target.</p>
        pub fn inputs(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.inputs.unwrap_or_default();
            v.push(input.into());
            self.inputs = Some(v);
            self
        }
        /// <p>The nodes that are inputs to the data target.</p>
        pub fn set_inputs(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inputs = input;
            self
        }
        /// Appends an item to `partition_keys`.
        ///
        /// To override the contents of this collection use [`set_partition_keys`](Self::set_partition_keys).
        ///
        /// <p>Specifies native partitioning using a sequence of keys.</p>
        pub fn partition_keys(mut self, input: std::vec::Vec<std::string::String>) -> Self {
            let mut v = self.partition_keys.unwrap_or_default();
            v.push(input);
            self.partition_keys = Some(v);
            self
        }
        /// <p>Specifies native partitioning using a sequence of keys.</p>
        pub fn set_partition_keys(
            mut self,
            input: std::option::Option<std::vec::Vec<std::vec::Vec<std::string::String>>>,
        ) -> Self {
            self.partition_keys = input;
            self
        }
        /// <p>The name of the table in the database to write to.</p>
        pub fn table(mut self, input: impl Into<std::string::String>) -> Self {
            self.table = Some(input.into());
            self
        }
        /// <p>The name of the table in the database to write to.</p>
        pub fn set_table(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.table = input;
            self
        }
        /// <p>The name of the database to write to.</p>
        pub fn database(mut self, input: impl Into<std::string::String>) -> Self {
            self.database = Some(input.into());
            self
        }
        /// <p>The name of the database to write to.</p>
        pub fn set_database(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.database = input;
            self
        }
        /// <p>A policy that specifies update behavior for the crawler.</p>
        pub fn schema_change_policy(
            mut self,
            input: crate::model::CatalogSchemaChangePolicy,
        ) -> Self {
            self.schema_change_policy = Some(input);
            self
        }
        /// <p>A policy that specifies update behavior for the crawler.</p>
        pub fn set_schema_change_policy(
            mut self,
            input: std::option::Option<crate::model::CatalogSchemaChangePolicy>,
        ) -> Self {
            self.schema_change_policy = input;
            self
        }
        /// Consumes the builder and constructs a [`S3CatalogTarget`](crate::model::S3CatalogTarget).
        pub fn build(self) -> crate::model::S3CatalogTarget {
            crate::model::S3CatalogTarget {
                name: self.name,
                inputs: self.inputs,
                partition_keys: self.partition_keys,
                table: self.table,
                database: self.database,
                schema_change_policy: self.schema_change_policy,
            }
        }
    }
}
impl S3CatalogTarget {
    /// Creates a new builder-style object to manufacture [`S3CatalogTarget`](crate::model::S3CatalogTarget).
    pub fn builder() -> crate::model::s3_catalog_target::Builder {
        crate::model::s3_catalog_target::Builder::default()
    }
}

/// <p>Specifies a target that uses Amazon Redshift.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RedshiftTarget {
    /// <p>The name of the data target.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The nodes that are inputs to the data target.</p>
    #[doc(hidden)]
    pub inputs: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The name of the database to write to.</p>
    #[doc(hidden)]
    pub database: std::option::Option<std::string::String>,
    /// <p>The name of the table in the database to write to.</p>
    #[doc(hidden)]
    pub table: std::option::Option<std::string::String>,
    /// <p>The Amazon S3 path where temporary data can be staged when copying out of the database.</p>
    #[doc(hidden)]
    pub redshift_tmp_dir: std::option::Option<std::string::String>,
    /// <p>The IAM role with permissions.</p>
    #[doc(hidden)]
    pub tmp_dir_iam_role: std::option::Option<std::string::String>,
    /// <p>The set of options to configure an upsert operation when writing to a Redshift target.</p>
    #[doc(hidden)]
    pub upsert_redshift_options: std::option::Option<crate::model::UpsertRedshiftTargetOptions>,
}
impl RedshiftTarget {
    /// <p>The name of the data target.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The nodes that are inputs to the data target.</p>
    pub fn inputs(&self) -> std::option::Option<&[std::string::String]> {
        self.inputs.as_deref()
    }
    /// <p>The name of the database to write to.</p>
    pub fn database(&self) -> std::option::Option<&str> {
        self.database.as_deref()
    }
    /// <p>The name of the table in the database to write to.</p>
    pub fn table(&self) -> std::option::Option<&str> {
        self.table.as_deref()
    }
    /// <p>The Amazon S3 path where temporary data can be staged when copying out of the database.</p>
    pub fn redshift_tmp_dir(&self) -> std::option::Option<&str> {
        self.redshift_tmp_dir.as_deref()
    }
    /// <p>The IAM role with permissions.</p>
    pub fn tmp_dir_iam_role(&self) -> std::option::Option<&str> {
        self.tmp_dir_iam_role.as_deref()
    }
    /// <p>The set of options to configure an upsert operation when writing to a Redshift target.</p>
    pub fn upsert_redshift_options(
        &self,
    ) -> std::option::Option<&crate::model::UpsertRedshiftTargetOptions> {
        self.upsert_redshift_options.as_ref()
    }
}
/// See [`RedshiftTarget`](crate::model::RedshiftTarget).
pub mod redshift_target {

    /// A builder for [`RedshiftTarget`](crate::model::RedshiftTarget).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) inputs: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) database: std::option::Option<std::string::String>,
        pub(crate) table: std::option::Option<std::string::String>,
        pub(crate) redshift_tmp_dir: std::option::Option<std::string::String>,
        pub(crate) tmp_dir_iam_role: std::option::Option<std::string::String>,
        pub(crate) upsert_redshift_options:
            std::option::Option<crate::model::UpsertRedshiftTargetOptions>,
    }
    impl Builder {
        /// <p>The name of the data target.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the data target.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Appends an item to `inputs`.
        ///
        /// To override the contents of this collection use [`set_inputs`](Self::set_inputs).
        ///
        /// <p>The nodes that are inputs to the data target.</p>
        pub fn inputs(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.inputs.unwrap_or_default();
            v.push(input.into());
            self.inputs = Some(v);
            self
        }
        /// <p>The nodes that are inputs to the data target.</p>
        pub fn set_inputs(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inputs = input;
            self
        }
        /// <p>The name of the database to write to.</p>
        pub fn database(mut self, input: impl Into<std::string::String>) -> Self {
            self.database = Some(input.into());
            self
        }
        /// <p>The name of the database to write to.</p>
        pub fn set_database(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.database = input;
            self
        }
        /// <p>The name of the table in the database to write to.</p>
        pub fn table(mut self, input: impl Into<std::string::String>) -> Self {
            self.table = Some(input.into());
            self
        }
        /// <p>The name of the table in the database to write to.</p>
        pub fn set_table(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.table = input;
            self
        }
        /// <p>The Amazon S3 path where temporary data can be staged when copying out of the database.</p>
        pub fn redshift_tmp_dir(mut self, input: impl Into<std::string::String>) -> Self {
            self.redshift_tmp_dir = Some(input.into());
            self
        }
        /// <p>The Amazon S3 path where temporary data can be staged when copying out of the database.</p>
        pub fn set_redshift_tmp_dir(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.redshift_tmp_dir = input;
            self
        }
        /// <p>The IAM role with permissions.</p>
        pub fn tmp_dir_iam_role(mut self, input: impl Into<std::string::String>) -> Self {
            self.tmp_dir_iam_role = Some(input.into());
            self
        }
        /// <p>The IAM role with permissions.</p>
        pub fn set_tmp_dir_iam_role(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.tmp_dir_iam_role = input;
            self
        }
        /// <p>The set of options to configure an upsert operation when writing to a Redshift target.</p>
        pub fn upsert_redshift_options(
            mut self,
            input: crate::model::UpsertRedshiftTargetOptions,
        ) -> Self {
            self.upsert_redshift_options = Some(input);
            self
        }
        /// <p>The set of options to configure an upsert operation when writing to a Redshift target.</p>
        pub fn set_upsert_redshift_options(
            mut self,
            input: std::option::Option<crate::model::UpsertRedshiftTargetOptions>,
        ) -> Self {
            self.upsert_redshift_options = input;
            self
        }
        /// Consumes the builder and constructs a [`RedshiftTarget`](crate::model::RedshiftTarget).
        pub fn build(self) -> crate::model::RedshiftTarget {
            crate::model::RedshiftTarget {
                name: self.name,
                inputs: self.inputs,
                database: self.database,
                table: self.table,
                redshift_tmp_dir: self.redshift_tmp_dir,
                tmp_dir_iam_role: self.tmp_dir_iam_role,
                upsert_redshift_options: self.upsert_redshift_options,
            }
        }
    }
}
impl RedshiftTarget {
    /// Creates a new builder-style object to manufacture [`RedshiftTarget`](crate::model::RedshiftTarget).
    pub fn builder() -> crate::model::redshift_target::Builder {
        crate::model::redshift_target::Builder::default()
    }
}

/// <p>The options to configure an upsert operation when writing to a Redshift target .</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpsertRedshiftTargetOptions {
    /// <p>The physical location of the Redshift table.</p>
    #[doc(hidden)]
    pub table_location: std::option::Option<std::string::String>,
    /// <p>The name of the connection to use to write to Redshift.</p>
    #[doc(hidden)]
    pub connection_name: std::option::Option<std::string::String>,
    /// <p>The keys used to determine whether to perform an update or insert.</p>
    #[doc(hidden)]
    pub upsert_keys: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl UpsertRedshiftTargetOptions {
    /// <p>The physical location of the Redshift table.</p>
    pub fn table_location(&self) -> std::option::Option<&str> {
        self.table_location.as_deref()
    }
    /// <p>The name of the connection to use to write to Redshift.</p>
    pub fn connection_name(&self) -> std::option::Option<&str> {
        self.connection_name.as_deref()
    }
    /// <p>The keys used to determine whether to perform an update or insert.</p>
    pub fn upsert_keys(&self) -> std::option::Option<&[std::string::String]> {
        self.upsert_keys.as_deref()
    }
}
/// See [`UpsertRedshiftTargetOptions`](crate::model::UpsertRedshiftTargetOptions).
pub mod upsert_redshift_target_options {

    /// A builder for [`UpsertRedshiftTargetOptions`](crate::model::UpsertRedshiftTargetOptions).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) table_location: std::option::Option<std::string::String>,
        pub(crate) connection_name: std::option::Option<std::string::String>,
        pub(crate) upsert_keys: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The physical location of the Redshift table.</p>
        pub fn table_location(mut self, input: impl Into<std::string::String>) -> Self {
            self.table_location = Some(input.into());
            self
        }
        /// <p>The physical location of the Redshift table.</p>
        pub fn set_table_location(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.table_location = input;
            self
        }
        /// <p>The name of the connection to use to write to Redshift.</p>
        pub fn connection_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.connection_name = Some(input.into());
            self
        }
        /// <p>The name of the connection to use to write to Redshift.</p>
        pub fn set_connection_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.connection_name = input;
            self
        }
        /// Appends an item to `upsert_keys`.
        ///
        /// To override the contents of this collection use [`set_upsert_keys`](Self::set_upsert_keys).
        ///
        /// <p>The keys used to determine whether to perform an update or insert.</p>
        pub fn upsert_keys(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.upsert_keys.unwrap_or_default();
            v.push(input.into());
            self.upsert_keys = Some(v);
            self
        }
        /// <p>The keys used to determine whether to perform an update or insert.</p>
        pub fn set_upsert_keys(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.upsert_keys = input;
            self
        }
        /// Consumes the builder and constructs a [`UpsertRedshiftTargetOptions`](crate::model::UpsertRedshiftTargetOptions).
        pub fn build(self) -> crate::model::UpsertRedshiftTargetOptions {
            crate::model::UpsertRedshiftTargetOptions {
                table_location: self.table_location,
                connection_name: self.connection_name,
                upsert_keys: self.upsert_keys,
            }
        }
    }
}
impl UpsertRedshiftTargetOptions {
    /// Creates a new builder-style object to manufacture [`UpsertRedshiftTargetOptions`](crate::model::UpsertRedshiftTargetOptions).
    pub fn builder() -> crate::model::upsert_redshift_target_options::Builder {
        crate::model::upsert_redshift_target_options::Builder::default()
    }
}

/// <p>Specifies a target that uses a Glue Data Catalog table.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BasicCatalogTarget {
    /// <p>The name of your data target.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The nodes that are inputs to the data target.</p>
    #[doc(hidden)]
    pub inputs: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The database that contains the table you want to use as the target. This database must already exist in the Data Catalog.</p>
    #[doc(hidden)]
    pub database: std::option::Option<std::string::String>,
    /// <p>The table that defines the schema of your output data. This table must already exist in the Data Catalog.</p>
    #[doc(hidden)]
    pub table: std::option::Option<std::string::String>,
}
impl BasicCatalogTarget {
    /// <p>The name of your data target.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The nodes that are inputs to the data target.</p>
    pub fn inputs(&self) -> std::option::Option<&[std::string::String]> {
        self.inputs.as_deref()
    }
    /// <p>The database that contains the table you want to use as the target. This database must already exist in the Data Catalog.</p>
    pub fn database(&self) -> std::option::Option<&str> {
        self.database.as_deref()
    }
    /// <p>The table that defines the schema of your output data. This table must already exist in the Data Catalog.</p>
    pub fn table(&self) -> std::option::Option<&str> {
        self.table.as_deref()
    }
}
/// See [`BasicCatalogTarget`](crate::model::BasicCatalogTarget).
pub mod basic_catalog_target {

    /// A builder for [`BasicCatalogTarget`](crate::model::BasicCatalogTarget).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) inputs: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) database: std::option::Option<std::string::String>,
        pub(crate) table: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of your data target.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of your data target.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Appends an item to `inputs`.
        ///
        /// To override the contents of this collection use [`set_inputs`](Self::set_inputs).
        ///
        /// <p>The nodes that are inputs to the data target.</p>
        pub fn inputs(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.inputs.unwrap_or_default();
            v.push(input.into());
            self.inputs = Some(v);
            self
        }
        /// <p>The nodes that are inputs to the data target.</p>
        pub fn set_inputs(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inputs = input;
            self
        }
        /// <p>The database that contains the table you want to use as the target. This database must already exist in the Data Catalog.</p>
        pub fn database(mut self, input: impl Into<std::string::String>) -> Self {
            self.database = Some(input.into());
            self
        }
        /// <p>The database that contains the table you want to use as the target. This database must already exist in the Data Catalog.</p>
        pub fn set_database(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.database = input;
            self
        }
        /// <p>The table that defines the schema of your output data. This table must already exist in the Data Catalog.</p>
        pub fn table(mut self, input: impl Into<std::string::String>) -> Self {
            self.table = Some(input.into());
            self
        }
        /// <p>The table that defines the schema of your output data. This table must already exist in the Data Catalog.</p>
        pub fn set_table(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.table = input;
            self
        }
        /// Consumes the builder and constructs a [`BasicCatalogTarget`](crate::model::BasicCatalogTarget).
        pub fn build(self) -> crate::model::BasicCatalogTarget {
            crate::model::BasicCatalogTarget {
                name: self.name,
                inputs: self.inputs,
                database: self.database,
                table: self.table,
            }
        }
    }
}
impl BasicCatalogTarget {
    /// Creates a new builder-style object to manufacture [`BasicCatalogTarget`](crate::model::BasicCatalogTarget).
    pub fn builder() -> crate::model::basic_catalog_target::Builder {
        crate::model::basic_catalog_target::Builder::default()
    }
}

/// <p>Specifies a target that uses an Apache Spark connector.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SparkConnectorTarget {
    /// <p>The name of the data target.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The nodes that are inputs to the data target.</p>
    #[doc(hidden)]
    pub inputs: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The name of a connection for an Apache Spark connector.</p>
    #[doc(hidden)]
    pub connection_name: std::option::Option<std::string::String>,
    /// <p>The name of an Apache Spark connector.</p>
    #[doc(hidden)]
    pub connector_name: std::option::Option<std::string::String>,
    /// <p>The type of connection, such as marketplace.spark or custom.spark, designating a connection to an Apache Spark data store.</p>
    #[doc(hidden)]
    pub connection_type: std::option::Option<std::string::String>,
    /// <p>Additional connection options for the connector.</p>
    #[doc(hidden)]
    pub additional_options:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>Specifies the data schema for the custom spark target.</p>
    #[doc(hidden)]
    pub output_schemas: std::option::Option<std::vec::Vec<crate::model::GlueSchema>>,
}
impl SparkConnectorTarget {
    /// <p>The name of the data target.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The nodes that are inputs to the data target.</p>
    pub fn inputs(&self) -> std::option::Option<&[std::string::String]> {
        self.inputs.as_deref()
    }
    /// <p>The name of a connection for an Apache Spark connector.</p>
    pub fn connection_name(&self) -> std::option::Option<&str> {
        self.connection_name.as_deref()
    }
    /// <p>The name of an Apache Spark connector.</p>
    pub fn connector_name(&self) -> std::option::Option<&str> {
        self.connector_name.as_deref()
    }
    /// <p>The type of connection, such as marketplace.spark or custom.spark, designating a connection to an Apache Spark data store.</p>
    pub fn connection_type(&self) -> std::option::Option<&str> {
        self.connection_type.as_deref()
    }
    /// <p>Additional connection options for the connector.</p>
    pub fn additional_options(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.additional_options.as_ref()
    }
    /// <p>Specifies the data schema for the custom spark target.</p>
    pub fn output_schemas(&self) -> std::option::Option<&[crate::model::GlueSchema]> {
        self.output_schemas.as_deref()
    }
}
/// See [`SparkConnectorTarget`](crate::model::SparkConnectorTarget).
pub mod spark_connector_target {

    /// A builder for [`SparkConnectorTarget`](crate::model::SparkConnectorTarget).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) inputs: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) connection_name: std::option::Option<std::string::String>,
        pub(crate) connector_name: std::option::Option<std::string::String>,
        pub(crate) connection_type: std::option::Option<std::string::String>,
        pub(crate) additional_options: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) output_schemas: std::option::Option<std::vec::Vec<crate::model::GlueSchema>>,
    }
    impl Builder {
        /// <p>The name of the data target.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the data target.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Appends an item to `inputs`.
        ///
        /// To override the contents of this collection use [`set_inputs`](Self::set_inputs).
        ///
        /// <p>The nodes that are inputs to the data target.</p>
        pub fn inputs(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.inputs.unwrap_or_default();
            v.push(input.into());
            self.inputs = Some(v);
            self
        }
        /// <p>The nodes that are inputs to the data target.</p>
        pub fn set_inputs(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inputs = input;
            self
        }
        /// <p>The name of a connection for an Apache Spark connector.</p>
        pub fn connection_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.connection_name = Some(input.into());
            self
        }
        /// <p>The name of a connection for an Apache Spark connector.</p>
        pub fn set_connection_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.connection_name = input;
            self
        }
        /// <p>The name of an Apache Spark connector.</p>
        pub fn connector_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.connector_name = Some(input.into());
            self
        }
        /// <p>The name of an Apache Spark connector.</p>
        pub fn set_connector_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.connector_name = input;
            self
        }
        /// <p>The type of connection, such as marketplace.spark or custom.spark, designating a connection to an Apache Spark data store.</p>
        pub fn connection_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.connection_type = Some(input.into());
            self
        }
        /// <p>The type of connection, such as marketplace.spark or custom.spark, designating a connection to an Apache Spark data store.</p>
        pub fn set_connection_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.connection_type = input;
            self
        }
        /// Adds a key-value pair to `additional_options`.
        ///
        /// To override the contents of this collection use [`set_additional_options`](Self::set_additional_options).
        ///
        /// <p>Additional connection options for the connector.</p>
        pub fn additional_options(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.additional_options.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.additional_options = Some(hash_map);
            self
        }
        /// <p>Additional connection options for the connector.</p>
        pub fn set_additional_options(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.additional_options = input;
            self
        }
        /// Appends an item to `output_schemas`.
        ///
        /// To override the contents of this collection use [`set_output_schemas`](Self::set_output_schemas).
        ///
        /// <p>Specifies the data schema for the custom spark target.</p>
        pub fn output_schemas(mut self, input: crate::model::GlueSchema) -> Self {
            let mut v = self.output_schemas.unwrap_or_default();
            v.push(input);
            self.output_schemas = Some(v);
            self
        }
        /// <p>Specifies the data schema for the custom spark target.</p>
        pub fn set_output_schemas(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::GlueSchema>>,
        ) -> Self {
            self.output_schemas = input;
            self
        }
        /// Consumes the builder and constructs a [`SparkConnectorTarget`](crate::model::SparkConnectorTarget).
        pub fn build(self) -> crate::model::SparkConnectorTarget {
            crate::model::SparkConnectorTarget {
                name: self.name,
                inputs: self.inputs,
                connection_name: self.connection_name,
                connector_name: self.connector_name,
                connection_type: self.connection_type,
                additional_options: self.additional_options,
                output_schemas: self.output_schemas,
            }
        }
    }
}
impl SparkConnectorTarget {
    /// Creates a new builder-style object to manufacture [`SparkConnectorTarget`](crate::model::SparkConnectorTarget).
    pub fn builder() -> crate::model::spark_connector_target::Builder {
        crate::model::spark_connector_target::Builder::default()
    }
}

/// <p>Specifies a data target that writes to Amazon S3 in Apache Parquet columnar storage.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct JdbcConnectorTarget {
    /// <p>The name of the data target.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The nodes that are inputs to the data target.</p>
    #[doc(hidden)]
    pub inputs: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The name of the connection that is associated with the connector.</p>
    #[doc(hidden)]
    pub connection_name: std::option::Option<std::string::String>,
    /// <p>The name of the table in the data target.</p>
    #[doc(hidden)]
    pub connection_table: std::option::Option<std::string::String>,
    /// <p>The name of a connector that will be used.</p>
    #[doc(hidden)]
    pub connector_name: std::option::Option<std::string::String>,
    /// <p>The type of connection, such as marketplace.jdbc or custom.jdbc, designating a connection to a JDBC data target.</p>
    #[doc(hidden)]
    pub connection_type: std::option::Option<std::string::String>,
    /// <p>Additional connection options for the connector.</p>
    #[doc(hidden)]
    pub additional_options:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>Specifies the data schema for the JDBC target.</p>
    #[doc(hidden)]
    pub output_schemas: std::option::Option<std::vec::Vec<crate::model::GlueSchema>>,
}
impl JdbcConnectorTarget {
    /// <p>The name of the data target.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The nodes that are inputs to the data target.</p>
    pub fn inputs(&self) -> std::option::Option<&[std::string::String]> {
        self.inputs.as_deref()
    }
    /// <p>The name of the connection that is associated with the connector.</p>
    pub fn connection_name(&self) -> std::option::Option<&str> {
        self.connection_name.as_deref()
    }
    /// <p>The name of the table in the data target.</p>
    pub fn connection_table(&self) -> std::option::Option<&str> {
        self.connection_table.as_deref()
    }
    /// <p>The name of a connector that will be used.</p>
    pub fn connector_name(&self) -> std::option::Option<&str> {
        self.connector_name.as_deref()
    }
    /// <p>The type of connection, such as marketplace.jdbc or custom.jdbc, designating a connection to a JDBC data target.</p>
    pub fn connection_type(&self) -> std::option::Option<&str> {
        self.connection_type.as_deref()
    }
    /// <p>Additional connection options for the connector.</p>
    pub fn additional_options(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.additional_options.as_ref()
    }
    /// <p>Specifies the data schema for the JDBC target.</p>
    pub fn output_schemas(&self) -> std::option::Option<&[crate::model::GlueSchema]> {
        self.output_schemas.as_deref()
    }
}
/// See [`JdbcConnectorTarget`](crate::model::JdbcConnectorTarget).
pub mod jdbc_connector_target {

    /// A builder for [`JdbcConnectorTarget`](crate::model::JdbcConnectorTarget).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) inputs: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) connection_name: std::option::Option<std::string::String>,
        pub(crate) connection_table: std::option::Option<std::string::String>,
        pub(crate) connector_name: std::option::Option<std::string::String>,
        pub(crate) connection_type: std::option::Option<std::string::String>,
        pub(crate) additional_options: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) output_schemas: std::option::Option<std::vec::Vec<crate::model::GlueSchema>>,
    }
    impl Builder {
        /// <p>The name of the data target.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the data target.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Appends an item to `inputs`.
        ///
        /// To override the contents of this collection use [`set_inputs`](Self::set_inputs).
        ///
        /// <p>The nodes that are inputs to the data target.</p>
        pub fn inputs(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.inputs.unwrap_or_default();
            v.push(input.into());
            self.inputs = Some(v);
            self
        }
        /// <p>The nodes that are inputs to the data target.</p>
        pub fn set_inputs(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inputs = input;
            self
        }
        /// <p>The name of the connection that is associated with the connector.</p>
        pub fn connection_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.connection_name = Some(input.into());
            self
        }
        /// <p>The name of the connection that is associated with the connector.</p>
        pub fn set_connection_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.connection_name = input;
            self
        }
        /// <p>The name of the table in the data target.</p>
        pub fn connection_table(mut self, input: impl Into<std::string::String>) -> Self {
            self.connection_table = Some(input.into());
            self
        }
        /// <p>The name of the table in the data target.</p>
        pub fn set_connection_table(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.connection_table = input;
            self
        }
        /// <p>The name of a connector that will be used.</p>
        pub fn connector_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.connector_name = Some(input.into());
            self
        }
        /// <p>The name of a connector that will be used.</p>
        pub fn set_connector_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.connector_name = input;
            self
        }
        /// <p>The type of connection, such as marketplace.jdbc or custom.jdbc, designating a connection to a JDBC data target.</p>
        pub fn connection_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.connection_type = Some(input.into());
            self
        }
        /// <p>The type of connection, such as marketplace.jdbc or custom.jdbc, designating a connection to a JDBC data target.</p>
        pub fn set_connection_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.connection_type = input;
            self
        }
        /// Adds a key-value pair to `additional_options`.
        ///
        /// To override the contents of this collection use [`set_additional_options`](Self::set_additional_options).
        ///
        /// <p>Additional connection options for the connector.</p>
        pub fn additional_options(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.additional_options.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.additional_options = Some(hash_map);
            self
        }
        /// <p>Additional connection options for the connector.</p>
        pub fn set_additional_options(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.additional_options = input;
            self
        }
        /// Appends an item to `output_schemas`.
        ///
        /// To override the contents of this collection use [`set_output_schemas`](Self::set_output_schemas).
        ///
        /// <p>Specifies the data schema for the JDBC target.</p>
        pub fn output_schemas(mut self, input: crate::model::GlueSchema) -> Self {
            let mut v = self.output_schemas.unwrap_or_default();
            v.push(input);
            self.output_schemas = Some(v);
            self
        }
        /// <p>Specifies the data schema for the JDBC target.</p>
        pub fn set_output_schemas(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::GlueSchema>>,
        ) -> Self {
            self.output_schemas = input;
            self
        }
        /// Consumes the builder and constructs a [`JdbcConnectorTarget`](crate::model::JdbcConnectorTarget).
        pub fn build(self) -> crate::model::JdbcConnectorTarget {
            crate::model::JdbcConnectorTarget {
                name: self.name,
                inputs: self.inputs,
                connection_name: self.connection_name,
                connection_table: self.connection_table,
                connector_name: self.connector_name,
                connection_type: self.connection_type,
                additional_options: self.additional_options,
                output_schemas: self.output_schemas,
            }
        }
    }
}
impl JdbcConnectorTarget {
    /// Creates a new builder-style object to manufacture [`JdbcConnectorTarget`](crate::model::JdbcConnectorTarget).
    pub fn builder() -> crate::model::jdbc_connector_target::Builder {
        crate::model::jdbc_connector_target::Builder::default()
    }
}

/// <p>Specifies a DynamoDB data source in the Glue Data Catalog.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DynamoDbCatalogSource {
    /// <p>The name of the data source.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The name of the database to read from.</p>
    #[doc(hidden)]
    pub database: std::option::Option<std::string::String>,
    /// <p>The name of the table in the database to read from.</p>
    #[doc(hidden)]
    pub table: std::option::Option<std::string::String>,
}
impl DynamoDbCatalogSource {
    /// <p>The name of the data source.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The name of the database to read from.</p>
    pub fn database(&self) -> std::option::Option<&str> {
        self.database.as_deref()
    }
    /// <p>The name of the table in the database to read from.</p>
    pub fn table(&self) -> std::option::Option<&str> {
        self.table.as_deref()
    }
}
/// See [`DynamoDbCatalogSource`](crate::model::DynamoDbCatalogSource).
pub mod dynamo_db_catalog_source {

    /// A builder for [`DynamoDbCatalogSource`](crate::model::DynamoDbCatalogSource).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) database: std::option::Option<std::string::String>,
        pub(crate) table: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the data source.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the data source.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The name of the database to read from.</p>
        pub fn database(mut self, input: impl Into<std::string::String>) -> Self {
            self.database = Some(input.into());
            self
        }
        /// <p>The name of the database to read from.</p>
        pub fn set_database(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.database = input;
            self
        }
        /// <p>The name of the table in the database to read from.</p>
        pub fn table(mut self, input: impl Into<std::string::String>) -> Self {
            self.table = Some(input.into());
            self
        }
        /// <p>The name of the table in the database to read from.</p>
        pub fn set_table(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.table = input;
            self
        }
        /// Consumes the builder and constructs a [`DynamoDbCatalogSource`](crate::model::DynamoDbCatalogSource).
        pub fn build(self) -> crate::model::DynamoDbCatalogSource {
            crate::model::DynamoDbCatalogSource {
                name: self.name,
                database: self.database,
                table: self.table,
            }
        }
    }
}
impl DynamoDbCatalogSource {
    /// Creates a new builder-style object to manufacture [`DynamoDbCatalogSource`](crate::model::DynamoDbCatalogSource).
    pub fn builder() -> crate::model::dynamo_db_catalog_source::Builder {
        crate::model::dynamo_db_catalog_source::Builder::default()
    }
}

/// <p>Specifies a Relational database data source in the Glue Data Catalog.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RelationalCatalogSource {
    /// <p>The name of the data source.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The name of the database to read from.</p>
    #[doc(hidden)]
    pub database: std::option::Option<std::string::String>,
    /// <p>The name of the table in the database to read from.</p>
    #[doc(hidden)]
    pub table: std::option::Option<std::string::String>,
}
impl RelationalCatalogSource {
    /// <p>The name of the data source.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The name of the database to read from.</p>
    pub fn database(&self) -> std::option::Option<&str> {
        self.database.as_deref()
    }
    /// <p>The name of the table in the database to read from.</p>
    pub fn table(&self) -> std::option::Option<&str> {
        self.table.as_deref()
    }
}
/// See [`RelationalCatalogSource`](crate::model::RelationalCatalogSource).
pub mod relational_catalog_source {

    /// A builder for [`RelationalCatalogSource`](crate::model::RelationalCatalogSource).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) database: std::option::Option<std::string::String>,
        pub(crate) table: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the data source.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the data source.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The name of the database to read from.</p>
        pub fn database(mut self, input: impl Into<std::string::String>) -> Self {
            self.database = Some(input.into());
            self
        }
        /// <p>The name of the database to read from.</p>
        pub fn set_database(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.database = input;
            self
        }
        /// <p>The name of the table in the database to read from.</p>
        pub fn table(mut self, input: impl Into<std::string::String>) -> Self {
            self.table = Some(input.into());
            self
        }
        /// <p>The name of the table in the database to read from.</p>
        pub fn set_table(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.table = input;
            self
        }
        /// Consumes the builder and constructs a [`RelationalCatalogSource`](crate::model::RelationalCatalogSource).
        pub fn build(self) -> crate::model::RelationalCatalogSource {
            crate::model::RelationalCatalogSource {
                name: self.name,
                database: self.database,
                table: self.table,
            }
        }
    }
}
impl RelationalCatalogSource {
    /// Creates a new builder-style object to manufacture [`RelationalCatalogSource`](crate::model::RelationalCatalogSource).
    pub fn builder() -> crate::model::relational_catalog_source::Builder {
        crate::model::relational_catalog_source::Builder::default()
    }
}

/// <p>Specifies an Apache Parquet data store stored in Amazon S3.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct S3ParquetSource {
    /// <p>The name of the data store.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>A list of the Amazon S3 paths to read from.</p>
    #[doc(hidden)]
    pub paths: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Specifies how the data is compressed. This is generally not necessary if the data has a standard file extension. Possible values are <code>"gzip"</code> and <code>"bzip"</code>).</p>
    #[doc(hidden)]
    pub compression_type: std::option::Option<crate::model::ParquetCompressionType>,
    /// <p>A string containing a JSON list of Unix-style glob patterns to exclude. For example, "[\"**.pdf\"]" excludes all PDF files. </p>
    #[doc(hidden)]
    pub exclusions: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The target group size in bytes. The default is computed based on the input data size and the size of your cluster. When there are fewer than 50,000 input files, <code>"groupFiles"</code> must be set to <code>"inPartition"</code> for this to take effect.</p>
    #[doc(hidden)]
    pub group_size: std::option::Option<std::string::String>,
    /// <p>Grouping files is turned on by default when the input contains more than 50,000 files. To turn on grouping with fewer than 50,000 files, set this parameter to "inPartition". To disable grouping when there are more than 50,000 files, set this parameter to <code>"none"</code>.</p>
    #[doc(hidden)]
    pub group_files: std::option::Option<std::string::String>,
    /// <p>If set to true, recursively reads files in all subdirectories under the specified paths.</p>
    #[doc(hidden)]
    pub recurse: std::option::Option<bool>,
    /// <p>This option controls the duration in milliseconds after which the s3 listing is likely to be consistent. Files with modification timestamps falling within the last maxBand milliseconds are tracked specially when using JobBookmarks to account for Amazon S3 eventual consistency. Most users don't need to set this option. The default is 900000 milliseconds, or 15 minutes.</p>
    #[doc(hidden)]
    pub max_band: std::option::Option<i32>,
    /// <p>This option specifies the maximum number of files to save from the last maxBand seconds. If this number is exceeded, extra files are skipped and only processed in the next job run.</p>
    #[doc(hidden)]
    pub max_files_in_band: std::option::Option<i32>,
    /// <p>Specifies additional connection options.</p>
    #[doc(hidden)]
    pub additional_options: std::option::Option<crate::model::S3DirectSourceAdditionalOptions>,
    /// <p>Specifies the data schema for the S3 Parquet source.</p>
    #[doc(hidden)]
    pub output_schemas: std::option::Option<std::vec::Vec<crate::model::GlueSchema>>,
}
impl S3ParquetSource {
    /// <p>The name of the data store.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>A list of the Amazon S3 paths to read from.</p>
    pub fn paths(&self) -> std::option::Option<&[std::string::String]> {
        self.paths.as_deref()
    }
    /// <p>Specifies how the data is compressed. This is generally not necessary if the data has a standard file extension. Possible values are <code>"gzip"</code> and <code>"bzip"</code>).</p>
    pub fn compression_type(&self) -> std::option::Option<&crate::model::ParquetCompressionType> {
        self.compression_type.as_ref()
    }
    /// <p>A string containing a JSON list of Unix-style glob patterns to exclude. For example, "[\"**.pdf\"]" excludes all PDF files. </p>
    pub fn exclusions(&self) -> std::option::Option<&[std::string::String]> {
        self.exclusions.as_deref()
    }
    /// <p>The target group size in bytes. The default is computed based on the input data size and the size of your cluster. When there are fewer than 50,000 input files, <code>"groupFiles"</code> must be set to <code>"inPartition"</code> for this to take effect.</p>
    pub fn group_size(&self) -> std::option::Option<&str> {
        self.group_size.as_deref()
    }
    /// <p>Grouping files is turned on by default when the input contains more than 50,000 files. To turn on grouping with fewer than 50,000 files, set this parameter to "inPartition". To disable grouping when there are more than 50,000 files, set this parameter to <code>"none"</code>.</p>
    pub fn group_files(&self) -> std::option::Option<&str> {
        self.group_files.as_deref()
    }
    /// <p>If set to true, recursively reads files in all subdirectories under the specified paths.</p>
    pub fn recurse(&self) -> std::option::Option<bool> {
        self.recurse
    }
    /// <p>This option controls the duration in milliseconds after which the s3 listing is likely to be consistent. Files with modification timestamps falling within the last maxBand milliseconds are tracked specially when using JobBookmarks to account for Amazon S3 eventual consistency. Most users don't need to set this option. The default is 900000 milliseconds, or 15 minutes.</p>
    pub fn max_band(&self) -> std::option::Option<i32> {
        self.max_band
    }
    /// <p>This option specifies the maximum number of files to save from the last maxBand seconds. If this number is exceeded, extra files are skipped and only processed in the next job run.</p>
    pub fn max_files_in_band(&self) -> std::option::Option<i32> {
        self.max_files_in_band
    }
    /// <p>Specifies additional connection options.</p>
    pub fn additional_options(
        &self,
    ) -> std::option::Option<&crate::model::S3DirectSourceAdditionalOptions> {
        self.additional_options.as_ref()
    }
    /// <p>Specifies the data schema for the S3 Parquet source.</p>
    pub fn output_schemas(&self) -> std::option::Option<&[crate::model::GlueSchema]> {
        self.output_schemas.as_deref()
    }
}
/// See [`S3ParquetSource`](crate::model::S3ParquetSource).
pub mod s3_parquet_source {

    /// A builder for [`S3ParquetSource`](crate::model::S3ParquetSource).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) paths: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) compression_type: std::option::Option<crate::model::ParquetCompressionType>,
        pub(crate) exclusions: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) group_size: std::option::Option<std::string::String>,
        pub(crate) group_files: std::option::Option<std::string::String>,
        pub(crate) recurse: std::option::Option<bool>,
        pub(crate) max_band: std::option::Option<i32>,
        pub(crate) max_files_in_band: std::option::Option<i32>,
        pub(crate) additional_options:
            std::option::Option<crate::model::S3DirectSourceAdditionalOptions>,
        pub(crate) output_schemas: std::option::Option<std::vec::Vec<crate::model::GlueSchema>>,
    }
    impl Builder {
        /// <p>The name of the data store.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the data store.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Appends an item to `paths`.
        ///
        /// To override the contents of this collection use [`set_paths`](Self::set_paths).
        ///
        /// <p>A list of the Amazon S3 paths to read from.</p>
        pub fn paths(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.paths.unwrap_or_default();
            v.push(input.into());
            self.paths = Some(v);
            self
        }
        /// <p>A list of the Amazon S3 paths to read from.</p>
        pub fn set_paths(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.paths = input;
            self
        }
        /// <p>Specifies how the data is compressed. This is generally not necessary if the data has a standard file extension. Possible values are <code>"gzip"</code> and <code>"bzip"</code>).</p>
        pub fn compression_type(mut self, input: crate::model::ParquetCompressionType) -> Self {
            self.compression_type = Some(input);
            self
        }
        /// <p>Specifies how the data is compressed. This is generally not necessary if the data has a standard file extension. Possible values are <code>"gzip"</code> and <code>"bzip"</code>).</p>
        pub fn set_compression_type(
            mut self,
            input: std::option::Option<crate::model::ParquetCompressionType>,
        ) -> Self {
            self.compression_type = input;
            self
        }
        /// Appends an item to `exclusions`.
        ///
        /// To override the contents of this collection use [`set_exclusions`](Self::set_exclusions).
        ///
        /// <p>A string containing a JSON list of Unix-style glob patterns to exclude. For example, "[\"**.pdf\"]" excludes all PDF files. </p>
        pub fn exclusions(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.exclusions.unwrap_or_default();
            v.push(input.into());
            self.exclusions = Some(v);
            self
        }
        /// <p>A string containing a JSON list of Unix-style glob patterns to exclude. For example, "[\"**.pdf\"]" excludes all PDF files. </p>
        pub fn set_exclusions(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.exclusions = input;
            self
        }
        /// <p>The target group size in bytes. The default is computed based on the input data size and the size of your cluster. When there are fewer than 50,000 input files, <code>"groupFiles"</code> must be set to <code>"inPartition"</code> for this to take effect.</p>
        pub fn group_size(mut self, input: impl Into<std::string::String>) -> Self {
            self.group_size = Some(input.into());
            self
        }
        /// <p>The target group size in bytes. The default is computed based on the input data size and the size of your cluster. When there are fewer than 50,000 input files, <code>"groupFiles"</code> must be set to <code>"inPartition"</code> for this to take effect.</p>
        pub fn set_group_size(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.group_size = input;
            self
        }
        /// <p>Grouping files is turned on by default when the input contains more than 50,000 files. To turn on grouping with fewer than 50,000 files, set this parameter to "inPartition". To disable grouping when there are more than 50,000 files, set this parameter to <code>"none"</code>.</p>
        pub fn group_files(mut self, input: impl Into<std::string::String>) -> Self {
            self.group_files = Some(input.into());
            self
        }
        /// <p>Grouping files is turned on by default when the input contains more than 50,000 files. To turn on grouping with fewer than 50,000 files, set this parameter to "inPartition". To disable grouping when there are more than 50,000 files, set this parameter to <code>"none"</code>.</p>
        pub fn set_group_files(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.group_files = input;
            self
        }
        /// <p>If set to true, recursively reads files in all subdirectories under the specified paths.</p>
        pub fn recurse(mut self, input: bool) -> Self {
            self.recurse = Some(input);
            self
        }
        /// <p>If set to true, recursively reads files in all subdirectories under the specified paths.</p>
        pub fn set_recurse(mut self, input: std::option::Option<bool>) -> Self {
            self.recurse = input;
            self
        }
        /// <p>This option controls the duration in milliseconds after which the s3 listing is likely to be consistent. Files with modification timestamps falling within the last maxBand milliseconds are tracked specially when using JobBookmarks to account for Amazon S3 eventual consistency. Most users don't need to set this option. The default is 900000 milliseconds, or 15 minutes.</p>
        pub fn max_band(mut self, input: i32) -> Self {
            self.max_band = Some(input);
            self
        }
        /// <p>This option controls the duration in milliseconds after which the s3 listing is likely to be consistent. Files with modification timestamps falling within the last maxBand milliseconds are tracked specially when using JobBookmarks to account for Amazon S3 eventual consistency. Most users don't need to set this option. The default is 900000 milliseconds, or 15 minutes.</p>
        pub fn set_max_band(mut self, input: std::option::Option<i32>) -> Self {
            self.max_band = input;
            self
        }
        /// <p>This option specifies the maximum number of files to save from the last maxBand seconds. If this number is exceeded, extra files are skipped and only processed in the next job run.</p>
        pub fn max_files_in_band(mut self, input: i32) -> Self {
            self.max_files_in_band = Some(input);
            self
        }
        /// <p>This option specifies the maximum number of files to save from the last maxBand seconds. If this number is exceeded, extra files are skipped and only processed in the next job run.</p>
        pub fn set_max_files_in_band(mut self, input: std::option::Option<i32>) -> Self {
            self.max_files_in_band = input;
            self
        }
        /// <p>Specifies additional connection options.</p>
        pub fn additional_options(
            mut self,
            input: crate::model::S3DirectSourceAdditionalOptions,
        ) -> Self {
            self.additional_options = Some(input);
            self
        }
        /// <p>Specifies additional connection options.</p>
        pub fn set_additional_options(
            mut self,
            input: std::option::Option<crate::model::S3DirectSourceAdditionalOptions>,
        ) -> Self {
            self.additional_options = input;
            self
        }
        /// Appends an item to `output_schemas`.
        ///
        /// To override the contents of this collection use [`set_output_schemas`](Self::set_output_schemas).
        ///
        /// <p>Specifies the data schema for the S3 Parquet source.</p>
        pub fn output_schemas(mut self, input: crate::model::GlueSchema) -> Self {
            let mut v = self.output_schemas.unwrap_or_default();
            v.push(input);
            self.output_schemas = Some(v);
            self
        }
        /// <p>Specifies the data schema for the S3 Parquet source.</p>
        pub fn set_output_schemas(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::GlueSchema>>,
        ) -> Self {
            self.output_schemas = input;
            self
        }
        /// Consumes the builder and constructs a [`S3ParquetSource`](crate::model::S3ParquetSource).
        pub fn build(self) -> crate::model::S3ParquetSource {
            crate::model::S3ParquetSource {
                name: self.name,
                paths: self.paths,
                compression_type: self.compression_type,
                exclusions: self.exclusions,
                group_size: self.group_size,
                group_files: self.group_files,
                recurse: self.recurse,
                max_band: self.max_band,
                max_files_in_band: self.max_files_in_band,
                additional_options: self.additional_options,
                output_schemas: self.output_schemas,
            }
        }
    }
}
impl S3ParquetSource {
    /// Creates a new builder-style object to manufacture [`S3ParquetSource`](crate::model::S3ParquetSource).
    pub fn builder() -> crate::model::s3_parquet_source::Builder {
        crate::model::s3_parquet_source::Builder::default()
    }
}

/// <p>Specifies a JSON data store stored in Amazon S3.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct S3JsonSource {
    /// <p>The name of the data store.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>A list of the Amazon S3 paths to read from.</p>
    #[doc(hidden)]
    pub paths: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Specifies how the data is compressed. This is generally not necessary if the data has a standard file extension. Possible values are <code>"gzip"</code> and <code>"bzip"</code>).</p>
    #[doc(hidden)]
    pub compression_type: std::option::Option<crate::model::CompressionType>,
    /// <p>A string containing a JSON list of Unix-style glob patterns to exclude. For example, "[\"**.pdf\"]" excludes all PDF files. </p>
    #[doc(hidden)]
    pub exclusions: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The target group size in bytes. The default is computed based on the input data size and the size of your cluster. When there are fewer than 50,000 input files, <code>"groupFiles"</code> must be set to <code>"inPartition"</code> for this to take effect.</p>
    #[doc(hidden)]
    pub group_size: std::option::Option<std::string::String>,
    /// <p>Grouping files is turned on by default when the input contains more than 50,000 files. To turn on grouping with fewer than 50,000 files, set this parameter to "inPartition". To disable grouping when there are more than 50,000 files, set this parameter to <code>"none"</code>.</p>
    #[doc(hidden)]
    pub group_files: std::option::Option<std::string::String>,
    /// <p>If set to true, recursively reads files in all subdirectories under the specified paths.</p>
    #[doc(hidden)]
    pub recurse: std::option::Option<bool>,
    /// <p>This option controls the duration in milliseconds after which the s3 listing is likely to be consistent. Files with modification timestamps falling within the last maxBand milliseconds are tracked specially when using JobBookmarks to account for Amazon S3 eventual consistency. Most users don't need to set this option. The default is 900000 milliseconds, or 15 minutes.</p>
    #[doc(hidden)]
    pub max_band: std::option::Option<i32>,
    /// <p>This option specifies the maximum number of files to save from the last maxBand seconds. If this number is exceeded, extra files are skipped and only processed in the next job run.</p>
    #[doc(hidden)]
    pub max_files_in_band: std::option::Option<i32>,
    /// <p>Specifies additional connection options.</p>
    #[doc(hidden)]
    pub additional_options: std::option::Option<crate::model::S3DirectSourceAdditionalOptions>,
    /// <p>A JsonPath string defining the JSON data.</p>
    #[doc(hidden)]
    pub json_path: std::option::Option<std::string::String>,
    /// <p>A Boolean value that specifies whether a single record can span multiple lines. This can occur when a field contains a quoted new-line character. You must set this option to True if any record spans multiple lines. The default value is <code>False</code>, which allows for more aggressive file-splitting during parsing.</p>
    #[doc(hidden)]
    pub multiline: std::option::Option<bool>,
    /// <p>Specifies the data schema for the S3 JSON source.</p>
    #[doc(hidden)]
    pub output_schemas: std::option::Option<std::vec::Vec<crate::model::GlueSchema>>,
}
impl S3JsonSource {
    /// <p>The name of the data store.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>A list of the Amazon S3 paths to read from.</p>
    pub fn paths(&self) -> std::option::Option<&[std::string::String]> {
        self.paths.as_deref()
    }
    /// <p>Specifies how the data is compressed. This is generally not necessary if the data has a standard file extension. Possible values are <code>"gzip"</code> and <code>"bzip"</code>).</p>
    pub fn compression_type(&self) -> std::option::Option<&crate::model::CompressionType> {
        self.compression_type.as_ref()
    }
    /// <p>A string containing a JSON list of Unix-style glob patterns to exclude. For example, "[\"**.pdf\"]" excludes all PDF files. </p>
    pub fn exclusions(&self) -> std::option::Option<&[std::string::String]> {
        self.exclusions.as_deref()
    }
    /// <p>The target group size in bytes. The default is computed based on the input data size and the size of your cluster. When there are fewer than 50,000 input files, <code>"groupFiles"</code> must be set to <code>"inPartition"</code> for this to take effect.</p>
    pub fn group_size(&self) -> std::option::Option<&str> {
        self.group_size.as_deref()
    }
    /// <p>Grouping files is turned on by default when the input contains more than 50,000 files. To turn on grouping with fewer than 50,000 files, set this parameter to "inPartition". To disable grouping when there are more than 50,000 files, set this parameter to <code>"none"</code>.</p>
    pub fn group_files(&self) -> std::option::Option<&str> {
        self.group_files.as_deref()
    }
    /// <p>If set to true, recursively reads files in all subdirectories under the specified paths.</p>
    pub fn recurse(&self) -> std::option::Option<bool> {
        self.recurse
    }
    /// <p>This option controls the duration in milliseconds after which the s3 listing is likely to be consistent. Files with modification timestamps falling within the last maxBand milliseconds are tracked specially when using JobBookmarks to account for Amazon S3 eventual consistency. Most users don't need to set this option. The default is 900000 milliseconds, or 15 minutes.</p>
    pub fn max_band(&self) -> std::option::Option<i32> {
        self.max_band
    }
    /// <p>This option specifies the maximum number of files to save from the last maxBand seconds. If this number is exceeded, extra files are skipped and only processed in the next job run.</p>
    pub fn max_files_in_band(&self) -> std::option::Option<i32> {
        self.max_files_in_band
    }
    /// <p>Specifies additional connection options.</p>
    pub fn additional_options(
        &self,
    ) -> std::option::Option<&crate::model::S3DirectSourceAdditionalOptions> {
        self.additional_options.as_ref()
    }
    /// <p>A JsonPath string defining the JSON data.</p>
    pub fn json_path(&self) -> std::option::Option<&str> {
        self.json_path.as_deref()
    }
    /// <p>A Boolean value that specifies whether a single record can span multiple lines. This can occur when a field contains a quoted new-line character. You must set this option to True if any record spans multiple lines. The default value is <code>False</code>, which allows for more aggressive file-splitting during parsing.</p>
    pub fn multiline(&self) -> std::option::Option<bool> {
        self.multiline
    }
    /// <p>Specifies the data schema for the S3 JSON source.</p>
    pub fn output_schemas(&self) -> std::option::Option<&[crate::model::GlueSchema]> {
        self.output_schemas.as_deref()
    }
}
/// See [`S3JsonSource`](crate::model::S3JsonSource).
pub mod s3_json_source {

    /// A builder for [`S3JsonSource`](crate::model::S3JsonSource).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) paths: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) compression_type: std::option::Option<crate::model::CompressionType>,
        pub(crate) exclusions: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) group_size: std::option::Option<std::string::String>,
        pub(crate) group_files: std::option::Option<std::string::String>,
        pub(crate) recurse: std::option::Option<bool>,
        pub(crate) max_band: std::option::Option<i32>,
        pub(crate) max_files_in_band: std::option::Option<i32>,
        pub(crate) additional_options:
            std::option::Option<crate::model::S3DirectSourceAdditionalOptions>,
        pub(crate) json_path: std::option::Option<std::string::String>,
        pub(crate) multiline: std::option::Option<bool>,
        pub(crate) output_schemas: std::option::Option<std::vec::Vec<crate::model::GlueSchema>>,
    }
    impl Builder {
        /// <p>The name of the data store.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the data store.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Appends an item to `paths`.
        ///
        /// To override the contents of this collection use [`set_paths`](Self::set_paths).
        ///
        /// <p>A list of the Amazon S3 paths to read from.</p>
        pub fn paths(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.paths.unwrap_or_default();
            v.push(input.into());
            self.paths = Some(v);
            self
        }
        /// <p>A list of the Amazon S3 paths to read from.</p>
        pub fn set_paths(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.paths = input;
            self
        }
        /// <p>Specifies how the data is compressed. This is generally not necessary if the data has a standard file extension. Possible values are <code>"gzip"</code> and <code>"bzip"</code>).</p>
        pub fn compression_type(mut self, input: crate::model::CompressionType) -> Self {
            self.compression_type = Some(input);
            self
        }
        /// <p>Specifies how the data is compressed. This is generally not necessary if the data has a standard file extension. Possible values are <code>"gzip"</code> and <code>"bzip"</code>).</p>
        pub fn set_compression_type(
            mut self,
            input: std::option::Option<crate::model::CompressionType>,
        ) -> Self {
            self.compression_type = input;
            self
        }
        /// Appends an item to `exclusions`.
        ///
        /// To override the contents of this collection use [`set_exclusions`](Self::set_exclusions).
        ///
        /// <p>A string containing a JSON list of Unix-style glob patterns to exclude. For example, "[\"**.pdf\"]" excludes all PDF files. </p>
        pub fn exclusions(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.exclusions.unwrap_or_default();
            v.push(input.into());
            self.exclusions = Some(v);
            self
        }
        /// <p>A string containing a JSON list of Unix-style glob patterns to exclude. For example, "[\"**.pdf\"]" excludes all PDF files. </p>
        pub fn set_exclusions(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.exclusions = input;
            self
        }
        /// <p>The target group size in bytes. The default is computed based on the input data size and the size of your cluster. When there are fewer than 50,000 input files, <code>"groupFiles"</code> must be set to <code>"inPartition"</code> for this to take effect.</p>
        pub fn group_size(mut self, input: impl Into<std::string::String>) -> Self {
            self.group_size = Some(input.into());
            self
        }
        /// <p>The target group size in bytes. The default is computed based on the input data size and the size of your cluster. When there are fewer than 50,000 input files, <code>"groupFiles"</code> must be set to <code>"inPartition"</code> for this to take effect.</p>
        pub fn set_group_size(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.group_size = input;
            self
        }
        /// <p>Grouping files is turned on by default when the input contains more than 50,000 files. To turn on grouping with fewer than 50,000 files, set this parameter to "inPartition". To disable grouping when there are more than 50,000 files, set this parameter to <code>"none"</code>.</p>
        pub fn group_files(mut self, input: impl Into<std::string::String>) -> Self {
            self.group_files = Some(input.into());
            self
        }
        /// <p>Grouping files is turned on by default when the input contains more than 50,000 files. To turn on grouping with fewer than 50,000 files, set this parameter to "inPartition". To disable grouping when there are more than 50,000 files, set this parameter to <code>"none"</code>.</p>
        pub fn set_group_files(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.group_files = input;
            self
        }
        /// <p>If set to true, recursively reads files in all subdirectories under the specified paths.</p>
        pub fn recurse(mut self, input: bool) -> Self {
            self.recurse = Some(input);
            self
        }
        /// <p>If set to true, recursively reads files in all subdirectories under the specified paths.</p>
        pub fn set_recurse(mut self, input: std::option::Option<bool>) -> Self {
            self.recurse = input;
            self
        }
        /// <p>This option controls the duration in milliseconds after which the s3 listing is likely to be consistent. Files with modification timestamps falling within the last maxBand milliseconds are tracked specially when using JobBookmarks to account for Amazon S3 eventual consistency. Most users don't need to set this option. The default is 900000 milliseconds, or 15 minutes.</p>
        pub fn max_band(mut self, input: i32) -> Self {
            self.max_band = Some(input);
            self
        }
        /// <p>This option controls the duration in milliseconds after which the s3 listing is likely to be consistent. Files with modification timestamps falling within the last maxBand milliseconds are tracked specially when using JobBookmarks to account for Amazon S3 eventual consistency. Most users don't need to set this option. The default is 900000 milliseconds, or 15 minutes.</p>
        pub fn set_max_band(mut self, input: std::option::Option<i32>) -> Self {
            self.max_band = input;
            self
        }
        /// <p>This option specifies the maximum number of files to save from the last maxBand seconds. If this number is exceeded, extra files are skipped and only processed in the next job run.</p>
        pub fn max_files_in_band(mut self, input: i32) -> Self {
            self.max_files_in_band = Some(input);
            self
        }
        /// <p>This option specifies the maximum number of files to save from the last maxBand seconds. If this number is exceeded, extra files are skipped and only processed in the next job run.</p>
        pub fn set_max_files_in_band(mut self, input: std::option::Option<i32>) -> Self {
            self.max_files_in_band = input;
            self
        }
        /// <p>Specifies additional connection options.</p>
        pub fn additional_options(
            mut self,
            input: crate::model::S3DirectSourceAdditionalOptions,
        ) -> Self {
            self.additional_options = Some(input);
            self
        }
        /// <p>Specifies additional connection options.</p>
        pub fn set_additional_options(
            mut self,
            input: std::option::Option<crate::model::S3DirectSourceAdditionalOptions>,
        ) -> Self {
            self.additional_options = input;
            self
        }
        /// <p>A JsonPath string defining the JSON data.</p>
        pub fn json_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.json_path = Some(input.into());
            self
        }
        /// <p>A JsonPath string defining the JSON data.</p>
        pub fn set_json_path(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.json_path = input;
            self
        }
        /// <p>A Boolean value that specifies whether a single record can span multiple lines. This can occur when a field contains a quoted new-line character. You must set this option to True if any record spans multiple lines. The default value is <code>False</code>, which allows for more aggressive file-splitting during parsing.</p>
        pub fn multiline(mut self, input: bool) -> Self {
            self.multiline = Some(input);
            self
        }
        /// <p>A Boolean value that specifies whether a single record can span multiple lines. This can occur when a field contains a quoted new-line character. You must set this option to True if any record spans multiple lines. The default value is <code>False</code>, which allows for more aggressive file-splitting during parsing.</p>
        pub fn set_multiline(mut self, input: std::option::Option<bool>) -> Self {
            self.multiline = input;
            self
        }
        /// Appends an item to `output_schemas`.
        ///
        /// To override the contents of this collection use [`set_output_schemas`](Self::set_output_schemas).
        ///
        /// <p>Specifies the data schema for the S3 JSON source.</p>
        pub fn output_schemas(mut self, input: crate::model::GlueSchema) -> Self {
            let mut v = self.output_schemas.unwrap_or_default();
            v.push(input);
            self.output_schemas = Some(v);
            self
        }
        /// <p>Specifies the data schema for the S3 JSON source.</p>
        pub fn set_output_schemas(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::GlueSchema>>,
        ) -> Self {
            self.output_schemas = input;
            self
        }
        /// Consumes the builder and constructs a [`S3JsonSource`](crate::model::S3JsonSource).
        pub fn build(self) -> crate::model::S3JsonSource {
            crate::model::S3JsonSource {
                name: self.name,
                paths: self.paths,
                compression_type: self.compression_type,
                exclusions: self.exclusions,
                group_size: self.group_size,
                group_files: self.group_files,
                recurse: self.recurse,
                max_band: self.max_band,
                max_files_in_band: self.max_files_in_band,
                additional_options: self.additional_options,
                json_path: self.json_path,
                multiline: self.multiline,
                output_schemas: self.output_schemas,
            }
        }
    }
}
impl S3JsonSource {
    /// Creates a new builder-style object to manufacture [`S3JsonSource`](crate::model::S3JsonSource).
    pub fn builder() -> crate::model::s3_json_source::Builder {
        crate::model::s3_json_source::Builder::default()
    }
}

/// When writing a match expression against `CompressionType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let compressiontype = unimplemented!();
/// match compressiontype {
///     CompressionType::Bzip2 => { /* ... */ },
///     CompressionType::Gzip => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `compressiontype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `CompressionType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `CompressionType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `CompressionType::NewFeature` is defined.
/// Specifically, when `compressiontype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `CompressionType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum CompressionType {
    #[allow(missing_docs)] // documentation missing in model
    Bzip2,
    #[allow(missing_docs)] // documentation missing in model
    Gzip,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for CompressionType {
    fn from(s: &str) -> Self {
        match s {
            "bzip2" => CompressionType::Bzip2,
            "gzip" => CompressionType::Gzip,
            other => CompressionType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for CompressionType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(CompressionType::from(s))
    }
}
impl CompressionType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            CompressionType::Bzip2 => "bzip2",
            CompressionType::Gzip => "gzip",
            CompressionType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["bzip2", "gzip"]
    }
}
impl AsRef<str> for CompressionType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Specifies a command-separated value (CSV) data store stored in Amazon S3.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct S3CsvSource {
    /// <p>The name of the data store.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>A list of the Amazon S3 paths to read from.</p>
    #[doc(hidden)]
    pub paths: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Specifies how the data is compressed. This is generally not necessary if the data has a standard file extension. Possible values are <code>"gzip"</code> and <code>"bzip"</code>).</p>
    #[doc(hidden)]
    pub compression_type: std::option::Option<crate::model::CompressionType>,
    /// <p>A string containing a JSON list of Unix-style glob patterns to exclude. For example, "[\"**.pdf\"]" excludes all PDF files. </p>
    #[doc(hidden)]
    pub exclusions: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The target group size in bytes. The default is computed based on the input data size and the size of your cluster. When there are fewer than 50,000 input files, <code>"groupFiles"</code> must be set to <code>"inPartition"</code> for this to take effect.</p>
    #[doc(hidden)]
    pub group_size: std::option::Option<std::string::String>,
    /// <p>Grouping files is turned on by default when the input contains more than 50,000 files. To turn on grouping with fewer than 50,000 files, set this parameter to "inPartition". To disable grouping when there are more than 50,000 files, set this parameter to <code>"none"</code>.</p>
    #[doc(hidden)]
    pub group_files: std::option::Option<std::string::String>,
    /// <p>If set to true, recursively reads files in all subdirectories under the specified paths.</p>
    #[doc(hidden)]
    pub recurse: std::option::Option<bool>,
    /// <p>This option controls the duration in milliseconds after which the s3 listing is likely to be consistent. Files with modification timestamps falling within the last maxBand milliseconds are tracked specially when using JobBookmarks to account for Amazon S3 eventual consistency. Most users don't need to set this option. The default is 900000 milliseconds, or 15 minutes.</p>
    #[doc(hidden)]
    pub max_band: std::option::Option<i32>,
    /// <p>This option specifies the maximum number of files to save from the last maxBand seconds. If this number is exceeded, extra files are skipped and only processed in the next job run.</p>
    #[doc(hidden)]
    pub max_files_in_band: std::option::Option<i32>,
    /// <p>Specifies additional connection options.</p>
    #[doc(hidden)]
    pub additional_options: std::option::Option<crate::model::S3DirectSourceAdditionalOptions>,
    /// <p>Specifies the delimiter character. The default is a comma: ",", but any other character can be specified.</p>
    #[doc(hidden)]
    pub separator: std::option::Option<crate::model::Separator>,
    /// <p>Specifies a character to use for escaping. This option is used only when reading CSV files. The default value is <code>none</code>. If enabled, the character which immediately follows is used as-is, except for a small set of well-known escapes (<code>\n</code>, <code>\r</code>, <code>\t</code>, and <code>\0</code>).</p>
    #[doc(hidden)]
    pub escaper: std::option::Option<std::string::String>,
    /// <p>Specifies the character to use for quoting. The default is a double quote: <code>'"'</code>. Set this to <code>-1</code> to turn off quoting entirely.</p>
    #[doc(hidden)]
    pub quote_char: std::option::Option<crate::model::QuoteChar>,
    /// <p>A Boolean value that specifies whether a single record can span multiple lines. This can occur when a field contains a quoted new-line character. You must set this option to True if any record spans multiple lines. The default value is <code>False</code>, which allows for more aggressive file-splitting during parsing.</p>
    #[doc(hidden)]
    pub multiline: std::option::Option<bool>,
    /// <p>A Boolean value that specifies whether to treat the first line as a header. The default value is <code>False</code>.</p>
    #[doc(hidden)]
    pub with_header: std::option::Option<bool>,
    /// <p>A Boolean value that specifies whether to write the header to output. The default value is <code>True</code>. </p>
    #[doc(hidden)]
    pub write_header: std::option::Option<bool>,
    /// <p>A Boolean value that specifies whether to skip the first data line. The default value is <code>False</code>.</p>
    #[doc(hidden)]
    pub skip_first: std::option::Option<bool>,
    /// <p>A Boolean value that specifies whether to use the advanced SIMD CSV reader along with Apache Arrow based columnar memory formats. Only available in Glue version 3.0.</p>
    #[doc(hidden)]
    pub optimize_performance: bool,
    /// <p>Specifies the data schema for the S3 CSV source.</p>
    #[doc(hidden)]
    pub output_schemas: std::option::Option<std::vec::Vec<crate::model::GlueSchema>>,
}
impl S3CsvSource {
    /// <p>The name of the data store.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>A list of the Amazon S3 paths to read from.</p>
    pub fn paths(&self) -> std::option::Option<&[std::string::String]> {
        self.paths.as_deref()
    }
    /// <p>Specifies how the data is compressed. This is generally not necessary if the data has a standard file extension. Possible values are <code>"gzip"</code> and <code>"bzip"</code>).</p>
    pub fn compression_type(&self) -> std::option::Option<&crate::model::CompressionType> {
        self.compression_type.as_ref()
    }
    /// <p>A string containing a JSON list of Unix-style glob patterns to exclude. For example, "[\"**.pdf\"]" excludes all PDF files. </p>
    pub fn exclusions(&self) -> std::option::Option<&[std::string::String]> {
        self.exclusions.as_deref()
    }
    /// <p>The target group size in bytes. The default is computed based on the input data size and the size of your cluster. When there are fewer than 50,000 input files, <code>"groupFiles"</code> must be set to <code>"inPartition"</code> for this to take effect.</p>
    pub fn group_size(&self) -> std::option::Option<&str> {
        self.group_size.as_deref()
    }
    /// <p>Grouping files is turned on by default when the input contains more than 50,000 files. To turn on grouping with fewer than 50,000 files, set this parameter to "inPartition". To disable grouping when there are more than 50,000 files, set this parameter to <code>"none"</code>.</p>
    pub fn group_files(&self) -> std::option::Option<&str> {
        self.group_files.as_deref()
    }
    /// <p>If set to true, recursively reads files in all subdirectories under the specified paths.</p>
    pub fn recurse(&self) -> std::option::Option<bool> {
        self.recurse
    }
    /// <p>This option controls the duration in milliseconds after which the s3 listing is likely to be consistent. Files with modification timestamps falling within the last maxBand milliseconds are tracked specially when using JobBookmarks to account for Amazon S3 eventual consistency. Most users don't need to set this option. The default is 900000 milliseconds, or 15 minutes.</p>
    pub fn max_band(&self) -> std::option::Option<i32> {
        self.max_band
    }
    /// <p>This option specifies the maximum number of files to save from the last maxBand seconds. If this number is exceeded, extra files are skipped and only processed in the next job run.</p>
    pub fn max_files_in_band(&self) -> std::option::Option<i32> {
        self.max_files_in_band
    }
    /// <p>Specifies additional connection options.</p>
    pub fn additional_options(
        &self,
    ) -> std::option::Option<&crate::model::S3DirectSourceAdditionalOptions> {
        self.additional_options.as_ref()
    }
    /// <p>Specifies the delimiter character. The default is a comma: ",", but any other character can be specified.</p>
    pub fn separator(&self) -> std::option::Option<&crate::model::Separator> {
        self.separator.as_ref()
    }
    /// <p>Specifies a character to use for escaping. This option is used only when reading CSV files. The default value is <code>none</code>. If enabled, the character which immediately follows is used as-is, except for a small set of well-known escapes (<code>\n</code>, <code>\r</code>, <code>\t</code>, and <code>\0</code>).</p>
    pub fn escaper(&self) -> std::option::Option<&str> {
        self.escaper.as_deref()
    }
    /// <p>Specifies the character to use for quoting. The default is a double quote: <code>'"'</code>. Set this to <code>-1</code> to turn off quoting entirely.</p>
    pub fn quote_char(&self) -> std::option::Option<&crate::model::QuoteChar> {
        self.quote_char.as_ref()
    }
    /// <p>A Boolean value that specifies whether a single record can span multiple lines. This can occur when a field contains a quoted new-line character. You must set this option to True if any record spans multiple lines. The default value is <code>False</code>, which allows for more aggressive file-splitting during parsing.</p>
    pub fn multiline(&self) -> std::option::Option<bool> {
        self.multiline
    }
    /// <p>A Boolean value that specifies whether to treat the first line as a header. The default value is <code>False</code>.</p>
    pub fn with_header(&self) -> std::option::Option<bool> {
        self.with_header
    }
    /// <p>A Boolean value that specifies whether to write the header to output. The default value is <code>True</code>. </p>
    pub fn write_header(&self) -> std::option::Option<bool> {
        self.write_header
    }
    /// <p>A Boolean value that specifies whether to skip the first data line. The default value is <code>False</code>.</p>
    pub fn skip_first(&self) -> std::option::Option<bool> {
        self.skip_first
    }
    /// <p>A Boolean value that specifies whether to use the advanced SIMD CSV reader along with Apache Arrow based columnar memory formats. Only available in Glue version 3.0.</p>
    pub fn optimize_performance(&self) -> bool {
        self.optimize_performance
    }
    /// <p>Specifies the data schema for the S3 CSV source.</p>
    pub fn output_schemas(&self) -> std::option::Option<&[crate::model::GlueSchema]> {
        self.output_schemas.as_deref()
    }
}
/// See [`S3CsvSource`](crate::model::S3CsvSource).
pub mod s3_csv_source {

    /// A builder for [`S3CsvSource`](crate::model::S3CsvSource).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) paths: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) compression_type: std::option::Option<crate::model::CompressionType>,
        pub(crate) exclusions: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) group_size: std::option::Option<std::string::String>,
        pub(crate) group_files: std::option::Option<std::string::String>,
        pub(crate) recurse: std::option::Option<bool>,
        pub(crate) max_band: std::option::Option<i32>,
        pub(crate) max_files_in_band: std::option::Option<i32>,
        pub(crate) additional_options:
            std::option::Option<crate::model::S3DirectSourceAdditionalOptions>,
        pub(crate) separator: std::option::Option<crate::model::Separator>,
        pub(crate) escaper: std::option::Option<std::string::String>,
        pub(crate) quote_char: std::option::Option<crate::model::QuoteChar>,
        pub(crate) multiline: std::option::Option<bool>,
        pub(crate) with_header: std::option::Option<bool>,
        pub(crate) write_header: std::option::Option<bool>,
        pub(crate) skip_first: std::option::Option<bool>,
        pub(crate) optimize_performance: std::option::Option<bool>,
        pub(crate) output_schemas: std::option::Option<std::vec::Vec<crate::model::GlueSchema>>,
    }
    impl Builder {
        /// <p>The name of the data store.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the data store.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Appends an item to `paths`.
        ///
        /// To override the contents of this collection use [`set_paths`](Self::set_paths).
        ///
        /// <p>A list of the Amazon S3 paths to read from.</p>
        pub fn paths(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.paths.unwrap_or_default();
            v.push(input.into());
            self.paths = Some(v);
            self
        }
        /// <p>A list of the Amazon S3 paths to read from.</p>
        pub fn set_paths(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.paths = input;
            self
        }
        /// <p>Specifies how the data is compressed. This is generally not necessary if the data has a standard file extension. Possible values are <code>"gzip"</code> and <code>"bzip"</code>).</p>
        pub fn compression_type(mut self, input: crate::model::CompressionType) -> Self {
            self.compression_type = Some(input);
            self
        }
        /// <p>Specifies how the data is compressed. This is generally not necessary if the data has a standard file extension. Possible values are <code>"gzip"</code> and <code>"bzip"</code>).</p>
        pub fn set_compression_type(
            mut self,
            input: std::option::Option<crate::model::CompressionType>,
        ) -> Self {
            self.compression_type = input;
            self
        }
        /// Appends an item to `exclusions`.
        ///
        /// To override the contents of this collection use [`set_exclusions`](Self::set_exclusions).
        ///
        /// <p>A string containing a JSON list of Unix-style glob patterns to exclude. For example, "[\"**.pdf\"]" excludes all PDF files. </p>
        pub fn exclusions(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.exclusions.unwrap_or_default();
            v.push(input.into());
            self.exclusions = Some(v);
            self
        }
        /// <p>A string containing a JSON list of Unix-style glob patterns to exclude. For example, "[\"**.pdf\"]" excludes all PDF files. </p>
        pub fn set_exclusions(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.exclusions = input;
            self
        }
        /// <p>The target group size in bytes. The default is computed based on the input data size and the size of your cluster. When there are fewer than 50,000 input files, <code>"groupFiles"</code> must be set to <code>"inPartition"</code> for this to take effect.</p>
        pub fn group_size(mut self, input: impl Into<std::string::String>) -> Self {
            self.group_size = Some(input.into());
            self
        }
        /// <p>The target group size in bytes. The default is computed based on the input data size and the size of your cluster. When there are fewer than 50,000 input files, <code>"groupFiles"</code> must be set to <code>"inPartition"</code> for this to take effect.</p>
        pub fn set_group_size(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.group_size = input;
            self
        }
        /// <p>Grouping files is turned on by default when the input contains more than 50,000 files. To turn on grouping with fewer than 50,000 files, set this parameter to "inPartition". To disable grouping when there are more than 50,000 files, set this parameter to <code>"none"</code>.</p>
        pub fn group_files(mut self, input: impl Into<std::string::String>) -> Self {
            self.group_files = Some(input.into());
            self
        }
        /// <p>Grouping files is turned on by default when the input contains more than 50,000 files. To turn on grouping with fewer than 50,000 files, set this parameter to "inPartition". To disable grouping when there are more than 50,000 files, set this parameter to <code>"none"</code>.</p>
        pub fn set_group_files(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.group_files = input;
            self
        }
        /// <p>If set to true, recursively reads files in all subdirectories under the specified paths.</p>
        pub fn recurse(mut self, input: bool) -> Self {
            self.recurse = Some(input);
            self
        }
        /// <p>If set to true, recursively reads files in all subdirectories under the specified paths.</p>
        pub fn set_recurse(mut self, input: std::option::Option<bool>) -> Self {
            self.recurse = input;
            self
        }
        /// <p>This option controls the duration in milliseconds after which the s3 listing is likely to be consistent. Files with modification timestamps falling within the last maxBand milliseconds are tracked specially when using JobBookmarks to account for Amazon S3 eventual consistency. Most users don't need to set this option. The default is 900000 milliseconds, or 15 minutes.</p>
        pub fn max_band(mut self, input: i32) -> Self {
            self.max_band = Some(input);
            self
        }
        /// <p>This option controls the duration in milliseconds after which the s3 listing is likely to be consistent. Files with modification timestamps falling within the last maxBand milliseconds are tracked specially when using JobBookmarks to account for Amazon S3 eventual consistency. Most users don't need to set this option. The default is 900000 milliseconds, or 15 minutes.</p>
        pub fn set_max_band(mut self, input: std::option::Option<i32>) -> Self {
            self.max_band = input;
            self
        }
        /// <p>This option specifies the maximum number of files to save from the last maxBand seconds. If this number is exceeded, extra files are skipped and only processed in the next job run.</p>
        pub fn max_files_in_band(mut self, input: i32) -> Self {
            self.max_files_in_band = Some(input);
            self
        }
        /// <p>This option specifies the maximum number of files to save from the last maxBand seconds. If this number is exceeded, extra files are skipped and only processed in the next job run.</p>
        pub fn set_max_files_in_band(mut self, input: std::option::Option<i32>) -> Self {
            self.max_files_in_band = input;
            self
        }
        /// <p>Specifies additional connection options.</p>
        pub fn additional_options(
            mut self,
            input: crate::model::S3DirectSourceAdditionalOptions,
        ) -> Self {
            self.additional_options = Some(input);
            self
        }
        /// <p>Specifies additional connection options.</p>
        pub fn set_additional_options(
            mut self,
            input: std::option::Option<crate::model::S3DirectSourceAdditionalOptions>,
        ) -> Self {
            self.additional_options = input;
            self
        }
        /// <p>Specifies the delimiter character. The default is a comma: ",", but any other character can be specified.</p>
        pub fn separator(mut self, input: crate::model::Separator) -> Self {
            self.separator = Some(input);
            self
        }
        /// <p>Specifies the delimiter character. The default is a comma: ",", but any other character can be specified.</p>
        pub fn set_separator(
            mut self,
            input: std::option::Option<crate::model::Separator>,
        ) -> Self {
            self.separator = input;
            self
        }
        /// <p>Specifies a character to use for escaping. This option is used only when reading CSV files. The default value is <code>none</code>. If enabled, the character which immediately follows is used as-is, except for a small set of well-known escapes (<code>\n</code>, <code>\r</code>, <code>\t</code>, and <code>\0</code>).</p>
        pub fn escaper(mut self, input: impl Into<std::string::String>) -> Self {
            self.escaper = Some(input.into());
            self
        }
        /// <p>Specifies a character to use for escaping. This option is used only when reading CSV files. The default value is <code>none</code>. If enabled, the character which immediately follows is used as-is, except for a small set of well-known escapes (<code>\n</code>, <code>\r</code>, <code>\t</code>, and <code>\0</code>).</p>
        pub fn set_escaper(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.escaper = input;
            self
        }
        /// <p>Specifies the character to use for quoting. The default is a double quote: <code>'"'</code>. Set this to <code>-1</code> to turn off quoting entirely.</p>
        pub fn quote_char(mut self, input: crate::model::QuoteChar) -> Self {
            self.quote_char = Some(input);
            self
        }
        /// <p>Specifies the character to use for quoting. The default is a double quote: <code>'"'</code>. Set this to <code>-1</code> to turn off quoting entirely.</p>
        pub fn set_quote_char(
            mut self,
            input: std::option::Option<crate::model::QuoteChar>,
        ) -> Self {
            self.quote_char = input;
            self
        }
        /// <p>A Boolean value that specifies whether a single record can span multiple lines. This can occur when a field contains a quoted new-line character. You must set this option to True if any record spans multiple lines. The default value is <code>False</code>, which allows for more aggressive file-splitting during parsing.</p>
        pub fn multiline(mut self, input: bool) -> Self {
            self.multiline = Some(input);
            self
        }
        /// <p>A Boolean value that specifies whether a single record can span multiple lines. This can occur when a field contains a quoted new-line character. You must set this option to True if any record spans multiple lines. The default value is <code>False</code>, which allows for more aggressive file-splitting during parsing.</p>
        pub fn set_multiline(mut self, input: std::option::Option<bool>) -> Self {
            self.multiline = input;
            self
        }
        /// <p>A Boolean value that specifies whether to treat the first line as a header. The default value is <code>False</code>.</p>
        pub fn with_header(mut self, input: bool) -> Self {
            self.with_header = Some(input);
            self
        }
        /// <p>A Boolean value that specifies whether to treat the first line as a header. The default value is <code>False</code>.</p>
        pub fn set_with_header(mut self, input: std::option::Option<bool>) -> Self {
            self.with_header = input;
            self
        }
        /// <p>A Boolean value that specifies whether to write the header to output. The default value is <code>True</code>. </p>
        pub fn write_header(mut self, input: bool) -> Self {
            self.write_header = Some(input);
            self
        }
        /// <p>A Boolean value that specifies whether to write the header to output. The default value is <code>True</code>. </p>
        pub fn set_write_header(mut self, input: std::option::Option<bool>) -> Self {
            self.write_header = input;
            self
        }
        /// <p>A Boolean value that specifies whether to skip the first data line. The default value is <code>False</code>.</p>
        pub fn skip_first(mut self, input: bool) -> Self {
            self.skip_first = Some(input);
            self
        }
        /// <p>A Boolean value that specifies whether to skip the first data line. The default value is <code>False</code>.</p>
        pub fn set_skip_first(mut self, input: std::option::Option<bool>) -> Self {
            self.skip_first = input;
            self
        }
        /// <p>A Boolean value that specifies whether to use the advanced SIMD CSV reader along with Apache Arrow based columnar memory formats. Only available in Glue version 3.0.</p>
        pub fn optimize_performance(mut self, input: bool) -> Self {
            self.optimize_performance = Some(input);
            self
        }
        /// <p>A Boolean value that specifies whether to use the advanced SIMD CSV reader along with Apache Arrow based columnar memory formats. Only available in Glue version 3.0.</p>
        pub fn set_optimize_performance(mut self, input: std::option::Option<bool>) -> Self {
            self.optimize_performance = input;
            self
        }
        /// Appends an item to `output_schemas`.
        ///
        /// To override the contents of this collection use [`set_output_schemas`](Self::set_output_schemas).
        ///
        /// <p>Specifies the data schema for the S3 CSV source.</p>
        pub fn output_schemas(mut self, input: crate::model::GlueSchema) -> Self {
            let mut v = self.output_schemas.unwrap_or_default();
            v.push(input);
            self.output_schemas = Some(v);
            self
        }
        /// <p>Specifies the data schema for the S3 CSV source.</p>
        pub fn set_output_schemas(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::GlueSchema>>,
        ) -> Self {
            self.output_schemas = input;
            self
        }
        /// Consumes the builder and constructs a [`S3CsvSource`](crate::model::S3CsvSource).
        pub fn build(self) -> crate::model::S3CsvSource {
            crate::model::S3CsvSource {
                name: self.name,
                paths: self.paths,
                compression_type: self.compression_type,
                exclusions: self.exclusions,
                group_size: self.group_size,
                group_files: self.group_files,
                recurse: self.recurse,
                max_band: self.max_band,
                max_files_in_band: self.max_files_in_band,
                additional_options: self.additional_options,
                separator: self.separator,
                escaper: self.escaper,
                quote_char: self.quote_char,
                multiline: self.multiline,
                with_header: self.with_header,
                write_header: self.write_header,
                skip_first: self.skip_first,
                optimize_performance: self.optimize_performance.unwrap_or_default(),
                output_schemas: self.output_schemas,
            }
        }
    }
}
impl S3CsvSource {
    /// Creates a new builder-style object to manufacture [`S3CsvSource`](crate::model::S3CsvSource).
    pub fn builder() -> crate::model::s3_csv_source::Builder {
        crate::model::s3_csv_source::Builder::default()
    }
}

/// When writing a match expression against `QuoteChar`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let quotechar = unimplemented!();
/// match quotechar {
///     QuoteChar::Disabled => { /* ... */ },
///     QuoteChar::Quillemet => { /* ... */ },
///     QuoteChar::Quote => { /* ... */ },
///     QuoteChar::SingleQuote => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `quotechar` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `QuoteChar::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `QuoteChar::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `QuoteChar::NewFeature` is defined.
/// Specifically, when `quotechar` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `QuoteChar::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum QuoteChar {
    #[allow(missing_docs)] // documentation missing in model
    Disabled,
    #[allow(missing_docs)] // documentation missing in model
    Quillemet,
    #[allow(missing_docs)] // documentation missing in model
    Quote,
    #[allow(missing_docs)] // documentation missing in model
    SingleQuote,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for QuoteChar {
    fn from(s: &str) -> Self {
        match s {
            "disabled" => QuoteChar::Disabled,
            "quillemet" => QuoteChar::Quillemet,
            "quote" => QuoteChar::Quote,
            "single_quote" => QuoteChar::SingleQuote,
            other => QuoteChar::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for QuoteChar {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(QuoteChar::from(s))
    }
}
impl QuoteChar {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            QuoteChar::Disabled => "disabled",
            QuoteChar::Quillemet => "quillemet",
            QuoteChar::Quote => "quote",
            QuoteChar::SingleQuote => "single_quote",
            QuoteChar::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["disabled", "quillemet", "quote", "single_quote"]
    }
}
impl AsRef<str> for QuoteChar {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `Separator`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let separator = unimplemented!();
/// match separator {
///     Separator::Comma => { /* ... */ },
///     Separator::Ctrla => { /* ... */ },
///     Separator::Pipe => { /* ... */ },
///     Separator::Semicolon => { /* ... */ },
///     Separator::Tab => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `separator` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `Separator::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `Separator::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `Separator::NewFeature` is defined.
/// Specifically, when `separator` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `Separator::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Separator {
    #[allow(missing_docs)] // documentation missing in model
    Comma,
    #[allow(missing_docs)] // documentation missing in model
    Ctrla,
    #[allow(missing_docs)] // documentation missing in model
    Pipe,
    #[allow(missing_docs)] // documentation missing in model
    Semicolon,
    #[allow(missing_docs)] // documentation missing in model
    Tab,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for Separator {
    fn from(s: &str) -> Self {
        match s {
            "comma" => Separator::Comma,
            "ctrla" => Separator::Ctrla,
            "pipe" => Separator::Pipe,
            "semicolon" => Separator::Semicolon,
            "tab" => Separator::Tab,
            other => Separator::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for Separator {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(Separator::from(s))
    }
}
impl Separator {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            Separator::Comma => "comma",
            Separator::Ctrla => "ctrla",
            Separator::Pipe => "pipe",
            Separator::Semicolon => "semicolon",
            Separator::Tab => "tab",
            Separator::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["comma", "ctrla", "pipe", "semicolon", "tab"]
    }
}
impl AsRef<str> for Separator {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Specifies an Amazon S3 data store in the Glue Data Catalog.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct S3CatalogSource {
    /// <p>The name of the data store.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The database to read from.</p>
    #[doc(hidden)]
    pub database: std::option::Option<std::string::String>,
    /// <p>The database table to read from.</p>
    #[doc(hidden)]
    pub table: std::option::Option<std::string::String>,
    /// <p>Partitions satisfying this predicate are deleted. Files within the retention period in these partitions are not deleted. Set to <code>""</code> – empty by default.</p>
    #[doc(hidden)]
    pub partition_predicate: std::option::Option<std::string::String>,
    /// <p>Specifies additional connection options.</p>
    #[doc(hidden)]
    pub additional_options: std::option::Option<crate::model::S3SourceAdditionalOptions>,
}
impl S3CatalogSource {
    /// <p>The name of the data store.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The database to read from.</p>
    pub fn database(&self) -> std::option::Option<&str> {
        self.database.as_deref()
    }
    /// <p>The database table to read from.</p>
    pub fn table(&self) -> std::option::Option<&str> {
        self.table.as_deref()
    }
    /// <p>Partitions satisfying this predicate are deleted. Files within the retention period in these partitions are not deleted. Set to <code>""</code> – empty by default.</p>
    pub fn partition_predicate(&self) -> std::option::Option<&str> {
        self.partition_predicate.as_deref()
    }
    /// <p>Specifies additional connection options.</p>
    pub fn additional_options(
        &self,
    ) -> std::option::Option<&crate::model::S3SourceAdditionalOptions> {
        self.additional_options.as_ref()
    }
}
/// See [`S3CatalogSource`](crate::model::S3CatalogSource).
pub mod s3_catalog_source {

    /// A builder for [`S3CatalogSource`](crate::model::S3CatalogSource).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) database: std::option::Option<std::string::String>,
        pub(crate) table: std::option::Option<std::string::String>,
        pub(crate) partition_predicate: std::option::Option<std::string::String>,
        pub(crate) additional_options: std::option::Option<crate::model::S3SourceAdditionalOptions>,
    }
    impl Builder {
        /// <p>The name of the data store.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the data store.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The database to read from.</p>
        pub fn database(mut self, input: impl Into<std::string::String>) -> Self {
            self.database = Some(input.into());
            self
        }
        /// <p>The database to read from.</p>
        pub fn set_database(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.database = input;
            self
        }
        /// <p>The database table to read from.</p>
        pub fn table(mut self, input: impl Into<std::string::String>) -> Self {
            self.table = Some(input.into());
            self
        }
        /// <p>The database table to read from.</p>
        pub fn set_table(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.table = input;
            self
        }
        /// <p>Partitions satisfying this predicate are deleted. Files within the retention period in these partitions are not deleted. Set to <code>""</code> – empty by default.</p>
        pub fn partition_predicate(mut self, input: impl Into<std::string::String>) -> Self {
            self.partition_predicate = Some(input.into());
            self
        }
        /// <p>Partitions satisfying this predicate are deleted. Files within the retention period in these partitions are not deleted. Set to <code>""</code> – empty by default.</p>
        pub fn set_partition_predicate(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.partition_predicate = input;
            self
        }
        /// <p>Specifies additional connection options.</p>
        pub fn additional_options(
            mut self,
            input: crate::model::S3SourceAdditionalOptions,
        ) -> Self {
            self.additional_options = Some(input);
            self
        }
        /// <p>Specifies additional connection options.</p>
        pub fn set_additional_options(
            mut self,
            input: std::option::Option<crate::model::S3SourceAdditionalOptions>,
        ) -> Self {
            self.additional_options = input;
            self
        }
        /// Consumes the builder and constructs a [`S3CatalogSource`](crate::model::S3CatalogSource).
        pub fn build(self) -> crate::model::S3CatalogSource {
            crate::model::S3CatalogSource {
                name: self.name,
                database: self.database,
                table: self.table,
                partition_predicate: self.partition_predicate,
                additional_options: self.additional_options,
            }
        }
    }
}
impl S3CatalogSource {
    /// Creates a new builder-style object to manufacture [`S3CatalogSource`](crate::model::S3CatalogSource).
    pub fn builder() -> crate::model::s3_catalog_source::Builder {
        crate::model::s3_catalog_source::Builder::default()
    }
}

/// <p>Specifies an Amazon Redshift data store.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RedshiftSource {
    /// <p>The name of the Amazon Redshift data store.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The database to read from.</p>
    #[doc(hidden)]
    pub database: std::option::Option<std::string::String>,
    /// <p>The database table to read from.</p>
    #[doc(hidden)]
    pub table: std::option::Option<std::string::String>,
    /// <p>The Amazon S3 path where temporary data can be staged when copying out of the database.</p>
    #[doc(hidden)]
    pub redshift_tmp_dir: std::option::Option<std::string::String>,
    /// <p>The IAM role with permissions.</p>
    #[doc(hidden)]
    pub tmp_dir_iam_role: std::option::Option<std::string::String>,
}
impl RedshiftSource {
    /// <p>The name of the Amazon Redshift data store.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The database to read from.</p>
    pub fn database(&self) -> std::option::Option<&str> {
        self.database.as_deref()
    }
    /// <p>The database table to read from.</p>
    pub fn table(&self) -> std::option::Option<&str> {
        self.table.as_deref()
    }
    /// <p>The Amazon S3 path where temporary data can be staged when copying out of the database.</p>
    pub fn redshift_tmp_dir(&self) -> std::option::Option<&str> {
        self.redshift_tmp_dir.as_deref()
    }
    /// <p>The IAM role with permissions.</p>
    pub fn tmp_dir_iam_role(&self) -> std::option::Option<&str> {
        self.tmp_dir_iam_role.as_deref()
    }
}
/// See [`RedshiftSource`](crate::model::RedshiftSource).
pub mod redshift_source {

    /// A builder for [`RedshiftSource`](crate::model::RedshiftSource).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) database: std::option::Option<std::string::String>,
        pub(crate) table: std::option::Option<std::string::String>,
        pub(crate) redshift_tmp_dir: std::option::Option<std::string::String>,
        pub(crate) tmp_dir_iam_role: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the Amazon Redshift data store.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the Amazon Redshift data store.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The database to read from.</p>
        pub fn database(mut self, input: impl Into<std::string::String>) -> Self {
            self.database = Some(input.into());
            self
        }
        /// <p>The database to read from.</p>
        pub fn set_database(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.database = input;
            self
        }
        /// <p>The database table to read from.</p>
        pub fn table(mut self, input: impl Into<std::string::String>) -> Self {
            self.table = Some(input.into());
            self
        }
        /// <p>The database table to read from.</p>
        pub fn set_table(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.table = input;
            self
        }
        /// <p>The Amazon S3 path where temporary data can be staged when copying out of the database.</p>
        pub fn redshift_tmp_dir(mut self, input: impl Into<std::string::String>) -> Self {
            self.redshift_tmp_dir = Some(input.into());
            self
        }
        /// <p>The Amazon S3 path where temporary data can be staged when copying out of the database.</p>
        pub fn set_redshift_tmp_dir(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.redshift_tmp_dir = input;
            self
        }
        /// <p>The IAM role with permissions.</p>
        pub fn tmp_dir_iam_role(mut self, input: impl Into<std::string::String>) -> Self {
            self.tmp_dir_iam_role = Some(input.into());
            self
        }
        /// <p>The IAM role with permissions.</p>
        pub fn set_tmp_dir_iam_role(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.tmp_dir_iam_role = input;
            self
        }
        /// Consumes the builder and constructs a [`RedshiftSource`](crate::model::RedshiftSource).
        pub fn build(self) -> crate::model::RedshiftSource {
            crate::model::RedshiftSource {
                name: self.name,
                database: self.database,
                table: self.table,
                redshift_tmp_dir: self.redshift_tmp_dir,
                tmp_dir_iam_role: self.tmp_dir_iam_role,
            }
        }
    }
}
impl RedshiftSource {
    /// Creates a new builder-style object to manufacture [`RedshiftSource`](crate::model::RedshiftSource).
    pub fn builder() -> crate::model::redshift_source::Builder {
        crate::model::redshift_source::Builder::default()
    }
}

/// <p>Specifies a data store in the Glue Data Catalog.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CatalogSource {
    /// <p>The name of the data store.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The name of the database to read from.</p>
    #[doc(hidden)]
    pub database: std::option::Option<std::string::String>,
    /// <p>The name of the table in the database to read from.</p>
    #[doc(hidden)]
    pub table: std::option::Option<std::string::String>,
}
impl CatalogSource {
    /// <p>The name of the data store.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The name of the database to read from.</p>
    pub fn database(&self) -> std::option::Option<&str> {
        self.database.as_deref()
    }
    /// <p>The name of the table in the database to read from.</p>
    pub fn table(&self) -> std::option::Option<&str> {
        self.table.as_deref()
    }
}
/// See [`CatalogSource`](crate::model::CatalogSource).
pub mod catalog_source {

    /// A builder for [`CatalogSource`](crate::model::CatalogSource).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) database: std::option::Option<std::string::String>,
        pub(crate) table: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the data store.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the data store.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The name of the database to read from.</p>
        pub fn database(mut self, input: impl Into<std::string::String>) -> Self {
            self.database = Some(input.into());
            self
        }
        /// <p>The name of the database to read from.</p>
        pub fn set_database(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.database = input;
            self
        }
        /// <p>The name of the table in the database to read from.</p>
        pub fn table(mut self, input: impl Into<std::string::String>) -> Self {
            self.table = Some(input.into());
            self
        }
        /// <p>The name of the table in the database to read from.</p>
        pub fn set_table(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.table = input;
            self
        }
        /// Consumes the builder and constructs a [`CatalogSource`](crate::model::CatalogSource).
        pub fn build(self) -> crate::model::CatalogSource {
            crate::model::CatalogSource {
                name: self.name,
                database: self.database,
                table: self.table,
            }
        }
    }
}
impl CatalogSource {
    /// Creates a new builder-style object to manufacture [`CatalogSource`](crate::model::CatalogSource).
    pub fn builder() -> crate::model::catalog_source::Builder {
        crate::model::catalog_source::Builder::default()
    }
}

/// <p>Specifies a connector to an Apache Spark data source.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SparkConnectorSource {
    /// <p>The name of the data source.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The name of the connection that is associated with the connector.</p>
    #[doc(hidden)]
    pub connection_name: std::option::Option<std::string::String>,
    /// <p>The name of a connector that assists with accessing the data store in Glue Studio.</p>
    #[doc(hidden)]
    pub connector_name: std::option::Option<std::string::String>,
    /// <p>The type of connection, such as marketplace.spark or custom.spark, designating a connection to an Apache Spark data store.</p>
    #[doc(hidden)]
    pub connection_type: std::option::Option<std::string::String>,
    /// <p>Additional connection options for the connector.</p>
    #[doc(hidden)]
    pub additional_options:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>Specifies data schema for the custom spark source.</p>
    #[doc(hidden)]
    pub output_schemas: std::option::Option<std::vec::Vec<crate::model::GlueSchema>>,
}
impl SparkConnectorSource {
    /// <p>The name of the data source.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The name of the connection that is associated with the connector.</p>
    pub fn connection_name(&self) -> std::option::Option<&str> {
        self.connection_name.as_deref()
    }
    /// <p>The name of a connector that assists with accessing the data store in Glue Studio.</p>
    pub fn connector_name(&self) -> std::option::Option<&str> {
        self.connector_name.as_deref()
    }
    /// <p>The type of connection, such as marketplace.spark or custom.spark, designating a connection to an Apache Spark data store.</p>
    pub fn connection_type(&self) -> std::option::Option<&str> {
        self.connection_type.as_deref()
    }
    /// <p>Additional connection options for the connector.</p>
    pub fn additional_options(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.additional_options.as_ref()
    }
    /// <p>Specifies data schema for the custom spark source.</p>
    pub fn output_schemas(&self) -> std::option::Option<&[crate::model::GlueSchema]> {
        self.output_schemas.as_deref()
    }
}
/// See [`SparkConnectorSource`](crate::model::SparkConnectorSource).
pub mod spark_connector_source {

    /// A builder for [`SparkConnectorSource`](crate::model::SparkConnectorSource).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) connection_name: std::option::Option<std::string::String>,
        pub(crate) connector_name: std::option::Option<std::string::String>,
        pub(crate) connection_type: std::option::Option<std::string::String>,
        pub(crate) additional_options: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) output_schemas: std::option::Option<std::vec::Vec<crate::model::GlueSchema>>,
    }
    impl Builder {
        /// <p>The name of the data source.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the data source.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The name of the connection that is associated with the connector.</p>
        pub fn connection_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.connection_name = Some(input.into());
            self
        }
        /// <p>The name of the connection that is associated with the connector.</p>
        pub fn set_connection_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.connection_name = input;
            self
        }
        /// <p>The name of a connector that assists with accessing the data store in Glue Studio.</p>
        pub fn connector_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.connector_name = Some(input.into());
            self
        }
        /// <p>The name of a connector that assists with accessing the data store in Glue Studio.</p>
        pub fn set_connector_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.connector_name = input;
            self
        }
        /// <p>The type of connection, such as marketplace.spark or custom.spark, designating a connection to an Apache Spark data store.</p>
        pub fn connection_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.connection_type = Some(input.into());
            self
        }
        /// <p>The type of connection, such as marketplace.spark or custom.spark, designating a connection to an Apache Spark data store.</p>
        pub fn set_connection_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.connection_type = input;
            self
        }
        /// Adds a key-value pair to `additional_options`.
        ///
        /// To override the contents of this collection use [`set_additional_options`](Self::set_additional_options).
        ///
        /// <p>Additional connection options for the connector.</p>
        pub fn additional_options(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.additional_options.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.additional_options = Some(hash_map);
            self
        }
        /// <p>Additional connection options for the connector.</p>
        pub fn set_additional_options(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.additional_options = input;
            self
        }
        /// Appends an item to `output_schemas`.
        ///
        /// To override the contents of this collection use [`set_output_schemas`](Self::set_output_schemas).
        ///
        /// <p>Specifies data schema for the custom spark source.</p>
        pub fn output_schemas(mut self, input: crate::model::GlueSchema) -> Self {
            let mut v = self.output_schemas.unwrap_or_default();
            v.push(input);
            self.output_schemas = Some(v);
            self
        }
        /// <p>Specifies data schema for the custom spark source.</p>
        pub fn set_output_schemas(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::GlueSchema>>,
        ) -> Self {
            self.output_schemas = input;
            self
        }
        /// Consumes the builder and constructs a [`SparkConnectorSource`](crate::model::SparkConnectorSource).
        pub fn build(self) -> crate::model::SparkConnectorSource {
            crate::model::SparkConnectorSource {
                name: self.name,
                connection_name: self.connection_name,
                connector_name: self.connector_name,
                connection_type: self.connection_type,
                additional_options: self.additional_options,
                output_schemas: self.output_schemas,
            }
        }
    }
}
impl SparkConnectorSource {
    /// Creates a new builder-style object to manufacture [`SparkConnectorSource`](crate::model::SparkConnectorSource).
    pub fn builder() -> crate::model::spark_connector_source::Builder {
        crate::model::spark_connector_source::Builder::default()
    }
}

/// <p>Specifies a connector to a JDBC data source.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct JdbcConnectorSource {
    /// <p>The name of the data source.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The name of the connection that is associated with the connector.</p>
    #[doc(hidden)]
    pub connection_name: std::option::Option<std::string::String>,
    /// <p>The name of a connector that assists with accessing the data store in Glue Studio.</p>
    #[doc(hidden)]
    pub connector_name: std::option::Option<std::string::String>,
    /// <p>The type of connection, such as marketplace.jdbc or custom.jdbc, designating a connection to a JDBC data store.</p>
    #[doc(hidden)]
    pub connection_type: std::option::Option<std::string::String>,
    /// <p>Additional connection options for the connector.</p>
    #[doc(hidden)]
    pub additional_options: std::option::Option<crate::model::JdbcConnectorOptions>,
    /// <p>The name of the table in the data source.</p>
    #[doc(hidden)]
    pub connection_table: std::option::Option<std::string::String>,
    /// <p>The table or SQL query to get the data from. You can specify either <code>ConnectionTable</code> or <code>query</code>, but not both.</p>
    #[doc(hidden)]
    pub query: std::option::Option<std::string::String>,
    /// <p>Specifies the data schema for the custom JDBC source.</p>
    #[doc(hidden)]
    pub output_schemas: std::option::Option<std::vec::Vec<crate::model::GlueSchema>>,
}
impl JdbcConnectorSource {
    /// <p>The name of the data source.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The name of the connection that is associated with the connector.</p>
    pub fn connection_name(&self) -> std::option::Option<&str> {
        self.connection_name.as_deref()
    }
    /// <p>The name of a connector that assists with accessing the data store in Glue Studio.</p>
    pub fn connector_name(&self) -> std::option::Option<&str> {
        self.connector_name.as_deref()
    }
    /// <p>The type of connection, such as marketplace.jdbc or custom.jdbc, designating a connection to a JDBC data store.</p>
    pub fn connection_type(&self) -> std::option::Option<&str> {
        self.connection_type.as_deref()
    }
    /// <p>Additional connection options for the connector.</p>
    pub fn additional_options(&self) -> std::option::Option<&crate::model::JdbcConnectorOptions> {
        self.additional_options.as_ref()
    }
    /// <p>The name of the table in the data source.</p>
    pub fn connection_table(&self) -> std::option::Option<&str> {
        self.connection_table.as_deref()
    }
    /// <p>The table or SQL query to get the data from. You can specify either <code>ConnectionTable</code> or <code>query</code>, but not both.</p>
    pub fn query(&self) -> std::option::Option<&str> {
        self.query.as_deref()
    }
    /// <p>Specifies the data schema for the custom JDBC source.</p>
    pub fn output_schemas(&self) -> std::option::Option<&[crate::model::GlueSchema]> {
        self.output_schemas.as_deref()
    }
}
/// See [`JdbcConnectorSource`](crate::model::JdbcConnectorSource).
pub mod jdbc_connector_source {

    /// A builder for [`JdbcConnectorSource`](crate::model::JdbcConnectorSource).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) connection_name: std::option::Option<std::string::String>,
        pub(crate) connector_name: std::option::Option<std::string::String>,
        pub(crate) connection_type: std::option::Option<std::string::String>,
        pub(crate) additional_options: std::option::Option<crate::model::JdbcConnectorOptions>,
        pub(crate) connection_table: std::option::Option<std::string::String>,
        pub(crate) query: std::option::Option<std::string::String>,
        pub(crate) output_schemas: std::option::Option<std::vec::Vec<crate::model::GlueSchema>>,
    }
    impl Builder {
        /// <p>The name of the data source.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the data source.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The name of the connection that is associated with the connector.</p>
        pub fn connection_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.connection_name = Some(input.into());
            self
        }
        /// <p>The name of the connection that is associated with the connector.</p>
        pub fn set_connection_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.connection_name = input;
            self
        }
        /// <p>The name of a connector that assists with accessing the data store in Glue Studio.</p>
        pub fn connector_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.connector_name = Some(input.into());
            self
        }
        /// <p>The name of a connector that assists with accessing the data store in Glue Studio.</p>
        pub fn set_connector_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.connector_name = input;
            self
        }
        /// <p>The type of connection, such as marketplace.jdbc or custom.jdbc, designating a connection to a JDBC data store.</p>
        pub fn connection_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.connection_type = Some(input.into());
            self
        }
        /// <p>The type of connection, such as marketplace.jdbc or custom.jdbc, designating a connection to a JDBC data store.</p>
        pub fn set_connection_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.connection_type = input;
            self
        }
        /// <p>Additional connection options for the connector.</p>
        pub fn additional_options(mut self, input: crate::model::JdbcConnectorOptions) -> Self {
            self.additional_options = Some(input);
            self
        }
        /// <p>Additional connection options for the connector.</p>
        pub fn set_additional_options(
            mut self,
            input: std::option::Option<crate::model::JdbcConnectorOptions>,
        ) -> Self {
            self.additional_options = input;
            self
        }
        /// <p>The name of the table in the data source.</p>
        pub fn connection_table(mut self, input: impl Into<std::string::String>) -> Self {
            self.connection_table = Some(input.into());
            self
        }
        /// <p>The name of the table in the data source.</p>
        pub fn set_connection_table(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.connection_table = input;
            self
        }
        /// <p>The table or SQL query to get the data from. You can specify either <code>ConnectionTable</code> or <code>query</code>, but not both.</p>
        pub fn query(mut self, input: impl Into<std::string::String>) -> Self {
            self.query = Some(input.into());
            self
        }
        /// <p>The table or SQL query to get the data from. You can specify either <code>ConnectionTable</code> or <code>query</code>, but not both.</p>
        pub fn set_query(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.query = input;
            self
        }
        /// Appends an item to `output_schemas`.
        ///
        /// To override the contents of this collection use [`set_output_schemas`](Self::set_output_schemas).
        ///
        /// <p>Specifies the data schema for the custom JDBC source.</p>
        pub fn output_schemas(mut self, input: crate::model::GlueSchema) -> Self {
            let mut v = self.output_schemas.unwrap_or_default();
            v.push(input);
            self.output_schemas = Some(v);
            self
        }
        /// <p>Specifies the data schema for the custom JDBC source.</p>
        pub fn set_output_schemas(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::GlueSchema>>,
        ) -> Self {
            self.output_schemas = input;
            self
        }
        /// Consumes the builder and constructs a [`JdbcConnectorSource`](crate::model::JdbcConnectorSource).
        pub fn build(self) -> crate::model::JdbcConnectorSource {
            crate::model::JdbcConnectorSource {
                name: self.name,
                connection_name: self.connection_name,
                connector_name: self.connector_name,
                connection_type: self.connection_type,
                additional_options: self.additional_options,
                connection_table: self.connection_table,
                query: self.query,
                output_schemas: self.output_schemas,
            }
        }
    }
}
impl JdbcConnectorSource {
    /// Creates a new builder-style object to manufacture [`JdbcConnectorSource`](crate::model::JdbcConnectorSource).
    pub fn builder() -> crate::model::jdbc_connector_source::Builder {
        crate::model::jdbc_connector_source::Builder::default()
    }
}

/// <p>Additional connection options for the connector.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct JdbcConnectorOptions {
    /// <p>Extra condition clause to filter data from source. For example:</p>
    /// <p> <code>BillingCity='Mountain View'</code> </p>
    /// <p>When using a query instead of a table name, you should validate that the query works with the specified <code>filterPredicate</code>.</p>
    #[doc(hidden)]
    pub filter_predicate: std::option::Option<std::string::String>,
    /// <p>The name of an integer column that is used for partitioning. This option works only when it's included with <code>lowerBound</code>, <code>upperBound</code>, and <code>numPartitions</code>. This option works the same way as in the Spark SQL JDBC reader.</p>
    #[doc(hidden)]
    pub partition_column: std::option::Option<std::string::String>,
    /// <p>The minimum value of <code>partitionColumn</code> that is used to decide partition stride.</p>
    #[doc(hidden)]
    pub lower_bound: std::option::Option<i64>,
    /// <p>The maximum value of <code>partitionColumn</code> that is used to decide partition stride.</p>
    #[doc(hidden)]
    pub upper_bound: std::option::Option<i64>,
    /// <p>The number of partitions. This value, along with <code>lowerBound</code> (inclusive) and <code>upperBound</code> (exclusive), form partition strides for generated <code>WHERE</code> clause expressions that are used to split the <code>partitionColumn</code>.</p>
    #[doc(hidden)]
    pub num_partitions: std::option::Option<i64>,
    /// <p>The name of the job bookmark keys on which to sort.</p>
    #[doc(hidden)]
    pub job_bookmark_keys: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Specifies an ascending or descending sort order.</p>
    #[doc(hidden)]
    pub job_bookmark_keys_sort_order: std::option::Option<std::string::String>,
    /// <p>Custom data type mapping that builds a mapping from a JDBC data type to an Glue data type. For example, the option <code>"dataTypeMapping":{"FLOAT":"STRING"}</code> maps data fields of JDBC type <code>FLOAT</code> into the Java <code>String</code> type by calling the <code>ResultSet.getString()</code> method of the driver, and uses it to build the Glue record. The <code>ResultSet</code> object is implemented by each driver, so the behavior is specific to the driver you use. Refer to the documentation for your JDBC driver to understand how the driver performs the conversions.</p>
    #[doc(hidden)]
    pub data_type_mapping: std::option::Option<
        std::collections::HashMap<crate::model::JdbcDataType, crate::model::GlueRecordType>,
    >,
}
impl JdbcConnectorOptions {
    /// <p>Extra condition clause to filter data from source. For example:</p>
    /// <p> <code>BillingCity='Mountain View'</code> </p>
    /// <p>When using a query instead of a table name, you should validate that the query works with the specified <code>filterPredicate</code>.</p>
    pub fn filter_predicate(&self) -> std::option::Option<&str> {
        self.filter_predicate.as_deref()
    }
    /// <p>The name of an integer column that is used for partitioning. This option works only when it's included with <code>lowerBound</code>, <code>upperBound</code>, and <code>numPartitions</code>. This option works the same way as in the Spark SQL JDBC reader.</p>
    pub fn partition_column(&self) -> std::option::Option<&str> {
        self.partition_column.as_deref()
    }
    /// <p>The minimum value of <code>partitionColumn</code> that is used to decide partition stride.</p>
    pub fn lower_bound(&self) -> std::option::Option<i64> {
        self.lower_bound
    }
    /// <p>The maximum value of <code>partitionColumn</code> that is used to decide partition stride.</p>
    pub fn upper_bound(&self) -> std::option::Option<i64> {
        self.upper_bound
    }
    /// <p>The number of partitions. This value, along with <code>lowerBound</code> (inclusive) and <code>upperBound</code> (exclusive), form partition strides for generated <code>WHERE</code> clause expressions that are used to split the <code>partitionColumn</code>.</p>
    pub fn num_partitions(&self) -> std::option::Option<i64> {
        self.num_partitions
    }
    /// <p>The name of the job bookmark keys on which to sort.</p>
    pub fn job_bookmark_keys(&self) -> std::option::Option<&[std::string::String]> {
        self.job_bookmark_keys.as_deref()
    }
    /// <p>Specifies an ascending or descending sort order.</p>
    pub fn job_bookmark_keys_sort_order(&self) -> std::option::Option<&str> {
        self.job_bookmark_keys_sort_order.as_deref()
    }
    /// <p>Custom data type mapping that builds a mapping from a JDBC data type to an Glue data type. For example, the option <code>"dataTypeMapping":{"FLOAT":"STRING"}</code> maps data fields of JDBC type <code>FLOAT</code> into the Java <code>String</code> type by calling the <code>ResultSet.getString()</code> method of the driver, and uses it to build the Glue record. The <code>ResultSet</code> object is implemented by each driver, so the behavior is specific to the driver you use. Refer to the documentation for your JDBC driver to understand how the driver performs the conversions.</p>
    pub fn data_type_mapping(
        &self,
    ) -> std::option::Option<
        &std::collections::HashMap<crate::model::JdbcDataType, crate::model::GlueRecordType>,
    > {
        self.data_type_mapping.as_ref()
    }
}
/// See [`JdbcConnectorOptions`](crate::model::JdbcConnectorOptions).
pub mod jdbc_connector_options {

    /// A builder for [`JdbcConnectorOptions`](crate::model::JdbcConnectorOptions).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) filter_predicate: std::option::Option<std::string::String>,
        pub(crate) partition_column: std::option::Option<std::string::String>,
        pub(crate) lower_bound: std::option::Option<i64>,
        pub(crate) upper_bound: std::option::Option<i64>,
        pub(crate) num_partitions: std::option::Option<i64>,
        pub(crate) job_bookmark_keys: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) job_bookmark_keys_sort_order: std::option::Option<std::string::String>,
        pub(crate) data_type_mapping: std::option::Option<
            std::collections::HashMap<crate::model::JdbcDataType, crate::model::GlueRecordType>,
        >,
    }
    impl Builder {
        /// <p>Extra condition clause to filter data from source. For example:</p>
        /// <p> <code>BillingCity='Mountain View'</code> </p>
        /// <p>When using a query instead of a table name, you should validate that the query works with the specified <code>filterPredicate</code>.</p>
        pub fn filter_predicate(mut self, input: impl Into<std::string::String>) -> Self {
            self.filter_predicate = Some(input.into());
            self
        }
        /// <p>Extra condition clause to filter data from source. For example:</p>
        /// <p> <code>BillingCity='Mountain View'</code> </p>
        /// <p>When using a query instead of a table name, you should validate that the query works with the specified <code>filterPredicate</code>.</p>
        pub fn set_filter_predicate(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.filter_predicate = input;
            self
        }
        /// <p>The name of an integer column that is used for partitioning. This option works only when it's included with <code>lowerBound</code>, <code>upperBound</code>, and <code>numPartitions</code>. This option works the same way as in the Spark SQL JDBC reader.</p>
        pub fn partition_column(mut self, input: impl Into<std::string::String>) -> Self {
            self.partition_column = Some(input.into());
            self
        }
        /// <p>The name of an integer column that is used for partitioning. This option works only when it's included with <code>lowerBound</code>, <code>upperBound</code>, and <code>numPartitions</code>. This option works the same way as in the Spark SQL JDBC reader.</p>
        pub fn set_partition_column(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.partition_column = input;
            self
        }
        /// <p>The minimum value of <code>partitionColumn</code> that is used to decide partition stride.</p>
        pub fn lower_bound(mut self, input: i64) -> Self {
            self.lower_bound = Some(input);
            self
        }
        /// <p>The minimum value of <code>partitionColumn</code> that is used to decide partition stride.</p>
        pub fn set_lower_bound(mut self, input: std::option::Option<i64>) -> Self {
            self.lower_bound = input;
            self
        }
        /// <p>The maximum value of <code>partitionColumn</code> that is used to decide partition stride.</p>
        pub fn upper_bound(mut self, input: i64) -> Self {
            self.upper_bound = Some(input);
            self
        }
        /// <p>The maximum value of <code>partitionColumn</code> that is used to decide partition stride.</p>
        pub fn set_upper_bound(mut self, input: std::option::Option<i64>) -> Self {
            self.upper_bound = input;
            self
        }
        /// <p>The number of partitions. This value, along with <code>lowerBound</code> (inclusive) and <code>upperBound</code> (exclusive), form partition strides for generated <code>WHERE</code> clause expressions that are used to split the <code>partitionColumn</code>.</p>
        pub fn num_partitions(mut self, input: i64) -> Self {
            self.num_partitions = Some(input);
            self
        }
        /// <p>The number of partitions. This value, along with <code>lowerBound</code> (inclusive) and <code>upperBound</code> (exclusive), form partition strides for generated <code>WHERE</code> clause expressions that are used to split the <code>partitionColumn</code>.</p>
        pub fn set_num_partitions(mut self, input: std::option::Option<i64>) -> Self {
            self.num_partitions = input;
            self
        }
        /// Appends an item to `job_bookmark_keys`.
        ///
        /// To override the contents of this collection use [`set_job_bookmark_keys`](Self::set_job_bookmark_keys).
        ///
        /// <p>The name of the job bookmark keys on which to sort.</p>
        pub fn job_bookmark_keys(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.job_bookmark_keys.unwrap_or_default();
            v.push(input.into());
            self.job_bookmark_keys = Some(v);
            self
        }
        /// <p>The name of the job bookmark keys on which to sort.</p>
        pub fn set_job_bookmark_keys(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.job_bookmark_keys = input;
            self
        }
        /// <p>Specifies an ascending or descending sort order.</p>
        pub fn job_bookmark_keys_sort_order(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.job_bookmark_keys_sort_order = Some(input.into());
            self
        }
        /// <p>Specifies an ascending or descending sort order.</p>
        pub fn set_job_bookmark_keys_sort_order(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.job_bookmark_keys_sort_order = input;
            self
        }
        /// Adds a key-value pair to `data_type_mapping`.
        ///
        /// To override the contents of this collection use [`set_data_type_mapping`](Self::set_data_type_mapping).
        ///
        /// <p>Custom data type mapping that builds a mapping from a JDBC data type to an Glue data type. For example, the option <code>"dataTypeMapping":{"FLOAT":"STRING"}</code> maps data fields of JDBC type <code>FLOAT</code> into the Java <code>String</code> type by calling the <code>ResultSet.getString()</code> method of the driver, and uses it to build the Glue record. The <code>ResultSet</code> object is implemented by each driver, so the behavior is specific to the driver you use. Refer to the documentation for your JDBC driver to understand how the driver performs the conversions.</p>
        pub fn data_type_mapping(
            mut self,
            k: crate::model::JdbcDataType,
            v: crate::model::GlueRecordType,
        ) -> Self {
            let mut hash_map = self.data_type_mapping.unwrap_or_default();
            hash_map.insert(k, v);
            self.data_type_mapping = Some(hash_map);
            self
        }
        /// <p>Custom data type mapping that builds a mapping from a JDBC data type to an Glue data type. For example, the option <code>"dataTypeMapping":{"FLOAT":"STRING"}</code> maps data fields of JDBC type <code>FLOAT</code> into the Java <code>String</code> type by calling the <code>ResultSet.getString()</code> method of the driver, and uses it to build the Glue record. The <code>ResultSet</code> object is implemented by each driver, so the behavior is specific to the driver you use. Refer to the documentation for your JDBC driver to understand how the driver performs the conversions.</p>
        pub fn set_data_type_mapping(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<crate::model::JdbcDataType, crate::model::GlueRecordType>,
            >,
        ) -> Self {
            self.data_type_mapping = input;
            self
        }
        /// Consumes the builder and constructs a [`JdbcConnectorOptions`](crate::model::JdbcConnectorOptions).
        pub fn build(self) -> crate::model::JdbcConnectorOptions {
            crate::model::JdbcConnectorOptions {
                filter_predicate: self.filter_predicate,
                partition_column: self.partition_column,
                lower_bound: self.lower_bound,
                upper_bound: self.upper_bound,
                num_partitions: self.num_partitions,
                job_bookmark_keys: self.job_bookmark_keys,
                job_bookmark_keys_sort_order: self.job_bookmark_keys_sort_order,
                data_type_mapping: self.data_type_mapping,
            }
        }
    }
}
impl JdbcConnectorOptions {
    /// Creates a new builder-style object to manufacture [`JdbcConnectorOptions`](crate::model::JdbcConnectorOptions).
    pub fn builder() -> crate::model::jdbc_connector_options::Builder {
        crate::model::jdbc_connector_options::Builder::default()
    }
}

/// When writing a match expression against `GlueRecordType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let gluerecordtype = unimplemented!();
/// match gluerecordtype {
///     GlueRecordType::Bigdecimal => { /* ... */ },
///     GlueRecordType::Byte => { /* ... */ },
///     GlueRecordType::Date => { /* ... */ },
///     GlueRecordType::Double => { /* ... */ },
///     GlueRecordType::Float => { /* ... */ },
///     GlueRecordType::Int => { /* ... */ },
///     GlueRecordType::Long => { /* ... */ },
///     GlueRecordType::Short => { /* ... */ },
///     GlueRecordType::String => { /* ... */ },
///     GlueRecordType::Timestamp => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `gluerecordtype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `GlueRecordType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `GlueRecordType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `GlueRecordType::NewFeature` is defined.
/// Specifically, when `gluerecordtype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `GlueRecordType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum GlueRecordType {
    #[allow(missing_docs)] // documentation missing in model
    Bigdecimal,
    #[allow(missing_docs)] // documentation missing in model
    Byte,
    #[allow(missing_docs)] // documentation missing in model
    Date,
    #[allow(missing_docs)] // documentation missing in model
    Double,
    #[allow(missing_docs)] // documentation missing in model
    Float,
    #[allow(missing_docs)] // documentation missing in model
    Int,
    #[allow(missing_docs)] // documentation missing in model
    Long,
    #[allow(missing_docs)] // documentation missing in model
    Short,
    #[allow(missing_docs)] // documentation missing in model
    String,
    #[allow(missing_docs)] // documentation missing in model
    Timestamp,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for GlueRecordType {
    fn from(s: &str) -> Self {
        match s {
            "BIGDECIMAL" => GlueRecordType::Bigdecimal,
            "BYTE" => GlueRecordType::Byte,
            "DATE" => GlueRecordType::Date,
            "DOUBLE" => GlueRecordType::Double,
            "FLOAT" => GlueRecordType::Float,
            "INT" => GlueRecordType::Int,
            "LONG" => GlueRecordType::Long,
            "SHORT" => GlueRecordType::Short,
            "STRING" => GlueRecordType::String,
            "TIMESTAMP" => GlueRecordType::Timestamp,
            other => GlueRecordType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for GlueRecordType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(GlueRecordType::from(s))
    }
}
impl GlueRecordType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            GlueRecordType::Bigdecimal => "BIGDECIMAL",
            GlueRecordType::Byte => "BYTE",
            GlueRecordType::Date => "DATE",
            GlueRecordType::Double => "DOUBLE",
            GlueRecordType::Float => "FLOAT",
            GlueRecordType::Int => "INT",
            GlueRecordType::Long => "LONG",
            GlueRecordType::Short => "SHORT",
            GlueRecordType::String => "STRING",
            GlueRecordType::Timestamp => "TIMESTAMP",
            GlueRecordType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "BIGDECIMAL",
            "BYTE",
            "DATE",
            "DOUBLE",
            "FLOAT",
            "INT",
            "LONG",
            "SHORT",
            "STRING",
            "TIMESTAMP",
        ]
    }
}
impl AsRef<str> for GlueRecordType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `JdbcDataType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let jdbcdatatype = unimplemented!();
/// match jdbcdatatype {
///     JdbcDataType::Array => { /* ... */ },
///     JdbcDataType::Bigint => { /* ... */ },
///     JdbcDataType::Binary => { /* ... */ },
///     JdbcDataType::Bit => { /* ... */ },
///     JdbcDataType::Blob => { /* ... */ },
///     JdbcDataType::Boolean => { /* ... */ },
///     JdbcDataType::Char => { /* ... */ },
///     JdbcDataType::Clob => { /* ... */ },
///     JdbcDataType::Datalink => { /* ... */ },
///     JdbcDataType::Date => { /* ... */ },
///     JdbcDataType::Decimal => { /* ... */ },
///     JdbcDataType::Distinct => { /* ... */ },
///     JdbcDataType::Double => { /* ... */ },
///     JdbcDataType::Float => { /* ... */ },
///     JdbcDataType::Integer => { /* ... */ },
///     JdbcDataType::JavaObject => { /* ... */ },
///     JdbcDataType::Longnvarchar => { /* ... */ },
///     JdbcDataType::Longvarbinary => { /* ... */ },
///     JdbcDataType::Longvarchar => { /* ... */ },
///     JdbcDataType::Nchar => { /* ... */ },
///     JdbcDataType::Nclob => { /* ... */ },
///     JdbcDataType::Null => { /* ... */ },
///     JdbcDataType::Numeric => { /* ... */ },
///     JdbcDataType::Nvarchar => { /* ... */ },
///     JdbcDataType::Other => { /* ... */ },
///     JdbcDataType::Real => { /* ... */ },
///     JdbcDataType::Ref => { /* ... */ },
///     JdbcDataType::RefCursor => { /* ... */ },
///     JdbcDataType::Rowid => { /* ... */ },
///     JdbcDataType::Smallint => { /* ... */ },
///     JdbcDataType::Sqlxml => { /* ... */ },
///     JdbcDataType::Struct => { /* ... */ },
///     JdbcDataType::Time => { /* ... */ },
///     JdbcDataType::Timestamp => { /* ... */ },
///     JdbcDataType::TimestampWithTimezone => { /* ... */ },
///     JdbcDataType::TimeWithTimezone => { /* ... */ },
///     JdbcDataType::Tinyint => { /* ... */ },
///     JdbcDataType::Varbinary => { /* ... */ },
///     JdbcDataType::Varchar => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `jdbcdatatype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `JdbcDataType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `JdbcDataType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `JdbcDataType::NewFeature` is defined.
/// Specifically, when `jdbcdatatype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `JdbcDataType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum JdbcDataType {
    #[allow(missing_docs)] // documentation missing in model
    Array,
    #[allow(missing_docs)] // documentation missing in model
    Bigint,
    #[allow(missing_docs)] // documentation missing in model
    Binary,
    #[allow(missing_docs)] // documentation missing in model
    Bit,
    #[allow(missing_docs)] // documentation missing in model
    Blob,
    #[allow(missing_docs)] // documentation missing in model
    Boolean,
    #[allow(missing_docs)] // documentation missing in model
    Char,
    #[allow(missing_docs)] // documentation missing in model
    Clob,
    #[allow(missing_docs)] // documentation missing in model
    Datalink,
    #[allow(missing_docs)] // documentation missing in model
    Date,
    #[allow(missing_docs)] // documentation missing in model
    Decimal,
    #[allow(missing_docs)] // documentation missing in model
    Distinct,
    #[allow(missing_docs)] // documentation missing in model
    Double,
    #[allow(missing_docs)] // documentation missing in model
    Float,
    #[allow(missing_docs)] // documentation missing in model
    Integer,
    #[allow(missing_docs)] // documentation missing in model
    JavaObject,
    #[allow(missing_docs)] // documentation missing in model
    Longnvarchar,
    #[allow(missing_docs)] // documentation missing in model
    Longvarbinary,
    #[allow(missing_docs)] // documentation missing in model
    Longvarchar,
    #[allow(missing_docs)] // documentation missing in model
    Nchar,
    #[allow(missing_docs)] // documentation missing in model
    Nclob,
    #[allow(missing_docs)] // documentation missing in model
    Null,
    #[allow(missing_docs)] // documentation missing in model
    Numeric,
    #[allow(missing_docs)] // documentation missing in model
    Nvarchar,
    #[allow(missing_docs)] // documentation missing in model
    Other,
    #[allow(missing_docs)] // documentation missing in model
    Real,
    #[allow(missing_docs)] // documentation missing in model
    Ref,
    #[allow(missing_docs)] // documentation missing in model
    RefCursor,
    #[allow(missing_docs)] // documentation missing in model
    Rowid,
    #[allow(missing_docs)] // documentation missing in model
    Smallint,
    #[allow(missing_docs)] // documentation missing in model
    Sqlxml,
    #[allow(missing_docs)] // documentation missing in model
    Struct,
    #[allow(missing_docs)] // documentation missing in model
    Time,
    #[allow(missing_docs)] // documentation missing in model
    Timestamp,
    #[allow(missing_docs)] // documentation missing in model
    TimestampWithTimezone,
    #[allow(missing_docs)] // documentation missing in model
    TimeWithTimezone,
    #[allow(missing_docs)] // documentation missing in model
    Tinyint,
    #[allow(missing_docs)] // documentation missing in model
    Varbinary,
    #[allow(missing_docs)] // documentation missing in model
    Varchar,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for JdbcDataType {
    fn from(s: &str) -> Self {
        match s {
            "ARRAY" => JdbcDataType::Array,
            "BIGINT" => JdbcDataType::Bigint,
            "BINARY" => JdbcDataType::Binary,
            "BIT" => JdbcDataType::Bit,
            "BLOB" => JdbcDataType::Blob,
            "BOOLEAN" => JdbcDataType::Boolean,
            "CHAR" => JdbcDataType::Char,
            "CLOB" => JdbcDataType::Clob,
            "DATALINK" => JdbcDataType::Datalink,
            "DATE" => JdbcDataType::Date,
            "DECIMAL" => JdbcDataType::Decimal,
            "DISTINCT" => JdbcDataType::Distinct,
            "DOUBLE" => JdbcDataType::Double,
            "FLOAT" => JdbcDataType::Float,
            "INTEGER" => JdbcDataType::Integer,
            "JAVA_OBJECT" => JdbcDataType::JavaObject,
            "LONGNVARCHAR" => JdbcDataType::Longnvarchar,
            "LONGVARBINARY" => JdbcDataType::Longvarbinary,
            "LONGVARCHAR" => JdbcDataType::Longvarchar,
            "NCHAR" => JdbcDataType::Nchar,
            "NCLOB" => JdbcDataType::Nclob,
            "NULL" => JdbcDataType::Null,
            "NUMERIC" => JdbcDataType::Numeric,
            "NVARCHAR" => JdbcDataType::Nvarchar,
            "OTHER" => JdbcDataType::Other,
            "REAL" => JdbcDataType::Real,
            "REF" => JdbcDataType::Ref,
            "REF_CURSOR" => JdbcDataType::RefCursor,
            "ROWID" => JdbcDataType::Rowid,
            "SMALLINT" => JdbcDataType::Smallint,
            "SQLXML" => JdbcDataType::Sqlxml,
            "STRUCT" => JdbcDataType::Struct,
            "TIME" => JdbcDataType::Time,
            "TIMESTAMP" => JdbcDataType::Timestamp,
            "TIMESTAMP_WITH_TIMEZONE" => JdbcDataType::TimestampWithTimezone,
            "TIME_WITH_TIMEZONE" => JdbcDataType::TimeWithTimezone,
            "TINYINT" => JdbcDataType::Tinyint,
            "VARBINARY" => JdbcDataType::Varbinary,
            "VARCHAR" => JdbcDataType::Varchar,
            other => JdbcDataType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for JdbcDataType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(JdbcDataType::from(s))
    }
}
impl JdbcDataType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            JdbcDataType::Array => "ARRAY",
            JdbcDataType::Bigint => "BIGINT",
            JdbcDataType::Binary => "BINARY",
            JdbcDataType::Bit => "BIT",
            JdbcDataType::Blob => "BLOB",
            JdbcDataType::Boolean => "BOOLEAN",
            JdbcDataType::Char => "CHAR",
            JdbcDataType::Clob => "CLOB",
            JdbcDataType::Datalink => "DATALINK",
            JdbcDataType::Date => "DATE",
            JdbcDataType::Decimal => "DECIMAL",
            JdbcDataType::Distinct => "DISTINCT",
            JdbcDataType::Double => "DOUBLE",
            JdbcDataType::Float => "FLOAT",
            JdbcDataType::Integer => "INTEGER",
            JdbcDataType::JavaObject => "JAVA_OBJECT",
            JdbcDataType::Longnvarchar => "LONGNVARCHAR",
            JdbcDataType::Longvarbinary => "LONGVARBINARY",
            JdbcDataType::Longvarchar => "LONGVARCHAR",
            JdbcDataType::Nchar => "NCHAR",
            JdbcDataType::Nclob => "NCLOB",
            JdbcDataType::Null => "NULL",
            JdbcDataType::Numeric => "NUMERIC",
            JdbcDataType::Nvarchar => "NVARCHAR",
            JdbcDataType::Other => "OTHER",
            JdbcDataType::Real => "REAL",
            JdbcDataType::Ref => "REF",
            JdbcDataType::RefCursor => "REF_CURSOR",
            JdbcDataType::Rowid => "ROWID",
            JdbcDataType::Smallint => "SMALLINT",
            JdbcDataType::Sqlxml => "SQLXML",
            JdbcDataType::Struct => "STRUCT",
            JdbcDataType::Time => "TIME",
            JdbcDataType::Timestamp => "TIMESTAMP",
            JdbcDataType::TimestampWithTimezone => "TIMESTAMP_WITH_TIMEZONE",
            JdbcDataType::TimeWithTimezone => "TIME_WITH_TIMEZONE",
            JdbcDataType::Tinyint => "TINYINT",
            JdbcDataType::Varbinary => "VARBINARY",
            JdbcDataType::Varchar => "VARCHAR",
            JdbcDataType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "ARRAY",
            "BIGINT",
            "BINARY",
            "BIT",
            "BLOB",
            "BOOLEAN",
            "CHAR",
            "CLOB",
            "DATALINK",
            "DATE",
            "DECIMAL",
            "DISTINCT",
            "DOUBLE",
            "FLOAT",
            "INTEGER",
            "JAVA_OBJECT",
            "LONGNVARCHAR",
            "LONGVARBINARY",
            "LONGVARCHAR",
            "NCHAR",
            "NCLOB",
            "NULL",
            "NUMERIC",
            "NVARCHAR",
            "OTHER",
            "REAL",
            "REF",
            "REF_CURSOR",
            "ROWID",
            "SMALLINT",
            "SQLXML",
            "STRUCT",
            "TIME",
            "TIMESTAMP",
            "TIMESTAMP_WITH_TIMEZONE",
            "TIME_WITH_TIMEZONE",
            "TINYINT",
            "VARBINARY",
            "VARCHAR",
        ]
    }
}
impl AsRef<str> for JdbcDataType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Specifies a connector to an Amazon Athena data source.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AthenaConnectorSource {
    /// <p>The name of the data source.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The name of the connection that is associated with the connector.</p>
    #[doc(hidden)]
    pub connection_name: std::option::Option<std::string::String>,
    /// <p>The name of a connector that assists with accessing the data store in Glue Studio.</p>
    #[doc(hidden)]
    pub connector_name: std::option::Option<std::string::String>,
    /// <p>The type of connection, such as marketplace.athena or custom.athena, designating a connection to an Amazon Athena data store.</p>
    #[doc(hidden)]
    pub connection_type: std::option::Option<std::string::String>,
    /// <p>The name of the table in the data source.</p>
    #[doc(hidden)]
    pub connection_table: std::option::Option<std::string::String>,
    /// <p>The name of the Cloudwatch log group to read from. For example, <code>/aws-glue/jobs/output</code>.</p>
    #[doc(hidden)]
    pub schema_name: std::option::Option<std::string::String>,
    /// <p>Specifies the data schema for the custom Athena source.</p>
    #[doc(hidden)]
    pub output_schemas: std::option::Option<std::vec::Vec<crate::model::GlueSchema>>,
}
impl AthenaConnectorSource {
    /// <p>The name of the data source.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The name of the connection that is associated with the connector.</p>
    pub fn connection_name(&self) -> std::option::Option<&str> {
        self.connection_name.as_deref()
    }
    /// <p>The name of a connector that assists with accessing the data store in Glue Studio.</p>
    pub fn connector_name(&self) -> std::option::Option<&str> {
        self.connector_name.as_deref()
    }
    /// <p>The type of connection, such as marketplace.athena or custom.athena, designating a connection to an Amazon Athena data store.</p>
    pub fn connection_type(&self) -> std::option::Option<&str> {
        self.connection_type.as_deref()
    }
    /// <p>The name of the table in the data source.</p>
    pub fn connection_table(&self) -> std::option::Option<&str> {
        self.connection_table.as_deref()
    }
    /// <p>The name of the Cloudwatch log group to read from. For example, <code>/aws-glue/jobs/output</code>.</p>
    pub fn schema_name(&self) -> std::option::Option<&str> {
        self.schema_name.as_deref()
    }
    /// <p>Specifies the data schema for the custom Athena source.</p>
    pub fn output_schemas(&self) -> std::option::Option<&[crate::model::GlueSchema]> {
        self.output_schemas.as_deref()
    }
}
/// See [`AthenaConnectorSource`](crate::model::AthenaConnectorSource).
pub mod athena_connector_source {

    /// A builder for [`AthenaConnectorSource`](crate::model::AthenaConnectorSource).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) connection_name: std::option::Option<std::string::String>,
        pub(crate) connector_name: std::option::Option<std::string::String>,
        pub(crate) connection_type: std::option::Option<std::string::String>,
        pub(crate) connection_table: std::option::Option<std::string::String>,
        pub(crate) schema_name: std::option::Option<std::string::String>,
        pub(crate) output_schemas: std::option::Option<std::vec::Vec<crate::model::GlueSchema>>,
    }
    impl Builder {
        /// <p>The name of the data source.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the data source.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The name of the connection that is associated with the connector.</p>
        pub fn connection_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.connection_name = Some(input.into());
            self
        }
        /// <p>The name of the connection that is associated with the connector.</p>
        pub fn set_connection_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.connection_name = input;
            self
        }
        /// <p>The name of a connector that assists with accessing the data store in Glue Studio.</p>
        pub fn connector_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.connector_name = Some(input.into());
            self
        }
        /// <p>The name of a connector that assists with accessing the data store in Glue Studio.</p>
        pub fn set_connector_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.connector_name = input;
            self
        }
        /// <p>The type of connection, such as marketplace.athena or custom.athena, designating a connection to an Amazon Athena data store.</p>
        pub fn connection_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.connection_type = Some(input.into());
            self
        }
        /// <p>The type of connection, such as marketplace.athena or custom.athena, designating a connection to an Amazon Athena data store.</p>
        pub fn set_connection_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.connection_type = input;
            self
        }
        /// <p>The name of the table in the data source.</p>
        pub fn connection_table(mut self, input: impl Into<std::string::String>) -> Self {
            self.connection_table = Some(input.into());
            self
        }
        /// <p>The name of the table in the data source.</p>
        pub fn set_connection_table(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.connection_table = input;
            self
        }
        /// <p>The name of the Cloudwatch log group to read from. For example, <code>/aws-glue/jobs/output</code>.</p>
        pub fn schema_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.schema_name = Some(input.into());
            self
        }
        /// <p>The name of the Cloudwatch log group to read from. For example, <code>/aws-glue/jobs/output</code>.</p>
        pub fn set_schema_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.schema_name = input;
            self
        }
        /// Appends an item to `output_schemas`.
        ///
        /// To override the contents of this collection use [`set_output_schemas`](Self::set_output_schemas).
        ///
        /// <p>Specifies the data schema for the custom Athena source.</p>
        pub fn output_schemas(mut self, input: crate::model::GlueSchema) -> Self {
            let mut v = self.output_schemas.unwrap_or_default();
            v.push(input);
            self.output_schemas = Some(v);
            self
        }
        /// <p>Specifies the data schema for the custom Athena source.</p>
        pub fn set_output_schemas(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::GlueSchema>>,
        ) -> Self {
            self.output_schemas = input;
            self
        }
        /// Consumes the builder and constructs a [`AthenaConnectorSource`](crate::model::AthenaConnectorSource).
        pub fn build(self) -> crate::model::AthenaConnectorSource {
            crate::model::AthenaConnectorSource {
                name: self.name,
                connection_name: self.connection_name,
                connector_name: self.connector_name,
                connection_type: self.connection_type,
                connection_table: self.connection_table,
                schema_name: self.schema_name,
                output_schemas: self.output_schemas,
            }
        }
    }
}
impl AthenaConnectorSource {
    /// Creates a new builder-style object to manufacture [`AthenaConnectorSource`](crate::model::AthenaConnectorSource).
    pub fn builder() -> crate::model::athena_connector_source::Builder {
        crate::model::athena_connector_source::Builder::default()
    }
}

/// <p>Specifies the connections used by a job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ConnectionsList {
    /// <p>A list of connections used by the job.</p>
    #[doc(hidden)]
    pub connections: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl ConnectionsList {
    /// <p>A list of connections used by the job.</p>
    pub fn connections(&self) -> std::option::Option<&[std::string::String]> {
        self.connections.as_deref()
    }
}
/// See [`ConnectionsList`](crate::model::ConnectionsList).
pub mod connections_list {

    /// A builder for [`ConnectionsList`](crate::model::ConnectionsList).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) connections: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// Appends an item to `connections`.
        ///
        /// To override the contents of this collection use [`set_connections`](Self::set_connections).
        ///
        /// <p>A list of connections used by the job.</p>
        pub fn connections(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.connections.unwrap_or_default();
            v.push(input.into());
            self.connections = Some(v);
            self
        }
        /// <p>A list of connections used by the job.</p>
        pub fn set_connections(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.connections = input;
            self
        }
        /// Consumes the builder and constructs a [`ConnectionsList`](crate::model::ConnectionsList).
        pub fn build(self) -> crate::model::ConnectionsList {
            crate::model::ConnectionsList {
                connections: self.connections,
            }
        }
    }
}
impl ConnectionsList {
    /// Creates a new builder-style object to manufacture [`ConnectionsList`](crate::model::ConnectionsList).
    pub fn builder() -> crate::model::connections_list::Builder {
        crate::model::connections_list::Builder::default()
    }
}

/// <p>Specifies code that runs when a job is run.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct JobCommand {
    /// <p>The name of the job command. For an Apache Spark ETL job, this must be <code>glueetl</code>. For a Python shell job, it must be <code>pythonshell</code>. For an Apache Spark streaming ETL job, this must be <code>gluestreaming</code>.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>Specifies the Amazon Simple Storage Service (Amazon S3) path to a script that runs a job.</p>
    #[doc(hidden)]
    pub script_location: std::option::Option<std::string::String>,
    /// <p>The Python version being used to run a Python shell job. Allowed values are 2 or 3.</p>
    #[doc(hidden)]
    pub python_version: std::option::Option<std::string::String>,
}
impl JobCommand {
    /// <p>The name of the job command. For an Apache Spark ETL job, this must be <code>glueetl</code>. For a Python shell job, it must be <code>pythonshell</code>. For an Apache Spark streaming ETL job, this must be <code>gluestreaming</code>.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>Specifies the Amazon Simple Storage Service (Amazon S3) path to a script that runs a job.</p>
    pub fn script_location(&self) -> std::option::Option<&str> {
        self.script_location.as_deref()
    }
    /// <p>The Python version being used to run a Python shell job. Allowed values are 2 or 3.</p>
    pub fn python_version(&self) -> std::option::Option<&str> {
        self.python_version.as_deref()
    }
}
/// See [`JobCommand`](crate::model::JobCommand).
pub mod job_command {

    /// A builder for [`JobCommand`](crate::model::JobCommand).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) script_location: std::option::Option<std::string::String>,
        pub(crate) python_version: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the job command. For an Apache Spark ETL job, this must be <code>glueetl</code>. For a Python shell job, it must be <code>pythonshell</code>. For an Apache Spark streaming ETL job, this must be <code>gluestreaming</code>.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the job command. For an Apache Spark ETL job, this must be <code>glueetl</code>. For a Python shell job, it must be <code>pythonshell</code>. For an Apache Spark streaming ETL job, this must be <code>gluestreaming</code>.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>Specifies the Amazon Simple Storage Service (Amazon S3) path to a script that runs a job.</p>
        pub fn script_location(mut self, input: impl Into<std::string::String>) -> Self {
            self.script_location = Some(input.into());
            self
        }
        /// <p>Specifies the Amazon Simple Storage Service (Amazon S3) path to a script that runs a job.</p>
        pub fn set_script_location(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.script_location = input;
            self
        }
        /// <p>The Python version being used to run a Python shell job. Allowed values are 2 or 3.</p>
        pub fn python_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.python_version = Some(input.into());
            self
        }
        /// <p>The Python version being used to run a Python shell job. Allowed values are 2 or 3.</p>
        pub fn set_python_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.python_version = input;
            self
        }
        /// Consumes the builder and constructs a [`JobCommand`](crate::model::JobCommand).
        pub fn build(self) -> crate::model::JobCommand {
            crate::model::JobCommand {
                name: self.name,
                script_location: self.script_location,
                python_version: self.python_version,
            }
        }
    }
}
impl JobCommand {
    /// Creates a new builder-style object to manufacture [`JobCommand`](crate::model::JobCommand).
    pub fn builder() -> crate::model::job_command::Builder {
        crate::model::job_command::Builder::default()
    }
}

/// <p>An execution property of a job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ExecutionProperty {
    /// <p>The maximum number of concurrent runs allowed for the job. The default is 1. An error is returned when this threshold is reached. The maximum value you can specify is controlled by a service limit.</p>
    #[doc(hidden)]
    pub max_concurrent_runs: i32,
}
impl ExecutionProperty {
    /// <p>The maximum number of concurrent runs allowed for the job. The default is 1. An error is returned when this threshold is reached. The maximum value you can specify is controlled by a service limit.</p>
    pub fn max_concurrent_runs(&self) -> i32 {
        self.max_concurrent_runs
    }
}
/// See [`ExecutionProperty`](crate::model::ExecutionProperty).
pub mod execution_property {

    /// A builder for [`ExecutionProperty`](crate::model::ExecutionProperty).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) max_concurrent_runs: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The maximum number of concurrent runs allowed for the job. The default is 1. An error is returned when this threshold is reached. The maximum value you can specify is controlled by a service limit.</p>
        pub fn max_concurrent_runs(mut self, input: i32) -> Self {
            self.max_concurrent_runs = Some(input);
            self
        }
        /// <p>The maximum number of concurrent runs allowed for the job. The default is 1. An error is returned when this threshold is reached. The maximum value you can specify is controlled by a service limit.</p>
        pub fn set_max_concurrent_runs(mut self, input: std::option::Option<i32>) -> Self {
            self.max_concurrent_runs = input;
            self
        }
        /// Consumes the builder and constructs a [`ExecutionProperty`](crate::model::ExecutionProperty).
        pub fn build(self) -> crate::model::ExecutionProperty {
            crate::model::ExecutionProperty {
                max_concurrent_runs: self.max_concurrent_runs.unwrap_or_default(),
            }
        }
    }
}
impl ExecutionProperty {
    /// Creates a new builder-style object to manufacture [`ExecutionProperty`](crate::model::ExecutionProperty).
    pub fn builder() -> crate::model::execution_property::Builder {
        crate::model::execution_property::Builder::default()
    }
}

/// <p>Custom libraries to be loaded into a development endpoint.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DevEndpointCustomLibraries {
    /// <p>The paths to one or more Python libraries in an Amazon Simple Storage Service (Amazon S3) bucket that should be loaded in your <code>DevEndpoint</code>. Multiple values must be complete paths separated by a comma.</p> <note>
    /// <p>You can only use pure Python libraries with a <code>DevEndpoint</code>. Libraries that rely on C extensions, such as the <a href="http://pandas.pydata.org/">pandas</a> Python data analysis library, are not currently supported.</p>
    /// </note>
    #[doc(hidden)]
    pub extra_python_libs_s3_path: std::option::Option<std::string::String>,
    /// <p>The path to one or more Java <code>.jar</code> files in an S3 bucket that should be loaded in your <code>DevEndpoint</code>.</p> <note>
    /// <p>You can only use pure Java/Scala libraries with a <code>DevEndpoint</code>.</p>
    /// </note>
    #[doc(hidden)]
    pub extra_jars_s3_path: std::option::Option<std::string::String>,
}
impl DevEndpointCustomLibraries {
    /// <p>The paths to one or more Python libraries in an Amazon Simple Storage Service (Amazon S3) bucket that should be loaded in your <code>DevEndpoint</code>. Multiple values must be complete paths separated by a comma.</p> <note>
    /// <p>You can only use pure Python libraries with a <code>DevEndpoint</code>. Libraries that rely on C extensions, such as the <a href="http://pandas.pydata.org/">pandas</a> Python data analysis library, are not currently supported.</p>
    /// </note>
    pub fn extra_python_libs_s3_path(&self) -> std::option::Option<&str> {
        self.extra_python_libs_s3_path.as_deref()
    }
    /// <p>The path to one or more Java <code>.jar</code> files in an S3 bucket that should be loaded in your <code>DevEndpoint</code>.</p> <note>
    /// <p>You can only use pure Java/Scala libraries with a <code>DevEndpoint</code>.</p>
    /// </note>
    pub fn extra_jars_s3_path(&self) -> std::option::Option<&str> {
        self.extra_jars_s3_path.as_deref()
    }
}
/// See [`DevEndpointCustomLibraries`](crate::model::DevEndpointCustomLibraries).
pub mod dev_endpoint_custom_libraries {

    /// A builder for [`DevEndpointCustomLibraries`](crate::model::DevEndpointCustomLibraries).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) extra_python_libs_s3_path: std::option::Option<std::string::String>,
        pub(crate) extra_jars_s3_path: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The paths to one or more Python libraries in an Amazon Simple Storage Service (Amazon S3) bucket that should be loaded in your <code>DevEndpoint</code>. Multiple values must be complete paths separated by a comma.</p> <note>
        /// <p>You can only use pure Python libraries with a <code>DevEndpoint</code>. Libraries that rely on C extensions, such as the <a href="http://pandas.pydata.org/">pandas</a> Python data analysis library, are not currently supported.</p>
        /// </note>
        pub fn extra_python_libs_s3_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.extra_python_libs_s3_path = Some(input.into());
            self
        }
        /// <p>The paths to one or more Python libraries in an Amazon Simple Storage Service (Amazon S3) bucket that should be loaded in your <code>DevEndpoint</code>. Multiple values must be complete paths separated by a comma.</p> <note>
        /// <p>You can only use pure Python libraries with a <code>DevEndpoint</code>. Libraries that rely on C extensions, such as the <a href="http://pandas.pydata.org/">pandas</a> Python data analysis library, are not currently supported.</p>
        /// </note>
        pub fn set_extra_python_libs_s3_path(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.extra_python_libs_s3_path = input;
            self
        }
        /// <p>The path to one or more Java <code>.jar</code> files in an S3 bucket that should be loaded in your <code>DevEndpoint</code>.</p> <note>
        /// <p>You can only use pure Java/Scala libraries with a <code>DevEndpoint</code>.</p>
        /// </note>
        pub fn extra_jars_s3_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.extra_jars_s3_path = Some(input.into());
            self
        }
        /// <p>The path to one or more Java <code>.jar</code> files in an S3 bucket that should be loaded in your <code>DevEndpoint</code>.</p> <note>
        /// <p>You can only use pure Java/Scala libraries with a <code>DevEndpoint</code>.</p>
        /// </note>
        pub fn set_extra_jars_s3_path(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.extra_jars_s3_path = input;
            self
        }
        /// Consumes the builder and constructs a [`DevEndpointCustomLibraries`](crate::model::DevEndpointCustomLibraries).
        pub fn build(self) -> crate::model::DevEndpointCustomLibraries {
            crate::model::DevEndpointCustomLibraries {
                extra_python_libs_s3_path: self.extra_python_libs_s3_path,
                extra_jars_s3_path: self.extra_jars_s3_path,
            }
        }
    }
}
impl DevEndpointCustomLibraries {
    /// Creates a new builder-style object to manufacture [`DevEndpointCustomLibraries`](crate::model::DevEndpointCustomLibraries).
    pub fn builder() -> crate::model::dev_endpoint_custom_libraries::Builder {
        crate::model::dev_endpoint_custom_libraries::Builder::default()
    }
}

/// <p>The structure used to create or update a database.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DatabaseInput {
    /// <p>The name of the database. For Hive compatibility, this is folded to lowercase when it is stored.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>A description of the database.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The location of the database (for example, an HDFS path). </p>
    #[doc(hidden)]
    pub location_uri: std::option::Option<std::string::String>,
    /// <p>These key-value pairs define parameters and properties of the database.</p>
    /// <p>These key-value pairs define parameters and properties of the database.</p>
    #[doc(hidden)]
    pub parameters:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>Creates a set of default permissions on the table for principals. </p>
    #[doc(hidden)]
    pub create_table_default_permissions:
        std::option::Option<std::vec::Vec<crate::model::PrincipalPermissions>>,
    /// <p>A <code>DatabaseIdentifier</code> structure that describes a target database for resource linking.</p>
    #[doc(hidden)]
    pub target_database: std::option::Option<crate::model::DatabaseIdentifier>,
}
impl DatabaseInput {
    /// <p>The name of the database. For Hive compatibility, this is folded to lowercase when it is stored.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>A description of the database.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The location of the database (for example, an HDFS path). </p>
    pub fn location_uri(&self) -> std::option::Option<&str> {
        self.location_uri.as_deref()
    }
    /// <p>These key-value pairs define parameters and properties of the database.</p>
    /// <p>These key-value pairs define parameters and properties of the database.</p>
    pub fn parameters(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.parameters.as_ref()
    }
    /// <p>Creates a set of default permissions on the table for principals. </p>
    pub fn create_table_default_permissions(
        &self,
    ) -> std::option::Option<&[crate::model::PrincipalPermissions]> {
        self.create_table_default_permissions.as_deref()
    }
    /// <p>A <code>DatabaseIdentifier</code> structure that describes a target database for resource linking.</p>
    pub fn target_database(&self) -> std::option::Option<&crate::model::DatabaseIdentifier> {
        self.target_database.as_ref()
    }
}
/// See [`DatabaseInput`](crate::model::DatabaseInput).
pub mod database_input {

    /// A builder for [`DatabaseInput`](crate::model::DatabaseInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) location_uri: std::option::Option<std::string::String>,
        pub(crate) parameters: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) create_table_default_permissions:
            std::option::Option<std::vec::Vec<crate::model::PrincipalPermissions>>,
        pub(crate) target_database: std::option::Option<crate::model::DatabaseIdentifier>,
    }
    impl Builder {
        /// <p>The name of the database. For Hive compatibility, this is folded to lowercase when it is stored.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the database. For Hive compatibility, this is folded to lowercase when it is stored.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>A description of the database.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A description of the database.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The location of the database (for example, an HDFS path). </p>
        pub fn location_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.location_uri = Some(input.into());
            self
        }
        /// <p>The location of the database (for example, an HDFS path). </p>
        pub fn set_location_uri(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.location_uri = input;
            self
        }
        /// Adds a key-value pair to `parameters`.
        ///
        /// To override the contents of this collection use [`set_parameters`](Self::set_parameters).
        ///
        /// <p>These key-value pairs define parameters and properties of the database.</p>
        /// <p>These key-value pairs define parameters and properties of the database.</p>
        pub fn parameters(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.parameters.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.parameters = Some(hash_map);
            self
        }
        /// <p>These key-value pairs define parameters and properties of the database.</p>
        /// <p>These key-value pairs define parameters and properties of the database.</p>
        pub fn set_parameters(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.parameters = input;
            self
        }
        /// Appends an item to `create_table_default_permissions`.
        ///
        /// To override the contents of this collection use [`set_create_table_default_permissions`](Self::set_create_table_default_permissions).
        ///
        /// <p>Creates a set of default permissions on the table for principals. </p>
        pub fn create_table_default_permissions(
            mut self,
            input: crate::model::PrincipalPermissions,
        ) -> Self {
            let mut v = self.create_table_default_permissions.unwrap_or_default();
            v.push(input);
            self.create_table_default_permissions = Some(v);
            self
        }
        /// <p>Creates a set of default permissions on the table for principals. </p>
        pub fn set_create_table_default_permissions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::PrincipalPermissions>>,
        ) -> Self {
            self.create_table_default_permissions = input;
            self
        }
        /// <p>A <code>DatabaseIdentifier</code> structure that describes a target database for resource linking.</p>
        pub fn target_database(mut self, input: crate::model::DatabaseIdentifier) -> Self {
            self.target_database = Some(input);
            self
        }
        /// <p>A <code>DatabaseIdentifier</code> structure that describes a target database for resource linking.</p>
        pub fn set_target_database(
            mut self,
            input: std::option::Option<crate::model::DatabaseIdentifier>,
        ) -> Self {
            self.target_database = input;
            self
        }
        /// Consumes the builder and constructs a [`DatabaseInput`](crate::model::DatabaseInput).
        pub fn build(self) -> crate::model::DatabaseInput {
            crate::model::DatabaseInput {
                name: self.name,
                description: self.description,
                location_uri: self.location_uri,
                parameters: self.parameters,
                create_table_default_permissions: self.create_table_default_permissions,
                target_database: self.target_database,
            }
        }
    }
}
impl DatabaseInput {
    /// Creates a new builder-style object to manufacture [`DatabaseInput`](crate::model::DatabaseInput).
    pub fn builder() -> crate::model::database_input::Builder {
        crate::model::database_input::Builder::default()
    }
}

/// <p>A structure that describes a target database for resource linking.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DatabaseIdentifier {
    /// <p>The ID of the Data Catalog in which the database resides.</p>
    #[doc(hidden)]
    pub catalog_id: std::option::Option<std::string::String>,
    /// <p>The name of the catalog database.</p>
    #[doc(hidden)]
    pub database_name: std::option::Option<std::string::String>,
}
impl DatabaseIdentifier {
    /// <p>The ID of the Data Catalog in which the database resides.</p>
    pub fn catalog_id(&self) -> std::option::Option<&str> {
        self.catalog_id.as_deref()
    }
    /// <p>The name of the catalog database.</p>
    pub fn database_name(&self) -> std::option::Option<&str> {
        self.database_name.as_deref()
    }
}
/// See [`DatabaseIdentifier`](crate::model::DatabaseIdentifier).
pub mod database_identifier {

    /// A builder for [`DatabaseIdentifier`](crate::model::DatabaseIdentifier).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) catalog_id: std::option::Option<std::string::String>,
        pub(crate) database_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the Data Catalog in which the database resides.</p>
        pub fn catalog_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.catalog_id = Some(input.into());
            self
        }
        /// <p>The ID of the Data Catalog in which the database resides.</p>
        pub fn set_catalog_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.catalog_id = input;
            self
        }
        /// <p>The name of the catalog database.</p>
        pub fn database_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.database_name = Some(input.into());
            self
        }
        /// <p>The name of the catalog database.</p>
        pub fn set_database_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.database_name = input;
            self
        }
        /// Consumes the builder and constructs a [`DatabaseIdentifier`](crate::model::DatabaseIdentifier).
        pub fn build(self) -> crate::model::DatabaseIdentifier {
            crate::model::DatabaseIdentifier {
                catalog_id: self.catalog_id,
                database_name: self.database_name,
            }
        }
    }
}
impl DatabaseIdentifier {
    /// Creates a new builder-style object to manufacture [`DatabaseIdentifier`](crate::model::DatabaseIdentifier).
    pub fn builder() -> crate::model::database_identifier::Builder {
        crate::model::database_identifier::Builder::default()
    }
}

/// <p>Permissions granted to a principal.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PrincipalPermissions {
    /// <p>The principal who is granted permissions.</p>
    #[doc(hidden)]
    pub principal: std::option::Option<crate::model::DataLakePrincipal>,
    /// <p>The permissions that are granted to the principal.</p>
    #[doc(hidden)]
    pub permissions: std::option::Option<std::vec::Vec<crate::model::Permission>>,
}
impl PrincipalPermissions {
    /// <p>The principal who is granted permissions.</p>
    pub fn principal(&self) -> std::option::Option<&crate::model::DataLakePrincipal> {
        self.principal.as_ref()
    }
    /// <p>The permissions that are granted to the principal.</p>
    pub fn permissions(&self) -> std::option::Option<&[crate::model::Permission]> {
        self.permissions.as_deref()
    }
}
/// See [`PrincipalPermissions`](crate::model::PrincipalPermissions).
pub mod principal_permissions {

    /// A builder for [`PrincipalPermissions`](crate::model::PrincipalPermissions).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) principal: std::option::Option<crate::model::DataLakePrincipal>,
        pub(crate) permissions: std::option::Option<std::vec::Vec<crate::model::Permission>>,
    }
    impl Builder {
        /// <p>The principal who is granted permissions.</p>
        pub fn principal(mut self, input: crate::model::DataLakePrincipal) -> Self {
            self.principal = Some(input);
            self
        }
        /// <p>The principal who is granted permissions.</p>
        pub fn set_principal(
            mut self,
            input: std::option::Option<crate::model::DataLakePrincipal>,
        ) -> Self {
            self.principal = input;
            self
        }
        /// Appends an item to `permissions`.
        ///
        /// To override the contents of this collection use [`set_permissions`](Self::set_permissions).
        ///
        /// <p>The permissions that are granted to the principal.</p>
        pub fn permissions(mut self, input: crate::model::Permission) -> Self {
            let mut v = self.permissions.unwrap_or_default();
            v.push(input);
            self.permissions = Some(v);
            self
        }
        /// <p>The permissions that are granted to the principal.</p>
        pub fn set_permissions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Permission>>,
        ) -> Self {
            self.permissions = input;
            self
        }
        /// Consumes the builder and constructs a [`PrincipalPermissions`](crate::model::PrincipalPermissions).
        pub fn build(self) -> crate::model::PrincipalPermissions {
            crate::model::PrincipalPermissions {
                principal: self.principal,
                permissions: self.permissions,
            }
        }
    }
}
impl PrincipalPermissions {
    /// Creates a new builder-style object to manufacture [`PrincipalPermissions`](crate::model::PrincipalPermissions).
    pub fn builder() -> crate::model::principal_permissions::Builder {
        crate::model::principal_permissions::Builder::default()
    }
}

/// When writing a match expression against `Permission`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let permission = unimplemented!();
/// match permission {
///     Permission::All => { /* ... */ },
///     Permission::Alter => { /* ... */ },
///     Permission::CreateDatabase => { /* ... */ },
///     Permission::CreateTable => { /* ... */ },
///     Permission::DataLocationAccess => { /* ... */ },
///     Permission::Delete => { /* ... */ },
///     Permission::Drop => { /* ... */ },
///     Permission::Insert => { /* ... */ },
///     Permission::Select => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `permission` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `Permission::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `Permission::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `Permission::NewFeature` is defined.
/// Specifically, when `permission` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `Permission::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Permission {
    #[allow(missing_docs)] // documentation missing in model
    All,
    #[allow(missing_docs)] // documentation missing in model
    Alter,
    #[allow(missing_docs)] // documentation missing in model
    CreateDatabase,
    #[allow(missing_docs)] // documentation missing in model
    CreateTable,
    #[allow(missing_docs)] // documentation missing in model
    DataLocationAccess,
    #[allow(missing_docs)] // documentation missing in model
    Delete,
    #[allow(missing_docs)] // documentation missing in model
    Drop,
    #[allow(missing_docs)] // documentation missing in model
    Insert,
    #[allow(missing_docs)] // documentation missing in model
    Select,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for Permission {
    fn from(s: &str) -> Self {
        match s {
            "ALL" => Permission::All,
            "ALTER" => Permission::Alter,
            "CREATE_DATABASE" => Permission::CreateDatabase,
            "CREATE_TABLE" => Permission::CreateTable,
            "DATA_LOCATION_ACCESS" => Permission::DataLocationAccess,
            "DELETE" => Permission::Delete,
            "DROP" => Permission::Drop,
            "INSERT" => Permission::Insert,
            "SELECT" => Permission::Select,
            other => Permission::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for Permission {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(Permission::from(s))
    }
}
impl Permission {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            Permission::All => "ALL",
            Permission::Alter => "ALTER",
            Permission::CreateDatabase => "CREATE_DATABASE",
            Permission::CreateTable => "CREATE_TABLE",
            Permission::DataLocationAccess => "DATA_LOCATION_ACCESS",
            Permission::Delete => "DELETE",
            Permission::Drop => "DROP",
            Permission::Insert => "INSERT",
            Permission::Select => "SELECT",
            Permission::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "ALL",
            "ALTER",
            "CREATE_DATABASE",
            "CREATE_TABLE",
            "DATA_LOCATION_ACCESS",
            "DELETE",
            "DROP",
            "INSERT",
            "SELECT",
        ]
    }
}
impl AsRef<str> for Permission {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The Lake Formation principal.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DataLakePrincipal {
    /// <p>An identifier for the Lake Formation principal.</p>
    #[doc(hidden)]
    pub data_lake_principal_identifier: std::option::Option<std::string::String>,
}
impl DataLakePrincipal {
    /// <p>An identifier for the Lake Formation principal.</p>
    pub fn data_lake_principal_identifier(&self) -> std::option::Option<&str> {
        self.data_lake_principal_identifier.as_deref()
    }
}
/// See [`DataLakePrincipal`](crate::model::DataLakePrincipal).
pub mod data_lake_principal {

    /// A builder for [`DataLakePrincipal`](crate::model::DataLakePrincipal).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) data_lake_principal_identifier: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>An identifier for the Lake Formation principal.</p>
        pub fn data_lake_principal_identifier(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.data_lake_principal_identifier = Some(input.into());
            self
        }
        /// <p>An identifier for the Lake Formation principal.</p>
        pub fn set_data_lake_principal_identifier(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.data_lake_principal_identifier = input;
            self
        }
        /// Consumes the builder and constructs a [`DataLakePrincipal`](crate::model::DataLakePrincipal).
        pub fn build(self) -> crate::model::DataLakePrincipal {
            crate::model::DataLakePrincipal {
                data_lake_principal_identifier: self.data_lake_principal_identifier,
            }
        }
    }
}
impl DataLakePrincipal {
    /// Creates a new builder-style object to manufacture [`DataLakePrincipal`](crate::model::DataLakePrincipal).
    pub fn builder() -> crate::model::data_lake_principal::Builder {
        crate::model::data_lake_principal::Builder::default()
    }
}

/// <p>Specifies Lake Formation configuration settings for the crawler.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LakeFormationConfiguration {
    /// <p>Specifies whether to use Lake Formation credentials for the crawler instead of the IAM role credentials.</p>
    #[doc(hidden)]
    pub use_lake_formation_credentials: std::option::Option<bool>,
    /// <p>Required for cross account crawls. For same account crawls as the target data, this can be left as null.</p>
    #[doc(hidden)]
    pub account_id: std::option::Option<std::string::String>,
}
impl LakeFormationConfiguration {
    /// <p>Specifies whether to use Lake Formation credentials for the crawler instead of the IAM role credentials.</p>
    pub fn use_lake_formation_credentials(&self) -> std::option::Option<bool> {
        self.use_lake_formation_credentials
    }
    /// <p>Required for cross account crawls. For same account crawls as the target data, this can be left as null.</p>
    pub fn account_id(&self) -> std::option::Option<&str> {
        self.account_id.as_deref()
    }
}
/// See [`LakeFormationConfiguration`](crate::model::LakeFormationConfiguration).
pub mod lake_formation_configuration {

    /// A builder for [`LakeFormationConfiguration`](crate::model::LakeFormationConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) use_lake_formation_credentials: std::option::Option<bool>,
        pub(crate) account_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Specifies whether to use Lake Formation credentials for the crawler instead of the IAM role credentials.</p>
        pub fn use_lake_formation_credentials(mut self, input: bool) -> Self {
            self.use_lake_formation_credentials = Some(input);
            self
        }
        /// <p>Specifies whether to use Lake Formation credentials for the crawler instead of the IAM role credentials.</p>
        pub fn set_use_lake_formation_credentials(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.use_lake_formation_credentials = input;
            self
        }
        /// <p>Required for cross account crawls. For same account crawls as the target data, this can be left as null.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_id = Some(input.into());
            self
        }
        /// <p>Required for cross account crawls. For same account crawls as the target data, this can be left as null.</p>
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_id = input;
            self
        }
        /// Consumes the builder and constructs a [`LakeFormationConfiguration`](crate::model::LakeFormationConfiguration).
        pub fn build(self) -> crate::model::LakeFormationConfiguration {
            crate::model::LakeFormationConfiguration {
                use_lake_formation_credentials: self.use_lake_formation_credentials,
                account_id: self.account_id,
            }
        }
    }
}
impl LakeFormationConfiguration {
    /// Creates a new builder-style object to manufacture [`LakeFormationConfiguration`](crate::model::LakeFormationConfiguration).
    pub fn builder() -> crate::model::lake_formation_configuration::Builder {
        crate::model::lake_formation_configuration::Builder::default()
    }
}

/// <p>Specifies data lineage configuration settings for the crawler.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LineageConfiguration {
    /// <p>Specifies whether data lineage is enabled for the crawler. Valid values are:</p>
    /// <ul>
    /// <li> <p>ENABLE: enables data lineage for the crawler</p> </li>
    /// <li> <p>DISABLE: disables data lineage for the crawler</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub crawler_lineage_settings: std::option::Option<crate::model::CrawlerLineageSettings>,
}
impl LineageConfiguration {
    /// <p>Specifies whether data lineage is enabled for the crawler. Valid values are:</p>
    /// <ul>
    /// <li> <p>ENABLE: enables data lineage for the crawler</p> </li>
    /// <li> <p>DISABLE: disables data lineage for the crawler</p> </li>
    /// </ul>
    pub fn crawler_lineage_settings(
        &self,
    ) -> std::option::Option<&crate::model::CrawlerLineageSettings> {
        self.crawler_lineage_settings.as_ref()
    }
}
/// See [`LineageConfiguration`](crate::model::LineageConfiguration).
pub mod lineage_configuration {

    /// A builder for [`LineageConfiguration`](crate::model::LineageConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) crawler_lineage_settings:
            std::option::Option<crate::model::CrawlerLineageSettings>,
    }
    impl Builder {
        /// <p>Specifies whether data lineage is enabled for the crawler. Valid values are:</p>
        /// <ul>
        /// <li> <p>ENABLE: enables data lineage for the crawler</p> </li>
        /// <li> <p>DISABLE: disables data lineage for the crawler</p> </li>
        /// </ul>
        pub fn crawler_lineage_settings(
            mut self,
            input: crate::model::CrawlerLineageSettings,
        ) -> Self {
            self.crawler_lineage_settings = Some(input);
            self
        }
        /// <p>Specifies whether data lineage is enabled for the crawler. Valid values are:</p>
        /// <ul>
        /// <li> <p>ENABLE: enables data lineage for the crawler</p> </li>
        /// <li> <p>DISABLE: disables data lineage for the crawler</p> </li>
        /// </ul>
        pub fn set_crawler_lineage_settings(
            mut self,
            input: std::option::Option<crate::model::CrawlerLineageSettings>,
        ) -> Self {
            self.crawler_lineage_settings = input;
            self
        }
        /// Consumes the builder and constructs a [`LineageConfiguration`](crate::model::LineageConfiguration).
        pub fn build(self) -> crate::model::LineageConfiguration {
            crate::model::LineageConfiguration {
                crawler_lineage_settings: self.crawler_lineage_settings,
            }
        }
    }
}
impl LineageConfiguration {
    /// Creates a new builder-style object to manufacture [`LineageConfiguration`](crate::model::LineageConfiguration).
    pub fn builder() -> crate::model::lineage_configuration::Builder {
        crate::model::lineage_configuration::Builder::default()
    }
}

/// When writing a match expression against `CrawlerLineageSettings`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let crawlerlineagesettings = unimplemented!();
/// match crawlerlineagesettings {
///     CrawlerLineageSettings::Disable => { /* ... */ },
///     CrawlerLineageSettings::Enable => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `crawlerlineagesettings` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `CrawlerLineageSettings::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `CrawlerLineageSettings::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `CrawlerLineageSettings::NewFeature` is defined.
/// Specifically, when `crawlerlineagesettings` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `CrawlerLineageSettings::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum CrawlerLineageSettings {
    #[allow(missing_docs)] // documentation missing in model
    Disable,
    #[allow(missing_docs)] // documentation missing in model
    Enable,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for CrawlerLineageSettings {
    fn from(s: &str) -> Self {
        match s {
            "DISABLE" => CrawlerLineageSettings::Disable,
            "ENABLE" => CrawlerLineageSettings::Enable,
            other => {
                CrawlerLineageSettings::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for CrawlerLineageSettings {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(CrawlerLineageSettings::from(s))
    }
}
impl CrawlerLineageSettings {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            CrawlerLineageSettings::Disable => "DISABLE",
            CrawlerLineageSettings::Enable => "ENABLE",
            CrawlerLineageSettings::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["DISABLE", "ENABLE"]
    }
}
impl AsRef<str> for CrawlerLineageSettings {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>When crawling an Amazon S3 data source after the first crawl is complete, specifies whether to crawl the entire dataset again or to crawl only folders that were added since the last crawler run. For more information, see <a href="https://docs.aws.amazon.com/glue/latest/dg/incremental-crawls.html">Incremental Crawls in Glue</a> in the developer guide.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RecrawlPolicy {
    /// <p>Specifies whether to crawl the entire dataset again or to crawl only folders that were added since the last crawler run.</p>
    /// <p>A value of <code>CRAWL_EVERYTHING</code> specifies crawling the entire dataset again.</p>
    /// <p>A value of <code>CRAWL_NEW_FOLDERS_ONLY</code> specifies crawling only folders that were added since the last crawler run.</p>
    /// <p>A value of <code>CRAWL_EVENT_MODE</code> specifies crawling only the changes identified by Amazon S3 events.</p>
    #[doc(hidden)]
    pub recrawl_behavior: std::option::Option<crate::model::RecrawlBehavior>,
}
impl RecrawlPolicy {
    /// <p>Specifies whether to crawl the entire dataset again or to crawl only folders that were added since the last crawler run.</p>
    /// <p>A value of <code>CRAWL_EVERYTHING</code> specifies crawling the entire dataset again.</p>
    /// <p>A value of <code>CRAWL_NEW_FOLDERS_ONLY</code> specifies crawling only folders that were added since the last crawler run.</p>
    /// <p>A value of <code>CRAWL_EVENT_MODE</code> specifies crawling only the changes identified by Amazon S3 events.</p>
    pub fn recrawl_behavior(&self) -> std::option::Option<&crate::model::RecrawlBehavior> {
        self.recrawl_behavior.as_ref()
    }
}
/// See [`RecrawlPolicy`](crate::model::RecrawlPolicy).
pub mod recrawl_policy {

    /// A builder for [`RecrawlPolicy`](crate::model::RecrawlPolicy).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) recrawl_behavior: std::option::Option<crate::model::RecrawlBehavior>,
    }
    impl Builder {
        /// <p>Specifies whether to crawl the entire dataset again or to crawl only folders that were added since the last crawler run.</p>
        /// <p>A value of <code>CRAWL_EVERYTHING</code> specifies crawling the entire dataset again.</p>
        /// <p>A value of <code>CRAWL_NEW_FOLDERS_ONLY</code> specifies crawling only folders that were added since the last crawler run.</p>
        /// <p>A value of <code>CRAWL_EVENT_MODE</code> specifies crawling only the changes identified by Amazon S3 events.</p>
        pub fn recrawl_behavior(mut self, input: crate::model::RecrawlBehavior) -> Self {
            self.recrawl_behavior = Some(input);
            self
        }
        /// <p>Specifies whether to crawl the entire dataset again or to crawl only folders that were added since the last crawler run.</p>
        /// <p>A value of <code>CRAWL_EVERYTHING</code> specifies crawling the entire dataset again.</p>
        /// <p>A value of <code>CRAWL_NEW_FOLDERS_ONLY</code> specifies crawling only folders that were added since the last crawler run.</p>
        /// <p>A value of <code>CRAWL_EVENT_MODE</code> specifies crawling only the changes identified by Amazon S3 events.</p>
        pub fn set_recrawl_behavior(
            mut self,
            input: std::option::Option<crate::model::RecrawlBehavior>,
        ) -> Self {
            self.recrawl_behavior = input;
            self
        }
        /// Consumes the builder and constructs a [`RecrawlPolicy`](crate::model::RecrawlPolicy).
        pub fn build(self) -> crate::model::RecrawlPolicy {
            crate::model::RecrawlPolicy {
                recrawl_behavior: self.recrawl_behavior,
            }
        }
    }
}
impl RecrawlPolicy {
    /// Creates a new builder-style object to manufacture [`RecrawlPolicy`](crate::model::RecrawlPolicy).
    pub fn builder() -> crate::model::recrawl_policy::Builder {
        crate::model::recrawl_policy::Builder::default()
    }
}

/// When writing a match expression against `RecrawlBehavior`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let recrawlbehavior = unimplemented!();
/// match recrawlbehavior {
///     RecrawlBehavior::CrawlEventMode => { /* ... */ },
///     RecrawlBehavior::CrawlEverything => { /* ... */ },
///     RecrawlBehavior::CrawlNewFoldersOnly => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `recrawlbehavior` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `RecrawlBehavior::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `RecrawlBehavior::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `RecrawlBehavior::NewFeature` is defined.
/// Specifically, when `recrawlbehavior` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `RecrawlBehavior::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum RecrawlBehavior {
    #[allow(missing_docs)] // documentation missing in model
    CrawlEventMode,
    #[allow(missing_docs)] // documentation missing in model
    CrawlEverything,
    #[allow(missing_docs)] // documentation missing in model
    CrawlNewFoldersOnly,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for RecrawlBehavior {
    fn from(s: &str) -> Self {
        match s {
            "CRAWL_EVENT_MODE" => RecrawlBehavior::CrawlEventMode,
            "CRAWL_EVERYTHING" => RecrawlBehavior::CrawlEverything,
            "CRAWL_NEW_FOLDERS_ONLY" => RecrawlBehavior::CrawlNewFoldersOnly,
            other => RecrawlBehavior::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for RecrawlBehavior {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(RecrawlBehavior::from(s))
    }
}
impl RecrawlBehavior {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            RecrawlBehavior::CrawlEventMode => "CRAWL_EVENT_MODE",
            RecrawlBehavior::CrawlEverything => "CRAWL_EVERYTHING",
            RecrawlBehavior::CrawlNewFoldersOnly => "CRAWL_NEW_FOLDERS_ONLY",
            RecrawlBehavior::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "CRAWL_EVENT_MODE",
            "CRAWL_EVERYTHING",
            "CRAWL_NEW_FOLDERS_ONLY",
        ]
    }
}
impl AsRef<str> for RecrawlBehavior {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A policy that specifies update and deletion behaviors for the crawler.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SchemaChangePolicy {
    /// <p>The update behavior when the crawler finds a changed schema.</p>
    #[doc(hidden)]
    pub update_behavior: std::option::Option<crate::model::UpdateBehavior>,
    /// <p>The deletion behavior when the crawler finds a deleted object.</p>
    #[doc(hidden)]
    pub delete_behavior: std::option::Option<crate::model::DeleteBehavior>,
}
impl SchemaChangePolicy {
    /// <p>The update behavior when the crawler finds a changed schema.</p>
    pub fn update_behavior(&self) -> std::option::Option<&crate::model::UpdateBehavior> {
        self.update_behavior.as_ref()
    }
    /// <p>The deletion behavior when the crawler finds a deleted object.</p>
    pub fn delete_behavior(&self) -> std::option::Option<&crate::model::DeleteBehavior> {
        self.delete_behavior.as_ref()
    }
}
/// See [`SchemaChangePolicy`](crate::model::SchemaChangePolicy).
pub mod schema_change_policy {

    /// A builder for [`SchemaChangePolicy`](crate::model::SchemaChangePolicy).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) update_behavior: std::option::Option<crate::model::UpdateBehavior>,
        pub(crate) delete_behavior: std::option::Option<crate::model::DeleteBehavior>,
    }
    impl Builder {
        /// <p>The update behavior when the crawler finds a changed schema.</p>
        pub fn update_behavior(mut self, input: crate::model::UpdateBehavior) -> Self {
            self.update_behavior = Some(input);
            self
        }
        /// <p>The update behavior when the crawler finds a changed schema.</p>
        pub fn set_update_behavior(
            mut self,
            input: std::option::Option<crate::model::UpdateBehavior>,
        ) -> Self {
            self.update_behavior = input;
            self
        }
        /// <p>The deletion behavior when the crawler finds a deleted object.</p>
        pub fn delete_behavior(mut self, input: crate::model::DeleteBehavior) -> Self {
            self.delete_behavior = Some(input);
            self
        }
        /// <p>The deletion behavior when the crawler finds a deleted object.</p>
        pub fn set_delete_behavior(
            mut self,
            input: std::option::Option<crate::model::DeleteBehavior>,
        ) -> Self {
            self.delete_behavior = input;
            self
        }
        /// Consumes the builder and constructs a [`SchemaChangePolicy`](crate::model::SchemaChangePolicy).
        pub fn build(self) -> crate::model::SchemaChangePolicy {
            crate::model::SchemaChangePolicy {
                update_behavior: self.update_behavior,
                delete_behavior: self.delete_behavior,
            }
        }
    }
}
impl SchemaChangePolicy {
    /// Creates a new builder-style object to manufacture [`SchemaChangePolicy`](crate::model::SchemaChangePolicy).
    pub fn builder() -> crate::model::schema_change_policy::Builder {
        crate::model::schema_change_policy::Builder::default()
    }
}

/// When writing a match expression against `DeleteBehavior`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let deletebehavior = unimplemented!();
/// match deletebehavior {
///     DeleteBehavior::DeleteFromDatabase => { /* ... */ },
///     DeleteBehavior::DeprecateInDatabase => { /* ... */ },
///     DeleteBehavior::Log => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `deletebehavior` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `DeleteBehavior::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `DeleteBehavior::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `DeleteBehavior::NewFeature` is defined.
/// Specifically, when `deletebehavior` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `DeleteBehavior::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DeleteBehavior {
    #[allow(missing_docs)] // documentation missing in model
    DeleteFromDatabase,
    #[allow(missing_docs)] // documentation missing in model
    DeprecateInDatabase,
    #[allow(missing_docs)] // documentation missing in model
    Log,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for DeleteBehavior {
    fn from(s: &str) -> Self {
        match s {
            "DELETE_FROM_DATABASE" => DeleteBehavior::DeleteFromDatabase,
            "DEPRECATE_IN_DATABASE" => DeleteBehavior::DeprecateInDatabase,
            "LOG" => DeleteBehavior::Log,
            other => DeleteBehavior::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for DeleteBehavior {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DeleteBehavior::from(s))
    }
}
impl DeleteBehavior {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            DeleteBehavior::DeleteFromDatabase => "DELETE_FROM_DATABASE",
            DeleteBehavior::DeprecateInDatabase => "DEPRECATE_IN_DATABASE",
            DeleteBehavior::Log => "LOG",
            DeleteBehavior::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["DELETE_FROM_DATABASE", "DEPRECATE_IN_DATABASE", "LOG"]
    }
}
impl AsRef<str> for DeleteBehavior {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `UpdateBehavior`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let updatebehavior = unimplemented!();
/// match updatebehavior {
///     UpdateBehavior::Log => { /* ... */ },
///     UpdateBehavior::UpdateInDatabase => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `updatebehavior` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `UpdateBehavior::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `UpdateBehavior::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `UpdateBehavior::NewFeature` is defined.
/// Specifically, when `updatebehavior` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `UpdateBehavior::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum UpdateBehavior {
    #[allow(missing_docs)] // documentation missing in model
    Log,
    #[allow(missing_docs)] // documentation missing in model
    UpdateInDatabase,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for UpdateBehavior {
    fn from(s: &str) -> Self {
        match s {
            "LOG" => UpdateBehavior::Log,
            "UPDATE_IN_DATABASE" => UpdateBehavior::UpdateInDatabase,
            other => UpdateBehavior::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for UpdateBehavior {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(UpdateBehavior::from(s))
    }
}
impl UpdateBehavior {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            UpdateBehavior::Log => "LOG",
            UpdateBehavior::UpdateInDatabase => "UPDATE_IN_DATABASE",
            UpdateBehavior::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["LOG", "UPDATE_IN_DATABASE"]
    }
}
impl AsRef<str> for UpdateBehavior {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Specifies data stores to crawl.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CrawlerTargets {
    /// <p>Specifies Amazon Simple Storage Service (Amazon S3) targets.</p>
    #[doc(hidden)]
    pub s3_targets: std::option::Option<std::vec::Vec<crate::model::S3Target>>,
    /// <p>Specifies JDBC targets.</p>
    #[doc(hidden)]
    pub jdbc_targets: std::option::Option<std::vec::Vec<crate::model::JdbcTarget>>,
    /// <p>Specifies Amazon DocumentDB or MongoDB targets.</p>
    #[doc(hidden)]
    pub mongo_db_targets: std::option::Option<std::vec::Vec<crate::model::MongoDbTarget>>,
    /// <p>Specifies Amazon DynamoDB targets.</p>
    #[doc(hidden)]
    pub dynamo_db_targets: std::option::Option<std::vec::Vec<crate::model::DynamoDbTarget>>,
    /// <p>Specifies Glue Data Catalog targets.</p>
    #[doc(hidden)]
    pub catalog_targets: std::option::Option<std::vec::Vec<crate::model::CatalogTarget>>,
    /// <p>Specifies Delta data store targets.</p>
    #[doc(hidden)]
    pub delta_targets: std::option::Option<std::vec::Vec<crate::model::DeltaTarget>>,
}
impl CrawlerTargets {
    /// <p>Specifies Amazon Simple Storage Service (Amazon S3) targets.</p>
    pub fn s3_targets(&self) -> std::option::Option<&[crate::model::S3Target]> {
        self.s3_targets.as_deref()
    }
    /// <p>Specifies JDBC targets.</p>
    pub fn jdbc_targets(&self) -> std::option::Option<&[crate::model::JdbcTarget]> {
        self.jdbc_targets.as_deref()
    }
    /// <p>Specifies Amazon DocumentDB or MongoDB targets.</p>
    pub fn mongo_db_targets(&self) -> std::option::Option<&[crate::model::MongoDbTarget]> {
        self.mongo_db_targets.as_deref()
    }
    /// <p>Specifies Amazon DynamoDB targets.</p>
    pub fn dynamo_db_targets(&self) -> std::option::Option<&[crate::model::DynamoDbTarget]> {
        self.dynamo_db_targets.as_deref()
    }
    /// <p>Specifies Glue Data Catalog targets.</p>
    pub fn catalog_targets(&self) -> std::option::Option<&[crate::model::CatalogTarget]> {
        self.catalog_targets.as_deref()
    }
    /// <p>Specifies Delta data store targets.</p>
    pub fn delta_targets(&self) -> std::option::Option<&[crate::model::DeltaTarget]> {
        self.delta_targets.as_deref()
    }
}
/// See [`CrawlerTargets`](crate::model::CrawlerTargets).
pub mod crawler_targets {

    /// A builder for [`CrawlerTargets`](crate::model::CrawlerTargets).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) s3_targets: std::option::Option<std::vec::Vec<crate::model::S3Target>>,
        pub(crate) jdbc_targets: std::option::Option<std::vec::Vec<crate::model::JdbcTarget>>,
        pub(crate) mongo_db_targets:
            std::option::Option<std::vec::Vec<crate::model::MongoDbTarget>>,
        pub(crate) dynamo_db_targets:
            std::option::Option<std::vec::Vec<crate::model::DynamoDbTarget>>,
        pub(crate) catalog_targets: std::option::Option<std::vec::Vec<crate::model::CatalogTarget>>,
        pub(crate) delta_targets: std::option::Option<std::vec::Vec<crate::model::DeltaTarget>>,
    }
    impl Builder {
        /// Appends an item to `s3_targets`.
        ///
        /// To override the contents of this collection use [`set_s3_targets`](Self::set_s3_targets).
        ///
        /// <p>Specifies Amazon Simple Storage Service (Amazon S3) targets.</p>
        pub fn s3_targets(mut self, input: crate::model::S3Target) -> Self {
            let mut v = self.s3_targets.unwrap_or_default();
            v.push(input);
            self.s3_targets = Some(v);
            self
        }
        /// <p>Specifies Amazon Simple Storage Service (Amazon S3) targets.</p>
        pub fn set_s3_targets(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::S3Target>>,
        ) -> Self {
            self.s3_targets = input;
            self
        }
        /// Appends an item to `jdbc_targets`.
        ///
        /// To override the contents of this collection use [`set_jdbc_targets`](Self::set_jdbc_targets).
        ///
        /// <p>Specifies JDBC targets.</p>
        pub fn jdbc_targets(mut self, input: crate::model::JdbcTarget) -> Self {
            let mut v = self.jdbc_targets.unwrap_or_default();
            v.push(input);
            self.jdbc_targets = Some(v);
            self
        }
        /// <p>Specifies JDBC targets.</p>
        pub fn set_jdbc_targets(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::JdbcTarget>>,
        ) -> Self {
            self.jdbc_targets = input;
            self
        }
        /// Appends an item to `mongo_db_targets`.
        ///
        /// To override the contents of this collection use [`set_mongo_db_targets`](Self::set_mongo_db_targets).
        ///
        /// <p>Specifies Amazon DocumentDB or MongoDB targets.</p>
        pub fn mongo_db_targets(mut self, input: crate::model::MongoDbTarget) -> Self {
            let mut v = self.mongo_db_targets.unwrap_or_default();
            v.push(input);
            self.mongo_db_targets = Some(v);
            self
        }
        /// <p>Specifies Amazon DocumentDB or MongoDB targets.</p>
        pub fn set_mongo_db_targets(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::MongoDbTarget>>,
        ) -> Self {
            self.mongo_db_targets = input;
            self
        }
        /// Appends an item to `dynamo_db_targets`.
        ///
        /// To override the contents of this collection use [`set_dynamo_db_targets`](Self::set_dynamo_db_targets).
        ///
        /// <p>Specifies Amazon DynamoDB targets.</p>
        pub fn dynamo_db_targets(mut self, input: crate::model::DynamoDbTarget) -> Self {
            let mut v = self.dynamo_db_targets.unwrap_or_default();
            v.push(input);
            self.dynamo_db_targets = Some(v);
            self
        }
        /// <p>Specifies Amazon DynamoDB targets.</p>
        pub fn set_dynamo_db_targets(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DynamoDbTarget>>,
        ) -> Self {
            self.dynamo_db_targets = input;
            self
        }
        /// Appends an item to `catalog_targets`.
        ///
        /// To override the contents of this collection use [`set_catalog_targets`](Self::set_catalog_targets).
        ///
        /// <p>Specifies Glue Data Catalog targets.</p>
        pub fn catalog_targets(mut self, input: crate::model::CatalogTarget) -> Self {
            let mut v = self.catalog_targets.unwrap_or_default();
            v.push(input);
            self.catalog_targets = Some(v);
            self
        }
        /// <p>Specifies Glue Data Catalog targets.</p>
        pub fn set_catalog_targets(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::CatalogTarget>>,
        ) -> Self {
            self.catalog_targets = input;
            self
        }
        /// Appends an item to `delta_targets`.
        ///
        /// To override the contents of this collection use [`set_delta_targets`](Self::set_delta_targets).
        ///
        /// <p>Specifies Delta data store targets.</p>
        pub fn delta_targets(mut self, input: crate::model::DeltaTarget) -> Self {
            let mut v = self.delta_targets.unwrap_or_default();
            v.push(input);
            self.delta_targets = Some(v);
            self
        }
        /// <p>Specifies Delta data store targets.</p>
        pub fn set_delta_targets(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DeltaTarget>>,
        ) -> Self {
            self.delta_targets = input;
            self
        }
        /// Consumes the builder and constructs a [`CrawlerTargets`](crate::model::CrawlerTargets).
        pub fn build(self) -> crate::model::CrawlerTargets {
            crate::model::CrawlerTargets {
                s3_targets: self.s3_targets,
                jdbc_targets: self.jdbc_targets,
                mongo_db_targets: self.mongo_db_targets,
                dynamo_db_targets: self.dynamo_db_targets,
                catalog_targets: self.catalog_targets,
                delta_targets: self.delta_targets,
            }
        }
    }
}
impl CrawlerTargets {
    /// Creates a new builder-style object to manufacture [`CrawlerTargets`](crate::model::CrawlerTargets).
    pub fn builder() -> crate::model::crawler_targets::Builder {
        crate::model::crawler_targets::Builder::default()
    }
}

/// <p>Specifies a Delta data store to crawl one or more Delta tables.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeltaTarget {
    /// <p>A list of the Amazon S3 paths to the Delta tables.</p>
    #[doc(hidden)]
    pub delta_tables: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The name of the connection to use to connect to the Delta table target.</p>
    #[doc(hidden)]
    pub connection_name: std::option::Option<std::string::String>,
    /// <p>Specifies whether to write the manifest files to the Delta table path.</p>
    #[doc(hidden)]
    pub write_manifest: std::option::Option<bool>,
    /// <p>Specifies whether the crawler will create native tables, to allow integration with query engines that support querying of the Delta transaction log directly.</p>
    #[doc(hidden)]
    pub create_native_delta_table: std::option::Option<bool>,
}
impl DeltaTarget {
    /// <p>A list of the Amazon S3 paths to the Delta tables.</p>
    pub fn delta_tables(&self) -> std::option::Option<&[std::string::String]> {
        self.delta_tables.as_deref()
    }
    /// <p>The name of the connection to use to connect to the Delta table target.</p>
    pub fn connection_name(&self) -> std::option::Option<&str> {
        self.connection_name.as_deref()
    }
    /// <p>Specifies whether to write the manifest files to the Delta table path.</p>
    pub fn write_manifest(&self) -> std::option::Option<bool> {
        self.write_manifest
    }
    /// <p>Specifies whether the crawler will create native tables, to allow integration with query engines that support querying of the Delta transaction log directly.</p>
    pub fn create_native_delta_table(&self) -> std::option::Option<bool> {
        self.create_native_delta_table
    }
}
/// See [`DeltaTarget`](crate::model::DeltaTarget).
pub mod delta_target {

    /// A builder for [`DeltaTarget`](crate::model::DeltaTarget).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) delta_tables: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) connection_name: std::option::Option<std::string::String>,
        pub(crate) write_manifest: std::option::Option<bool>,
        pub(crate) create_native_delta_table: std::option::Option<bool>,
    }
    impl Builder {
        /// Appends an item to `delta_tables`.
        ///
        /// To override the contents of this collection use [`set_delta_tables`](Self::set_delta_tables).
        ///
        /// <p>A list of the Amazon S3 paths to the Delta tables.</p>
        pub fn delta_tables(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.delta_tables.unwrap_or_default();
            v.push(input.into());
            self.delta_tables = Some(v);
            self
        }
        /// <p>A list of the Amazon S3 paths to the Delta tables.</p>
        pub fn set_delta_tables(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.delta_tables = input;
            self
        }
        /// <p>The name of the connection to use to connect to the Delta table target.</p>
        pub fn connection_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.connection_name = Some(input.into());
            self
        }
        /// <p>The name of the connection to use to connect to the Delta table target.</p>
        pub fn set_connection_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.connection_name = input;
            self
        }
        /// <p>Specifies whether to write the manifest files to the Delta table path.</p>
        pub fn write_manifest(mut self, input: bool) -> Self {
            self.write_manifest = Some(input);
            self
        }
        /// <p>Specifies whether to write the manifest files to the Delta table path.</p>
        pub fn set_write_manifest(mut self, input: std::option::Option<bool>) -> Self {
            self.write_manifest = input;
            self
        }
        /// <p>Specifies whether the crawler will create native tables, to allow integration with query engines that support querying of the Delta transaction log directly.</p>
        pub fn create_native_delta_table(mut self, input: bool) -> Self {
            self.create_native_delta_table = Some(input);
            self
        }
        /// <p>Specifies whether the crawler will create native tables, to allow integration with query engines that support querying of the Delta transaction log directly.</p>
        pub fn set_create_native_delta_table(mut self, input: std::option::Option<bool>) -> Self {
            self.create_native_delta_table = input;
            self
        }
        /// Consumes the builder and constructs a [`DeltaTarget`](crate::model::DeltaTarget).
        pub fn build(self) -> crate::model::DeltaTarget {
            crate::model::DeltaTarget {
                delta_tables: self.delta_tables,
                connection_name: self.connection_name,
                write_manifest: self.write_manifest,
                create_native_delta_table: self.create_native_delta_table,
            }
        }
    }
}
impl DeltaTarget {
    /// Creates a new builder-style object to manufacture [`DeltaTarget`](crate::model::DeltaTarget).
    pub fn builder() -> crate::model::delta_target::Builder {
        crate::model::delta_target::Builder::default()
    }
}

/// <p>Specifies an Glue Data Catalog target.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CatalogTarget {
    /// <p>The name of the database to be synchronized.</p>
    #[doc(hidden)]
    pub database_name: std::option::Option<std::string::String>,
    /// <p>A list of the tables to be synchronized.</p>
    #[doc(hidden)]
    pub tables: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The name of the connection for an Amazon S3-backed Data Catalog table to be a target of the crawl when using a <code>Catalog</code> connection type paired with a <code>NETWORK</code> Connection type.</p>
    #[doc(hidden)]
    pub connection_name: std::option::Option<std::string::String>,
    /// <p>A valid Amazon SQS ARN. For example, <code>arn:aws:sqs:region:account:sqs</code>.</p>
    #[doc(hidden)]
    pub event_queue_arn: std::option::Option<std::string::String>,
    /// <p>A valid Amazon dead-letter SQS ARN. For example, <code>arn:aws:sqs:region:account:deadLetterQueue</code>.</p>
    #[doc(hidden)]
    pub dlq_event_queue_arn: std::option::Option<std::string::String>,
}
impl CatalogTarget {
    /// <p>The name of the database to be synchronized.</p>
    pub fn database_name(&self) -> std::option::Option<&str> {
        self.database_name.as_deref()
    }
    /// <p>A list of the tables to be synchronized.</p>
    pub fn tables(&self) -> std::option::Option<&[std::string::String]> {
        self.tables.as_deref()
    }
    /// <p>The name of the connection for an Amazon S3-backed Data Catalog table to be a target of the crawl when using a <code>Catalog</code> connection type paired with a <code>NETWORK</code> Connection type.</p>
    pub fn connection_name(&self) -> std::option::Option<&str> {
        self.connection_name.as_deref()
    }
    /// <p>A valid Amazon SQS ARN. For example, <code>arn:aws:sqs:region:account:sqs</code>.</p>
    pub fn event_queue_arn(&self) -> std::option::Option<&str> {
        self.event_queue_arn.as_deref()
    }
    /// <p>A valid Amazon dead-letter SQS ARN. For example, <code>arn:aws:sqs:region:account:deadLetterQueue</code>.</p>
    pub fn dlq_event_queue_arn(&self) -> std::option::Option<&str> {
        self.dlq_event_queue_arn.as_deref()
    }
}
/// See [`CatalogTarget`](crate::model::CatalogTarget).
pub mod catalog_target {

    /// A builder for [`CatalogTarget`](crate::model::CatalogTarget).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) database_name: std::option::Option<std::string::String>,
        pub(crate) tables: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) connection_name: std::option::Option<std::string::String>,
        pub(crate) event_queue_arn: std::option::Option<std::string::String>,
        pub(crate) dlq_event_queue_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the database to be synchronized.</p>
        pub fn database_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.database_name = Some(input.into());
            self
        }
        /// <p>The name of the database to be synchronized.</p>
        pub fn set_database_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.database_name = input;
            self
        }
        /// Appends an item to `tables`.
        ///
        /// To override the contents of this collection use [`set_tables`](Self::set_tables).
        ///
        /// <p>A list of the tables to be synchronized.</p>
        pub fn tables(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.tables.unwrap_or_default();
            v.push(input.into());
            self.tables = Some(v);
            self
        }
        /// <p>A list of the tables to be synchronized.</p>
        pub fn set_tables(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.tables = input;
            self
        }
        /// <p>The name of the connection for an Amazon S3-backed Data Catalog table to be a target of the crawl when using a <code>Catalog</code> connection type paired with a <code>NETWORK</code> Connection type.</p>
        pub fn connection_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.connection_name = Some(input.into());
            self
        }
        /// <p>The name of the connection for an Amazon S3-backed Data Catalog table to be a target of the crawl when using a <code>Catalog</code> connection type paired with a <code>NETWORK</code> Connection type.</p>
        pub fn set_connection_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.connection_name = input;
            self
        }
        /// <p>A valid Amazon SQS ARN. For example, <code>arn:aws:sqs:region:account:sqs</code>.</p>
        pub fn event_queue_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.event_queue_arn = Some(input.into());
            self
        }
        /// <p>A valid Amazon SQS ARN. For example, <code>arn:aws:sqs:region:account:sqs</code>.</p>
        pub fn set_event_queue_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.event_queue_arn = input;
            self
        }
        /// <p>A valid Amazon dead-letter SQS ARN. For example, <code>arn:aws:sqs:region:account:deadLetterQueue</code>.</p>
        pub fn dlq_event_queue_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.dlq_event_queue_arn = Some(input.into());
            self
        }
        /// <p>A valid Amazon dead-letter SQS ARN. For example, <code>arn:aws:sqs:region:account:deadLetterQueue</code>.</p>
        pub fn set_dlq_event_queue_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.dlq_event_queue_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`CatalogTarget`](crate::model::CatalogTarget).
        pub fn build(self) -> crate::model::CatalogTarget {
            crate::model::CatalogTarget {
                database_name: self.database_name,
                tables: self.tables,
                connection_name: self.connection_name,
                event_queue_arn: self.event_queue_arn,
                dlq_event_queue_arn: self.dlq_event_queue_arn,
            }
        }
    }
}
impl CatalogTarget {
    /// Creates a new builder-style object to manufacture [`CatalogTarget`](crate::model::CatalogTarget).
    pub fn builder() -> crate::model::catalog_target::Builder {
        crate::model::catalog_target::Builder::default()
    }
}

/// <p>Specifies an Amazon DynamoDB table to crawl.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DynamoDbTarget {
    /// <p>The name of the DynamoDB table to crawl.</p>
    #[doc(hidden)]
    pub path: std::option::Option<std::string::String>,
    /// <p>Indicates whether to scan all the records, or to sample rows from the table. Scanning all the records can take a long time when the table is not a high throughput table.</p>
    /// <p>A value of <code>true</code> means to scan all records, while a value of <code>false</code> means to sample the records. If no value is specified, the value defaults to <code>true</code>.</p>
    #[doc(hidden)]
    pub scan_all: std::option::Option<bool>,
    /// <p>The percentage of the configured read capacity units to use by the Glue crawler. Read capacity units is a term defined by DynamoDB, and is a numeric value that acts as rate limiter for the number of reads that can be performed on that table per second.</p>
    /// <p>The valid values are null or a value between 0.1 to 1.5. A null value is used when user does not provide a value, and defaults to 0.5 of the configured Read Capacity Unit (for provisioned tables), or 0.25 of the max configured Read Capacity Unit (for tables using on-demand mode).</p>
    #[doc(hidden)]
    pub scan_rate: std::option::Option<f64>,
}
impl DynamoDbTarget {
    /// <p>The name of the DynamoDB table to crawl.</p>
    pub fn path(&self) -> std::option::Option<&str> {
        self.path.as_deref()
    }
    /// <p>Indicates whether to scan all the records, or to sample rows from the table. Scanning all the records can take a long time when the table is not a high throughput table.</p>
    /// <p>A value of <code>true</code> means to scan all records, while a value of <code>false</code> means to sample the records. If no value is specified, the value defaults to <code>true</code>.</p>
    pub fn scan_all(&self) -> std::option::Option<bool> {
        self.scan_all
    }
    /// <p>The percentage of the configured read capacity units to use by the Glue crawler. Read capacity units is a term defined by DynamoDB, and is a numeric value that acts as rate limiter for the number of reads that can be performed on that table per second.</p>
    /// <p>The valid values are null or a value between 0.1 to 1.5. A null value is used when user does not provide a value, and defaults to 0.5 of the configured Read Capacity Unit (for provisioned tables), or 0.25 of the max configured Read Capacity Unit (for tables using on-demand mode).</p>
    pub fn scan_rate(&self) -> std::option::Option<f64> {
        self.scan_rate
    }
}
/// See [`DynamoDbTarget`](crate::model::DynamoDbTarget).
pub mod dynamo_db_target {

    /// A builder for [`DynamoDbTarget`](crate::model::DynamoDbTarget).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) path: std::option::Option<std::string::String>,
        pub(crate) scan_all: std::option::Option<bool>,
        pub(crate) scan_rate: std::option::Option<f64>,
    }
    impl Builder {
        /// <p>The name of the DynamoDB table to crawl.</p>
        pub fn path(mut self, input: impl Into<std::string::String>) -> Self {
            self.path = Some(input.into());
            self
        }
        /// <p>The name of the DynamoDB table to crawl.</p>
        pub fn set_path(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.path = input;
            self
        }
        /// <p>Indicates whether to scan all the records, or to sample rows from the table. Scanning all the records can take a long time when the table is not a high throughput table.</p>
        /// <p>A value of <code>true</code> means to scan all records, while a value of <code>false</code> means to sample the records. If no value is specified, the value defaults to <code>true</code>.</p>
        pub fn scan_all(mut self, input: bool) -> Self {
            self.scan_all = Some(input);
            self
        }
        /// <p>Indicates whether to scan all the records, or to sample rows from the table. Scanning all the records can take a long time when the table is not a high throughput table.</p>
        /// <p>A value of <code>true</code> means to scan all records, while a value of <code>false</code> means to sample the records. If no value is specified, the value defaults to <code>true</code>.</p>
        pub fn set_scan_all(mut self, input: std::option::Option<bool>) -> Self {
            self.scan_all = input;
            self
        }
        /// <p>The percentage of the configured read capacity units to use by the Glue crawler. Read capacity units is a term defined by DynamoDB, and is a numeric value that acts as rate limiter for the number of reads that can be performed on that table per second.</p>
        /// <p>The valid values are null or a value between 0.1 to 1.5. A null value is used when user does not provide a value, and defaults to 0.5 of the configured Read Capacity Unit (for provisioned tables), or 0.25 of the max configured Read Capacity Unit (for tables using on-demand mode).</p>
        pub fn scan_rate(mut self, input: f64) -> Self {
            self.scan_rate = Some(input);
            self
        }
        /// <p>The percentage of the configured read capacity units to use by the Glue crawler. Read capacity units is a term defined by DynamoDB, and is a numeric value that acts as rate limiter for the number of reads that can be performed on that table per second.</p>
        /// <p>The valid values are null or a value between 0.1 to 1.5. A null value is used when user does not provide a value, and defaults to 0.5 of the configured Read Capacity Unit (for provisioned tables), or 0.25 of the max configured Read Capacity Unit (for tables using on-demand mode).</p>
        pub fn set_scan_rate(mut self, input: std::option::Option<f64>) -> Self {
            self.scan_rate = input;
            self
        }
        /// Consumes the builder and constructs a [`DynamoDbTarget`](crate::model::DynamoDbTarget).
        pub fn build(self) -> crate::model::DynamoDbTarget {
            crate::model::DynamoDbTarget {
                path: self.path,
                scan_all: self.scan_all,
                scan_rate: self.scan_rate,
            }
        }
    }
}
impl DynamoDbTarget {
    /// Creates a new builder-style object to manufacture [`DynamoDbTarget`](crate::model::DynamoDbTarget).
    pub fn builder() -> crate::model::dynamo_db_target::Builder {
        crate::model::dynamo_db_target::Builder::default()
    }
}

/// <p>Specifies an Amazon DocumentDB or MongoDB data store to crawl.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct MongoDbTarget {
    /// <p>The name of the connection to use to connect to the Amazon DocumentDB or MongoDB target.</p>
    #[doc(hidden)]
    pub connection_name: std::option::Option<std::string::String>,
    /// <p>The path of the Amazon DocumentDB or MongoDB target (database/collection).</p>
    #[doc(hidden)]
    pub path: std::option::Option<std::string::String>,
    /// <p>Indicates whether to scan all the records, or to sample rows from the table. Scanning all the records can take a long time when the table is not a high throughput table.</p>
    /// <p>A value of <code>true</code> means to scan all records, while a value of <code>false</code> means to sample the records. If no value is specified, the value defaults to <code>true</code>.</p>
    #[doc(hidden)]
    pub scan_all: std::option::Option<bool>,
}
impl MongoDbTarget {
    /// <p>The name of the connection to use to connect to the Amazon DocumentDB or MongoDB target.</p>
    pub fn connection_name(&self) -> std::option::Option<&str> {
        self.connection_name.as_deref()
    }
    /// <p>The path of the Amazon DocumentDB or MongoDB target (database/collection).</p>
    pub fn path(&self) -> std::option::Option<&str> {
        self.path.as_deref()
    }
    /// <p>Indicates whether to scan all the records, or to sample rows from the table. Scanning all the records can take a long time when the table is not a high throughput table.</p>
    /// <p>A value of <code>true</code> means to scan all records, while a value of <code>false</code> means to sample the records. If no value is specified, the value defaults to <code>true</code>.</p>
    pub fn scan_all(&self) -> std::option::Option<bool> {
        self.scan_all
    }
}
/// See [`MongoDbTarget`](crate::model::MongoDbTarget).
pub mod mongo_db_target {

    /// A builder for [`MongoDbTarget`](crate::model::MongoDbTarget).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) connection_name: std::option::Option<std::string::String>,
        pub(crate) path: std::option::Option<std::string::String>,
        pub(crate) scan_all: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The name of the connection to use to connect to the Amazon DocumentDB or MongoDB target.</p>
        pub fn connection_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.connection_name = Some(input.into());
            self
        }
        /// <p>The name of the connection to use to connect to the Amazon DocumentDB or MongoDB target.</p>
        pub fn set_connection_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.connection_name = input;
            self
        }
        /// <p>The path of the Amazon DocumentDB or MongoDB target (database/collection).</p>
        pub fn path(mut self, input: impl Into<std::string::String>) -> Self {
            self.path = Some(input.into());
            self
        }
        /// <p>The path of the Amazon DocumentDB or MongoDB target (database/collection).</p>
        pub fn set_path(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.path = input;
            self
        }
        /// <p>Indicates whether to scan all the records, or to sample rows from the table. Scanning all the records can take a long time when the table is not a high throughput table.</p>
        /// <p>A value of <code>true</code> means to scan all records, while a value of <code>false</code> means to sample the records. If no value is specified, the value defaults to <code>true</code>.</p>
        pub fn scan_all(mut self, input: bool) -> Self {
            self.scan_all = Some(input);
            self
        }
        /// <p>Indicates whether to scan all the records, or to sample rows from the table. Scanning all the records can take a long time when the table is not a high throughput table.</p>
        /// <p>A value of <code>true</code> means to scan all records, while a value of <code>false</code> means to sample the records. If no value is specified, the value defaults to <code>true</code>.</p>
        pub fn set_scan_all(mut self, input: std::option::Option<bool>) -> Self {
            self.scan_all = input;
            self
        }
        /// Consumes the builder and constructs a [`MongoDbTarget`](crate::model::MongoDbTarget).
        pub fn build(self) -> crate::model::MongoDbTarget {
            crate::model::MongoDbTarget {
                connection_name: self.connection_name,
                path: self.path,
                scan_all: self.scan_all,
            }
        }
    }
}
impl MongoDbTarget {
    /// Creates a new builder-style object to manufacture [`MongoDbTarget`](crate::model::MongoDbTarget).
    pub fn builder() -> crate::model::mongo_db_target::Builder {
        crate::model::mongo_db_target::Builder::default()
    }
}

/// <p>Specifies a JDBC data store to crawl.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct JdbcTarget {
    /// <p>The name of the connection to use to connect to the JDBC target.</p>
    #[doc(hidden)]
    pub connection_name: std::option::Option<std::string::String>,
    /// <p>The path of the JDBC target.</p>
    #[doc(hidden)]
    pub path: std::option::Option<std::string::String>,
    /// <p>A list of glob patterns used to exclude from the crawl. For more information, see <a href="https://docs.aws.amazon.com/glue/latest/dg/add-crawler.html">Catalog Tables with a Crawler</a>.</p>
    #[doc(hidden)]
    pub exclusions: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Specify a value of <code>RAWTYPES</code> or <code>COMMENTS</code> to enable additional metadata in table responses. <code>RAWTYPES</code> provides the native-level datatype. <code>COMMENTS</code> provides comments associated with a column or table in the database.</p>
    /// <p>If you do not need additional metadata, keep the field empty.</p>
    #[doc(hidden)]
    pub enable_additional_metadata:
        std::option::Option<std::vec::Vec<crate::model::JdbcMetadataEntry>>,
}
impl JdbcTarget {
    /// <p>The name of the connection to use to connect to the JDBC target.</p>
    pub fn connection_name(&self) -> std::option::Option<&str> {
        self.connection_name.as_deref()
    }
    /// <p>The path of the JDBC target.</p>
    pub fn path(&self) -> std::option::Option<&str> {
        self.path.as_deref()
    }
    /// <p>A list of glob patterns used to exclude from the crawl. For more information, see <a href="https://docs.aws.amazon.com/glue/latest/dg/add-crawler.html">Catalog Tables with a Crawler</a>.</p>
    pub fn exclusions(&self) -> std::option::Option<&[std::string::String]> {
        self.exclusions.as_deref()
    }
    /// <p>Specify a value of <code>RAWTYPES</code> or <code>COMMENTS</code> to enable additional metadata in table responses. <code>RAWTYPES</code> provides the native-level datatype. <code>COMMENTS</code> provides comments associated with a column or table in the database.</p>
    /// <p>If you do not need additional metadata, keep the field empty.</p>
    pub fn enable_additional_metadata(
        &self,
    ) -> std::option::Option<&[crate::model::JdbcMetadataEntry]> {
        self.enable_additional_metadata.as_deref()
    }
}
/// See [`JdbcTarget`](crate::model::JdbcTarget).
pub mod jdbc_target {

    /// A builder for [`JdbcTarget`](crate::model::JdbcTarget).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) connection_name: std::option::Option<std::string::String>,
        pub(crate) path: std::option::Option<std::string::String>,
        pub(crate) exclusions: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) enable_additional_metadata:
            std::option::Option<std::vec::Vec<crate::model::JdbcMetadataEntry>>,
    }
    impl Builder {
        /// <p>The name of the connection to use to connect to the JDBC target.</p>
        pub fn connection_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.connection_name = Some(input.into());
            self
        }
        /// <p>The name of the connection to use to connect to the JDBC target.</p>
        pub fn set_connection_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.connection_name = input;
            self
        }
        /// <p>The path of the JDBC target.</p>
        pub fn path(mut self, input: impl Into<std::string::String>) -> Self {
            self.path = Some(input.into());
            self
        }
        /// <p>The path of the JDBC target.</p>
        pub fn set_path(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.path = input;
            self
        }
        /// Appends an item to `exclusions`.
        ///
        /// To override the contents of this collection use [`set_exclusions`](Self::set_exclusions).
        ///
        /// <p>A list of glob patterns used to exclude from the crawl. For more information, see <a href="https://docs.aws.amazon.com/glue/latest/dg/add-crawler.html">Catalog Tables with a Crawler</a>.</p>
        pub fn exclusions(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.exclusions.unwrap_or_default();
            v.push(input.into());
            self.exclusions = Some(v);
            self
        }
        /// <p>A list of glob patterns used to exclude from the crawl. For more information, see <a href="https://docs.aws.amazon.com/glue/latest/dg/add-crawler.html">Catalog Tables with a Crawler</a>.</p>
        pub fn set_exclusions(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.exclusions = input;
            self
        }
        /// Appends an item to `enable_additional_metadata`.
        ///
        /// To override the contents of this collection use [`set_enable_additional_metadata`](Self::set_enable_additional_metadata).
        ///
        /// <p>Specify a value of <code>RAWTYPES</code> or <code>COMMENTS</code> to enable additional metadata in table responses. <code>RAWTYPES</code> provides the native-level datatype. <code>COMMENTS</code> provides comments associated with a column or table in the database.</p>
        /// <p>If you do not need additional metadata, keep the field empty.</p>
        pub fn enable_additional_metadata(
            mut self,
            input: crate::model::JdbcMetadataEntry,
        ) -> Self {
            let mut v = self.enable_additional_metadata.unwrap_or_default();
            v.push(input);
            self.enable_additional_metadata = Some(v);
            self
        }
        /// <p>Specify a value of <code>RAWTYPES</code> or <code>COMMENTS</code> to enable additional metadata in table responses. <code>RAWTYPES</code> provides the native-level datatype. <code>COMMENTS</code> provides comments associated with a column or table in the database.</p>
        /// <p>If you do not need additional metadata, keep the field empty.</p>
        pub fn set_enable_additional_metadata(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::JdbcMetadataEntry>>,
        ) -> Self {
            self.enable_additional_metadata = input;
            self
        }
        /// Consumes the builder and constructs a [`JdbcTarget`](crate::model::JdbcTarget).
        pub fn build(self) -> crate::model::JdbcTarget {
            crate::model::JdbcTarget {
                connection_name: self.connection_name,
                path: self.path,
                exclusions: self.exclusions,
                enable_additional_metadata: self.enable_additional_metadata,
            }
        }
    }
}
impl JdbcTarget {
    /// Creates a new builder-style object to manufacture [`JdbcTarget`](crate::model::JdbcTarget).
    pub fn builder() -> crate::model::jdbc_target::Builder {
        crate::model::jdbc_target::Builder::default()
    }
}

/// When writing a match expression against `JdbcMetadataEntry`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let jdbcmetadataentry = unimplemented!();
/// match jdbcmetadataentry {
///     JdbcMetadataEntry::Comments => { /* ... */ },
///     JdbcMetadataEntry::Rawtypes => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `jdbcmetadataentry` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `JdbcMetadataEntry::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `JdbcMetadataEntry::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `JdbcMetadataEntry::NewFeature` is defined.
/// Specifically, when `jdbcmetadataentry` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `JdbcMetadataEntry::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum JdbcMetadataEntry {
    #[allow(missing_docs)] // documentation missing in model
    Comments,
    #[allow(missing_docs)] // documentation missing in model
    Rawtypes,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for JdbcMetadataEntry {
    fn from(s: &str) -> Self {
        match s {
            "COMMENTS" => JdbcMetadataEntry::Comments,
            "RAWTYPES" => JdbcMetadataEntry::Rawtypes,
            other => {
                JdbcMetadataEntry::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for JdbcMetadataEntry {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(JdbcMetadataEntry::from(s))
    }
}
impl JdbcMetadataEntry {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            JdbcMetadataEntry::Comments => "COMMENTS",
            JdbcMetadataEntry::Rawtypes => "RAWTYPES",
            JdbcMetadataEntry::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["COMMENTS", "RAWTYPES"]
    }
}
impl AsRef<str> for JdbcMetadataEntry {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Specifies a data store in Amazon Simple Storage Service (Amazon S3).</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct S3Target {
    /// <p>The path to the Amazon S3 target.</p>
    #[doc(hidden)]
    pub path: std::option::Option<std::string::String>,
    /// <p>A list of glob patterns used to exclude from the crawl. For more information, see <a href="https://docs.aws.amazon.com/glue/latest/dg/add-crawler.html">Catalog Tables with a Crawler</a>.</p>
    #[doc(hidden)]
    pub exclusions: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The name of a connection which allows a job or crawler to access data in Amazon S3 within an Amazon Virtual Private Cloud environment (Amazon VPC).</p>
    #[doc(hidden)]
    pub connection_name: std::option::Option<std::string::String>,
    /// <p>Sets the number of files in each leaf folder to be crawled when crawling sample files in a dataset. If not set, all the files are crawled. A valid value is an integer between 1 and 249.</p>
    #[doc(hidden)]
    pub sample_size: std::option::Option<i32>,
    /// <p>A valid Amazon SQS ARN. For example, <code>arn:aws:sqs:region:account:sqs</code>.</p>
    #[doc(hidden)]
    pub event_queue_arn: std::option::Option<std::string::String>,
    /// <p>A valid Amazon dead-letter SQS ARN. For example, <code>arn:aws:sqs:region:account:deadLetterQueue</code>.</p>
    #[doc(hidden)]
    pub dlq_event_queue_arn: std::option::Option<std::string::String>,
}
impl S3Target {
    /// <p>The path to the Amazon S3 target.</p>
    pub fn path(&self) -> std::option::Option<&str> {
        self.path.as_deref()
    }
    /// <p>A list of glob patterns used to exclude from the crawl. For more information, see <a href="https://docs.aws.amazon.com/glue/latest/dg/add-crawler.html">Catalog Tables with a Crawler</a>.</p>
    pub fn exclusions(&self) -> std::option::Option<&[std::string::String]> {
        self.exclusions.as_deref()
    }
    /// <p>The name of a connection which allows a job or crawler to access data in Amazon S3 within an Amazon Virtual Private Cloud environment (Amazon VPC).</p>
    pub fn connection_name(&self) -> std::option::Option<&str> {
        self.connection_name.as_deref()
    }
    /// <p>Sets the number of files in each leaf folder to be crawled when crawling sample files in a dataset. If not set, all the files are crawled. A valid value is an integer between 1 and 249.</p>
    pub fn sample_size(&self) -> std::option::Option<i32> {
        self.sample_size
    }
    /// <p>A valid Amazon SQS ARN. For example, <code>arn:aws:sqs:region:account:sqs</code>.</p>
    pub fn event_queue_arn(&self) -> std::option::Option<&str> {
        self.event_queue_arn.as_deref()
    }
    /// <p>A valid Amazon dead-letter SQS ARN. For example, <code>arn:aws:sqs:region:account:deadLetterQueue</code>.</p>
    pub fn dlq_event_queue_arn(&self) -> std::option::Option<&str> {
        self.dlq_event_queue_arn.as_deref()
    }
}
/// See [`S3Target`](crate::model::S3Target).
pub mod s3_target {

    /// A builder for [`S3Target`](crate::model::S3Target).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) path: std::option::Option<std::string::String>,
        pub(crate) exclusions: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) connection_name: std::option::Option<std::string::String>,
        pub(crate) sample_size: std::option::Option<i32>,
        pub(crate) event_queue_arn: std::option::Option<std::string::String>,
        pub(crate) dlq_event_queue_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The path to the Amazon S3 target.</p>
        pub fn path(mut self, input: impl Into<std::string::String>) -> Self {
            self.path = Some(input.into());
            self
        }
        /// <p>The path to the Amazon S3 target.</p>
        pub fn set_path(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.path = input;
            self
        }
        /// Appends an item to `exclusions`.
        ///
        /// To override the contents of this collection use [`set_exclusions`](Self::set_exclusions).
        ///
        /// <p>A list of glob patterns used to exclude from the crawl. For more information, see <a href="https://docs.aws.amazon.com/glue/latest/dg/add-crawler.html">Catalog Tables with a Crawler</a>.</p>
        pub fn exclusions(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.exclusions.unwrap_or_default();
            v.push(input.into());
            self.exclusions = Some(v);
            self
        }
        /// <p>A list of glob patterns used to exclude from the crawl. For more information, see <a href="https://docs.aws.amazon.com/glue/latest/dg/add-crawler.html">Catalog Tables with a Crawler</a>.</p>
        pub fn set_exclusions(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.exclusions = input;
            self
        }
        /// <p>The name of a connection which allows a job or crawler to access data in Amazon S3 within an Amazon Virtual Private Cloud environment (Amazon VPC).</p>
        pub fn connection_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.connection_name = Some(input.into());
            self
        }
        /// <p>The name of a connection which allows a job or crawler to access data in Amazon S3 within an Amazon Virtual Private Cloud environment (Amazon VPC).</p>
        pub fn set_connection_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.connection_name = input;
            self
        }
        /// <p>Sets the number of files in each leaf folder to be crawled when crawling sample files in a dataset. If not set, all the files are crawled. A valid value is an integer between 1 and 249.</p>
        pub fn sample_size(mut self, input: i32) -> Self {
            self.sample_size = Some(input);
            self
        }
        /// <p>Sets the number of files in each leaf folder to be crawled when crawling sample files in a dataset. If not set, all the files are crawled. A valid value is an integer between 1 and 249.</p>
        pub fn set_sample_size(mut self, input: std::option::Option<i32>) -> Self {
            self.sample_size = input;
            self
        }
        /// <p>A valid Amazon SQS ARN. For example, <code>arn:aws:sqs:region:account:sqs</code>.</p>
        pub fn event_queue_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.event_queue_arn = Some(input.into());
            self
        }
        /// <p>A valid Amazon SQS ARN. For example, <code>arn:aws:sqs:region:account:sqs</code>.</p>
        pub fn set_event_queue_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.event_queue_arn = input;
            self
        }
        /// <p>A valid Amazon dead-letter SQS ARN. For example, <code>arn:aws:sqs:region:account:deadLetterQueue</code>.</p>
        pub fn dlq_event_queue_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.dlq_event_queue_arn = Some(input.into());
            self
        }
        /// <p>A valid Amazon dead-letter SQS ARN. For example, <code>arn:aws:sqs:region:account:deadLetterQueue</code>.</p>
        pub fn set_dlq_event_queue_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.dlq_event_queue_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`S3Target`](crate::model::S3Target).
        pub fn build(self) -> crate::model::S3Target {
            crate::model::S3Target {
                path: self.path,
                exclusions: self.exclusions,
                connection_name: self.connection_name,
                sample_size: self.sample_size,
                event_queue_arn: self.event_queue_arn,
                dlq_event_queue_arn: self.dlq_event_queue_arn,
            }
        }
    }
}
impl S3Target {
    /// Creates a new builder-style object to manufacture [`S3Target`](crate::model::S3Target).
    pub fn builder() -> crate::model::s3_target::Builder {
        crate::model::s3_target::Builder::default()
    }
}

/// <p>A structure that is used to specify a connection to create or update.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ConnectionInput {
    /// <p>The name of the connection.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The description of the connection.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The type of the connection. Currently, these types are supported:</p>
    /// <ul>
    /// <li> <p> <code>JDBC</code> - Designates a connection to a database through Java Database Connectivity (JDBC).</p> </li>
    /// <li> <p> <code>KAFKA</code> - Designates a connection to an Apache Kafka streaming platform.</p> </li>
    /// <li> <p> <code>MONGODB</code> - Designates a connection to a MongoDB document database.</p> </li>
    /// <li> <p> <code>NETWORK</code> - Designates a network connection to a data source within an Amazon Virtual Private Cloud environment (Amazon VPC).</p> </li>
    /// <li> <p> <code>MARKETPLACE</code> - Uses configuration settings contained in a connector purchased from Amazon Web Services Marketplace to read from and write to data stores that are not natively supported by Glue.</p> </li>
    /// <li> <p> <code>CUSTOM</code> - Uses configuration settings contained in a custom connector to read from and write to data stores that are not natively supported by Glue.</p> </li>
    /// </ul>
    /// <p>SFTP is not supported.</p>
    #[doc(hidden)]
    pub connection_type: std::option::Option<crate::model::ConnectionType>,
    /// <p>A list of criteria that can be used in selecting this connection.</p>
    #[doc(hidden)]
    pub match_criteria: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>These key-value pairs define parameters for the connection.</p>
    #[doc(hidden)]
    pub connection_properties: std::option::Option<
        std::collections::HashMap<crate::model::ConnectionPropertyKey, std::string::String>,
    >,
    /// <p>A map of physical connection requirements, such as virtual private cloud (VPC) and <code>SecurityGroup</code>, that are needed to successfully make this connection.</p>
    #[doc(hidden)]
    pub physical_connection_requirements:
        std::option::Option<crate::model::PhysicalConnectionRequirements>,
}
impl ConnectionInput {
    /// <p>The name of the connection.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The description of the connection.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The type of the connection. Currently, these types are supported:</p>
    /// <ul>
    /// <li> <p> <code>JDBC</code> - Designates a connection to a database through Java Database Connectivity (JDBC).</p> </li>
    /// <li> <p> <code>KAFKA</code> - Designates a connection to an Apache Kafka streaming platform.</p> </li>
    /// <li> <p> <code>MONGODB</code> - Designates a connection to a MongoDB document database.</p> </li>
    /// <li> <p> <code>NETWORK</code> - Designates a network connection to a data source within an Amazon Virtual Private Cloud environment (Amazon VPC).</p> </li>
    /// <li> <p> <code>MARKETPLACE</code> - Uses configuration settings contained in a connector purchased from Amazon Web Services Marketplace to read from and write to data stores that are not natively supported by Glue.</p> </li>
    /// <li> <p> <code>CUSTOM</code> - Uses configuration settings contained in a custom connector to read from and write to data stores that are not natively supported by Glue.</p> </li>
    /// </ul>
    /// <p>SFTP is not supported.</p>
    pub fn connection_type(&self) -> std::option::Option<&crate::model::ConnectionType> {
        self.connection_type.as_ref()
    }
    /// <p>A list of criteria that can be used in selecting this connection.</p>
    pub fn match_criteria(&self) -> std::option::Option<&[std::string::String]> {
        self.match_criteria.as_deref()
    }
    /// <p>These key-value pairs define parameters for the connection.</p>
    pub fn connection_properties(
        &self,
    ) -> std::option::Option<
        &std::collections::HashMap<crate::model::ConnectionPropertyKey, std::string::String>,
    > {
        self.connection_properties.as_ref()
    }
    /// <p>A map of physical connection requirements, such as virtual private cloud (VPC) and <code>SecurityGroup</code>, that are needed to successfully make this connection.</p>
    pub fn physical_connection_requirements(
        &self,
    ) -> std::option::Option<&crate::model::PhysicalConnectionRequirements> {
        self.physical_connection_requirements.as_ref()
    }
}
/// See [`ConnectionInput`](crate::model::ConnectionInput).
pub mod connection_input {

    /// A builder for [`ConnectionInput`](crate::model::ConnectionInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) connection_type: std::option::Option<crate::model::ConnectionType>,
        pub(crate) match_criteria: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) connection_properties: std::option::Option<
            std::collections::HashMap<crate::model::ConnectionPropertyKey, std::string::String>,
        >,
        pub(crate) physical_connection_requirements:
            std::option::Option<crate::model::PhysicalConnectionRequirements>,
    }
    impl Builder {
        /// <p>The name of the connection.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the connection.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The description of the connection.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the connection.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The type of the connection. Currently, these types are supported:</p>
        /// <ul>
        /// <li> <p> <code>JDBC</code> - Designates a connection to a database through Java Database Connectivity (JDBC).</p> </li>
        /// <li> <p> <code>KAFKA</code> - Designates a connection to an Apache Kafka streaming platform.</p> </li>
        /// <li> <p> <code>MONGODB</code> - Designates a connection to a MongoDB document database.</p> </li>
        /// <li> <p> <code>NETWORK</code> - Designates a network connection to a data source within an Amazon Virtual Private Cloud environment (Amazon VPC).</p> </li>
        /// <li> <p> <code>MARKETPLACE</code> - Uses configuration settings contained in a connector purchased from Amazon Web Services Marketplace to read from and write to data stores that are not natively supported by Glue.</p> </li>
        /// <li> <p> <code>CUSTOM</code> - Uses configuration settings contained in a custom connector to read from and write to data stores that are not natively supported by Glue.</p> </li>
        /// </ul>
        /// <p>SFTP is not supported.</p>
        pub fn connection_type(mut self, input: crate::model::ConnectionType) -> Self {
            self.connection_type = Some(input);
            self
        }
        /// <p>The type of the connection. Currently, these types are supported:</p>
        /// <ul>
        /// <li> <p> <code>JDBC</code> - Designates a connection to a database through Java Database Connectivity (JDBC).</p> </li>
        /// <li> <p> <code>KAFKA</code> - Designates a connection to an Apache Kafka streaming platform.</p> </li>
        /// <li> <p> <code>MONGODB</code> - Designates a connection to a MongoDB document database.</p> </li>
        /// <li> <p> <code>NETWORK</code> - Designates a network connection to a data source within an Amazon Virtual Private Cloud environment (Amazon VPC).</p> </li>
        /// <li> <p> <code>MARKETPLACE</code> - Uses configuration settings contained in a connector purchased from Amazon Web Services Marketplace to read from and write to data stores that are not natively supported by Glue.</p> </li>
        /// <li> <p> <code>CUSTOM</code> - Uses configuration settings contained in a custom connector to read from and write to data stores that are not natively supported by Glue.</p> </li>
        /// </ul>
        /// <p>SFTP is not supported.</p>
        pub fn set_connection_type(
            mut self,
            input: std::option::Option<crate::model::ConnectionType>,
        ) -> Self {
            self.connection_type = input;
            self
        }
        /// Appends an item to `match_criteria`.
        ///
        /// To override the contents of this collection use [`set_match_criteria`](Self::set_match_criteria).
        ///
        /// <p>A list of criteria that can be used in selecting this connection.</p>
        pub fn match_criteria(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.match_criteria.unwrap_or_default();
            v.push(input.into());
            self.match_criteria = Some(v);
            self
        }
        /// <p>A list of criteria that can be used in selecting this connection.</p>
        pub fn set_match_criteria(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.match_criteria = input;
            self
        }
        /// Adds a key-value pair to `connection_properties`.
        ///
        /// To override the contents of this collection use [`set_connection_properties`](Self::set_connection_properties).
        ///
        /// <p>These key-value pairs define parameters for the connection.</p>
        pub fn connection_properties(
            mut self,
            k: crate::model::ConnectionPropertyKey,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.connection_properties.unwrap_or_default();
            hash_map.insert(k, v.into());
            self.connection_properties = Some(hash_map);
            self
        }
        /// <p>These key-value pairs define parameters for the connection.</p>
        pub fn set_connection_properties(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<crate::model::ConnectionPropertyKey, std::string::String>,
            >,
        ) -> Self {
            self.connection_properties = input;
            self
        }
        /// <p>A map of physical connection requirements, such as virtual private cloud (VPC) and <code>SecurityGroup</code>, that are needed to successfully make this connection.</p>
        pub fn physical_connection_requirements(
            mut self,
            input: crate::model::PhysicalConnectionRequirements,
        ) -> Self {
            self.physical_connection_requirements = Some(input);
            self
        }
        /// <p>A map of physical connection requirements, such as virtual private cloud (VPC) and <code>SecurityGroup</code>, that are needed to successfully make this connection.</p>
        pub fn set_physical_connection_requirements(
            mut self,
            input: std::option::Option<crate::model::PhysicalConnectionRequirements>,
        ) -> Self {
            self.physical_connection_requirements = input;
            self
        }
        /// Consumes the builder and constructs a [`ConnectionInput`](crate::model::ConnectionInput).
        pub fn build(self) -> crate::model::ConnectionInput {
            crate::model::ConnectionInput {
                name: self.name,
                description: self.description,
                connection_type: self.connection_type,
                match_criteria: self.match_criteria,
                connection_properties: self.connection_properties,
                physical_connection_requirements: self.physical_connection_requirements,
            }
        }
    }
}
impl ConnectionInput {
    /// Creates a new builder-style object to manufacture [`ConnectionInput`](crate::model::ConnectionInput).
    pub fn builder() -> crate::model::connection_input::Builder {
        crate::model::connection_input::Builder::default()
    }
}

/// <p>Specifies the physical requirements for a connection.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PhysicalConnectionRequirements {
    /// <p>The subnet ID used by the connection.</p>
    #[doc(hidden)]
    pub subnet_id: std::option::Option<std::string::String>,
    /// <p>The security group ID list used by the connection.</p>
    #[doc(hidden)]
    pub security_group_id_list: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The connection's Availability Zone. This field is redundant because the specified subnet implies the Availability Zone to be used. Currently the field must be populated, but it will be deprecated in the future.</p>
    #[doc(hidden)]
    pub availability_zone: std::option::Option<std::string::String>,
}
impl PhysicalConnectionRequirements {
    /// <p>The subnet ID used by the connection.</p>
    pub fn subnet_id(&self) -> std::option::Option<&str> {
        self.subnet_id.as_deref()
    }
    /// <p>The security group ID list used by the connection.</p>
    pub fn security_group_id_list(&self) -> std::option::Option<&[std::string::String]> {
        self.security_group_id_list.as_deref()
    }
    /// <p>The connection's Availability Zone. This field is redundant because the specified subnet implies the Availability Zone to be used. Currently the field must be populated, but it will be deprecated in the future.</p>
    pub fn availability_zone(&self) -> std::option::Option<&str> {
        self.availability_zone.as_deref()
    }
}
/// See [`PhysicalConnectionRequirements`](crate::model::PhysicalConnectionRequirements).
pub mod physical_connection_requirements {

    /// A builder for [`PhysicalConnectionRequirements`](crate::model::PhysicalConnectionRequirements).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) subnet_id: std::option::Option<std::string::String>,
        pub(crate) security_group_id_list: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) availability_zone: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The subnet ID used by the connection.</p>
        pub fn subnet_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.subnet_id = Some(input.into());
            self
        }
        /// <p>The subnet ID used by the connection.</p>
        pub fn set_subnet_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.subnet_id = input;
            self
        }
        /// Appends an item to `security_group_id_list`.
        ///
        /// To override the contents of this collection use [`set_security_group_id_list`](Self::set_security_group_id_list).
        ///
        /// <p>The security group ID list used by the connection.</p>
        pub fn security_group_id_list(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.security_group_id_list.unwrap_or_default();
            v.push(input.into());
            self.security_group_id_list = Some(v);
            self
        }
        /// <p>The security group ID list used by the connection.</p>
        pub fn set_security_group_id_list(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.security_group_id_list = input;
            self
        }
        /// <p>The connection's Availability Zone. This field is redundant because the specified subnet implies the Availability Zone to be used. Currently the field must be populated, but it will be deprecated in the future.</p>
        pub fn availability_zone(mut self, input: impl Into<std::string::String>) -> Self {
            self.availability_zone = Some(input.into());
            self
        }
        /// <p>The connection's Availability Zone. This field is redundant because the specified subnet implies the Availability Zone to be used. Currently the field must be populated, but it will be deprecated in the future.</p>
        pub fn set_availability_zone(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.availability_zone = input;
            self
        }
        /// Consumes the builder and constructs a [`PhysicalConnectionRequirements`](crate::model::PhysicalConnectionRequirements).
        pub fn build(self) -> crate::model::PhysicalConnectionRequirements {
            crate::model::PhysicalConnectionRequirements {
                subnet_id: self.subnet_id,
                security_group_id_list: self.security_group_id_list,
                availability_zone: self.availability_zone,
            }
        }
    }
}
impl PhysicalConnectionRequirements {
    /// Creates a new builder-style object to manufacture [`PhysicalConnectionRequirements`](crate::model::PhysicalConnectionRequirements).
    pub fn builder() -> crate::model::physical_connection_requirements::Builder {
        crate::model::physical_connection_requirements::Builder::default()
    }
}

/// When writing a match expression against `ConnectionPropertyKey`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let connectionpropertykey = unimplemented!();
/// match connectionpropertykey {
///     ConnectionPropertyKey::ConfigFiles => { /* ... */ },
///     ConnectionPropertyKey::ConnectionUrl => { /* ... */ },
///     ConnectionPropertyKey::ConnectorClassName => { /* ... */ },
///     ConnectionPropertyKey::ConnectorType => { /* ... */ },
///     ConnectionPropertyKey::ConnectorUrl => { /* ... */ },
///     ConnectionPropertyKey::CustomJdbcCert => { /* ... */ },
///     ConnectionPropertyKey::CustomJdbcCertString => { /* ... */ },
///     ConnectionPropertyKey::EncryptedKafkaClientKeystorePassword => { /* ... */ },
///     ConnectionPropertyKey::EncryptedKafkaClientKeyPassword => { /* ... */ },
///     ConnectionPropertyKey::EncryptedPassword => { /* ... */ },
///     ConnectionPropertyKey::Host => { /* ... */ },
///     ConnectionPropertyKey::InstanceId => { /* ... */ },
///     ConnectionPropertyKey::JdbcConnectionUrl => { /* ... */ },
///     ConnectionPropertyKey::JdbcDriverClassName => { /* ... */ },
///     ConnectionPropertyKey::JdbcDriverJarUri => { /* ... */ },
///     ConnectionPropertyKey::JdbcEnforceSsl => { /* ... */ },
///     ConnectionPropertyKey::JdbcEngine => { /* ... */ },
///     ConnectionPropertyKey::JdbcEngineVersion => { /* ... */ },
///     ConnectionPropertyKey::KafkaBootstrapServers => { /* ... */ },
///     ConnectionPropertyKey::KafkaClientKeystore => { /* ... */ },
///     ConnectionPropertyKey::KafkaClientKeystorePassword => { /* ... */ },
///     ConnectionPropertyKey::KafkaClientKeyPassword => { /* ... */ },
///     ConnectionPropertyKey::KafkaCustomCert => { /* ... */ },
///     ConnectionPropertyKey::KafkaSkipCustomCertValidation => { /* ... */ },
///     ConnectionPropertyKey::KafkaSslEnabled => { /* ... */ },
///     ConnectionPropertyKey::Password => { /* ... */ },
///     ConnectionPropertyKey::Port => { /* ... */ },
///     ConnectionPropertyKey::SecretId => { /* ... */ },
///     ConnectionPropertyKey::SkipCustomJdbcCertValidation => { /* ... */ },
///     ConnectionPropertyKey::UserName => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `connectionpropertykey` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ConnectionPropertyKey::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ConnectionPropertyKey::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ConnectionPropertyKey::NewFeature` is defined.
/// Specifically, when `connectionpropertykey` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ConnectionPropertyKey::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ConnectionPropertyKey {
    #[allow(missing_docs)] // documentation missing in model
    ConfigFiles,
    #[allow(missing_docs)] // documentation missing in model
    ConnectionUrl,
    #[allow(missing_docs)] // documentation missing in model
    ConnectorClassName,
    #[allow(missing_docs)] // documentation missing in model
    ConnectorType,
    #[allow(missing_docs)] // documentation missing in model
    ConnectorUrl,
    #[allow(missing_docs)] // documentation missing in model
    CustomJdbcCert,
    #[allow(missing_docs)] // documentation missing in model
    CustomJdbcCertString,
    #[allow(missing_docs)] // documentation missing in model
    EncryptedKafkaClientKeystorePassword,
    #[allow(missing_docs)] // documentation missing in model
    EncryptedKafkaClientKeyPassword,
    #[allow(missing_docs)] // documentation missing in model
    EncryptedPassword,
    #[allow(missing_docs)] // documentation missing in model
    Host,
    #[allow(missing_docs)] // documentation missing in model
    InstanceId,
    #[allow(missing_docs)] // documentation missing in model
    JdbcConnectionUrl,
    #[allow(missing_docs)] // documentation missing in model
    JdbcDriverClassName,
    #[allow(missing_docs)] // documentation missing in model
    JdbcDriverJarUri,
    #[allow(missing_docs)] // documentation missing in model
    JdbcEnforceSsl,
    #[allow(missing_docs)] // documentation missing in model
    JdbcEngine,
    #[allow(missing_docs)] // documentation missing in model
    JdbcEngineVersion,
    #[allow(missing_docs)] // documentation missing in model
    KafkaBootstrapServers,
    #[allow(missing_docs)] // documentation missing in model
    KafkaClientKeystore,
    #[allow(missing_docs)] // documentation missing in model
    KafkaClientKeystorePassword,
    #[allow(missing_docs)] // documentation missing in model
    KafkaClientKeyPassword,
    #[allow(missing_docs)] // documentation missing in model
    KafkaCustomCert,
    #[allow(missing_docs)] // documentation missing in model
    KafkaSkipCustomCertValidation,
    #[allow(missing_docs)] // documentation missing in model
    KafkaSslEnabled,
    #[allow(missing_docs)] // documentation missing in model
    Password,
    #[allow(missing_docs)] // documentation missing in model
    Port,
    #[allow(missing_docs)] // documentation missing in model
    SecretId,
    #[allow(missing_docs)] // documentation missing in model
    SkipCustomJdbcCertValidation,
    #[allow(missing_docs)] // documentation missing in model
    UserName,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ConnectionPropertyKey {
    fn from(s: &str) -> Self {
        match s {
            "CONFIG_FILES" => ConnectionPropertyKey::ConfigFiles,
            "CONNECTION_URL" => ConnectionPropertyKey::ConnectionUrl,
            "CONNECTOR_CLASS_NAME" => ConnectionPropertyKey::ConnectorClassName,
            "CONNECTOR_TYPE" => ConnectionPropertyKey::ConnectorType,
            "CONNECTOR_URL" => ConnectionPropertyKey::ConnectorUrl,
            "CUSTOM_JDBC_CERT" => ConnectionPropertyKey::CustomJdbcCert,
            "CUSTOM_JDBC_CERT_STRING" => ConnectionPropertyKey::CustomJdbcCertString,
            "ENCRYPTED_KAFKA_CLIENT_KEYSTORE_PASSWORD" => {
                ConnectionPropertyKey::EncryptedKafkaClientKeystorePassword
            }
            "ENCRYPTED_KAFKA_CLIENT_KEY_PASSWORD" => {
                ConnectionPropertyKey::EncryptedKafkaClientKeyPassword
            }
            "ENCRYPTED_PASSWORD" => ConnectionPropertyKey::EncryptedPassword,
            "HOST" => ConnectionPropertyKey::Host,
            "INSTANCE_ID" => ConnectionPropertyKey::InstanceId,
            "JDBC_CONNECTION_URL" => ConnectionPropertyKey::JdbcConnectionUrl,
            "JDBC_DRIVER_CLASS_NAME" => ConnectionPropertyKey::JdbcDriverClassName,
            "JDBC_DRIVER_JAR_URI" => ConnectionPropertyKey::JdbcDriverJarUri,
            "JDBC_ENFORCE_SSL" => ConnectionPropertyKey::JdbcEnforceSsl,
            "JDBC_ENGINE" => ConnectionPropertyKey::JdbcEngine,
            "JDBC_ENGINE_VERSION" => ConnectionPropertyKey::JdbcEngineVersion,
            "KAFKA_BOOTSTRAP_SERVERS" => ConnectionPropertyKey::KafkaBootstrapServers,
            "KAFKA_CLIENT_KEYSTORE" => ConnectionPropertyKey::KafkaClientKeystore,
            "KAFKA_CLIENT_KEYSTORE_PASSWORD" => ConnectionPropertyKey::KafkaClientKeystorePassword,
            "KAFKA_CLIENT_KEY_PASSWORD" => ConnectionPropertyKey::KafkaClientKeyPassword,
            "KAFKA_CUSTOM_CERT" => ConnectionPropertyKey::KafkaCustomCert,
            "KAFKA_SKIP_CUSTOM_CERT_VALIDATION" => {
                ConnectionPropertyKey::KafkaSkipCustomCertValidation
            }
            "KAFKA_SSL_ENABLED" => ConnectionPropertyKey::KafkaSslEnabled,
            "PASSWORD" => ConnectionPropertyKey::Password,
            "PORT" => ConnectionPropertyKey::Port,
            "SECRET_ID" => ConnectionPropertyKey::SecretId,
            "SKIP_CUSTOM_JDBC_CERT_VALIDATION" => {
                ConnectionPropertyKey::SkipCustomJdbcCertValidation
            }
            "USERNAME" => ConnectionPropertyKey::UserName,
            other => {
                ConnectionPropertyKey::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for ConnectionPropertyKey {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ConnectionPropertyKey::from(s))
    }
}
impl ConnectionPropertyKey {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ConnectionPropertyKey::ConfigFiles => "CONFIG_FILES",
            ConnectionPropertyKey::ConnectionUrl => "CONNECTION_URL",
            ConnectionPropertyKey::ConnectorClassName => "CONNECTOR_CLASS_NAME",
            ConnectionPropertyKey::ConnectorType => "CONNECTOR_TYPE",
            ConnectionPropertyKey::ConnectorUrl => "CONNECTOR_URL",
            ConnectionPropertyKey::CustomJdbcCert => "CUSTOM_JDBC_CERT",
            ConnectionPropertyKey::CustomJdbcCertString => "CUSTOM_JDBC_CERT_STRING",
            ConnectionPropertyKey::EncryptedKafkaClientKeystorePassword => {
                "ENCRYPTED_KAFKA_CLIENT_KEYSTORE_PASSWORD"
            }
            ConnectionPropertyKey::EncryptedKafkaClientKeyPassword => {
                "ENCRYPTED_KAFKA_CLIENT_KEY_PASSWORD"
            }
            ConnectionPropertyKey::EncryptedPassword => "ENCRYPTED_PASSWORD",
            ConnectionPropertyKey::Host => "HOST",
            ConnectionPropertyKey::InstanceId => "INSTANCE_ID",
            ConnectionPropertyKey::JdbcConnectionUrl => "JDBC_CONNECTION_URL",
            ConnectionPropertyKey::JdbcDriverClassName => "JDBC_DRIVER_CLASS_NAME",
            ConnectionPropertyKey::JdbcDriverJarUri => "JDBC_DRIVER_JAR_URI",
            ConnectionPropertyKey::JdbcEnforceSsl => "JDBC_ENFORCE_SSL",
            ConnectionPropertyKey::JdbcEngine => "JDBC_ENGINE",
            ConnectionPropertyKey::JdbcEngineVersion => "JDBC_ENGINE_VERSION",
            ConnectionPropertyKey::KafkaBootstrapServers => "KAFKA_BOOTSTRAP_SERVERS",
            ConnectionPropertyKey::KafkaClientKeystore => "KAFKA_CLIENT_KEYSTORE",
            ConnectionPropertyKey::KafkaClientKeystorePassword => "KAFKA_CLIENT_KEYSTORE_PASSWORD",
            ConnectionPropertyKey::KafkaClientKeyPassword => "KAFKA_CLIENT_KEY_PASSWORD",
            ConnectionPropertyKey::KafkaCustomCert => "KAFKA_CUSTOM_CERT",
            ConnectionPropertyKey::KafkaSkipCustomCertValidation => {
                "KAFKA_SKIP_CUSTOM_CERT_VALIDATION"
            }
            ConnectionPropertyKey::KafkaSslEnabled => "KAFKA_SSL_ENABLED",
            ConnectionPropertyKey::Password => "PASSWORD",
            ConnectionPropertyKey::Port => "PORT",
            ConnectionPropertyKey::SecretId => "SECRET_ID",
            ConnectionPropertyKey::SkipCustomJdbcCertValidation => {
                "SKIP_CUSTOM_JDBC_CERT_VALIDATION"
            }
            ConnectionPropertyKey::UserName => "USERNAME",
            ConnectionPropertyKey::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "CONFIG_FILES",
            "CONNECTION_URL",
            "CONNECTOR_CLASS_NAME",
            "CONNECTOR_TYPE",
            "CONNECTOR_URL",
            "CUSTOM_JDBC_CERT",
            "CUSTOM_JDBC_CERT_STRING",
            "ENCRYPTED_KAFKA_CLIENT_KEYSTORE_PASSWORD",
            "ENCRYPTED_KAFKA_CLIENT_KEY_PASSWORD",
            "ENCRYPTED_PASSWORD",
            "HOST",
            "INSTANCE_ID",
            "JDBC_CONNECTION_URL",
            "JDBC_DRIVER_CLASS_NAME",
            "JDBC_DRIVER_JAR_URI",
            "JDBC_ENFORCE_SSL",
            "JDBC_ENGINE",
            "JDBC_ENGINE_VERSION",
            "KAFKA_BOOTSTRAP_SERVERS",
            "KAFKA_CLIENT_KEYSTORE",
            "KAFKA_CLIENT_KEYSTORE_PASSWORD",
            "KAFKA_CLIENT_KEY_PASSWORD",
            "KAFKA_CUSTOM_CERT",
            "KAFKA_SKIP_CUSTOM_CERT_VALIDATION",
            "KAFKA_SSL_ENABLED",
            "PASSWORD",
            "PORT",
            "SECRET_ID",
            "SKIP_CUSTOM_JDBC_CERT_VALIDATION",
            "USERNAME",
        ]
    }
}
impl AsRef<str> for ConnectionPropertyKey {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `ConnectionType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let connectiontype = unimplemented!();
/// match connectiontype {
///     ConnectionType::Custom => { /* ... */ },
///     ConnectionType::Jdbc => { /* ... */ },
///     ConnectionType::Kafka => { /* ... */ },
///     ConnectionType::Marketplace => { /* ... */ },
///     ConnectionType::Mongodb => { /* ... */ },
///     ConnectionType::Network => { /* ... */ },
///     ConnectionType::Sftp => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `connectiontype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ConnectionType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ConnectionType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ConnectionType::NewFeature` is defined.
/// Specifically, when `connectiontype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ConnectionType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ConnectionType {
    #[allow(missing_docs)] // documentation missing in model
    Custom,
    #[allow(missing_docs)] // documentation missing in model
    Jdbc,
    #[allow(missing_docs)] // documentation missing in model
    Kafka,
    #[allow(missing_docs)] // documentation missing in model
    Marketplace,
    #[allow(missing_docs)] // documentation missing in model
    Mongodb,
    #[allow(missing_docs)] // documentation missing in model
    Network,
    #[allow(missing_docs)] // documentation missing in model
    Sftp,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ConnectionType {
    fn from(s: &str) -> Self {
        match s {
            "CUSTOM" => ConnectionType::Custom,
            "JDBC" => ConnectionType::Jdbc,
            "KAFKA" => ConnectionType::Kafka,
            "MARKETPLACE" => ConnectionType::Marketplace,
            "MONGODB" => ConnectionType::Mongodb,
            "NETWORK" => ConnectionType::Network,
            "SFTP" => ConnectionType::Sftp,
            other => ConnectionType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ConnectionType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ConnectionType::from(s))
    }
}
impl ConnectionType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ConnectionType::Custom => "CUSTOM",
            ConnectionType::Jdbc => "JDBC",
            ConnectionType::Kafka => "KAFKA",
            ConnectionType::Marketplace => "MARKETPLACE",
            ConnectionType::Mongodb => "MONGODB",
            ConnectionType::Network => "NETWORK",
            ConnectionType::Sftp => "SFTP",
            ConnectionType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "CUSTOM",
            "JDBC",
            "KAFKA",
            "MARKETPLACE",
            "MONGODB",
            "NETWORK",
            "SFTP",
        ]
    }
}
impl AsRef<str> for ConnectionType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Encapsulates a <code>ColumnStatistics</code> object that failed and the reason for failure.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ColumnStatisticsError {
    /// <p>The <code>ColumnStatistics</code> of the column.</p>
    #[doc(hidden)]
    pub column_statistics: std::option::Option<crate::model::ColumnStatistics>,
    /// <p>An error message with the reason for the failure of an operation.</p>
    #[doc(hidden)]
    pub error: std::option::Option<crate::model::ErrorDetail>,
}
impl ColumnStatisticsError {
    /// <p>The <code>ColumnStatistics</code> of the column.</p>
    pub fn column_statistics(&self) -> std::option::Option<&crate::model::ColumnStatistics> {
        self.column_statistics.as_ref()
    }
    /// <p>An error message with the reason for the failure of an operation.</p>
    pub fn error(&self) -> std::option::Option<&crate::model::ErrorDetail> {
        self.error.as_ref()
    }
}
/// See [`ColumnStatisticsError`](crate::model::ColumnStatisticsError).
pub mod column_statistics_error {

    /// A builder for [`ColumnStatisticsError`](crate::model::ColumnStatisticsError).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) column_statistics: std::option::Option<crate::model::ColumnStatistics>,
        pub(crate) error: std::option::Option<crate::model::ErrorDetail>,
    }
    impl Builder {
        /// <p>The <code>ColumnStatistics</code> of the column.</p>
        pub fn column_statistics(mut self, input: crate::model::ColumnStatistics) -> Self {
            self.column_statistics = Some(input);
            self
        }
        /// <p>The <code>ColumnStatistics</code> of the column.</p>
        pub fn set_column_statistics(
            mut self,
            input: std::option::Option<crate::model::ColumnStatistics>,
        ) -> Self {
            self.column_statistics = input;
            self
        }
        /// <p>An error message with the reason for the failure of an operation.</p>
        pub fn error(mut self, input: crate::model::ErrorDetail) -> Self {
            self.error = Some(input);
            self
        }
        /// <p>An error message with the reason for the failure of an operation.</p>
        pub fn set_error(mut self, input: std::option::Option<crate::model::ErrorDetail>) -> Self {
            self.error = input;
            self
        }
        /// Consumes the builder and constructs a [`ColumnStatisticsError`](crate::model::ColumnStatisticsError).
        pub fn build(self) -> crate::model::ColumnStatisticsError {
            crate::model::ColumnStatisticsError {
                column_statistics: self.column_statistics,
                error: self.error,
            }
        }
    }
}
impl ColumnStatisticsError {
    /// Creates a new builder-style object to manufacture [`ColumnStatisticsError`](crate::model::ColumnStatisticsError).
    pub fn builder() -> crate::model::column_statistics_error::Builder {
        crate::model::column_statistics_error::Builder::default()
    }
}

/// <p>Contains details about an error.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ErrorDetail {
    /// <p>The code associated with this error.</p>
    #[doc(hidden)]
    pub error_code: std::option::Option<std::string::String>,
    /// <p>A message describing the error.</p>
    #[doc(hidden)]
    pub error_message: std::option::Option<std::string::String>,
}
impl ErrorDetail {
    /// <p>The code associated with this error.</p>
    pub fn error_code(&self) -> std::option::Option<&str> {
        self.error_code.as_deref()
    }
    /// <p>A message describing the error.</p>
    pub fn error_message(&self) -> std::option::Option<&str> {
        self.error_message.as_deref()
    }
}
/// See [`ErrorDetail`](crate::model::ErrorDetail).
pub mod error_detail {

    /// A builder for [`ErrorDetail`](crate::model::ErrorDetail).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) error_code: std::option::Option<std::string::String>,
        pub(crate) error_message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The code associated with this error.</p>
        pub fn error_code(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_code = Some(input.into());
            self
        }
        /// <p>The code associated with this error.</p>
        pub fn set_error_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.error_code = input;
            self
        }
        /// <p>A message describing the error.</p>
        pub fn error_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_message = Some(input.into());
            self
        }
        /// <p>A message describing the error.</p>
        pub fn set_error_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.error_message = input;
            self
        }
        /// Consumes the builder and constructs a [`ErrorDetail`](crate::model::ErrorDetail).
        pub fn build(self) -> crate::model::ErrorDetail {
            crate::model::ErrorDetail {
                error_code: self.error_code,
                error_message: self.error_message,
            }
        }
    }
}
impl ErrorDetail {
    /// Creates a new builder-style object to manufacture [`ErrorDetail`](crate::model::ErrorDetail).
    pub fn builder() -> crate::model::error_detail::Builder {
        crate::model::error_detail::Builder::default()
    }
}

/// <p>Represents the generated column-level statistics for a table or partition.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ColumnStatistics {
    /// <p>Name of column which statistics belong to.</p>
    #[doc(hidden)]
    pub column_name: std::option::Option<std::string::String>,
    /// <p>The data type of the column.</p>
    #[doc(hidden)]
    pub column_type: std::option::Option<std::string::String>,
    /// <p>The timestamp of when column statistics were generated.</p>
    #[doc(hidden)]
    pub analyzed_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>A <code>ColumnStatisticData</code> object that contains the statistics data values.</p>
    #[doc(hidden)]
    pub statistics_data: std::option::Option<crate::model::ColumnStatisticsData>,
}
impl ColumnStatistics {
    /// <p>Name of column which statistics belong to.</p>
    pub fn column_name(&self) -> std::option::Option<&str> {
        self.column_name.as_deref()
    }
    /// <p>The data type of the column.</p>
    pub fn column_type(&self) -> std::option::Option<&str> {
        self.column_type.as_deref()
    }
    /// <p>The timestamp of when column statistics were generated.</p>
    pub fn analyzed_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.analyzed_time.as_ref()
    }
    /// <p>A <code>ColumnStatisticData</code> object that contains the statistics data values.</p>
    pub fn statistics_data(&self) -> std::option::Option<&crate::model::ColumnStatisticsData> {
        self.statistics_data.as_ref()
    }
}
/// See [`ColumnStatistics`](crate::model::ColumnStatistics).
pub mod column_statistics {

    /// A builder for [`ColumnStatistics`](crate::model::ColumnStatistics).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) column_name: std::option::Option<std::string::String>,
        pub(crate) column_type: std::option::Option<std::string::String>,
        pub(crate) analyzed_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) statistics_data: std::option::Option<crate::model::ColumnStatisticsData>,
    }
    impl Builder {
        /// <p>Name of column which statistics belong to.</p>
        pub fn column_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.column_name = Some(input.into());
            self
        }
        /// <p>Name of column which statistics belong to.</p>
        pub fn set_column_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.column_name = input;
            self
        }
        /// <p>The data type of the column.</p>
        pub fn column_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.column_type = Some(input.into());
            self
        }
        /// <p>The data type of the column.</p>
        pub fn set_column_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.column_type = input;
            self
        }
        /// <p>The timestamp of when column statistics were generated.</p>
        pub fn analyzed_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.analyzed_time = Some(input);
            self
        }
        /// <p>The timestamp of when column statistics were generated.</p>
        pub fn set_analyzed_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.analyzed_time = input;
            self
        }
        /// <p>A <code>ColumnStatisticData</code> object that contains the statistics data values.</p>
        pub fn statistics_data(mut self, input: crate::model::ColumnStatisticsData) -> Self {
            self.statistics_data = Some(input);
            self
        }
        /// <p>A <code>ColumnStatisticData</code> object that contains the statistics data values.</p>
        pub fn set_statistics_data(
            mut self,
            input: std::option::Option<crate::model::ColumnStatisticsData>,
        ) -> Self {
            self.statistics_data = input;
            self
        }
        /// Consumes the builder and constructs a [`ColumnStatistics`](crate::model::ColumnStatistics).
        pub fn build(self) -> crate::model::ColumnStatistics {
            crate::model::ColumnStatistics {
                column_name: self.column_name,
                column_type: self.column_type,
                analyzed_time: self.analyzed_time,
                statistics_data: self.statistics_data,
            }
        }
    }
}
impl ColumnStatistics {
    /// Creates a new builder-style object to manufacture [`ColumnStatistics`](crate::model::ColumnStatistics).
    pub fn builder() -> crate::model::column_statistics::Builder {
        crate::model::column_statistics::Builder::default()
    }
}

/// <p>Contains the individual types of column statistics data. Only one data object should be set and indicated by the <code>Type</code> attribute.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ColumnStatisticsData {
    /// <p>The type of column statistics data.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::ColumnStatisticsType>,
    /// <p>Boolean column statistics data.</p>
    #[doc(hidden)]
    pub boolean_column_statistics_data:
        std::option::Option<crate::model::BooleanColumnStatisticsData>,
    /// <p>Date column statistics data.</p>
    #[doc(hidden)]
    pub date_column_statistics_data: std::option::Option<crate::model::DateColumnStatisticsData>,
    /// <p>Decimal column statistics data.</p>
    #[doc(hidden)]
    pub decimal_column_statistics_data:
        std::option::Option<crate::model::DecimalColumnStatisticsData>,
    /// <p>Double column statistics data.</p>
    #[doc(hidden)]
    pub double_column_statistics_data:
        std::option::Option<crate::model::DoubleColumnStatisticsData>,
    /// <p>Long column statistics data.</p>
    #[doc(hidden)]
    pub long_column_statistics_data: std::option::Option<crate::model::LongColumnStatisticsData>,
    /// <p>String column statistics data.</p>
    #[doc(hidden)]
    pub string_column_statistics_data:
        std::option::Option<crate::model::StringColumnStatisticsData>,
    /// <p>Binary column statistics data.</p>
    #[doc(hidden)]
    pub binary_column_statistics_data:
        std::option::Option<crate::model::BinaryColumnStatisticsData>,
}
impl ColumnStatisticsData {
    /// <p>The type of column statistics data.</p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::ColumnStatisticsType> {
        self.r#type.as_ref()
    }
    /// <p>Boolean column statistics data.</p>
    pub fn boolean_column_statistics_data(
        &self,
    ) -> std::option::Option<&crate::model::BooleanColumnStatisticsData> {
        self.boolean_column_statistics_data.as_ref()
    }
    /// <p>Date column statistics data.</p>
    pub fn date_column_statistics_data(
        &self,
    ) -> std::option::Option<&crate::model::DateColumnStatisticsData> {
        self.date_column_statistics_data.as_ref()
    }
    /// <p>Decimal column statistics data.</p>
    pub fn decimal_column_statistics_data(
        &self,
    ) -> std::option::Option<&crate::model::DecimalColumnStatisticsData> {
        self.decimal_column_statistics_data.as_ref()
    }
    /// <p>Double column statistics data.</p>
    pub fn double_column_statistics_data(
        &self,
    ) -> std::option::Option<&crate::model::DoubleColumnStatisticsData> {
        self.double_column_statistics_data.as_ref()
    }
    /// <p>Long column statistics data.</p>
    pub fn long_column_statistics_data(
        &self,
    ) -> std::option::Option<&crate::model::LongColumnStatisticsData> {
        self.long_column_statistics_data.as_ref()
    }
    /// <p>String column statistics data.</p>
    pub fn string_column_statistics_data(
        &self,
    ) -> std::option::Option<&crate::model::StringColumnStatisticsData> {
        self.string_column_statistics_data.as_ref()
    }
    /// <p>Binary column statistics data.</p>
    pub fn binary_column_statistics_data(
        &self,
    ) -> std::option::Option<&crate::model::BinaryColumnStatisticsData> {
        self.binary_column_statistics_data.as_ref()
    }
}
/// See [`ColumnStatisticsData`](crate::model::ColumnStatisticsData).
pub mod column_statistics_data {

    /// A builder for [`ColumnStatisticsData`](crate::model::ColumnStatisticsData).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<crate::model::ColumnStatisticsType>,
        pub(crate) boolean_column_statistics_data:
            std::option::Option<crate::model::BooleanColumnStatisticsData>,
        pub(crate) date_column_statistics_data:
            std::option::Option<crate::model::DateColumnStatisticsData>,
        pub(crate) decimal_column_statistics_data:
            std::option::Option<crate::model::DecimalColumnStatisticsData>,
        pub(crate) double_column_statistics_data:
            std::option::Option<crate::model::DoubleColumnStatisticsData>,
        pub(crate) long_column_statistics_data:
            std::option::Option<crate::model::LongColumnStatisticsData>,
        pub(crate) string_column_statistics_data:
            std::option::Option<crate::model::StringColumnStatisticsData>,
        pub(crate) binary_column_statistics_data:
            std::option::Option<crate::model::BinaryColumnStatisticsData>,
    }
    impl Builder {
        /// <p>The type of column statistics data.</p>
        pub fn r#type(mut self, input: crate::model::ColumnStatisticsType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The type of column statistics data.</p>
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::ColumnStatisticsType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// <p>Boolean column statistics data.</p>
        pub fn boolean_column_statistics_data(
            mut self,
            input: crate::model::BooleanColumnStatisticsData,
        ) -> Self {
            self.boolean_column_statistics_data = Some(input);
            self
        }
        /// <p>Boolean column statistics data.</p>
        pub fn set_boolean_column_statistics_data(
            mut self,
            input: std::option::Option<crate::model::BooleanColumnStatisticsData>,
        ) -> Self {
            self.boolean_column_statistics_data = input;
            self
        }
        /// <p>Date column statistics data.</p>
        pub fn date_column_statistics_data(
            mut self,
            input: crate::model::DateColumnStatisticsData,
        ) -> Self {
            self.date_column_statistics_data = Some(input);
            self
        }
        /// <p>Date column statistics data.</p>
        pub fn set_date_column_statistics_data(
            mut self,
            input: std::option::Option<crate::model::DateColumnStatisticsData>,
        ) -> Self {
            self.date_column_statistics_data = input;
            self
        }
        /// <p>Decimal column statistics data.</p>
        pub fn decimal_column_statistics_data(
            mut self,
            input: crate::model::DecimalColumnStatisticsData,
        ) -> Self {
            self.decimal_column_statistics_data = Some(input);
            self
        }
        /// <p>Decimal column statistics data.</p>
        pub fn set_decimal_column_statistics_data(
            mut self,
            input: std::option::Option<crate::model::DecimalColumnStatisticsData>,
        ) -> Self {
            self.decimal_column_statistics_data = input;
            self
        }
        /// <p>Double column statistics data.</p>
        pub fn double_column_statistics_data(
            mut self,
            input: crate::model::DoubleColumnStatisticsData,
        ) -> Self {
            self.double_column_statistics_data = Some(input);
            self
        }
        /// <p>Double column statistics data.</p>
        pub fn set_double_column_statistics_data(
            mut self,
            input: std::option::Option<crate::model::DoubleColumnStatisticsData>,
        ) -> Self {
            self.double_column_statistics_data = input;
            self
        }
        /// <p>Long column statistics data.</p>
        pub fn long_column_statistics_data(
            mut self,
            input: crate::model::LongColumnStatisticsData,
        ) -> Self {
            self.long_column_statistics_data = Some(input);
            self
        }
        /// <p>Long column statistics data.</p>
        pub fn set_long_column_statistics_data(
            mut self,
            input: std::option::Option<crate::model::LongColumnStatisticsData>,
        ) -> Self {
            self.long_column_statistics_data = input;
            self
        }
        /// <p>String column statistics data.</p>
        pub fn string_column_statistics_data(
            mut self,
            input: crate::model::StringColumnStatisticsData,
        ) -> Self {
            self.string_column_statistics_data = Some(input);
            self
        }
        /// <p>String column statistics data.</p>
        pub fn set_string_column_statistics_data(
            mut self,
            input: std::option::Option<crate::model::StringColumnStatisticsData>,
        ) -> Self {
            self.string_column_statistics_data = input;
            self
        }
        /// <p>Binary column statistics data.</p>
        pub fn binary_column_statistics_data(
            mut self,
            input: crate::model::BinaryColumnStatisticsData,
        ) -> Self {
            self.binary_column_statistics_data = Some(input);
            self
        }
        /// <p>Binary column statistics data.</p>
        pub fn set_binary_column_statistics_data(
            mut self,
            input: std::option::Option<crate::model::BinaryColumnStatisticsData>,
        ) -> Self {
            self.binary_column_statistics_data = input;
            self
        }
        /// Consumes the builder and constructs a [`ColumnStatisticsData`](crate::model::ColumnStatisticsData).
        pub fn build(self) -> crate::model::ColumnStatisticsData {
            crate::model::ColumnStatisticsData {
                r#type: self.r#type,
                boolean_column_statistics_data: self.boolean_column_statistics_data,
                date_column_statistics_data: self.date_column_statistics_data,
                decimal_column_statistics_data: self.decimal_column_statistics_data,
                double_column_statistics_data: self.double_column_statistics_data,
                long_column_statistics_data: self.long_column_statistics_data,
                string_column_statistics_data: self.string_column_statistics_data,
                binary_column_statistics_data: self.binary_column_statistics_data,
            }
        }
    }
}
impl ColumnStatisticsData {
    /// Creates a new builder-style object to manufacture [`ColumnStatisticsData`](crate::model::ColumnStatisticsData).
    pub fn builder() -> crate::model::column_statistics_data::Builder {
        crate::model::column_statistics_data::Builder::default()
    }
}

/// <p>Defines column statistics supported for bit sequence data values.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BinaryColumnStatisticsData {
    /// <p>The size of the longest bit sequence in the column.</p>
    #[doc(hidden)]
    pub maximum_length: i64,
    /// <p>The average bit sequence length in the column.</p>
    #[doc(hidden)]
    pub average_length: f64,
    /// <p>The number of null values in the column.</p>
    #[doc(hidden)]
    pub number_of_nulls: i64,
}
impl BinaryColumnStatisticsData {
    /// <p>The size of the longest bit sequence in the column.</p>
    pub fn maximum_length(&self) -> i64 {
        self.maximum_length
    }
    /// <p>The average bit sequence length in the column.</p>
    pub fn average_length(&self) -> f64 {
        self.average_length
    }
    /// <p>The number of null values in the column.</p>
    pub fn number_of_nulls(&self) -> i64 {
        self.number_of_nulls
    }
}
/// See [`BinaryColumnStatisticsData`](crate::model::BinaryColumnStatisticsData).
pub mod binary_column_statistics_data {

    /// A builder for [`BinaryColumnStatisticsData`](crate::model::BinaryColumnStatisticsData).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) maximum_length: std::option::Option<i64>,
        pub(crate) average_length: std::option::Option<f64>,
        pub(crate) number_of_nulls: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>The size of the longest bit sequence in the column.</p>
        pub fn maximum_length(mut self, input: i64) -> Self {
            self.maximum_length = Some(input);
            self
        }
        /// <p>The size of the longest bit sequence in the column.</p>
        pub fn set_maximum_length(mut self, input: std::option::Option<i64>) -> Self {
            self.maximum_length = input;
            self
        }
        /// <p>The average bit sequence length in the column.</p>
        pub fn average_length(mut self, input: f64) -> Self {
            self.average_length = Some(input);
            self
        }
        /// <p>The average bit sequence length in the column.</p>
        pub fn set_average_length(mut self, input: std::option::Option<f64>) -> Self {
            self.average_length = input;
            self
        }
        /// <p>The number of null values in the column.</p>
        pub fn number_of_nulls(mut self, input: i64) -> Self {
            self.number_of_nulls = Some(input);
            self
        }
        /// <p>The number of null values in the column.</p>
        pub fn set_number_of_nulls(mut self, input: std::option::Option<i64>) -> Self {
            self.number_of_nulls = input;
            self
        }
        /// Consumes the builder and constructs a [`BinaryColumnStatisticsData`](crate::model::BinaryColumnStatisticsData).
        pub fn build(self) -> crate::model::BinaryColumnStatisticsData {
            crate::model::BinaryColumnStatisticsData {
                maximum_length: self.maximum_length.unwrap_or_default(),
                average_length: self.average_length.unwrap_or_default(),
                number_of_nulls: self.number_of_nulls.unwrap_or_default(),
            }
        }
    }
}
impl BinaryColumnStatisticsData {
    /// Creates a new builder-style object to manufacture [`BinaryColumnStatisticsData`](crate::model::BinaryColumnStatisticsData).
    pub fn builder() -> crate::model::binary_column_statistics_data::Builder {
        crate::model::binary_column_statistics_data::Builder::default()
    }
}

/// <p>Defines column statistics supported for character sequence data values.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct StringColumnStatisticsData {
    /// <p>The size of the longest string in the column.</p>
    #[doc(hidden)]
    pub maximum_length: i64,
    /// <p>The average string length in the column.</p>
    #[doc(hidden)]
    pub average_length: f64,
    /// <p>The number of null values in the column.</p>
    #[doc(hidden)]
    pub number_of_nulls: i64,
    /// <p>The number of distinct values in a column.</p>
    #[doc(hidden)]
    pub number_of_distinct_values: i64,
}
impl StringColumnStatisticsData {
    /// <p>The size of the longest string in the column.</p>
    pub fn maximum_length(&self) -> i64 {
        self.maximum_length
    }
    /// <p>The average string length in the column.</p>
    pub fn average_length(&self) -> f64 {
        self.average_length
    }
    /// <p>The number of null values in the column.</p>
    pub fn number_of_nulls(&self) -> i64 {
        self.number_of_nulls
    }
    /// <p>The number of distinct values in a column.</p>
    pub fn number_of_distinct_values(&self) -> i64 {
        self.number_of_distinct_values
    }
}
/// See [`StringColumnStatisticsData`](crate::model::StringColumnStatisticsData).
pub mod string_column_statistics_data {

    /// A builder for [`StringColumnStatisticsData`](crate::model::StringColumnStatisticsData).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) maximum_length: std::option::Option<i64>,
        pub(crate) average_length: std::option::Option<f64>,
        pub(crate) number_of_nulls: std::option::Option<i64>,
        pub(crate) number_of_distinct_values: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>The size of the longest string in the column.</p>
        pub fn maximum_length(mut self, input: i64) -> Self {
            self.maximum_length = Some(input);
            self
        }
        /// <p>The size of the longest string in the column.</p>
        pub fn set_maximum_length(mut self, input: std::option::Option<i64>) -> Self {
            self.maximum_length = input;
            self
        }
        /// <p>The average string length in the column.</p>
        pub fn average_length(mut self, input: f64) -> Self {
            self.average_length = Some(input);
            self
        }
        /// <p>The average string length in the column.</p>
        pub fn set_average_length(mut self, input: std::option::Option<f64>) -> Self {
            self.average_length = input;
            self
        }
        /// <p>The number of null values in the column.</p>
        pub fn number_of_nulls(mut self, input: i64) -> Self {
            self.number_of_nulls = Some(input);
            self
        }
        /// <p>The number of null values in the column.</p>
        pub fn set_number_of_nulls(mut self, input: std::option::Option<i64>) -> Self {
            self.number_of_nulls = input;
            self
        }
        /// <p>The number of distinct values in a column.</p>
        pub fn number_of_distinct_values(mut self, input: i64) -> Self {
            self.number_of_distinct_values = Some(input);
            self
        }
        /// <p>The number of distinct values in a column.</p>
        pub fn set_number_of_distinct_values(mut self, input: std::option::Option<i64>) -> Self {
            self.number_of_distinct_values = input;
            self
        }
        /// Consumes the builder and constructs a [`StringColumnStatisticsData`](crate::model::StringColumnStatisticsData).
        pub fn build(self) -> crate::model::StringColumnStatisticsData {
            crate::model::StringColumnStatisticsData {
                maximum_length: self.maximum_length.unwrap_or_default(),
                average_length: self.average_length.unwrap_or_default(),
                number_of_nulls: self.number_of_nulls.unwrap_or_default(),
                number_of_distinct_values: self.number_of_distinct_values.unwrap_or_default(),
            }
        }
    }
}
impl StringColumnStatisticsData {
    /// Creates a new builder-style object to manufacture [`StringColumnStatisticsData`](crate::model::StringColumnStatisticsData).
    pub fn builder() -> crate::model::string_column_statistics_data::Builder {
        crate::model::string_column_statistics_data::Builder::default()
    }
}

/// <p>Defines column statistics supported for integer data columns.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LongColumnStatisticsData {
    /// <p>The lowest value in the column.</p>
    #[doc(hidden)]
    pub minimum_value: i64,
    /// <p>The highest value in the column.</p>
    #[doc(hidden)]
    pub maximum_value: i64,
    /// <p>The number of null values in the column.</p>
    #[doc(hidden)]
    pub number_of_nulls: i64,
    /// <p>The number of distinct values in a column.</p>
    #[doc(hidden)]
    pub number_of_distinct_values: i64,
}
impl LongColumnStatisticsData {
    /// <p>The lowest value in the column.</p>
    pub fn minimum_value(&self) -> i64 {
        self.minimum_value
    }
    /// <p>The highest value in the column.</p>
    pub fn maximum_value(&self) -> i64 {
        self.maximum_value
    }
    /// <p>The number of null values in the column.</p>
    pub fn number_of_nulls(&self) -> i64 {
        self.number_of_nulls
    }
    /// <p>The number of distinct values in a column.</p>
    pub fn number_of_distinct_values(&self) -> i64 {
        self.number_of_distinct_values
    }
}
/// See [`LongColumnStatisticsData`](crate::model::LongColumnStatisticsData).
pub mod long_column_statistics_data {

    /// A builder for [`LongColumnStatisticsData`](crate::model::LongColumnStatisticsData).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) minimum_value: std::option::Option<i64>,
        pub(crate) maximum_value: std::option::Option<i64>,
        pub(crate) number_of_nulls: std::option::Option<i64>,
        pub(crate) number_of_distinct_values: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>The lowest value in the column.</p>
        pub fn minimum_value(mut self, input: i64) -> Self {
            self.minimum_value = Some(input);
            self
        }
        /// <p>The lowest value in the column.</p>
        pub fn set_minimum_value(mut self, input: std::option::Option<i64>) -> Self {
            self.minimum_value = input;
            self
        }
        /// <p>The highest value in the column.</p>
        pub fn maximum_value(mut self, input: i64) -> Self {
            self.maximum_value = Some(input);
            self
        }
        /// <p>The highest value in the column.</p>
        pub fn set_maximum_value(mut self, input: std::option::Option<i64>) -> Self {
            self.maximum_value = input;
            self
        }
        /// <p>The number of null values in the column.</p>
        pub fn number_of_nulls(mut self, input: i64) -> Self {
            self.number_of_nulls = Some(input);
            self
        }
        /// <p>The number of null values in the column.</p>
        pub fn set_number_of_nulls(mut self, input: std::option::Option<i64>) -> Self {
            self.number_of_nulls = input;
            self
        }
        /// <p>The number of distinct values in a column.</p>
        pub fn number_of_distinct_values(mut self, input: i64) -> Self {
            self.number_of_distinct_values = Some(input);
            self
        }
        /// <p>The number of distinct values in a column.</p>
        pub fn set_number_of_distinct_values(mut self, input: std::option::Option<i64>) -> Self {
            self.number_of_distinct_values = input;
            self
        }
        /// Consumes the builder and constructs a [`LongColumnStatisticsData`](crate::model::LongColumnStatisticsData).
        pub fn build(self) -> crate::model::LongColumnStatisticsData {
            crate::model::LongColumnStatisticsData {
                minimum_value: self.minimum_value.unwrap_or_default(),
                maximum_value: self.maximum_value.unwrap_or_default(),
                number_of_nulls: self.number_of_nulls.unwrap_or_default(),
                number_of_distinct_values: self.number_of_distinct_values.unwrap_or_default(),
            }
        }
    }
}
impl LongColumnStatisticsData {
    /// Creates a new builder-style object to manufacture [`LongColumnStatisticsData`](crate::model::LongColumnStatisticsData).
    pub fn builder() -> crate::model::long_column_statistics_data::Builder {
        crate::model::long_column_statistics_data::Builder::default()
    }
}

/// <p>Defines column statistics supported for floating-point number data columns.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DoubleColumnStatisticsData {
    /// <p>The lowest value in the column.</p>
    #[doc(hidden)]
    pub minimum_value: f64,
    /// <p>The highest value in the column.</p>
    #[doc(hidden)]
    pub maximum_value: f64,
    /// <p>The number of null values in the column.</p>
    #[doc(hidden)]
    pub number_of_nulls: i64,
    /// <p>The number of distinct values in a column.</p>
    #[doc(hidden)]
    pub number_of_distinct_values: i64,
}
impl DoubleColumnStatisticsData {
    /// <p>The lowest value in the column.</p>
    pub fn minimum_value(&self) -> f64 {
        self.minimum_value
    }
    /// <p>The highest value in the column.</p>
    pub fn maximum_value(&self) -> f64 {
        self.maximum_value
    }
    /// <p>The number of null values in the column.</p>
    pub fn number_of_nulls(&self) -> i64 {
        self.number_of_nulls
    }
    /// <p>The number of distinct values in a column.</p>
    pub fn number_of_distinct_values(&self) -> i64 {
        self.number_of_distinct_values
    }
}
/// See [`DoubleColumnStatisticsData`](crate::model::DoubleColumnStatisticsData).
pub mod double_column_statistics_data {

    /// A builder for [`DoubleColumnStatisticsData`](crate::model::DoubleColumnStatisticsData).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) minimum_value: std::option::Option<f64>,
        pub(crate) maximum_value: std::option::Option<f64>,
        pub(crate) number_of_nulls: std::option::Option<i64>,
        pub(crate) number_of_distinct_values: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>The lowest value in the column.</p>
        pub fn minimum_value(mut self, input: f64) -> Self {
            self.minimum_value = Some(input);
            self
        }
        /// <p>The lowest value in the column.</p>
        pub fn set_minimum_value(mut self, input: std::option::Option<f64>) -> Self {
            self.minimum_value = input;
            self
        }
        /// <p>The highest value in the column.</p>
        pub fn maximum_value(mut self, input: f64) -> Self {
            self.maximum_value = Some(input);
            self
        }
        /// <p>The highest value in the column.</p>
        pub fn set_maximum_value(mut self, input: std::option::Option<f64>) -> Self {
            self.maximum_value = input;
            self
        }
        /// <p>The number of null values in the column.</p>
        pub fn number_of_nulls(mut self, input: i64) -> Self {
            self.number_of_nulls = Some(input);
            self
        }
        /// <p>The number of null values in the column.</p>
        pub fn set_number_of_nulls(mut self, input: std::option::Option<i64>) -> Self {
            self.number_of_nulls = input;
            self
        }
        /// <p>The number of distinct values in a column.</p>
        pub fn number_of_distinct_values(mut self, input: i64) -> Self {
            self.number_of_distinct_values = Some(input);
            self
        }
        /// <p>The number of distinct values in a column.</p>
        pub fn set_number_of_distinct_values(mut self, input: std::option::Option<i64>) -> Self {
            self.number_of_distinct_values = input;
            self
        }
        /// Consumes the builder and constructs a [`DoubleColumnStatisticsData`](crate::model::DoubleColumnStatisticsData).
        pub fn build(self) -> crate::model::DoubleColumnStatisticsData {
            crate::model::DoubleColumnStatisticsData {
                minimum_value: self.minimum_value.unwrap_or_default(),
                maximum_value: self.maximum_value.unwrap_or_default(),
                number_of_nulls: self.number_of_nulls.unwrap_or_default(),
                number_of_distinct_values: self.number_of_distinct_values.unwrap_or_default(),
            }
        }
    }
}
impl DoubleColumnStatisticsData {
    /// Creates a new builder-style object to manufacture [`DoubleColumnStatisticsData`](crate::model::DoubleColumnStatisticsData).
    pub fn builder() -> crate::model::double_column_statistics_data::Builder {
        crate::model::double_column_statistics_data::Builder::default()
    }
}

/// <p>Defines column statistics supported for fixed-point number data columns.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DecimalColumnStatisticsData {
    /// <p>The lowest value in the column.</p>
    #[doc(hidden)]
    pub minimum_value: std::option::Option<crate::model::DecimalNumber>,
    /// <p>The highest value in the column.</p>
    #[doc(hidden)]
    pub maximum_value: std::option::Option<crate::model::DecimalNumber>,
    /// <p>The number of null values in the column.</p>
    #[doc(hidden)]
    pub number_of_nulls: i64,
    /// <p>The number of distinct values in a column.</p>
    #[doc(hidden)]
    pub number_of_distinct_values: i64,
}
impl DecimalColumnStatisticsData {
    /// <p>The lowest value in the column.</p>
    pub fn minimum_value(&self) -> std::option::Option<&crate::model::DecimalNumber> {
        self.minimum_value.as_ref()
    }
    /// <p>The highest value in the column.</p>
    pub fn maximum_value(&self) -> std::option::Option<&crate::model::DecimalNumber> {
        self.maximum_value.as_ref()
    }
    /// <p>The number of null values in the column.</p>
    pub fn number_of_nulls(&self) -> i64 {
        self.number_of_nulls
    }
    /// <p>The number of distinct values in a column.</p>
    pub fn number_of_distinct_values(&self) -> i64 {
        self.number_of_distinct_values
    }
}
/// See [`DecimalColumnStatisticsData`](crate::model::DecimalColumnStatisticsData).
pub mod decimal_column_statistics_data {

    /// A builder for [`DecimalColumnStatisticsData`](crate::model::DecimalColumnStatisticsData).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) minimum_value: std::option::Option<crate::model::DecimalNumber>,
        pub(crate) maximum_value: std::option::Option<crate::model::DecimalNumber>,
        pub(crate) number_of_nulls: std::option::Option<i64>,
        pub(crate) number_of_distinct_values: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>The lowest value in the column.</p>
        pub fn minimum_value(mut self, input: crate::model::DecimalNumber) -> Self {
            self.minimum_value = Some(input);
            self
        }
        /// <p>The lowest value in the column.</p>
        pub fn set_minimum_value(
            mut self,
            input: std::option::Option<crate::model::DecimalNumber>,
        ) -> Self {
            self.minimum_value = input;
            self
        }
        /// <p>The highest value in the column.</p>
        pub fn maximum_value(mut self, input: crate::model::DecimalNumber) -> Self {
            self.maximum_value = Some(input);
            self
        }
        /// <p>The highest value in the column.</p>
        pub fn set_maximum_value(
            mut self,
            input: std::option::Option<crate::model::DecimalNumber>,
        ) -> Self {
            self.maximum_value = input;
            self
        }
        /// <p>The number of null values in the column.</p>
        pub fn number_of_nulls(mut self, input: i64) -> Self {
            self.number_of_nulls = Some(input);
            self
        }
        /// <p>The number of null values in the column.</p>
        pub fn set_number_of_nulls(mut self, input: std::option::Option<i64>) -> Self {
            self.number_of_nulls = input;
            self
        }
        /// <p>The number of distinct values in a column.</p>
        pub fn number_of_distinct_values(mut self, input: i64) -> Self {
            self.number_of_distinct_values = Some(input);
            self
        }
        /// <p>The number of distinct values in a column.</p>
        pub fn set_number_of_distinct_values(mut self, input: std::option::Option<i64>) -> Self {
            self.number_of_distinct_values = input;
            self
        }
        /// Consumes the builder and constructs a [`DecimalColumnStatisticsData`](crate::model::DecimalColumnStatisticsData).
        pub fn build(self) -> crate::model::DecimalColumnStatisticsData {
            crate::model::DecimalColumnStatisticsData {
                minimum_value: self.minimum_value,
                maximum_value: self.maximum_value,
                number_of_nulls: self.number_of_nulls.unwrap_or_default(),
                number_of_distinct_values: self.number_of_distinct_values.unwrap_or_default(),
            }
        }
    }
}
impl DecimalColumnStatisticsData {
    /// Creates a new builder-style object to manufacture [`DecimalColumnStatisticsData`](crate::model::DecimalColumnStatisticsData).
    pub fn builder() -> crate::model::decimal_column_statistics_data::Builder {
        crate::model::decimal_column_statistics_data::Builder::default()
    }
}

/// <p>Contains a numeric value in decimal format.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DecimalNumber {
    /// <p>The unscaled numeric value.</p>
    #[doc(hidden)]
    pub unscaled_value: std::option::Option<aws_smithy_types::Blob>,
    /// <p>The scale that determines where the decimal point falls in the unscaled value.</p>
    #[doc(hidden)]
    pub scale: i32,
}
impl DecimalNumber {
    /// <p>The unscaled numeric value.</p>
    pub fn unscaled_value(&self) -> std::option::Option<&aws_smithy_types::Blob> {
        self.unscaled_value.as_ref()
    }
    /// <p>The scale that determines where the decimal point falls in the unscaled value.</p>
    pub fn scale(&self) -> i32 {
        self.scale
    }
}
/// See [`DecimalNumber`](crate::model::DecimalNumber).
pub mod decimal_number {

    /// A builder for [`DecimalNumber`](crate::model::DecimalNumber).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) unscaled_value: std::option::Option<aws_smithy_types::Blob>,
        pub(crate) scale: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The unscaled numeric value.</p>
        pub fn unscaled_value(mut self, input: aws_smithy_types::Blob) -> Self {
            self.unscaled_value = Some(input);
            self
        }
        /// <p>The unscaled numeric value.</p>
        pub fn set_unscaled_value(
            mut self,
            input: std::option::Option<aws_smithy_types::Blob>,
        ) -> Self {
            self.unscaled_value = input;
            self
        }
        /// <p>The scale that determines where the decimal point falls in the unscaled value.</p>
        pub fn scale(mut self, input: i32) -> Self {
            self.scale = Some(input);
            self
        }
        /// <p>The scale that determines where the decimal point falls in the unscaled value.</p>
        pub fn set_scale(mut self, input: std::option::Option<i32>) -> Self {
            self.scale = input;
            self
        }
        /// Consumes the builder and constructs a [`DecimalNumber`](crate::model::DecimalNumber).
        pub fn build(self) -> crate::model::DecimalNumber {
            crate::model::DecimalNumber {
                unscaled_value: self.unscaled_value,
                scale: self.scale.unwrap_or_default(),
            }
        }
    }
}
impl DecimalNumber {
    /// Creates a new builder-style object to manufacture [`DecimalNumber`](crate::model::DecimalNumber).
    pub fn builder() -> crate::model::decimal_number::Builder {
        crate::model::decimal_number::Builder::default()
    }
}

/// <p>Defines column statistics supported for timestamp data columns.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DateColumnStatisticsData {
    /// <p>The lowest value in the column.</p>
    #[doc(hidden)]
    pub minimum_value: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The highest value in the column.</p>
    #[doc(hidden)]
    pub maximum_value: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The number of null values in the column.</p>
    #[doc(hidden)]
    pub number_of_nulls: i64,
    /// <p>The number of distinct values in a column.</p>
    #[doc(hidden)]
    pub number_of_distinct_values: i64,
}
impl DateColumnStatisticsData {
    /// <p>The lowest value in the column.</p>
    pub fn minimum_value(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.minimum_value.as_ref()
    }
    /// <p>The highest value in the column.</p>
    pub fn maximum_value(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.maximum_value.as_ref()
    }
    /// <p>The number of null values in the column.</p>
    pub fn number_of_nulls(&self) -> i64 {
        self.number_of_nulls
    }
    /// <p>The number of distinct values in a column.</p>
    pub fn number_of_distinct_values(&self) -> i64 {
        self.number_of_distinct_values
    }
}
/// See [`DateColumnStatisticsData`](crate::model::DateColumnStatisticsData).
pub mod date_column_statistics_data {

    /// A builder for [`DateColumnStatisticsData`](crate::model::DateColumnStatisticsData).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) minimum_value: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) maximum_value: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) number_of_nulls: std::option::Option<i64>,
        pub(crate) number_of_distinct_values: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>The lowest value in the column.</p>
        pub fn minimum_value(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.minimum_value = Some(input);
            self
        }
        /// <p>The lowest value in the column.</p>
        pub fn set_minimum_value(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.minimum_value = input;
            self
        }
        /// <p>The highest value in the column.</p>
        pub fn maximum_value(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.maximum_value = Some(input);
            self
        }
        /// <p>The highest value in the column.</p>
        pub fn set_maximum_value(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.maximum_value = input;
            self
        }
        /// <p>The number of null values in the column.</p>
        pub fn number_of_nulls(mut self, input: i64) -> Self {
            self.number_of_nulls = Some(input);
            self
        }
        /// <p>The number of null values in the column.</p>
        pub fn set_number_of_nulls(mut self, input: std::option::Option<i64>) -> Self {
            self.number_of_nulls = input;
            self
        }
        /// <p>The number of distinct values in a column.</p>
        pub fn number_of_distinct_values(mut self, input: i64) -> Self {
            self.number_of_distinct_values = Some(input);
            self
        }
        /// <p>The number of distinct values in a column.</p>
        pub fn set_number_of_distinct_values(mut self, input: std::option::Option<i64>) -> Self {
            self.number_of_distinct_values = input;
            self
        }
        /// Consumes the builder and constructs a [`DateColumnStatisticsData`](crate::model::DateColumnStatisticsData).
        pub fn build(self) -> crate::model::DateColumnStatisticsData {
            crate::model::DateColumnStatisticsData {
                minimum_value: self.minimum_value,
                maximum_value: self.maximum_value,
                number_of_nulls: self.number_of_nulls.unwrap_or_default(),
                number_of_distinct_values: self.number_of_distinct_values.unwrap_or_default(),
            }
        }
    }
}
impl DateColumnStatisticsData {
    /// Creates a new builder-style object to manufacture [`DateColumnStatisticsData`](crate::model::DateColumnStatisticsData).
    pub fn builder() -> crate::model::date_column_statistics_data::Builder {
        crate::model::date_column_statistics_data::Builder::default()
    }
}

/// <p>Defines column statistics supported for Boolean data columns.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BooleanColumnStatisticsData {
    /// <p>The number of true values in the column.</p>
    #[doc(hidden)]
    pub number_of_trues: i64,
    /// <p>The number of false values in the column.</p>
    #[doc(hidden)]
    pub number_of_falses: i64,
    /// <p>The number of null values in the column.</p>
    #[doc(hidden)]
    pub number_of_nulls: i64,
}
impl BooleanColumnStatisticsData {
    /// <p>The number of true values in the column.</p>
    pub fn number_of_trues(&self) -> i64 {
        self.number_of_trues
    }
    /// <p>The number of false values in the column.</p>
    pub fn number_of_falses(&self) -> i64 {
        self.number_of_falses
    }
    /// <p>The number of null values in the column.</p>
    pub fn number_of_nulls(&self) -> i64 {
        self.number_of_nulls
    }
}
/// See [`BooleanColumnStatisticsData`](crate::model::BooleanColumnStatisticsData).
pub mod boolean_column_statistics_data {

    /// A builder for [`BooleanColumnStatisticsData`](crate::model::BooleanColumnStatisticsData).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) number_of_trues: std::option::Option<i64>,
        pub(crate) number_of_falses: std::option::Option<i64>,
        pub(crate) number_of_nulls: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>The number of true values in the column.</p>
        pub fn number_of_trues(mut self, input: i64) -> Self {
            self.number_of_trues = Some(input);
            self
        }
        /// <p>The number of true values in the column.</p>
        pub fn set_number_of_trues(mut self, input: std::option::Option<i64>) -> Self {
            self.number_of_trues = input;
            self
        }
        /// <p>The number of false values in the column.</p>
        pub fn number_of_falses(mut self, input: i64) -> Self {
            self.number_of_falses = Some(input);
            self
        }
        /// <p>The number of false values in the column.</p>
        pub fn set_number_of_falses(mut self, input: std::option::Option<i64>) -> Self {
            self.number_of_falses = input;
            self
        }
        /// <p>The number of null values in the column.</p>
        pub fn number_of_nulls(mut self, input: i64) -> Self {
            self.number_of_nulls = Some(input);
            self
        }
        /// <p>The number of null values in the column.</p>
        pub fn set_number_of_nulls(mut self, input: std::option::Option<i64>) -> Self {
            self.number_of_nulls = input;
            self
        }
        /// Consumes the builder and constructs a [`BooleanColumnStatisticsData`](crate::model::BooleanColumnStatisticsData).
        pub fn build(self) -> crate::model::BooleanColumnStatisticsData {
            crate::model::BooleanColumnStatisticsData {
                number_of_trues: self.number_of_trues.unwrap_or_default(),
                number_of_falses: self.number_of_falses.unwrap_or_default(),
                number_of_nulls: self.number_of_nulls.unwrap_or_default(),
            }
        }
    }
}
impl BooleanColumnStatisticsData {
    /// Creates a new builder-style object to manufacture [`BooleanColumnStatisticsData`](crate::model::BooleanColumnStatisticsData).
    pub fn builder() -> crate::model::boolean_column_statistics_data::Builder {
        crate::model::boolean_column_statistics_data::Builder::default()
    }
}

/// When writing a match expression against `ColumnStatisticsType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let columnstatisticstype = unimplemented!();
/// match columnstatisticstype {
///     ColumnStatisticsType::Binary => { /* ... */ },
///     ColumnStatisticsType::Boolean => { /* ... */ },
///     ColumnStatisticsType::Date => { /* ... */ },
///     ColumnStatisticsType::Decimal => { /* ... */ },
///     ColumnStatisticsType::Double => { /* ... */ },
///     ColumnStatisticsType::Long => { /* ... */ },
///     ColumnStatisticsType::String => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `columnstatisticstype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ColumnStatisticsType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ColumnStatisticsType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ColumnStatisticsType::NewFeature` is defined.
/// Specifically, when `columnstatisticstype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ColumnStatisticsType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ColumnStatisticsType {
    #[allow(missing_docs)] // documentation missing in model
    Binary,
    #[allow(missing_docs)] // documentation missing in model
    Boolean,
    #[allow(missing_docs)] // documentation missing in model
    Date,
    #[allow(missing_docs)] // documentation missing in model
    Decimal,
    #[allow(missing_docs)] // documentation missing in model
    Double,
    #[allow(missing_docs)] // documentation missing in model
    Long,
    #[allow(missing_docs)] // documentation missing in model
    String,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ColumnStatisticsType {
    fn from(s: &str) -> Self {
        match s {
            "BINARY" => ColumnStatisticsType::Binary,
            "BOOLEAN" => ColumnStatisticsType::Boolean,
            "DATE" => ColumnStatisticsType::Date,
            "DECIMAL" => ColumnStatisticsType::Decimal,
            "DOUBLE" => ColumnStatisticsType::Double,
            "LONG" => ColumnStatisticsType::Long,
            "STRING" => ColumnStatisticsType::String,
            other => {
                ColumnStatisticsType::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for ColumnStatisticsType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ColumnStatisticsType::from(s))
    }
}
impl ColumnStatisticsType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ColumnStatisticsType::Binary => "BINARY",
            ColumnStatisticsType::Boolean => "BOOLEAN",
            ColumnStatisticsType::Date => "DATE",
            ColumnStatisticsType::Decimal => "DECIMAL",
            ColumnStatisticsType::Double => "DOUBLE",
            ColumnStatisticsType::Long => "LONG",
            ColumnStatisticsType::String => "STRING",
            ColumnStatisticsType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "BINARY", "BOOLEAN", "DATE", "DECIMAL", "DOUBLE", "LONG", "STRING",
        ]
    }
}
impl AsRef<str> for ColumnStatisticsType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Specifies a custom CSV classifier to be updated.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateCsvClassifierRequest {
    /// <p>The name of the classifier.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>A custom symbol to denote what separates each column entry in the row.</p>
    #[doc(hidden)]
    pub delimiter: std::option::Option<std::string::String>,
    /// <p>A custom symbol to denote what combines content into a single column value. It must be different from the column delimiter.</p>
    #[doc(hidden)]
    pub quote_symbol: std::option::Option<std::string::String>,
    /// <p>Indicates whether the CSV file contains a header.</p>
    #[doc(hidden)]
    pub contains_header: std::option::Option<crate::model::CsvHeaderOption>,
    /// <p>A list of strings representing column names.</p>
    #[doc(hidden)]
    pub header: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Specifies not to trim values before identifying the type of column values. The default value is true.</p>
    #[doc(hidden)]
    pub disable_value_trimming: std::option::Option<bool>,
    /// <p>Enables the processing of files that contain only one column.</p>
    #[doc(hidden)]
    pub allow_single_column: std::option::Option<bool>,
    /// <p>Specifies the configuration of custom datatypes.</p>
    #[doc(hidden)]
    pub custom_datatype_configured: std::option::Option<bool>,
    /// <p>Specifies a list of supported custom datatypes.</p>
    #[doc(hidden)]
    pub custom_datatypes: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl UpdateCsvClassifierRequest {
    /// <p>The name of the classifier.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>A custom symbol to denote what separates each column entry in the row.</p>
    pub fn delimiter(&self) -> std::option::Option<&str> {
        self.delimiter.as_deref()
    }
    /// <p>A custom symbol to denote what combines content into a single column value. It must be different from the column delimiter.</p>
    pub fn quote_symbol(&self) -> std::option::Option<&str> {
        self.quote_symbol.as_deref()
    }
    /// <p>Indicates whether the CSV file contains a header.</p>
    pub fn contains_header(&self) -> std::option::Option<&crate::model::CsvHeaderOption> {
        self.contains_header.as_ref()
    }
    /// <p>A list of strings representing column names.</p>
    pub fn header(&self) -> std::option::Option<&[std::string::String]> {
        self.header.as_deref()
    }
    /// <p>Specifies not to trim values before identifying the type of column values. The default value is true.</p>
    pub fn disable_value_trimming(&self) -> std::option::Option<bool> {
        self.disable_value_trimming
    }
    /// <p>Enables the processing of files that contain only one column.</p>
    pub fn allow_single_column(&self) -> std::option::Option<bool> {
        self.allow_single_column
    }
    /// <p>Specifies the configuration of custom datatypes.</p>
    pub fn custom_datatype_configured(&self) -> std::option::Option<bool> {
        self.custom_datatype_configured
    }
    /// <p>Specifies a list of supported custom datatypes.</p>
    pub fn custom_datatypes(&self) -> std::option::Option<&[std::string::String]> {
        self.custom_datatypes.as_deref()
    }
}
/// See [`UpdateCsvClassifierRequest`](crate::model::UpdateCsvClassifierRequest).
pub mod update_csv_classifier_request {

    /// A builder for [`UpdateCsvClassifierRequest`](crate::model::UpdateCsvClassifierRequest).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) delimiter: std::option::Option<std::string::String>,
        pub(crate) quote_symbol: std::option::Option<std::string::String>,
        pub(crate) contains_header: std::option::Option<crate::model::CsvHeaderOption>,
        pub(crate) header: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) disable_value_trimming: std::option::Option<bool>,
        pub(crate) allow_single_column: std::option::Option<bool>,
        pub(crate) custom_datatype_configured: std::option::Option<bool>,
        pub(crate) custom_datatypes: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The name of the classifier.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the classifier.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>A custom symbol to denote what separates each column entry in the row.</p>
        pub fn delimiter(mut self, input: impl Into<std::string::String>) -> Self {
            self.delimiter = Some(input.into());
            self
        }
        /// <p>A custom symbol to denote what separates each column entry in the row.</p>
        pub fn set_delimiter(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.delimiter = input;
            self
        }
        /// <p>A custom symbol to denote what combines content into a single column value. It must be different from the column delimiter.</p>
        pub fn quote_symbol(mut self, input: impl Into<std::string::String>) -> Self {
            self.quote_symbol = Some(input.into());
            self
        }
        /// <p>A custom symbol to denote what combines content into a single column value. It must be different from the column delimiter.</p>
        pub fn set_quote_symbol(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.quote_symbol = input;
            self
        }
        /// <p>Indicates whether the CSV file contains a header.</p>
        pub fn contains_header(mut self, input: crate::model::CsvHeaderOption) -> Self {
            self.contains_header = Some(input);
            self
        }
        /// <p>Indicates whether the CSV file contains a header.</p>
        pub fn set_contains_header(
            mut self,
            input: std::option::Option<crate::model::CsvHeaderOption>,
        ) -> Self {
            self.contains_header = input;
            self
        }
        /// Appends an item to `header`.
        ///
        /// To override the contents of this collection use [`set_header`](Self::set_header).
        ///
        /// <p>A list of strings representing column names.</p>
        pub fn header(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.header.unwrap_or_default();
            v.push(input.into());
            self.header = Some(v);
            self
        }
        /// <p>A list of strings representing column names.</p>
        pub fn set_header(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.header = input;
            self
        }
        /// <p>Specifies not to trim values before identifying the type of column values. The default value is true.</p>
        pub fn disable_value_trimming(mut self, input: bool) -> Self {
            self.disable_value_trimming = Some(input);
            self
        }
        /// <p>Specifies not to trim values before identifying the type of column values. The default value is true.</p>
        pub fn set_disable_value_trimming(mut self, input: std::option::Option<bool>) -> Self {
            self.disable_value_trimming = input;
            self
        }
        /// <p>Enables the processing of files that contain only one column.</p>
        pub fn allow_single_column(mut self, input: bool) -> Self {
            self.allow_single_column = Some(input);
            self
        }
        /// <p>Enables the processing of files that contain only one column.</p>
        pub fn set_allow_single_column(mut self, input: std::option::Option<bool>) -> Self {
            self.allow_single_column = input;
            self
        }
        /// <p>Specifies the configuration of custom datatypes.</p>
        pub fn custom_datatype_configured(mut self, input: bool) -> Self {
            self.custom_datatype_configured = Some(input);
            self
        }
        /// <p>Specifies the configuration of custom datatypes.</p>
        pub fn set_custom_datatype_configured(mut self, input: std::option::Option<bool>) -> Self {
            self.custom_datatype_configured = input;
            self
        }
        /// Appends an item to `custom_datatypes`.
        ///
        /// To override the contents of this collection use [`set_custom_datatypes`](Self::set_custom_datatypes).
        ///
        /// <p>Specifies a list of supported custom datatypes.</p>
        pub fn custom_datatypes(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.custom_datatypes.unwrap_or_default();
            v.push(input.into());
            self.custom_datatypes = Some(v);
            self
        }
        /// <p>Specifies a list of supported custom datatypes.</p>
        pub fn set_custom_datatypes(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.custom_datatypes = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateCsvClassifierRequest`](crate::model::UpdateCsvClassifierRequest).
        pub fn build(self) -> crate::model::UpdateCsvClassifierRequest {
            crate::model::UpdateCsvClassifierRequest {
                name: self.name,
                delimiter: self.delimiter,
                quote_symbol: self.quote_symbol,
                contains_header: self.contains_header,
                header: self.header,
                disable_value_trimming: self.disable_value_trimming,
                allow_single_column: self.allow_single_column,
                custom_datatype_configured: self.custom_datatype_configured,
                custom_datatypes: self.custom_datatypes,
            }
        }
    }
}
impl UpdateCsvClassifierRequest {
    /// Creates a new builder-style object to manufacture [`UpdateCsvClassifierRequest`](crate::model::UpdateCsvClassifierRequest).
    pub fn builder() -> crate::model::update_csv_classifier_request::Builder {
        crate::model::update_csv_classifier_request::Builder::default()
    }
}

/// When writing a match expression against `CsvHeaderOption`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let csvheaderoption = unimplemented!();
/// match csvheaderoption {
///     CsvHeaderOption::Absent => { /* ... */ },
///     CsvHeaderOption::Present => { /* ... */ },
///     CsvHeaderOption::UnknownValue => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `csvheaderoption` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `CsvHeaderOption::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `CsvHeaderOption::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `CsvHeaderOption::NewFeature` is defined.
/// Specifically, when `csvheaderoption` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `CsvHeaderOption::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
/// _Note: `CsvHeaderOption::Unknown` has been renamed to `::UnknownValue`._
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum CsvHeaderOption {
    #[allow(missing_docs)] // documentation missing in model
    Absent,
    #[allow(missing_docs)] // documentation missing in model
    Present,
    /// _Note: `::Unknown` has been renamed to `::UnknownValue`._
    UnknownValue,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for CsvHeaderOption {
    fn from(s: &str) -> Self {
        match s {
            "ABSENT" => CsvHeaderOption::Absent,
            "PRESENT" => CsvHeaderOption::Present,
            "UNKNOWN" => CsvHeaderOption::UnknownValue,
            other => CsvHeaderOption::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for CsvHeaderOption {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(CsvHeaderOption::from(s))
    }
}
impl CsvHeaderOption {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            CsvHeaderOption::Absent => "ABSENT",
            CsvHeaderOption::Present => "PRESENT",
            CsvHeaderOption::UnknownValue => "UNKNOWN",
            CsvHeaderOption::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ABSENT", "PRESENT", "UNKNOWN"]
    }
}
impl AsRef<str> for CsvHeaderOption {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Specifies a JSON classifier to be updated.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateJsonClassifierRequest {
    /// <p>The name of the classifier.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>A <code>JsonPath</code> string defining the JSON data for the classifier to classify. Glue supports a subset of JsonPath, as described in <a href="https://docs.aws.amazon.com/glue/latest/dg/custom-classifier.html#custom-classifier-json">Writing JsonPath Custom Classifiers</a>.</p>
    #[doc(hidden)]
    pub json_path: std::option::Option<std::string::String>,
}
impl UpdateJsonClassifierRequest {
    /// <p>The name of the classifier.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>A <code>JsonPath</code> string defining the JSON data for the classifier to classify. Glue supports a subset of JsonPath, as described in <a href="https://docs.aws.amazon.com/glue/latest/dg/custom-classifier.html#custom-classifier-json">Writing JsonPath Custom Classifiers</a>.</p>
    pub fn json_path(&self) -> std::option::Option<&str> {
        self.json_path.as_deref()
    }
}
/// See [`UpdateJsonClassifierRequest`](crate::model::UpdateJsonClassifierRequest).
pub mod update_json_classifier_request {

    /// A builder for [`UpdateJsonClassifierRequest`](crate::model::UpdateJsonClassifierRequest).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) json_path: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the classifier.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the classifier.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>A <code>JsonPath</code> string defining the JSON data for the classifier to classify. Glue supports a subset of JsonPath, as described in <a href="https://docs.aws.amazon.com/glue/latest/dg/custom-classifier.html#custom-classifier-json">Writing JsonPath Custom Classifiers</a>.</p>
        pub fn json_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.json_path = Some(input.into());
            self
        }
        /// <p>A <code>JsonPath</code> string defining the JSON data for the classifier to classify. Glue supports a subset of JsonPath, as described in <a href="https://docs.aws.amazon.com/glue/latest/dg/custom-classifier.html#custom-classifier-json">Writing JsonPath Custom Classifiers</a>.</p>
        pub fn set_json_path(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.json_path = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateJsonClassifierRequest`](crate::model::UpdateJsonClassifierRequest).
        pub fn build(self) -> crate::model::UpdateJsonClassifierRequest {
            crate::model::UpdateJsonClassifierRequest {
                name: self.name,
                json_path: self.json_path,
            }
        }
    }
}
impl UpdateJsonClassifierRequest {
    /// Creates a new builder-style object to manufacture [`UpdateJsonClassifierRequest`](crate::model::UpdateJsonClassifierRequest).
    pub fn builder() -> crate::model::update_json_classifier_request::Builder {
        crate::model::update_json_classifier_request::Builder::default()
    }
}

/// <p>Specifies an XML classifier to be updated.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateXmlClassifierRequest {
    /// <p>The name of the classifier.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>An identifier of the data format that the classifier matches.</p>
    #[doc(hidden)]
    pub classification: std::option::Option<std::string::String>,
    /// <p>The XML tag designating the element that contains each record in an XML document being parsed. This cannot identify a self-closing element (closed by <code>/&gt;</code>). An empty row element that contains only attributes can be parsed as long as it ends with a closing tag (for example, <code>
    /// <row item_a="A" item_b="B" /></code> is okay, but <code>
    /// <row item_a="A" item_b="B" /></code> is not).</p>
    #[doc(hidden)]
    pub row_tag: std::option::Option<std::string::String>,
}
impl UpdateXmlClassifierRequest {
    /// <p>The name of the classifier.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>An identifier of the data format that the classifier matches.</p>
    pub fn classification(&self) -> std::option::Option<&str> {
        self.classification.as_deref()
    }
    /// <p>The XML tag designating the element that contains each record in an XML document being parsed. This cannot identify a self-closing element (closed by <code>/&gt;</code>). An empty row element that contains only attributes can be parsed as long as it ends with a closing tag (for example, <code>
    /// <row item_a="A" item_b="B" /></code> is okay, but <code>
    /// <row item_a="A" item_b="B" /></code> is not).</p>
    pub fn row_tag(&self) -> std::option::Option<&str> {
        self.row_tag.as_deref()
    }
}
/// See [`UpdateXmlClassifierRequest`](crate::model::UpdateXmlClassifierRequest).
pub mod update_xml_classifier_request {

    /// A builder for [`UpdateXmlClassifierRequest`](crate::model::UpdateXmlClassifierRequest).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) classification: std::option::Option<std::string::String>,
        pub(crate) row_tag: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the classifier.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the classifier.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>An identifier of the data format that the classifier matches.</p>
        pub fn classification(mut self, input: impl Into<std::string::String>) -> Self {
            self.classification = Some(input.into());
            self
        }
        /// <p>An identifier of the data format that the classifier matches.</p>
        pub fn set_classification(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.classification = input;
            self
        }
        /// <p>The XML tag designating the element that contains each record in an XML document being parsed. This cannot identify a self-closing element (closed by <code>/&gt;</code>). An empty row element that contains only attributes can be parsed as long as it ends with a closing tag (for example, <code>
        /// <row item_a="A" item_b="B" /></code> is okay, but <code>
        /// <row item_a="A" item_b="B" /></code> is not).</p>
        pub fn row_tag(mut self, input: impl Into<std::string::String>) -> Self {
            self.row_tag = Some(input.into());
            self
        }
        /// <p>The XML tag designating the element that contains each record in an XML document being parsed. This cannot identify a self-closing element (closed by <code>/&gt;</code>). An empty row element that contains only attributes can be parsed as long as it ends with a closing tag (for example, <code>
        /// <row item_a="A" item_b="B" /></code> is okay, but <code>
        /// <row item_a="A" item_b="B" /></code> is not).</p>
        pub fn set_row_tag(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.row_tag = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateXmlClassifierRequest`](crate::model::UpdateXmlClassifierRequest).
        pub fn build(self) -> crate::model::UpdateXmlClassifierRequest {
            crate::model::UpdateXmlClassifierRequest {
                name: self.name,
                classification: self.classification,
                row_tag: self.row_tag,
            }
        }
    }
}
impl UpdateXmlClassifierRequest {
    /// Creates a new builder-style object to manufacture [`UpdateXmlClassifierRequest`](crate::model::UpdateXmlClassifierRequest).
    pub fn builder() -> crate::model::update_xml_classifier_request::Builder {
        crate::model::update_xml_classifier_request::Builder::default()
    }
}

/// <p>Specifies a grok classifier to update when passed to <code>UpdateClassifier</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateGrokClassifierRequest {
    /// <p>The name of the <code>GrokClassifier</code>.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>An identifier of the data format that the classifier matches, such as Twitter, JSON, Omniture logs, Amazon CloudWatch Logs, and so on.</p>
    #[doc(hidden)]
    pub classification: std::option::Option<std::string::String>,
    /// <p>The grok pattern used by this classifier.</p>
    #[doc(hidden)]
    pub grok_pattern: std::option::Option<std::string::String>,
    /// <p>Optional custom grok patterns used by this classifier.</p>
    #[doc(hidden)]
    pub custom_patterns: std::option::Option<std::string::String>,
}
impl UpdateGrokClassifierRequest {
    /// <p>The name of the <code>GrokClassifier</code>.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>An identifier of the data format that the classifier matches, such as Twitter, JSON, Omniture logs, Amazon CloudWatch Logs, and so on.</p>
    pub fn classification(&self) -> std::option::Option<&str> {
        self.classification.as_deref()
    }
    /// <p>The grok pattern used by this classifier.</p>
    pub fn grok_pattern(&self) -> std::option::Option<&str> {
        self.grok_pattern.as_deref()
    }
    /// <p>Optional custom grok patterns used by this classifier.</p>
    pub fn custom_patterns(&self) -> std::option::Option<&str> {
        self.custom_patterns.as_deref()
    }
}
/// See [`UpdateGrokClassifierRequest`](crate::model::UpdateGrokClassifierRequest).
pub mod update_grok_classifier_request {

    /// A builder for [`UpdateGrokClassifierRequest`](crate::model::UpdateGrokClassifierRequest).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) classification: std::option::Option<std::string::String>,
        pub(crate) grok_pattern: std::option::Option<std::string::String>,
        pub(crate) custom_patterns: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the <code>GrokClassifier</code>.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the <code>GrokClassifier</code>.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>An identifier of the data format that the classifier matches, such as Twitter, JSON, Omniture logs, Amazon CloudWatch Logs, and so on.</p>
        pub fn classification(mut self, input: impl Into<std::string::String>) -> Self {
            self.classification = Some(input.into());
            self
        }
        /// <p>An identifier of the data format that the classifier matches, such as Twitter, JSON, Omniture logs, Amazon CloudWatch Logs, and so on.</p>
        pub fn set_classification(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.classification = input;
            self
        }
        /// <p>The grok pattern used by this classifier.</p>
        pub fn grok_pattern(mut self, input: impl Into<std::string::String>) -> Self {
            self.grok_pattern = Some(input.into());
            self
        }
        /// <p>The grok pattern used by this classifier.</p>
        pub fn set_grok_pattern(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.grok_pattern = input;
            self
        }
        /// <p>Optional custom grok patterns used by this classifier.</p>
        pub fn custom_patterns(mut self, input: impl Into<std::string::String>) -> Self {
            self.custom_patterns = Some(input.into());
            self
        }
        /// <p>Optional custom grok patterns used by this classifier.</p>
        pub fn set_custom_patterns(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.custom_patterns = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateGrokClassifierRequest`](crate::model::UpdateGrokClassifierRequest).
        pub fn build(self) -> crate::model::UpdateGrokClassifierRequest {
            crate::model::UpdateGrokClassifierRequest {
                name: self.name,
                classification: self.classification,
                grok_pattern: self.grok_pattern,
                custom_patterns: self.custom_patterns,
            }
        }
    }
}
impl UpdateGrokClassifierRequest {
    /// Creates a new builder-style object to manufacture [`UpdateGrokClassifierRequest`](crate::model::UpdateGrokClassifierRequest).
    pub fn builder() -> crate::model::update_grok_classifier_request::Builder {
        crate::model::update_grok_classifier_request::Builder::default()
    }
}

/// <p>Additional run options you can specify for an evaluation run.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DataQualityEvaluationRunAdditionalRunOptions {
    /// <p>Whether or not to enable CloudWatch metrics.</p>
    #[doc(hidden)]
    pub cloud_watch_metrics_enabled: std::option::Option<bool>,
    /// <p>Prefix for Amazon S3 to store results.</p>
    #[doc(hidden)]
    pub results_s3_prefix: std::option::Option<std::string::String>,
}
impl DataQualityEvaluationRunAdditionalRunOptions {
    /// <p>Whether or not to enable CloudWatch metrics.</p>
    pub fn cloud_watch_metrics_enabled(&self) -> std::option::Option<bool> {
        self.cloud_watch_metrics_enabled
    }
    /// <p>Prefix for Amazon S3 to store results.</p>
    pub fn results_s3_prefix(&self) -> std::option::Option<&str> {
        self.results_s3_prefix.as_deref()
    }
}
/// See [`DataQualityEvaluationRunAdditionalRunOptions`](crate::model::DataQualityEvaluationRunAdditionalRunOptions).
pub mod data_quality_evaluation_run_additional_run_options {

    /// A builder for [`DataQualityEvaluationRunAdditionalRunOptions`](crate::model::DataQualityEvaluationRunAdditionalRunOptions).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) cloud_watch_metrics_enabled: std::option::Option<bool>,
        pub(crate) results_s3_prefix: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Whether or not to enable CloudWatch metrics.</p>
        pub fn cloud_watch_metrics_enabled(mut self, input: bool) -> Self {
            self.cloud_watch_metrics_enabled = Some(input);
            self
        }
        /// <p>Whether or not to enable CloudWatch metrics.</p>
        pub fn set_cloud_watch_metrics_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.cloud_watch_metrics_enabled = input;
            self
        }
        /// <p>Prefix for Amazon S3 to store results.</p>
        pub fn results_s3_prefix(mut self, input: impl Into<std::string::String>) -> Self {
            self.results_s3_prefix = Some(input.into());
            self
        }
        /// <p>Prefix for Amazon S3 to store results.</p>
        pub fn set_results_s3_prefix(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.results_s3_prefix = input;
            self
        }
        /// Consumes the builder and constructs a [`DataQualityEvaluationRunAdditionalRunOptions`](crate::model::DataQualityEvaluationRunAdditionalRunOptions).
        pub fn build(self) -> crate::model::DataQualityEvaluationRunAdditionalRunOptions {
            crate::model::DataQualityEvaluationRunAdditionalRunOptions {
                cloud_watch_metrics_enabled: self.cloud_watch_metrics_enabled,
                results_s3_prefix: self.results_s3_prefix,
            }
        }
    }
}
impl DataQualityEvaluationRunAdditionalRunOptions {
    /// Creates a new builder-style object to manufacture [`DataQualityEvaluationRunAdditionalRunOptions`](crate::model::DataQualityEvaluationRunAdditionalRunOptions).
    pub fn builder() -> crate::model::data_quality_evaluation_run_additional_run_options::Builder {
        crate::model::data_quality_evaluation_run_additional_run_options::Builder::default()
    }
}

/// <p>A data source (an Glue table) for which you want data quality results.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DataSource {
    /// <p>An Glue table.</p>
    #[doc(hidden)]
    pub glue_table: std::option::Option<crate::model::GlueTable>,
}
impl DataSource {
    /// <p>An Glue table.</p>
    pub fn glue_table(&self) -> std::option::Option<&crate::model::GlueTable> {
        self.glue_table.as_ref()
    }
}
/// See [`DataSource`](crate::model::DataSource).
pub mod data_source {

    /// A builder for [`DataSource`](crate::model::DataSource).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) glue_table: std::option::Option<crate::model::GlueTable>,
    }
    impl Builder {
        /// <p>An Glue table.</p>
        pub fn glue_table(mut self, input: crate::model::GlueTable) -> Self {
            self.glue_table = Some(input);
            self
        }
        /// <p>An Glue table.</p>
        pub fn set_glue_table(
            mut self,
            input: std::option::Option<crate::model::GlueTable>,
        ) -> Self {
            self.glue_table = input;
            self
        }
        /// Consumes the builder and constructs a [`DataSource`](crate::model::DataSource).
        pub fn build(self) -> crate::model::DataSource {
            crate::model::DataSource {
                glue_table: self.glue_table,
            }
        }
    }
}
impl DataSource {
    /// Creates a new builder-style object to manufacture [`DataSource`](crate::model::DataSource).
    pub fn builder() -> crate::model::data_source::Builder {
        crate::model::data_source::Builder::default()
    }
}

/// <p>The database and table in the Glue Data Catalog that is used for input or output data.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GlueTable {
    /// <p>A database name in the Glue Data Catalog.</p>
    #[doc(hidden)]
    pub database_name: std::option::Option<std::string::String>,
    /// <p>A table name in the Glue Data Catalog.</p>
    #[doc(hidden)]
    pub table_name: std::option::Option<std::string::String>,
    /// <p>A unique identifier for the Glue Data Catalog.</p>
    #[doc(hidden)]
    pub catalog_id: std::option::Option<std::string::String>,
    /// <p>The name of the connection to the Glue Data Catalog.</p>
    #[doc(hidden)]
    pub connection_name: std::option::Option<std::string::String>,
    /// <p>Additional options for the table. Currently there are two keys supported:</p>
    /// <ul>
    /// <li> <p> <code>pushDownPredicate</code>: to filter on partitions without having to list and read all the files in your dataset.</p> </li>
    /// <li> <p> <code>catalogPartitionPredicate</code>: to use server-side partition pruning using partition indexes in the Glue Data Catalog.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub additional_options:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl GlueTable {
    /// <p>A database name in the Glue Data Catalog.</p>
    pub fn database_name(&self) -> std::option::Option<&str> {
        self.database_name.as_deref()
    }
    /// <p>A table name in the Glue Data Catalog.</p>
    pub fn table_name(&self) -> std::option::Option<&str> {
        self.table_name.as_deref()
    }
    /// <p>A unique identifier for the Glue Data Catalog.</p>
    pub fn catalog_id(&self) -> std::option::Option<&str> {
        self.catalog_id.as_deref()
    }
    /// <p>The name of the connection to the Glue Data Catalog.</p>
    pub fn connection_name(&self) -> std::option::Option<&str> {
        self.connection_name.as_deref()
    }
    /// <p>Additional options for the table. Currently there are two keys supported:</p>
    /// <ul>
    /// <li> <p> <code>pushDownPredicate</code>: to filter on partitions without having to list and read all the files in your dataset.</p> </li>
    /// <li> <p> <code>catalogPartitionPredicate</code>: to use server-side partition pruning using partition indexes in the Glue Data Catalog.</p> </li>
    /// </ul>
    pub fn additional_options(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.additional_options.as_ref()
    }
}
/// See [`GlueTable`](crate::model::GlueTable).
pub mod glue_table {

    /// A builder for [`GlueTable`](crate::model::GlueTable).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) database_name: std::option::Option<std::string::String>,
        pub(crate) table_name: std::option::Option<std::string::String>,
        pub(crate) catalog_id: std::option::Option<std::string::String>,
        pub(crate) connection_name: std::option::Option<std::string::String>,
        pub(crate) additional_options: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>A database name in the Glue Data Catalog.</p>
        pub fn database_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.database_name = Some(input.into());
            self
        }
        /// <p>A database name in the Glue Data Catalog.</p>
        pub fn set_database_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.database_name = input;
            self
        }
        /// <p>A table name in the Glue Data Catalog.</p>
        pub fn table_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.table_name = Some(input.into());
            self
        }
        /// <p>A table name in the Glue Data Catalog.</p>
        pub fn set_table_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.table_name = input;
            self
        }
        /// <p>A unique identifier for the Glue Data Catalog.</p>
        pub fn catalog_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.catalog_id = Some(input.into());
            self
        }
        /// <p>A unique identifier for the Glue Data Catalog.</p>
        pub fn set_catalog_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.catalog_id = input;
            self
        }
        /// <p>The name of the connection to the Glue Data Catalog.</p>
        pub fn connection_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.connection_name = Some(input.into());
            self
        }
        /// <p>The name of the connection to the Glue Data Catalog.</p>
        pub fn set_connection_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.connection_name = input;
            self
        }
        /// Adds a key-value pair to `additional_options`.
        ///
        /// To override the contents of this collection use [`set_additional_options`](Self::set_additional_options).
        ///
        /// <p>Additional options for the table. Currently there are two keys supported:</p>
        /// <ul>
        /// <li> <p> <code>pushDownPredicate</code>: to filter on partitions without having to list and read all the files in your dataset.</p> </li>
        /// <li> <p> <code>catalogPartitionPredicate</code>: to use server-side partition pruning using partition indexes in the Glue Data Catalog.</p> </li>
        /// </ul>
        pub fn additional_options(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.additional_options.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.additional_options = Some(hash_map);
            self
        }
        /// <p>Additional options for the table. Currently there are two keys supported:</p>
        /// <ul>
        /// <li> <p> <code>pushDownPredicate</code>: to filter on partitions without having to list and read all the files in your dataset.</p> </li>
        /// <li> <p> <code>catalogPartitionPredicate</code>: to use server-side partition pruning using partition indexes in the Glue Data Catalog.</p> </li>
        /// </ul>
        pub fn set_additional_options(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.additional_options = input;
            self
        }
        /// Consumes the builder and constructs a [`GlueTable`](crate::model::GlueTable).
        pub fn build(self) -> crate::model::GlueTable {
            crate::model::GlueTable {
                database_name: self.database_name,
                table_name: self.table_name,
                catalog_id: self.catalog_id,
                connection_name: self.connection_name,
                additional_options: self.additional_options,
            }
        }
    }
}
impl GlueTable {
    /// Creates a new builder-style object to manufacture [`GlueTable`](crate::model::GlueTable).
    pub fn builder() -> crate::model::glue_table::Builder {
        crate::model::glue_table::Builder::default()
    }
}

/// <p>Represents a collection of related data organized in columns and rows.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Table {
    /// <p>The table name. For Hive compatibility, this must be entirely lowercase.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The name of the database where the table metadata resides. For Hive compatibility, this must be all lowercase.</p>
    #[doc(hidden)]
    pub database_name: std::option::Option<std::string::String>,
    /// <p>A description of the table.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The owner of the table.</p>
    #[doc(hidden)]
    pub owner: std::option::Option<std::string::String>,
    /// <p>The time when the table definition was created in the Data Catalog.</p>
    #[doc(hidden)]
    pub create_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The last time that the table was updated.</p>
    #[doc(hidden)]
    pub update_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The last time that the table was accessed. This is usually taken from HDFS, and might not be reliable.</p>
    #[doc(hidden)]
    pub last_access_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The last time that column statistics were computed for this table.</p>
    #[doc(hidden)]
    pub last_analyzed_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The retention time for this table.</p>
    #[doc(hidden)]
    pub retention: i32,
    /// <p>A storage descriptor containing information about the physical storage of this table.</p>
    #[doc(hidden)]
    pub storage_descriptor: std::option::Option<crate::model::StorageDescriptor>,
    /// <p>A list of columns by which the table is partitioned. Only primitive types are supported as partition keys.</p>
    /// <p>When you create a table used by Amazon Athena, and you do not specify any <code>partitionKeys</code>, you must at least set the value of <code>partitionKeys</code> to an empty list. For example:</p>
    /// <p> <code>"PartitionKeys": []</code> </p>
    #[doc(hidden)]
    pub partition_keys: std::option::Option<std::vec::Vec<crate::model::Column>>,
    /// <p>If the table is a view, the original text of the view; otherwise <code>null</code>.</p>
    #[doc(hidden)]
    pub view_original_text: std::option::Option<std::string::String>,
    /// <p>If the table is a view, the expanded text of the view; otherwise <code>null</code>.</p>
    #[doc(hidden)]
    pub view_expanded_text: std::option::Option<std::string::String>,
    /// <p>The type of this table (<code>EXTERNAL_TABLE</code>, <code>VIRTUAL_VIEW</code>, etc.).</p>
    #[doc(hidden)]
    pub table_type: std::option::Option<std::string::String>,
    /// <p>These key-value pairs define properties associated with the table.</p>
    #[doc(hidden)]
    pub parameters:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The person or entity who created the table.</p>
    #[doc(hidden)]
    pub created_by: std::option::Option<std::string::String>,
    /// <p>Indicates whether the table has been registered with Lake Formation.</p>
    #[doc(hidden)]
    pub is_registered_with_lake_formation: bool,
    /// <p>A <code>TableIdentifier</code> structure that describes a target table for resource linking.</p>
    #[doc(hidden)]
    pub target_table: std::option::Option<crate::model::TableIdentifier>,
    /// <p>The ID of the Data Catalog in which the table resides.</p>
    #[doc(hidden)]
    pub catalog_id: std::option::Option<std::string::String>,
    /// <p>The ID of the table version.</p>
    #[doc(hidden)]
    pub version_id: std::option::Option<std::string::String>,
}
impl Table {
    /// <p>The table name. For Hive compatibility, this must be entirely lowercase.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The name of the database where the table metadata resides. For Hive compatibility, this must be all lowercase.</p>
    pub fn database_name(&self) -> std::option::Option<&str> {
        self.database_name.as_deref()
    }
    /// <p>A description of the table.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The owner of the table.</p>
    pub fn owner(&self) -> std::option::Option<&str> {
        self.owner.as_deref()
    }
    /// <p>The time when the table definition was created in the Data Catalog.</p>
    pub fn create_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.create_time.as_ref()
    }
    /// <p>The last time that the table was updated.</p>
    pub fn update_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.update_time.as_ref()
    }
    /// <p>The last time that the table was accessed. This is usually taken from HDFS, and might not be reliable.</p>
    pub fn last_access_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_access_time.as_ref()
    }
    /// <p>The last time that column statistics were computed for this table.</p>
    pub fn last_analyzed_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_analyzed_time.as_ref()
    }
    /// <p>The retention time for this table.</p>
    pub fn retention(&self) -> i32 {
        self.retention
    }
    /// <p>A storage descriptor containing information about the physical storage of this table.</p>
    pub fn storage_descriptor(&self) -> std::option::Option<&crate::model::StorageDescriptor> {
        self.storage_descriptor.as_ref()
    }
    /// <p>A list of columns by which the table is partitioned. Only primitive types are supported as partition keys.</p>
    /// <p>When you create a table used by Amazon Athena, and you do not specify any <code>partitionKeys</code>, you must at least set the value of <code>partitionKeys</code> to an empty list. For example:</p>
    /// <p> <code>"PartitionKeys": []</code> </p>
    pub fn partition_keys(&self) -> std::option::Option<&[crate::model::Column]> {
        self.partition_keys.as_deref()
    }
    /// <p>If the table is a view, the original text of the view; otherwise <code>null</code>.</p>
    pub fn view_original_text(&self) -> std::option::Option<&str> {
        self.view_original_text.as_deref()
    }
    /// <p>If the table is a view, the expanded text of the view; otherwise <code>null</code>.</p>
    pub fn view_expanded_text(&self) -> std::option::Option<&str> {
        self.view_expanded_text.as_deref()
    }
    /// <p>The type of this table (<code>EXTERNAL_TABLE</code>, <code>VIRTUAL_VIEW</code>, etc.).</p>
    pub fn table_type(&self) -> std::option::Option<&str> {
        self.table_type.as_deref()
    }
    /// <p>These key-value pairs define properties associated with the table.</p>
    pub fn parameters(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.parameters.as_ref()
    }
    /// <p>The person or entity who created the table.</p>
    pub fn created_by(&self) -> std::option::Option<&str> {
        self.created_by.as_deref()
    }
    /// <p>Indicates whether the table has been registered with Lake Formation.</p>
    pub fn is_registered_with_lake_formation(&self) -> bool {
        self.is_registered_with_lake_formation
    }
    /// <p>A <code>TableIdentifier</code> structure that describes a target table for resource linking.</p>
    pub fn target_table(&self) -> std::option::Option<&crate::model::TableIdentifier> {
        self.target_table.as_ref()
    }
    /// <p>The ID of the Data Catalog in which the table resides.</p>
    pub fn catalog_id(&self) -> std::option::Option<&str> {
        self.catalog_id.as_deref()
    }
    /// <p>The ID of the table version.</p>
    pub fn version_id(&self) -> std::option::Option<&str> {
        self.version_id.as_deref()
    }
}
/// See [`Table`](crate::model::Table).
pub mod table {

    /// A builder for [`Table`](crate::model::Table).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) database_name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) owner: std::option::Option<std::string::String>,
        pub(crate) create_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) update_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_access_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_analyzed_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) retention: std::option::Option<i32>,
        pub(crate) storage_descriptor: std::option::Option<crate::model::StorageDescriptor>,
        pub(crate) partition_keys: std::option::Option<std::vec::Vec<crate::model::Column>>,
        pub(crate) view_original_text: std::option::Option<std::string::String>,
        pub(crate) view_expanded_text: std::option::Option<std::string::String>,
        pub(crate) table_type: std::option::Option<std::string::String>,
        pub(crate) parameters: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) created_by: std::option::Option<std::string::String>,
        pub(crate) is_registered_with_lake_formation: std::option::Option<bool>,
        pub(crate) target_table: std::option::Option<crate::model::TableIdentifier>,
        pub(crate) catalog_id: std::option::Option<std::string::String>,
        pub(crate) version_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The table name. For Hive compatibility, this must be entirely lowercase.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The table name. For Hive compatibility, this must be entirely lowercase.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The name of the database where the table metadata resides. For Hive compatibility, this must be all lowercase.</p>
        pub fn database_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.database_name = Some(input.into());
            self
        }
        /// <p>The name of the database where the table metadata resides. For Hive compatibility, this must be all lowercase.</p>
        pub fn set_database_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.database_name = input;
            self
        }
        /// <p>A description of the table.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A description of the table.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The owner of the table.</p>
        pub fn owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.owner = Some(input.into());
            self
        }
        /// <p>The owner of the table.</p>
        pub fn set_owner(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.owner = input;
            self
        }
        /// <p>The time when the table definition was created in the Data Catalog.</p>
        pub fn create_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.create_time = Some(input);
            self
        }
        /// <p>The time when the table definition was created in the Data Catalog.</p>
        pub fn set_create_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.create_time = input;
            self
        }
        /// <p>The last time that the table was updated.</p>
        pub fn update_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.update_time = Some(input);
            self
        }
        /// <p>The last time that the table was updated.</p>
        pub fn set_update_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.update_time = input;
            self
        }
        /// <p>The last time that the table was accessed. This is usually taken from HDFS, and might not be reliable.</p>
        pub fn last_access_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_access_time = Some(input);
            self
        }
        /// <p>The last time that the table was accessed. This is usually taken from HDFS, and might not be reliable.</p>
        pub fn set_last_access_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_access_time = input;
            self
        }
        /// <p>The last time that column statistics were computed for this table.</p>
        pub fn last_analyzed_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_analyzed_time = Some(input);
            self
        }
        /// <p>The last time that column statistics were computed for this table.</p>
        pub fn set_last_analyzed_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_analyzed_time = input;
            self
        }
        /// <p>The retention time for this table.</p>
        pub fn retention(mut self, input: i32) -> Self {
            self.retention = Some(input);
            self
        }
        /// <p>The retention time for this table.</p>
        pub fn set_retention(mut self, input: std::option::Option<i32>) -> Self {
            self.retention = input;
            self
        }
        /// <p>A storage descriptor containing information about the physical storage of this table.</p>
        pub fn storage_descriptor(mut self, input: crate::model::StorageDescriptor) -> Self {
            self.storage_descriptor = Some(input);
            self
        }
        /// <p>A storage descriptor containing information about the physical storage of this table.</p>
        pub fn set_storage_descriptor(
            mut self,
            input: std::option::Option<crate::model::StorageDescriptor>,
        ) -> Self {
            self.storage_descriptor = input;
            self
        }
        /// Appends an item to `partition_keys`.
        ///
        /// To override the contents of this collection use [`set_partition_keys`](Self::set_partition_keys).
        ///
        /// <p>A list of columns by which the table is partitioned. Only primitive types are supported as partition keys.</p>
        /// <p>When you create a table used by Amazon Athena, and you do not specify any <code>partitionKeys</code>, you must at least set the value of <code>partitionKeys</code> to an empty list. For example:</p>
        /// <p> <code>"PartitionKeys": []</code> </p>
        pub fn partition_keys(mut self, input: crate::model::Column) -> Self {
            let mut v = self.partition_keys.unwrap_or_default();
            v.push(input);
            self.partition_keys = Some(v);
            self
        }
        /// <p>A list of columns by which the table is partitioned. Only primitive types are supported as partition keys.</p>
        /// <p>When you create a table used by Amazon Athena, and you do not specify any <code>partitionKeys</code>, you must at least set the value of <code>partitionKeys</code> to an empty list. For example:</p>
        /// <p> <code>"PartitionKeys": []</code> </p>
        pub fn set_partition_keys(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Column>>,
        ) -> Self {
            self.partition_keys = input;
            self
        }
        /// <p>If the table is a view, the original text of the view; otherwise <code>null</code>.</p>
        pub fn view_original_text(mut self, input: impl Into<std::string::String>) -> Self {
            self.view_original_text = Some(input.into());
            self
        }
        /// <p>If the table is a view, the original text of the view; otherwise <code>null</code>.</p>
        pub fn set_view_original_text(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.view_original_text = input;
            self
        }
        /// <p>If the table is a view, the expanded text of the view; otherwise <code>null</code>.</p>
        pub fn view_expanded_text(mut self, input: impl Into<std::string::String>) -> Self {
            self.view_expanded_text = Some(input.into());
            self
        }
        /// <p>If the table is a view, the expanded text of the view; otherwise <code>null</code>.</p>
        pub fn set_view_expanded_text(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.view_expanded_text = input;
            self
        }
        /// <p>The type of this table (<code>EXTERNAL_TABLE</code>, <code>VIRTUAL_VIEW</code>, etc.).</p>
        pub fn table_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.table_type = Some(input.into());
            self
        }
        /// <p>The type of this table (<code>EXTERNAL_TABLE</code>, <code>VIRTUAL_VIEW</code>, etc.).</p>
        pub fn set_table_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.table_type = input;
            self
        }
        /// Adds a key-value pair to `parameters`.
        ///
        /// To override the contents of this collection use [`set_parameters`](Self::set_parameters).
        ///
        /// <p>These key-value pairs define properties associated with the table.</p>
        pub fn parameters(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.parameters.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.parameters = Some(hash_map);
            self
        }
        /// <p>These key-value pairs define properties associated with the table.</p>
        pub fn set_parameters(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.parameters = input;
            self
        }
        /// <p>The person or entity who created the table.</p>
        pub fn created_by(mut self, input: impl Into<std::string::String>) -> Self {
            self.created_by = Some(input.into());
            self
        }
        /// <p>The person or entity who created the table.</p>
        pub fn set_created_by(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.created_by = input;
            self
        }
        /// <p>Indicates whether the table has been registered with Lake Formation.</p>
        pub fn is_registered_with_lake_formation(mut self, input: bool) -> Self {
            self.is_registered_with_lake_formation = Some(input);
            self
        }
        /// <p>Indicates whether the table has been registered with Lake Formation.</p>
        pub fn set_is_registered_with_lake_formation(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.is_registered_with_lake_formation = input;
            self
        }
        /// <p>A <code>TableIdentifier</code> structure that describes a target table for resource linking.</p>
        pub fn target_table(mut self, input: crate::model::TableIdentifier) -> Self {
            self.target_table = Some(input);
            self
        }
        /// <p>A <code>TableIdentifier</code> structure that describes a target table for resource linking.</p>
        pub fn set_target_table(
            mut self,
            input: std::option::Option<crate::model::TableIdentifier>,
        ) -> Self {
            self.target_table = input;
            self
        }
        /// <p>The ID of the Data Catalog in which the table resides.</p>
        pub fn catalog_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.catalog_id = Some(input.into());
            self
        }
        /// <p>The ID of the Data Catalog in which the table resides.</p>
        pub fn set_catalog_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.catalog_id = input;
            self
        }
        /// <p>The ID of the table version.</p>
        pub fn version_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.version_id = Some(input.into());
            self
        }
        /// <p>The ID of the table version.</p>
        pub fn set_version_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.version_id = input;
            self
        }
        /// Consumes the builder and constructs a [`Table`](crate::model::Table).
        pub fn build(self) -> crate::model::Table {
            crate::model::Table {
                name: self.name,
                database_name: self.database_name,
                description: self.description,
                owner: self.owner,
                create_time: self.create_time,
                update_time: self.update_time,
                last_access_time: self.last_access_time,
                last_analyzed_time: self.last_analyzed_time,
                retention: self.retention.unwrap_or_default(),
                storage_descriptor: self.storage_descriptor,
                partition_keys: self.partition_keys,
                view_original_text: self.view_original_text,
                view_expanded_text: self.view_expanded_text,
                table_type: self.table_type,
                parameters: self.parameters,
                created_by: self.created_by,
                is_registered_with_lake_formation: self
                    .is_registered_with_lake_formation
                    .unwrap_or_default(),
                target_table: self.target_table,
                catalog_id: self.catalog_id,
                version_id: self.version_id,
            }
        }
    }
}
impl Table {
    /// Creates a new builder-style object to manufacture [`Table`](crate::model::Table).
    pub fn builder() -> crate::model::table::Builder {
        crate::model::table::Builder::default()
    }
}

/// When writing a match expression against `ResourceShareType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let resourcesharetype = unimplemented!();
/// match resourcesharetype {
///     ResourceShareType::All => { /* ... */ },
///     ResourceShareType::Foreign => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `resourcesharetype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ResourceShareType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ResourceShareType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ResourceShareType::NewFeature` is defined.
/// Specifically, when `resourcesharetype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ResourceShareType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ResourceShareType {
    #[allow(missing_docs)] // documentation missing in model
    All,
    #[allow(missing_docs)] // documentation missing in model
    Foreign,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ResourceShareType {
    fn from(s: &str) -> Self {
        match s {
            "ALL" => ResourceShareType::All,
            "FOREIGN" => ResourceShareType::Foreign,
            other => {
                ResourceShareType::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for ResourceShareType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ResourceShareType::from(s))
    }
}
impl ResourceShareType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ResourceShareType::All => "ALL",
            ResourceShareType::Foreign => "FOREIGN",
            ResourceShareType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ALL", "FOREIGN"]
    }
}
impl AsRef<str> for ResourceShareType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Specifies a field to sort by and a sort order.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SortCriterion {
    /// <p>The name of the field on which to sort.</p>
    #[doc(hidden)]
    pub field_name: std::option::Option<std::string::String>,
    /// <p>An ascending or descending sort.</p>
    #[doc(hidden)]
    pub sort: std::option::Option<crate::model::Sort>,
}
impl SortCriterion {
    /// <p>The name of the field on which to sort.</p>
    pub fn field_name(&self) -> std::option::Option<&str> {
        self.field_name.as_deref()
    }
    /// <p>An ascending or descending sort.</p>
    pub fn sort(&self) -> std::option::Option<&crate::model::Sort> {
        self.sort.as_ref()
    }
}
/// See [`SortCriterion`](crate::model::SortCriterion).
pub mod sort_criterion {

    /// A builder for [`SortCriterion`](crate::model::SortCriterion).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) field_name: std::option::Option<std::string::String>,
        pub(crate) sort: std::option::Option<crate::model::Sort>,
    }
    impl Builder {
        /// <p>The name of the field on which to sort.</p>
        pub fn field_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.field_name = Some(input.into());
            self
        }
        /// <p>The name of the field on which to sort.</p>
        pub fn set_field_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.field_name = input;
            self
        }
        /// <p>An ascending or descending sort.</p>
        pub fn sort(mut self, input: crate::model::Sort) -> Self {
            self.sort = Some(input);
            self
        }
        /// <p>An ascending or descending sort.</p>
        pub fn set_sort(mut self, input: std::option::Option<crate::model::Sort>) -> Self {
            self.sort = input;
            self
        }
        /// Consumes the builder and constructs a [`SortCriterion`](crate::model::SortCriterion).
        pub fn build(self) -> crate::model::SortCriterion {
            crate::model::SortCriterion {
                field_name: self.field_name,
                sort: self.sort,
            }
        }
    }
}
impl SortCriterion {
    /// Creates a new builder-style object to manufacture [`SortCriterion`](crate::model::SortCriterion).
    pub fn builder() -> crate::model::sort_criterion::Builder {
        crate::model::sort_criterion::Builder::default()
    }
}

/// When writing a match expression against `Sort`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let sort = unimplemented!();
/// match sort {
///     Sort::Ascending => { /* ... */ },
///     Sort::Descending => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `sort` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `Sort::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `Sort::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `Sort::NewFeature` is defined.
/// Specifically, when `sort` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `Sort::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Sort {
    #[allow(missing_docs)] // documentation missing in model
    Ascending,
    #[allow(missing_docs)] // documentation missing in model
    Descending,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for Sort {
    fn from(s: &str) -> Self {
        match s {
            "ASC" => Sort::Ascending,
            "DESC" => Sort::Descending,
            other => Sort::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for Sort {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(Sort::from(s))
    }
}
impl Sort {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            Sort::Ascending => "ASC",
            Sort::Descending => "DESC",
            Sort::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ASC", "DESC"]
    }
}
impl AsRef<str> for Sort {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Defines a property predicate.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PropertyPredicate {
    /// <p>The key of the property.</p>
    #[doc(hidden)]
    pub key: std::option::Option<std::string::String>,
    /// <p>The value of the property.</p>
    #[doc(hidden)]
    pub value: std::option::Option<std::string::String>,
    /// <p>The comparator used to compare this property to others.</p>
    #[doc(hidden)]
    pub comparator: std::option::Option<crate::model::Comparator>,
}
impl PropertyPredicate {
    /// <p>The key of the property.</p>
    pub fn key(&self) -> std::option::Option<&str> {
        self.key.as_deref()
    }
    /// <p>The value of the property.</p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
    /// <p>The comparator used to compare this property to others.</p>
    pub fn comparator(&self) -> std::option::Option<&crate::model::Comparator> {
        self.comparator.as_ref()
    }
}
/// See [`PropertyPredicate`](crate::model::PropertyPredicate).
pub mod property_predicate {

    /// A builder for [`PropertyPredicate`](crate::model::PropertyPredicate).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
        pub(crate) comparator: std::option::Option<crate::model::Comparator>,
    }
    impl Builder {
        /// <p>The key of the property.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        /// <p>The key of the property.</p>
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// <p>The value of the property.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>The value of the property.</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// <p>The comparator used to compare this property to others.</p>
        pub fn comparator(mut self, input: crate::model::Comparator) -> Self {
            self.comparator = Some(input);
            self
        }
        /// <p>The comparator used to compare this property to others.</p>
        pub fn set_comparator(
            mut self,
            input: std::option::Option<crate::model::Comparator>,
        ) -> Self {
            self.comparator = input;
            self
        }
        /// Consumes the builder and constructs a [`PropertyPredicate`](crate::model::PropertyPredicate).
        pub fn build(self) -> crate::model::PropertyPredicate {
            crate::model::PropertyPredicate {
                key: self.key,
                value: self.value,
                comparator: self.comparator,
            }
        }
    }
}
impl PropertyPredicate {
    /// Creates a new builder-style object to manufacture [`PropertyPredicate`](crate::model::PropertyPredicate).
    pub fn builder() -> crate::model::property_predicate::Builder {
        crate::model::property_predicate::Builder::default()
    }
}

/// When writing a match expression against `Comparator`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let comparator = unimplemented!();
/// match comparator {
///     Comparator::Equals => { /* ... */ },
///     Comparator::GreaterThan => { /* ... */ },
///     Comparator::GreaterThanEquals => { /* ... */ },
///     Comparator::LessThan => { /* ... */ },
///     Comparator::LessThanEquals => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `comparator` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `Comparator::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `Comparator::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `Comparator::NewFeature` is defined.
/// Specifically, when `comparator` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `Comparator::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Comparator {
    #[allow(missing_docs)] // documentation missing in model
    Equals,
    #[allow(missing_docs)] // documentation missing in model
    GreaterThan,
    #[allow(missing_docs)] // documentation missing in model
    GreaterThanEquals,
    #[allow(missing_docs)] // documentation missing in model
    LessThan,
    #[allow(missing_docs)] // documentation missing in model
    LessThanEquals,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for Comparator {
    fn from(s: &str) -> Self {
        match s {
            "EQUALS" => Comparator::Equals,
            "GREATER_THAN" => Comparator::GreaterThan,
            "GREATER_THAN_EQUALS" => Comparator::GreaterThanEquals,
            "LESS_THAN" => Comparator::LessThan,
            "LESS_THAN_EQUALS" => Comparator::LessThanEquals,
            other => Comparator::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for Comparator {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(Comparator::from(s))
    }
}
impl Comparator {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            Comparator::Equals => "EQUALS",
            Comparator::GreaterThan => "GREATER_THAN",
            Comparator::GreaterThanEquals => "GREATER_THAN_EQUALS",
            Comparator::LessThan => "LESS_THAN",
            Comparator::LessThanEquals => "LESS_THAN_EQUALS",
            Comparator::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "EQUALS",
            "GREATER_THAN",
            "GREATER_THAN_EQUALS",
            "LESS_THAN",
            "LESS_THAN_EQUALS",
        ]
    }
}
impl AsRef<str> for Comparator {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Defines a point that a job can resume processing.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct JobBookmarkEntry {
    /// <p>The name of the job in question.</p>
    #[doc(hidden)]
    pub job_name: std::option::Option<std::string::String>,
    /// <p>The version of the job.</p>
    #[doc(hidden)]
    pub version: i32,
    /// <p>The run ID number.</p>
    #[doc(hidden)]
    pub run: i32,
    /// <p>The attempt ID number.</p>
    #[doc(hidden)]
    pub attempt: i32,
    /// <p>The unique run identifier associated with the previous job run.</p>
    #[doc(hidden)]
    pub previous_run_id: std::option::Option<std::string::String>,
    /// <p>The run ID number.</p>
    #[doc(hidden)]
    pub run_id: std::option::Option<std::string::String>,
    /// <p>The bookmark itself.</p>
    #[doc(hidden)]
    pub job_bookmark: std::option::Option<std::string::String>,
}
impl JobBookmarkEntry {
    /// <p>The name of the job in question.</p>
    pub fn job_name(&self) -> std::option::Option<&str> {
        self.job_name.as_deref()
    }
    /// <p>The version of the job.</p>
    pub fn version(&self) -> i32 {
        self.version
    }
    /// <p>The run ID number.</p>
    pub fn run(&self) -> i32 {
        self.run
    }
    /// <p>The attempt ID number.</p>
    pub fn attempt(&self) -> i32 {
        self.attempt
    }
    /// <p>The unique run identifier associated with the previous job run.</p>
    pub fn previous_run_id(&self) -> std::option::Option<&str> {
        self.previous_run_id.as_deref()
    }
    /// <p>The run ID number.</p>
    pub fn run_id(&self) -> std::option::Option<&str> {
        self.run_id.as_deref()
    }
    /// <p>The bookmark itself.</p>
    pub fn job_bookmark(&self) -> std::option::Option<&str> {
        self.job_bookmark.as_deref()
    }
}
/// See [`JobBookmarkEntry`](crate::model::JobBookmarkEntry).
pub mod job_bookmark_entry {

    /// A builder for [`JobBookmarkEntry`](crate::model::JobBookmarkEntry).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) job_name: std::option::Option<std::string::String>,
        pub(crate) version: std::option::Option<i32>,
        pub(crate) run: std::option::Option<i32>,
        pub(crate) attempt: std::option::Option<i32>,
        pub(crate) previous_run_id: std::option::Option<std::string::String>,
        pub(crate) run_id: std::option::Option<std::string::String>,
        pub(crate) job_bookmark: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the job in question.</p>
        pub fn job_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_name = Some(input.into());
            self
        }
        /// <p>The name of the job in question.</p>
        pub fn set_job_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_name = input;
            self
        }
        /// <p>The version of the job.</p>
        pub fn version(mut self, input: i32) -> Self {
            self.version = Some(input);
            self
        }
        /// <p>The version of the job.</p>
        pub fn set_version(mut self, input: std::option::Option<i32>) -> Self {
            self.version = input;
            self
        }
        /// <p>The run ID number.</p>
        pub fn run(mut self, input: i32) -> Self {
            self.run = Some(input);
            self
        }
        /// <p>The run ID number.</p>
        pub fn set_run(mut self, input: std::option::Option<i32>) -> Self {
            self.run = input;
            self
        }
        /// <p>The attempt ID number.</p>
        pub fn attempt(mut self, input: i32) -> Self {
            self.attempt = Some(input);
            self
        }
        /// <p>The attempt ID number.</p>
        pub fn set_attempt(mut self, input: std::option::Option<i32>) -> Self {
            self.attempt = input;
            self
        }
        /// <p>The unique run identifier associated with the previous job run.</p>
        pub fn previous_run_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.previous_run_id = Some(input.into());
            self
        }
        /// <p>The unique run identifier associated with the previous job run.</p>
        pub fn set_previous_run_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.previous_run_id = input;
            self
        }
        /// <p>The run ID number.</p>
        pub fn run_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.run_id = Some(input.into());
            self
        }
        /// <p>The run ID number.</p>
        pub fn set_run_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.run_id = input;
            self
        }
        /// <p>The bookmark itself.</p>
        pub fn job_bookmark(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_bookmark = Some(input.into());
            self
        }
        /// <p>The bookmark itself.</p>
        pub fn set_job_bookmark(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_bookmark = input;
            self
        }
        /// Consumes the builder and constructs a [`JobBookmarkEntry`](crate::model::JobBookmarkEntry).
        pub fn build(self) -> crate::model::JobBookmarkEntry {
            crate::model::JobBookmarkEntry {
                job_name: self.job_name,
                version: self.version.unwrap_or_default(),
                run: self.run.unwrap_or_default(),
                attempt: self.attempt.unwrap_or_default(),
                previous_run_id: self.previous_run_id,
                run_id: self.run_id,
                job_bookmark: self.job_bookmark,
            }
        }
    }
}
impl JobBookmarkEntry {
    /// Creates a new builder-style object to manufacture [`JobBookmarkEntry`](crate::model::JobBookmarkEntry).
    pub fn builder() -> crate::model::job_bookmark_entry::Builder {
        crate::model::job_bookmark_entry::Builder::default()
    }
}

/// <p>A structure containing a key value pair for metadata.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct MetadataKeyValuePair {
    /// <p>A metadata key.</p>
    #[doc(hidden)]
    pub metadata_key: std::option::Option<std::string::String>,
    /// <p>A metadata key’s corresponding value.</p>
    #[doc(hidden)]
    pub metadata_value: std::option::Option<std::string::String>,
}
impl MetadataKeyValuePair {
    /// <p>A metadata key.</p>
    pub fn metadata_key(&self) -> std::option::Option<&str> {
        self.metadata_key.as_deref()
    }
    /// <p>A metadata key’s corresponding value.</p>
    pub fn metadata_value(&self) -> std::option::Option<&str> {
        self.metadata_value.as_deref()
    }
}
/// See [`MetadataKeyValuePair`](crate::model::MetadataKeyValuePair).
pub mod metadata_key_value_pair {

    /// A builder for [`MetadataKeyValuePair`](crate::model::MetadataKeyValuePair).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) metadata_key: std::option::Option<std::string::String>,
        pub(crate) metadata_value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A metadata key.</p>
        pub fn metadata_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.metadata_key = Some(input.into());
            self
        }
        /// <p>A metadata key.</p>
        pub fn set_metadata_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.metadata_key = input;
            self
        }
        /// <p>A metadata key’s corresponding value.</p>
        pub fn metadata_value(mut self, input: impl Into<std::string::String>) -> Self {
            self.metadata_value = Some(input.into());
            self
        }
        /// <p>A metadata key’s corresponding value.</p>
        pub fn set_metadata_value(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.metadata_value = input;
            self
        }
        /// Consumes the builder and constructs a [`MetadataKeyValuePair`](crate::model::MetadataKeyValuePair).
        pub fn build(self) -> crate::model::MetadataKeyValuePair {
            crate::model::MetadataKeyValuePair {
                metadata_key: self.metadata_key,
                metadata_value: self.metadata_value,
            }
        }
    }
}
impl MetadataKeyValuePair {
    /// Creates a new builder-style object to manufacture [`MetadataKeyValuePair`](crate::model::MetadataKeyValuePair).
    pub fn builder() -> crate::model::metadata_key_value_pair::Builder {
        crate::model::metadata_key_value_pair::Builder::default()
    }
}

/// When writing a match expression against `SchemaVersionStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let schemaversionstatus = unimplemented!();
/// match schemaversionstatus {
///     SchemaVersionStatus::Available => { /* ... */ },
///     SchemaVersionStatus::Deleting => { /* ... */ },
///     SchemaVersionStatus::Failure => { /* ... */ },
///     SchemaVersionStatus::Pending => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `schemaversionstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `SchemaVersionStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `SchemaVersionStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `SchemaVersionStatus::NewFeature` is defined.
/// Specifically, when `schemaversionstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `SchemaVersionStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SchemaVersionStatus {
    #[allow(missing_docs)] // documentation missing in model
    Available,
    #[allow(missing_docs)] // documentation missing in model
    Deleting,
    #[allow(missing_docs)] // documentation missing in model
    Failure,
    #[allow(missing_docs)] // documentation missing in model
    Pending,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for SchemaVersionStatus {
    fn from(s: &str) -> Self {
        match s {
            "AVAILABLE" => SchemaVersionStatus::Available,
            "DELETING" => SchemaVersionStatus::Deleting,
            "FAILURE" => SchemaVersionStatus::Failure,
            "PENDING" => SchemaVersionStatus::Pending,
            other => {
                SchemaVersionStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for SchemaVersionStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SchemaVersionStatus::from(s))
    }
}
impl SchemaVersionStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            SchemaVersionStatus::Available => "AVAILABLE",
            SchemaVersionStatus::Deleting => "DELETING",
            SchemaVersionStatus::Failure => "FAILURE",
            SchemaVersionStatus::Pending => "PENDING",
            SchemaVersionStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["AVAILABLE", "DELETING", "FAILURE", "PENDING"]
    }
}
impl AsRef<str> for SchemaVersionStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A structure containing metadata information for a schema version.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct MetadataInfo {
    /// <p>The metadata key’s corresponding value.</p>
    #[doc(hidden)]
    pub metadata_value: std::option::Option<std::string::String>,
    /// <p>The time at which the entry was created.</p>
    #[doc(hidden)]
    pub created_time: std::option::Option<std::string::String>,
    /// <p>Other metadata belonging to the same metadata key.</p>
    #[doc(hidden)]
    pub other_metadata_value_list:
        std::option::Option<std::vec::Vec<crate::model::OtherMetadataValueListItem>>,
}
impl MetadataInfo {
    /// <p>The metadata key’s corresponding value.</p>
    pub fn metadata_value(&self) -> std::option::Option<&str> {
        self.metadata_value.as_deref()
    }
    /// <p>The time at which the entry was created.</p>
    pub fn created_time(&self) -> std::option::Option<&str> {
        self.created_time.as_deref()
    }
    /// <p>Other metadata belonging to the same metadata key.</p>
    pub fn other_metadata_value_list(
        &self,
    ) -> std::option::Option<&[crate::model::OtherMetadataValueListItem]> {
        self.other_metadata_value_list.as_deref()
    }
}
/// See [`MetadataInfo`](crate::model::MetadataInfo).
pub mod metadata_info {

    /// A builder for [`MetadataInfo`](crate::model::MetadataInfo).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) metadata_value: std::option::Option<std::string::String>,
        pub(crate) created_time: std::option::Option<std::string::String>,
        pub(crate) other_metadata_value_list:
            std::option::Option<std::vec::Vec<crate::model::OtherMetadataValueListItem>>,
    }
    impl Builder {
        /// <p>The metadata key’s corresponding value.</p>
        pub fn metadata_value(mut self, input: impl Into<std::string::String>) -> Self {
            self.metadata_value = Some(input.into());
            self
        }
        /// <p>The metadata key’s corresponding value.</p>
        pub fn set_metadata_value(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.metadata_value = input;
            self
        }
        /// <p>The time at which the entry was created.</p>
        pub fn created_time(mut self, input: impl Into<std::string::String>) -> Self {
            self.created_time = Some(input.into());
            self
        }
        /// <p>The time at which the entry was created.</p>
        pub fn set_created_time(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.created_time = input;
            self
        }
        /// Appends an item to `other_metadata_value_list`.
        ///
        /// To override the contents of this collection use [`set_other_metadata_value_list`](Self::set_other_metadata_value_list).
        ///
        /// <p>Other metadata belonging to the same metadata key.</p>
        pub fn other_metadata_value_list(
            mut self,
            input: crate::model::OtherMetadataValueListItem,
        ) -> Self {
            let mut v = self.other_metadata_value_list.unwrap_or_default();
            v.push(input);
            self.other_metadata_value_list = Some(v);
            self
        }
        /// <p>Other metadata belonging to the same metadata key.</p>
        pub fn set_other_metadata_value_list(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::OtherMetadataValueListItem>>,
        ) -> Self {
            self.other_metadata_value_list = input;
            self
        }
        /// Consumes the builder and constructs a [`MetadataInfo`](crate::model::MetadataInfo).
        pub fn build(self) -> crate::model::MetadataInfo {
            crate::model::MetadataInfo {
                metadata_value: self.metadata_value,
                created_time: self.created_time,
                other_metadata_value_list: self.other_metadata_value_list,
            }
        }
    }
}
impl MetadataInfo {
    /// Creates a new builder-style object to manufacture [`MetadataInfo`](crate::model::MetadataInfo).
    pub fn builder() -> crate::model::metadata_info::Builder {
        crate::model::metadata_info::Builder::default()
    }
}

/// <p>A structure containing other metadata for a schema version belonging to the same metadata key.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct OtherMetadataValueListItem {
    /// <p>The metadata key’s corresponding value for the other metadata belonging to the same metadata key.</p>
    #[doc(hidden)]
    pub metadata_value: std::option::Option<std::string::String>,
    /// <p>The time at which the entry was created.</p>
    #[doc(hidden)]
    pub created_time: std::option::Option<std::string::String>,
}
impl OtherMetadataValueListItem {
    /// <p>The metadata key’s corresponding value for the other metadata belonging to the same metadata key.</p>
    pub fn metadata_value(&self) -> std::option::Option<&str> {
        self.metadata_value.as_deref()
    }
    /// <p>The time at which the entry was created.</p>
    pub fn created_time(&self) -> std::option::Option<&str> {
        self.created_time.as_deref()
    }
}
/// See [`OtherMetadataValueListItem`](crate::model::OtherMetadataValueListItem).
pub mod other_metadata_value_list_item {

    /// A builder for [`OtherMetadataValueListItem`](crate::model::OtherMetadataValueListItem).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) metadata_value: std::option::Option<std::string::String>,
        pub(crate) created_time: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The metadata key’s corresponding value for the other metadata belonging to the same metadata key.</p>
        pub fn metadata_value(mut self, input: impl Into<std::string::String>) -> Self {
            self.metadata_value = Some(input.into());
            self
        }
        /// <p>The metadata key’s corresponding value for the other metadata belonging to the same metadata key.</p>
        pub fn set_metadata_value(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.metadata_value = input;
            self
        }
        /// <p>The time at which the entry was created.</p>
        pub fn created_time(mut self, input: impl Into<std::string::String>) -> Self {
            self.created_time = Some(input.into());
            self
        }
        /// <p>The time at which the entry was created.</p>
        pub fn set_created_time(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.created_time = input;
            self
        }
        /// Consumes the builder and constructs a [`OtherMetadataValueListItem`](crate::model::OtherMetadataValueListItem).
        pub fn build(self) -> crate::model::OtherMetadataValueListItem {
            crate::model::OtherMetadataValueListItem {
                metadata_value: self.metadata_value,
                created_time: self.created_time,
            }
        }
    }
}
impl OtherMetadataValueListItem {
    /// Creates a new builder-style object to manufacture [`OtherMetadataValueListItem`](crate::model::OtherMetadataValueListItem).
    pub fn builder() -> crate::model::other_metadata_value_list_item::Builder {
        crate::model::other_metadata_value_list_item::Builder::default()
    }
}

/// When writing a match expression against `EnableHybridValues`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let enablehybridvalues = unimplemented!();
/// match enablehybridvalues {
///     EnableHybridValues::False => { /* ... */ },
///     EnableHybridValues::True => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `enablehybridvalues` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `EnableHybridValues::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `EnableHybridValues::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `EnableHybridValues::NewFeature` is defined.
/// Specifically, when `enablehybridvalues` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `EnableHybridValues::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum EnableHybridValues {
    #[allow(missing_docs)] // documentation missing in model
    False,
    #[allow(missing_docs)] // documentation missing in model
    True,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for EnableHybridValues {
    fn from(s: &str) -> Self {
        match s {
            "FALSE" => EnableHybridValues::False,
            "TRUE" => EnableHybridValues::True,
            other => {
                EnableHybridValues::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for EnableHybridValues {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(EnableHybridValues::from(s))
    }
}
impl EnableHybridValues {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            EnableHybridValues::False => "FALSE",
            EnableHybridValues::True => "TRUE",
            EnableHybridValues::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["FALSE", "TRUE"]
    }
}
impl AsRef<str> for EnableHybridValues {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `ExistCondition`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let existcondition = unimplemented!();
/// match existcondition {
///     ExistCondition::MustExist => { /* ... */ },
///     ExistCondition::None => { /* ... */ },
///     ExistCondition::NotExist => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `existcondition` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ExistCondition::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ExistCondition::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ExistCondition::NewFeature` is defined.
/// Specifically, when `existcondition` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ExistCondition::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ExistCondition {
    #[allow(missing_docs)] // documentation missing in model
    MustExist,
    #[allow(missing_docs)] // documentation missing in model
    None,
    #[allow(missing_docs)] // documentation missing in model
    NotExist,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ExistCondition {
    fn from(s: &str) -> Self {
        match s {
            "MUST_EXIST" => ExistCondition::MustExist,
            "NONE" => ExistCondition::None,
            "NOT_EXIST" => ExistCondition::NotExist,
            other => ExistCondition::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ExistCondition {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ExistCondition::from(s))
    }
}
impl ExistCondition {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ExistCondition::MustExist => "MUST_EXIST",
            ExistCondition::None => "NONE",
            ExistCondition::NotExist => "NOT_EXIST",
            ExistCondition::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["MUST_EXIST", "NONE", "NOT_EXIST"]
    }
}
impl AsRef<str> for ExistCondition {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Contains configuration information for maintaining Data Catalog security.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DataCatalogEncryptionSettings {
    /// <p>Specifies the encryption-at-rest configuration for the Data Catalog.</p>
    #[doc(hidden)]
    pub encryption_at_rest: std::option::Option<crate::model::EncryptionAtRest>,
    /// <p>When connection password protection is enabled, the Data Catalog uses a customer-provided key to encrypt the password as part of <code>CreateConnection</code> or <code>UpdateConnection</code> and store it in the <code>ENCRYPTED_PASSWORD</code> field in the connection properties. You can enable catalog encryption or only password encryption.</p>
    #[doc(hidden)]
    pub connection_password_encryption:
        std::option::Option<crate::model::ConnectionPasswordEncryption>,
}
impl DataCatalogEncryptionSettings {
    /// <p>Specifies the encryption-at-rest configuration for the Data Catalog.</p>
    pub fn encryption_at_rest(&self) -> std::option::Option<&crate::model::EncryptionAtRest> {
        self.encryption_at_rest.as_ref()
    }
    /// <p>When connection password protection is enabled, the Data Catalog uses a customer-provided key to encrypt the password as part of <code>CreateConnection</code> or <code>UpdateConnection</code> and store it in the <code>ENCRYPTED_PASSWORD</code> field in the connection properties. You can enable catalog encryption or only password encryption.</p>
    pub fn connection_password_encryption(
        &self,
    ) -> std::option::Option<&crate::model::ConnectionPasswordEncryption> {
        self.connection_password_encryption.as_ref()
    }
}
/// See [`DataCatalogEncryptionSettings`](crate::model::DataCatalogEncryptionSettings).
pub mod data_catalog_encryption_settings {

    /// A builder for [`DataCatalogEncryptionSettings`](crate::model::DataCatalogEncryptionSettings).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) encryption_at_rest: std::option::Option<crate::model::EncryptionAtRest>,
        pub(crate) connection_password_encryption:
            std::option::Option<crate::model::ConnectionPasswordEncryption>,
    }
    impl Builder {
        /// <p>Specifies the encryption-at-rest configuration for the Data Catalog.</p>
        pub fn encryption_at_rest(mut self, input: crate::model::EncryptionAtRest) -> Self {
            self.encryption_at_rest = Some(input);
            self
        }
        /// <p>Specifies the encryption-at-rest configuration for the Data Catalog.</p>
        pub fn set_encryption_at_rest(
            mut self,
            input: std::option::Option<crate::model::EncryptionAtRest>,
        ) -> Self {
            self.encryption_at_rest = input;
            self
        }
        /// <p>When connection password protection is enabled, the Data Catalog uses a customer-provided key to encrypt the password as part of <code>CreateConnection</code> or <code>UpdateConnection</code> and store it in the <code>ENCRYPTED_PASSWORD</code> field in the connection properties. You can enable catalog encryption or only password encryption.</p>
        pub fn connection_password_encryption(
            mut self,
            input: crate::model::ConnectionPasswordEncryption,
        ) -> Self {
            self.connection_password_encryption = Some(input);
            self
        }
        /// <p>When connection password protection is enabled, the Data Catalog uses a customer-provided key to encrypt the password as part of <code>CreateConnection</code> or <code>UpdateConnection</code> and store it in the <code>ENCRYPTED_PASSWORD</code> field in the connection properties. You can enable catalog encryption or only password encryption.</p>
        pub fn set_connection_password_encryption(
            mut self,
            input: std::option::Option<crate::model::ConnectionPasswordEncryption>,
        ) -> Self {
            self.connection_password_encryption = input;
            self
        }
        /// Consumes the builder and constructs a [`DataCatalogEncryptionSettings`](crate::model::DataCatalogEncryptionSettings).
        pub fn build(self) -> crate::model::DataCatalogEncryptionSettings {
            crate::model::DataCatalogEncryptionSettings {
                encryption_at_rest: self.encryption_at_rest,
                connection_password_encryption: self.connection_password_encryption,
            }
        }
    }
}
impl DataCatalogEncryptionSettings {
    /// Creates a new builder-style object to manufacture [`DataCatalogEncryptionSettings`](crate::model::DataCatalogEncryptionSettings).
    pub fn builder() -> crate::model::data_catalog_encryption_settings::Builder {
        crate::model::data_catalog_encryption_settings::Builder::default()
    }
}

/// <p>The data structure used by the Data Catalog to encrypt the password as part of <code>CreateConnection</code> or <code>UpdateConnection</code> and store it in the <code>ENCRYPTED_PASSWORD</code> field in the connection properties. You can enable catalog encryption or only password encryption.</p>
/// <p>When a <code>CreationConnection</code> request arrives containing a password, the Data Catalog first encrypts the password using your KMS key. It then encrypts the whole connection object again if catalog encryption is also enabled.</p>
/// <p>This encryption requires that you set KMS key permissions to enable or restrict access on the password key according to your security requirements. For example, you might want only administrators to have decrypt permission on the password key.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ConnectionPasswordEncryption {
    /// <p>When the <code>ReturnConnectionPasswordEncrypted</code> flag is set to "true", passwords remain encrypted in the responses of <code>GetConnection</code> and <code>GetConnections</code>. This encryption takes effect independently from catalog encryption. </p>
    #[doc(hidden)]
    pub return_connection_password_encrypted: bool,
    /// <p>An KMS key that is used to encrypt the connection password. </p>
    /// <p>If connection password protection is enabled, the caller of <code>CreateConnection</code> and <code>UpdateConnection</code> needs at least <code>kms:Encrypt</code> permission on the specified KMS key, to encrypt passwords before storing them in the Data Catalog. </p>
    /// <p>You can set the decrypt permission to enable or restrict access on the password key according to your security requirements.</p>
    #[doc(hidden)]
    pub aws_kms_key_id: std::option::Option<std::string::String>,
}
impl ConnectionPasswordEncryption {
    /// <p>When the <code>ReturnConnectionPasswordEncrypted</code> flag is set to "true", passwords remain encrypted in the responses of <code>GetConnection</code> and <code>GetConnections</code>. This encryption takes effect independently from catalog encryption. </p>
    pub fn return_connection_password_encrypted(&self) -> bool {
        self.return_connection_password_encrypted
    }
    /// <p>An KMS key that is used to encrypt the connection password. </p>
    /// <p>If connection password protection is enabled, the caller of <code>CreateConnection</code> and <code>UpdateConnection</code> needs at least <code>kms:Encrypt</code> permission on the specified KMS key, to encrypt passwords before storing them in the Data Catalog. </p>
    /// <p>You can set the decrypt permission to enable or restrict access on the password key according to your security requirements.</p>
    pub fn aws_kms_key_id(&self) -> std::option::Option<&str> {
        self.aws_kms_key_id.as_deref()
    }
}
/// See [`ConnectionPasswordEncryption`](crate::model::ConnectionPasswordEncryption).
pub mod connection_password_encryption {

    /// A builder for [`ConnectionPasswordEncryption`](crate::model::ConnectionPasswordEncryption).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) return_connection_password_encrypted: std::option::Option<bool>,
        pub(crate) aws_kms_key_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>When the <code>ReturnConnectionPasswordEncrypted</code> flag is set to "true", passwords remain encrypted in the responses of <code>GetConnection</code> and <code>GetConnections</code>. This encryption takes effect independently from catalog encryption. </p>
        pub fn return_connection_password_encrypted(mut self, input: bool) -> Self {
            self.return_connection_password_encrypted = Some(input);
            self
        }
        /// <p>When the <code>ReturnConnectionPasswordEncrypted</code> flag is set to "true", passwords remain encrypted in the responses of <code>GetConnection</code> and <code>GetConnections</code>. This encryption takes effect independently from catalog encryption. </p>
        pub fn set_return_connection_password_encrypted(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.return_connection_password_encrypted = input;
            self
        }
        /// <p>An KMS key that is used to encrypt the connection password. </p>
        /// <p>If connection password protection is enabled, the caller of <code>CreateConnection</code> and <code>UpdateConnection</code> needs at least <code>kms:Encrypt</code> permission on the specified KMS key, to encrypt passwords before storing them in the Data Catalog. </p>
        /// <p>You can set the decrypt permission to enable or restrict access on the password key according to your security requirements.</p>
        pub fn aws_kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.aws_kms_key_id = Some(input.into());
            self
        }
        /// <p>An KMS key that is used to encrypt the connection password. </p>
        /// <p>If connection password protection is enabled, the caller of <code>CreateConnection</code> and <code>UpdateConnection</code> needs at least <code>kms:Encrypt</code> permission on the specified KMS key, to encrypt passwords before storing them in the Data Catalog. </p>
        /// <p>You can set the decrypt permission to enable or restrict access on the password key according to your security requirements.</p>
        pub fn set_aws_kms_key_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.aws_kms_key_id = input;
            self
        }
        /// Consumes the builder and constructs a [`ConnectionPasswordEncryption`](crate::model::ConnectionPasswordEncryption).
        pub fn build(self) -> crate::model::ConnectionPasswordEncryption {
            crate::model::ConnectionPasswordEncryption {
                return_connection_password_encrypted: self
                    .return_connection_password_encrypted
                    .unwrap_or_default(),
                aws_kms_key_id: self.aws_kms_key_id,
            }
        }
    }
}
impl ConnectionPasswordEncryption {
    /// Creates a new builder-style object to manufacture [`ConnectionPasswordEncryption`](crate::model::ConnectionPasswordEncryption).
    pub fn builder() -> crate::model::connection_password_encryption::Builder {
        crate::model::connection_password_encryption::Builder::default()
    }
}

/// <p>Specifies the encryption-at-rest configuration for the Data Catalog.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct EncryptionAtRest {
    /// <p>The encryption-at-rest mode for encrypting Data Catalog data.</p>
    #[doc(hidden)]
    pub catalog_encryption_mode: std::option::Option<crate::model::CatalogEncryptionMode>,
    /// <p>The ID of the KMS key to use for encryption at rest.</p>
    #[doc(hidden)]
    pub sse_aws_kms_key_id: std::option::Option<std::string::String>,
}
impl EncryptionAtRest {
    /// <p>The encryption-at-rest mode for encrypting Data Catalog data.</p>
    pub fn catalog_encryption_mode(
        &self,
    ) -> std::option::Option<&crate::model::CatalogEncryptionMode> {
        self.catalog_encryption_mode.as_ref()
    }
    /// <p>The ID of the KMS key to use for encryption at rest.</p>
    pub fn sse_aws_kms_key_id(&self) -> std::option::Option<&str> {
        self.sse_aws_kms_key_id.as_deref()
    }
}
/// See [`EncryptionAtRest`](crate::model::EncryptionAtRest).
pub mod encryption_at_rest {

    /// A builder for [`EncryptionAtRest`](crate::model::EncryptionAtRest).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) catalog_encryption_mode:
            std::option::Option<crate::model::CatalogEncryptionMode>,
        pub(crate) sse_aws_kms_key_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The encryption-at-rest mode for encrypting Data Catalog data.</p>
        pub fn catalog_encryption_mode(
            mut self,
            input: crate::model::CatalogEncryptionMode,
        ) -> Self {
            self.catalog_encryption_mode = Some(input);
            self
        }
        /// <p>The encryption-at-rest mode for encrypting Data Catalog data.</p>
        pub fn set_catalog_encryption_mode(
            mut self,
            input: std::option::Option<crate::model::CatalogEncryptionMode>,
        ) -> Self {
            self.catalog_encryption_mode = input;
            self
        }
        /// <p>The ID of the KMS key to use for encryption at rest.</p>
        pub fn sse_aws_kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.sse_aws_kms_key_id = Some(input.into());
            self
        }
        /// <p>The ID of the KMS key to use for encryption at rest.</p>
        pub fn set_sse_aws_kms_key_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.sse_aws_kms_key_id = input;
            self
        }
        /// Consumes the builder and constructs a [`EncryptionAtRest`](crate::model::EncryptionAtRest).
        pub fn build(self) -> crate::model::EncryptionAtRest {
            crate::model::EncryptionAtRest {
                catalog_encryption_mode: self.catalog_encryption_mode,
                sse_aws_kms_key_id: self.sse_aws_kms_key_id,
            }
        }
    }
}
impl EncryptionAtRest {
    /// Creates a new builder-style object to manufacture [`EncryptionAtRest`](crate::model::EncryptionAtRest).
    pub fn builder() -> crate::model::encryption_at_rest::Builder {
        crate::model::encryption_at_rest::Builder::default()
    }
}

/// When writing a match expression against `CatalogEncryptionMode`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let catalogencryptionmode = unimplemented!();
/// match catalogencryptionmode {
///     CatalogEncryptionMode::Disabled => { /* ... */ },
///     CatalogEncryptionMode::Ssekms => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `catalogencryptionmode` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `CatalogEncryptionMode::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `CatalogEncryptionMode::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `CatalogEncryptionMode::NewFeature` is defined.
/// Specifically, when `catalogencryptionmode` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `CatalogEncryptionMode::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum CatalogEncryptionMode {
    #[allow(missing_docs)] // documentation missing in model
    Disabled,
    #[allow(missing_docs)] // documentation missing in model
    Ssekms,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for CatalogEncryptionMode {
    fn from(s: &str) -> Self {
        match s {
            "DISABLED" => CatalogEncryptionMode::Disabled,
            "SSE-KMS" => CatalogEncryptionMode::Ssekms,
            other => {
                CatalogEncryptionMode::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for CatalogEncryptionMode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(CatalogEncryptionMode::from(s))
    }
}
impl CatalogEncryptionMode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            CatalogEncryptionMode::Disabled => "DISABLED",
            CatalogEncryptionMode::Ssekms => "SSE-KMS",
            CatalogEncryptionMode::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["DISABLED", "SSE-KMS"]
    }
}
impl AsRef<str> for CatalogEncryptionMode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The statement or request for a particular action to occur in a session.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Statement {
    /// <p>The ID of the statement.</p>
    #[doc(hidden)]
    pub id: i32,
    /// <p>The execution code of the statement.</p>
    #[doc(hidden)]
    pub code: std::option::Option<std::string::String>,
    /// <p>The state while request is actioned.</p>
    #[doc(hidden)]
    pub state: std::option::Option<crate::model::StatementState>,
    /// <p>The output in JSON.</p>
    #[doc(hidden)]
    pub output: std::option::Option<crate::model::StatementOutput>,
    /// <p>The code execution progress.</p>
    #[doc(hidden)]
    pub progress: f64,
    /// <p>The unix time and date that the job definition was started.</p>
    #[doc(hidden)]
    pub started_on: i64,
    /// <p>The unix time and date that the job definition was completed.</p>
    #[doc(hidden)]
    pub completed_on: i64,
}
impl Statement {
    /// <p>The ID of the statement.</p>
    pub fn id(&self) -> i32 {
        self.id
    }
    /// <p>The execution code of the statement.</p>
    pub fn code(&self) -> std::option::Option<&str> {
        self.code.as_deref()
    }
    /// <p>The state while request is actioned.</p>
    pub fn state(&self) -> std::option::Option<&crate::model::StatementState> {
        self.state.as_ref()
    }
    /// <p>The output in JSON.</p>
    pub fn output(&self) -> std::option::Option<&crate::model::StatementOutput> {
        self.output.as_ref()
    }
    /// <p>The code execution progress.</p>
    pub fn progress(&self) -> f64 {
        self.progress
    }
    /// <p>The unix time and date that the job definition was started.</p>
    pub fn started_on(&self) -> i64 {
        self.started_on
    }
    /// <p>The unix time and date that the job definition was completed.</p>
    pub fn completed_on(&self) -> i64 {
        self.completed_on
    }
}
/// See [`Statement`](crate::model::Statement).
pub mod statement {

    /// A builder for [`Statement`](crate::model::Statement).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<i32>,
        pub(crate) code: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<crate::model::StatementState>,
        pub(crate) output: std::option::Option<crate::model::StatementOutput>,
        pub(crate) progress: std::option::Option<f64>,
        pub(crate) started_on: std::option::Option<i64>,
        pub(crate) completed_on: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>The ID of the statement.</p>
        pub fn id(mut self, input: i32) -> Self {
            self.id = Some(input);
            self
        }
        /// <p>The ID of the statement.</p>
        pub fn set_id(mut self, input: std::option::Option<i32>) -> Self {
            self.id = input;
            self
        }
        /// <p>The execution code of the statement.</p>
        pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
            self.code = Some(input.into());
            self
        }
        /// <p>The execution code of the statement.</p>
        pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.code = input;
            self
        }
        /// <p>The state while request is actioned.</p>
        pub fn state(mut self, input: crate::model::StatementState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The state while request is actioned.</p>
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::StatementState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// <p>The output in JSON.</p>
        pub fn output(mut self, input: crate::model::StatementOutput) -> Self {
            self.output = Some(input);
            self
        }
        /// <p>The output in JSON.</p>
        pub fn set_output(
            mut self,
            input: std::option::Option<crate::model::StatementOutput>,
        ) -> Self {
            self.output = input;
            self
        }
        /// <p>The code execution progress.</p>
        pub fn progress(mut self, input: f64) -> Self {
            self.progress = Some(input);
            self
        }
        /// <p>The code execution progress.</p>
        pub fn set_progress(mut self, input: std::option::Option<f64>) -> Self {
            self.progress = input;
            self
        }
        /// <p>The unix time and date that the job definition was started.</p>
        pub fn started_on(mut self, input: i64) -> Self {
            self.started_on = Some(input);
            self
        }
        /// <p>The unix time and date that the job definition was started.</p>
        pub fn set_started_on(mut self, input: std::option::Option<i64>) -> Self {
            self.started_on = input;
            self
        }
        /// <p>The unix time and date that the job definition was completed.</p>
        pub fn completed_on(mut self, input: i64) -> Self {
            self.completed_on = Some(input);
            self
        }
        /// <p>The unix time and date that the job definition was completed.</p>
        pub fn set_completed_on(mut self, input: std::option::Option<i64>) -> Self {
            self.completed_on = input;
            self
        }
        /// Consumes the builder and constructs a [`Statement`](crate::model::Statement).
        pub fn build(self) -> crate::model::Statement {
            crate::model::Statement {
                id: self.id.unwrap_or_default(),
                code: self.code,
                state: self.state,
                output: self.output,
                progress: self.progress.unwrap_or_default(),
                started_on: self.started_on.unwrap_or_default(),
                completed_on: self.completed_on.unwrap_or_default(),
            }
        }
    }
}
impl Statement {
    /// Creates a new builder-style object to manufacture [`Statement`](crate::model::Statement).
    pub fn builder() -> crate::model::statement::Builder {
        crate::model::statement::Builder::default()
    }
}

/// <p>The code execution output in JSON format.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct StatementOutput {
    /// <p>The code execution output.</p>
    #[doc(hidden)]
    pub data: std::option::Option<crate::model::StatementOutputData>,
    /// <p>The execution count of the output.</p>
    #[doc(hidden)]
    pub execution_count: i32,
    /// <p>The status of the code execution output.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::StatementState>,
    /// <p>The name of the error in the output.</p>
    #[doc(hidden)]
    pub error_name: std::option::Option<std::string::String>,
    /// <p>The error value of the output.</p>
    #[doc(hidden)]
    pub error_value: std::option::Option<std::string::String>,
    /// <p>The traceback of the output.</p>
    #[doc(hidden)]
    pub traceback: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl StatementOutput {
    /// <p>The code execution output.</p>
    pub fn data(&self) -> std::option::Option<&crate::model::StatementOutputData> {
        self.data.as_ref()
    }
    /// <p>The execution count of the output.</p>
    pub fn execution_count(&self) -> i32 {
        self.execution_count
    }
    /// <p>The status of the code execution output.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::StatementState> {
        self.status.as_ref()
    }
    /// <p>The name of the error in the output.</p>
    pub fn error_name(&self) -> std::option::Option<&str> {
        self.error_name.as_deref()
    }
    /// <p>The error value of the output.</p>
    pub fn error_value(&self) -> std::option::Option<&str> {
        self.error_value.as_deref()
    }
    /// <p>The traceback of the output.</p>
    pub fn traceback(&self) -> std::option::Option<&[std::string::String]> {
        self.traceback.as_deref()
    }
}
/// See [`StatementOutput`](crate::model::StatementOutput).
pub mod statement_output {

    /// A builder for [`StatementOutput`](crate::model::StatementOutput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) data: std::option::Option<crate::model::StatementOutputData>,
        pub(crate) execution_count: std::option::Option<i32>,
        pub(crate) status: std::option::Option<crate::model::StatementState>,
        pub(crate) error_name: std::option::Option<std::string::String>,
        pub(crate) error_value: std::option::Option<std::string::String>,
        pub(crate) traceback: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The code execution output.</p>
        pub fn data(mut self, input: crate::model::StatementOutputData) -> Self {
            self.data = Some(input);
            self
        }
        /// <p>The code execution output.</p>
        pub fn set_data(
            mut self,
            input: std::option::Option<crate::model::StatementOutputData>,
        ) -> Self {
            self.data = input;
            self
        }
        /// <p>The execution count of the output.</p>
        pub fn execution_count(mut self, input: i32) -> Self {
            self.execution_count = Some(input);
            self
        }
        /// <p>The execution count of the output.</p>
        pub fn set_execution_count(mut self, input: std::option::Option<i32>) -> Self {
            self.execution_count = input;
            self
        }
        /// <p>The status of the code execution output.</p>
        pub fn status(mut self, input: crate::model::StatementState) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the code execution output.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::StatementState>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>The name of the error in the output.</p>
        pub fn error_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_name = Some(input.into());
            self
        }
        /// <p>The name of the error in the output.</p>
        pub fn set_error_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.error_name = input;
            self
        }
        /// <p>The error value of the output.</p>
        pub fn error_value(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_value = Some(input.into());
            self
        }
        /// <p>The error value of the output.</p>
        pub fn set_error_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.error_value = input;
            self
        }
        /// Appends an item to `traceback`.
        ///
        /// To override the contents of this collection use [`set_traceback`](Self::set_traceback).
        ///
        /// <p>The traceback of the output.</p>
        pub fn traceback(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.traceback.unwrap_or_default();
            v.push(input.into());
            self.traceback = Some(v);
            self
        }
        /// <p>The traceback of the output.</p>
        pub fn set_traceback(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.traceback = input;
            self
        }
        /// Consumes the builder and constructs a [`StatementOutput`](crate::model::StatementOutput).
        pub fn build(self) -> crate::model::StatementOutput {
            crate::model::StatementOutput {
                data: self.data,
                execution_count: self.execution_count.unwrap_or_default(),
                status: self.status,
                error_name: self.error_name,
                error_value: self.error_value,
                traceback: self.traceback,
            }
        }
    }
}
impl StatementOutput {
    /// Creates a new builder-style object to manufacture [`StatementOutput`](crate::model::StatementOutput).
    pub fn builder() -> crate::model::statement_output::Builder {
        crate::model::statement_output::Builder::default()
    }
}

/// When writing a match expression against `StatementState`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let statementstate = unimplemented!();
/// match statementstate {
///     StatementState::Available => { /* ... */ },
///     StatementState::Cancelled => { /* ... */ },
///     StatementState::Cancelling => { /* ... */ },
///     StatementState::Error => { /* ... */ },
///     StatementState::Running => { /* ... */ },
///     StatementState::Waiting => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `statementstate` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `StatementState::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `StatementState::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `StatementState::NewFeature` is defined.
/// Specifically, when `statementstate` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `StatementState::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum StatementState {
    #[allow(missing_docs)] // documentation missing in model
    Available,
    #[allow(missing_docs)] // documentation missing in model
    Cancelled,
    #[allow(missing_docs)] // documentation missing in model
    Cancelling,
    #[allow(missing_docs)] // documentation missing in model
    Error,
    #[allow(missing_docs)] // documentation missing in model
    Running,
    #[allow(missing_docs)] // documentation missing in model
    Waiting,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for StatementState {
    fn from(s: &str) -> Self {
        match s {
            "AVAILABLE" => StatementState::Available,
            "CANCELLED" => StatementState::Cancelled,
            "CANCELLING" => StatementState::Cancelling,
            "ERROR" => StatementState::Error,
            "RUNNING" => StatementState::Running,
            "WAITING" => StatementState::Waiting,
            other => StatementState::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for StatementState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(StatementState::from(s))
    }
}
impl StatementState {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            StatementState::Available => "AVAILABLE",
            StatementState::Cancelled => "CANCELLED",
            StatementState::Cancelling => "CANCELLING",
            StatementState::Error => "ERROR",
            StatementState::Running => "RUNNING",
            StatementState::Waiting => "WAITING",
            StatementState::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "AVAILABLE",
            "CANCELLED",
            "CANCELLING",
            "ERROR",
            "RUNNING",
            "WAITING",
        ]
    }
}
impl AsRef<str> for StatementState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The code execution output in JSON format.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct StatementOutputData {
    /// <p>The code execution output in text format.</p>
    #[doc(hidden)]
    pub text_plain: std::option::Option<std::string::String>,
}
impl StatementOutputData {
    /// <p>The code execution output in text format.</p>
    pub fn text_plain(&self) -> std::option::Option<&str> {
        self.text_plain.as_deref()
    }
}
/// See [`StatementOutputData`](crate::model::StatementOutputData).
pub mod statement_output_data {

    /// A builder for [`StatementOutputData`](crate::model::StatementOutputData).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) text_plain: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The code execution output in text format.</p>
        pub fn text_plain(mut self, input: impl Into<std::string::String>) -> Self {
            self.text_plain = Some(input.into());
            self
        }
        /// <p>The code execution output in text format.</p>
        pub fn set_text_plain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.text_plain = input;
            self
        }
        /// Consumes the builder and constructs a [`StatementOutputData`](crate::model::StatementOutputData).
        pub fn build(self) -> crate::model::StatementOutputData {
            crate::model::StatementOutputData {
                text_plain: self.text_plain,
            }
        }
    }
}
impl StatementOutputData {
    /// Creates a new builder-style object to manufacture [`StatementOutputData`](crate::model::StatementOutputData).
    pub fn builder() -> crate::model::statement_output_data::Builder {
        crate::model::statement_output_data::Builder::default()
    }
}

/// <p>The period in which a remote Spark runtime environment is running.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Session {
    /// <p>The ID of the session.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The time and date when the session was created.</p>
    #[doc(hidden)]
    pub created_on: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The session status. </p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::SessionStatus>,
    /// <p>The error message displayed during the session.</p>
    #[doc(hidden)]
    pub error_message: std::option::Option<std::string::String>,
    /// <p>The description of the session.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The name or Amazon Resource Name (ARN) of the IAM role associated with the Session.</p>
    #[doc(hidden)]
    pub role: std::option::Option<std::string::String>,
    /// <p>The command object.See SessionCommand.</p>
    #[doc(hidden)]
    pub command: std::option::Option<crate::model::SessionCommand>,
    /// <p>A map array of key-value pairs. Max is 75 pairs. </p>
    #[doc(hidden)]
    pub default_arguments:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The number of connections used for the session.</p>
    #[doc(hidden)]
    pub connections: std::option::Option<crate::model::ConnectionsList>,
    /// <p>The code execution progress of the session.</p>
    #[doc(hidden)]
    pub progress: f64,
    /// <p>The number of Glue data processing units (DPUs) that can be allocated when the job runs. A DPU is a relative measure of processing power that consists of 4 vCPUs of compute capacity and 16 GB memory. </p>
    #[doc(hidden)]
    pub max_capacity: std::option::Option<f64>,
    /// <p>The name of the SecurityConfiguration structure to be used with the session.</p>
    #[doc(hidden)]
    pub security_configuration: std::option::Option<std::string::String>,
    /// <p>The Glue version determines the versions of Apache Spark and Python that Glue supports. The GlueVersion must be greater than 2.0.</p>
    #[doc(hidden)]
    pub glue_version: std::option::Option<std::string::String>,
}
impl Session {
    /// <p>The ID of the session.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The time and date when the session was created.</p>
    pub fn created_on(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_on.as_ref()
    }
    /// <p>The session status. </p>
    pub fn status(&self) -> std::option::Option<&crate::model::SessionStatus> {
        self.status.as_ref()
    }
    /// <p>The error message displayed during the session.</p>
    pub fn error_message(&self) -> std::option::Option<&str> {
        self.error_message.as_deref()
    }
    /// <p>The description of the session.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The name or Amazon Resource Name (ARN) of the IAM role associated with the Session.</p>
    pub fn role(&self) -> std::option::Option<&str> {
        self.role.as_deref()
    }
    /// <p>The command object.See SessionCommand.</p>
    pub fn command(&self) -> std::option::Option<&crate::model::SessionCommand> {
        self.command.as_ref()
    }
    /// <p>A map array of key-value pairs. Max is 75 pairs. </p>
    pub fn default_arguments(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.default_arguments.as_ref()
    }
    /// <p>The number of connections used for the session.</p>
    pub fn connections(&self) -> std::option::Option<&crate::model::ConnectionsList> {
        self.connections.as_ref()
    }
    /// <p>The code execution progress of the session.</p>
    pub fn progress(&self) -> f64 {
        self.progress
    }
    /// <p>The number of Glue data processing units (DPUs) that can be allocated when the job runs. A DPU is a relative measure of processing power that consists of 4 vCPUs of compute capacity and 16 GB memory. </p>
    pub fn max_capacity(&self) -> std::option::Option<f64> {
        self.max_capacity
    }
    /// <p>The name of the SecurityConfiguration structure to be used with the session.</p>
    pub fn security_configuration(&self) -> std::option::Option<&str> {
        self.security_configuration.as_deref()
    }
    /// <p>The Glue version determines the versions of Apache Spark and Python that Glue supports. The GlueVersion must be greater than 2.0.</p>
    pub fn glue_version(&self) -> std::option::Option<&str> {
        self.glue_version.as_deref()
    }
}
/// See [`Session`](crate::model::Session).
pub mod session {

    /// A builder for [`Session`](crate::model::Session).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) created_on: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) status: std::option::Option<crate::model::SessionStatus>,
        pub(crate) error_message: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) role: std::option::Option<std::string::String>,
        pub(crate) command: std::option::Option<crate::model::SessionCommand>,
        pub(crate) default_arguments: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) connections: std::option::Option<crate::model::ConnectionsList>,
        pub(crate) progress: std::option::Option<f64>,
        pub(crate) max_capacity: std::option::Option<f64>,
        pub(crate) security_configuration: std::option::Option<std::string::String>,
        pub(crate) glue_version: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the session.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The ID of the session.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The time and date when the session was created.</p>
        pub fn created_on(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_on = Some(input);
            self
        }
        /// <p>The time and date when the session was created.</p>
        pub fn set_created_on(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_on = input;
            self
        }
        /// <p>The session status. </p>
        pub fn status(mut self, input: crate::model::SessionStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The session status. </p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::SessionStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>The error message displayed during the session.</p>
        pub fn error_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_message = Some(input.into());
            self
        }
        /// <p>The error message displayed during the session.</p>
        pub fn set_error_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.error_message = input;
            self
        }
        /// <p>The description of the session.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the session.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The name or Amazon Resource Name (ARN) of the IAM role associated with the Session.</p>
        pub fn role(mut self, input: impl Into<std::string::String>) -> Self {
            self.role = Some(input.into());
            self
        }
        /// <p>The name or Amazon Resource Name (ARN) of the IAM role associated with the Session.</p>
        pub fn set_role(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.role = input;
            self
        }
        /// <p>The command object.See SessionCommand.</p>
        pub fn command(mut self, input: crate::model::SessionCommand) -> Self {
            self.command = Some(input);
            self
        }
        /// <p>The command object.See SessionCommand.</p>
        pub fn set_command(
            mut self,
            input: std::option::Option<crate::model::SessionCommand>,
        ) -> Self {
            self.command = input;
            self
        }
        /// Adds a key-value pair to `default_arguments`.
        ///
        /// To override the contents of this collection use [`set_default_arguments`](Self::set_default_arguments).
        ///
        /// <p>A map array of key-value pairs. Max is 75 pairs. </p>
        pub fn default_arguments(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.default_arguments.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.default_arguments = Some(hash_map);
            self
        }
        /// <p>A map array of key-value pairs. Max is 75 pairs. </p>
        pub fn set_default_arguments(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.default_arguments = input;
            self
        }
        /// <p>The number of connections used for the session.</p>
        pub fn connections(mut self, input: crate::model::ConnectionsList) -> Self {
            self.connections = Some(input);
            self
        }
        /// <p>The number of connections used for the session.</p>
        pub fn set_connections(
            mut self,
            input: std::option::Option<crate::model::ConnectionsList>,
        ) -> Self {
            self.connections = input;
            self
        }
        /// <p>The code execution progress of the session.</p>
        pub fn progress(mut self, input: f64) -> Self {
            self.progress = Some(input);
            self
        }
        /// <p>The code execution progress of the session.</p>
        pub fn set_progress(mut self, input: std::option::Option<f64>) -> Self {
            self.progress = input;
            self
        }
        /// <p>The number of Glue data processing units (DPUs) that can be allocated when the job runs. A DPU is a relative measure of processing power that consists of 4 vCPUs of compute capacity and 16 GB memory. </p>
        pub fn max_capacity(mut self, input: f64) -> Self {
            self.max_capacity = Some(input);
            self
        }
        /// <p>The number of Glue data processing units (DPUs) that can be allocated when the job runs. A DPU is a relative measure of processing power that consists of 4 vCPUs of compute capacity and 16 GB memory. </p>
        pub fn set_max_capacity(mut self, input: std::option::Option<f64>) -> Self {
            self.max_capacity = input;
            self
        }
        /// <p>The name of the SecurityConfiguration structure to be used with the session.</p>
        pub fn security_configuration(mut self, input: impl Into<std::string::String>) -> Self {
            self.security_configuration = Some(input.into());
            self
        }
        /// <p>The name of the SecurityConfiguration structure to be used with the session.</p>
        pub fn set_security_configuration(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.security_configuration = input;
            self
        }
        /// <p>The Glue version determines the versions of Apache Spark and Python that Glue supports. The GlueVersion must be greater than 2.0.</p>
        pub fn glue_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.glue_version = Some(input.into());
            self
        }
        /// <p>The Glue version determines the versions of Apache Spark and Python that Glue supports. The GlueVersion must be greater than 2.0.</p>
        pub fn set_glue_version(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.glue_version = input;
            self
        }
        /// Consumes the builder and constructs a [`Session`](crate::model::Session).
        pub fn build(self) -> crate::model::Session {
            crate::model::Session {
                id: self.id,
                created_on: self.created_on,
                status: self.status,
                error_message: self.error_message,
                description: self.description,
                role: self.role,
                command: self.command,
                default_arguments: self.default_arguments,
                connections: self.connections,
                progress: self.progress.unwrap_or_default(),
                max_capacity: self.max_capacity,
                security_configuration: self.security_configuration,
                glue_version: self.glue_version,
            }
        }
    }
}
impl Session {
    /// Creates a new builder-style object to manufacture [`Session`](crate::model::Session).
    pub fn builder() -> crate::model::session::Builder {
        crate::model::session::Builder::default()
    }
}

/// <p>The <code>SessionCommand</code> that runs the job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SessionCommand {
    /// <p>Specifies the name of the SessionCommand. Can be 'glueetl' or 'gluestreaming'.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>Specifies the Python version. The Python version indicates the version supported for jobs of type Spark.</p>
    #[doc(hidden)]
    pub python_version: std::option::Option<std::string::String>,
}
impl SessionCommand {
    /// <p>Specifies the name of the SessionCommand. Can be 'glueetl' or 'gluestreaming'.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>Specifies the Python version. The Python version indicates the version supported for jobs of type Spark.</p>
    pub fn python_version(&self) -> std::option::Option<&str> {
        self.python_version.as_deref()
    }
}
/// See [`SessionCommand`](crate::model::SessionCommand).
pub mod session_command {

    /// A builder for [`SessionCommand`](crate::model::SessionCommand).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) python_version: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Specifies the name of the SessionCommand. Can be 'glueetl' or 'gluestreaming'.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>Specifies the name of the SessionCommand. Can be 'glueetl' or 'gluestreaming'.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>Specifies the Python version. The Python version indicates the version supported for jobs of type Spark.</p>
        pub fn python_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.python_version = Some(input.into());
            self
        }
        /// <p>Specifies the Python version. The Python version indicates the version supported for jobs of type Spark.</p>
        pub fn set_python_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.python_version = input;
            self
        }
        /// Consumes the builder and constructs a [`SessionCommand`](crate::model::SessionCommand).
        pub fn build(self) -> crate::model::SessionCommand {
            crate::model::SessionCommand {
                name: self.name,
                python_version: self.python_version,
            }
        }
    }
}
impl SessionCommand {
    /// Creates a new builder-style object to manufacture [`SessionCommand`](crate::model::SessionCommand).
    pub fn builder() -> crate::model::session_command::Builder {
        crate::model::session_command::Builder::default()
    }
}

/// When writing a match expression against `SessionStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let sessionstatus = unimplemented!();
/// match sessionstatus {
///     SessionStatus::Failed => { /* ... */ },
///     SessionStatus::Provisioning => { /* ... */ },
///     SessionStatus::Ready => { /* ... */ },
///     SessionStatus::Stopped => { /* ... */ },
///     SessionStatus::Stopping => { /* ... */ },
///     SessionStatus::Timeout => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `sessionstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `SessionStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `SessionStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `SessionStatus::NewFeature` is defined.
/// Specifically, when `sessionstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `SessionStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SessionStatus {
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    Provisioning,
    #[allow(missing_docs)] // documentation missing in model
    Ready,
    #[allow(missing_docs)] // documentation missing in model
    Stopped,
    #[allow(missing_docs)] // documentation missing in model
    Stopping,
    #[allow(missing_docs)] // documentation missing in model
    Timeout,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for SessionStatus {
    fn from(s: &str) -> Self {
        match s {
            "FAILED" => SessionStatus::Failed,
            "PROVISIONING" => SessionStatus::Provisioning,
            "READY" => SessionStatus::Ready,
            "STOPPED" => SessionStatus::Stopped,
            "STOPPING" => SessionStatus::Stopping,
            "TIMEOUT" => SessionStatus::Timeout,
            other => SessionStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for SessionStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SessionStatus::from(s))
    }
}
impl SessionStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            SessionStatus::Failed => "FAILED",
            SessionStatus::Provisioning => "PROVISIONING",
            SessionStatus::Ready => "READY",
            SessionStatus::Stopped => "STOPPED",
            SessionStatus::Stopping => "STOPPING",
            SessionStatus::Timeout => "TIMEOUT",
            SessionStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "FAILED",
            "PROVISIONING",
            "READY",
            "STOPPED",
            "STOPPING",
            "TIMEOUT",
        ]
    }
}
impl AsRef<str> for SessionStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>An object containing the details about a schema version.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SchemaVersionListItem {
    /// <p>The Amazon Resource Name (ARN) of the schema.</p>
    #[doc(hidden)]
    pub schema_arn: std::option::Option<std::string::String>,
    /// <p>The unique identifier of the schema version.</p>
    #[doc(hidden)]
    pub schema_version_id: std::option::Option<std::string::String>,
    /// <p>The version number of the schema.</p>
    #[doc(hidden)]
    pub version_number: i64,
    /// <p>The status of the schema version.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::SchemaVersionStatus>,
    /// <p>The date and time the schema version was created.</p>
    #[doc(hidden)]
    pub created_time: std::option::Option<std::string::String>,
}
impl SchemaVersionListItem {
    /// <p>The Amazon Resource Name (ARN) of the schema.</p>
    pub fn schema_arn(&self) -> std::option::Option<&str> {
        self.schema_arn.as_deref()
    }
    /// <p>The unique identifier of the schema version.</p>
    pub fn schema_version_id(&self) -> std::option::Option<&str> {
        self.schema_version_id.as_deref()
    }
    /// <p>The version number of the schema.</p>
    pub fn version_number(&self) -> i64 {
        self.version_number
    }
    /// <p>The status of the schema version.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::SchemaVersionStatus> {
        self.status.as_ref()
    }
    /// <p>The date and time the schema version was created.</p>
    pub fn created_time(&self) -> std::option::Option<&str> {
        self.created_time.as_deref()
    }
}
/// See [`SchemaVersionListItem`](crate::model::SchemaVersionListItem).
pub mod schema_version_list_item {

    /// A builder for [`SchemaVersionListItem`](crate::model::SchemaVersionListItem).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) schema_arn: std::option::Option<std::string::String>,
        pub(crate) schema_version_id: std::option::Option<std::string::String>,
        pub(crate) version_number: std::option::Option<i64>,
        pub(crate) status: std::option::Option<crate::model::SchemaVersionStatus>,
        pub(crate) created_time: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the schema.</p>
        pub fn schema_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.schema_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the schema.</p>
        pub fn set_schema_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.schema_arn = input;
            self
        }
        /// <p>The unique identifier of the schema version.</p>
        pub fn schema_version_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.schema_version_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of the schema version.</p>
        pub fn set_schema_version_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.schema_version_id = input;
            self
        }
        /// <p>The version number of the schema.</p>
        pub fn version_number(mut self, input: i64) -> Self {
            self.version_number = Some(input);
            self
        }
        /// <p>The version number of the schema.</p>
        pub fn set_version_number(mut self, input: std::option::Option<i64>) -> Self {
            self.version_number = input;
            self
        }
        /// <p>The status of the schema version.</p>
        pub fn status(mut self, input: crate::model::SchemaVersionStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the schema version.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::SchemaVersionStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>The date and time the schema version was created.</p>
        pub fn created_time(mut self, input: impl Into<std::string::String>) -> Self {
            self.created_time = Some(input.into());
            self
        }
        /// <p>The date and time the schema version was created.</p>
        pub fn set_created_time(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.created_time = input;
            self
        }
        /// Consumes the builder and constructs a [`SchemaVersionListItem`](crate::model::SchemaVersionListItem).
        pub fn build(self) -> crate::model::SchemaVersionListItem {
            crate::model::SchemaVersionListItem {
                schema_arn: self.schema_arn,
                schema_version_id: self.schema_version_id,
                version_number: self.version_number.unwrap_or_default(),
                status: self.status,
                created_time: self.created_time,
            }
        }
    }
}
impl SchemaVersionListItem {
    /// Creates a new builder-style object to manufacture [`SchemaVersionListItem`](crate::model::SchemaVersionListItem).
    pub fn builder() -> crate::model::schema_version_list_item::Builder {
        crate::model::schema_version_list_item::Builder::default()
    }
}

/// <p>An object that contains minimal details for a schema.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SchemaListItem {
    /// <p>the name of the registry where the schema resides.</p>
    #[doc(hidden)]
    pub registry_name: std::option::Option<std::string::String>,
    /// <p>The name of the schema.</p>
    #[doc(hidden)]
    pub schema_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) for the schema.</p>
    #[doc(hidden)]
    pub schema_arn: std::option::Option<std::string::String>,
    /// <p>A description for the schema.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The status of the schema.</p>
    #[doc(hidden)]
    pub schema_status: std::option::Option<crate::model::SchemaStatus>,
    /// <p>The date and time that a schema was created.</p>
    #[doc(hidden)]
    pub created_time: std::option::Option<std::string::String>,
    /// <p>The date and time that a schema was updated.</p>
    #[doc(hidden)]
    pub updated_time: std::option::Option<std::string::String>,
}
impl SchemaListItem {
    /// <p>the name of the registry where the schema resides.</p>
    pub fn registry_name(&self) -> std::option::Option<&str> {
        self.registry_name.as_deref()
    }
    /// <p>The name of the schema.</p>
    pub fn schema_name(&self) -> std::option::Option<&str> {
        self.schema_name.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) for the schema.</p>
    pub fn schema_arn(&self) -> std::option::Option<&str> {
        self.schema_arn.as_deref()
    }
    /// <p>A description for the schema.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The status of the schema.</p>
    pub fn schema_status(&self) -> std::option::Option<&crate::model::SchemaStatus> {
        self.schema_status.as_ref()
    }
    /// <p>The date and time that a schema was created.</p>
    pub fn created_time(&self) -> std::option::Option<&str> {
        self.created_time.as_deref()
    }
    /// <p>The date and time that a schema was updated.</p>
    pub fn updated_time(&self) -> std::option::Option<&str> {
        self.updated_time.as_deref()
    }
}
/// See [`SchemaListItem`](crate::model::SchemaListItem).
pub mod schema_list_item {

    /// A builder for [`SchemaListItem`](crate::model::SchemaListItem).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) registry_name: std::option::Option<std::string::String>,
        pub(crate) schema_name: std::option::Option<std::string::String>,
        pub(crate) schema_arn: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) schema_status: std::option::Option<crate::model::SchemaStatus>,
        pub(crate) created_time: std::option::Option<std::string::String>,
        pub(crate) updated_time: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>the name of the registry where the schema resides.</p>
        pub fn registry_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.registry_name = Some(input.into());
            self
        }
        /// <p>the name of the registry where the schema resides.</p>
        pub fn set_registry_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.registry_name = input;
            self
        }
        /// <p>The name of the schema.</p>
        pub fn schema_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.schema_name = Some(input.into());
            self
        }
        /// <p>The name of the schema.</p>
        pub fn set_schema_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.schema_name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) for the schema.</p>
        pub fn schema_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.schema_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) for the schema.</p>
        pub fn set_schema_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.schema_arn = input;
            self
        }
        /// <p>A description for the schema.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A description for the schema.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The status of the schema.</p>
        pub fn schema_status(mut self, input: crate::model::SchemaStatus) -> Self {
            self.schema_status = Some(input);
            self
        }
        /// <p>The status of the schema.</p>
        pub fn set_schema_status(
            mut self,
            input: std::option::Option<crate::model::SchemaStatus>,
        ) -> Self {
            self.schema_status = input;
            self
        }
        /// <p>The date and time that a schema was created.</p>
        pub fn created_time(mut self, input: impl Into<std::string::String>) -> Self {
            self.created_time = Some(input.into());
            self
        }
        /// <p>The date and time that a schema was created.</p>
        pub fn set_created_time(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.created_time = input;
            self
        }
        /// <p>The date and time that a schema was updated.</p>
        pub fn updated_time(mut self, input: impl Into<std::string::String>) -> Self {
            self.updated_time = Some(input.into());
            self
        }
        /// <p>The date and time that a schema was updated.</p>
        pub fn set_updated_time(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.updated_time = input;
            self
        }
        /// Consumes the builder and constructs a [`SchemaListItem`](crate::model::SchemaListItem).
        pub fn build(self) -> crate::model::SchemaListItem {
            crate::model::SchemaListItem {
                registry_name: self.registry_name,
                schema_name: self.schema_name,
                schema_arn: self.schema_arn,
                description: self.description,
                schema_status: self.schema_status,
                created_time: self.created_time,
                updated_time: self.updated_time,
            }
        }
    }
}
impl SchemaListItem {
    /// Creates a new builder-style object to manufacture [`SchemaListItem`](crate::model::SchemaListItem).
    pub fn builder() -> crate::model::schema_list_item::Builder {
        crate::model::schema_list_item::Builder::default()
    }
}

/// When writing a match expression against `SchemaStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let schemastatus = unimplemented!();
/// match schemastatus {
///     SchemaStatus::Available => { /* ... */ },
///     SchemaStatus::Deleting => { /* ... */ },
///     SchemaStatus::Pending => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `schemastatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `SchemaStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `SchemaStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `SchemaStatus::NewFeature` is defined.
/// Specifically, when `schemastatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `SchemaStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SchemaStatus {
    #[allow(missing_docs)] // documentation missing in model
    Available,
    #[allow(missing_docs)] // documentation missing in model
    Deleting,
    #[allow(missing_docs)] // documentation missing in model
    Pending,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for SchemaStatus {
    fn from(s: &str) -> Self {
        match s {
            "AVAILABLE" => SchemaStatus::Available,
            "DELETING" => SchemaStatus::Deleting,
            "PENDING" => SchemaStatus::Pending,
            other => SchemaStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for SchemaStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SchemaStatus::from(s))
    }
}
impl SchemaStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            SchemaStatus::Available => "AVAILABLE",
            SchemaStatus::Deleting => "DELETING",
            SchemaStatus::Pending => "PENDING",
            SchemaStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["AVAILABLE", "DELETING", "PENDING"]
    }
}
impl AsRef<str> for SchemaStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A structure containing the details for a registry.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RegistryListItem {
    /// <p>The name of the registry.</p>
    #[doc(hidden)]
    pub registry_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the registry.</p>
    #[doc(hidden)]
    pub registry_arn: std::option::Option<std::string::String>,
    /// <p>A description of the registry.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The status of the registry.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::RegistryStatus>,
    /// <p>The data the registry was created.</p>
    #[doc(hidden)]
    pub created_time: std::option::Option<std::string::String>,
    /// <p>The date the registry was updated.</p>
    #[doc(hidden)]
    pub updated_time: std::option::Option<std::string::String>,
}
impl RegistryListItem {
    /// <p>The name of the registry.</p>
    pub fn registry_name(&self) -> std::option::Option<&str> {
        self.registry_name.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the registry.</p>
    pub fn registry_arn(&self) -> std::option::Option<&str> {
        self.registry_arn.as_deref()
    }
    /// <p>A description of the registry.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The status of the registry.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::RegistryStatus> {
        self.status.as_ref()
    }
    /// <p>The data the registry was created.</p>
    pub fn created_time(&self) -> std::option::Option<&str> {
        self.created_time.as_deref()
    }
    /// <p>The date the registry was updated.</p>
    pub fn updated_time(&self) -> std::option::Option<&str> {
        self.updated_time.as_deref()
    }
}
/// See [`RegistryListItem`](crate::model::RegistryListItem).
pub mod registry_list_item {

    /// A builder for [`RegistryListItem`](crate::model::RegistryListItem).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) registry_name: std::option::Option<std::string::String>,
        pub(crate) registry_arn: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::RegistryStatus>,
        pub(crate) created_time: std::option::Option<std::string::String>,
        pub(crate) updated_time: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the registry.</p>
        pub fn registry_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.registry_name = Some(input.into());
            self
        }
        /// <p>The name of the registry.</p>
        pub fn set_registry_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.registry_name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the registry.</p>
        pub fn registry_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.registry_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the registry.</p>
        pub fn set_registry_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.registry_arn = input;
            self
        }
        /// <p>A description of the registry.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A description of the registry.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The status of the registry.</p>
        pub fn status(mut self, input: crate::model::RegistryStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the registry.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::RegistryStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>The data the registry was created.</p>
        pub fn created_time(mut self, input: impl Into<std::string::String>) -> Self {
            self.created_time = Some(input.into());
            self
        }
        /// <p>The data the registry was created.</p>
        pub fn set_created_time(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.created_time = input;
            self
        }
        /// <p>The date the registry was updated.</p>
        pub fn updated_time(mut self, input: impl Into<std::string::String>) -> Self {
            self.updated_time = Some(input.into());
            self
        }
        /// <p>The date the registry was updated.</p>
        pub fn set_updated_time(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.updated_time = input;
            self
        }
        /// Consumes the builder and constructs a [`RegistryListItem`](crate::model::RegistryListItem).
        pub fn build(self) -> crate::model::RegistryListItem {
            crate::model::RegistryListItem {
                registry_name: self.registry_name,
                registry_arn: self.registry_arn,
                description: self.description,
                status: self.status,
                created_time: self.created_time,
                updated_time: self.updated_time,
            }
        }
    }
}
impl RegistryListItem {
    /// Creates a new builder-style object to manufacture [`RegistryListItem`](crate::model::RegistryListItem).
    pub fn builder() -> crate::model::registry_list_item::Builder {
        crate::model::registry_list_item::Builder::default()
    }
}

/// When writing a match expression against `RegistryStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let registrystatus = unimplemented!();
/// match registrystatus {
///     RegistryStatus::Available => { /* ... */ },
///     RegistryStatus::Deleting => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `registrystatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `RegistryStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `RegistryStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `RegistryStatus::NewFeature` is defined.
/// Specifically, when `registrystatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `RegistryStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum RegistryStatus {
    #[allow(missing_docs)] // documentation missing in model
    Available,
    #[allow(missing_docs)] // documentation missing in model
    Deleting,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for RegistryStatus {
    fn from(s: &str) -> Self {
        match s {
            "AVAILABLE" => RegistryStatus::Available,
            "DELETING" => RegistryStatus::Deleting,
            other => RegistryStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for RegistryStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(RegistryStatus::from(s))
    }
}
impl RegistryStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            RegistryStatus::Available => "AVAILABLE",
            RegistryStatus::Deleting => "DELETING",
            RegistryStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["AVAILABLE", "DELETING"]
    }
}
impl AsRef<str> for RegistryStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The sorting criteria that are associated with the machine learning transform.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TransformSortCriteria {
    /// <p>The column to be used in the sorting criteria that are associated with the machine learning transform.</p>
    #[doc(hidden)]
    pub column: std::option::Option<crate::model::TransformSortColumnType>,
    /// <p>The sort direction to be used in the sorting criteria that are associated with the machine learning transform.</p>
    #[doc(hidden)]
    pub sort_direction: std::option::Option<crate::model::SortDirectionType>,
}
impl TransformSortCriteria {
    /// <p>The column to be used in the sorting criteria that are associated with the machine learning transform.</p>
    pub fn column(&self) -> std::option::Option<&crate::model::TransformSortColumnType> {
        self.column.as_ref()
    }
    /// <p>The sort direction to be used in the sorting criteria that are associated with the machine learning transform.</p>
    pub fn sort_direction(&self) -> std::option::Option<&crate::model::SortDirectionType> {
        self.sort_direction.as_ref()
    }
}
/// See [`TransformSortCriteria`](crate::model::TransformSortCriteria).
pub mod transform_sort_criteria {

    /// A builder for [`TransformSortCriteria`](crate::model::TransformSortCriteria).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) column: std::option::Option<crate::model::TransformSortColumnType>,
        pub(crate) sort_direction: std::option::Option<crate::model::SortDirectionType>,
    }
    impl Builder {
        /// <p>The column to be used in the sorting criteria that are associated with the machine learning transform.</p>
        pub fn column(mut self, input: crate::model::TransformSortColumnType) -> Self {
            self.column = Some(input);
            self
        }
        /// <p>The column to be used in the sorting criteria that are associated with the machine learning transform.</p>
        pub fn set_column(
            mut self,
            input: std::option::Option<crate::model::TransformSortColumnType>,
        ) -> Self {
            self.column = input;
            self
        }
        /// <p>The sort direction to be used in the sorting criteria that are associated with the machine learning transform.</p>
        pub fn sort_direction(mut self, input: crate::model::SortDirectionType) -> Self {
            self.sort_direction = Some(input);
            self
        }
        /// <p>The sort direction to be used in the sorting criteria that are associated with the machine learning transform.</p>
        pub fn set_sort_direction(
            mut self,
            input: std::option::Option<crate::model::SortDirectionType>,
        ) -> Self {
            self.sort_direction = input;
            self
        }
        /// Consumes the builder and constructs a [`TransformSortCriteria`](crate::model::TransformSortCriteria).
        pub fn build(self) -> crate::model::TransformSortCriteria {
            crate::model::TransformSortCriteria {
                column: self.column,
                sort_direction: self.sort_direction,
            }
        }
    }
}
impl TransformSortCriteria {
    /// Creates a new builder-style object to manufacture [`TransformSortCriteria`](crate::model::TransformSortCriteria).
    pub fn builder() -> crate::model::transform_sort_criteria::Builder {
        crate::model::transform_sort_criteria::Builder::default()
    }
}

/// When writing a match expression against `SortDirectionType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let sortdirectiontype = unimplemented!();
/// match sortdirectiontype {
///     SortDirectionType::Ascending => { /* ... */ },
///     SortDirectionType::Descending => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `sortdirectiontype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `SortDirectionType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `SortDirectionType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `SortDirectionType::NewFeature` is defined.
/// Specifically, when `sortdirectiontype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `SortDirectionType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SortDirectionType {
    #[allow(missing_docs)] // documentation missing in model
    Ascending,
    #[allow(missing_docs)] // documentation missing in model
    Descending,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for SortDirectionType {
    fn from(s: &str) -> Self {
        match s {
            "ASCENDING" => SortDirectionType::Ascending,
            "DESCENDING" => SortDirectionType::Descending,
            other => {
                SortDirectionType::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for SortDirectionType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SortDirectionType::from(s))
    }
}
impl SortDirectionType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            SortDirectionType::Ascending => "ASCENDING",
            SortDirectionType::Descending => "DESCENDING",
            SortDirectionType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ASCENDING", "DESCENDING"]
    }
}
impl AsRef<str> for SortDirectionType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `TransformSortColumnType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let transformsortcolumntype = unimplemented!();
/// match transformsortcolumntype {
///     TransformSortColumnType::Created => { /* ... */ },
///     TransformSortColumnType::LastModified => { /* ... */ },
///     TransformSortColumnType::Name => { /* ... */ },
///     TransformSortColumnType::Status => { /* ... */ },
///     TransformSortColumnType::TransformType => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `transformsortcolumntype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `TransformSortColumnType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `TransformSortColumnType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `TransformSortColumnType::NewFeature` is defined.
/// Specifically, when `transformsortcolumntype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `TransformSortColumnType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TransformSortColumnType {
    #[allow(missing_docs)] // documentation missing in model
    Created,
    #[allow(missing_docs)] // documentation missing in model
    LastModified,
    #[allow(missing_docs)] // documentation missing in model
    Name,
    #[allow(missing_docs)] // documentation missing in model
    Status,
    #[allow(missing_docs)] // documentation missing in model
    TransformType,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for TransformSortColumnType {
    fn from(s: &str) -> Self {
        match s {
            "CREATED" => TransformSortColumnType::Created,
            "LAST_MODIFIED" => TransformSortColumnType::LastModified,
            "NAME" => TransformSortColumnType::Name,
            "STATUS" => TransformSortColumnType::Status,
            "TRANSFORM_TYPE" => TransformSortColumnType::TransformType,
            other => TransformSortColumnType::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for TransformSortColumnType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TransformSortColumnType::from(s))
    }
}
impl TransformSortColumnType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            TransformSortColumnType::Created => "CREATED",
            TransformSortColumnType::LastModified => "LAST_MODIFIED",
            TransformSortColumnType::Name => "NAME",
            TransformSortColumnType::Status => "STATUS",
            TransformSortColumnType::TransformType => "TRANSFORM_TYPE",
            TransformSortColumnType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "CREATED",
            "LAST_MODIFIED",
            "NAME",
            "STATUS",
            "TRANSFORM_TYPE",
        ]
    }
}
impl AsRef<str> for TransformSortColumnType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The criteria used to filter the machine learning transforms.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TransformFilterCriteria {
    /// <p>A unique transform name that is used to filter the machine learning transforms.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The type of machine learning transform that is used to filter the machine learning transforms.</p>
    #[doc(hidden)]
    pub transform_type: std::option::Option<crate::model::TransformType>,
    /// <p>Filters the list of machine learning transforms by the last known status of the transforms (to indicate whether a transform can be used or not). One of "NOT_READY", "READY", or "DELETING".</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::TransformStatusType>,
    /// <p>This value determines which version of Glue this machine learning transform is compatible with. Glue 1.0 is recommended for most customers. If the value is not set, the Glue compatibility defaults to Glue 0.9. For more information, see <a href="https://docs.aws.amazon.com/glue/latest/dg/release-notes.html#release-notes-versions">Glue Versions</a> in the developer guide.</p>
    #[doc(hidden)]
    pub glue_version: std::option::Option<std::string::String>,
    /// <p>The time and date before which the transforms were created.</p>
    #[doc(hidden)]
    pub created_before: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The time and date after which the transforms were created.</p>
    #[doc(hidden)]
    pub created_after: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Filter on transforms last modified before this date.</p>
    #[doc(hidden)]
    pub last_modified_before: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Filter on transforms last modified after this date.</p>
    #[doc(hidden)]
    pub last_modified_after: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Filters on datasets with a specific schema. The <code>Map
    /// <column, type></column,></code> object is an array of key-value pairs representing the schema this transform accepts, where <code>Column</code> is the name of a column, and <code>Type</code> is the type of the data such as an integer or string. Has an upper bound of 100 columns.</p>
    #[doc(hidden)]
    pub schema: std::option::Option<std::vec::Vec<crate::model::SchemaColumn>>,
}
impl TransformFilterCriteria {
    /// <p>A unique transform name that is used to filter the machine learning transforms.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The type of machine learning transform that is used to filter the machine learning transforms.</p>
    pub fn transform_type(&self) -> std::option::Option<&crate::model::TransformType> {
        self.transform_type.as_ref()
    }
    /// <p>Filters the list of machine learning transforms by the last known status of the transforms (to indicate whether a transform can be used or not). One of "NOT_READY", "READY", or "DELETING".</p>
    pub fn status(&self) -> std::option::Option<&crate::model::TransformStatusType> {
        self.status.as_ref()
    }
    /// <p>This value determines which version of Glue this machine learning transform is compatible with. Glue 1.0 is recommended for most customers. If the value is not set, the Glue compatibility defaults to Glue 0.9. For more information, see <a href="https://docs.aws.amazon.com/glue/latest/dg/release-notes.html#release-notes-versions">Glue Versions</a> in the developer guide.</p>
    pub fn glue_version(&self) -> std::option::Option<&str> {
        self.glue_version.as_deref()
    }
    /// <p>The time and date before which the transforms were created.</p>
    pub fn created_before(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_before.as_ref()
    }
    /// <p>The time and date after which the transforms were created.</p>
    pub fn created_after(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_after.as_ref()
    }
    /// <p>Filter on transforms last modified before this date.</p>
    pub fn last_modified_before(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_modified_before.as_ref()
    }
    /// <p>Filter on transforms last modified after this date.</p>
    pub fn last_modified_after(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_modified_after.as_ref()
    }
    /// <p>Filters on datasets with a specific schema. The <code>Map
    /// <column, type></column,></code> object is an array of key-value pairs representing the schema this transform accepts, where <code>Column</code> is the name of a column, and <code>Type</code> is the type of the data such as an integer or string. Has an upper bound of 100 columns.</p>
    pub fn schema(&self) -> std::option::Option<&[crate::model::SchemaColumn]> {
        self.schema.as_deref()
    }
}
/// See [`TransformFilterCriteria`](crate::model::TransformFilterCriteria).
pub mod transform_filter_criteria {

    /// A builder for [`TransformFilterCriteria`](crate::model::TransformFilterCriteria).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) transform_type: std::option::Option<crate::model::TransformType>,
        pub(crate) status: std::option::Option<crate::model::TransformStatusType>,
        pub(crate) glue_version: std::option::Option<std::string::String>,
        pub(crate) created_before: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) created_after: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_modified_before: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_modified_after: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) schema: std::option::Option<std::vec::Vec<crate::model::SchemaColumn>>,
    }
    impl Builder {
        /// <p>A unique transform name that is used to filter the machine learning transforms.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>A unique transform name that is used to filter the machine learning transforms.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The type of machine learning transform that is used to filter the machine learning transforms.</p>
        pub fn transform_type(mut self, input: crate::model::TransformType) -> Self {
            self.transform_type = Some(input);
            self
        }
        /// <p>The type of machine learning transform that is used to filter the machine learning transforms.</p>
        pub fn set_transform_type(
            mut self,
            input: std::option::Option<crate::model::TransformType>,
        ) -> Self {
            self.transform_type = input;
            self
        }
        /// <p>Filters the list of machine learning transforms by the last known status of the transforms (to indicate whether a transform can be used or not). One of "NOT_READY", "READY", or "DELETING".</p>
        pub fn status(mut self, input: crate::model::TransformStatusType) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>Filters the list of machine learning transforms by the last known status of the transforms (to indicate whether a transform can be used or not). One of "NOT_READY", "READY", or "DELETING".</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::TransformStatusType>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>This value determines which version of Glue this machine learning transform is compatible with. Glue 1.0 is recommended for most customers. If the value is not set, the Glue compatibility defaults to Glue 0.9. For more information, see <a href="https://docs.aws.amazon.com/glue/latest/dg/release-notes.html#release-notes-versions">Glue Versions</a> in the developer guide.</p>
        pub fn glue_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.glue_version = Some(input.into());
            self
        }
        /// <p>This value determines which version of Glue this machine learning transform is compatible with. Glue 1.0 is recommended for most customers. If the value is not set, the Glue compatibility defaults to Glue 0.9. For more information, see <a href="https://docs.aws.amazon.com/glue/latest/dg/release-notes.html#release-notes-versions">Glue Versions</a> in the developer guide.</p>
        pub fn set_glue_version(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.glue_version = input;
            self
        }
        /// <p>The time and date before which the transforms were created.</p>
        pub fn created_before(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_before = Some(input);
            self
        }
        /// <p>The time and date before which the transforms were created.</p>
        pub fn set_created_before(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_before = input;
            self
        }
        /// <p>The time and date after which the transforms were created.</p>
        pub fn created_after(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_after = Some(input);
            self
        }
        /// <p>The time and date after which the transforms were created.</p>
        pub fn set_created_after(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_after = input;
            self
        }
        /// <p>Filter on transforms last modified before this date.</p>
        pub fn last_modified_before(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_modified_before = Some(input);
            self
        }
        /// <p>Filter on transforms last modified before this date.</p>
        pub fn set_last_modified_before(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_modified_before = input;
            self
        }
        /// <p>Filter on transforms last modified after this date.</p>
        pub fn last_modified_after(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_modified_after = Some(input);
            self
        }
        /// <p>Filter on transforms last modified after this date.</p>
        pub fn set_last_modified_after(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_modified_after = input;
            self
        }
        /// Appends an item to `schema`.
        ///
        /// To override the contents of this collection use [`set_schema`](Self::set_schema).
        ///
        /// <p>Filters on datasets with a specific schema. The <code>Map
        /// <column, type></column,></code> object is an array of key-value pairs representing the schema this transform accepts, where <code>Column</code> is the name of a column, and <code>Type</code> is the type of the data such as an integer or string. Has an upper bound of 100 columns.</p>
        pub fn schema(mut self, input: crate::model::SchemaColumn) -> Self {
            let mut v = self.schema.unwrap_or_default();
            v.push(input);
            self.schema = Some(v);
            self
        }
        /// <p>Filters on datasets with a specific schema. The <code>Map
        /// <column, type></column,></code> object is an array of key-value pairs representing the schema this transform accepts, where <code>Column</code> is the name of a column, and <code>Type</code> is the type of the data such as an integer or string. Has an upper bound of 100 columns.</p>
        pub fn set_schema(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::SchemaColumn>>,
        ) -> Self {
            self.schema = input;
            self
        }
        /// Consumes the builder and constructs a [`TransformFilterCriteria`](crate::model::TransformFilterCriteria).
        pub fn build(self) -> crate::model::TransformFilterCriteria {
            crate::model::TransformFilterCriteria {
                name: self.name,
                transform_type: self.transform_type,
                status: self.status,
                glue_version: self.glue_version,
                created_before: self.created_before,
                created_after: self.created_after,
                last_modified_before: self.last_modified_before,
                last_modified_after: self.last_modified_after,
                schema: self.schema,
            }
        }
    }
}
impl TransformFilterCriteria {
    /// Creates a new builder-style object to manufacture [`TransformFilterCriteria`](crate::model::TransformFilterCriteria).
    pub fn builder() -> crate::model::transform_filter_criteria::Builder {
        crate::model::transform_filter_criteria::Builder::default()
    }
}

/// <p>A key-value pair representing a column and data type that this transform can run against. The <code>Schema</code> parameter of the <code>MLTransform</code> may contain up to 100 of these structures.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SchemaColumn {
    /// <p>The name of the column.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The type of data in the column.</p>
    #[doc(hidden)]
    pub data_type: std::option::Option<std::string::String>,
}
impl SchemaColumn {
    /// <p>The name of the column.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The type of data in the column.</p>
    pub fn data_type(&self) -> std::option::Option<&str> {
        self.data_type.as_deref()
    }
}
/// See [`SchemaColumn`](crate::model::SchemaColumn).
pub mod schema_column {

    /// A builder for [`SchemaColumn`](crate::model::SchemaColumn).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) data_type: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the column.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the column.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The type of data in the column.</p>
        pub fn data_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.data_type = Some(input.into());
            self
        }
        /// <p>The type of data in the column.</p>
        pub fn set_data_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.data_type = input;
            self
        }
        /// Consumes the builder and constructs a [`SchemaColumn`](crate::model::SchemaColumn).
        pub fn build(self) -> crate::model::SchemaColumn {
            crate::model::SchemaColumn {
                name: self.name,
                data_type: self.data_type,
            }
        }
    }
}
impl SchemaColumn {
    /// Creates a new builder-style object to manufacture [`SchemaColumn`](crate::model::SchemaColumn).
    pub fn builder() -> crate::model::schema_column::Builder {
        crate::model::schema_column::Builder::default()
    }
}

/// When writing a match expression against `TransformStatusType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let transformstatustype = unimplemented!();
/// match transformstatustype {
///     TransformStatusType::Deleting => { /* ... */ },
///     TransformStatusType::NotReady => { /* ... */ },
///     TransformStatusType::Ready => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `transformstatustype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `TransformStatusType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `TransformStatusType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `TransformStatusType::NewFeature` is defined.
/// Specifically, when `transformstatustype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `TransformStatusType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TransformStatusType {
    #[allow(missing_docs)] // documentation missing in model
    Deleting,
    #[allow(missing_docs)] // documentation missing in model
    NotReady,
    #[allow(missing_docs)] // documentation missing in model
    Ready,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for TransformStatusType {
    fn from(s: &str) -> Self {
        match s {
            "DELETING" => TransformStatusType::Deleting,
            "NOT_READY" => TransformStatusType::NotReady,
            "READY" => TransformStatusType::Ready,
            other => {
                TransformStatusType::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for TransformStatusType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TransformStatusType::from(s))
    }
}
impl TransformStatusType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            TransformStatusType::Deleting => "DELETING",
            TransformStatusType::NotReady => "NOT_READY",
            TransformStatusType::Ready => "READY",
            TransformStatusType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["DELETING", "NOT_READY", "READY"]
    }
}
impl AsRef<str> for TransformStatusType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes a data quality ruleset returned by <code>GetDataQualityRuleset</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DataQualityRulesetListDetails {
    /// <p>The name of the data quality ruleset.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>A description of the data quality ruleset.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The date and time the data quality ruleset was created.</p>
    #[doc(hidden)]
    pub created_on: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The date and time the data quality ruleset was last modified.</p>
    #[doc(hidden)]
    pub last_modified_on: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>An object representing an Glue table.</p>
    #[doc(hidden)]
    pub target_table: std::option::Option<crate::model::DataQualityTargetTable>,
    /// <p>When a ruleset was created from a recommendation run, this run ID is generated to link the two together.</p>
    #[doc(hidden)]
    pub recommendation_run_id: std::option::Option<std::string::String>,
    /// <p>The number of rules in the ruleset.</p>
    #[doc(hidden)]
    pub rule_count: std::option::Option<i32>,
}
impl DataQualityRulesetListDetails {
    /// <p>The name of the data quality ruleset.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>A description of the data quality ruleset.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The date and time the data quality ruleset was created.</p>
    pub fn created_on(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_on.as_ref()
    }
    /// <p>The date and time the data quality ruleset was last modified.</p>
    pub fn last_modified_on(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_modified_on.as_ref()
    }
    /// <p>An object representing an Glue table.</p>
    pub fn target_table(&self) -> std::option::Option<&crate::model::DataQualityTargetTable> {
        self.target_table.as_ref()
    }
    /// <p>When a ruleset was created from a recommendation run, this run ID is generated to link the two together.</p>
    pub fn recommendation_run_id(&self) -> std::option::Option<&str> {
        self.recommendation_run_id.as_deref()
    }
    /// <p>The number of rules in the ruleset.</p>
    pub fn rule_count(&self) -> std::option::Option<i32> {
        self.rule_count
    }
}
/// See [`DataQualityRulesetListDetails`](crate::model::DataQualityRulesetListDetails).
pub mod data_quality_ruleset_list_details {

    /// A builder for [`DataQualityRulesetListDetails`](crate::model::DataQualityRulesetListDetails).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) created_on: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_modified_on: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) target_table: std::option::Option<crate::model::DataQualityTargetTable>,
        pub(crate) recommendation_run_id: std::option::Option<std::string::String>,
        pub(crate) rule_count: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The name of the data quality ruleset.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the data quality ruleset.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>A description of the data quality ruleset.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A description of the data quality ruleset.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The date and time the data quality ruleset was created.</p>
        pub fn created_on(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_on = Some(input);
            self
        }
        /// <p>The date and time the data quality ruleset was created.</p>
        pub fn set_created_on(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_on = input;
            self
        }
        /// <p>The date and time the data quality ruleset was last modified.</p>
        pub fn last_modified_on(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_modified_on = Some(input);
            self
        }
        /// <p>The date and time the data quality ruleset was last modified.</p>
        pub fn set_last_modified_on(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_modified_on = input;
            self
        }
        /// <p>An object representing an Glue table.</p>
        pub fn target_table(mut self, input: crate::model::DataQualityTargetTable) -> Self {
            self.target_table = Some(input);
            self
        }
        /// <p>An object representing an Glue table.</p>
        pub fn set_target_table(
            mut self,
            input: std::option::Option<crate::model::DataQualityTargetTable>,
        ) -> Self {
            self.target_table = input;
            self
        }
        /// <p>When a ruleset was created from a recommendation run, this run ID is generated to link the two together.</p>
        pub fn recommendation_run_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.recommendation_run_id = Some(input.into());
            self
        }
        /// <p>When a ruleset was created from a recommendation run, this run ID is generated to link the two together.</p>
        pub fn set_recommendation_run_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.recommendation_run_id = input;
            self
        }
        /// <p>The number of rules in the ruleset.</p>
        pub fn rule_count(mut self, input: i32) -> Self {
            self.rule_count = Some(input);
            self
        }
        /// <p>The number of rules in the ruleset.</p>
        pub fn set_rule_count(mut self, input: std::option::Option<i32>) -> Self {
            self.rule_count = input;
            self
        }
        /// Consumes the builder and constructs a [`DataQualityRulesetListDetails`](crate::model::DataQualityRulesetListDetails).
        pub fn build(self) -> crate::model::DataQualityRulesetListDetails {
            crate::model::DataQualityRulesetListDetails {
                name: self.name,
                description: self.description,
                created_on: self.created_on,
                last_modified_on: self.last_modified_on,
                target_table: self.target_table,
                recommendation_run_id: self.recommendation_run_id,
                rule_count: self.rule_count,
            }
        }
    }
}
impl DataQualityRulesetListDetails {
    /// Creates a new builder-style object to manufacture [`DataQualityRulesetListDetails`](crate::model::DataQualityRulesetListDetails).
    pub fn builder() -> crate::model::data_quality_ruleset_list_details::Builder {
        crate::model::data_quality_ruleset_list_details::Builder::default()
    }
}

/// <p>An object representing an Glue table.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DataQualityTargetTable {
    /// <p>The name of the Glue table.</p>
    #[doc(hidden)]
    pub table_name: std::option::Option<std::string::String>,
    /// <p>The name of the database where the Glue table exists.</p>
    #[doc(hidden)]
    pub database_name: std::option::Option<std::string::String>,
}
impl DataQualityTargetTable {
    /// <p>The name of the Glue table.</p>
    pub fn table_name(&self) -> std::option::Option<&str> {
        self.table_name.as_deref()
    }
    /// <p>The name of the database where the Glue table exists.</p>
    pub fn database_name(&self) -> std::option::Option<&str> {
        self.database_name.as_deref()
    }
}
/// See [`DataQualityTargetTable`](crate::model::DataQualityTargetTable).
pub mod data_quality_target_table {

    /// A builder for [`DataQualityTargetTable`](crate::model::DataQualityTargetTable).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) table_name: std::option::Option<std::string::String>,
        pub(crate) database_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the Glue table.</p>
        pub fn table_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.table_name = Some(input.into());
            self
        }
        /// <p>The name of the Glue table.</p>
        pub fn set_table_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.table_name = input;
            self
        }
        /// <p>The name of the database where the Glue table exists.</p>
        pub fn database_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.database_name = Some(input.into());
            self
        }
        /// <p>The name of the database where the Glue table exists.</p>
        pub fn set_database_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.database_name = input;
            self
        }
        /// Consumes the builder and constructs a [`DataQualityTargetTable`](crate::model::DataQualityTargetTable).
        pub fn build(self) -> crate::model::DataQualityTargetTable {
            crate::model::DataQualityTargetTable {
                table_name: self.table_name,
                database_name: self.database_name,
            }
        }
    }
}
impl DataQualityTargetTable {
    /// Creates a new builder-style object to manufacture [`DataQualityTargetTable`](crate::model::DataQualityTargetTable).
    pub fn builder() -> crate::model::data_quality_target_table::Builder {
        crate::model::data_quality_target_table::Builder::default()
    }
}

/// <p>The criteria used to filter data quality rulesets.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DataQualityRulesetFilterCriteria {
    /// <p>The name of the ruleset filter criteria.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The description of the ruleset filter criteria.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>Filter on rulesets created before this date.</p>
    #[doc(hidden)]
    pub created_before: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Filter on rulesets created after this date.</p>
    #[doc(hidden)]
    pub created_after: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Filter on rulesets last modified before this date.</p>
    #[doc(hidden)]
    pub last_modified_before: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Filter on rulesets last modified after this date.</p>
    #[doc(hidden)]
    pub last_modified_after: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The name and database name of the target table.</p>
    #[doc(hidden)]
    pub target_table: std::option::Option<crate::model::DataQualityTargetTable>,
}
impl DataQualityRulesetFilterCriteria {
    /// <p>The name of the ruleset filter criteria.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The description of the ruleset filter criteria.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>Filter on rulesets created before this date.</p>
    pub fn created_before(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_before.as_ref()
    }
    /// <p>Filter on rulesets created after this date.</p>
    pub fn created_after(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_after.as_ref()
    }
    /// <p>Filter on rulesets last modified before this date.</p>
    pub fn last_modified_before(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_modified_before.as_ref()
    }
    /// <p>Filter on rulesets last modified after this date.</p>
    pub fn last_modified_after(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_modified_after.as_ref()
    }
    /// <p>The name and database name of the target table.</p>
    pub fn target_table(&self) -> std::option::Option<&crate::model::DataQualityTargetTable> {
        self.target_table.as_ref()
    }
}
/// See [`DataQualityRulesetFilterCriteria`](crate::model::DataQualityRulesetFilterCriteria).
pub mod data_quality_ruleset_filter_criteria {

    /// A builder for [`DataQualityRulesetFilterCriteria`](crate::model::DataQualityRulesetFilterCriteria).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) created_before: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) created_after: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_modified_before: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_modified_after: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) target_table: std::option::Option<crate::model::DataQualityTargetTable>,
    }
    impl Builder {
        /// <p>The name of the ruleset filter criteria.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the ruleset filter criteria.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The description of the ruleset filter criteria.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the ruleset filter criteria.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>Filter on rulesets created before this date.</p>
        pub fn created_before(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_before = Some(input);
            self
        }
        /// <p>Filter on rulesets created before this date.</p>
        pub fn set_created_before(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_before = input;
            self
        }
        /// <p>Filter on rulesets created after this date.</p>
        pub fn created_after(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_after = Some(input);
            self
        }
        /// <p>Filter on rulesets created after this date.</p>
        pub fn set_created_after(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_after = input;
            self
        }
        /// <p>Filter on rulesets last modified before this date.</p>
        pub fn last_modified_before(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_modified_before = Some(input);
            self
        }
        /// <p>Filter on rulesets last modified before this date.</p>
        pub fn set_last_modified_before(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_modified_before = input;
            self
        }
        /// <p>Filter on rulesets last modified after this date.</p>
        pub fn last_modified_after(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_modified_after = Some(input);
            self
        }
        /// <p>Filter on rulesets last modified after this date.</p>
        pub fn set_last_modified_after(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_modified_after = input;
            self
        }
        /// <p>The name and database name of the target table.</p>
        pub fn target_table(mut self, input: crate::model::DataQualityTargetTable) -> Self {
            self.target_table = Some(input);
            self
        }
        /// <p>The name and database name of the target table.</p>
        pub fn set_target_table(
            mut self,
            input: std::option::Option<crate::model::DataQualityTargetTable>,
        ) -> Self {
            self.target_table = input;
            self
        }
        /// Consumes the builder and constructs a [`DataQualityRulesetFilterCriteria`](crate::model::DataQualityRulesetFilterCriteria).
        pub fn build(self) -> crate::model::DataQualityRulesetFilterCriteria {
            crate::model::DataQualityRulesetFilterCriteria {
                name: self.name,
                description: self.description,
                created_before: self.created_before,
                created_after: self.created_after,
                last_modified_before: self.last_modified_before,
                last_modified_after: self.last_modified_after,
                target_table: self.target_table,
            }
        }
    }
}
impl DataQualityRulesetFilterCriteria {
    /// Creates a new builder-style object to manufacture [`DataQualityRulesetFilterCriteria`](crate::model::DataQualityRulesetFilterCriteria).
    pub fn builder() -> crate::model::data_quality_ruleset_filter_criteria::Builder {
        crate::model::data_quality_ruleset_filter_criteria::Builder::default()
    }
}

/// <p>Describes the result of a data quality ruleset evaluation run.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DataQualityRulesetEvaluationRunDescription {
    /// <p>The unique run identifier associated with this run.</p>
    #[doc(hidden)]
    pub run_id: std::option::Option<std::string::String>,
    /// <p>The status for this run.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::TaskStatusType>,
    /// <p>The date and time when the run started.</p>
    #[doc(hidden)]
    pub started_on: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The data source (an Glue table) associated with the run.</p>
    #[doc(hidden)]
    pub data_source: std::option::Option<crate::model::DataSource>,
}
impl DataQualityRulesetEvaluationRunDescription {
    /// <p>The unique run identifier associated with this run.</p>
    pub fn run_id(&self) -> std::option::Option<&str> {
        self.run_id.as_deref()
    }
    /// <p>The status for this run.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::TaskStatusType> {
        self.status.as_ref()
    }
    /// <p>The date and time when the run started.</p>
    pub fn started_on(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.started_on.as_ref()
    }
    /// <p>The data source (an Glue table) associated with the run.</p>
    pub fn data_source(&self) -> std::option::Option<&crate::model::DataSource> {
        self.data_source.as_ref()
    }
}
/// See [`DataQualityRulesetEvaluationRunDescription`](crate::model::DataQualityRulesetEvaluationRunDescription).
pub mod data_quality_ruleset_evaluation_run_description {

    /// A builder for [`DataQualityRulesetEvaluationRunDescription`](crate::model::DataQualityRulesetEvaluationRunDescription).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) run_id: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::TaskStatusType>,
        pub(crate) started_on: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) data_source: std::option::Option<crate::model::DataSource>,
    }
    impl Builder {
        /// <p>The unique run identifier associated with this run.</p>
        pub fn run_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.run_id = Some(input.into());
            self
        }
        /// <p>The unique run identifier associated with this run.</p>
        pub fn set_run_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.run_id = input;
            self
        }
        /// <p>The status for this run.</p>
        pub fn status(mut self, input: crate::model::TaskStatusType) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status for this run.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::TaskStatusType>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>The date and time when the run started.</p>
        pub fn started_on(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.started_on = Some(input);
            self
        }
        /// <p>The date and time when the run started.</p>
        pub fn set_started_on(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.started_on = input;
            self
        }
        /// <p>The data source (an Glue table) associated with the run.</p>
        pub fn data_source(mut self, input: crate::model::DataSource) -> Self {
            self.data_source = Some(input);
            self
        }
        /// <p>The data source (an Glue table) associated with the run.</p>
        pub fn set_data_source(
            mut self,
            input: std::option::Option<crate::model::DataSource>,
        ) -> Self {
            self.data_source = input;
            self
        }
        /// Consumes the builder and constructs a [`DataQualityRulesetEvaluationRunDescription`](crate::model::DataQualityRulesetEvaluationRunDescription).
        pub fn build(self) -> crate::model::DataQualityRulesetEvaluationRunDescription {
            crate::model::DataQualityRulesetEvaluationRunDescription {
                run_id: self.run_id,
                status: self.status,
                started_on: self.started_on,
                data_source: self.data_source,
            }
        }
    }
}
impl DataQualityRulesetEvaluationRunDescription {
    /// Creates a new builder-style object to manufacture [`DataQualityRulesetEvaluationRunDescription`](crate::model::DataQualityRulesetEvaluationRunDescription).
    pub fn builder() -> crate::model::data_quality_ruleset_evaluation_run_description::Builder {
        crate::model::data_quality_ruleset_evaluation_run_description::Builder::default()
    }
}

/// When writing a match expression against `TaskStatusType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let taskstatustype = unimplemented!();
/// match taskstatustype {
///     TaskStatusType::Failed => { /* ... */ },
///     TaskStatusType::Running => { /* ... */ },
///     TaskStatusType::Starting => { /* ... */ },
///     TaskStatusType::Stopped => { /* ... */ },
///     TaskStatusType::Stopping => { /* ... */ },
///     TaskStatusType::Succeeded => { /* ... */ },
///     TaskStatusType::Timeout => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `taskstatustype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `TaskStatusType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `TaskStatusType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `TaskStatusType::NewFeature` is defined.
/// Specifically, when `taskstatustype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `TaskStatusType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TaskStatusType {
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    Running,
    #[allow(missing_docs)] // documentation missing in model
    Starting,
    #[allow(missing_docs)] // documentation missing in model
    Stopped,
    #[allow(missing_docs)] // documentation missing in model
    Stopping,
    #[allow(missing_docs)] // documentation missing in model
    Succeeded,
    #[allow(missing_docs)] // documentation missing in model
    Timeout,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for TaskStatusType {
    fn from(s: &str) -> Self {
        match s {
            "FAILED" => TaskStatusType::Failed,
            "RUNNING" => TaskStatusType::Running,
            "STARTING" => TaskStatusType::Starting,
            "STOPPED" => TaskStatusType::Stopped,
            "STOPPING" => TaskStatusType::Stopping,
            "SUCCEEDED" => TaskStatusType::Succeeded,
            "TIMEOUT" => TaskStatusType::Timeout,
            other => TaskStatusType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for TaskStatusType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TaskStatusType::from(s))
    }
}
impl TaskStatusType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            TaskStatusType::Failed => "FAILED",
            TaskStatusType::Running => "RUNNING",
            TaskStatusType::Starting => "STARTING",
            TaskStatusType::Stopped => "STOPPED",
            TaskStatusType::Stopping => "STOPPING",
            TaskStatusType::Succeeded => "SUCCEEDED",
            TaskStatusType::Timeout => "TIMEOUT",
            TaskStatusType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "FAILED",
            "RUNNING",
            "STARTING",
            "STOPPED",
            "STOPPING",
            "SUCCEEDED",
            "TIMEOUT",
        ]
    }
}
impl AsRef<str> for TaskStatusType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The filter criteria.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DataQualityRulesetEvaluationRunFilter {
    /// <p>Filter based on a data source (an Glue table) associated with the run.</p>
    #[doc(hidden)]
    pub data_source: std::option::Option<crate::model::DataSource>,
    /// <p>Filter results by runs that started before this time.</p>
    #[doc(hidden)]
    pub started_before: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Filter results by runs that started after this time.</p>
    #[doc(hidden)]
    pub started_after: std::option::Option<aws_smithy_types::DateTime>,
}
impl DataQualityRulesetEvaluationRunFilter {
    /// <p>Filter based on a data source (an Glue table) associated with the run.</p>
    pub fn data_source(&self) -> std::option::Option<&crate::model::DataSource> {
        self.data_source.as_ref()
    }
    /// <p>Filter results by runs that started before this time.</p>
    pub fn started_before(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.started_before.as_ref()
    }
    /// <p>Filter results by runs that started after this time.</p>
    pub fn started_after(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.started_after.as_ref()
    }
}
/// See [`DataQualityRulesetEvaluationRunFilter`](crate::model::DataQualityRulesetEvaluationRunFilter).
pub mod data_quality_ruleset_evaluation_run_filter {

    /// A builder for [`DataQualityRulesetEvaluationRunFilter`](crate::model::DataQualityRulesetEvaluationRunFilter).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) data_source: std::option::Option<crate::model::DataSource>,
        pub(crate) started_before: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) started_after: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>Filter based on a data source (an Glue table) associated with the run.</p>
        pub fn data_source(mut self, input: crate::model::DataSource) -> Self {
            self.data_source = Some(input);
            self
        }
        /// <p>Filter based on a data source (an Glue table) associated with the run.</p>
        pub fn set_data_source(
            mut self,
            input: std::option::Option<crate::model::DataSource>,
        ) -> Self {
            self.data_source = input;
            self
        }
        /// <p>Filter results by runs that started before this time.</p>
        pub fn started_before(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.started_before = Some(input);
            self
        }
        /// <p>Filter results by runs that started before this time.</p>
        pub fn set_started_before(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.started_before = input;
            self
        }
        /// <p>Filter results by runs that started after this time.</p>
        pub fn started_after(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.started_after = Some(input);
            self
        }
        /// <p>Filter results by runs that started after this time.</p>
        pub fn set_started_after(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.started_after = input;
            self
        }
        /// Consumes the builder and constructs a [`DataQualityRulesetEvaluationRunFilter`](crate::model::DataQualityRulesetEvaluationRunFilter).
        pub fn build(self) -> crate::model::DataQualityRulesetEvaluationRunFilter {
            crate::model::DataQualityRulesetEvaluationRunFilter {
                data_source: self.data_source,
                started_before: self.started_before,
                started_after: self.started_after,
            }
        }
    }
}
impl DataQualityRulesetEvaluationRunFilter {
    /// Creates a new builder-style object to manufacture [`DataQualityRulesetEvaluationRunFilter`](crate::model::DataQualityRulesetEvaluationRunFilter).
    pub fn builder() -> crate::model::data_quality_ruleset_evaluation_run_filter::Builder {
        crate::model::data_quality_ruleset_evaluation_run_filter::Builder::default()
    }
}

/// <p>Describes the result of a data quality rule recommendation run.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DataQualityRuleRecommendationRunDescription {
    /// <p>The unique run identifier associated with this run.</p>
    #[doc(hidden)]
    pub run_id: std::option::Option<std::string::String>,
    /// <p>The status for this run.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::TaskStatusType>,
    /// <p>The date and time when this run started.</p>
    #[doc(hidden)]
    pub started_on: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The data source (Glue table) associated with the recommendation run.</p>
    #[doc(hidden)]
    pub data_source: std::option::Option<crate::model::DataSource>,
}
impl DataQualityRuleRecommendationRunDescription {
    /// <p>The unique run identifier associated with this run.</p>
    pub fn run_id(&self) -> std::option::Option<&str> {
        self.run_id.as_deref()
    }
    /// <p>The status for this run.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::TaskStatusType> {
        self.status.as_ref()
    }
    /// <p>The date and time when this run started.</p>
    pub fn started_on(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.started_on.as_ref()
    }
    /// <p>The data source (Glue table) associated with the recommendation run.</p>
    pub fn data_source(&self) -> std::option::Option<&crate::model::DataSource> {
        self.data_source.as_ref()
    }
}
/// See [`DataQualityRuleRecommendationRunDescription`](crate::model::DataQualityRuleRecommendationRunDescription).
pub mod data_quality_rule_recommendation_run_description {

    /// A builder for [`DataQualityRuleRecommendationRunDescription`](crate::model::DataQualityRuleRecommendationRunDescription).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) run_id: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::TaskStatusType>,
        pub(crate) started_on: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) data_source: std::option::Option<crate::model::DataSource>,
    }
    impl Builder {
        /// <p>The unique run identifier associated with this run.</p>
        pub fn run_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.run_id = Some(input.into());
            self
        }
        /// <p>The unique run identifier associated with this run.</p>
        pub fn set_run_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.run_id = input;
            self
        }
        /// <p>The status for this run.</p>
        pub fn status(mut self, input: crate::model::TaskStatusType) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status for this run.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::TaskStatusType>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>The date and time when this run started.</p>
        pub fn started_on(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.started_on = Some(input);
            self
        }
        /// <p>The date and time when this run started.</p>
        pub fn set_started_on(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.started_on = input;
            self
        }
        /// <p>The data source (Glue table) associated with the recommendation run.</p>
        pub fn data_source(mut self, input: crate::model::DataSource) -> Self {
            self.data_source = Some(input);
            self
        }
        /// <p>The data source (Glue table) associated with the recommendation run.</p>
        pub fn set_data_source(
            mut self,
            input: std::option::Option<crate::model::DataSource>,
        ) -> Self {
            self.data_source = input;
            self
        }
        /// Consumes the builder and constructs a [`DataQualityRuleRecommendationRunDescription`](crate::model::DataQualityRuleRecommendationRunDescription).
        pub fn build(self) -> crate::model::DataQualityRuleRecommendationRunDescription {
            crate::model::DataQualityRuleRecommendationRunDescription {
                run_id: self.run_id,
                status: self.status,
                started_on: self.started_on,
                data_source: self.data_source,
            }
        }
    }
}
impl DataQualityRuleRecommendationRunDescription {
    /// Creates a new builder-style object to manufacture [`DataQualityRuleRecommendationRunDescription`](crate::model::DataQualityRuleRecommendationRunDescription).
    pub fn builder() -> crate::model::data_quality_rule_recommendation_run_description::Builder {
        crate::model::data_quality_rule_recommendation_run_description::Builder::default()
    }
}

/// <p>A filter for listing data quality recommendation runs.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DataQualityRuleRecommendationRunFilter {
    /// <p>Filter based on a specified data source (Glue table).</p>
    #[doc(hidden)]
    pub data_source: std::option::Option<crate::model::DataSource>,
    /// <p>Filter based on time for results started before provided time.</p>
    #[doc(hidden)]
    pub started_before: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Filter based on time for results started after provided time.</p>
    #[doc(hidden)]
    pub started_after: std::option::Option<aws_smithy_types::DateTime>,
}
impl DataQualityRuleRecommendationRunFilter {
    /// <p>Filter based on a specified data source (Glue table).</p>
    pub fn data_source(&self) -> std::option::Option<&crate::model::DataSource> {
        self.data_source.as_ref()
    }
    /// <p>Filter based on time for results started before provided time.</p>
    pub fn started_before(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.started_before.as_ref()
    }
    /// <p>Filter based on time for results started after provided time.</p>
    pub fn started_after(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.started_after.as_ref()
    }
}
/// See [`DataQualityRuleRecommendationRunFilter`](crate::model::DataQualityRuleRecommendationRunFilter).
pub mod data_quality_rule_recommendation_run_filter {

    /// A builder for [`DataQualityRuleRecommendationRunFilter`](crate::model::DataQualityRuleRecommendationRunFilter).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) data_source: std::option::Option<crate::model::DataSource>,
        pub(crate) started_before: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) started_after: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>Filter based on a specified data source (Glue table).</p>
        pub fn data_source(mut self, input: crate::model::DataSource) -> Self {
            self.data_source = Some(input);
            self
        }
        /// <p>Filter based on a specified data source (Glue table).</p>
        pub fn set_data_source(
            mut self,
            input: std::option::Option<crate::model::DataSource>,
        ) -> Self {
            self.data_source = input;
            self
        }
        /// <p>Filter based on time for results started before provided time.</p>
        pub fn started_before(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.started_before = Some(input);
            self
        }
        /// <p>Filter based on time for results started before provided time.</p>
        pub fn set_started_before(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.started_before = input;
            self
        }
        /// <p>Filter based on time for results started after provided time.</p>
        pub fn started_after(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.started_after = Some(input);
            self
        }
        /// <p>Filter based on time for results started after provided time.</p>
        pub fn set_started_after(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.started_after = input;
            self
        }
        /// Consumes the builder and constructs a [`DataQualityRuleRecommendationRunFilter`](crate::model::DataQualityRuleRecommendationRunFilter).
        pub fn build(self) -> crate::model::DataQualityRuleRecommendationRunFilter {
            crate::model::DataQualityRuleRecommendationRunFilter {
                data_source: self.data_source,
                started_before: self.started_before,
                started_after: self.started_after,
            }
        }
    }
}
impl DataQualityRuleRecommendationRunFilter {
    /// Creates a new builder-style object to manufacture [`DataQualityRuleRecommendationRunFilter`](crate::model::DataQualityRuleRecommendationRunFilter).
    pub fn builder() -> crate::model::data_quality_rule_recommendation_run_filter::Builder {
        crate::model::data_quality_rule_recommendation_run_filter::Builder::default()
    }
}

/// <p>Describes a data quality result.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DataQualityResultDescription {
    /// <p>The unique result ID for this data quality result.</p>
    #[doc(hidden)]
    pub result_id: std::option::Option<std::string::String>,
    /// <p>The table name associated with the data quality result.</p>
    #[doc(hidden)]
    pub data_source: std::option::Option<crate::model::DataSource>,
    /// <p>The job name associated with the data quality result.</p>
    #[doc(hidden)]
    pub job_name: std::option::Option<std::string::String>,
    /// <p>The job run ID associated with the data quality result.</p>
    #[doc(hidden)]
    pub job_run_id: std::option::Option<std::string::String>,
    /// <p>The time that the run started for this data quality result.</p>
    #[doc(hidden)]
    pub started_on: std::option::Option<aws_smithy_types::DateTime>,
}
impl DataQualityResultDescription {
    /// <p>The unique result ID for this data quality result.</p>
    pub fn result_id(&self) -> std::option::Option<&str> {
        self.result_id.as_deref()
    }
    /// <p>The table name associated with the data quality result.</p>
    pub fn data_source(&self) -> std::option::Option<&crate::model::DataSource> {
        self.data_source.as_ref()
    }
    /// <p>The job name associated with the data quality result.</p>
    pub fn job_name(&self) -> std::option::Option<&str> {
        self.job_name.as_deref()
    }
    /// <p>The job run ID associated with the data quality result.</p>
    pub fn job_run_id(&self) -> std::option::Option<&str> {
        self.job_run_id.as_deref()
    }
    /// <p>The time that the run started for this data quality result.</p>
    pub fn started_on(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.started_on.as_ref()
    }
}
/// See [`DataQualityResultDescription`](crate::model::DataQualityResultDescription).
pub mod data_quality_result_description {

    /// A builder for [`DataQualityResultDescription`](crate::model::DataQualityResultDescription).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) result_id: std::option::Option<std::string::String>,
        pub(crate) data_source: std::option::Option<crate::model::DataSource>,
        pub(crate) job_name: std::option::Option<std::string::String>,
        pub(crate) job_run_id: std::option::Option<std::string::String>,
        pub(crate) started_on: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The unique result ID for this data quality result.</p>
        pub fn result_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.result_id = Some(input.into());
            self
        }
        /// <p>The unique result ID for this data quality result.</p>
        pub fn set_result_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.result_id = input;
            self
        }
        /// <p>The table name associated with the data quality result.</p>
        pub fn data_source(mut self, input: crate::model::DataSource) -> Self {
            self.data_source = Some(input);
            self
        }
        /// <p>The table name associated with the data quality result.</p>
        pub fn set_data_source(
            mut self,
            input: std::option::Option<crate::model::DataSource>,
        ) -> Self {
            self.data_source = input;
            self
        }
        /// <p>The job name associated with the data quality result.</p>
        pub fn job_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_name = Some(input.into());
            self
        }
        /// <p>The job name associated with the data quality result.</p>
        pub fn set_job_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_name = input;
            self
        }
        /// <p>The job run ID associated with the data quality result.</p>
        pub fn job_run_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_run_id = Some(input.into());
            self
        }
        /// <p>The job run ID associated with the data quality result.</p>
        pub fn set_job_run_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_run_id = input;
            self
        }
        /// <p>The time that the run started for this data quality result.</p>
        pub fn started_on(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.started_on = Some(input);
            self
        }
        /// <p>The time that the run started for this data quality result.</p>
        pub fn set_started_on(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.started_on = input;
            self
        }
        /// Consumes the builder and constructs a [`DataQualityResultDescription`](crate::model::DataQualityResultDescription).
        pub fn build(self) -> crate::model::DataQualityResultDescription {
            crate::model::DataQualityResultDescription {
                result_id: self.result_id,
                data_source: self.data_source,
                job_name: self.job_name,
                job_run_id: self.job_run_id,
                started_on: self.started_on,
            }
        }
    }
}
impl DataQualityResultDescription {
    /// Creates a new builder-style object to manufacture [`DataQualityResultDescription`](crate::model::DataQualityResultDescription).
    pub fn builder() -> crate::model::data_quality_result_description::Builder {
        crate::model::data_quality_result_description::Builder::default()
    }
}

/// <p>Criteria used to return data quality results.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DataQualityResultFilterCriteria {
    /// <p>Filter results by the specified data source. For example, retrieving all results for an Glue table.</p>
    #[doc(hidden)]
    pub data_source: std::option::Option<crate::model::DataSource>,
    /// <p>Filter results by the specified job name.</p>
    #[doc(hidden)]
    pub job_name: std::option::Option<std::string::String>,
    /// <p>Filter results by the specified job run ID.</p>
    #[doc(hidden)]
    pub job_run_id: std::option::Option<std::string::String>,
    /// <p>Filter results by runs that started after this time.</p>
    #[doc(hidden)]
    pub started_after: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Filter results by runs that started before this time.</p>
    #[doc(hidden)]
    pub started_before: std::option::Option<aws_smithy_types::DateTime>,
}
impl DataQualityResultFilterCriteria {
    /// <p>Filter results by the specified data source. For example, retrieving all results for an Glue table.</p>
    pub fn data_source(&self) -> std::option::Option<&crate::model::DataSource> {
        self.data_source.as_ref()
    }
    /// <p>Filter results by the specified job name.</p>
    pub fn job_name(&self) -> std::option::Option<&str> {
        self.job_name.as_deref()
    }
    /// <p>Filter results by the specified job run ID.</p>
    pub fn job_run_id(&self) -> std::option::Option<&str> {
        self.job_run_id.as_deref()
    }
    /// <p>Filter results by runs that started after this time.</p>
    pub fn started_after(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.started_after.as_ref()
    }
    /// <p>Filter results by runs that started before this time.</p>
    pub fn started_before(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.started_before.as_ref()
    }
}
/// See [`DataQualityResultFilterCriteria`](crate::model::DataQualityResultFilterCriteria).
pub mod data_quality_result_filter_criteria {

    /// A builder for [`DataQualityResultFilterCriteria`](crate::model::DataQualityResultFilterCriteria).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) data_source: std::option::Option<crate::model::DataSource>,
        pub(crate) job_name: std::option::Option<std::string::String>,
        pub(crate) job_run_id: std::option::Option<std::string::String>,
        pub(crate) started_after: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) started_before: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>Filter results by the specified data source. For example, retrieving all results for an Glue table.</p>
        pub fn data_source(mut self, input: crate::model::DataSource) -> Self {
            self.data_source = Some(input);
            self
        }
        /// <p>Filter results by the specified data source. For example, retrieving all results for an Glue table.</p>
        pub fn set_data_source(
            mut self,
            input: std::option::Option<crate::model::DataSource>,
        ) -> Self {
            self.data_source = input;
            self
        }
        /// <p>Filter results by the specified job name.</p>
        pub fn job_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_name = Some(input.into());
            self
        }
        /// <p>Filter results by the specified job name.</p>
        pub fn set_job_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_name = input;
            self
        }
        /// <p>Filter results by the specified job run ID.</p>
        pub fn job_run_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_run_id = Some(input.into());
            self
        }
        /// <p>Filter results by the specified job run ID.</p>
        pub fn set_job_run_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_run_id = input;
            self
        }
        /// <p>Filter results by runs that started after this time.</p>
        pub fn started_after(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.started_after = Some(input);
            self
        }
        /// <p>Filter results by runs that started after this time.</p>
        pub fn set_started_after(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.started_after = input;
            self
        }
        /// <p>Filter results by runs that started before this time.</p>
        pub fn started_before(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.started_before = Some(input);
            self
        }
        /// <p>Filter results by runs that started before this time.</p>
        pub fn set_started_before(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.started_before = input;
            self
        }
        /// Consumes the builder and constructs a [`DataQualityResultFilterCriteria`](crate::model::DataQualityResultFilterCriteria).
        pub fn build(self) -> crate::model::DataQualityResultFilterCriteria {
            crate::model::DataQualityResultFilterCriteria {
                data_source: self.data_source,
                job_name: self.job_name,
                job_run_id: self.job_run_id,
                started_after: self.started_after,
                started_before: self.started_before,
            }
        }
    }
}
impl DataQualityResultFilterCriteria {
    /// Creates a new builder-style object to manufacture [`DataQualityResultFilterCriteria`](crate::model::DataQualityResultFilterCriteria).
    pub fn builder() -> crate::model::data_quality_result_filter_criteria::Builder {
        crate::model::data_quality_result_filter_criteria::Builder::default()
    }
}

/// <p>An object representing a custom pattern for detecting sensitive data across the columns and rows of your structured data.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CustomEntityType {
    /// <p>A name for the custom pattern that allows it to be retrieved or deleted later. This name must be unique per Amazon Web Services account.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>A regular expression string that is used for detecting sensitive data in a custom pattern.</p>
    #[doc(hidden)]
    pub regex_string: std::option::Option<std::string::String>,
    /// <p>A list of context words. If none of these context words are found within the vicinity of the regular expression the data will not be detected as sensitive data.</p>
    /// <p>If no context words are passed only a regular expression is checked.</p>
    #[doc(hidden)]
    pub context_words: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl CustomEntityType {
    /// <p>A name for the custom pattern that allows it to be retrieved or deleted later. This name must be unique per Amazon Web Services account.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>A regular expression string that is used for detecting sensitive data in a custom pattern.</p>
    pub fn regex_string(&self) -> std::option::Option<&str> {
        self.regex_string.as_deref()
    }
    /// <p>A list of context words. If none of these context words are found within the vicinity of the regular expression the data will not be detected as sensitive data.</p>
    /// <p>If no context words are passed only a regular expression is checked.</p>
    pub fn context_words(&self) -> std::option::Option<&[std::string::String]> {
        self.context_words.as_deref()
    }
}
/// See [`CustomEntityType`](crate::model::CustomEntityType).
pub mod custom_entity_type {

    /// A builder for [`CustomEntityType`](crate::model::CustomEntityType).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) regex_string: std::option::Option<std::string::String>,
        pub(crate) context_words: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>A name for the custom pattern that allows it to be retrieved or deleted later. This name must be unique per Amazon Web Services account.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>A name for the custom pattern that allows it to be retrieved or deleted later. This name must be unique per Amazon Web Services account.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>A regular expression string that is used for detecting sensitive data in a custom pattern.</p>
        pub fn regex_string(mut self, input: impl Into<std::string::String>) -> Self {
            self.regex_string = Some(input.into());
            self
        }
        /// <p>A regular expression string that is used for detecting sensitive data in a custom pattern.</p>
        pub fn set_regex_string(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.regex_string = input;
            self
        }
        /// Appends an item to `context_words`.
        ///
        /// To override the contents of this collection use [`set_context_words`](Self::set_context_words).
        ///
        /// <p>A list of context words. If none of these context words are found within the vicinity of the regular expression the data will not be detected as sensitive data.</p>
        /// <p>If no context words are passed only a regular expression is checked.</p>
        pub fn context_words(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.context_words.unwrap_or_default();
            v.push(input.into());
            self.context_words = Some(v);
            self
        }
        /// <p>A list of context words. If none of these context words are found within the vicinity of the regular expression the data will not be detected as sensitive data.</p>
        /// <p>If no context words are passed only a regular expression is checked.</p>
        pub fn set_context_words(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.context_words = input;
            self
        }
        /// Consumes the builder and constructs a [`CustomEntityType`](crate::model::CustomEntityType).
        pub fn build(self) -> crate::model::CustomEntityType {
            crate::model::CustomEntityType {
                name: self.name,
                regex_string: self.regex_string,
                context_words: self.context_words,
            }
        }
    }
}
impl CustomEntityType {
    /// Creates a new builder-style object to manufacture [`CustomEntityType`](crate::model::CustomEntityType).
    pub fn builder() -> crate::model::custom_entity_type::Builder {
        crate::model::custom_entity_type::Builder::default()
    }
}

/// <p>Contains the information for a run of a crawler.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CrawlerHistory {
    /// <p>A UUID identifier for each crawl.</p>
    #[doc(hidden)]
    pub crawl_id: std::option::Option<std::string::String>,
    /// <p>The state of the crawl.</p>
    #[doc(hidden)]
    pub state: std::option::Option<crate::model::CrawlerHistoryState>,
    /// <p>The date and time on which the crawl started.</p>
    #[doc(hidden)]
    pub start_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The date and time on which the crawl ended.</p>
    #[doc(hidden)]
    pub end_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>A run summary for the specific crawl in JSON. Contains the catalog tables and partitions that were added, updated, or deleted.</p>
    #[doc(hidden)]
    pub summary: std::option::Option<std::string::String>,
    /// <p>If an error occurred, the error message associated with the crawl.</p>
    #[doc(hidden)]
    pub error_message: std::option::Option<std::string::String>,
    /// <p>The log group associated with the crawl.</p>
    #[doc(hidden)]
    pub log_group: std::option::Option<std::string::String>,
    /// <p>The log stream associated with the crawl.</p>
    #[doc(hidden)]
    pub log_stream: std::option::Option<std::string::String>,
    /// <p>The prefix for a CloudWatch message about this crawl.</p>
    #[doc(hidden)]
    pub message_prefix: std::option::Option<std::string::String>,
    /// <p>The number of data processing units (DPU) used in hours for the crawl.</p>
    #[doc(hidden)]
    pub dpu_hour: f64,
}
impl CrawlerHistory {
    /// <p>A UUID identifier for each crawl.</p>
    pub fn crawl_id(&self) -> std::option::Option<&str> {
        self.crawl_id.as_deref()
    }
    /// <p>The state of the crawl.</p>
    pub fn state(&self) -> std::option::Option<&crate::model::CrawlerHistoryState> {
        self.state.as_ref()
    }
    /// <p>The date and time on which the crawl started.</p>
    pub fn start_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.start_time.as_ref()
    }
    /// <p>The date and time on which the crawl ended.</p>
    pub fn end_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.end_time.as_ref()
    }
    /// <p>A run summary for the specific crawl in JSON. Contains the catalog tables and partitions that were added, updated, or deleted.</p>
    pub fn summary(&self) -> std::option::Option<&str> {
        self.summary.as_deref()
    }
    /// <p>If an error occurred, the error message associated with the crawl.</p>
    pub fn error_message(&self) -> std::option::Option<&str> {
        self.error_message.as_deref()
    }
    /// <p>The log group associated with the crawl.</p>
    pub fn log_group(&self) -> std::option::Option<&str> {
        self.log_group.as_deref()
    }
    /// <p>The log stream associated with the crawl.</p>
    pub fn log_stream(&self) -> std::option::Option<&str> {
        self.log_stream.as_deref()
    }
    /// <p>The prefix for a CloudWatch message about this crawl.</p>
    pub fn message_prefix(&self) -> std::option::Option<&str> {
        self.message_prefix.as_deref()
    }
    /// <p>The number of data processing units (DPU) used in hours for the crawl.</p>
    pub fn dpu_hour(&self) -> f64 {
        self.dpu_hour
    }
}
/// See [`CrawlerHistory`](crate::model::CrawlerHistory).
pub mod crawler_history {

    /// A builder for [`CrawlerHistory`](crate::model::CrawlerHistory).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) crawl_id: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<crate::model::CrawlerHistoryState>,
        pub(crate) start_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) end_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) summary: std::option::Option<std::string::String>,
        pub(crate) error_message: std::option::Option<std::string::String>,
        pub(crate) log_group: std::option::Option<std::string::String>,
        pub(crate) log_stream: std::option::Option<std::string::String>,
        pub(crate) message_prefix: std::option::Option<std::string::String>,
        pub(crate) dpu_hour: std::option::Option<f64>,
    }
    impl Builder {
        /// <p>A UUID identifier for each crawl.</p>
        pub fn crawl_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.crawl_id = Some(input.into());
            self
        }
        /// <p>A UUID identifier for each crawl.</p>
        pub fn set_crawl_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.crawl_id = input;
            self
        }
        /// <p>The state of the crawl.</p>
        pub fn state(mut self, input: crate::model::CrawlerHistoryState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The state of the crawl.</p>
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::CrawlerHistoryState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// <p>The date and time on which the crawl started.</p>
        pub fn start_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.start_time = Some(input);
            self
        }
        /// <p>The date and time on which the crawl started.</p>
        pub fn set_start_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.start_time = input;
            self
        }
        /// <p>The date and time on which the crawl ended.</p>
        pub fn end_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.end_time = Some(input);
            self
        }
        /// <p>The date and time on which the crawl ended.</p>
        pub fn set_end_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.end_time = input;
            self
        }
        /// <p>A run summary for the specific crawl in JSON. Contains the catalog tables and partitions that were added, updated, or deleted.</p>
        pub fn summary(mut self, input: impl Into<std::string::String>) -> Self {
            self.summary = Some(input.into());
            self
        }
        /// <p>A run summary for the specific crawl in JSON. Contains the catalog tables and partitions that were added, updated, or deleted.</p>
        pub fn set_summary(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.summary = input;
            self
        }
        /// <p>If an error occurred, the error message associated with the crawl.</p>
        pub fn error_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_message = Some(input.into());
            self
        }
        /// <p>If an error occurred, the error message associated with the crawl.</p>
        pub fn set_error_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.error_message = input;
            self
        }
        /// <p>The log group associated with the crawl.</p>
        pub fn log_group(mut self, input: impl Into<std::string::String>) -> Self {
            self.log_group = Some(input.into());
            self
        }
        /// <p>The log group associated with the crawl.</p>
        pub fn set_log_group(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.log_group = input;
            self
        }
        /// <p>The log stream associated with the crawl.</p>
        pub fn log_stream(mut self, input: impl Into<std::string::String>) -> Self {
            self.log_stream = Some(input.into());
            self
        }
        /// <p>The log stream associated with the crawl.</p>
        pub fn set_log_stream(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.log_stream = input;
            self
        }
        /// <p>The prefix for a CloudWatch message about this crawl.</p>
        pub fn message_prefix(mut self, input: impl Into<std::string::String>) -> Self {
            self.message_prefix = Some(input.into());
            self
        }
        /// <p>The prefix for a CloudWatch message about this crawl.</p>
        pub fn set_message_prefix(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.message_prefix = input;
            self
        }
        /// <p>The number of data processing units (DPU) used in hours for the crawl.</p>
        pub fn dpu_hour(mut self, input: f64) -> Self {
            self.dpu_hour = Some(input);
            self
        }
        /// <p>The number of data processing units (DPU) used in hours for the crawl.</p>
        pub fn set_dpu_hour(mut self, input: std::option::Option<f64>) -> Self {
            self.dpu_hour = input;
            self
        }
        /// Consumes the builder and constructs a [`CrawlerHistory`](crate::model::CrawlerHistory).
        pub fn build(self) -> crate::model::CrawlerHistory {
            crate::model::CrawlerHistory {
                crawl_id: self.crawl_id,
                state: self.state,
                start_time: self.start_time,
                end_time: self.end_time,
                summary: self.summary,
                error_message: self.error_message,
                log_group: self.log_group,
                log_stream: self.log_stream,
                message_prefix: self.message_prefix,
                dpu_hour: self.dpu_hour.unwrap_or_default(),
            }
        }
    }
}
impl CrawlerHistory {
    /// Creates a new builder-style object to manufacture [`CrawlerHistory`](crate::model::CrawlerHistory).
    pub fn builder() -> crate::model::crawler_history::Builder {
        crate::model::crawler_history::Builder::default()
    }
}

/// When writing a match expression against `CrawlerHistoryState`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let crawlerhistorystate = unimplemented!();
/// match crawlerhistorystate {
///     CrawlerHistoryState::Completed => { /* ... */ },
///     CrawlerHistoryState::Failed => { /* ... */ },
///     CrawlerHistoryState::Running => { /* ... */ },
///     CrawlerHistoryState::Stopped => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `crawlerhistorystate` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `CrawlerHistoryState::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `CrawlerHistoryState::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `CrawlerHistoryState::NewFeature` is defined.
/// Specifically, when `crawlerhistorystate` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `CrawlerHistoryState::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum CrawlerHistoryState {
    #[allow(missing_docs)] // documentation missing in model
    Completed,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    Running,
    #[allow(missing_docs)] // documentation missing in model
    Stopped,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for CrawlerHistoryState {
    fn from(s: &str) -> Self {
        match s {
            "COMPLETED" => CrawlerHistoryState::Completed,
            "FAILED" => CrawlerHistoryState::Failed,
            "RUNNING" => CrawlerHistoryState::Running,
            "STOPPED" => CrawlerHistoryState::Stopped,
            other => {
                CrawlerHistoryState::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for CrawlerHistoryState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(CrawlerHistoryState::from(s))
    }
}
impl CrawlerHistoryState {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            CrawlerHistoryState::Completed => "COMPLETED",
            CrawlerHistoryState::Failed => "FAILED",
            CrawlerHistoryState::Running => "RUNNING",
            CrawlerHistoryState::Stopped => "STOPPED",
            CrawlerHistoryState::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["COMPLETED", "FAILED", "RUNNING", "STOPPED"]
    }
}
impl AsRef<str> for CrawlerHistoryState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A list of fields, comparators and value that you can use to filter the crawler runs for a specified crawler.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CrawlsFilter {
    /// <p>A key used to filter the crawler runs for a specified crawler. Valid values for each of the field names are:</p>
    /// <ul>
    /// <li> <p> <code>CRAWL_ID</code>: A string representing the UUID identifier for a crawl.</p> </li>
    /// <li> <p> <code>STATE</code>: A string representing the state of the crawl.</p> </li>
    /// <li> <p> <code>START_TIME</code> and <code>END_TIME</code>: The epoch timestamp in milliseconds.</p> </li>
    /// <li> <p> <code>DPU_HOUR</code>: The number of data processing unit (DPU) hours used for the crawl.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub field_name: std::option::Option<crate::model::FieldName>,
    /// <p>A defined comparator that operates on the value. The available operators are:</p>
    /// <ul>
    /// <li> <p> <code>GT</code>: Greater than.</p> </li>
    /// <li> <p> <code>GE</code>: Greater than or equal to.</p> </li>
    /// <li> <p> <code>LT</code>: Less than.</p> </li>
    /// <li> <p> <code>LE</code>: Less than or equal to.</p> </li>
    /// <li> <p> <code>EQ</code>: Equal to.</p> </li>
    /// <li> <p> <code>NE</code>: Not equal to.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub filter_operator: std::option::Option<crate::model::FilterOperator>,
    /// <p>The value provided for comparison on the crawl field. </p>
    #[doc(hidden)]
    pub field_value: std::option::Option<std::string::String>,
}
impl CrawlsFilter {
    /// <p>A key used to filter the crawler runs for a specified crawler. Valid values for each of the field names are:</p>
    /// <ul>
    /// <li> <p> <code>CRAWL_ID</code>: A string representing the UUID identifier for a crawl.</p> </li>
    /// <li> <p> <code>STATE</code>: A string representing the state of the crawl.</p> </li>
    /// <li> <p> <code>START_TIME</code> and <code>END_TIME</code>: The epoch timestamp in milliseconds.</p> </li>
    /// <li> <p> <code>DPU_HOUR</code>: The number of data processing unit (DPU) hours used for the crawl.</p> </li>
    /// </ul>
    pub fn field_name(&self) -> std::option::Option<&crate::model::FieldName> {
        self.field_name.as_ref()
    }
    /// <p>A defined comparator that operates on the value. The available operators are:</p>
    /// <ul>
    /// <li> <p> <code>GT</code>: Greater than.</p> </li>
    /// <li> <p> <code>GE</code>: Greater than or equal to.</p> </li>
    /// <li> <p> <code>LT</code>: Less than.</p> </li>
    /// <li> <p> <code>LE</code>: Less than or equal to.</p> </li>
    /// <li> <p> <code>EQ</code>: Equal to.</p> </li>
    /// <li> <p> <code>NE</code>: Not equal to.</p> </li>
    /// </ul>
    pub fn filter_operator(&self) -> std::option::Option<&crate::model::FilterOperator> {
        self.filter_operator.as_ref()
    }
    /// <p>The value provided for comparison on the crawl field. </p>
    pub fn field_value(&self) -> std::option::Option<&str> {
        self.field_value.as_deref()
    }
}
/// See [`CrawlsFilter`](crate::model::CrawlsFilter).
pub mod crawls_filter {

    /// A builder for [`CrawlsFilter`](crate::model::CrawlsFilter).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) field_name: std::option::Option<crate::model::FieldName>,
        pub(crate) filter_operator: std::option::Option<crate::model::FilterOperator>,
        pub(crate) field_value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A key used to filter the crawler runs for a specified crawler. Valid values for each of the field names are:</p>
        /// <ul>
        /// <li> <p> <code>CRAWL_ID</code>: A string representing the UUID identifier for a crawl.</p> </li>
        /// <li> <p> <code>STATE</code>: A string representing the state of the crawl.</p> </li>
        /// <li> <p> <code>START_TIME</code> and <code>END_TIME</code>: The epoch timestamp in milliseconds.</p> </li>
        /// <li> <p> <code>DPU_HOUR</code>: The number of data processing unit (DPU) hours used for the crawl.</p> </li>
        /// </ul>
        pub fn field_name(mut self, input: crate::model::FieldName) -> Self {
            self.field_name = Some(input);
            self
        }
        /// <p>A key used to filter the crawler runs for a specified crawler. Valid values for each of the field names are:</p>
        /// <ul>
        /// <li> <p> <code>CRAWL_ID</code>: A string representing the UUID identifier for a crawl.</p> </li>
        /// <li> <p> <code>STATE</code>: A string representing the state of the crawl.</p> </li>
        /// <li> <p> <code>START_TIME</code> and <code>END_TIME</code>: The epoch timestamp in milliseconds.</p> </li>
        /// <li> <p> <code>DPU_HOUR</code>: The number of data processing unit (DPU) hours used for the crawl.</p> </li>
        /// </ul>
        pub fn set_field_name(
            mut self,
            input: std::option::Option<crate::model::FieldName>,
        ) -> Self {
            self.field_name = input;
            self
        }
        /// <p>A defined comparator that operates on the value. The available operators are:</p>
        /// <ul>
        /// <li> <p> <code>GT</code>: Greater than.</p> </li>
        /// <li> <p> <code>GE</code>: Greater than or equal to.</p> </li>
        /// <li> <p> <code>LT</code>: Less than.</p> </li>
        /// <li> <p> <code>LE</code>: Less than or equal to.</p> </li>
        /// <li> <p> <code>EQ</code>: Equal to.</p> </li>
        /// <li> <p> <code>NE</code>: Not equal to.</p> </li>
        /// </ul>
        pub fn filter_operator(mut self, input: crate::model::FilterOperator) -> Self {
            self.filter_operator = Some(input);
            self
        }
        /// <p>A defined comparator that operates on the value. The available operators are:</p>
        /// <ul>
        /// <li> <p> <code>GT</code>: Greater than.</p> </li>
        /// <li> <p> <code>GE</code>: Greater than or equal to.</p> </li>
        /// <li> <p> <code>LT</code>: Less than.</p> </li>
        /// <li> <p> <code>LE</code>: Less than or equal to.</p> </li>
        /// <li> <p> <code>EQ</code>: Equal to.</p> </li>
        /// <li> <p> <code>NE</code>: Not equal to.</p> </li>
        /// </ul>
        pub fn set_filter_operator(
            mut self,
            input: std::option::Option<crate::model::FilterOperator>,
        ) -> Self {
            self.filter_operator = input;
            self
        }
        /// <p>The value provided for comparison on the crawl field. </p>
        pub fn field_value(mut self, input: impl Into<std::string::String>) -> Self {
            self.field_value = Some(input.into());
            self
        }
        /// <p>The value provided for comparison on the crawl field. </p>
        pub fn set_field_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.field_value = input;
            self
        }
        /// Consumes the builder and constructs a [`CrawlsFilter`](crate::model::CrawlsFilter).
        pub fn build(self) -> crate::model::CrawlsFilter {
            crate::model::CrawlsFilter {
                field_name: self.field_name,
                filter_operator: self.filter_operator,
                field_value: self.field_value,
            }
        }
    }
}
impl CrawlsFilter {
    /// Creates a new builder-style object to manufacture [`CrawlsFilter`](crate::model::CrawlsFilter).
    pub fn builder() -> crate::model::crawls_filter::Builder {
        crate::model::crawls_filter::Builder::default()
    }
}

/// When writing a match expression against `FilterOperator`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let filteroperator = unimplemented!();
/// match filteroperator {
///     FilterOperator::Eq => { /* ... */ },
///     FilterOperator::Ge => { /* ... */ },
///     FilterOperator::Gt => { /* ... */ },
///     FilterOperator::Le => { /* ... */ },
///     FilterOperator::Lt => { /* ... */ },
///     FilterOperator::Ne => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `filteroperator` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `FilterOperator::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `FilterOperator::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `FilterOperator::NewFeature` is defined.
/// Specifically, when `filteroperator` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `FilterOperator::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum FilterOperator {
    #[allow(missing_docs)] // documentation missing in model
    Eq,
    #[allow(missing_docs)] // documentation missing in model
    Ge,
    #[allow(missing_docs)] // documentation missing in model
    Gt,
    #[allow(missing_docs)] // documentation missing in model
    Le,
    #[allow(missing_docs)] // documentation missing in model
    Lt,
    #[allow(missing_docs)] // documentation missing in model
    Ne,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for FilterOperator {
    fn from(s: &str) -> Self {
        match s {
            "EQ" => FilterOperator::Eq,
            "GE" => FilterOperator::Ge,
            "GT" => FilterOperator::Gt,
            "LE" => FilterOperator::Le,
            "LT" => FilterOperator::Lt,
            "NE" => FilterOperator::Ne,
            other => FilterOperator::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for FilterOperator {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(FilterOperator::from(s))
    }
}
impl FilterOperator {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            FilterOperator::Eq => "EQ",
            FilterOperator::Ge => "GE",
            FilterOperator::Gt => "GT",
            FilterOperator::Le => "LE",
            FilterOperator::Lt => "LT",
            FilterOperator::Ne => "NE",
            FilterOperator::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["EQ", "GE", "GT", "LE", "LT", "NE"]
    }
}
impl AsRef<str> for FilterOperator {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `FieldName`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let fieldname = unimplemented!();
/// match fieldname {
///     FieldName::CrawlId => { /* ... */ },
///     FieldName::DpuHour => { /* ... */ },
///     FieldName::EndTime => { /* ... */ },
///     FieldName::StartTime => { /* ... */ },
///     FieldName::State => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `fieldname` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `FieldName::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `FieldName::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `FieldName::NewFeature` is defined.
/// Specifically, when `fieldname` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `FieldName::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum FieldName {
    #[allow(missing_docs)] // documentation missing in model
    CrawlId,
    #[allow(missing_docs)] // documentation missing in model
    DpuHour,
    #[allow(missing_docs)] // documentation missing in model
    EndTime,
    #[allow(missing_docs)] // documentation missing in model
    StartTime,
    #[allow(missing_docs)] // documentation missing in model
    State,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for FieldName {
    fn from(s: &str) -> Self {
        match s {
            "CRAWL_ID" => FieldName::CrawlId,
            "DPU_HOUR" => FieldName::DpuHour,
            "END_TIME" => FieldName::EndTime,
            "START_TIME" => FieldName::StartTime,
            "STATE" => FieldName::State,
            other => FieldName::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for FieldName {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(FieldName::from(s))
    }
}
impl FieldName {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            FieldName::CrawlId => "CRAWL_ID",
            FieldName::DpuHour => "DPU_HOUR",
            FieldName::EndTime => "END_TIME",
            FieldName::StartTime => "START_TIME",
            FieldName::State => "STATE",
            FieldName::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["CRAWL_ID", "DPU_HOUR", "END_TIME", "START_TIME", "STATE"]
    }
}
impl AsRef<str> for FieldName {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A workflow run is an execution of a workflow providing all the runtime information.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct WorkflowRun {
    /// <p>Name of the workflow that was run.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The ID of this workflow run.</p>
    #[doc(hidden)]
    pub workflow_run_id: std::option::Option<std::string::String>,
    /// <p>The ID of the previous workflow run.</p>
    #[doc(hidden)]
    pub previous_run_id: std::option::Option<std::string::String>,
    /// <p>The workflow run properties which were set during the run.</p>
    #[doc(hidden)]
    pub workflow_run_properties:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The date and time when the workflow run was started.</p>
    #[doc(hidden)]
    pub started_on: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The date and time when the workflow run completed.</p>
    #[doc(hidden)]
    pub completed_on: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The status of the workflow run.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::WorkflowRunStatus>,
    /// <p>This error message describes any error that may have occurred in starting the workflow run. Currently the only error message is "Concurrent runs exceeded for workflow: <code>foo</code>."</p>
    #[doc(hidden)]
    pub error_message: std::option::Option<std::string::String>,
    /// <p>The statistics of the run.</p>
    #[doc(hidden)]
    pub statistics: std::option::Option<crate::model::WorkflowRunStatistics>,
    /// <p>The graph representing all the Glue components that belong to the workflow as nodes and directed connections between them as edges.</p>
    #[doc(hidden)]
    pub graph: std::option::Option<crate::model::WorkflowGraph>,
    /// <p>The batch condition that started the workflow run.</p>
    #[doc(hidden)]
    pub starting_event_batch_condition:
        std::option::Option<crate::model::StartingEventBatchCondition>,
}
impl WorkflowRun {
    /// <p>Name of the workflow that was run.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The ID of this workflow run.</p>
    pub fn workflow_run_id(&self) -> std::option::Option<&str> {
        self.workflow_run_id.as_deref()
    }
    /// <p>The ID of the previous workflow run.</p>
    pub fn previous_run_id(&self) -> std::option::Option<&str> {
        self.previous_run_id.as_deref()
    }
    /// <p>The workflow run properties which were set during the run.</p>
    pub fn workflow_run_properties(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.workflow_run_properties.as_ref()
    }
    /// <p>The date and time when the workflow run was started.</p>
    pub fn started_on(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.started_on.as_ref()
    }
    /// <p>The date and time when the workflow run completed.</p>
    pub fn completed_on(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.completed_on.as_ref()
    }
    /// <p>The status of the workflow run.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::WorkflowRunStatus> {
        self.status.as_ref()
    }
    /// <p>This error message describes any error that may have occurred in starting the workflow run. Currently the only error message is "Concurrent runs exceeded for workflow: <code>foo</code>."</p>
    pub fn error_message(&self) -> std::option::Option<&str> {
        self.error_message.as_deref()
    }
    /// <p>The statistics of the run.</p>
    pub fn statistics(&self) -> std::option::Option<&crate::model::WorkflowRunStatistics> {
        self.statistics.as_ref()
    }
    /// <p>The graph representing all the Glue components that belong to the workflow as nodes and directed connections between them as edges.</p>
    pub fn graph(&self) -> std::option::Option<&crate::model::WorkflowGraph> {
        self.graph.as_ref()
    }
    /// <p>The batch condition that started the workflow run.</p>
    pub fn starting_event_batch_condition(
        &self,
    ) -> std::option::Option<&crate::model::StartingEventBatchCondition> {
        self.starting_event_batch_condition.as_ref()
    }
}
/// See [`WorkflowRun`](crate::model::WorkflowRun).
pub mod workflow_run {

    /// A builder for [`WorkflowRun`](crate::model::WorkflowRun).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) workflow_run_id: std::option::Option<std::string::String>,
        pub(crate) previous_run_id: std::option::Option<std::string::String>,
        pub(crate) workflow_run_properties: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) started_on: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) completed_on: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) status: std::option::Option<crate::model::WorkflowRunStatus>,
        pub(crate) error_message: std::option::Option<std::string::String>,
        pub(crate) statistics: std::option::Option<crate::model::WorkflowRunStatistics>,
        pub(crate) graph: std::option::Option<crate::model::WorkflowGraph>,
        pub(crate) starting_event_batch_condition:
            std::option::Option<crate::model::StartingEventBatchCondition>,
    }
    impl Builder {
        /// <p>Name of the workflow that was run.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>Name of the workflow that was run.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The ID of this workflow run.</p>
        pub fn workflow_run_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.workflow_run_id = Some(input.into());
            self
        }
        /// <p>The ID of this workflow run.</p>
        pub fn set_workflow_run_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.workflow_run_id = input;
            self
        }
        /// <p>The ID of the previous workflow run.</p>
        pub fn previous_run_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.previous_run_id = Some(input.into());
            self
        }
        /// <p>The ID of the previous workflow run.</p>
        pub fn set_previous_run_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.previous_run_id = input;
            self
        }
        /// Adds a key-value pair to `workflow_run_properties`.
        ///
        /// To override the contents of this collection use [`set_workflow_run_properties`](Self::set_workflow_run_properties).
        ///
        /// <p>The workflow run properties which were set during the run.</p>
        pub fn workflow_run_properties(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.workflow_run_properties.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.workflow_run_properties = Some(hash_map);
            self
        }
        /// <p>The workflow run properties which were set during the run.</p>
        pub fn set_workflow_run_properties(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.workflow_run_properties = input;
            self
        }
        /// <p>The date and time when the workflow run was started.</p>
        pub fn started_on(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.started_on = Some(input);
            self
        }
        /// <p>The date and time when the workflow run was started.</p>
        pub fn set_started_on(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.started_on = input;
            self
        }
        /// <p>The date and time when the workflow run completed.</p>
        pub fn completed_on(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.completed_on = Some(input);
            self
        }
        /// <p>The date and time when the workflow run completed.</p>
        pub fn set_completed_on(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.completed_on = input;
            self
        }
        /// <p>The status of the workflow run.</p>
        pub fn status(mut self, input: crate::model::WorkflowRunStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the workflow run.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::WorkflowRunStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>This error message describes any error that may have occurred in starting the workflow run. Currently the only error message is "Concurrent runs exceeded for workflow: <code>foo</code>."</p>
        pub fn error_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_message = Some(input.into());
            self
        }
        /// <p>This error message describes any error that may have occurred in starting the workflow run. Currently the only error message is "Concurrent runs exceeded for workflow: <code>foo</code>."</p>
        pub fn set_error_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.error_message = input;
            self
        }
        /// <p>The statistics of the run.</p>
        pub fn statistics(mut self, input: crate::model::WorkflowRunStatistics) -> Self {
            self.statistics = Some(input);
            self
        }
        /// <p>The statistics of the run.</p>
        pub fn set_statistics(
            mut self,
            input: std::option::Option<crate::model::WorkflowRunStatistics>,
        ) -> Self {
            self.statistics = input;
            self
        }
        /// <p>The graph representing all the Glue components that belong to the workflow as nodes and directed connections between them as edges.</p>
        pub fn graph(mut self, input: crate::model::WorkflowGraph) -> Self {
            self.graph = Some(input);
            self
        }
        /// <p>The graph representing all the Glue components that belong to the workflow as nodes and directed connections between them as edges.</p>
        pub fn set_graph(
            mut self,
            input: std::option::Option<crate::model::WorkflowGraph>,
        ) -> Self {
            self.graph = input;
            self
        }
        /// <p>The batch condition that started the workflow run.</p>
        pub fn starting_event_batch_condition(
            mut self,
            input: crate::model::StartingEventBatchCondition,
        ) -> Self {
            self.starting_event_batch_condition = Some(input);
            self
        }
        /// <p>The batch condition that started the workflow run.</p>
        pub fn set_starting_event_batch_condition(
            mut self,
            input: std::option::Option<crate::model::StartingEventBatchCondition>,
        ) -> Self {
            self.starting_event_batch_condition = input;
            self
        }
        /// Consumes the builder and constructs a [`WorkflowRun`](crate::model::WorkflowRun).
        pub fn build(self) -> crate::model::WorkflowRun {
            crate::model::WorkflowRun {
                name: self.name,
                workflow_run_id: self.workflow_run_id,
                previous_run_id: self.previous_run_id,
                workflow_run_properties: self.workflow_run_properties,
                started_on: self.started_on,
                completed_on: self.completed_on,
                status: self.status,
                error_message: self.error_message,
                statistics: self.statistics,
                graph: self.graph,
                starting_event_batch_condition: self.starting_event_batch_condition,
            }
        }
    }
}
impl WorkflowRun {
    /// Creates a new builder-style object to manufacture [`WorkflowRun`](crate::model::WorkflowRun).
    pub fn builder() -> crate::model::workflow_run::Builder {
        crate::model::workflow_run::Builder::default()
    }
}

/// <p>The batch condition that started the workflow run. Either the number of events in the batch size arrived, in which case the BatchSize member is non-zero, or the batch window expired, in which case the BatchWindow member is non-zero.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct StartingEventBatchCondition {
    /// <p>Number of events in the batch.</p>
    #[doc(hidden)]
    pub batch_size: std::option::Option<i32>,
    /// <p>Duration of the batch window in seconds.</p>
    #[doc(hidden)]
    pub batch_window: std::option::Option<i32>,
}
impl StartingEventBatchCondition {
    /// <p>Number of events in the batch.</p>
    pub fn batch_size(&self) -> std::option::Option<i32> {
        self.batch_size
    }
    /// <p>Duration of the batch window in seconds.</p>
    pub fn batch_window(&self) -> std::option::Option<i32> {
        self.batch_window
    }
}
/// See [`StartingEventBatchCondition`](crate::model::StartingEventBatchCondition).
pub mod starting_event_batch_condition {

    /// A builder for [`StartingEventBatchCondition`](crate::model::StartingEventBatchCondition).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) batch_size: std::option::Option<i32>,
        pub(crate) batch_window: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>Number of events in the batch.</p>
        pub fn batch_size(mut self, input: i32) -> Self {
            self.batch_size = Some(input);
            self
        }
        /// <p>Number of events in the batch.</p>
        pub fn set_batch_size(mut self, input: std::option::Option<i32>) -> Self {
            self.batch_size = input;
            self
        }
        /// <p>Duration of the batch window in seconds.</p>
        pub fn batch_window(mut self, input: i32) -> Self {
            self.batch_window = Some(input);
            self
        }
        /// <p>Duration of the batch window in seconds.</p>
        pub fn set_batch_window(mut self, input: std::option::Option<i32>) -> Self {
            self.batch_window = input;
            self
        }
        /// Consumes the builder and constructs a [`StartingEventBatchCondition`](crate::model::StartingEventBatchCondition).
        pub fn build(self) -> crate::model::StartingEventBatchCondition {
            crate::model::StartingEventBatchCondition {
                batch_size: self.batch_size,
                batch_window: self.batch_window,
            }
        }
    }
}
impl StartingEventBatchCondition {
    /// Creates a new builder-style object to manufacture [`StartingEventBatchCondition`](crate::model::StartingEventBatchCondition).
    pub fn builder() -> crate::model::starting_event_batch_condition::Builder {
        crate::model::starting_event_batch_condition::Builder::default()
    }
}

/// <p>A workflow graph represents the complete workflow containing all the Glue components present in the workflow and all the directed connections between them.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct WorkflowGraph {
    /// <p>A list of the the Glue components belong to the workflow represented as nodes.</p>
    #[doc(hidden)]
    pub nodes: std::option::Option<std::vec::Vec<crate::model::Node>>,
    /// <p>A list of all the directed connections between the nodes belonging to the workflow.</p>
    #[doc(hidden)]
    pub edges: std::option::Option<std::vec::Vec<crate::model::Edge>>,
}
impl WorkflowGraph {
    /// <p>A list of the the Glue components belong to the workflow represented as nodes.</p>
    pub fn nodes(&self) -> std::option::Option<&[crate::model::Node]> {
        self.nodes.as_deref()
    }
    /// <p>A list of all the directed connections between the nodes belonging to the workflow.</p>
    pub fn edges(&self) -> std::option::Option<&[crate::model::Edge]> {
        self.edges.as_deref()
    }
}
/// See [`WorkflowGraph`](crate::model::WorkflowGraph).
pub mod workflow_graph {

    /// A builder for [`WorkflowGraph`](crate::model::WorkflowGraph).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) nodes: std::option::Option<std::vec::Vec<crate::model::Node>>,
        pub(crate) edges: std::option::Option<std::vec::Vec<crate::model::Edge>>,
    }
    impl Builder {
        /// Appends an item to `nodes`.
        ///
        /// To override the contents of this collection use [`set_nodes`](Self::set_nodes).
        ///
        /// <p>A list of the the Glue components belong to the workflow represented as nodes.</p>
        pub fn nodes(mut self, input: crate::model::Node) -> Self {
            let mut v = self.nodes.unwrap_or_default();
            v.push(input);
            self.nodes = Some(v);
            self
        }
        /// <p>A list of the the Glue components belong to the workflow represented as nodes.</p>
        pub fn set_nodes(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Node>>,
        ) -> Self {
            self.nodes = input;
            self
        }
        /// Appends an item to `edges`.
        ///
        /// To override the contents of this collection use [`set_edges`](Self::set_edges).
        ///
        /// <p>A list of all the directed connections between the nodes belonging to the workflow.</p>
        pub fn edges(mut self, input: crate::model::Edge) -> Self {
            let mut v = self.edges.unwrap_or_default();
            v.push(input);
            self.edges = Some(v);
            self
        }
        /// <p>A list of all the directed connections between the nodes belonging to the workflow.</p>
        pub fn set_edges(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Edge>>,
        ) -> Self {
            self.edges = input;
            self
        }
        /// Consumes the builder and constructs a [`WorkflowGraph`](crate::model::WorkflowGraph).
        pub fn build(self) -> crate::model::WorkflowGraph {
            crate::model::WorkflowGraph {
                nodes: self.nodes,
                edges: self.edges,
            }
        }
    }
}
impl WorkflowGraph {
    /// Creates a new builder-style object to manufacture [`WorkflowGraph`](crate::model::WorkflowGraph).
    pub fn builder() -> crate::model::workflow_graph::Builder {
        crate::model::workflow_graph::Builder::default()
    }
}

/// <p>An edge represents a directed connection between two Glue components that are part of the workflow the edge belongs to.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Edge {
    /// <p>The unique of the node within the workflow where the edge starts.</p>
    #[doc(hidden)]
    pub source_id: std::option::Option<std::string::String>,
    /// <p>The unique of the node within the workflow where the edge ends.</p>
    #[doc(hidden)]
    pub destination_id: std::option::Option<std::string::String>,
}
impl Edge {
    /// <p>The unique of the node within the workflow where the edge starts.</p>
    pub fn source_id(&self) -> std::option::Option<&str> {
        self.source_id.as_deref()
    }
    /// <p>The unique of the node within the workflow where the edge ends.</p>
    pub fn destination_id(&self) -> std::option::Option<&str> {
        self.destination_id.as_deref()
    }
}
/// See [`Edge`](crate::model::Edge).
pub mod edge {

    /// A builder for [`Edge`](crate::model::Edge).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) source_id: std::option::Option<std::string::String>,
        pub(crate) destination_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique of the node within the workflow where the edge starts.</p>
        pub fn source_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_id = Some(input.into());
            self
        }
        /// <p>The unique of the node within the workflow where the edge starts.</p>
        pub fn set_source_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.source_id = input;
            self
        }
        /// <p>The unique of the node within the workflow where the edge ends.</p>
        pub fn destination_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.destination_id = Some(input.into());
            self
        }
        /// <p>The unique of the node within the workflow where the edge ends.</p>
        pub fn set_destination_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.destination_id = input;
            self
        }
        /// Consumes the builder and constructs a [`Edge`](crate::model::Edge).
        pub fn build(self) -> crate::model::Edge {
            crate::model::Edge {
                source_id: self.source_id,
                destination_id: self.destination_id,
            }
        }
    }
}
impl Edge {
    /// Creates a new builder-style object to manufacture [`Edge`](crate::model::Edge).
    pub fn builder() -> crate::model::edge::Builder {
        crate::model::edge::Builder::default()
    }
}

/// <p>A node represents an Glue component (trigger, crawler, or job) on a workflow graph.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Node {
    /// <p>The type of Glue component represented by the node.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::NodeType>,
    /// <p>The name of the Glue component represented by the node.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The unique Id assigned to the node within the workflow.</p>
    #[doc(hidden)]
    pub unique_id: std::option::Option<std::string::String>,
    /// <p>Details of the Trigger when the node represents a Trigger.</p>
    #[doc(hidden)]
    pub trigger_details: std::option::Option<crate::model::TriggerNodeDetails>,
    /// <p>Details of the Job when the node represents a Job.</p>
    #[doc(hidden)]
    pub job_details: std::option::Option<crate::model::JobNodeDetails>,
    /// <p>Details of the crawler when the node represents a crawler.</p>
    #[doc(hidden)]
    pub crawler_details: std::option::Option<crate::model::CrawlerNodeDetails>,
}
impl Node {
    /// <p>The type of Glue component represented by the node.</p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::NodeType> {
        self.r#type.as_ref()
    }
    /// <p>The name of the Glue component represented by the node.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The unique Id assigned to the node within the workflow.</p>
    pub fn unique_id(&self) -> std::option::Option<&str> {
        self.unique_id.as_deref()
    }
    /// <p>Details of the Trigger when the node represents a Trigger.</p>
    pub fn trigger_details(&self) -> std::option::Option<&crate::model::TriggerNodeDetails> {
        self.trigger_details.as_ref()
    }
    /// <p>Details of the Job when the node represents a Job.</p>
    pub fn job_details(&self) -> std::option::Option<&crate::model::JobNodeDetails> {
        self.job_details.as_ref()
    }
    /// <p>Details of the crawler when the node represents a crawler.</p>
    pub fn crawler_details(&self) -> std::option::Option<&crate::model::CrawlerNodeDetails> {
        self.crawler_details.as_ref()
    }
}
/// See [`Node`](crate::model::Node).
pub mod node {

    /// A builder for [`Node`](crate::model::Node).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<crate::model::NodeType>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) unique_id: std::option::Option<std::string::String>,
        pub(crate) trigger_details: std::option::Option<crate::model::TriggerNodeDetails>,
        pub(crate) job_details: std::option::Option<crate::model::JobNodeDetails>,
        pub(crate) crawler_details: std::option::Option<crate::model::CrawlerNodeDetails>,
    }
    impl Builder {
        /// <p>The type of Glue component represented by the node.</p>
        pub fn r#type(mut self, input: crate::model::NodeType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The type of Glue component represented by the node.</p>
        pub fn set_type(mut self, input: std::option::Option<crate::model::NodeType>) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The name of the Glue component represented by the node.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the Glue component represented by the node.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The unique Id assigned to the node within the workflow.</p>
        pub fn unique_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.unique_id = Some(input.into());
            self
        }
        /// <p>The unique Id assigned to the node within the workflow.</p>
        pub fn set_unique_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.unique_id = input;
            self
        }
        /// <p>Details of the Trigger when the node represents a Trigger.</p>
        pub fn trigger_details(mut self, input: crate::model::TriggerNodeDetails) -> Self {
            self.trigger_details = Some(input);
            self
        }
        /// <p>Details of the Trigger when the node represents a Trigger.</p>
        pub fn set_trigger_details(
            mut self,
            input: std::option::Option<crate::model::TriggerNodeDetails>,
        ) -> Self {
            self.trigger_details = input;
            self
        }
        /// <p>Details of the Job when the node represents a Job.</p>
        pub fn job_details(mut self, input: crate::model::JobNodeDetails) -> Self {
            self.job_details = Some(input);
            self
        }
        /// <p>Details of the Job when the node represents a Job.</p>
        pub fn set_job_details(
            mut self,
            input: std::option::Option<crate::model::JobNodeDetails>,
        ) -> Self {
            self.job_details = input;
            self
        }
        /// <p>Details of the crawler when the node represents a crawler.</p>
        pub fn crawler_details(mut self, input: crate::model::CrawlerNodeDetails) -> Self {
            self.crawler_details = Some(input);
            self
        }
        /// <p>Details of the crawler when the node represents a crawler.</p>
        pub fn set_crawler_details(
            mut self,
            input: std::option::Option<crate::model::CrawlerNodeDetails>,
        ) -> Self {
            self.crawler_details = input;
            self
        }
        /// Consumes the builder and constructs a [`Node`](crate::model::Node).
        pub fn build(self) -> crate::model::Node {
            crate::model::Node {
                r#type: self.r#type,
                name: self.name,
                unique_id: self.unique_id,
                trigger_details: self.trigger_details,
                job_details: self.job_details,
                crawler_details: self.crawler_details,
            }
        }
    }
}
impl Node {
    /// Creates a new builder-style object to manufacture [`Node`](crate::model::Node).
    pub fn builder() -> crate::model::node::Builder {
        crate::model::node::Builder::default()
    }
}

/// <p>The details of a Crawler node present in the workflow.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CrawlerNodeDetails {
    /// <p>A list of crawls represented by the crawl node.</p>
    #[doc(hidden)]
    pub crawls: std::option::Option<std::vec::Vec<crate::model::Crawl>>,
}
impl CrawlerNodeDetails {
    /// <p>A list of crawls represented by the crawl node.</p>
    pub fn crawls(&self) -> std::option::Option<&[crate::model::Crawl]> {
        self.crawls.as_deref()
    }
}
/// See [`CrawlerNodeDetails`](crate::model::CrawlerNodeDetails).
pub mod crawler_node_details {

    /// A builder for [`CrawlerNodeDetails`](crate::model::CrawlerNodeDetails).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) crawls: std::option::Option<std::vec::Vec<crate::model::Crawl>>,
    }
    impl Builder {
        /// Appends an item to `crawls`.
        ///
        /// To override the contents of this collection use [`set_crawls`](Self::set_crawls).
        ///
        /// <p>A list of crawls represented by the crawl node.</p>
        pub fn crawls(mut self, input: crate::model::Crawl) -> Self {
            let mut v = self.crawls.unwrap_or_default();
            v.push(input);
            self.crawls = Some(v);
            self
        }
        /// <p>A list of crawls represented by the crawl node.</p>
        pub fn set_crawls(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Crawl>>,
        ) -> Self {
            self.crawls = input;
            self
        }
        /// Consumes the builder and constructs a [`CrawlerNodeDetails`](crate::model::CrawlerNodeDetails).
        pub fn build(self) -> crate::model::CrawlerNodeDetails {
            crate::model::CrawlerNodeDetails {
                crawls: self.crawls,
            }
        }
    }
}
impl CrawlerNodeDetails {
    /// Creates a new builder-style object to manufacture [`CrawlerNodeDetails`](crate::model::CrawlerNodeDetails).
    pub fn builder() -> crate::model::crawler_node_details::Builder {
        crate::model::crawler_node_details::Builder::default()
    }
}

/// <p>The details of a crawl in the workflow.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Crawl {
    /// <p>The state of the crawler.</p>
    #[doc(hidden)]
    pub state: std::option::Option<crate::model::CrawlState>,
    /// <p>The date and time on which the crawl started.</p>
    #[doc(hidden)]
    pub started_on: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The date and time on which the crawl completed.</p>
    #[doc(hidden)]
    pub completed_on: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The error message associated with the crawl.</p>
    #[doc(hidden)]
    pub error_message: std::option::Option<std::string::String>,
    /// <p>The log group associated with the crawl.</p>
    #[doc(hidden)]
    pub log_group: std::option::Option<std::string::String>,
    /// <p>The log stream associated with the crawl.</p>
    #[doc(hidden)]
    pub log_stream: std::option::Option<std::string::String>,
}
impl Crawl {
    /// <p>The state of the crawler.</p>
    pub fn state(&self) -> std::option::Option<&crate::model::CrawlState> {
        self.state.as_ref()
    }
    /// <p>The date and time on which the crawl started.</p>
    pub fn started_on(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.started_on.as_ref()
    }
    /// <p>The date and time on which the crawl completed.</p>
    pub fn completed_on(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.completed_on.as_ref()
    }
    /// <p>The error message associated with the crawl.</p>
    pub fn error_message(&self) -> std::option::Option<&str> {
        self.error_message.as_deref()
    }
    /// <p>The log group associated with the crawl.</p>
    pub fn log_group(&self) -> std::option::Option<&str> {
        self.log_group.as_deref()
    }
    /// <p>The log stream associated with the crawl.</p>
    pub fn log_stream(&self) -> std::option::Option<&str> {
        self.log_stream.as_deref()
    }
}
/// See [`Crawl`](crate::model::Crawl).
pub mod crawl {

    /// A builder for [`Crawl`](crate::model::Crawl).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) state: std::option::Option<crate::model::CrawlState>,
        pub(crate) started_on: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) completed_on: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) error_message: std::option::Option<std::string::String>,
        pub(crate) log_group: std::option::Option<std::string::String>,
        pub(crate) log_stream: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The state of the crawler.</p>
        pub fn state(mut self, input: crate::model::CrawlState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The state of the crawler.</p>
        pub fn set_state(mut self, input: std::option::Option<crate::model::CrawlState>) -> Self {
            self.state = input;
            self
        }
        /// <p>The date and time on which the crawl started.</p>
        pub fn started_on(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.started_on = Some(input);
            self
        }
        /// <p>The date and time on which the crawl started.</p>
        pub fn set_started_on(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.started_on = input;
            self
        }
        /// <p>The date and time on which the crawl completed.</p>
        pub fn completed_on(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.completed_on = Some(input);
            self
        }
        /// <p>The date and time on which the crawl completed.</p>
        pub fn set_completed_on(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.completed_on = input;
            self
        }
        /// <p>The error message associated with the crawl.</p>
        pub fn error_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_message = Some(input.into());
            self
        }
        /// <p>The error message associated with the crawl.</p>
        pub fn set_error_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.error_message = input;
            self
        }
        /// <p>The log group associated with the crawl.</p>
        pub fn log_group(mut self, input: impl Into<std::string::String>) -> Self {
            self.log_group = Some(input.into());
            self
        }
        /// <p>The log group associated with the crawl.</p>
        pub fn set_log_group(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.log_group = input;
            self
        }
        /// <p>The log stream associated with the crawl.</p>
        pub fn log_stream(mut self, input: impl Into<std::string::String>) -> Self {
            self.log_stream = Some(input.into());
            self
        }
        /// <p>The log stream associated with the crawl.</p>
        pub fn set_log_stream(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.log_stream = input;
            self
        }
        /// Consumes the builder and constructs a [`Crawl`](crate::model::Crawl).
        pub fn build(self) -> crate::model::Crawl {
            crate::model::Crawl {
                state: self.state,
                started_on: self.started_on,
                completed_on: self.completed_on,
                error_message: self.error_message,
                log_group: self.log_group,
                log_stream: self.log_stream,
            }
        }
    }
}
impl Crawl {
    /// Creates a new builder-style object to manufacture [`Crawl`](crate::model::Crawl).
    pub fn builder() -> crate::model::crawl::Builder {
        crate::model::crawl::Builder::default()
    }
}

/// <p>The details of a Job node present in the workflow.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct JobNodeDetails {
    /// <p>The information for the job runs represented by the job node.</p>
    #[doc(hidden)]
    pub job_runs: std::option::Option<std::vec::Vec<crate::model::JobRun>>,
}
impl JobNodeDetails {
    /// <p>The information for the job runs represented by the job node.</p>
    pub fn job_runs(&self) -> std::option::Option<&[crate::model::JobRun]> {
        self.job_runs.as_deref()
    }
}
/// See [`JobNodeDetails`](crate::model::JobNodeDetails).
pub mod job_node_details {

    /// A builder for [`JobNodeDetails`](crate::model::JobNodeDetails).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) job_runs: std::option::Option<std::vec::Vec<crate::model::JobRun>>,
    }
    impl Builder {
        /// Appends an item to `job_runs`.
        ///
        /// To override the contents of this collection use [`set_job_runs`](Self::set_job_runs).
        ///
        /// <p>The information for the job runs represented by the job node.</p>
        pub fn job_runs(mut self, input: crate::model::JobRun) -> Self {
            let mut v = self.job_runs.unwrap_or_default();
            v.push(input);
            self.job_runs = Some(v);
            self
        }
        /// <p>The information for the job runs represented by the job node.</p>
        pub fn set_job_runs(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::JobRun>>,
        ) -> Self {
            self.job_runs = input;
            self
        }
        /// Consumes the builder and constructs a [`JobNodeDetails`](crate::model::JobNodeDetails).
        pub fn build(self) -> crate::model::JobNodeDetails {
            crate::model::JobNodeDetails {
                job_runs: self.job_runs,
            }
        }
    }
}
impl JobNodeDetails {
    /// Creates a new builder-style object to manufacture [`JobNodeDetails`](crate::model::JobNodeDetails).
    pub fn builder() -> crate::model::job_node_details::Builder {
        crate::model::job_node_details::Builder::default()
    }
}

/// <p>Contains information about a job run.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct JobRun {
    /// <p>The ID of this job run.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The number of the attempt to run this job.</p>
    #[doc(hidden)]
    pub attempt: i32,
    /// <p>The ID of the previous run of this job. For example, the <code>JobRunId</code> specified in the <code>StartJobRun</code> action.</p>
    #[doc(hidden)]
    pub previous_run_id: std::option::Option<std::string::String>,
    /// <p>The name of the trigger that started this job run.</p>
    #[doc(hidden)]
    pub trigger_name: std::option::Option<std::string::String>,
    /// <p>The name of the job definition being used in this run.</p>
    #[doc(hidden)]
    pub job_name: std::option::Option<std::string::String>,
    /// <p>The date and time at which this job run was started.</p>
    #[doc(hidden)]
    pub started_on: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The last time that this job run was modified.</p>
    #[doc(hidden)]
    pub last_modified_on: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The date and time that this job run completed.</p>
    #[doc(hidden)]
    pub completed_on: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The current state of the job run. For more information about the statuses of jobs that have terminated abnormally, see <a href="https://docs.aws.amazon.com/glue/latest/dg/job-run-statuses.html">Glue Job Run Statuses</a>.</p>
    #[doc(hidden)]
    pub job_run_state: std::option::Option<crate::model::JobRunState>,
    /// <p>The job arguments associated with this run. For this job run, they replace the default arguments set in the job definition itself.</p>
    /// <p>You can specify arguments here that your own job-execution script consumes, as well as arguments that Glue itself consumes.</p>
    /// <p>For information about how to specify and consume your own job arguments, see the <a href="https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-python-calling.html">Calling Glue APIs in Python</a> topic in the developer guide.</p>
    /// <p>For information about the key-value pairs that Glue consumes to set up your job, see the <a href="https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-etl-glue-arguments.html">Special Parameters Used by Glue</a> topic in the developer guide.</p>
    #[doc(hidden)]
    pub arguments:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>An error message associated with this job run.</p>
    #[doc(hidden)]
    pub error_message: std::option::Option<std::string::String>,
    /// <p>A list of predecessors to this job run.</p>
    #[doc(hidden)]
    pub predecessor_runs: std::option::Option<std::vec::Vec<crate::model::Predecessor>>,
    /// <p>This field is deprecated. Use <code>MaxCapacity</code> instead.</p>
    /// <p>The number of Glue data processing units (DPUs) allocated to this JobRun. From 2 to 100 DPUs can be allocated; the default is 10. A DPU is a relative measure of processing power that consists of 4 vCPUs of compute capacity and 16 GB of memory. For more information, see the <a href="https://aws.amazon.com/glue/pricing/">Glue pricing page</a>.</p>
    #[deprecated(note = "This property is deprecated, use MaxCapacity instead.")]
    #[doc(hidden)]
    pub allocated_capacity: i32,
    /// <p>The amount of time (in seconds) that the job run consumed resources.</p>
    #[doc(hidden)]
    pub execution_time: i32,
    /// <p>The <code>JobRun</code> timeout in minutes. This is the maximum time that a job run can consume resources before it is terminated and enters <code>TIMEOUT</code> status. This value overrides the timeout value set in the parent job.</p>
    /// <p>Streaming jobs do not have a timeout. The default for non-streaming jobs is 2,880 minutes (48 hours).</p>
    #[doc(hidden)]
    pub timeout: std::option::Option<i32>,
    /// <p>The number of Glue data processing units (DPUs) that can be allocated when this job runs. A DPU is a relative measure of processing power that consists of 4 vCPUs of compute capacity and 16 GB of memory. For more information, see the <a href="https://aws.amazon.com/glue/pricing/">Glue pricing page</a>.</p>
    /// <p>Do not set <code>Max Capacity</code> if using <code>WorkerType</code> and <code>NumberOfWorkers</code>.</p>
    /// <p>The value that can be allocated for <code>MaxCapacity</code> depends on whether you are running a Python shell job or an Apache Spark ETL job:</p>
    /// <ul>
    /// <li> <p>When you specify a Python shell job (<code>JobCommand.Name</code>="pythonshell"), you can allocate either 0.0625 or 1 DPU. The default is 0.0625 DPU.</p> </li>
    /// <li> <p>When you specify an Apache Spark ETL job (<code>JobCommand.Name</code>="glueetl"), you can allocate a minimum of 2 DPUs. The default is 10 DPUs. This job type cannot have a fractional DPU allocation.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub max_capacity: std::option::Option<f64>,
    /// <p>The type of predefined worker that is allocated when a job runs. Accepts a value of Standard, G.1X, G.2X, or G.025X.</p>
    /// <ul>
    /// <li> <p>For the <code>Standard</code> worker type, each worker provides 4 vCPU, 16 GB of memory and a 50GB disk, and 2 executors per worker.</p> </li>
    /// <li> <p>For the <code>G.1X</code> worker type, each worker provides 4 vCPU, 16 GB of memory and a 64GB disk, and 1 executor per worker.</p> </li>
    /// <li> <p>For the <code>G.2X</code> worker type, each worker provides 8 vCPU, 32 GB of memory and a 128GB disk, and 1 executor per worker.</p> </li>
    /// <li> <p>For the <code>G.025X</code> worker type, each worker maps to 0.25 DPU (2 vCPU, 4 GB of memory, 64 GB disk), and provides 1 executor per worker. We recommend this worker type for low volume streaming jobs. This worker type is only available for Glue version 3.0 streaming jobs.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub worker_type: std::option::Option<crate::model::WorkerType>,
    /// <p>The number of workers of a defined <code>workerType</code> that are allocated when a job runs.</p>
    #[doc(hidden)]
    pub number_of_workers: std::option::Option<i32>,
    /// <p>The name of the <code>SecurityConfiguration</code> structure to be used with this job run.</p>
    #[doc(hidden)]
    pub security_configuration: std::option::Option<std::string::String>,
    /// <p>The name of the log group for secure logging that can be server-side encrypted in Amazon CloudWatch using KMS. This name can be <code>/aws-glue/jobs/</code>, in which case the default encryption is <code>NONE</code>. If you add a role name and <code>SecurityConfiguration</code> name (in other words, <code>/aws-glue/jobs-yourRoleName-yourSecurityConfigurationName/</code>), then that security configuration is used to encrypt the log group.</p>
    #[doc(hidden)]
    pub log_group_name: std::option::Option<std::string::String>,
    /// <p>Specifies configuration properties of a job run notification.</p>
    #[doc(hidden)]
    pub notification_property: std::option::Option<crate::model::NotificationProperty>,
    /// <p>Glue version determines the versions of Apache Spark and Python that Glue supports. The Python version indicates the version supported for jobs of type Spark. </p>
    /// <p>For more information about the available Glue versions and corresponding Spark and Python versions, see <a href="https://docs.aws.amazon.com/glue/latest/dg/add-job.html">Glue version</a> in the developer guide.</p>
    /// <p>Jobs that are created without specifying a Glue version default to Glue 0.9.</p>
    #[doc(hidden)]
    pub glue_version: std::option::Option<std::string::String>,
    /// <p>This field populates only for Auto Scaling job runs, and represents the total time each executor ran during the lifecycle of a job run in seconds, multiplied by a DPU factor (1 for <code>G.1X</code>, 2 for <code>G.2X</code>, or 0.25 for <code>G.025X</code> workers). This value may be different than the <code>executionEngineRuntime</code> * <code>MaxCapacity</code> as in the case of Auto Scaling jobs, as the number of executors running at a given time may be less than the <code>MaxCapacity</code>. Therefore, it is possible that the value of <code>DPUSeconds</code> is less than <code>executionEngineRuntime</code> * <code>MaxCapacity</code>.</p>
    #[doc(hidden)]
    pub dpu_seconds: std::option::Option<f64>,
    /// <p>Indicates whether the job is run with a standard or flexible execution class. The standard execution-class is ideal for time-sensitive workloads that require fast job startup and dedicated resources.</p>
    /// <p>The flexible execution class is appropriate for time-insensitive jobs whose start and completion times may vary. </p>
    /// <p>Only jobs with Glue version 3.0 and above and command type <code>glueetl</code> will be allowed to set <code>ExecutionClass</code> to <code>FLEX</code>. The flexible execution class is available for Spark jobs.</p>
    #[doc(hidden)]
    pub execution_class: std::option::Option<crate::model::ExecutionClass>,
}
impl JobRun {
    /// <p>The ID of this job run.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The number of the attempt to run this job.</p>
    pub fn attempt(&self) -> i32 {
        self.attempt
    }
    /// <p>The ID of the previous run of this job. For example, the <code>JobRunId</code> specified in the <code>StartJobRun</code> action.</p>
    pub fn previous_run_id(&self) -> std::option::Option<&str> {
        self.previous_run_id.as_deref()
    }
    /// <p>The name of the trigger that started this job run.</p>
    pub fn trigger_name(&self) -> std::option::Option<&str> {
        self.trigger_name.as_deref()
    }
    /// <p>The name of the job definition being used in this run.</p>
    pub fn job_name(&self) -> std::option::Option<&str> {
        self.job_name.as_deref()
    }
    /// <p>The date and time at which this job run was started.</p>
    pub fn started_on(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.started_on.as_ref()
    }
    /// <p>The last time that this job run was modified.</p>
    pub fn last_modified_on(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_modified_on.as_ref()
    }
    /// <p>The date and time that this job run completed.</p>
    pub fn completed_on(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.completed_on.as_ref()
    }
    /// <p>The current state of the job run. For more information about the statuses of jobs that have terminated abnormally, see <a href="https://docs.aws.amazon.com/glue/latest/dg/job-run-statuses.html">Glue Job Run Statuses</a>.</p>
    pub fn job_run_state(&self) -> std::option::Option<&crate::model::JobRunState> {
        self.job_run_state.as_ref()
    }
    /// <p>The job arguments associated with this run. For this job run, they replace the default arguments set in the job definition itself.</p>
    /// <p>You can specify arguments here that your own job-execution script consumes, as well as arguments that Glue itself consumes.</p>
    /// <p>For information about how to specify and consume your own job arguments, see the <a href="https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-python-calling.html">Calling Glue APIs in Python</a> topic in the developer guide.</p>
    /// <p>For information about the key-value pairs that Glue consumes to set up your job, see the <a href="https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-etl-glue-arguments.html">Special Parameters Used by Glue</a> topic in the developer guide.</p>
    pub fn arguments(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.arguments.as_ref()
    }
    /// <p>An error message associated with this job run.</p>
    pub fn error_message(&self) -> std::option::Option<&str> {
        self.error_message.as_deref()
    }
    /// <p>A list of predecessors to this job run.</p>
    pub fn predecessor_runs(&self) -> std::option::Option<&[crate::model::Predecessor]> {
        self.predecessor_runs.as_deref()
    }
    /// <p>This field is deprecated. Use <code>MaxCapacity</code> instead.</p>
    /// <p>The number of Glue data processing units (DPUs) allocated to this JobRun. From 2 to 100 DPUs can be allocated; the default is 10. A DPU is a relative measure of processing power that consists of 4 vCPUs of compute capacity and 16 GB of memory. For more information, see the <a href="https://aws.amazon.com/glue/pricing/">Glue pricing page</a>.</p>
    #[deprecated(note = "This property is deprecated, use MaxCapacity instead.")]
    pub fn allocated_capacity(&self) -> i32 {
        self.allocated_capacity
    }
    /// <p>The amount of time (in seconds) that the job run consumed resources.</p>
    pub fn execution_time(&self) -> i32 {
        self.execution_time
    }
    /// <p>The <code>JobRun</code> timeout in minutes. This is the maximum time that a job run can consume resources before it is terminated and enters <code>TIMEOUT</code> status. This value overrides the timeout value set in the parent job.</p>
    /// <p>Streaming jobs do not have a timeout. The default for non-streaming jobs is 2,880 minutes (48 hours).</p>
    pub fn timeout(&self) -> std::option::Option<i32> {
        self.timeout
    }
    /// <p>The number of Glue data processing units (DPUs) that can be allocated when this job runs. A DPU is a relative measure of processing power that consists of 4 vCPUs of compute capacity and 16 GB of memory. For more information, see the <a href="https://aws.amazon.com/glue/pricing/">Glue pricing page</a>.</p>
    /// <p>Do not set <code>Max Capacity</code> if using <code>WorkerType</code> and <code>NumberOfWorkers</code>.</p>
    /// <p>The value that can be allocated for <code>MaxCapacity</code> depends on whether you are running a Python shell job or an Apache Spark ETL job:</p>
    /// <ul>
    /// <li> <p>When you specify a Python shell job (<code>JobCommand.Name</code>="pythonshell"), you can allocate either 0.0625 or 1 DPU. The default is 0.0625 DPU.</p> </li>
    /// <li> <p>When you specify an Apache Spark ETL job (<code>JobCommand.Name</code>="glueetl"), you can allocate a minimum of 2 DPUs. The default is 10 DPUs. This job type cannot have a fractional DPU allocation.</p> </li>
    /// </ul>
    pub fn max_capacity(&self) -> std::option::Option<f64> {
        self.max_capacity
    }
    /// <p>The type of predefined worker that is allocated when a job runs. Accepts a value of Standard, G.1X, G.2X, or G.025X.</p>
    /// <ul>
    /// <li> <p>For the <code>Standard</code> worker type, each worker provides 4 vCPU, 16 GB of memory and a 50GB disk, and 2 executors per worker.</p> </li>
    /// <li> <p>For the <code>G.1X</code> worker type, each worker provides 4 vCPU, 16 GB of memory and a 64GB disk, and 1 executor per worker.</p> </li>
    /// <li> <p>For the <code>G.2X</code> worker type, each worker provides 8 vCPU, 32 GB of memory and a 128GB disk, and 1 executor per worker.</p> </li>
    /// <li> <p>For the <code>G.025X</code> worker type, each worker maps to 0.25 DPU (2 vCPU, 4 GB of memory, 64 GB disk), and provides 1 executor per worker. We recommend this worker type for low volume streaming jobs. This worker type is only available for Glue version 3.0 streaming jobs.</p> </li>
    /// </ul>
    pub fn worker_type(&self) -> std::option::Option<&crate::model::WorkerType> {
        self.worker_type.as_ref()
    }
    /// <p>The number of workers of a defined <code>workerType</code> that are allocated when a job runs.</p>
    pub fn number_of_workers(&self) -> std::option::Option<i32> {
        self.number_of_workers
    }
    /// <p>The name of the <code>SecurityConfiguration</code> structure to be used with this job run.</p>
    pub fn security_configuration(&self) -> std::option::Option<&str> {
        self.security_configuration.as_deref()
    }
    /// <p>The name of the log group for secure logging that can be server-side encrypted in Amazon CloudWatch using KMS. This name can be <code>/aws-glue/jobs/</code>, in which case the default encryption is <code>NONE</code>. If you add a role name and <code>SecurityConfiguration</code> name (in other words, <code>/aws-glue/jobs-yourRoleName-yourSecurityConfigurationName/</code>), then that security configuration is used to encrypt the log group.</p>
    pub fn log_group_name(&self) -> std::option::Option<&str> {
        self.log_group_name.as_deref()
    }
    /// <p>Specifies configuration properties of a job run notification.</p>
    pub fn notification_property(
        &self,
    ) -> std::option::Option<&crate::model::NotificationProperty> {
        self.notification_property.as_ref()
    }
    /// <p>Glue version determines the versions of Apache Spark and Python that Glue supports. The Python version indicates the version supported for jobs of type Spark. </p>
    /// <p>For more information about the available Glue versions and corresponding Spark and Python versions, see <a href="https://docs.aws.amazon.com/glue/latest/dg/add-job.html">Glue version</a> in the developer guide.</p>
    /// <p>Jobs that are created without specifying a Glue version default to Glue 0.9.</p>
    pub fn glue_version(&self) -> std::option::Option<&str> {
        self.glue_version.as_deref()
    }
    /// <p>This field populates only for Auto Scaling job runs, and represents the total time each executor ran during the lifecycle of a job run in seconds, multiplied by a DPU factor (1 for <code>G.1X</code>, 2 for <code>G.2X</code>, or 0.25 for <code>G.025X</code> workers). This value may be different than the <code>executionEngineRuntime</code> * <code>MaxCapacity</code> as in the case of Auto Scaling jobs, as the number of executors running at a given time may be less than the <code>MaxCapacity</code>. Therefore, it is possible that the value of <code>DPUSeconds</code> is less than <code>executionEngineRuntime</code> * <code>MaxCapacity</code>.</p>
    pub fn dpu_seconds(&self) -> std::option::Option<f64> {
        self.dpu_seconds
    }
    /// <p>Indicates whether the job is run with a standard or flexible execution class. The standard execution-class is ideal for time-sensitive workloads that require fast job startup and dedicated resources.</p>
    /// <p>The flexible execution class is appropriate for time-insensitive jobs whose start and completion times may vary. </p>
    /// <p>Only jobs with Glue version 3.0 and above and command type <code>glueetl</code> will be allowed to set <code>ExecutionClass</code> to <code>FLEX</code>. The flexible execution class is available for Spark jobs.</p>
    pub fn execution_class(&self) -> std::option::Option<&crate::model::ExecutionClass> {
        self.execution_class.as_ref()
    }
}
/// See [`JobRun`](crate::model::JobRun).
pub mod job_run {

    /// A builder for [`JobRun`](crate::model::JobRun).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) attempt: std::option::Option<i32>,
        pub(crate) previous_run_id: std::option::Option<std::string::String>,
        pub(crate) trigger_name: std::option::Option<std::string::String>,
        pub(crate) job_name: std::option::Option<std::string::String>,
        pub(crate) started_on: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_modified_on: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) completed_on: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) job_run_state: std::option::Option<crate::model::JobRunState>,
        pub(crate) arguments: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) error_message: std::option::Option<std::string::String>,
        pub(crate) predecessor_runs: std::option::Option<std::vec::Vec<crate::model::Predecessor>>,
        pub(crate) allocated_capacity: std::option::Option<i32>,
        pub(crate) execution_time: std::option::Option<i32>,
        pub(crate) timeout: std::option::Option<i32>,
        pub(crate) max_capacity: std::option::Option<f64>,
        pub(crate) worker_type: std::option::Option<crate::model::WorkerType>,
        pub(crate) number_of_workers: std::option::Option<i32>,
        pub(crate) security_configuration: std::option::Option<std::string::String>,
        pub(crate) log_group_name: std::option::Option<std::string::String>,
        pub(crate) notification_property: std::option::Option<crate::model::NotificationProperty>,
        pub(crate) glue_version: std::option::Option<std::string::String>,
        pub(crate) dpu_seconds: std::option::Option<f64>,
        pub(crate) execution_class: std::option::Option<crate::model::ExecutionClass>,
    }
    impl Builder {
        /// <p>The ID of this job run.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The ID of this job run.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The number of the attempt to run this job.</p>
        pub fn attempt(mut self, input: i32) -> Self {
            self.attempt = Some(input);
            self
        }
        /// <p>The number of the attempt to run this job.</p>
        pub fn set_attempt(mut self, input: std::option::Option<i32>) -> Self {
            self.attempt = input;
            self
        }
        /// <p>The ID of the previous run of this job. For example, the <code>JobRunId</code> specified in the <code>StartJobRun</code> action.</p>
        pub fn previous_run_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.previous_run_id = Some(input.into());
            self
        }
        /// <p>The ID of the previous run of this job. For example, the <code>JobRunId</code> specified in the <code>StartJobRun</code> action.</p>
        pub fn set_previous_run_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.previous_run_id = input;
            self
        }
        /// <p>The name of the trigger that started this job run.</p>
        pub fn trigger_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.trigger_name = Some(input.into());
            self
        }
        /// <p>The name of the trigger that started this job run.</p>
        pub fn set_trigger_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.trigger_name = input;
            self
        }
        /// <p>The name of the job definition being used in this run.</p>
        pub fn job_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_name = Some(input.into());
            self
        }
        /// <p>The name of the job definition being used in this run.</p>
        pub fn set_job_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_name = input;
            self
        }
        /// <p>The date and time at which this job run was started.</p>
        pub fn started_on(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.started_on = Some(input);
            self
        }
        /// <p>The date and time at which this job run was started.</p>
        pub fn set_started_on(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.started_on = input;
            self
        }
        /// <p>The last time that this job run was modified.</p>
        pub fn last_modified_on(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_modified_on = Some(input);
            self
        }
        /// <p>The last time that this job run was modified.</p>
        pub fn set_last_modified_on(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_modified_on = input;
            self
        }
        /// <p>The date and time that this job run completed.</p>
        pub fn completed_on(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.completed_on = Some(input);
            self
        }
        /// <p>The date and time that this job run completed.</p>
        pub fn set_completed_on(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.completed_on = input;
            self
        }
        /// <p>The current state of the job run. For more information about the statuses of jobs that have terminated abnormally, see <a href="https://docs.aws.amazon.com/glue/latest/dg/job-run-statuses.html">Glue Job Run Statuses</a>.</p>
        pub fn job_run_state(mut self, input: crate::model::JobRunState) -> Self {
            self.job_run_state = Some(input);
            self
        }
        /// <p>The current state of the job run. For more information about the statuses of jobs that have terminated abnormally, see <a href="https://docs.aws.amazon.com/glue/latest/dg/job-run-statuses.html">Glue Job Run Statuses</a>.</p>
        pub fn set_job_run_state(
            mut self,
            input: std::option::Option<crate::model::JobRunState>,
        ) -> Self {
            self.job_run_state = input;
            self
        }
        /// Adds a key-value pair to `arguments`.
        ///
        /// To override the contents of this collection use [`set_arguments`](Self::set_arguments).
        ///
        /// <p>The job arguments associated with this run. For this job run, they replace the default arguments set in the job definition itself.</p>
        /// <p>You can specify arguments here that your own job-execution script consumes, as well as arguments that Glue itself consumes.</p>
        /// <p>For information about how to specify and consume your own job arguments, see the <a href="https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-python-calling.html">Calling Glue APIs in Python</a> topic in the developer guide.</p>
        /// <p>For information about the key-value pairs that Glue consumes to set up your job, see the <a href="https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-etl-glue-arguments.html">Special Parameters Used by Glue</a> topic in the developer guide.</p>
        pub fn arguments(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.arguments.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.arguments = Some(hash_map);
            self
        }
        /// <p>The job arguments associated with this run. For this job run, they replace the default arguments set in the job definition itself.</p>
        /// <p>You can specify arguments here that your own job-execution script consumes, as well as arguments that Glue itself consumes.</p>
        /// <p>For information about how to specify and consume your own job arguments, see the <a href="https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-python-calling.html">Calling Glue APIs in Python</a> topic in the developer guide.</p>
        /// <p>For information about the key-value pairs that Glue consumes to set up your job, see the <a href="https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-etl-glue-arguments.html">Special Parameters Used by Glue</a> topic in the developer guide.</p>
        pub fn set_arguments(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.arguments = input;
            self
        }
        /// <p>An error message associated with this job run.</p>
        pub fn error_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_message = Some(input.into());
            self
        }
        /// <p>An error message associated with this job run.</p>
        pub fn set_error_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.error_message = input;
            self
        }
        /// Appends an item to `predecessor_runs`.
        ///
        /// To override the contents of this collection use [`set_predecessor_runs`](Self::set_predecessor_runs).
        ///
        /// <p>A list of predecessors to this job run.</p>
        pub fn predecessor_runs(mut self, input: crate::model::Predecessor) -> Self {
            let mut v = self.predecessor_runs.unwrap_or_default();
            v.push(input);
            self.predecessor_runs = Some(v);
            self
        }
        /// <p>A list of predecessors to this job run.</p>
        pub fn set_predecessor_runs(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Predecessor>>,
        ) -> Self {
            self.predecessor_runs = input;
            self
        }
        /// <p>This field is deprecated. Use <code>MaxCapacity</code> instead.</p>
        /// <p>The number of Glue data processing units (DPUs) allocated to this JobRun. From 2 to 100 DPUs can be allocated; the default is 10. A DPU is a relative measure of processing power that consists of 4 vCPUs of compute capacity and 16 GB of memory. For more information, see the <a href="https://aws.amazon.com/glue/pricing/">Glue pricing page</a>.</p>
        #[deprecated(note = "This property is deprecated, use MaxCapacity instead.")]
        pub fn allocated_capacity(mut self, input: i32) -> Self {
            self.allocated_capacity = Some(input);
            self
        }
        /// <p>This field is deprecated. Use <code>MaxCapacity</code> instead.</p>
        /// <p>The number of Glue data processing units (DPUs) allocated to this JobRun. From 2 to 100 DPUs can be allocated; the default is 10. A DPU is a relative measure of processing power that consists of 4 vCPUs of compute capacity and 16 GB of memory. For more information, see the <a href="https://aws.amazon.com/glue/pricing/">Glue pricing page</a>.</p>
        #[deprecated(note = "This property is deprecated, use MaxCapacity instead.")]
        pub fn set_allocated_capacity(mut self, input: std::option::Option<i32>) -> Self {
            self.allocated_capacity = input;
            self
        }
        /// <p>The amount of time (in seconds) that the job run consumed resources.</p>
        pub fn execution_time(mut self, input: i32) -> Self {
            self.execution_time = Some(input);
            self
        }
        /// <p>The amount of time (in seconds) that the job run consumed resources.</p>
        pub fn set_execution_time(mut self, input: std::option::Option<i32>) -> Self {
            self.execution_time = input;
            self
        }
        /// <p>The <code>JobRun</code> timeout in minutes. This is the maximum time that a job run can consume resources before it is terminated and enters <code>TIMEOUT</code> status. This value overrides the timeout value set in the parent job.</p>
        /// <p>Streaming jobs do not have a timeout. The default for non-streaming jobs is 2,880 minutes (48 hours).</p>
        pub fn timeout(mut self, input: i32) -> Self {
            self.timeout = Some(input);
            self
        }
        /// <p>The <code>JobRun</code> timeout in minutes. This is the maximum time that a job run can consume resources before it is terminated and enters <code>TIMEOUT</code> status. This value overrides the timeout value set in the parent job.</p>
        /// <p>Streaming jobs do not have a timeout. The default for non-streaming jobs is 2,880 minutes (48 hours).</p>
        pub fn set_timeout(mut self, input: std::option::Option<i32>) -> Self {
            self.timeout = input;
            self
        }
        /// <p>The number of Glue data processing units (DPUs) that can be allocated when this job runs. A DPU is a relative measure of processing power that consists of 4 vCPUs of compute capacity and 16 GB of memory. For more information, see the <a href="https://aws.amazon.com/glue/pricing/">Glue pricing page</a>.</p>
        /// <p>Do not set <code>Max Capacity</code> if using <code>WorkerType</code> and <code>NumberOfWorkers</code>.</p>
        /// <p>The value that can be allocated for <code>MaxCapacity</code> depends on whether you are running a Python shell job or an Apache Spark ETL job:</p>
        /// <ul>
        /// <li> <p>When you specify a Python shell job (<code>JobCommand.Name</code>="pythonshell"), you can allocate either 0.0625 or 1 DPU. The default is 0.0625 DPU.</p> </li>
        /// <li> <p>When you specify an Apache Spark ETL job (<code>JobCommand.Name</code>="glueetl"), you can allocate a minimum of 2 DPUs. The default is 10 DPUs. This job type cannot have a fractional DPU allocation.</p> </li>
        /// </ul>
        pub fn max_capacity(mut self, input: f64) -> Self {
            self.max_capacity = Some(input);
            self
        }
        /// <p>The number of Glue data processing units (DPUs) that can be allocated when this job runs. A DPU is a relative measure of processing power that consists of 4 vCPUs of compute capacity and 16 GB of memory. For more information, see the <a href="https://aws.amazon.com/glue/pricing/">Glue pricing page</a>.</p>
        /// <p>Do not set <code>Max Capacity</code> if using <code>WorkerType</code> and <code>NumberOfWorkers</code>.</p>
        /// <p>The value that can be allocated for <code>MaxCapacity</code> depends on whether you are running a Python shell job or an Apache Spark ETL job:</p>
        /// <ul>
        /// <li> <p>When you specify a Python shell job (<code>JobCommand.Name</code>="pythonshell"), you can allocate either 0.0625 or 1 DPU. The default is 0.0625 DPU.</p> </li>
        /// <li> <p>When you specify an Apache Spark ETL job (<code>JobCommand.Name</code>="glueetl"), you can allocate a minimum of 2 DPUs. The default is 10 DPUs. This job type cannot have a fractional DPU allocation.</p> </li>
        /// </ul>
        pub fn set_max_capacity(mut self, input: std::option::Option<f64>) -> Self {
            self.max_capacity = input;
            self
        }
        /// <p>The type of predefined worker that is allocated when a job runs. Accepts a value of Standard, G.1X, G.2X, or G.025X.</p>
        /// <ul>
        /// <li> <p>For the <code>Standard</code> worker type, each worker provides 4 vCPU, 16 GB of memory and a 50GB disk, and 2 executors per worker.</p> </li>
        /// <li> <p>For the <code>G.1X</code> worker type, each worker provides 4 vCPU, 16 GB of memory and a 64GB disk, and 1 executor per worker.</p> </li>
        /// <li> <p>For the <code>G.2X</code> worker type, each worker provides 8 vCPU, 32 GB of memory and a 128GB disk, and 1 executor per worker.</p> </li>
        /// <li> <p>For the <code>G.025X</code> worker type, each worker maps to 0.25 DPU (2 vCPU, 4 GB of memory, 64 GB disk), and provides 1 executor per worker. We recommend this worker type for low volume streaming jobs. This worker type is only available for Glue version 3.0 streaming jobs.</p> </li>
        /// </ul>
        pub fn worker_type(mut self, input: crate::model::WorkerType) -> Self {
            self.worker_type = Some(input);
            self
        }
        /// <p>The type of predefined worker that is allocated when a job runs. Accepts a value of Standard, G.1X, G.2X, or G.025X.</p>
        /// <ul>
        /// <li> <p>For the <code>Standard</code> worker type, each worker provides 4 vCPU, 16 GB of memory and a 50GB disk, and 2 executors per worker.</p> </li>
        /// <li> <p>For the <code>G.1X</code> worker type, each worker provides 4 vCPU, 16 GB of memory and a 64GB disk, and 1 executor per worker.</p> </li>
        /// <li> <p>For the <code>G.2X</code> worker type, each worker provides 8 vCPU, 32 GB of memory and a 128GB disk, and 1 executor per worker.</p> </li>
        /// <li> <p>For the <code>G.025X</code> worker type, each worker maps to 0.25 DPU (2 vCPU, 4 GB of memory, 64 GB disk), and provides 1 executor per worker. We recommend this worker type for low volume streaming jobs. This worker type is only available for Glue version 3.0 streaming jobs.</p> </li>
        /// </ul>
        pub fn set_worker_type(
            mut self,
            input: std::option::Option<crate::model::WorkerType>,
        ) -> Self {
            self.worker_type = input;
            self
        }
        /// <p>The number of workers of a defined <code>workerType</code> that are allocated when a job runs.</p>
        pub fn number_of_workers(mut self, input: i32) -> Self {
            self.number_of_workers = Some(input);
            self
        }
        /// <p>The number of workers of a defined <code>workerType</code> that are allocated when a job runs.</p>
        pub fn set_number_of_workers(mut self, input: std::option::Option<i32>) -> Self {
            self.number_of_workers = input;
            self
        }
        /// <p>The name of the <code>SecurityConfiguration</code> structure to be used with this job run.</p>
        pub fn security_configuration(mut self, input: impl Into<std::string::String>) -> Self {
            self.security_configuration = Some(input.into());
            self
        }
        /// <p>The name of the <code>SecurityConfiguration</code> structure to be used with this job run.</p>
        pub fn set_security_configuration(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.security_configuration = input;
            self
        }
        /// <p>The name of the log group for secure logging that can be server-side encrypted in Amazon CloudWatch using KMS. This name can be <code>/aws-glue/jobs/</code>, in which case the default encryption is <code>NONE</code>. If you add a role name and <code>SecurityConfiguration</code> name (in other words, <code>/aws-glue/jobs-yourRoleName-yourSecurityConfigurationName/</code>), then that security configuration is used to encrypt the log group.</p>
        pub fn log_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.log_group_name = Some(input.into());
            self
        }
        /// <p>The name of the log group for secure logging that can be server-side encrypted in Amazon CloudWatch using KMS. This name can be <code>/aws-glue/jobs/</code>, in which case the default encryption is <code>NONE</code>. If you add a role name and <code>SecurityConfiguration</code> name (in other words, <code>/aws-glue/jobs-yourRoleName-yourSecurityConfigurationName/</code>), then that security configuration is used to encrypt the log group.</p>
        pub fn set_log_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.log_group_name = input;
            self
        }
        /// <p>Specifies configuration properties of a job run notification.</p>
        pub fn notification_property(mut self, input: crate::model::NotificationProperty) -> Self {
            self.notification_property = Some(input);
            self
        }
        /// <p>Specifies configuration properties of a job run notification.</p>
        pub fn set_notification_property(
            mut self,
            input: std::option::Option<crate::model::NotificationProperty>,
        ) -> Self {
            self.notification_property = input;
            self
        }
        /// <p>Glue version determines the versions of Apache Spark and Python that Glue supports. The Python version indicates the version supported for jobs of type Spark. </p>
        /// <p>For more information about the available Glue versions and corresponding Spark and Python versions, see <a href="https://docs.aws.amazon.com/glue/latest/dg/add-job.html">Glue version</a> in the developer guide.</p>
        /// <p>Jobs that are created without specifying a Glue version default to Glue 0.9.</p>
        pub fn glue_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.glue_version = Some(input.into());
            self
        }
        /// <p>Glue version determines the versions of Apache Spark and Python that Glue supports. The Python version indicates the version supported for jobs of type Spark. </p>
        /// <p>For more information about the available Glue versions and corresponding Spark and Python versions, see <a href="https://docs.aws.amazon.com/glue/latest/dg/add-job.html">Glue version</a> in the developer guide.</p>
        /// <p>Jobs that are created without specifying a Glue version default to Glue 0.9.</p>
        pub fn set_glue_version(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.glue_version = input;
            self
        }
        /// <p>This field populates only for Auto Scaling job runs, and represents the total time each executor ran during the lifecycle of a job run in seconds, multiplied by a DPU factor (1 for <code>G.1X</code>, 2 for <code>G.2X</code>, or 0.25 for <code>G.025X</code> workers). This value may be different than the <code>executionEngineRuntime</code> * <code>MaxCapacity</code> as in the case of Auto Scaling jobs, as the number of executors running at a given time may be less than the <code>MaxCapacity</code>. Therefore, it is possible that the value of <code>DPUSeconds</code> is less than <code>executionEngineRuntime</code> * <code>MaxCapacity</code>.</p>
        pub fn dpu_seconds(mut self, input: f64) -> Self {
            self.dpu_seconds = Some(input);
            self
        }
        /// <p>This field populates only for Auto Scaling job runs, and represents the total time each executor ran during the lifecycle of a job run in seconds, multiplied by a DPU factor (1 for <code>G.1X</code>, 2 for <code>G.2X</code>, or 0.25 for <code>G.025X</code> workers). This value may be different than the <code>executionEngineRuntime</code> * <code>MaxCapacity</code> as in the case of Auto Scaling jobs, as the number of executors running at a given time may be less than the <code>MaxCapacity</code>. Therefore, it is possible that the value of <code>DPUSeconds</code> is less than <code>executionEngineRuntime</code> * <code>MaxCapacity</code>.</p>
        pub fn set_dpu_seconds(mut self, input: std::option::Option<f64>) -> Self {
            self.dpu_seconds = input;
            self
        }
        /// <p>Indicates whether the job is run with a standard or flexible execution class. The standard execution-class is ideal for time-sensitive workloads that require fast job startup and dedicated resources.</p>
        /// <p>The flexible execution class is appropriate for time-insensitive jobs whose start and completion times may vary. </p>
        /// <p>Only jobs with Glue version 3.0 and above and command type <code>glueetl</code> will be allowed to set <code>ExecutionClass</code> to <code>FLEX</code>. The flexible execution class is available for Spark jobs.</p>
        pub fn execution_class(mut self, input: crate::model::ExecutionClass) -> Self {
            self.execution_class = Some(input);
            self
        }
        /// <p>Indicates whether the job is run with a standard or flexible execution class. The standard execution-class is ideal for time-sensitive workloads that require fast job startup and dedicated resources.</p>
        /// <p>The flexible execution class is appropriate for time-insensitive jobs whose start and completion times may vary. </p>
        /// <p>Only jobs with Glue version 3.0 and above and command type <code>glueetl</code> will be allowed to set <code>ExecutionClass</code> to <code>FLEX</code>. The flexible execution class is available for Spark jobs.</p>
        pub fn set_execution_class(
            mut self,
            input: std::option::Option<crate::model::ExecutionClass>,
        ) -> Self {
            self.execution_class = input;
            self
        }
        /// Consumes the builder and constructs a [`JobRun`](crate::model::JobRun).
        pub fn build(self) -> crate::model::JobRun {
            crate::model::JobRun {
                id: self.id,
                attempt: self.attempt.unwrap_or_default(),
                previous_run_id: self.previous_run_id,
                trigger_name: self.trigger_name,
                job_name: self.job_name,
                started_on: self.started_on,
                last_modified_on: self.last_modified_on,
                completed_on: self.completed_on,
                job_run_state: self.job_run_state,
                arguments: self.arguments,
                error_message: self.error_message,
                predecessor_runs: self.predecessor_runs,
                allocated_capacity: self.allocated_capacity.unwrap_or_default(),
                execution_time: self.execution_time.unwrap_or_default(),
                timeout: self.timeout,
                max_capacity: self.max_capacity,
                worker_type: self.worker_type,
                number_of_workers: self.number_of_workers,
                security_configuration: self.security_configuration,
                log_group_name: self.log_group_name,
                notification_property: self.notification_property,
                glue_version: self.glue_version,
                dpu_seconds: self.dpu_seconds,
                execution_class: self.execution_class,
            }
        }
    }
}
impl JobRun {
    /// Creates a new builder-style object to manufacture [`JobRun`](crate::model::JobRun).
    pub fn builder() -> crate::model::job_run::Builder {
        crate::model::job_run::Builder::default()
    }
}

/// <p>A job run that was used in the predicate of a conditional trigger that triggered this job run.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Predecessor {
    /// <p>The name of the job definition used by the predecessor job run.</p>
    #[doc(hidden)]
    pub job_name: std::option::Option<std::string::String>,
    /// <p>The job-run ID of the predecessor job run.</p>
    #[doc(hidden)]
    pub run_id: std::option::Option<std::string::String>,
}
impl Predecessor {
    /// <p>The name of the job definition used by the predecessor job run.</p>
    pub fn job_name(&self) -> std::option::Option<&str> {
        self.job_name.as_deref()
    }
    /// <p>The job-run ID of the predecessor job run.</p>
    pub fn run_id(&self) -> std::option::Option<&str> {
        self.run_id.as_deref()
    }
}
/// See [`Predecessor`](crate::model::Predecessor).
pub mod predecessor {

    /// A builder for [`Predecessor`](crate::model::Predecessor).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) job_name: std::option::Option<std::string::String>,
        pub(crate) run_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the job definition used by the predecessor job run.</p>
        pub fn job_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_name = Some(input.into());
            self
        }
        /// <p>The name of the job definition used by the predecessor job run.</p>
        pub fn set_job_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_name = input;
            self
        }
        /// <p>The job-run ID of the predecessor job run.</p>
        pub fn run_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.run_id = Some(input.into());
            self
        }
        /// <p>The job-run ID of the predecessor job run.</p>
        pub fn set_run_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.run_id = input;
            self
        }
        /// Consumes the builder and constructs a [`Predecessor`](crate::model::Predecessor).
        pub fn build(self) -> crate::model::Predecessor {
            crate::model::Predecessor {
                job_name: self.job_name,
                run_id: self.run_id,
            }
        }
    }
}
impl Predecessor {
    /// Creates a new builder-style object to manufacture [`Predecessor`](crate::model::Predecessor).
    pub fn builder() -> crate::model::predecessor::Builder {
        crate::model::predecessor::Builder::default()
    }
}

/// <p>The details of a Trigger node present in the workflow.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TriggerNodeDetails {
    /// <p>The information of the trigger represented by the trigger node.</p>
    #[doc(hidden)]
    pub trigger: std::option::Option<crate::model::Trigger>,
}
impl TriggerNodeDetails {
    /// <p>The information of the trigger represented by the trigger node.</p>
    pub fn trigger(&self) -> std::option::Option<&crate::model::Trigger> {
        self.trigger.as_ref()
    }
}
/// See [`TriggerNodeDetails`](crate::model::TriggerNodeDetails).
pub mod trigger_node_details {

    /// A builder for [`TriggerNodeDetails`](crate::model::TriggerNodeDetails).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) trigger: std::option::Option<crate::model::Trigger>,
    }
    impl Builder {
        /// <p>The information of the trigger represented by the trigger node.</p>
        pub fn trigger(mut self, input: crate::model::Trigger) -> Self {
            self.trigger = Some(input);
            self
        }
        /// <p>The information of the trigger represented by the trigger node.</p>
        pub fn set_trigger(mut self, input: std::option::Option<crate::model::Trigger>) -> Self {
            self.trigger = input;
            self
        }
        /// Consumes the builder and constructs a [`TriggerNodeDetails`](crate::model::TriggerNodeDetails).
        pub fn build(self) -> crate::model::TriggerNodeDetails {
            crate::model::TriggerNodeDetails {
                trigger: self.trigger,
            }
        }
    }
}
impl TriggerNodeDetails {
    /// Creates a new builder-style object to manufacture [`TriggerNodeDetails`](crate::model::TriggerNodeDetails).
    pub fn builder() -> crate::model::trigger_node_details::Builder {
        crate::model::trigger_node_details::Builder::default()
    }
}

/// When writing a match expression against `NodeType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let nodetype = unimplemented!();
/// match nodetype {
///     NodeType::Crawler => { /* ... */ },
///     NodeType::Job => { /* ... */ },
///     NodeType::Trigger => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `nodetype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `NodeType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `NodeType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `NodeType::NewFeature` is defined.
/// Specifically, when `nodetype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `NodeType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum NodeType {
    #[allow(missing_docs)] // documentation missing in model
    Crawler,
    #[allow(missing_docs)] // documentation missing in model
    Job,
    #[allow(missing_docs)] // documentation missing in model
    Trigger,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for NodeType {
    fn from(s: &str) -> Self {
        match s {
            "CRAWLER" => NodeType::Crawler,
            "JOB" => NodeType::Job,
            "TRIGGER" => NodeType::Trigger,
            other => NodeType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for NodeType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(NodeType::from(s))
    }
}
impl NodeType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            NodeType::Crawler => "CRAWLER",
            NodeType::Job => "JOB",
            NodeType::Trigger => "TRIGGER",
            NodeType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["CRAWLER", "JOB", "TRIGGER"]
    }
}
impl AsRef<str> for NodeType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Workflow run statistics provides statistics about the workflow run.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct WorkflowRunStatistics {
    /// <p>Total number of Actions in the workflow run.</p>
    #[doc(hidden)]
    pub total_actions: i32,
    /// <p>Total number of Actions that timed out.</p>
    #[doc(hidden)]
    pub timeout_actions: i32,
    /// <p>Total number of Actions that have failed.</p>
    #[doc(hidden)]
    pub failed_actions: i32,
    /// <p>Total number of Actions that have stopped.</p>
    #[doc(hidden)]
    pub stopped_actions: i32,
    /// <p>Total number of Actions that have succeeded.</p>
    #[doc(hidden)]
    pub succeeded_actions: i32,
    /// <p>Total number Actions in running state.</p>
    #[doc(hidden)]
    pub running_actions: i32,
    /// <p>Indicates the count of job runs in the ERROR state in the workflow run.</p>
    #[doc(hidden)]
    pub errored_actions: i32,
    /// <p>Indicates the count of job runs in WAITING state in the workflow run.</p>
    #[doc(hidden)]
    pub waiting_actions: i32,
}
impl WorkflowRunStatistics {
    /// <p>Total number of Actions in the workflow run.</p>
    pub fn total_actions(&self) -> i32 {
        self.total_actions
    }
    /// <p>Total number of Actions that timed out.</p>
    pub fn timeout_actions(&self) -> i32 {
        self.timeout_actions
    }
    /// <p>Total number of Actions that have failed.</p>
    pub fn failed_actions(&self) -> i32 {
        self.failed_actions
    }
    /// <p>Total number of Actions that have stopped.</p>
    pub fn stopped_actions(&self) -> i32 {
        self.stopped_actions
    }
    /// <p>Total number of Actions that have succeeded.</p>
    pub fn succeeded_actions(&self) -> i32 {
        self.succeeded_actions
    }
    /// <p>Total number Actions in running state.</p>
    pub fn running_actions(&self) -> i32 {
        self.running_actions
    }
    /// <p>Indicates the count of job runs in the ERROR state in the workflow run.</p>
    pub fn errored_actions(&self) -> i32 {
        self.errored_actions
    }
    /// <p>Indicates the count of job runs in WAITING state in the workflow run.</p>
    pub fn waiting_actions(&self) -> i32 {
        self.waiting_actions
    }
}
/// See [`WorkflowRunStatistics`](crate::model::WorkflowRunStatistics).
pub mod workflow_run_statistics {

    /// A builder for [`WorkflowRunStatistics`](crate::model::WorkflowRunStatistics).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) total_actions: std::option::Option<i32>,
        pub(crate) timeout_actions: std::option::Option<i32>,
        pub(crate) failed_actions: std::option::Option<i32>,
        pub(crate) stopped_actions: std::option::Option<i32>,
        pub(crate) succeeded_actions: std::option::Option<i32>,
        pub(crate) running_actions: std::option::Option<i32>,
        pub(crate) errored_actions: std::option::Option<i32>,
        pub(crate) waiting_actions: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>Total number of Actions in the workflow run.</p>
        pub fn total_actions(mut self, input: i32) -> Self {
            self.total_actions = Some(input);
            self
        }
        /// <p>Total number of Actions in the workflow run.</p>
        pub fn set_total_actions(mut self, input: std::option::Option<i32>) -> Self {
            self.total_actions = input;
            self
        }
        /// <p>Total number of Actions that timed out.</p>
        pub fn timeout_actions(mut self, input: i32) -> Self {
            self.timeout_actions = Some(input);
            self
        }
        /// <p>Total number of Actions that timed out.</p>
        pub fn set_timeout_actions(mut self, input: std::option::Option<i32>) -> Self {
            self.timeout_actions = input;
            self
        }
        /// <p>Total number of Actions that have failed.</p>
        pub fn failed_actions(mut self, input: i32) -> Self {
            self.failed_actions = Some(input);
            self
        }
        /// <p>Total number of Actions that have failed.</p>
        pub fn set_failed_actions(mut self, input: std::option::Option<i32>) -> Self {
            self.failed_actions = input;
            self
        }
        /// <p>Total number of Actions that have stopped.</p>
        pub fn stopped_actions(mut self, input: i32) -> Self {
            self.stopped_actions = Some(input);
            self
        }
        /// <p>Total number of Actions that have stopped.</p>
        pub fn set_stopped_actions(mut self, input: std::option::Option<i32>) -> Self {
            self.stopped_actions = input;
            self
        }
        /// <p>Total number of Actions that have succeeded.</p>
        pub fn succeeded_actions(mut self, input: i32) -> Self {
            self.succeeded_actions = Some(input);
            self
        }
        /// <p>Total number of Actions that have succeeded.</p>
        pub fn set_succeeded_actions(mut self, input: std::option::Option<i32>) -> Self {
            self.succeeded_actions = input;
            self
        }
        /// <p>Total number Actions in running state.</p>
        pub fn running_actions(mut self, input: i32) -> Self {
            self.running_actions = Some(input);
            self
        }
        /// <p>Total number Actions in running state.</p>
        pub fn set_running_actions(mut self, input: std::option::Option<i32>) -> Self {
            self.running_actions = input;
            self
        }
        /// <p>Indicates the count of job runs in the ERROR state in the workflow run.</p>
        pub fn errored_actions(mut self, input: i32) -> Self {
            self.errored_actions = Some(input);
            self
        }
        /// <p>Indicates the count of job runs in the ERROR state in the workflow run.</p>
        pub fn set_errored_actions(mut self, input: std::option::Option<i32>) -> Self {
            self.errored_actions = input;
            self
        }
        /// <p>Indicates the count of job runs in WAITING state in the workflow run.</p>
        pub fn waiting_actions(mut self, input: i32) -> Self {
            self.waiting_actions = Some(input);
            self
        }
        /// <p>Indicates the count of job runs in WAITING state in the workflow run.</p>
        pub fn set_waiting_actions(mut self, input: std::option::Option<i32>) -> Self {
            self.waiting_actions = input;
            self
        }
        /// Consumes the builder and constructs a [`WorkflowRunStatistics`](crate::model::WorkflowRunStatistics).
        pub fn build(self) -> crate::model::WorkflowRunStatistics {
            crate::model::WorkflowRunStatistics {
                total_actions: self.total_actions.unwrap_or_default(),
                timeout_actions: self.timeout_actions.unwrap_or_default(),
                failed_actions: self.failed_actions.unwrap_or_default(),
                stopped_actions: self.stopped_actions.unwrap_or_default(),
                succeeded_actions: self.succeeded_actions.unwrap_or_default(),
                running_actions: self.running_actions.unwrap_or_default(),
                errored_actions: self.errored_actions.unwrap_or_default(),
                waiting_actions: self.waiting_actions.unwrap_or_default(),
            }
        }
    }
}
impl WorkflowRunStatistics {
    /// Creates a new builder-style object to manufacture [`WorkflowRunStatistics`](crate::model::WorkflowRunStatistics).
    pub fn builder() -> crate::model::workflow_run_statistics::Builder {
        crate::model::workflow_run_statistics::Builder::default()
    }
}

/// When writing a match expression against `WorkflowRunStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let workflowrunstatus = unimplemented!();
/// match workflowrunstatus {
///     WorkflowRunStatus::Completed => { /* ... */ },
///     WorkflowRunStatus::Error => { /* ... */ },
///     WorkflowRunStatus::Running => { /* ... */ },
///     WorkflowRunStatus::Stopped => { /* ... */ },
///     WorkflowRunStatus::Stopping => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `workflowrunstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `WorkflowRunStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `WorkflowRunStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `WorkflowRunStatus::NewFeature` is defined.
/// Specifically, when `workflowrunstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `WorkflowRunStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum WorkflowRunStatus {
    #[allow(missing_docs)] // documentation missing in model
    Completed,
    #[allow(missing_docs)] // documentation missing in model
    Error,
    #[allow(missing_docs)] // documentation missing in model
    Running,
    #[allow(missing_docs)] // documentation missing in model
    Stopped,
    #[allow(missing_docs)] // documentation missing in model
    Stopping,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for WorkflowRunStatus {
    fn from(s: &str) -> Self {
        match s {
            "COMPLETED" => WorkflowRunStatus::Completed,
            "ERROR" => WorkflowRunStatus::Error,
            "RUNNING" => WorkflowRunStatus::Running,
            "STOPPED" => WorkflowRunStatus::Stopped,
            "STOPPING" => WorkflowRunStatus::Stopping,
            other => {
                WorkflowRunStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for WorkflowRunStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(WorkflowRunStatus::from(s))
    }
}
impl WorkflowRunStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            WorkflowRunStatus::Completed => "COMPLETED",
            WorkflowRunStatus::Error => "ERROR",
            WorkflowRunStatus::Running => "RUNNING",
            WorkflowRunStatus::Stopped => "STOPPED",
            WorkflowRunStatus::Stopping => "STOPPING",
            WorkflowRunStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["COMPLETED", "ERROR", "RUNNING", "STOPPED", "STOPPING"]
    }
}
impl AsRef<str> for WorkflowRunStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A workflow is a collection of multiple dependent Glue jobs and crawlers that are run to complete a complex ETL task. A workflow manages the execution and monitoring of all its jobs and crawlers.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Workflow {
    /// <p>The name of the workflow.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>A description of the workflow.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>A collection of properties to be used as part of each execution of the workflow. The run properties are made available to each job in the workflow. A job can modify the properties for the next jobs in the flow.</p>
    #[doc(hidden)]
    pub default_run_properties:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The date and time when the workflow was created.</p>
    #[doc(hidden)]
    pub created_on: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The date and time when the workflow was last modified.</p>
    #[doc(hidden)]
    pub last_modified_on: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The information about the last execution of the workflow.</p>
    #[doc(hidden)]
    pub last_run: std::option::Option<crate::model::WorkflowRun>,
    /// <p>The graph representing all the Glue components that belong to the workflow as nodes and directed connections between them as edges.</p>
    #[doc(hidden)]
    pub graph: std::option::Option<crate::model::WorkflowGraph>,
    /// <p>You can use this parameter to prevent unwanted multiple updates to data, to control costs, or in some cases, to prevent exceeding the maximum number of concurrent runs of any of the component jobs. If you leave this parameter blank, there is no limit to the number of concurrent workflow runs.</p>
    #[doc(hidden)]
    pub max_concurrent_runs: std::option::Option<i32>,
    /// <p>This structure indicates the details of the blueprint that this particular workflow is created from.</p>
    #[doc(hidden)]
    pub blueprint_details: std::option::Option<crate::model::BlueprintDetails>,
}
impl Workflow {
    /// <p>The name of the workflow.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>A description of the workflow.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>A collection of properties to be used as part of each execution of the workflow. The run properties are made available to each job in the workflow. A job can modify the properties for the next jobs in the flow.</p>
    pub fn default_run_properties(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.default_run_properties.as_ref()
    }
    /// <p>The date and time when the workflow was created.</p>
    pub fn created_on(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_on.as_ref()
    }
    /// <p>The date and time when the workflow was last modified.</p>
    pub fn last_modified_on(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_modified_on.as_ref()
    }
    /// <p>The information about the last execution of the workflow.</p>
    pub fn last_run(&self) -> std::option::Option<&crate::model::WorkflowRun> {
        self.last_run.as_ref()
    }
    /// <p>The graph representing all the Glue components that belong to the workflow as nodes and directed connections between them as edges.</p>
    pub fn graph(&self) -> std::option::Option<&crate::model::WorkflowGraph> {
        self.graph.as_ref()
    }
    /// <p>You can use this parameter to prevent unwanted multiple updates to data, to control costs, or in some cases, to prevent exceeding the maximum number of concurrent runs of any of the component jobs. If you leave this parameter blank, there is no limit to the number of concurrent workflow runs.</p>
    pub fn max_concurrent_runs(&self) -> std::option::Option<i32> {
        self.max_concurrent_runs
    }
    /// <p>This structure indicates the details of the blueprint that this particular workflow is created from.</p>
    pub fn blueprint_details(&self) -> std::option::Option<&crate::model::BlueprintDetails> {
        self.blueprint_details.as_ref()
    }
}
/// See [`Workflow`](crate::model::Workflow).
pub mod workflow {

    /// A builder for [`Workflow`](crate::model::Workflow).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) default_run_properties: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) created_on: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_modified_on: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_run: std::option::Option<crate::model::WorkflowRun>,
        pub(crate) graph: std::option::Option<crate::model::WorkflowGraph>,
        pub(crate) max_concurrent_runs: std::option::Option<i32>,
        pub(crate) blueprint_details: std::option::Option<crate::model::BlueprintDetails>,
    }
    impl Builder {
        /// <p>The name of the workflow.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the workflow.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>A description of the workflow.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A description of the workflow.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// Adds a key-value pair to `default_run_properties`.
        ///
        /// To override the contents of this collection use [`set_default_run_properties`](Self::set_default_run_properties).
        ///
        /// <p>A collection of properties to be used as part of each execution of the workflow. The run properties are made available to each job in the workflow. A job can modify the properties for the next jobs in the flow.</p>
        pub fn default_run_properties(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.default_run_properties.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.default_run_properties = Some(hash_map);
            self
        }
        /// <p>A collection of properties to be used as part of each execution of the workflow. The run properties are made available to each job in the workflow. A job can modify the properties for the next jobs in the flow.</p>
        pub fn set_default_run_properties(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.default_run_properties = input;
            self
        }
        /// <p>The date and time when the workflow was created.</p>
        pub fn created_on(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_on = Some(input);
            self
        }
        /// <p>The date and time when the workflow was created.</p>
        pub fn set_created_on(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_on = input;
            self
        }
        /// <p>The date and time when the workflow was last modified.</p>
        pub fn last_modified_on(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_modified_on = Some(input);
            self
        }
        /// <p>The date and time when the workflow was last modified.</p>
        pub fn set_last_modified_on(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_modified_on = input;
            self
        }
        /// <p>The information about the last execution of the workflow.</p>
        pub fn last_run(mut self, input: crate::model::WorkflowRun) -> Self {
            self.last_run = Some(input);
            self
        }
        /// <p>The information about the last execution of the workflow.</p>
        pub fn set_last_run(
            mut self,
            input: std::option::Option<crate::model::WorkflowRun>,
        ) -> Self {
            self.last_run = input;
            self
        }
        /// <p>The graph representing all the Glue components that belong to the workflow as nodes and directed connections between them as edges.</p>
        pub fn graph(mut self, input: crate::model::WorkflowGraph) -> Self {
            self.graph = Some(input);
            self
        }
        /// <p>The graph representing all the Glue components that belong to the workflow as nodes and directed connections between them as edges.</p>
        pub fn set_graph(
            mut self,
            input: std::option::Option<crate::model::WorkflowGraph>,
        ) -> Self {
            self.graph = input;
            self
        }
        /// <p>You can use this parameter to prevent unwanted multiple updates to data, to control costs, or in some cases, to prevent exceeding the maximum number of concurrent runs of any of the component jobs. If you leave this parameter blank, there is no limit to the number of concurrent workflow runs.</p>
        pub fn max_concurrent_runs(mut self, input: i32) -> Self {
            self.max_concurrent_runs = Some(input);
            self
        }
        /// <p>You can use this parameter to prevent unwanted multiple updates to data, to control costs, or in some cases, to prevent exceeding the maximum number of concurrent runs of any of the component jobs. If you leave this parameter blank, there is no limit to the number of concurrent workflow runs.</p>
        pub fn set_max_concurrent_runs(mut self, input: std::option::Option<i32>) -> Self {
            self.max_concurrent_runs = input;
            self
        }
        /// <p>This structure indicates the details of the blueprint that this particular workflow is created from.</p>
        pub fn blueprint_details(mut self, input: crate::model::BlueprintDetails) -> Self {
            self.blueprint_details = Some(input);
            self
        }
        /// <p>This structure indicates the details of the blueprint that this particular workflow is created from.</p>
        pub fn set_blueprint_details(
            mut self,
            input: std::option::Option<crate::model::BlueprintDetails>,
        ) -> Self {
            self.blueprint_details = input;
            self
        }
        /// Consumes the builder and constructs a [`Workflow`](crate::model::Workflow).
        pub fn build(self) -> crate::model::Workflow {
            crate::model::Workflow {
                name: self.name,
                description: self.description,
                default_run_properties: self.default_run_properties,
                created_on: self.created_on,
                last_modified_on: self.last_modified_on,
                last_run: self.last_run,
                graph: self.graph,
                max_concurrent_runs: self.max_concurrent_runs,
                blueprint_details: self.blueprint_details,
            }
        }
    }
}
impl Workflow {
    /// Creates a new builder-style object to manufacture [`Workflow`](crate::model::Workflow).
    pub fn builder() -> crate::model::workflow::Builder {
        crate::model::workflow::Builder::default()
    }
}

/// <p>The details of a blueprint.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BlueprintDetails {
    /// <p>The name of the blueprint.</p>
    #[doc(hidden)]
    pub blueprint_name: std::option::Option<std::string::String>,
    /// <p>The run ID for this blueprint.</p>
    #[doc(hidden)]
    pub run_id: std::option::Option<std::string::String>,
}
impl BlueprintDetails {
    /// <p>The name of the blueprint.</p>
    pub fn blueprint_name(&self) -> std::option::Option<&str> {
        self.blueprint_name.as_deref()
    }
    /// <p>The run ID for this blueprint.</p>
    pub fn run_id(&self) -> std::option::Option<&str> {
        self.run_id.as_deref()
    }
}
/// See [`BlueprintDetails`](crate::model::BlueprintDetails).
pub mod blueprint_details {

    /// A builder for [`BlueprintDetails`](crate::model::BlueprintDetails).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) blueprint_name: std::option::Option<std::string::String>,
        pub(crate) run_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the blueprint.</p>
        pub fn blueprint_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.blueprint_name = Some(input.into());
            self
        }
        /// <p>The name of the blueprint.</p>
        pub fn set_blueprint_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.blueprint_name = input;
            self
        }
        /// <p>The run ID for this blueprint.</p>
        pub fn run_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.run_id = Some(input.into());
            self
        }
        /// <p>The run ID for this blueprint.</p>
        pub fn set_run_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.run_id = input;
            self
        }
        /// Consumes the builder and constructs a [`BlueprintDetails`](crate::model::BlueprintDetails).
        pub fn build(self) -> crate::model::BlueprintDetails {
            crate::model::BlueprintDetails {
                blueprint_name: self.blueprint_name,
                run_id: self.run_id,
            }
        }
    }
}
impl BlueprintDetails {
    /// Creates a new builder-style object to manufacture [`BlueprintDetails`](crate::model::BlueprintDetails).
    pub fn builder() -> crate::model::blueprint_details::Builder {
        crate::model::blueprint_details::Builder::default()
    }
}

/// <p>Represents the equivalent of a Hive user-defined function (<code>UDF</code>) definition.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UserDefinedFunction {
    /// <p>The name of the function.</p>
    #[doc(hidden)]
    pub function_name: std::option::Option<std::string::String>,
    /// <p>The name of the catalog database that contains the function.</p>
    #[doc(hidden)]
    pub database_name: std::option::Option<std::string::String>,
    /// <p>The Java class that contains the function code.</p>
    #[doc(hidden)]
    pub class_name: std::option::Option<std::string::String>,
    /// <p>The owner of the function.</p>
    #[doc(hidden)]
    pub owner_name: std::option::Option<std::string::String>,
    /// <p>The owner type.</p>
    #[doc(hidden)]
    pub owner_type: std::option::Option<crate::model::PrincipalType>,
    /// <p>The time at which the function was created.</p>
    #[doc(hidden)]
    pub create_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The resource URIs for the function.</p>
    #[doc(hidden)]
    pub resource_uris: std::option::Option<std::vec::Vec<crate::model::ResourceUri>>,
    /// <p>The ID of the Data Catalog in which the function resides.</p>
    #[doc(hidden)]
    pub catalog_id: std::option::Option<std::string::String>,
}
impl UserDefinedFunction {
    /// <p>The name of the function.</p>
    pub fn function_name(&self) -> std::option::Option<&str> {
        self.function_name.as_deref()
    }
    /// <p>The name of the catalog database that contains the function.</p>
    pub fn database_name(&self) -> std::option::Option<&str> {
        self.database_name.as_deref()
    }
    /// <p>The Java class that contains the function code.</p>
    pub fn class_name(&self) -> std::option::Option<&str> {
        self.class_name.as_deref()
    }
    /// <p>The owner of the function.</p>
    pub fn owner_name(&self) -> std::option::Option<&str> {
        self.owner_name.as_deref()
    }
    /// <p>The owner type.</p>
    pub fn owner_type(&self) -> std::option::Option<&crate::model::PrincipalType> {
        self.owner_type.as_ref()
    }
    /// <p>The time at which the function was created.</p>
    pub fn create_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.create_time.as_ref()
    }
    /// <p>The resource URIs for the function.</p>
    pub fn resource_uris(&self) -> std::option::Option<&[crate::model::ResourceUri]> {
        self.resource_uris.as_deref()
    }
    /// <p>The ID of the Data Catalog in which the function resides.</p>
    pub fn catalog_id(&self) -> std::option::Option<&str> {
        self.catalog_id.as_deref()
    }
}
/// See [`UserDefinedFunction`](crate::model::UserDefinedFunction).
pub mod user_defined_function {

    /// A builder for [`UserDefinedFunction`](crate::model::UserDefinedFunction).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) function_name: std::option::Option<std::string::String>,
        pub(crate) database_name: std::option::Option<std::string::String>,
        pub(crate) class_name: std::option::Option<std::string::String>,
        pub(crate) owner_name: std::option::Option<std::string::String>,
        pub(crate) owner_type: std::option::Option<crate::model::PrincipalType>,
        pub(crate) create_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) resource_uris: std::option::Option<std::vec::Vec<crate::model::ResourceUri>>,
        pub(crate) catalog_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the function.</p>
        pub fn function_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.function_name = Some(input.into());
            self
        }
        /// <p>The name of the function.</p>
        pub fn set_function_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.function_name = input;
            self
        }
        /// <p>The name of the catalog database that contains the function.</p>
        pub fn database_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.database_name = Some(input.into());
            self
        }
        /// <p>The name of the catalog database that contains the function.</p>
        pub fn set_database_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.database_name = input;
            self
        }
        /// <p>The Java class that contains the function code.</p>
        pub fn class_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.class_name = Some(input.into());
            self
        }
        /// <p>The Java class that contains the function code.</p>
        pub fn set_class_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.class_name = input;
            self
        }
        /// <p>The owner of the function.</p>
        pub fn owner_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.owner_name = Some(input.into());
            self
        }
        /// <p>The owner of the function.</p>
        pub fn set_owner_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.owner_name = input;
            self
        }
        /// <p>The owner type.</p>
        pub fn owner_type(mut self, input: crate::model::PrincipalType) -> Self {
            self.owner_type = Some(input);
            self
        }
        /// <p>The owner type.</p>
        pub fn set_owner_type(
            mut self,
            input: std::option::Option<crate::model::PrincipalType>,
        ) -> Self {
            self.owner_type = input;
            self
        }
        /// <p>The time at which the function was created.</p>
        pub fn create_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.create_time = Some(input);
            self
        }
        /// <p>The time at which the function was created.</p>
        pub fn set_create_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.create_time = input;
            self
        }
        /// Appends an item to `resource_uris`.
        ///
        /// To override the contents of this collection use [`set_resource_uris`](Self::set_resource_uris).
        ///
        /// <p>The resource URIs for the function.</p>
        pub fn resource_uris(mut self, input: crate::model::ResourceUri) -> Self {
            let mut v = self.resource_uris.unwrap_or_default();
            v.push(input);
            self.resource_uris = Some(v);
            self
        }
        /// <p>The resource URIs for the function.</p>
        pub fn set_resource_uris(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ResourceUri>>,
        ) -> Self {
            self.resource_uris = input;
            self
        }
        /// <p>The ID of the Data Catalog in which the function resides.</p>
        pub fn catalog_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.catalog_id = Some(input.into());
            self
        }
        /// <p>The ID of the Data Catalog in which the function resides.</p>
        pub fn set_catalog_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.catalog_id = input;
            self
        }
        /// Consumes the builder and constructs a [`UserDefinedFunction`](crate::model::UserDefinedFunction).
        pub fn build(self) -> crate::model::UserDefinedFunction {
            crate::model::UserDefinedFunction {
                function_name: self.function_name,
                database_name: self.database_name,
                class_name: self.class_name,
                owner_name: self.owner_name,
                owner_type: self.owner_type,
                create_time: self.create_time,
                resource_uris: self.resource_uris,
                catalog_id: self.catalog_id,
            }
        }
    }
}
impl UserDefinedFunction {
    /// Creates a new builder-style object to manufacture [`UserDefinedFunction`](crate::model::UserDefinedFunction).
    pub fn builder() -> crate::model::user_defined_function::Builder {
        crate::model::user_defined_function::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ColumnRowFilter {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub column_name: std::option::Option<std::string::String>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub row_filter_expression: std::option::Option<std::string::String>,
}
impl ColumnRowFilter {
    #[allow(missing_docs)] // documentation missing in model
    pub fn column_name(&self) -> std::option::Option<&str> {
        self.column_name.as_deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn row_filter_expression(&self) -> std::option::Option<&str> {
        self.row_filter_expression.as_deref()
    }
}
/// See [`ColumnRowFilter`](crate::model::ColumnRowFilter).
pub mod column_row_filter {

    /// A builder for [`ColumnRowFilter`](crate::model::ColumnRowFilter).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) column_name: std::option::Option<std::string::String>,
        pub(crate) row_filter_expression: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn column_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.column_name = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_column_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.column_name = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn row_filter_expression(mut self, input: impl Into<std::string::String>) -> Self {
            self.row_filter_expression = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_row_filter_expression(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.row_filter_expression = input;
            self
        }
        /// Consumes the builder and constructs a [`ColumnRowFilter`](crate::model::ColumnRowFilter).
        pub fn build(self) -> crate::model::ColumnRowFilter {
            crate::model::ColumnRowFilter {
                column_name: self.column_name,
                row_filter_expression: self.row_filter_expression,
            }
        }
    }
}
impl ColumnRowFilter {
    /// Creates a new builder-style object to manufacture [`ColumnRowFilter`](crate::model::ColumnRowFilter).
    pub fn builder() -> crate::model::column_row_filter::Builder {
        crate::model::column_row_filter::Builder::default()
    }
}

/// When writing a match expression against `PermissionType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let permissiontype = unimplemented!();
/// match permissiontype {
///     PermissionType::CellFilterPermission => { /* ... */ },
///     PermissionType::ColumnPermission => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `permissiontype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `PermissionType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `PermissionType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `PermissionType::NewFeature` is defined.
/// Specifically, when `permissiontype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `PermissionType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum PermissionType {
    #[allow(missing_docs)] // documentation missing in model
    CellFilterPermission,
    #[allow(missing_docs)] // documentation missing in model
    ColumnPermission,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for PermissionType {
    fn from(s: &str) -> Self {
        match s {
            "CELL_FILTER_PERMISSION" => PermissionType::CellFilterPermission,
            "COLUMN_PERMISSION" => PermissionType::ColumnPermission,
            other => PermissionType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for PermissionType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(PermissionType::from(s))
    }
}
impl PermissionType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            PermissionType::CellFilterPermission => "CELL_FILTER_PERMISSION",
            PermissionType::ColumnPermission => "COLUMN_PERMISSION",
            PermissionType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["CELL_FILTER_PERMISSION", "COLUMN_PERMISSION"]
    }
}
impl AsRef<str> for PermissionType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A structure containing information for audit.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AuditContext {
    /// <p>The context for the audit..</p>
    #[doc(hidden)]
    pub additional_audit_context: std::option::Option<std::string::String>,
    /// <p>The requested columns for audit.</p>
    #[doc(hidden)]
    pub requested_columns: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>All columns request for audit.</p>
    #[doc(hidden)]
    pub all_columns_requested: std::option::Option<bool>,
}
impl AuditContext {
    /// <p>The context for the audit..</p>
    pub fn additional_audit_context(&self) -> std::option::Option<&str> {
        self.additional_audit_context.as_deref()
    }
    /// <p>The requested columns for audit.</p>
    pub fn requested_columns(&self) -> std::option::Option<&[std::string::String]> {
        self.requested_columns.as_deref()
    }
    /// <p>All columns request for audit.</p>
    pub fn all_columns_requested(&self) -> std::option::Option<bool> {
        self.all_columns_requested
    }
}
/// See [`AuditContext`](crate::model::AuditContext).
pub mod audit_context {

    /// A builder for [`AuditContext`](crate::model::AuditContext).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) additional_audit_context: std::option::Option<std::string::String>,
        pub(crate) requested_columns: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) all_columns_requested: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The context for the audit..</p>
        pub fn additional_audit_context(mut self, input: impl Into<std::string::String>) -> Self {
            self.additional_audit_context = Some(input.into());
            self
        }
        /// <p>The context for the audit..</p>
        pub fn set_additional_audit_context(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.additional_audit_context = input;
            self
        }
        /// Appends an item to `requested_columns`.
        ///
        /// To override the contents of this collection use [`set_requested_columns`](Self::set_requested_columns).
        ///
        /// <p>The requested columns for audit.</p>
        pub fn requested_columns(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.requested_columns.unwrap_or_default();
            v.push(input.into());
            self.requested_columns = Some(v);
            self
        }
        /// <p>The requested columns for audit.</p>
        pub fn set_requested_columns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.requested_columns = input;
            self
        }
        /// <p>All columns request for audit.</p>
        pub fn all_columns_requested(mut self, input: bool) -> Self {
            self.all_columns_requested = Some(input);
            self
        }
        /// <p>All columns request for audit.</p>
        pub fn set_all_columns_requested(mut self, input: std::option::Option<bool>) -> Self {
            self.all_columns_requested = input;
            self
        }
        /// Consumes the builder and constructs a [`AuditContext`](crate::model::AuditContext).
        pub fn build(self) -> crate::model::AuditContext {
            crate::model::AuditContext {
                additional_audit_context: self.additional_audit_context,
                requested_columns: self.requested_columns,
                all_columns_requested: self.all_columns_requested,
            }
        }
    }
}
impl AuditContext {
    /// Creates a new builder-style object to manufacture [`AuditContext`](crate::model::AuditContext).
    pub fn builder() -> crate::model::audit_context::Builder {
        crate::model::audit_context::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UnfilteredPartition {
    /// <p>Represents a slice of table data.</p>
    #[doc(hidden)]
    pub partition: std::option::Option<crate::model::Partition>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub authorized_columns: std::option::Option<std::vec::Vec<std::string::String>>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub is_registered_with_lake_formation: bool,
}
impl UnfilteredPartition {
    /// <p>Represents a slice of table data.</p>
    pub fn partition(&self) -> std::option::Option<&crate::model::Partition> {
        self.partition.as_ref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn authorized_columns(&self) -> std::option::Option<&[std::string::String]> {
        self.authorized_columns.as_deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn is_registered_with_lake_formation(&self) -> bool {
        self.is_registered_with_lake_formation
    }
}
/// See [`UnfilteredPartition`](crate::model::UnfilteredPartition).
pub mod unfiltered_partition {

    /// A builder for [`UnfilteredPartition`](crate::model::UnfilteredPartition).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) partition: std::option::Option<crate::model::Partition>,
        pub(crate) authorized_columns: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) is_registered_with_lake_formation: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>Represents a slice of table data.</p>
        pub fn partition(mut self, input: crate::model::Partition) -> Self {
            self.partition = Some(input);
            self
        }
        /// <p>Represents a slice of table data.</p>
        pub fn set_partition(
            mut self,
            input: std::option::Option<crate::model::Partition>,
        ) -> Self {
            self.partition = input;
            self
        }
        /// Appends an item to `authorized_columns`.
        ///
        /// To override the contents of this collection use [`set_authorized_columns`](Self::set_authorized_columns).
        ///
        pub fn authorized_columns(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.authorized_columns.unwrap_or_default();
            v.push(input.into());
            self.authorized_columns = Some(v);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_authorized_columns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.authorized_columns = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn is_registered_with_lake_formation(mut self, input: bool) -> Self {
            self.is_registered_with_lake_formation = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_is_registered_with_lake_formation(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.is_registered_with_lake_formation = input;
            self
        }
        /// Consumes the builder and constructs a [`UnfilteredPartition`](crate::model::UnfilteredPartition).
        pub fn build(self) -> crate::model::UnfilteredPartition {
            crate::model::UnfilteredPartition {
                partition: self.partition,
                authorized_columns: self.authorized_columns,
                is_registered_with_lake_formation: self
                    .is_registered_with_lake_formation
                    .unwrap_or_default(),
            }
        }
    }
}
impl UnfilteredPartition {
    /// Creates a new builder-style object to manufacture [`UnfilteredPartition`](crate::model::UnfilteredPartition).
    pub fn builder() -> crate::model::unfiltered_partition::Builder {
        crate::model::unfiltered_partition::Builder::default()
    }
}

/// <p>Represents a slice of table data.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Partition {
    /// <p>The values of the partition.</p>
    #[doc(hidden)]
    pub values: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The name of the catalog database in which to create the partition.</p>
    #[doc(hidden)]
    pub database_name: std::option::Option<std::string::String>,
    /// <p>The name of the database table in which to create the partition.</p>
    #[doc(hidden)]
    pub table_name: std::option::Option<std::string::String>,
    /// <p>The time at which the partition was created.</p>
    #[doc(hidden)]
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The last time at which the partition was accessed.</p>
    #[doc(hidden)]
    pub last_access_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Provides information about the physical location where the partition is stored.</p>
    #[doc(hidden)]
    pub storage_descriptor: std::option::Option<crate::model::StorageDescriptor>,
    /// <p>These key-value pairs define partition parameters.</p>
    #[doc(hidden)]
    pub parameters:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The last time at which column statistics were computed for this partition.</p>
    #[doc(hidden)]
    pub last_analyzed_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The ID of the Data Catalog in which the partition resides.</p>
    #[doc(hidden)]
    pub catalog_id: std::option::Option<std::string::String>,
}
impl Partition {
    /// <p>The values of the partition.</p>
    pub fn values(&self) -> std::option::Option<&[std::string::String]> {
        self.values.as_deref()
    }
    /// <p>The name of the catalog database in which to create the partition.</p>
    pub fn database_name(&self) -> std::option::Option<&str> {
        self.database_name.as_deref()
    }
    /// <p>The name of the database table in which to create the partition.</p>
    pub fn table_name(&self) -> std::option::Option<&str> {
        self.table_name.as_deref()
    }
    /// <p>The time at which the partition was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>The last time at which the partition was accessed.</p>
    pub fn last_access_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_access_time.as_ref()
    }
    /// <p>Provides information about the physical location where the partition is stored.</p>
    pub fn storage_descriptor(&self) -> std::option::Option<&crate::model::StorageDescriptor> {
        self.storage_descriptor.as_ref()
    }
    /// <p>These key-value pairs define partition parameters.</p>
    pub fn parameters(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.parameters.as_ref()
    }
    /// <p>The last time at which column statistics were computed for this partition.</p>
    pub fn last_analyzed_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_analyzed_time.as_ref()
    }
    /// <p>The ID of the Data Catalog in which the partition resides.</p>
    pub fn catalog_id(&self) -> std::option::Option<&str> {
        self.catalog_id.as_deref()
    }
}
/// See [`Partition`](crate::model::Partition).
pub mod partition {

    /// A builder for [`Partition`](crate::model::Partition).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) values: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) database_name: std::option::Option<std::string::String>,
        pub(crate) table_name: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_access_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) storage_descriptor: std::option::Option<crate::model::StorageDescriptor>,
        pub(crate) parameters: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) last_analyzed_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) catalog_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `values`.
        ///
        /// To override the contents of this collection use [`set_values`](Self::set_values).
        ///
        /// <p>The values of the partition.</p>
        pub fn values(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.values.unwrap_or_default();
            v.push(input.into());
            self.values = Some(v);
            self
        }
        /// <p>The values of the partition.</p>
        pub fn set_values(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.values = input;
            self
        }
        /// <p>The name of the catalog database in which to create the partition.</p>
        pub fn database_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.database_name = Some(input.into());
            self
        }
        /// <p>The name of the catalog database in which to create the partition.</p>
        pub fn set_database_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.database_name = input;
            self
        }
        /// <p>The name of the database table in which to create the partition.</p>
        pub fn table_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.table_name = Some(input.into());
            self
        }
        /// <p>The name of the database table in which to create the partition.</p>
        pub fn set_table_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.table_name = input;
            self
        }
        /// <p>The time at which the partition was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>The time at which the partition was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>The last time at which the partition was accessed.</p>
        pub fn last_access_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_access_time = Some(input);
            self
        }
        /// <p>The last time at which the partition was accessed.</p>
        pub fn set_last_access_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_access_time = input;
            self
        }
        /// <p>Provides information about the physical location where the partition is stored.</p>
        pub fn storage_descriptor(mut self, input: crate::model::StorageDescriptor) -> Self {
            self.storage_descriptor = Some(input);
            self
        }
        /// <p>Provides information about the physical location where the partition is stored.</p>
        pub fn set_storage_descriptor(
            mut self,
            input: std::option::Option<crate::model::StorageDescriptor>,
        ) -> Self {
            self.storage_descriptor = input;
            self
        }
        /// Adds a key-value pair to `parameters`.
        ///
        /// To override the contents of this collection use [`set_parameters`](Self::set_parameters).
        ///
        /// <p>These key-value pairs define partition parameters.</p>
        pub fn parameters(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.parameters.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.parameters = Some(hash_map);
            self
        }
        /// <p>These key-value pairs define partition parameters.</p>
        pub fn set_parameters(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.parameters = input;
            self
        }
        /// <p>The last time at which column statistics were computed for this partition.</p>
        pub fn last_analyzed_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_analyzed_time = Some(input);
            self
        }
        /// <p>The last time at which column statistics were computed for this partition.</p>
        pub fn set_last_analyzed_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_analyzed_time = input;
            self
        }
        /// <p>The ID of the Data Catalog in which the partition resides.</p>
        pub fn catalog_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.catalog_id = Some(input.into());
            self
        }
        /// <p>The ID of the Data Catalog in which the partition resides.</p>
        pub fn set_catalog_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.catalog_id = input;
            self
        }
        /// Consumes the builder and constructs a [`Partition`](crate::model::Partition).
        pub fn build(self) -> crate::model::Partition {
            crate::model::Partition {
                values: self.values,
                database_name: self.database_name,
                table_name: self.table_name,
                creation_time: self.creation_time,
                last_access_time: self.last_access_time,
                storage_descriptor: self.storage_descriptor,
                parameters: self.parameters,
                last_analyzed_time: self.last_analyzed_time,
                catalog_id: self.catalog_id,
            }
        }
    }
}
impl Partition {
    /// Creates a new builder-style object to manufacture [`Partition`](crate::model::Partition).
    pub fn builder() -> crate::model::partition::Builder {
        crate::model::partition::Builder::default()
    }
}

/// <p>Defines a non-overlapping region of a table's partitions, allowing multiple requests to be run in parallel.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Segment {
    /// <p>The zero-based index number of the segment. For example, if the total number of segments is 4, <code>SegmentNumber</code> values range from 0 through 3.</p>
    #[doc(hidden)]
    pub segment_number: i32,
    /// <p>The total number of segments.</p>
    #[doc(hidden)]
    pub total_segments: i32,
}
impl Segment {
    /// <p>The zero-based index number of the segment. For example, if the total number of segments is 4, <code>SegmentNumber</code> values range from 0 through 3.</p>
    pub fn segment_number(&self) -> i32 {
        self.segment_number
    }
    /// <p>The total number of segments.</p>
    pub fn total_segments(&self) -> i32 {
        self.total_segments
    }
}
/// See [`Segment`](crate::model::Segment).
pub mod segment {

    /// A builder for [`Segment`](crate::model::Segment).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) segment_number: std::option::Option<i32>,
        pub(crate) total_segments: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The zero-based index number of the segment. For example, if the total number of segments is 4, <code>SegmentNumber</code> values range from 0 through 3.</p>
        pub fn segment_number(mut self, input: i32) -> Self {
            self.segment_number = Some(input);
            self
        }
        /// <p>The zero-based index number of the segment. For example, if the total number of segments is 4, <code>SegmentNumber</code> values range from 0 through 3.</p>
        pub fn set_segment_number(mut self, input: std::option::Option<i32>) -> Self {
            self.segment_number = input;
            self
        }
        /// <p>The total number of segments.</p>
        pub fn total_segments(mut self, input: i32) -> Self {
            self.total_segments = Some(input);
            self
        }
        /// <p>The total number of segments.</p>
        pub fn set_total_segments(mut self, input: std::option::Option<i32>) -> Self {
            self.total_segments = input;
            self
        }
        /// Consumes the builder and constructs a [`Segment`](crate::model::Segment).
        pub fn build(self) -> crate::model::Segment {
            crate::model::Segment {
                segment_number: self.segment_number.unwrap_or_default(),
                total_segments: self.total_segments.unwrap_or_default(),
            }
        }
    }
}
impl Segment {
    /// Creates a new builder-style object to manufacture [`Segment`](crate::model::Segment).
    pub fn builder() -> crate::model::segment::Builder {
        crate::model::segment::Builder::default()
    }
}

/// <p>Specifies a version of a table.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TableVersion {
    /// <p>The table in question.</p>
    #[doc(hidden)]
    pub table: std::option::Option<crate::model::Table>,
    /// <p>The ID value that identifies this table version. A <code>VersionId</code> is a string representation of an integer. Each version is incremented by 1.</p>
    #[doc(hidden)]
    pub version_id: std::option::Option<std::string::String>,
}
impl TableVersion {
    /// <p>The table in question.</p>
    pub fn table(&self) -> std::option::Option<&crate::model::Table> {
        self.table.as_ref()
    }
    /// <p>The ID value that identifies this table version. A <code>VersionId</code> is a string representation of an integer. Each version is incremented by 1.</p>
    pub fn version_id(&self) -> std::option::Option<&str> {
        self.version_id.as_deref()
    }
}
/// See [`TableVersion`](crate::model::TableVersion).
pub mod table_version {

    /// A builder for [`TableVersion`](crate::model::TableVersion).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) table: std::option::Option<crate::model::Table>,
        pub(crate) version_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The table in question.</p>
        pub fn table(mut self, input: crate::model::Table) -> Self {
            self.table = Some(input);
            self
        }
        /// <p>The table in question.</p>
        pub fn set_table(mut self, input: std::option::Option<crate::model::Table>) -> Self {
            self.table = input;
            self
        }
        /// <p>The ID value that identifies this table version. A <code>VersionId</code> is a string representation of an integer. Each version is incremented by 1.</p>
        pub fn version_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.version_id = Some(input.into());
            self
        }
        /// <p>The ID value that identifies this table version. A <code>VersionId</code> is a string representation of an integer. Each version is incremented by 1.</p>
        pub fn set_version_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.version_id = input;
            self
        }
        /// Consumes the builder and constructs a [`TableVersion`](crate::model::TableVersion).
        pub fn build(self) -> crate::model::TableVersion {
            crate::model::TableVersion {
                table: self.table,
                version_id: self.version_id,
            }
        }
    }
}
impl TableVersion {
    /// Creates a new builder-style object to manufacture [`TableVersion`](crate::model::TableVersion).
    pub fn builder() -> crate::model::table_version::Builder {
        crate::model::table_version::Builder::default()
    }
}

/// <p>Specifies a security configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SecurityConfiguration {
    /// <p>The name of the security configuration.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The time at which this security configuration was created.</p>
    #[doc(hidden)]
    pub created_time_stamp: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The encryption configuration associated with this security configuration.</p>
    #[doc(hidden)]
    pub encryption_configuration: std::option::Option<crate::model::EncryptionConfiguration>,
}
impl SecurityConfiguration {
    /// <p>The name of the security configuration.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The time at which this security configuration was created.</p>
    pub fn created_time_stamp(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_time_stamp.as_ref()
    }
    /// <p>The encryption configuration associated with this security configuration.</p>
    pub fn encryption_configuration(
        &self,
    ) -> std::option::Option<&crate::model::EncryptionConfiguration> {
        self.encryption_configuration.as_ref()
    }
}
/// See [`SecurityConfiguration`](crate::model::SecurityConfiguration).
pub mod security_configuration {

    /// A builder for [`SecurityConfiguration`](crate::model::SecurityConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) created_time_stamp: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) encryption_configuration:
            std::option::Option<crate::model::EncryptionConfiguration>,
    }
    impl Builder {
        /// <p>The name of the security configuration.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the security configuration.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The time at which this security configuration was created.</p>
        pub fn created_time_stamp(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_time_stamp = Some(input);
            self
        }
        /// <p>The time at which this security configuration was created.</p>
        pub fn set_created_time_stamp(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_time_stamp = input;
            self
        }
        /// <p>The encryption configuration associated with this security configuration.</p>
        pub fn encryption_configuration(
            mut self,
            input: crate::model::EncryptionConfiguration,
        ) -> Self {
            self.encryption_configuration = Some(input);
            self
        }
        /// <p>The encryption configuration associated with this security configuration.</p>
        pub fn set_encryption_configuration(
            mut self,
            input: std::option::Option<crate::model::EncryptionConfiguration>,
        ) -> Self {
            self.encryption_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`SecurityConfiguration`](crate::model::SecurityConfiguration).
        pub fn build(self) -> crate::model::SecurityConfiguration {
            crate::model::SecurityConfiguration {
                name: self.name,
                created_time_stamp: self.created_time_stamp,
                encryption_configuration: self.encryption_configuration,
            }
        }
    }
}
impl SecurityConfiguration {
    /// Creates a new builder-style object to manufacture [`SecurityConfiguration`](crate::model::SecurityConfiguration).
    pub fn builder() -> crate::model::security_configuration::Builder {
        crate::model::security_configuration::Builder::default()
    }
}

/// <p>Specifies an encryption configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct EncryptionConfiguration {
    /// <p>The encryption configuration for Amazon Simple Storage Service (Amazon S3) data.</p>
    #[doc(hidden)]
    pub s3_encryption: std::option::Option<std::vec::Vec<crate::model::S3Encryption>>,
    /// <p>The encryption configuration for Amazon CloudWatch.</p>
    #[doc(hidden)]
    pub cloud_watch_encryption: std::option::Option<crate::model::CloudWatchEncryption>,
    /// <p>The encryption configuration for job bookmarks.</p>
    #[doc(hidden)]
    pub job_bookmarks_encryption: std::option::Option<crate::model::JobBookmarksEncryption>,
}
impl EncryptionConfiguration {
    /// <p>The encryption configuration for Amazon Simple Storage Service (Amazon S3) data.</p>
    pub fn s3_encryption(&self) -> std::option::Option<&[crate::model::S3Encryption]> {
        self.s3_encryption.as_deref()
    }
    /// <p>The encryption configuration for Amazon CloudWatch.</p>
    pub fn cloud_watch_encryption(
        &self,
    ) -> std::option::Option<&crate::model::CloudWatchEncryption> {
        self.cloud_watch_encryption.as_ref()
    }
    /// <p>The encryption configuration for job bookmarks.</p>
    pub fn job_bookmarks_encryption(
        &self,
    ) -> std::option::Option<&crate::model::JobBookmarksEncryption> {
        self.job_bookmarks_encryption.as_ref()
    }
}
/// See [`EncryptionConfiguration`](crate::model::EncryptionConfiguration).
pub mod encryption_configuration {

    /// A builder for [`EncryptionConfiguration`](crate::model::EncryptionConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) s3_encryption: std::option::Option<std::vec::Vec<crate::model::S3Encryption>>,
        pub(crate) cloud_watch_encryption: std::option::Option<crate::model::CloudWatchEncryption>,
        pub(crate) job_bookmarks_encryption:
            std::option::Option<crate::model::JobBookmarksEncryption>,
    }
    impl Builder {
        /// Appends an item to `s3_encryption`.
        ///
        /// To override the contents of this collection use [`set_s3_encryption`](Self::set_s3_encryption).
        ///
        /// <p>The encryption configuration for Amazon Simple Storage Service (Amazon S3) data.</p>
        pub fn s3_encryption(mut self, input: crate::model::S3Encryption) -> Self {
            let mut v = self.s3_encryption.unwrap_or_default();
            v.push(input);
            self.s3_encryption = Some(v);
            self
        }
        /// <p>The encryption configuration for Amazon Simple Storage Service (Amazon S3) data.</p>
        pub fn set_s3_encryption(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::S3Encryption>>,
        ) -> Self {
            self.s3_encryption = input;
            self
        }
        /// <p>The encryption configuration for Amazon CloudWatch.</p>
        pub fn cloud_watch_encryption(mut self, input: crate::model::CloudWatchEncryption) -> Self {
            self.cloud_watch_encryption = Some(input);
            self
        }
        /// <p>The encryption configuration for Amazon CloudWatch.</p>
        pub fn set_cloud_watch_encryption(
            mut self,
            input: std::option::Option<crate::model::CloudWatchEncryption>,
        ) -> Self {
            self.cloud_watch_encryption = input;
            self
        }
        /// <p>The encryption configuration for job bookmarks.</p>
        pub fn job_bookmarks_encryption(
            mut self,
            input: crate::model::JobBookmarksEncryption,
        ) -> Self {
            self.job_bookmarks_encryption = Some(input);
            self
        }
        /// <p>The encryption configuration for job bookmarks.</p>
        pub fn set_job_bookmarks_encryption(
            mut self,
            input: std::option::Option<crate::model::JobBookmarksEncryption>,
        ) -> Self {
            self.job_bookmarks_encryption = input;
            self
        }
        /// Consumes the builder and constructs a [`EncryptionConfiguration`](crate::model::EncryptionConfiguration).
        pub fn build(self) -> crate::model::EncryptionConfiguration {
            crate::model::EncryptionConfiguration {
                s3_encryption: self.s3_encryption,
                cloud_watch_encryption: self.cloud_watch_encryption,
                job_bookmarks_encryption: self.job_bookmarks_encryption,
            }
        }
    }
}
impl EncryptionConfiguration {
    /// Creates a new builder-style object to manufacture [`EncryptionConfiguration`](crate::model::EncryptionConfiguration).
    pub fn builder() -> crate::model::encryption_configuration::Builder {
        crate::model::encryption_configuration::Builder::default()
    }
}

/// <p>Specifies how job bookmark data should be encrypted.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct JobBookmarksEncryption {
    /// <p>The encryption mode to use for job bookmarks data.</p>
    #[doc(hidden)]
    pub job_bookmarks_encryption_mode:
        std::option::Option<crate::model::JobBookmarksEncryptionMode>,
    /// <p>The Amazon Resource Name (ARN) of the KMS key to be used to encrypt the data.</p>
    #[doc(hidden)]
    pub kms_key_arn: std::option::Option<std::string::String>,
}
impl JobBookmarksEncryption {
    /// <p>The encryption mode to use for job bookmarks data.</p>
    pub fn job_bookmarks_encryption_mode(
        &self,
    ) -> std::option::Option<&crate::model::JobBookmarksEncryptionMode> {
        self.job_bookmarks_encryption_mode.as_ref()
    }
    /// <p>The Amazon Resource Name (ARN) of the KMS key to be used to encrypt the data.</p>
    pub fn kms_key_arn(&self) -> std::option::Option<&str> {
        self.kms_key_arn.as_deref()
    }
}
/// See [`JobBookmarksEncryption`](crate::model::JobBookmarksEncryption).
pub mod job_bookmarks_encryption {

    /// A builder for [`JobBookmarksEncryption`](crate::model::JobBookmarksEncryption).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) job_bookmarks_encryption_mode:
            std::option::Option<crate::model::JobBookmarksEncryptionMode>,
        pub(crate) kms_key_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The encryption mode to use for job bookmarks data.</p>
        pub fn job_bookmarks_encryption_mode(
            mut self,
            input: crate::model::JobBookmarksEncryptionMode,
        ) -> Self {
            self.job_bookmarks_encryption_mode = Some(input);
            self
        }
        /// <p>The encryption mode to use for job bookmarks data.</p>
        pub fn set_job_bookmarks_encryption_mode(
            mut self,
            input: std::option::Option<crate::model::JobBookmarksEncryptionMode>,
        ) -> Self {
            self.job_bookmarks_encryption_mode = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the KMS key to be used to encrypt the data.</p>
        pub fn kms_key_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.kms_key_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the KMS key to be used to encrypt the data.</p>
        pub fn set_kms_key_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.kms_key_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`JobBookmarksEncryption`](crate::model::JobBookmarksEncryption).
        pub fn build(self) -> crate::model::JobBookmarksEncryption {
            crate::model::JobBookmarksEncryption {
                job_bookmarks_encryption_mode: self.job_bookmarks_encryption_mode,
                kms_key_arn: self.kms_key_arn,
            }
        }
    }
}
impl JobBookmarksEncryption {
    /// Creates a new builder-style object to manufacture [`JobBookmarksEncryption`](crate::model::JobBookmarksEncryption).
    pub fn builder() -> crate::model::job_bookmarks_encryption::Builder {
        crate::model::job_bookmarks_encryption::Builder::default()
    }
}

/// When writing a match expression against `JobBookmarksEncryptionMode`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let jobbookmarksencryptionmode = unimplemented!();
/// match jobbookmarksencryptionmode {
///     JobBookmarksEncryptionMode::Csekms => { /* ... */ },
///     JobBookmarksEncryptionMode::Disabled => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `jobbookmarksencryptionmode` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `JobBookmarksEncryptionMode::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `JobBookmarksEncryptionMode::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `JobBookmarksEncryptionMode::NewFeature` is defined.
/// Specifically, when `jobbookmarksencryptionmode` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `JobBookmarksEncryptionMode::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum JobBookmarksEncryptionMode {
    #[allow(missing_docs)] // documentation missing in model
    Csekms,
    #[allow(missing_docs)] // documentation missing in model
    Disabled,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for JobBookmarksEncryptionMode {
    fn from(s: &str) -> Self {
        match s {
            "CSE-KMS" => JobBookmarksEncryptionMode::Csekms,
            "DISABLED" => JobBookmarksEncryptionMode::Disabled,
            other => JobBookmarksEncryptionMode::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for JobBookmarksEncryptionMode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(JobBookmarksEncryptionMode::from(s))
    }
}
impl JobBookmarksEncryptionMode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            JobBookmarksEncryptionMode::Csekms => "CSE-KMS",
            JobBookmarksEncryptionMode::Disabled => "DISABLED",
            JobBookmarksEncryptionMode::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["CSE-KMS", "DISABLED"]
    }
}
impl AsRef<str> for JobBookmarksEncryptionMode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Specifies how Amazon CloudWatch data should be encrypted.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CloudWatchEncryption {
    /// <p>The encryption mode to use for CloudWatch data.</p>
    #[doc(hidden)]
    pub cloud_watch_encryption_mode: std::option::Option<crate::model::CloudWatchEncryptionMode>,
    /// <p>The Amazon Resource Name (ARN) of the KMS key to be used to encrypt the data.</p>
    #[doc(hidden)]
    pub kms_key_arn: std::option::Option<std::string::String>,
}
impl CloudWatchEncryption {
    /// <p>The encryption mode to use for CloudWatch data.</p>
    pub fn cloud_watch_encryption_mode(
        &self,
    ) -> std::option::Option<&crate::model::CloudWatchEncryptionMode> {
        self.cloud_watch_encryption_mode.as_ref()
    }
    /// <p>The Amazon Resource Name (ARN) of the KMS key to be used to encrypt the data.</p>
    pub fn kms_key_arn(&self) -> std::option::Option<&str> {
        self.kms_key_arn.as_deref()
    }
}
/// See [`CloudWatchEncryption`](crate::model::CloudWatchEncryption).
pub mod cloud_watch_encryption {

    /// A builder for [`CloudWatchEncryption`](crate::model::CloudWatchEncryption).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) cloud_watch_encryption_mode:
            std::option::Option<crate::model::CloudWatchEncryptionMode>,
        pub(crate) kms_key_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The encryption mode to use for CloudWatch data.</p>
        pub fn cloud_watch_encryption_mode(
            mut self,
            input: crate::model::CloudWatchEncryptionMode,
        ) -> Self {
            self.cloud_watch_encryption_mode = Some(input);
            self
        }
        /// <p>The encryption mode to use for CloudWatch data.</p>
        pub fn set_cloud_watch_encryption_mode(
            mut self,
            input: std::option::Option<crate::model::CloudWatchEncryptionMode>,
        ) -> Self {
            self.cloud_watch_encryption_mode = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the KMS key to be used to encrypt the data.</p>
        pub fn kms_key_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.kms_key_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the KMS key to be used to encrypt the data.</p>
        pub fn set_kms_key_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.kms_key_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`CloudWatchEncryption`](crate::model::CloudWatchEncryption).
        pub fn build(self) -> crate::model::CloudWatchEncryption {
            crate::model::CloudWatchEncryption {
                cloud_watch_encryption_mode: self.cloud_watch_encryption_mode,
                kms_key_arn: self.kms_key_arn,
            }
        }
    }
}
impl CloudWatchEncryption {
    /// Creates a new builder-style object to manufacture [`CloudWatchEncryption`](crate::model::CloudWatchEncryption).
    pub fn builder() -> crate::model::cloud_watch_encryption::Builder {
        crate::model::cloud_watch_encryption::Builder::default()
    }
}

/// When writing a match expression against `CloudWatchEncryptionMode`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let cloudwatchencryptionmode = unimplemented!();
/// match cloudwatchencryptionmode {
///     CloudWatchEncryptionMode::Disabled => { /* ... */ },
///     CloudWatchEncryptionMode::Ssekms => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `cloudwatchencryptionmode` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `CloudWatchEncryptionMode::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `CloudWatchEncryptionMode::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `CloudWatchEncryptionMode::NewFeature` is defined.
/// Specifically, when `cloudwatchencryptionmode` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `CloudWatchEncryptionMode::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum CloudWatchEncryptionMode {
    #[allow(missing_docs)] // documentation missing in model
    Disabled,
    #[allow(missing_docs)] // documentation missing in model
    Ssekms,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for CloudWatchEncryptionMode {
    fn from(s: &str) -> Self {
        match s {
            "DISABLED" => CloudWatchEncryptionMode::Disabled,
            "SSE-KMS" => CloudWatchEncryptionMode::Ssekms,
            other => CloudWatchEncryptionMode::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for CloudWatchEncryptionMode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(CloudWatchEncryptionMode::from(s))
    }
}
impl CloudWatchEncryptionMode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            CloudWatchEncryptionMode::Disabled => "DISABLED",
            CloudWatchEncryptionMode::Ssekms => "SSE-KMS",
            CloudWatchEncryptionMode::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["DISABLED", "SSE-KMS"]
    }
}
impl AsRef<str> for CloudWatchEncryptionMode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Specifies how Amazon Simple Storage Service (Amazon S3) data should be encrypted.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct S3Encryption {
    /// <p>The encryption mode to use for Amazon S3 data.</p>
    #[doc(hidden)]
    pub s3_encryption_mode: std::option::Option<crate::model::S3EncryptionMode>,
    /// <p>The Amazon Resource Name (ARN) of the KMS key to be used to encrypt the data.</p>
    #[doc(hidden)]
    pub kms_key_arn: std::option::Option<std::string::String>,
}
impl S3Encryption {
    /// <p>The encryption mode to use for Amazon S3 data.</p>
    pub fn s3_encryption_mode(&self) -> std::option::Option<&crate::model::S3EncryptionMode> {
        self.s3_encryption_mode.as_ref()
    }
    /// <p>The Amazon Resource Name (ARN) of the KMS key to be used to encrypt the data.</p>
    pub fn kms_key_arn(&self) -> std::option::Option<&str> {
        self.kms_key_arn.as_deref()
    }
}
/// See [`S3Encryption`](crate::model::S3Encryption).
pub mod s3_encryption {

    /// A builder for [`S3Encryption`](crate::model::S3Encryption).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) s3_encryption_mode: std::option::Option<crate::model::S3EncryptionMode>,
        pub(crate) kms_key_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The encryption mode to use for Amazon S3 data.</p>
        pub fn s3_encryption_mode(mut self, input: crate::model::S3EncryptionMode) -> Self {
            self.s3_encryption_mode = Some(input);
            self
        }
        /// <p>The encryption mode to use for Amazon S3 data.</p>
        pub fn set_s3_encryption_mode(
            mut self,
            input: std::option::Option<crate::model::S3EncryptionMode>,
        ) -> Self {
            self.s3_encryption_mode = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the KMS key to be used to encrypt the data.</p>
        pub fn kms_key_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.kms_key_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the KMS key to be used to encrypt the data.</p>
        pub fn set_kms_key_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.kms_key_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`S3Encryption`](crate::model::S3Encryption).
        pub fn build(self) -> crate::model::S3Encryption {
            crate::model::S3Encryption {
                s3_encryption_mode: self.s3_encryption_mode,
                kms_key_arn: self.kms_key_arn,
            }
        }
    }
}
impl S3Encryption {
    /// Creates a new builder-style object to manufacture [`S3Encryption`](crate::model::S3Encryption).
    pub fn builder() -> crate::model::s3_encryption::Builder {
        crate::model::s3_encryption::Builder::default()
    }
}

/// When writing a match expression against `S3EncryptionMode`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let s3encryptionmode = unimplemented!();
/// match s3encryptionmode {
///     S3EncryptionMode::Disabled => { /* ... */ },
///     S3EncryptionMode::Ssekms => { /* ... */ },
///     S3EncryptionMode::Sses3 => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `s3encryptionmode` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `S3EncryptionMode::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `S3EncryptionMode::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `S3EncryptionMode::NewFeature` is defined.
/// Specifically, when `s3encryptionmode` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `S3EncryptionMode::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum S3EncryptionMode {
    #[allow(missing_docs)] // documentation missing in model
    Disabled,
    #[allow(missing_docs)] // documentation missing in model
    Ssekms,
    #[allow(missing_docs)] // documentation missing in model
    Sses3,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for S3EncryptionMode {
    fn from(s: &str) -> Self {
        match s {
            "DISABLED" => S3EncryptionMode::Disabled,
            "SSE-KMS" => S3EncryptionMode::Ssekms,
            "SSE-S3" => S3EncryptionMode::Sses3,
            other => S3EncryptionMode::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for S3EncryptionMode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(S3EncryptionMode::from(s))
    }
}
impl S3EncryptionMode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            S3EncryptionMode::Disabled => "DISABLED",
            S3EncryptionMode::Ssekms => "SSE-KMS",
            S3EncryptionMode::Sses3 => "SSE-S3",
            S3EncryptionMode::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["DISABLED", "SSE-KMS", "SSE-S3"]
    }
}
impl AsRef<str> for S3EncryptionMode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `SchemaDiffType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let schemadifftype = unimplemented!();
/// match schemadifftype {
///     SchemaDiffType::SyntaxDiff => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `schemadifftype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `SchemaDiffType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `SchemaDiffType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `SchemaDiffType::NewFeature` is defined.
/// Specifically, when `schemadifftype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `SchemaDiffType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SchemaDiffType {
    #[allow(missing_docs)] // documentation missing in model
    SyntaxDiff,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for SchemaDiffType {
    fn from(s: &str) -> Self {
        match s {
            "SYNTAX_DIFF" => SchemaDiffType::SyntaxDiff,
            other => SchemaDiffType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for SchemaDiffType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SchemaDiffType::from(s))
    }
}
impl SchemaDiffType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            SchemaDiffType::SyntaxDiff => "SYNTAX_DIFF",
            SchemaDiffType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["SYNTAX_DIFF"]
    }
}
impl AsRef<str> for SchemaDiffType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `DataFormat`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let dataformat = unimplemented!();
/// match dataformat {
///     DataFormat::Avro => { /* ... */ },
///     DataFormat::Json => { /* ... */ },
///     DataFormat::Protobuf => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `dataformat` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `DataFormat::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `DataFormat::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `DataFormat::NewFeature` is defined.
/// Specifically, when `dataformat` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `DataFormat::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DataFormat {
    #[allow(missing_docs)] // documentation missing in model
    Avro,
    #[allow(missing_docs)] // documentation missing in model
    Json,
    #[allow(missing_docs)] // documentation missing in model
    Protobuf,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for DataFormat {
    fn from(s: &str) -> Self {
        match s {
            "AVRO" => DataFormat::Avro,
            "JSON" => DataFormat::Json,
            "PROTOBUF" => DataFormat::Protobuf,
            other => DataFormat::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for DataFormat {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DataFormat::from(s))
    }
}
impl DataFormat {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            DataFormat::Avro => "AVRO",
            DataFormat::Json => "JSON",
            DataFormat::Protobuf => "PROTOBUF",
            DataFormat::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["AVRO", "JSON", "PROTOBUF"]
    }
}
impl AsRef<str> for DataFormat {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A structure for returning a resource policy.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GluePolicy {
    /// <p>Contains the requested policy document, in JSON format.</p>
    #[doc(hidden)]
    pub policy_in_json: std::option::Option<std::string::String>,
    /// <p>Contains the hash value associated with this policy.</p>
    #[doc(hidden)]
    pub policy_hash: std::option::Option<std::string::String>,
    /// <p>The date and time at which the policy was created.</p>
    #[doc(hidden)]
    pub create_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The date and time at which the policy was last updated.</p>
    #[doc(hidden)]
    pub update_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl GluePolicy {
    /// <p>Contains the requested policy document, in JSON format.</p>
    pub fn policy_in_json(&self) -> std::option::Option<&str> {
        self.policy_in_json.as_deref()
    }
    /// <p>Contains the hash value associated with this policy.</p>
    pub fn policy_hash(&self) -> std::option::Option<&str> {
        self.policy_hash.as_deref()
    }
    /// <p>The date and time at which the policy was created.</p>
    pub fn create_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.create_time.as_ref()
    }
    /// <p>The date and time at which the policy was last updated.</p>
    pub fn update_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.update_time.as_ref()
    }
}
/// See [`GluePolicy`](crate::model::GluePolicy).
pub mod glue_policy {

    /// A builder for [`GluePolicy`](crate::model::GluePolicy).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) policy_in_json: std::option::Option<std::string::String>,
        pub(crate) policy_hash: std::option::Option<std::string::String>,
        pub(crate) create_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) update_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>Contains the requested policy document, in JSON format.</p>
        pub fn policy_in_json(mut self, input: impl Into<std::string::String>) -> Self {
            self.policy_in_json = Some(input.into());
            self
        }
        /// <p>Contains the requested policy document, in JSON format.</p>
        pub fn set_policy_in_json(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.policy_in_json = input;
            self
        }
        /// <p>Contains the hash value associated with this policy.</p>
        pub fn policy_hash(mut self, input: impl Into<std::string::String>) -> Self {
            self.policy_hash = Some(input.into());
            self
        }
        /// <p>Contains the hash value associated with this policy.</p>
        pub fn set_policy_hash(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.policy_hash = input;
            self
        }
        /// <p>The date and time at which the policy was created.</p>
        pub fn create_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.create_time = Some(input);
            self
        }
        /// <p>The date and time at which the policy was created.</p>
        pub fn set_create_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.create_time = input;
            self
        }
        /// <p>The date and time at which the policy was last updated.</p>
        pub fn update_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.update_time = Some(input);
            self
        }
        /// <p>The date and time at which the policy was last updated.</p>
        pub fn set_update_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.update_time = input;
            self
        }
        /// Consumes the builder and constructs a [`GluePolicy`](crate::model::GluePolicy).
        pub fn build(self) -> crate::model::GluePolicy {
            crate::model::GluePolicy {
                policy_in_json: self.policy_in_json,
                policy_hash: self.policy_hash,
                create_time: self.create_time,
                update_time: self.update_time,
            }
        }
    }
}
impl GluePolicy {
    /// Creates a new builder-style object to manufacture [`GluePolicy`](crate::model::GluePolicy).
    pub fn builder() -> crate::model::glue_policy::Builder {
        crate::model::glue_policy::Builder::default()
    }
}

/// When writing a match expression against `Language`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let language = unimplemented!();
/// match language {
///     Language::Python => { /* ... */ },
///     Language::Scala => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `language` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `Language::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `Language::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `Language::NewFeature` is defined.
/// Specifically, when `language` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `Language::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Language {
    #[allow(missing_docs)] // documentation missing in model
    Python,
    #[allow(missing_docs)] // documentation missing in model
    Scala,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for Language {
    fn from(s: &str) -> Self {
        match s {
            "PYTHON" => Language::Python,
            "SCALA" => Language::Scala,
            other => Language::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for Language {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(Language::from(s))
    }
}
impl Language {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            Language::Python => "PYTHON",
            Language::Scala => "SCALA",
            Language::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["PYTHON", "SCALA"]
    }
}
impl AsRef<str> for Language {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The location of resources.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Location {
    /// <p>A JDBC location.</p>
    #[doc(hidden)]
    pub jdbc: std::option::Option<std::vec::Vec<crate::model::CodeGenNodeArg>>,
    /// <p>An Amazon Simple Storage Service (Amazon S3) location.</p>
    #[doc(hidden)]
    pub s3: std::option::Option<std::vec::Vec<crate::model::CodeGenNodeArg>>,
    /// <p>An Amazon DynamoDB table location.</p>
    #[doc(hidden)]
    pub dynamo_db: std::option::Option<std::vec::Vec<crate::model::CodeGenNodeArg>>,
}
impl Location {
    /// <p>A JDBC location.</p>
    pub fn jdbc(&self) -> std::option::Option<&[crate::model::CodeGenNodeArg]> {
        self.jdbc.as_deref()
    }
    /// <p>An Amazon Simple Storage Service (Amazon S3) location.</p>
    pub fn s3(&self) -> std::option::Option<&[crate::model::CodeGenNodeArg]> {
        self.s3.as_deref()
    }
    /// <p>An Amazon DynamoDB table location.</p>
    pub fn dynamo_db(&self) -> std::option::Option<&[crate::model::CodeGenNodeArg]> {
        self.dynamo_db.as_deref()
    }
}
/// See [`Location`](crate::model::Location).
pub mod location {

    /// A builder for [`Location`](crate::model::Location).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) jdbc: std::option::Option<std::vec::Vec<crate::model::CodeGenNodeArg>>,
        pub(crate) s3: std::option::Option<std::vec::Vec<crate::model::CodeGenNodeArg>>,
        pub(crate) dynamo_db: std::option::Option<std::vec::Vec<crate::model::CodeGenNodeArg>>,
    }
    impl Builder {
        /// Appends an item to `jdbc`.
        ///
        /// To override the contents of this collection use [`set_jdbc`](Self::set_jdbc).
        ///
        /// <p>A JDBC location.</p>
        pub fn jdbc(mut self, input: crate::model::CodeGenNodeArg) -> Self {
            let mut v = self.jdbc.unwrap_or_default();
            v.push(input);
            self.jdbc = Some(v);
            self
        }
        /// <p>A JDBC location.</p>
        pub fn set_jdbc(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::CodeGenNodeArg>>,
        ) -> Self {
            self.jdbc = input;
            self
        }
        /// Appends an item to `s3`.
        ///
        /// To override the contents of this collection use [`set_s3`](Self::set_s3).
        ///
        /// <p>An Amazon Simple Storage Service (Amazon S3) location.</p>
        pub fn s3(mut self, input: crate::model::CodeGenNodeArg) -> Self {
            let mut v = self.s3.unwrap_or_default();
            v.push(input);
            self.s3 = Some(v);
            self
        }
        /// <p>An Amazon Simple Storage Service (Amazon S3) location.</p>
        pub fn set_s3(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::CodeGenNodeArg>>,
        ) -> Self {
            self.s3 = input;
            self
        }
        /// Appends an item to `dynamo_db`.
        ///
        /// To override the contents of this collection use [`set_dynamo_db`](Self::set_dynamo_db).
        ///
        /// <p>An Amazon DynamoDB table location.</p>
        pub fn dynamo_db(mut self, input: crate::model::CodeGenNodeArg) -> Self {
            let mut v = self.dynamo_db.unwrap_or_default();
            v.push(input);
            self.dynamo_db = Some(v);
            self
        }
        /// <p>An Amazon DynamoDB table location.</p>
        pub fn set_dynamo_db(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::CodeGenNodeArg>>,
        ) -> Self {
            self.dynamo_db = input;
            self
        }
        /// Consumes the builder and constructs a [`Location`](crate::model::Location).
        pub fn build(self) -> crate::model::Location {
            crate::model::Location {
                jdbc: self.jdbc,
                s3: self.s3,
                dynamo_db: self.dynamo_db,
            }
        }
    }
}
impl Location {
    /// Creates a new builder-style object to manufacture [`Location`](crate::model::Location).
    pub fn builder() -> crate::model::location::Builder {
        crate::model::location::Builder::default()
    }
}

/// <p>An argument or property of a node.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CodeGenNodeArg {
    /// <p>The name of the argument or property.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The value of the argument or property.</p>
    #[doc(hidden)]
    pub value: std::option::Option<std::string::String>,
    /// <p>True if the value is used as a parameter.</p>
    #[doc(hidden)]
    pub param: bool,
}
impl CodeGenNodeArg {
    /// <p>The name of the argument or property.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The value of the argument or property.</p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
    /// <p>True if the value is used as a parameter.</p>
    pub fn param(&self) -> bool {
        self.param
    }
}
/// See [`CodeGenNodeArg`](crate::model::CodeGenNodeArg).
pub mod code_gen_node_arg {

    /// A builder for [`CodeGenNodeArg`](crate::model::CodeGenNodeArg).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
        pub(crate) param: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The name of the argument or property.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the argument or property.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The value of the argument or property.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>The value of the argument or property.</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// <p>True if the value is used as a parameter.</p>
        pub fn param(mut self, input: bool) -> Self {
            self.param = Some(input);
            self
        }
        /// <p>True if the value is used as a parameter.</p>
        pub fn set_param(mut self, input: std::option::Option<bool>) -> Self {
            self.param = input;
            self
        }
        /// Consumes the builder and constructs a [`CodeGenNodeArg`](crate::model::CodeGenNodeArg).
        pub fn build(self) -> crate::model::CodeGenNodeArg {
            crate::model::CodeGenNodeArg {
                name: self.name,
                value: self.value,
                param: self.param.unwrap_or_default(),
            }
        }
    }
}
impl CodeGenNodeArg {
    /// Creates a new builder-style object to manufacture [`CodeGenNodeArg`](crate::model::CodeGenNodeArg).
    pub fn builder() -> crate::model::code_gen_node_arg::Builder {
        crate::model::code_gen_node_arg::Builder::default()
    }
}

/// <p>Specifies a table definition in the Glue Data Catalog.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CatalogEntry {
    /// <p>The database in which the table metadata resides.</p>
    #[doc(hidden)]
    pub database_name: std::option::Option<std::string::String>,
    /// <p>The name of the table in question.</p>
    #[doc(hidden)]
    pub table_name: std::option::Option<std::string::String>,
}
impl CatalogEntry {
    /// <p>The database in which the table metadata resides.</p>
    pub fn database_name(&self) -> std::option::Option<&str> {
        self.database_name.as_deref()
    }
    /// <p>The name of the table in question.</p>
    pub fn table_name(&self) -> std::option::Option<&str> {
        self.table_name.as_deref()
    }
}
/// See [`CatalogEntry`](crate::model::CatalogEntry).
pub mod catalog_entry {

    /// A builder for [`CatalogEntry`](crate::model::CatalogEntry).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) database_name: std::option::Option<std::string::String>,
        pub(crate) table_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The database in which the table metadata resides.</p>
        pub fn database_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.database_name = Some(input.into());
            self
        }
        /// <p>The database in which the table metadata resides.</p>
        pub fn set_database_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.database_name = input;
            self
        }
        /// <p>The name of the table in question.</p>
        pub fn table_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.table_name = Some(input.into());
            self
        }
        /// <p>The name of the table in question.</p>
        pub fn set_table_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.table_name = input;
            self
        }
        /// Consumes the builder and constructs a [`CatalogEntry`](crate::model::CatalogEntry).
        pub fn build(self) -> crate::model::CatalogEntry {
            crate::model::CatalogEntry {
                database_name: self.database_name,
                table_name: self.table_name,
            }
        }
    }
}
impl CatalogEntry {
    /// Creates a new builder-style object to manufacture [`CatalogEntry`](crate::model::CatalogEntry).
    pub fn builder() -> crate::model::catalog_entry::Builder {
        crate::model::catalog_entry::Builder::default()
    }
}

/// <p>Defines a mapping.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct MappingEntry {
    /// <p>The name of the source table.</p>
    #[doc(hidden)]
    pub source_table: std::option::Option<std::string::String>,
    /// <p>The source path.</p>
    #[doc(hidden)]
    pub source_path: std::option::Option<std::string::String>,
    /// <p>The source type.</p>
    #[doc(hidden)]
    pub source_type: std::option::Option<std::string::String>,
    /// <p>The target table.</p>
    #[doc(hidden)]
    pub target_table: std::option::Option<std::string::String>,
    /// <p>The target path.</p>
    #[doc(hidden)]
    pub target_path: std::option::Option<std::string::String>,
    /// <p>The target type.</p>
    #[doc(hidden)]
    pub target_type: std::option::Option<std::string::String>,
}
impl MappingEntry {
    /// <p>The name of the source table.</p>
    pub fn source_table(&self) -> std::option::Option<&str> {
        self.source_table.as_deref()
    }
    /// <p>The source path.</p>
    pub fn source_path(&self) -> std::option::Option<&str> {
        self.source_path.as_deref()
    }
    /// <p>The source type.</p>
    pub fn source_type(&self) -> std::option::Option<&str> {
        self.source_type.as_deref()
    }
    /// <p>The target table.</p>
    pub fn target_table(&self) -> std::option::Option<&str> {
        self.target_table.as_deref()
    }
    /// <p>The target path.</p>
    pub fn target_path(&self) -> std::option::Option<&str> {
        self.target_path.as_deref()
    }
    /// <p>The target type.</p>
    pub fn target_type(&self) -> std::option::Option<&str> {
        self.target_type.as_deref()
    }
}
/// See [`MappingEntry`](crate::model::MappingEntry).
pub mod mapping_entry {

    /// A builder for [`MappingEntry`](crate::model::MappingEntry).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) source_table: std::option::Option<std::string::String>,
        pub(crate) source_path: std::option::Option<std::string::String>,
        pub(crate) source_type: std::option::Option<std::string::String>,
        pub(crate) target_table: std::option::Option<std::string::String>,
        pub(crate) target_path: std::option::Option<std::string::String>,
        pub(crate) target_type: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the source table.</p>
        pub fn source_table(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_table = Some(input.into());
            self
        }
        /// <p>The name of the source table.</p>
        pub fn set_source_table(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.source_table = input;
            self
        }
        /// <p>The source path.</p>
        pub fn source_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_path = Some(input.into());
            self
        }
        /// <p>The source path.</p>
        pub fn set_source_path(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.source_path = input;
            self
        }
        /// <p>The source type.</p>
        pub fn source_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_type = Some(input.into());
            self
        }
        /// <p>The source type.</p>
        pub fn set_source_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.source_type = input;
            self
        }
        /// <p>The target table.</p>
        pub fn target_table(mut self, input: impl Into<std::string::String>) -> Self {
            self.target_table = Some(input.into());
            self
        }
        /// <p>The target table.</p>
        pub fn set_target_table(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.target_table = input;
            self
        }
        /// <p>The target path.</p>
        pub fn target_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.target_path = Some(input.into());
            self
        }
        /// <p>The target path.</p>
        pub fn set_target_path(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.target_path = input;
            self
        }
        /// <p>The target type.</p>
        pub fn target_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.target_type = Some(input.into());
            self
        }
        /// <p>The target type.</p>
        pub fn set_target_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.target_type = input;
            self
        }
        /// Consumes the builder and constructs a [`MappingEntry`](crate::model::MappingEntry).
        pub fn build(self) -> crate::model::MappingEntry {
            crate::model::MappingEntry {
                source_table: self.source_table,
                source_path: self.source_path,
                source_type: self.source_type,
                target_table: self.target_table,
                target_path: self.target_path,
                target_type: self.target_type,
            }
        }
    }
}
impl MappingEntry {
    /// Creates a new builder-style object to manufacture [`MappingEntry`](crate::model::MappingEntry).
    pub fn builder() -> crate::model::mapping_entry::Builder {
        crate::model::mapping_entry::Builder::default()
    }
}

/// <p>A descriptor for a partition index in a table.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PartitionIndexDescriptor {
    /// <p>The name of the partition index.</p>
    #[doc(hidden)]
    pub index_name: std::option::Option<std::string::String>,
    /// <p>A list of one or more keys, as <code>KeySchemaElement</code> structures, for the partition index.</p>
    #[doc(hidden)]
    pub keys: std::option::Option<std::vec::Vec<crate::model::KeySchemaElement>>,
    /// <p>The status of the partition index. </p>
    /// <p>The possible statuses are:</p>
    /// <ul>
    /// <li> <p>CREATING: The index is being created. When an index is in a CREATING state, the index or its table cannot be deleted.</p> </li>
    /// <li> <p>ACTIVE: The index creation succeeds.</p> </li>
    /// <li> <p>FAILED: The index creation fails. </p> </li>
    /// <li> <p>DELETING: The index is deleted from the list of indexes.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub index_status: std::option::Option<crate::model::PartitionIndexStatus>,
    /// <p>A list of errors that can occur when registering partition indexes for an existing table.</p>
    #[doc(hidden)]
    pub backfill_errors: std::option::Option<std::vec::Vec<crate::model::BackfillError>>,
}
impl PartitionIndexDescriptor {
    /// <p>The name of the partition index.</p>
    pub fn index_name(&self) -> std::option::Option<&str> {
        self.index_name.as_deref()
    }
    /// <p>A list of one or more keys, as <code>KeySchemaElement</code> structures, for the partition index.</p>
    pub fn keys(&self) -> std::option::Option<&[crate::model::KeySchemaElement]> {
        self.keys.as_deref()
    }
    /// <p>The status of the partition index. </p>
    /// <p>The possible statuses are:</p>
    /// <ul>
    /// <li> <p>CREATING: The index is being created. When an index is in a CREATING state, the index or its table cannot be deleted.</p> </li>
    /// <li> <p>ACTIVE: The index creation succeeds.</p> </li>
    /// <li> <p>FAILED: The index creation fails. </p> </li>
    /// <li> <p>DELETING: The index is deleted from the list of indexes.</p> </li>
    /// </ul>
    pub fn index_status(&self) -> std::option::Option<&crate::model::PartitionIndexStatus> {
        self.index_status.as_ref()
    }
    /// <p>A list of errors that can occur when registering partition indexes for an existing table.</p>
    pub fn backfill_errors(&self) -> std::option::Option<&[crate::model::BackfillError]> {
        self.backfill_errors.as_deref()
    }
}
/// See [`PartitionIndexDescriptor`](crate::model::PartitionIndexDescriptor).
pub mod partition_index_descriptor {

    /// A builder for [`PartitionIndexDescriptor`](crate::model::PartitionIndexDescriptor).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) index_name: std::option::Option<std::string::String>,
        pub(crate) keys: std::option::Option<std::vec::Vec<crate::model::KeySchemaElement>>,
        pub(crate) index_status: std::option::Option<crate::model::PartitionIndexStatus>,
        pub(crate) backfill_errors: std::option::Option<std::vec::Vec<crate::model::BackfillError>>,
    }
    impl Builder {
        /// <p>The name of the partition index.</p>
        pub fn index_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.index_name = Some(input.into());
            self
        }
        /// <p>The name of the partition index.</p>
        pub fn set_index_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.index_name = input;
            self
        }
        /// Appends an item to `keys`.
        ///
        /// To override the contents of this collection use [`set_keys`](Self::set_keys).
        ///
        /// <p>A list of one or more keys, as <code>KeySchemaElement</code> structures, for the partition index.</p>
        pub fn keys(mut self, input: crate::model::KeySchemaElement) -> Self {
            let mut v = self.keys.unwrap_or_default();
            v.push(input);
            self.keys = Some(v);
            self
        }
        /// <p>A list of one or more keys, as <code>KeySchemaElement</code> structures, for the partition index.</p>
        pub fn set_keys(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::KeySchemaElement>>,
        ) -> Self {
            self.keys = input;
            self
        }
        /// <p>The status of the partition index. </p>
        /// <p>The possible statuses are:</p>
        /// <ul>
        /// <li> <p>CREATING: The index is being created. When an index is in a CREATING state, the index or its table cannot be deleted.</p> </li>
        /// <li> <p>ACTIVE: The index creation succeeds.</p> </li>
        /// <li> <p>FAILED: The index creation fails. </p> </li>
        /// <li> <p>DELETING: The index is deleted from the list of indexes.</p> </li>
        /// </ul>
        pub fn index_status(mut self, input: crate::model::PartitionIndexStatus) -> Self {
            self.index_status = Some(input);
            self
        }
        /// <p>The status of the partition index. </p>
        /// <p>The possible statuses are:</p>
        /// <ul>
        /// <li> <p>CREATING: The index is being created. When an index is in a CREATING state, the index or its table cannot be deleted.</p> </li>
        /// <li> <p>ACTIVE: The index creation succeeds.</p> </li>
        /// <li> <p>FAILED: The index creation fails. </p> </li>
        /// <li> <p>DELETING: The index is deleted from the list of indexes.</p> </li>
        /// </ul>
        pub fn set_index_status(
            mut self,
            input: std::option::Option<crate::model::PartitionIndexStatus>,
        ) -> Self {
            self.index_status = input;
            self
        }
        /// Appends an item to `backfill_errors`.
        ///
        /// To override the contents of this collection use [`set_backfill_errors`](Self::set_backfill_errors).
        ///
        /// <p>A list of errors that can occur when registering partition indexes for an existing table.</p>
        pub fn backfill_errors(mut self, input: crate::model::BackfillError) -> Self {
            let mut v = self.backfill_errors.unwrap_or_default();
            v.push(input);
            self.backfill_errors = Some(v);
            self
        }
        /// <p>A list of errors that can occur when registering partition indexes for an existing table.</p>
        pub fn set_backfill_errors(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::BackfillError>>,
        ) -> Self {
            self.backfill_errors = input;
            self
        }
        /// Consumes the builder and constructs a [`PartitionIndexDescriptor`](crate::model::PartitionIndexDescriptor).
        pub fn build(self) -> crate::model::PartitionIndexDescriptor {
            crate::model::PartitionIndexDescriptor {
                index_name: self.index_name,
                keys: self.keys,
                index_status: self.index_status,
                backfill_errors: self.backfill_errors,
            }
        }
    }
}
impl PartitionIndexDescriptor {
    /// Creates a new builder-style object to manufacture [`PartitionIndexDescriptor`](crate::model::PartitionIndexDescriptor).
    pub fn builder() -> crate::model::partition_index_descriptor::Builder {
        crate::model::partition_index_descriptor::Builder::default()
    }
}

/// <p>A list of errors that can occur when registering partition indexes for an existing table.</p>
/// <p>These errors give the details about why an index registration failed and provide a limited number of partitions in the response, so that you can fix the partitions at fault and try registering the index again. The most common set of errors that can occur are categorized as follows:</p>
/// <ul>
/// <li> <p>EncryptedPartitionError: The partitions are encrypted.</p> </li>
/// <li> <p>InvalidPartitionTypeDataError: The partition value doesn't match the data type for that partition column.</p> </li>
/// <li> <p>MissingPartitionValueError: The partitions are encrypted.</p> </li>
/// <li> <p>UnsupportedPartitionCharacterError: Characters inside the partition value are not supported. For example: U+0000 , U+0001, U+0002.</p> </li>
/// <li> <p>InternalError: Any error which does not belong to other error codes.</p> </li>
/// </ul>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BackfillError {
    /// <p>The error code for an error that occurred when registering partition indexes for an existing table.</p>
    #[doc(hidden)]
    pub code: std::option::Option<crate::model::BackfillErrorCode>,
    /// <p>A list of a limited number of partitions in the response.</p>
    #[doc(hidden)]
    pub partitions: std::option::Option<std::vec::Vec<crate::model::PartitionValueList>>,
}
impl BackfillError {
    /// <p>The error code for an error that occurred when registering partition indexes for an existing table.</p>
    pub fn code(&self) -> std::option::Option<&crate::model::BackfillErrorCode> {
        self.code.as_ref()
    }
    /// <p>A list of a limited number of partitions in the response.</p>
    pub fn partitions(&self) -> std::option::Option<&[crate::model::PartitionValueList]> {
        self.partitions.as_deref()
    }
}
/// See [`BackfillError`](crate::model::BackfillError).
pub mod backfill_error {

    /// A builder for [`BackfillError`](crate::model::BackfillError).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) code: std::option::Option<crate::model::BackfillErrorCode>,
        pub(crate) partitions: std::option::Option<std::vec::Vec<crate::model::PartitionValueList>>,
    }
    impl Builder {
        /// <p>The error code for an error that occurred when registering partition indexes for an existing table.</p>
        pub fn code(mut self, input: crate::model::BackfillErrorCode) -> Self {
            self.code = Some(input);
            self
        }
        /// <p>The error code for an error that occurred when registering partition indexes for an existing table.</p>
        pub fn set_code(
            mut self,
            input: std::option::Option<crate::model::BackfillErrorCode>,
        ) -> Self {
            self.code = input;
            self
        }
        /// Appends an item to `partitions`.
        ///
        /// To override the contents of this collection use [`set_partitions`](Self::set_partitions).
        ///
        /// <p>A list of a limited number of partitions in the response.</p>
        pub fn partitions(mut self, input: crate::model::PartitionValueList) -> Self {
            let mut v = self.partitions.unwrap_or_default();
            v.push(input);
            self.partitions = Some(v);
            self
        }
        /// <p>A list of a limited number of partitions in the response.</p>
        pub fn set_partitions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::PartitionValueList>>,
        ) -> Self {
            self.partitions = input;
            self
        }
        /// Consumes the builder and constructs a [`BackfillError`](crate::model::BackfillError).
        pub fn build(self) -> crate::model::BackfillError {
            crate::model::BackfillError {
                code: self.code,
                partitions: self.partitions,
            }
        }
    }
}
impl BackfillError {
    /// Creates a new builder-style object to manufacture [`BackfillError`](crate::model::BackfillError).
    pub fn builder() -> crate::model::backfill_error::Builder {
        crate::model::backfill_error::Builder::default()
    }
}

/// <p>Contains a list of values defining partitions.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PartitionValueList {
    /// <p>The list of values.</p>
    #[doc(hidden)]
    pub values: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl PartitionValueList {
    /// <p>The list of values.</p>
    pub fn values(&self) -> std::option::Option<&[std::string::String]> {
        self.values.as_deref()
    }
}
/// See [`PartitionValueList`](crate::model::PartitionValueList).
pub mod partition_value_list {

    /// A builder for [`PartitionValueList`](crate::model::PartitionValueList).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) values: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// Appends an item to `values`.
        ///
        /// To override the contents of this collection use [`set_values`](Self::set_values).
        ///
        /// <p>The list of values.</p>
        pub fn values(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.values.unwrap_or_default();
            v.push(input.into());
            self.values = Some(v);
            self
        }
        /// <p>The list of values.</p>
        pub fn set_values(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.values = input;
            self
        }
        /// Consumes the builder and constructs a [`PartitionValueList`](crate::model::PartitionValueList).
        pub fn build(self) -> crate::model::PartitionValueList {
            crate::model::PartitionValueList {
                values: self.values,
            }
        }
    }
}
impl PartitionValueList {
    /// Creates a new builder-style object to manufacture [`PartitionValueList`](crate::model::PartitionValueList).
    pub fn builder() -> crate::model::partition_value_list::Builder {
        crate::model::partition_value_list::Builder::default()
    }
}

/// When writing a match expression against `BackfillErrorCode`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let backfillerrorcode = unimplemented!();
/// match backfillerrorcode {
///     BackfillErrorCode::EncryptedPartitionError => { /* ... */ },
///     BackfillErrorCode::InternalError => { /* ... */ },
///     BackfillErrorCode::InvalidPartitionTypeDataError => { /* ... */ },
///     BackfillErrorCode::MissingPartitionValueError => { /* ... */ },
///     BackfillErrorCode::UnsupportedPartitionCharacterError => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `backfillerrorcode` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `BackfillErrorCode::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `BackfillErrorCode::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `BackfillErrorCode::NewFeature` is defined.
/// Specifically, when `backfillerrorcode` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `BackfillErrorCode::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum BackfillErrorCode {
    #[allow(missing_docs)] // documentation missing in model
    EncryptedPartitionError,
    #[allow(missing_docs)] // documentation missing in model
    InternalError,
    #[allow(missing_docs)] // documentation missing in model
    InvalidPartitionTypeDataError,
    #[allow(missing_docs)] // documentation missing in model
    MissingPartitionValueError,
    #[allow(missing_docs)] // documentation missing in model
    UnsupportedPartitionCharacterError,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for BackfillErrorCode {
    fn from(s: &str) -> Self {
        match s {
            "ENCRYPTED_PARTITION_ERROR" => BackfillErrorCode::EncryptedPartitionError,
            "INTERNAL_ERROR" => BackfillErrorCode::InternalError,
            "INVALID_PARTITION_TYPE_DATA_ERROR" => BackfillErrorCode::InvalidPartitionTypeDataError,
            "MISSING_PARTITION_VALUE_ERROR" => BackfillErrorCode::MissingPartitionValueError,
            "UNSUPPORTED_PARTITION_CHARACTER_ERROR" => {
                BackfillErrorCode::UnsupportedPartitionCharacterError
            }
            other => {
                BackfillErrorCode::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for BackfillErrorCode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(BackfillErrorCode::from(s))
    }
}
impl BackfillErrorCode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            BackfillErrorCode::EncryptedPartitionError => "ENCRYPTED_PARTITION_ERROR",
            BackfillErrorCode::InternalError => "INTERNAL_ERROR",
            BackfillErrorCode::InvalidPartitionTypeDataError => "INVALID_PARTITION_TYPE_DATA_ERROR",
            BackfillErrorCode::MissingPartitionValueError => "MISSING_PARTITION_VALUE_ERROR",
            BackfillErrorCode::UnsupportedPartitionCharacterError => {
                "UNSUPPORTED_PARTITION_CHARACTER_ERROR"
            }
            BackfillErrorCode::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "ENCRYPTED_PARTITION_ERROR",
            "INTERNAL_ERROR",
            "INVALID_PARTITION_TYPE_DATA_ERROR",
            "MISSING_PARTITION_VALUE_ERROR",
            "UNSUPPORTED_PARTITION_CHARACTER_ERROR",
        ]
    }
}
impl AsRef<str> for BackfillErrorCode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `PartitionIndexStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let partitionindexstatus = unimplemented!();
/// match partitionindexstatus {
///     PartitionIndexStatus::Active => { /* ... */ },
///     PartitionIndexStatus::Creating => { /* ... */ },
///     PartitionIndexStatus::Deleting => { /* ... */ },
///     PartitionIndexStatus::Failed => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `partitionindexstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `PartitionIndexStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `PartitionIndexStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `PartitionIndexStatus::NewFeature` is defined.
/// Specifically, when `partitionindexstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `PartitionIndexStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum PartitionIndexStatus {
    #[allow(missing_docs)] // documentation missing in model
    Active,
    #[allow(missing_docs)] // documentation missing in model
    Creating,
    #[allow(missing_docs)] // documentation missing in model
    Deleting,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for PartitionIndexStatus {
    fn from(s: &str) -> Self {
        match s {
            "ACTIVE" => PartitionIndexStatus::Active,
            "CREATING" => PartitionIndexStatus::Creating,
            "DELETING" => PartitionIndexStatus::Deleting,
            "FAILED" => PartitionIndexStatus::Failed,
            other => {
                PartitionIndexStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for PartitionIndexStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(PartitionIndexStatus::from(s))
    }
}
impl PartitionIndexStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            PartitionIndexStatus::Active => "ACTIVE",
            PartitionIndexStatus::Creating => "CREATING",
            PartitionIndexStatus::Deleting => "DELETING",
            PartitionIndexStatus::Failed => "FAILED",
            PartitionIndexStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ACTIVE", "CREATING", "DELETING", "FAILED"]
    }
}
impl AsRef<str> for PartitionIndexStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A partition key pair consisting of a name and a type.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct KeySchemaElement {
    /// <p>The name of a partition key.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The type of a partition key.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<std::string::String>,
}
impl KeySchemaElement {
    /// <p>The name of a partition key.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The type of a partition key.</p>
    pub fn r#type(&self) -> std::option::Option<&str> {
        self.r#type.as_deref()
    }
}
/// See [`KeySchemaElement`](crate::model::KeySchemaElement).
pub mod key_schema_element {

    /// A builder for [`KeySchemaElement`](crate::model::KeySchemaElement).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of a partition key.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of a partition key.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The type of a partition key.</p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        /// <p>The type of a partition key.</p>
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// Consumes the builder and constructs a [`KeySchemaElement`](crate::model::KeySchemaElement).
        pub fn build(self) -> crate::model::KeySchemaElement {
            crate::model::KeySchemaElement {
                name: self.name,
                r#type: self.r#type,
            }
        }
    }
}
impl KeySchemaElement {
    /// Creates a new builder-style object to manufacture [`KeySchemaElement`](crate::model::KeySchemaElement).
    pub fn builder() -> crate::model::key_schema_element::Builder {
        crate::model::key_schema_element::Builder::default()
    }
}

/// <p>A structure for a machine learning transform.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct MlTransform {
    /// <p>The unique transform ID that is generated for the machine learning transform. The ID is guaranteed to be unique and does not change.</p>
    #[doc(hidden)]
    pub transform_id: std::option::Option<std::string::String>,
    /// <p>A user-defined name for the machine learning transform. Names are not guaranteed unique and can be changed at any time.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>A user-defined, long-form description text for the machine learning transform. Descriptions are not guaranteed to be unique and can be changed at any time.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The current status of the machine learning transform.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::TransformStatusType>,
    /// <p>A timestamp. The time and date that this machine learning transform was created.</p>
    #[doc(hidden)]
    pub created_on: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>A timestamp. The last point in time when this machine learning transform was modified.</p>
    #[doc(hidden)]
    pub last_modified_on: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>A list of Glue table definitions used by the transform.</p>
    #[doc(hidden)]
    pub input_record_tables: std::option::Option<std::vec::Vec<crate::model::GlueTable>>,
    /// <p>A <code>TransformParameters</code> object. You can use parameters to tune (customize) the behavior of the machine learning transform by specifying what data it learns from and your preference on various tradeoffs (such as precious vs. recall, or accuracy vs. cost).</p>
    #[doc(hidden)]
    pub parameters: std::option::Option<crate::model::TransformParameters>,
    /// <p>An <code>EvaluationMetrics</code> object. Evaluation metrics provide an estimate of the quality of your machine learning transform.</p>
    #[doc(hidden)]
    pub evaluation_metrics: std::option::Option<crate::model::EvaluationMetrics>,
    /// <p>A count identifier for the labeling files generated by Glue for this transform. As you create a better transform, you can iteratively download, label, and upload the labeling file.</p>
    #[doc(hidden)]
    pub label_count: i32,
    /// <p>A map of key-value pairs representing the columns and data types that this transform can run against. Has an upper bound of 100 columns.</p>
    #[doc(hidden)]
    pub schema: std::option::Option<std::vec::Vec<crate::model::SchemaColumn>>,
    /// <p>The name or Amazon Resource Name (ARN) of the IAM role with the required permissions. The required permissions include both Glue service role permissions to Glue resources, and Amazon S3 permissions required by the transform. </p>
    /// <ul>
    /// <li> <p>This role needs Glue service role permissions to allow access to resources in Glue. See <a href="https://docs.aws.amazon.com/glue/latest/dg/attach-policy-iam-user.html">Attach a Policy to IAM Users That Access Glue</a>.</p> </li>
    /// <li> <p>This role needs permission to your Amazon Simple Storage Service (Amazon S3) sources, targets, temporary directory, scripts, and any libraries used by the task run for this transform.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub role: std::option::Option<std::string::String>,
    /// <p>This value determines which version of Glue this machine learning transform is compatible with. Glue 1.0 is recommended for most customers. If the value is not set, the Glue compatibility defaults to Glue 0.9. For more information, see <a href="https://docs.aws.amazon.com/glue/latest/dg/release-notes.html#release-notes-versions">Glue Versions</a> in the developer guide.</p>
    #[doc(hidden)]
    pub glue_version: std::option::Option<std::string::String>,
    /// <p>The number of Glue data processing units (DPUs) that are allocated to task runs for this transform. You can allocate from 2 to 100 DPUs; the default is 10. A DPU is a relative measure of processing power that consists of 4 vCPUs of compute capacity and 16 GB of memory. For more information, see the <a href="http://aws.amazon.com/glue/pricing/">Glue pricing page</a>. </p>
    /// <p> <code>MaxCapacity</code> is a mutually exclusive option with <code>NumberOfWorkers</code> and <code>WorkerType</code>.</p>
    /// <ul>
    /// <li> <p>If either <code>NumberOfWorkers</code> or <code>WorkerType</code> is set, then <code>MaxCapacity</code> cannot be set.</p> </li>
    /// <li> <p>If <code>MaxCapacity</code> is set then neither <code>NumberOfWorkers</code> or <code>WorkerType</code> can be set.</p> </li>
    /// <li> <p>If <code>WorkerType</code> is set, then <code>NumberOfWorkers</code> is required (and vice versa).</p> </li>
    /// <li> <p> <code>MaxCapacity</code> and <code>NumberOfWorkers</code> must both be at least 1.</p> </li>
    /// </ul>
    /// <p>When the <code>WorkerType</code> field is set to a value other than <code>Standard</code>, the <code>MaxCapacity</code> field is set automatically and becomes read-only.</p>
    #[doc(hidden)]
    pub max_capacity: std::option::Option<f64>,
    /// <p>The type of predefined worker that is allocated when a task of this transform runs. Accepts a value of Standard, G.1X, or G.2X.</p>
    /// <ul>
    /// <li> <p>For the <code>Standard</code> worker type, each worker provides 4 vCPU, 16 GB of memory and a 50GB disk, and 2 executors per worker.</p> </li>
    /// <li> <p>For the <code>G.1X</code> worker type, each worker provides 4 vCPU, 16 GB of memory and a 64GB disk, and 1 executor per worker.</p> </li>
    /// <li> <p>For the <code>G.2X</code> worker type, each worker provides 8 vCPU, 32 GB of memory and a 128GB disk, and 1 executor per worker.</p> </li>
    /// </ul>
    /// <p> <code>MaxCapacity</code> is a mutually exclusive option with <code>NumberOfWorkers</code> and <code>WorkerType</code>.</p>
    /// <ul>
    /// <li> <p>If either <code>NumberOfWorkers</code> or <code>WorkerType</code> is set, then <code>MaxCapacity</code> cannot be set.</p> </li>
    /// <li> <p>If <code>MaxCapacity</code> is set then neither <code>NumberOfWorkers</code> or <code>WorkerType</code> can be set.</p> </li>
    /// <li> <p>If <code>WorkerType</code> is set, then <code>NumberOfWorkers</code> is required (and vice versa).</p> </li>
    /// <li> <p> <code>MaxCapacity</code> and <code>NumberOfWorkers</code> must both be at least 1.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub worker_type: std::option::Option<crate::model::WorkerType>,
    /// <p>The number of workers of a defined <code>workerType</code> that are allocated when a task of the transform runs.</p>
    /// <p>If <code>WorkerType</code> is set, then <code>NumberOfWorkers</code> is required (and vice versa).</p>
    #[doc(hidden)]
    pub number_of_workers: std::option::Option<i32>,
    /// <p>The timeout in minutes of the machine learning transform.</p>
    #[doc(hidden)]
    pub timeout: std::option::Option<i32>,
    /// <p>The maximum number of times to retry after an <code>MLTaskRun</code> of the machine learning transform fails.</p>
    #[doc(hidden)]
    pub max_retries: std::option::Option<i32>,
    /// <p>The encryption-at-rest settings of the transform that apply to accessing user data. Machine learning transforms can access user data encrypted in Amazon S3 using KMS.</p>
    #[doc(hidden)]
    pub transform_encryption: std::option::Option<crate::model::TransformEncryption>,
}
impl MlTransform {
    /// <p>The unique transform ID that is generated for the machine learning transform. The ID is guaranteed to be unique and does not change.</p>
    pub fn transform_id(&self) -> std::option::Option<&str> {
        self.transform_id.as_deref()
    }
    /// <p>A user-defined name for the machine learning transform. Names are not guaranteed unique and can be changed at any time.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>A user-defined, long-form description text for the machine learning transform. Descriptions are not guaranteed to be unique and can be changed at any time.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The current status of the machine learning transform.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::TransformStatusType> {
        self.status.as_ref()
    }
    /// <p>A timestamp. The time and date that this machine learning transform was created.</p>
    pub fn created_on(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_on.as_ref()
    }
    /// <p>A timestamp. The last point in time when this machine learning transform was modified.</p>
    pub fn last_modified_on(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_modified_on.as_ref()
    }
    /// <p>A list of Glue table definitions used by the transform.</p>
    pub fn input_record_tables(&self) -> std::option::Option<&[crate::model::GlueTable]> {
        self.input_record_tables.as_deref()
    }
    /// <p>A <code>TransformParameters</code> object. You can use parameters to tune (customize) the behavior of the machine learning transform by specifying what data it learns from and your preference on various tradeoffs (such as precious vs. recall, or accuracy vs. cost).</p>
    pub fn parameters(&self) -> std::option::Option<&crate::model::TransformParameters> {
        self.parameters.as_ref()
    }
    /// <p>An <code>EvaluationMetrics</code> object. Evaluation metrics provide an estimate of the quality of your machine learning transform.</p>
    pub fn evaluation_metrics(&self) -> std::option::Option<&crate::model::EvaluationMetrics> {
        self.evaluation_metrics.as_ref()
    }
    /// <p>A count identifier for the labeling files generated by Glue for this transform. As you create a better transform, you can iteratively download, label, and upload the labeling file.</p>
    pub fn label_count(&self) -> i32 {
        self.label_count
    }
    /// <p>A map of key-value pairs representing the columns and data types that this transform can run against. Has an upper bound of 100 columns.</p>
    pub fn schema(&self) -> std::option::Option<&[crate::model::SchemaColumn]> {
        self.schema.as_deref()
    }
    /// <p>The name or Amazon Resource Name (ARN) of the IAM role with the required permissions. The required permissions include both Glue service role permissions to Glue resources, and Amazon S3 permissions required by the transform. </p>
    /// <ul>
    /// <li> <p>This role needs Glue service role permissions to allow access to resources in Glue. See <a href="https://docs.aws.amazon.com/glue/latest/dg/attach-policy-iam-user.html">Attach a Policy to IAM Users That Access Glue</a>.</p> </li>
    /// <li> <p>This role needs permission to your Amazon Simple Storage Service (Amazon S3) sources, targets, temporary directory, scripts, and any libraries used by the task run for this transform.</p> </li>
    /// </ul>
    pub fn role(&self) -> std::option::Option<&str> {
        self.role.as_deref()
    }
    /// <p>This value determines which version of Glue this machine learning transform is compatible with. Glue 1.0 is recommended for most customers. If the value is not set, the Glue compatibility defaults to Glue 0.9. For more information, see <a href="https://docs.aws.amazon.com/glue/latest/dg/release-notes.html#release-notes-versions">Glue Versions</a> in the developer guide.</p>
    pub fn glue_version(&self) -> std::option::Option<&str> {
        self.glue_version.as_deref()
    }
    /// <p>The number of Glue data processing units (DPUs) that are allocated to task runs for this transform. You can allocate from 2 to 100 DPUs; the default is 10. A DPU is a relative measure of processing power that consists of 4 vCPUs of compute capacity and 16 GB of memory. For more information, see the <a href="http://aws.amazon.com/glue/pricing/">Glue pricing page</a>. </p>
    /// <p> <code>MaxCapacity</code> is a mutually exclusive option with <code>NumberOfWorkers</code> and <code>WorkerType</code>.</p>
    /// <ul>
    /// <li> <p>If either <code>NumberOfWorkers</code> or <code>WorkerType</code> is set, then <code>MaxCapacity</code> cannot be set.</p> </li>
    /// <li> <p>If <code>MaxCapacity</code> is set then neither <code>NumberOfWorkers</code> or <code>WorkerType</code> can be set.</p> </li>
    /// <li> <p>If <code>WorkerType</code> is set, then <code>NumberOfWorkers</code> is required (and vice versa).</p> </li>
    /// <li> <p> <code>MaxCapacity</code> and <code>NumberOfWorkers</code> must both be at least 1.</p> </li>
    /// </ul>
    /// <p>When the <code>WorkerType</code> field is set to a value other than <code>Standard</code>, the <code>MaxCapacity</code> field is set automatically and becomes read-only.</p>
    pub fn max_capacity(&self) -> std::option::Option<f64> {
        self.max_capacity
    }
    /// <p>The type of predefined worker that is allocated when a task of this transform runs. Accepts a value of Standard, G.1X, or G.2X.</p>
    /// <ul>
    /// <li> <p>For the <code>Standard</code> worker type, each worker provides 4 vCPU, 16 GB of memory and a 50GB disk, and 2 executors per worker.</p> </li>
    /// <li> <p>For the <code>G.1X</code> worker type, each worker provides 4 vCPU, 16 GB of memory and a 64GB disk, and 1 executor per worker.</p> </li>
    /// <li> <p>For the <code>G.2X</code> worker type, each worker provides 8 vCPU, 32 GB of memory and a 128GB disk, and 1 executor per worker.</p> </li>
    /// </ul>
    /// <p> <code>MaxCapacity</code> is a mutually exclusive option with <code>NumberOfWorkers</code> and <code>WorkerType</code>.</p>
    /// <ul>
    /// <li> <p>If either <code>NumberOfWorkers</code> or <code>WorkerType</code> is set, then <code>MaxCapacity</code> cannot be set.</p> </li>
    /// <li> <p>If <code>MaxCapacity</code> is set then neither <code>NumberOfWorkers</code> or <code>WorkerType</code> can be set.</p> </li>
    /// <li> <p>If <code>WorkerType</code> is set, then <code>NumberOfWorkers</code> is required (and vice versa).</p> </li>
    /// <li> <p> <code>MaxCapacity</code> and <code>NumberOfWorkers</code> must both be at least 1.</p> </li>
    /// </ul>
    pub fn worker_type(&self) -> std::option::Option<&crate::model::WorkerType> {
        self.worker_type.as_ref()
    }
    /// <p>The number of workers of a defined <code>workerType</code> that are allocated when a task of the transform runs.</p>
    /// <p>If <code>WorkerType</code> is set, then <code>NumberOfWorkers</code> is required (and vice versa).</p>
    pub fn number_of_workers(&self) -> std::option::Option<i32> {
        self.number_of_workers
    }
    /// <p>The timeout in minutes of the machine learning transform.</p>
    pub fn timeout(&self) -> std::option::Option<i32> {
        self.timeout
    }
    /// <p>The maximum number of times to retry after an <code>MLTaskRun</code> of the machine learning transform fails.</p>
    pub fn max_retries(&self) -> std::option::Option<i32> {
        self.max_retries
    }
    /// <p>The encryption-at-rest settings of the transform that apply to accessing user data. Machine learning transforms can access user data encrypted in Amazon S3 using KMS.</p>
    pub fn transform_encryption(&self) -> std::option::Option<&crate::model::TransformEncryption> {
        self.transform_encryption.as_ref()
    }
}
/// See [`MlTransform`](crate::model::MlTransform).
pub mod ml_transform {

    /// A builder for [`MlTransform`](crate::model::MlTransform).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) transform_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::TransformStatusType>,
        pub(crate) created_on: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_modified_on: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) input_record_tables: std::option::Option<std::vec::Vec<crate::model::GlueTable>>,
        pub(crate) parameters: std::option::Option<crate::model::TransformParameters>,
        pub(crate) evaluation_metrics: std::option::Option<crate::model::EvaluationMetrics>,
        pub(crate) label_count: std::option::Option<i32>,
        pub(crate) schema: std::option::Option<std::vec::Vec<crate::model::SchemaColumn>>,
        pub(crate) role: std::option::Option<std::string::String>,
        pub(crate) glue_version: std::option::Option<std::string::String>,
        pub(crate) max_capacity: std::option::Option<f64>,
        pub(crate) worker_type: std::option::Option<crate::model::WorkerType>,
        pub(crate) number_of_workers: std::option::Option<i32>,
        pub(crate) timeout: std::option::Option<i32>,
        pub(crate) max_retries: std::option::Option<i32>,
        pub(crate) transform_encryption: std::option::Option<crate::model::TransformEncryption>,
    }
    impl Builder {
        /// <p>The unique transform ID that is generated for the machine learning transform. The ID is guaranteed to be unique and does not change.</p>
        pub fn transform_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.transform_id = Some(input.into());
            self
        }
        /// <p>The unique transform ID that is generated for the machine learning transform. The ID is guaranteed to be unique and does not change.</p>
        pub fn set_transform_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.transform_id = input;
            self
        }
        /// <p>A user-defined name for the machine learning transform. Names are not guaranteed unique and can be changed at any time.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>A user-defined name for the machine learning transform. Names are not guaranteed unique and can be changed at any time.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>A user-defined, long-form description text for the machine learning transform. Descriptions are not guaranteed to be unique and can be changed at any time.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A user-defined, long-form description text for the machine learning transform. Descriptions are not guaranteed to be unique and can be changed at any time.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The current status of the machine learning transform.</p>
        pub fn status(mut self, input: crate::model::TransformStatusType) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The current status of the machine learning transform.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::TransformStatusType>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>A timestamp. The time and date that this machine learning transform was created.</p>
        pub fn created_on(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_on = Some(input);
            self
        }
        /// <p>A timestamp. The time and date that this machine learning transform was created.</p>
        pub fn set_created_on(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_on = input;
            self
        }
        /// <p>A timestamp. The last point in time when this machine learning transform was modified.</p>
        pub fn last_modified_on(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_modified_on = Some(input);
            self
        }
        /// <p>A timestamp. The last point in time when this machine learning transform was modified.</p>
        pub fn set_last_modified_on(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_modified_on = input;
            self
        }
        /// Appends an item to `input_record_tables`.
        ///
        /// To override the contents of this collection use [`set_input_record_tables`](Self::set_input_record_tables).
        ///
        /// <p>A list of Glue table definitions used by the transform.</p>
        pub fn input_record_tables(mut self, input: crate::model::GlueTable) -> Self {
            let mut v = self.input_record_tables.unwrap_or_default();
            v.push(input);
            self.input_record_tables = Some(v);
            self
        }
        /// <p>A list of Glue table definitions used by the transform.</p>
        pub fn set_input_record_tables(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::GlueTable>>,
        ) -> Self {
            self.input_record_tables = input;
            self
        }
        /// <p>A <code>TransformParameters</code> object. You can use parameters to tune (customize) the behavior of the machine learning transform by specifying what data it learns from and your preference on various tradeoffs (such as precious vs. recall, or accuracy vs. cost).</p>
        pub fn parameters(mut self, input: crate::model::TransformParameters) -> Self {
            self.parameters = Some(input);
            self
        }
        /// <p>A <code>TransformParameters</code> object. You can use parameters to tune (customize) the behavior of the machine learning transform by specifying what data it learns from and your preference on various tradeoffs (such as precious vs. recall, or accuracy vs. cost).</p>
        pub fn set_parameters(
            mut self,
            input: std::option::Option<crate::model::TransformParameters>,
        ) -> Self {
            self.parameters = input;
            self
        }
        /// <p>An <code>EvaluationMetrics</code> object. Evaluation metrics provide an estimate of the quality of your machine learning transform.</p>
        pub fn evaluation_metrics(mut self, input: crate::model::EvaluationMetrics) -> Self {
            self.evaluation_metrics = Some(input);
            self
        }
        /// <p>An <code>EvaluationMetrics</code> object. Evaluation metrics provide an estimate of the quality of your machine learning transform.</p>
        pub fn set_evaluation_metrics(
            mut self,
            input: std::option::Option<crate::model::EvaluationMetrics>,
        ) -> Self {
            self.evaluation_metrics = input;
            self
        }
        /// <p>A count identifier for the labeling files generated by Glue for this transform. As you create a better transform, you can iteratively download, label, and upload the labeling file.</p>
        pub fn label_count(mut self, input: i32) -> Self {
            self.label_count = Some(input);
            self
        }
        /// <p>A count identifier for the labeling files generated by Glue for this transform. As you create a better transform, you can iteratively download, label, and upload the labeling file.</p>
        pub fn set_label_count(mut self, input: std::option::Option<i32>) -> Self {
            self.label_count = input;
            self
        }
        /// Appends an item to `schema`.
        ///
        /// To override the contents of this collection use [`set_schema`](Self::set_schema).
        ///
        /// <p>A map of key-value pairs representing the columns and data types that this transform can run against. Has an upper bound of 100 columns.</p>
        pub fn schema(mut self, input: crate::model::SchemaColumn) -> Self {
            let mut v = self.schema.unwrap_or_default();
            v.push(input);
            self.schema = Some(v);
            self
        }
        /// <p>A map of key-value pairs representing the columns and data types that this transform can run against. Has an upper bound of 100 columns.</p>
        pub fn set_schema(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::SchemaColumn>>,
        ) -> Self {
            self.schema = input;
            self
        }
        /// <p>The name or Amazon Resource Name (ARN) of the IAM role with the required permissions. The required permissions include both Glue service role permissions to Glue resources, and Amazon S3 permissions required by the transform. </p>
        /// <ul>
        /// <li> <p>This role needs Glue service role permissions to allow access to resources in Glue. See <a href="https://docs.aws.amazon.com/glue/latest/dg/attach-policy-iam-user.html">Attach a Policy to IAM Users That Access Glue</a>.</p> </li>
        /// <li> <p>This role needs permission to your Amazon Simple Storage Service (Amazon S3) sources, targets, temporary directory, scripts, and any libraries used by the task run for this transform.</p> </li>
        /// </ul>
        pub fn role(mut self, input: impl Into<std::string::String>) -> Self {
            self.role = Some(input.into());
            self
        }
        /// <p>The name or Amazon Resource Name (ARN) of the IAM role with the required permissions. The required permissions include both Glue service role permissions to Glue resources, and Amazon S3 permissions required by the transform. </p>
        /// <ul>
        /// <li> <p>This role needs Glue service role permissions to allow access to resources in Glue. See <a href="https://docs.aws.amazon.com/glue/latest/dg/attach-policy-iam-user.html">Attach a Policy to IAM Users That Access Glue</a>.</p> </li>
        /// <li> <p>This role needs permission to your Amazon Simple Storage Service (Amazon S3) sources, targets, temporary directory, scripts, and any libraries used by the task run for this transform.</p> </li>
        /// </ul>
        pub fn set_role(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.role = input;
            self
        }
        /// <p>This value determines which version of Glue this machine learning transform is compatible with. Glue 1.0 is recommended for most customers. If the value is not set, the Glue compatibility defaults to Glue 0.9. For more information, see <a href="https://docs.aws.amazon.com/glue/latest/dg/release-notes.html#release-notes-versions">Glue Versions</a> in the developer guide.</p>
        pub fn glue_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.glue_version = Some(input.into());
            self
        }
        /// <p>This value determines which version of Glue this machine learning transform is compatible with. Glue 1.0 is recommended for most customers. If the value is not set, the Glue compatibility defaults to Glue 0.9. For more information, see <a href="https://docs.aws.amazon.com/glue/latest/dg/release-notes.html#release-notes-versions">Glue Versions</a> in the developer guide.</p>
        pub fn set_glue_version(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.glue_version = input;
            self
        }
        /// <p>The number of Glue data processing units (DPUs) that are allocated to task runs for this transform. You can allocate from 2 to 100 DPUs; the default is 10. A DPU is a relative measure of processing power that consists of 4 vCPUs of compute capacity and 16 GB of memory. For more information, see the <a href="http://aws.amazon.com/glue/pricing/">Glue pricing page</a>. </p>
        /// <p> <code>MaxCapacity</code> is a mutually exclusive option with <code>NumberOfWorkers</code> and <code>WorkerType</code>.</p>
        /// <ul>
        /// <li> <p>If either <code>NumberOfWorkers</code> or <code>WorkerType</code> is set, then <code>MaxCapacity</code> cannot be set.</p> </li>
        /// <li> <p>If <code>MaxCapacity</code> is set then neither <code>NumberOfWorkers</code> or <code>WorkerType</code> can be set.</p> </li>
        /// <li> <p>If <code>WorkerType</code> is set, then <code>NumberOfWorkers</code> is required (and vice versa).</p> </li>
        /// <li> <p> <code>MaxCapacity</code> and <code>NumberOfWorkers</code> must both be at least 1.</p> </li>
        /// </ul>
        /// <p>When the <code>WorkerType</code> field is set to a value other than <code>Standard</code>, the <code>MaxCapacity</code> field is set automatically and becomes read-only.</p>
        pub fn max_capacity(mut self, input: f64) -> Self {
            self.max_capacity = Some(input);
            self
        }
        /// <p>The number of Glue data processing units (DPUs) that are allocated to task runs for this transform. You can allocate from 2 to 100 DPUs; the default is 10. A DPU is a relative measure of processing power that consists of 4 vCPUs of compute capacity and 16 GB of memory. For more information, see the <a href="http://aws.amazon.com/glue/pricing/">Glue pricing page</a>. </p>
        /// <p> <code>MaxCapacity</code> is a mutually exclusive option with <code>NumberOfWorkers</code> and <code>WorkerType</code>.</p>
        /// <ul>
        /// <li> <p>If either <code>NumberOfWorkers</code> or <code>WorkerType</code> is set, then <code>MaxCapacity</code> cannot be set.</p> </li>
        /// <li> <p>If <code>MaxCapacity</code> is set then neither <code>NumberOfWorkers</code> or <code>WorkerType</code> can be set.</p> </li>
        /// <li> <p>If <code>WorkerType</code> is set, then <code>NumberOfWorkers</code> is required (and vice versa).</p> </li>
        /// <li> <p> <code>MaxCapacity</code> and <code>NumberOfWorkers</code> must both be at least 1.</p> </li>
        /// </ul>
        /// <p>When the <code>WorkerType</code> field is set to a value other than <code>Standard</code>, the <code>MaxCapacity</code> field is set automatically and becomes read-only.</p>
        pub fn set_max_capacity(mut self, input: std::option::Option<f64>) -> Self {
            self.max_capacity = input;
            self
        }
        /// <p>The type of predefined worker that is allocated when a task of this transform runs. Accepts a value of Standard, G.1X, or G.2X.</p>
        /// <ul>
        /// <li> <p>For the <code>Standard</code> worker type, each worker provides 4 vCPU, 16 GB of memory and a 50GB disk, and 2 executors per worker.</p> </li>
        /// <li> <p>For the <code>G.1X</code> worker type, each worker provides 4 vCPU, 16 GB of memory and a 64GB disk, and 1 executor per worker.</p> </li>
        /// <li> <p>For the <code>G.2X</code> worker type, each worker provides 8 vCPU, 32 GB of memory and a 128GB disk, and 1 executor per worker.</p> </li>
        /// </ul>
        /// <p> <code>MaxCapacity</code> is a mutually exclusive option with <code>NumberOfWorkers</code> and <code>WorkerType</code>.</p>
        /// <ul>
        /// <li> <p>If either <code>NumberOfWorkers</code> or <code>WorkerType</code> is set, then <code>MaxCapacity</code> cannot be set.</p> </li>
        /// <li> <p>If <code>MaxCapacity</code> is set then neither <code>NumberOfWorkers</code> or <code>WorkerType</code> can be set.</p> </li>
        /// <li> <p>If <code>WorkerType</code> is set, then <code>NumberOfWorkers</code> is required (and vice versa).</p> </li>
        /// <li> <p> <code>MaxCapacity</code> and <code>NumberOfWorkers</code> must both be at least 1.</p> </li>
        /// </ul>
        pub fn worker_type(mut self, input: crate::model::WorkerType) -> Self {
            self.worker_type = Some(input);
            self
        }
        /// <p>The type of predefined worker that is allocated when a task of this transform runs. Accepts a value of Standard, G.1X, or G.2X.</p>
        /// <ul>
        /// <li> <p>For the <code>Standard</code> worker type, each worker provides 4 vCPU, 16 GB of memory and a 50GB disk, and 2 executors per worker.</p> </li>
        /// <li> <p>For the <code>G.1X</code> worker type, each worker provides 4 vCPU, 16 GB of memory and a 64GB disk, and 1 executor per worker.</p> </li>
        /// <li> <p>For the <code>G.2X</code> worker type, each worker provides 8 vCPU, 32 GB of memory and a 128GB disk, and 1 executor per worker.</p> </li>
        /// </ul>
        /// <p> <code>MaxCapacity</code> is a mutually exclusive option with <code>NumberOfWorkers</code> and <code>WorkerType</code>.</p>
        /// <ul>
        /// <li> <p>If either <code>NumberOfWorkers</code> or <code>WorkerType</code> is set, then <code>MaxCapacity</code> cannot be set.</p> </li>
        /// <li> <p>If <code>MaxCapacity</code> is set then neither <code>NumberOfWorkers</code> or <code>WorkerType</code> can be set.</p> </li>
        /// <li> <p>If <code>WorkerType</code> is set, then <code>NumberOfWorkers</code> is required (and vice versa).</p> </li>
        /// <li> <p> <code>MaxCapacity</code> and <code>NumberOfWorkers</code> must both be at least 1.</p> </li>
        /// </ul>
        pub fn set_worker_type(
            mut self,
            input: std::option::Option<crate::model::WorkerType>,
        ) -> Self {
            self.worker_type = input;
            self
        }
        /// <p>The number of workers of a defined <code>workerType</code> that are allocated when a task of the transform runs.</p>
        /// <p>If <code>WorkerType</code> is set, then <code>NumberOfWorkers</code> is required (and vice versa).</p>
        pub fn number_of_workers(mut self, input: i32) -> Self {
            self.number_of_workers = Some(input);
            self
        }
        /// <p>The number of workers of a defined <code>workerType</code> that are allocated when a task of the transform runs.</p>
        /// <p>If <code>WorkerType</code> is set, then <code>NumberOfWorkers</code> is required (and vice versa).</p>
        pub fn set_number_of_workers(mut self, input: std::option::Option<i32>) -> Self {
            self.number_of_workers = input;
            self
        }
        /// <p>The timeout in minutes of the machine learning transform.</p>
        pub fn timeout(mut self, input: i32) -> Self {
            self.timeout = Some(input);
            self
        }
        /// <p>The timeout in minutes of the machine learning transform.</p>
        pub fn set_timeout(mut self, input: std::option::Option<i32>) -> Self {
            self.timeout = input;
            self
        }
        /// <p>The maximum number of times to retry after an <code>MLTaskRun</code> of the machine learning transform fails.</p>
        pub fn max_retries(mut self, input: i32) -> Self {
            self.max_retries = Some(input);
            self
        }
        /// <p>The maximum number of times to retry after an <code>MLTaskRun</code> of the machine learning transform fails.</p>
        pub fn set_max_retries(mut self, input: std::option::Option<i32>) -> Self {
            self.max_retries = input;
            self
        }
        /// <p>The encryption-at-rest settings of the transform that apply to accessing user data. Machine learning transforms can access user data encrypted in Amazon S3 using KMS.</p>
        pub fn transform_encryption(mut self, input: crate::model::TransformEncryption) -> Self {
            self.transform_encryption = Some(input);
            self
        }
        /// <p>The encryption-at-rest settings of the transform that apply to accessing user data. Machine learning transforms can access user data encrypted in Amazon S3 using KMS.</p>
        pub fn set_transform_encryption(
            mut self,
            input: std::option::Option<crate::model::TransformEncryption>,
        ) -> Self {
            self.transform_encryption = input;
            self
        }
        /// Consumes the builder and constructs a [`MlTransform`](crate::model::MlTransform).
        pub fn build(self) -> crate::model::MlTransform {
            crate::model::MlTransform {
                transform_id: self.transform_id,
                name: self.name,
                description: self.description,
                status: self.status,
                created_on: self.created_on,
                last_modified_on: self.last_modified_on,
                input_record_tables: self.input_record_tables,
                parameters: self.parameters,
                evaluation_metrics: self.evaluation_metrics,
                label_count: self.label_count.unwrap_or_default(),
                schema: self.schema,
                role: self.role,
                glue_version: self.glue_version,
                max_capacity: self.max_capacity,
                worker_type: self.worker_type,
                number_of_workers: self.number_of_workers,
                timeout: self.timeout,
                max_retries: self.max_retries,
                transform_encryption: self.transform_encryption,
            }
        }
    }
}
impl MlTransform {
    /// Creates a new builder-style object to manufacture [`MlTransform`](crate::model::MlTransform).
    pub fn builder() -> crate::model::ml_transform::Builder {
        crate::model::ml_transform::Builder::default()
    }
}

/// <p>The encryption-at-rest settings of the transform that apply to accessing user data. Machine learning transforms can access user data encrypted in Amazon S3 using KMS.</p>
/// <p>Additionally, imported labels and trained transforms can now be encrypted using a customer provided KMS key.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TransformEncryption {
    /// <p>An <code>MLUserDataEncryption</code> object containing the encryption mode and customer-provided KMS key ID.</p>
    #[doc(hidden)]
    pub ml_user_data_encryption: std::option::Option<crate::model::MlUserDataEncryption>,
    /// <p>The name of the security configuration.</p>
    #[doc(hidden)]
    pub task_run_security_configuration_name: std::option::Option<std::string::String>,
}
impl TransformEncryption {
    /// <p>An <code>MLUserDataEncryption</code> object containing the encryption mode and customer-provided KMS key ID.</p>
    pub fn ml_user_data_encryption(
        &self,
    ) -> std::option::Option<&crate::model::MlUserDataEncryption> {
        self.ml_user_data_encryption.as_ref()
    }
    /// <p>The name of the security configuration.</p>
    pub fn task_run_security_configuration_name(&self) -> std::option::Option<&str> {
        self.task_run_security_configuration_name.as_deref()
    }
}
/// See [`TransformEncryption`](crate::model::TransformEncryption).
pub mod transform_encryption {

    /// A builder for [`TransformEncryption`](crate::model::TransformEncryption).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) ml_user_data_encryption: std::option::Option<crate::model::MlUserDataEncryption>,
        pub(crate) task_run_security_configuration_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>An <code>MLUserDataEncryption</code> object containing the encryption mode and customer-provided KMS key ID.</p>
        pub fn ml_user_data_encryption(
            mut self,
            input: crate::model::MlUserDataEncryption,
        ) -> Self {
            self.ml_user_data_encryption = Some(input);
            self
        }
        /// <p>An <code>MLUserDataEncryption</code> object containing the encryption mode and customer-provided KMS key ID.</p>
        pub fn set_ml_user_data_encryption(
            mut self,
            input: std::option::Option<crate::model::MlUserDataEncryption>,
        ) -> Self {
            self.ml_user_data_encryption = input;
            self
        }
        /// <p>The name of the security configuration.</p>
        pub fn task_run_security_configuration_name(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.task_run_security_configuration_name = Some(input.into());
            self
        }
        /// <p>The name of the security configuration.</p>
        pub fn set_task_run_security_configuration_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.task_run_security_configuration_name = input;
            self
        }
        /// Consumes the builder and constructs a [`TransformEncryption`](crate::model::TransformEncryption).
        pub fn build(self) -> crate::model::TransformEncryption {
            crate::model::TransformEncryption {
                ml_user_data_encryption: self.ml_user_data_encryption,
                task_run_security_configuration_name: self.task_run_security_configuration_name,
            }
        }
    }
}
impl TransformEncryption {
    /// Creates a new builder-style object to manufacture [`TransformEncryption`](crate::model::TransformEncryption).
    pub fn builder() -> crate::model::transform_encryption::Builder {
        crate::model::transform_encryption::Builder::default()
    }
}

/// <p>The encryption-at-rest settings of the transform that apply to accessing user data.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct MlUserDataEncryption {
    /// <p>The encryption mode applied to user data. Valid values are:</p>
    /// <ul>
    /// <li> <p>DISABLED: encryption is disabled</p> </li>
    /// <li> <p>SSEKMS: use of server-side encryption with Key Management Service (SSE-KMS) for user data stored in Amazon S3.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub ml_user_data_encryption_mode:
        std::option::Option<crate::model::MlUserDataEncryptionModeString>,
    /// <p>The ID for the customer-provided KMS key.</p>
    #[doc(hidden)]
    pub kms_key_id: std::option::Option<std::string::String>,
}
impl MlUserDataEncryption {
    /// <p>The encryption mode applied to user data. Valid values are:</p>
    /// <ul>
    /// <li> <p>DISABLED: encryption is disabled</p> </li>
    /// <li> <p>SSEKMS: use of server-side encryption with Key Management Service (SSE-KMS) for user data stored in Amazon S3.</p> </li>
    /// </ul>
    pub fn ml_user_data_encryption_mode(
        &self,
    ) -> std::option::Option<&crate::model::MlUserDataEncryptionModeString> {
        self.ml_user_data_encryption_mode.as_ref()
    }
    /// <p>The ID for the customer-provided KMS key.</p>
    pub fn kms_key_id(&self) -> std::option::Option<&str> {
        self.kms_key_id.as_deref()
    }
}
/// See [`MlUserDataEncryption`](crate::model::MlUserDataEncryption).
pub mod ml_user_data_encryption {

    /// A builder for [`MlUserDataEncryption`](crate::model::MlUserDataEncryption).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) ml_user_data_encryption_mode:
            std::option::Option<crate::model::MlUserDataEncryptionModeString>,
        pub(crate) kms_key_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The encryption mode applied to user data. Valid values are:</p>
        /// <ul>
        /// <li> <p>DISABLED: encryption is disabled</p> </li>
        /// <li> <p>SSEKMS: use of server-side encryption with Key Management Service (SSE-KMS) for user data stored in Amazon S3.</p> </li>
        /// </ul>
        pub fn ml_user_data_encryption_mode(
            mut self,
            input: crate::model::MlUserDataEncryptionModeString,
        ) -> Self {
            self.ml_user_data_encryption_mode = Some(input);
            self
        }
        /// <p>The encryption mode applied to user data. Valid values are:</p>
        /// <ul>
        /// <li> <p>DISABLED: encryption is disabled</p> </li>
        /// <li> <p>SSEKMS: use of server-side encryption with Key Management Service (SSE-KMS) for user data stored in Amazon S3.</p> </li>
        /// </ul>
        pub fn set_ml_user_data_encryption_mode(
            mut self,
            input: std::option::Option<crate::model::MlUserDataEncryptionModeString>,
        ) -> Self {
            self.ml_user_data_encryption_mode = input;
            self
        }
        /// <p>The ID for the customer-provided KMS key.</p>
        pub fn kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.kms_key_id = Some(input.into());
            self
        }
        /// <p>The ID for the customer-provided KMS key.</p>
        pub fn set_kms_key_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.kms_key_id = input;
            self
        }
        /// Consumes the builder and constructs a [`MlUserDataEncryption`](crate::model::MlUserDataEncryption).
        pub fn build(self) -> crate::model::MlUserDataEncryption {
            crate::model::MlUserDataEncryption {
                ml_user_data_encryption_mode: self.ml_user_data_encryption_mode,
                kms_key_id: self.kms_key_id,
            }
        }
    }
}
impl MlUserDataEncryption {
    /// Creates a new builder-style object to manufacture [`MlUserDataEncryption`](crate::model::MlUserDataEncryption).
    pub fn builder() -> crate::model::ml_user_data_encryption::Builder {
        crate::model::ml_user_data_encryption::Builder::default()
    }
}

/// When writing a match expression against `MlUserDataEncryptionModeString`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let mluserdataencryptionmodestring = unimplemented!();
/// match mluserdataencryptionmodestring {
///     MlUserDataEncryptionModeString::Disabled => { /* ... */ },
///     MlUserDataEncryptionModeString::Ssekms => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `mluserdataencryptionmodestring` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `MlUserDataEncryptionModeString::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `MlUserDataEncryptionModeString::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `MlUserDataEncryptionModeString::NewFeature` is defined.
/// Specifically, when `mluserdataencryptionmodestring` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `MlUserDataEncryptionModeString::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum MlUserDataEncryptionModeString {
    #[allow(missing_docs)] // documentation missing in model
    Disabled,
    #[allow(missing_docs)] // documentation missing in model
    Ssekms,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for MlUserDataEncryptionModeString {
    fn from(s: &str) -> Self {
        match s {
            "DISABLED" => MlUserDataEncryptionModeString::Disabled,
            "SSE-KMS" => MlUserDataEncryptionModeString::Ssekms,
            other => MlUserDataEncryptionModeString::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for MlUserDataEncryptionModeString {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(MlUserDataEncryptionModeString::from(s))
    }
}
impl MlUserDataEncryptionModeString {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            MlUserDataEncryptionModeString::Disabled => "DISABLED",
            MlUserDataEncryptionModeString::Ssekms => "SSE-KMS",
            MlUserDataEncryptionModeString::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["DISABLED", "SSE-KMS"]
    }
}
impl AsRef<str> for MlUserDataEncryptionModeString {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Evaluation metrics provide an estimate of the quality of your machine learning transform.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct EvaluationMetrics {
    /// <p>The type of machine learning transform.</p>
    #[doc(hidden)]
    pub transform_type: std::option::Option<crate::model::TransformType>,
    /// <p>The evaluation metrics for the find matches algorithm.</p>
    #[doc(hidden)]
    pub find_matches_metrics: std::option::Option<crate::model::FindMatchesMetrics>,
}
impl EvaluationMetrics {
    /// <p>The type of machine learning transform.</p>
    pub fn transform_type(&self) -> std::option::Option<&crate::model::TransformType> {
        self.transform_type.as_ref()
    }
    /// <p>The evaluation metrics for the find matches algorithm.</p>
    pub fn find_matches_metrics(&self) -> std::option::Option<&crate::model::FindMatchesMetrics> {
        self.find_matches_metrics.as_ref()
    }
}
/// See [`EvaluationMetrics`](crate::model::EvaluationMetrics).
pub mod evaluation_metrics {

    /// A builder for [`EvaluationMetrics`](crate::model::EvaluationMetrics).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) transform_type: std::option::Option<crate::model::TransformType>,
        pub(crate) find_matches_metrics: std::option::Option<crate::model::FindMatchesMetrics>,
    }
    impl Builder {
        /// <p>The type of machine learning transform.</p>
        pub fn transform_type(mut self, input: crate::model::TransformType) -> Self {
            self.transform_type = Some(input);
            self
        }
        /// <p>The type of machine learning transform.</p>
        pub fn set_transform_type(
            mut self,
            input: std::option::Option<crate::model::TransformType>,
        ) -> Self {
            self.transform_type = input;
            self
        }
        /// <p>The evaluation metrics for the find matches algorithm.</p>
        pub fn find_matches_metrics(mut self, input: crate::model::FindMatchesMetrics) -> Self {
            self.find_matches_metrics = Some(input);
            self
        }
        /// <p>The evaluation metrics for the find matches algorithm.</p>
        pub fn set_find_matches_metrics(
            mut self,
            input: std::option::Option<crate::model::FindMatchesMetrics>,
        ) -> Self {
            self.find_matches_metrics = input;
            self
        }
        /// Consumes the builder and constructs a [`EvaluationMetrics`](crate::model::EvaluationMetrics).
        pub fn build(self) -> crate::model::EvaluationMetrics {
            crate::model::EvaluationMetrics {
                transform_type: self.transform_type,
                find_matches_metrics: self.find_matches_metrics,
            }
        }
    }
}
impl EvaluationMetrics {
    /// Creates a new builder-style object to manufacture [`EvaluationMetrics`](crate::model::EvaluationMetrics).
    pub fn builder() -> crate::model::evaluation_metrics::Builder {
        crate::model::evaluation_metrics::Builder::default()
    }
}

/// <p>The evaluation metrics for the find matches algorithm. The quality of your machine learning transform is measured by getting your transform to predict some matches and comparing the results to known matches from the same dataset. The quality metrics are based on a subset of your data, so they are not precise.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FindMatchesMetrics {
    /// <p>The area under the precision/recall curve (AUPRC) is a single number measuring the overall quality of the transform, that is independent of the choice made for precision vs. recall. Higher values indicate that you have a more attractive precision vs. recall tradeoff.</p>
    /// <p>For more information, see <a href="https://en.wikipedia.org/wiki/Precision_and_recall">Precision and recall</a> in Wikipedia.</p>
    #[doc(hidden)]
    pub area_under_pr_curve: std::option::Option<f64>,
    /// <p>The precision metric indicates when often your transform is correct when it predicts a match. Specifically, it measures how well the transform finds true positives from the total true positives possible.</p>
    /// <p>For more information, see <a href="https://en.wikipedia.org/wiki/Precision_and_recall">Precision and recall</a> in Wikipedia.</p>
    #[doc(hidden)]
    pub precision: std::option::Option<f64>,
    /// <p>The recall metric indicates that for an actual match, how often your transform predicts the match. Specifically, it measures how well the transform finds true positives from the total records in the source data.</p>
    /// <p>For more information, see <a href="https://en.wikipedia.org/wiki/Precision_and_recall">Precision and recall</a> in Wikipedia.</p>
    #[doc(hidden)]
    pub recall: std::option::Option<f64>,
    /// <p>The maximum F1 metric indicates the transform's accuracy between 0 and 1, where 1 is the best accuracy.</p>
    /// <p>For more information, see <a href="https://en.wikipedia.org/wiki/F1_score">F1 score</a> in Wikipedia.</p>
    #[doc(hidden)]
    pub f1: std::option::Option<f64>,
    /// <p>The confusion matrix shows you what your transform is predicting accurately and what types of errors it is making.</p>
    /// <p>For more information, see <a href="https://en.wikipedia.org/wiki/Confusion_matrix">Confusion matrix</a> in Wikipedia.</p>
    #[doc(hidden)]
    pub confusion_matrix: std::option::Option<crate::model::ConfusionMatrix>,
    /// <p>A list of <code>ColumnImportance</code> structures containing column importance metrics, sorted in order of descending importance.</p>
    #[doc(hidden)]
    pub column_importances: std::option::Option<std::vec::Vec<crate::model::ColumnImportance>>,
}
impl FindMatchesMetrics {
    /// <p>The area under the precision/recall curve (AUPRC) is a single number measuring the overall quality of the transform, that is independent of the choice made for precision vs. recall. Higher values indicate that you have a more attractive precision vs. recall tradeoff.</p>
    /// <p>For more information, see <a href="https://en.wikipedia.org/wiki/Precision_and_recall">Precision and recall</a> in Wikipedia.</p>
    pub fn area_under_pr_curve(&self) -> std::option::Option<f64> {
        self.area_under_pr_curve
    }
    /// <p>The precision metric indicates when often your transform is correct when it predicts a match. Specifically, it measures how well the transform finds true positives from the total true positives possible.</p>
    /// <p>For more information, see <a href="https://en.wikipedia.org/wiki/Precision_and_recall">Precision and recall</a> in Wikipedia.</p>
    pub fn precision(&self) -> std::option::Option<f64> {
        self.precision
    }
    /// <p>The recall metric indicates that for an actual match, how often your transform predicts the match. Specifically, it measures how well the transform finds true positives from the total records in the source data.</p>
    /// <p>For more information, see <a href="https://en.wikipedia.org/wiki/Precision_and_recall">Precision and recall</a> in Wikipedia.</p>
    pub fn recall(&self) -> std::option::Option<f64> {
        self.recall
    }
    /// <p>The maximum F1 metric indicates the transform's accuracy between 0 and 1, where 1 is the best accuracy.</p>
    /// <p>For more information, see <a href="https://en.wikipedia.org/wiki/F1_score">F1 score</a> in Wikipedia.</p>
    pub fn f1(&self) -> std::option::Option<f64> {
        self.f1
    }
    /// <p>The confusion matrix shows you what your transform is predicting accurately and what types of errors it is making.</p>
    /// <p>For more information, see <a href="https://en.wikipedia.org/wiki/Confusion_matrix">Confusion matrix</a> in Wikipedia.</p>
    pub fn confusion_matrix(&self) -> std::option::Option<&crate::model::ConfusionMatrix> {
        self.confusion_matrix.as_ref()
    }
    /// <p>A list of <code>ColumnImportance</code> structures containing column importance metrics, sorted in order of descending importance.</p>
    pub fn column_importances(&self) -> std::option::Option<&[crate::model::ColumnImportance]> {
        self.column_importances.as_deref()
    }
}
/// See [`FindMatchesMetrics`](crate::model::FindMatchesMetrics).
pub mod find_matches_metrics {

    /// A builder for [`FindMatchesMetrics`](crate::model::FindMatchesMetrics).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) area_under_pr_curve: std::option::Option<f64>,
        pub(crate) precision: std::option::Option<f64>,
        pub(crate) recall: std::option::Option<f64>,
        pub(crate) f1: std::option::Option<f64>,
        pub(crate) confusion_matrix: std::option::Option<crate::model::ConfusionMatrix>,
        pub(crate) column_importances:
            std::option::Option<std::vec::Vec<crate::model::ColumnImportance>>,
    }
    impl Builder {
        /// <p>The area under the precision/recall curve (AUPRC) is a single number measuring the overall quality of the transform, that is independent of the choice made for precision vs. recall. Higher values indicate that you have a more attractive precision vs. recall tradeoff.</p>
        /// <p>For more information, see <a href="https://en.wikipedia.org/wiki/Precision_and_recall">Precision and recall</a> in Wikipedia.</p>
        pub fn area_under_pr_curve(mut self, input: f64) -> Self {
            self.area_under_pr_curve = Some(input);
            self
        }
        /// <p>The area under the precision/recall curve (AUPRC) is a single number measuring the overall quality of the transform, that is independent of the choice made for precision vs. recall. Higher values indicate that you have a more attractive precision vs. recall tradeoff.</p>
        /// <p>For more information, see <a href="https://en.wikipedia.org/wiki/Precision_and_recall">Precision and recall</a> in Wikipedia.</p>
        pub fn set_area_under_pr_curve(mut self, input: std::option::Option<f64>) -> Self {
            self.area_under_pr_curve = input;
            self
        }
        /// <p>The precision metric indicates when often your transform is correct when it predicts a match. Specifically, it measures how well the transform finds true positives from the total true positives possible.</p>
        /// <p>For more information, see <a href="https://en.wikipedia.org/wiki/Precision_and_recall">Precision and recall</a> in Wikipedia.</p>
        pub fn precision(mut self, input: f64) -> Self {
            self.precision = Some(input);
            self
        }
        /// <p>The precision metric indicates when often your transform is correct when it predicts a match. Specifically, it measures how well the transform finds true positives from the total true positives possible.</p>
        /// <p>For more information, see <a href="https://en.wikipedia.org/wiki/Precision_and_recall">Precision and recall</a> in Wikipedia.</p>
        pub fn set_precision(mut self, input: std::option::Option<f64>) -> Self {
            self.precision = input;
            self
        }
        /// <p>The recall metric indicates that for an actual match, how often your transform predicts the match. Specifically, it measures how well the transform finds true positives from the total records in the source data.</p>
        /// <p>For more information, see <a href="https://en.wikipedia.org/wiki/Precision_and_recall">Precision and recall</a> in Wikipedia.</p>
        pub fn recall(mut self, input: f64) -> Self {
            self.recall = Some(input);
            self
        }
        /// <p>The recall metric indicates that for an actual match, how often your transform predicts the match. Specifically, it measures how well the transform finds true positives from the total records in the source data.</p>
        /// <p>For more information, see <a href="https://en.wikipedia.org/wiki/Precision_and_recall">Precision and recall</a> in Wikipedia.</p>
        pub fn set_recall(mut self, input: std::option::Option<f64>) -> Self {
            self.recall = input;
            self
        }
        /// <p>The maximum F1 metric indicates the transform's accuracy between 0 and 1, where 1 is the best accuracy.</p>
        /// <p>For more information, see <a href="https://en.wikipedia.org/wiki/F1_score">F1 score</a> in Wikipedia.</p>
        pub fn f1(mut self, input: f64) -> Self {
            self.f1 = Some(input);
            self
        }
        /// <p>The maximum F1 metric indicates the transform's accuracy between 0 and 1, where 1 is the best accuracy.</p>
        /// <p>For more information, see <a href="https://en.wikipedia.org/wiki/F1_score">F1 score</a> in Wikipedia.</p>
        pub fn set_f1(mut self, input: std::option::Option<f64>) -> Self {
            self.f1 = input;
            self
        }
        /// <p>The confusion matrix shows you what your transform is predicting accurately and what types of errors it is making.</p>
        /// <p>For more information, see <a href="https://en.wikipedia.org/wiki/Confusion_matrix">Confusion matrix</a> in Wikipedia.</p>
        pub fn confusion_matrix(mut self, input: crate::model::ConfusionMatrix) -> Self {
            self.confusion_matrix = Some(input);
            self
        }
        /// <p>The confusion matrix shows you what your transform is predicting accurately and what types of errors it is making.</p>
        /// <p>For more information, see <a href="https://en.wikipedia.org/wiki/Confusion_matrix">Confusion matrix</a> in Wikipedia.</p>
        pub fn set_confusion_matrix(
            mut self,
            input: std::option::Option<crate::model::ConfusionMatrix>,
        ) -> Self {
            self.confusion_matrix = input;
            self
        }
        /// Appends an item to `column_importances`.
        ///
        /// To override the contents of this collection use [`set_column_importances`](Self::set_column_importances).
        ///
        /// <p>A list of <code>ColumnImportance</code> structures containing column importance metrics, sorted in order of descending importance.</p>
        pub fn column_importances(mut self, input: crate::model::ColumnImportance) -> Self {
            let mut v = self.column_importances.unwrap_or_default();
            v.push(input);
            self.column_importances = Some(v);
            self
        }
        /// <p>A list of <code>ColumnImportance</code> structures containing column importance metrics, sorted in order of descending importance.</p>
        pub fn set_column_importances(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ColumnImportance>>,
        ) -> Self {
            self.column_importances = input;
            self
        }
        /// Consumes the builder and constructs a [`FindMatchesMetrics`](crate::model::FindMatchesMetrics).
        pub fn build(self) -> crate::model::FindMatchesMetrics {
            crate::model::FindMatchesMetrics {
                area_under_pr_curve: self.area_under_pr_curve,
                precision: self.precision,
                recall: self.recall,
                f1: self.f1,
                confusion_matrix: self.confusion_matrix,
                column_importances: self.column_importances,
            }
        }
    }
}
impl FindMatchesMetrics {
    /// Creates a new builder-style object to manufacture [`FindMatchesMetrics`](crate::model::FindMatchesMetrics).
    pub fn builder() -> crate::model::find_matches_metrics::Builder {
        crate::model::find_matches_metrics::Builder::default()
    }
}

/// <p>A structure containing the column name and column importance score for a column. </p>
/// <p>Column importance helps you understand how columns contribute to your model, by identifying which columns in your records are more important than others.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ColumnImportance {
    /// <p>The name of a column.</p>
    #[doc(hidden)]
    pub column_name: std::option::Option<std::string::String>,
    /// <p>The column importance score for the column, as a decimal.</p>
    #[doc(hidden)]
    pub importance: std::option::Option<f64>,
}
impl ColumnImportance {
    /// <p>The name of a column.</p>
    pub fn column_name(&self) -> std::option::Option<&str> {
        self.column_name.as_deref()
    }
    /// <p>The column importance score for the column, as a decimal.</p>
    pub fn importance(&self) -> std::option::Option<f64> {
        self.importance
    }
}
/// See [`ColumnImportance`](crate::model::ColumnImportance).
pub mod column_importance {

    /// A builder for [`ColumnImportance`](crate::model::ColumnImportance).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) column_name: std::option::Option<std::string::String>,
        pub(crate) importance: std::option::Option<f64>,
    }
    impl Builder {
        /// <p>The name of a column.</p>
        pub fn column_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.column_name = Some(input.into());
            self
        }
        /// <p>The name of a column.</p>
        pub fn set_column_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.column_name = input;
            self
        }
        /// <p>The column importance score for the column, as a decimal.</p>
        pub fn importance(mut self, input: f64) -> Self {
            self.importance = Some(input);
            self
        }
        /// <p>The column importance score for the column, as a decimal.</p>
        pub fn set_importance(mut self, input: std::option::Option<f64>) -> Self {
            self.importance = input;
            self
        }
        /// Consumes the builder and constructs a [`ColumnImportance`](crate::model::ColumnImportance).
        pub fn build(self) -> crate::model::ColumnImportance {
            crate::model::ColumnImportance {
                column_name: self.column_name,
                importance: self.importance,
            }
        }
    }
}
impl ColumnImportance {
    /// Creates a new builder-style object to manufacture [`ColumnImportance`](crate::model::ColumnImportance).
    pub fn builder() -> crate::model::column_importance::Builder {
        crate::model::column_importance::Builder::default()
    }
}

/// <p>The confusion matrix shows you what your transform is predicting accurately and what types of errors it is making.</p>
/// <p>For more information, see <a href="https://en.wikipedia.org/wiki/Confusion_matrix">Confusion matrix</a> in Wikipedia.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ConfusionMatrix {
    /// <p>The number of matches in the data that the transform correctly found, in the confusion matrix for your transform.</p>
    #[doc(hidden)]
    pub num_true_positives: std::option::Option<i64>,
    /// <p>The number of nonmatches in the data that the transform incorrectly classified as a match, in the confusion matrix for your transform.</p>
    #[doc(hidden)]
    pub num_false_positives: std::option::Option<i64>,
    /// <p>The number of nonmatches in the data that the transform correctly rejected, in the confusion matrix for your transform.</p>
    #[doc(hidden)]
    pub num_true_negatives: std::option::Option<i64>,
    /// <p>The number of matches in the data that the transform didn't find, in the confusion matrix for your transform.</p>
    #[doc(hidden)]
    pub num_false_negatives: std::option::Option<i64>,
}
impl ConfusionMatrix {
    /// <p>The number of matches in the data that the transform correctly found, in the confusion matrix for your transform.</p>
    pub fn num_true_positives(&self) -> std::option::Option<i64> {
        self.num_true_positives
    }
    /// <p>The number of nonmatches in the data that the transform incorrectly classified as a match, in the confusion matrix for your transform.</p>
    pub fn num_false_positives(&self) -> std::option::Option<i64> {
        self.num_false_positives
    }
    /// <p>The number of nonmatches in the data that the transform correctly rejected, in the confusion matrix for your transform.</p>
    pub fn num_true_negatives(&self) -> std::option::Option<i64> {
        self.num_true_negatives
    }
    /// <p>The number of matches in the data that the transform didn't find, in the confusion matrix for your transform.</p>
    pub fn num_false_negatives(&self) -> std::option::Option<i64> {
        self.num_false_negatives
    }
}
/// See [`ConfusionMatrix`](crate::model::ConfusionMatrix).
pub mod confusion_matrix {

    /// A builder for [`ConfusionMatrix`](crate::model::ConfusionMatrix).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) num_true_positives: std::option::Option<i64>,
        pub(crate) num_false_positives: std::option::Option<i64>,
        pub(crate) num_true_negatives: std::option::Option<i64>,
        pub(crate) num_false_negatives: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>The number of matches in the data that the transform correctly found, in the confusion matrix for your transform.</p>
        pub fn num_true_positives(mut self, input: i64) -> Self {
            self.num_true_positives = Some(input);
            self
        }
        /// <p>The number of matches in the data that the transform correctly found, in the confusion matrix for your transform.</p>
        pub fn set_num_true_positives(mut self, input: std::option::Option<i64>) -> Self {
            self.num_true_positives = input;
            self
        }
        /// <p>The number of nonmatches in the data that the transform incorrectly classified as a match, in the confusion matrix for your transform.</p>
        pub fn num_false_positives(mut self, input: i64) -> Self {
            self.num_false_positives = Some(input);
            self
        }
        /// <p>The number of nonmatches in the data that the transform incorrectly classified as a match, in the confusion matrix for your transform.</p>
        pub fn set_num_false_positives(mut self, input: std::option::Option<i64>) -> Self {
            self.num_false_positives = input;
            self
        }
        /// <p>The number of nonmatches in the data that the transform correctly rejected, in the confusion matrix for your transform.</p>
        pub fn num_true_negatives(mut self, input: i64) -> Self {
            self.num_true_negatives = Some(input);
            self
        }
        /// <p>The number of nonmatches in the data that the transform correctly rejected, in the confusion matrix for your transform.</p>
        pub fn set_num_true_negatives(mut self, input: std::option::Option<i64>) -> Self {
            self.num_true_negatives = input;
            self
        }
        /// <p>The number of matches in the data that the transform didn't find, in the confusion matrix for your transform.</p>
        pub fn num_false_negatives(mut self, input: i64) -> Self {
            self.num_false_negatives = Some(input);
            self
        }
        /// <p>The number of matches in the data that the transform didn't find, in the confusion matrix for your transform.</p>
        pub fn set_num_false_negatives(mut self, input: std::option::Option<i64>) -> Self {
            self.num_false_negatives = input;
            self
        }
        /// Consumes the builder and constructs a [`ConfusionMatrix`](crate::model::ConfusionMatrix).
        pub fn build(self) -> crate::model::ConfusionMatrix {
            crate::model::ConfusionMatrix {
                num_true_positives: self.num_true_positives,
                num_false_positives: self.num_false_positives,
                num_true_negatives: self.num_true_negatives,
                num_false_negatives: self.num_false_negatives,
            }
        }
    }
}
impl ConfusionMatrix {
    /// Creates a new builder-style object to manufacture [`ConfusionMatrix`](crate::model::ConfusionMatrix).
    pub fn builder() -> crate::model::confusion_matrix::Builder {
        crate::model::confusion_matrix::Builder::default()
    }
}

/// <p>The sampling parameters that are associated with the machine learning transform.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TaskRun {
    /// <p>The unique identifier for the transform.</p>
    #[doc(hidden)]
    pub transform_id: std::option::Option<std::string::String>,
    /// <p>The unique identifier for this task run.</p>
    #[doc(hidden)]
    pub task_run_id: std::option::Option<std::string::String>,
    /// <p>The current status of the requested task run.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::TaskStatusType>,
    /// <p>The names of the log group for secure logging, associated with this task run.</p>
    #[doc(hidden)]
    pub log_group_name: std::option::Option<std::string::String>,
    /// <p>Specifies configuration properties associated with this task run.</p>
    #[doc(hidden)]
    pub properties: std::option::Option<crate::model::TaskRunProperties>,
    /// <p>The list of error strings associated with this task run.</p>
    #[doc(hidden)]
    pub error_string: std::option::Option<std::string::String>,
    /// <p>The date and time that this task run started.</p>
    #[doc(hidden)]
    pub started_on: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The last point in time that the requested task run was updated.</p>
    #[doc(hidden)]
    pub last_modified_on: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The last point in time that the requested task run was completed.</p>
    #[doc(hidden)]
    pub completed_on: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The amount of time (in seconds) that the task run consumed resources.</p>
    #[doc(hidden)]
    pub execution_time: i32,
}
impl TaskRun {
    /// <p>The unique identifier for the transform.</p>
    pub fn transform_id(&self) -> std::option::Option<&str> {
        self.transform_id.as_deref()
    }
    /// <p>The unique identifier for this task run.</p>
    pub fn task_run_id(&self) -> std::option::Option<&str> {
        self.task_run_id.as_deref()
    }
    /// <p>The current status of the requested task run.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::TaskStatusType> {
        self.status.as_ref()
    }
    /// <p>The names of the log group for secure logging, associated with this task run.</p>
    pub fn log_group_name(&self) -> std::option::Option<&str> {
        self.log_group_name.as_deref()
    }
    /// <p>Specifies configuration properties associated with this task run.</p>
    pub fn properties(&self) -> std::option::Option<&crate::model::TaskRunProperties> {
        self.properties.as_ref()
    }
    /// <p>The list of error strings associated with this task run.</p>
    pub fn error_string(&self) -> std::option::Option<&str> {
        self.error_string.as_deref()
    }
    /// <p>The date and time that this task run started.</p>
    pub fn started_on(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.started_on.as_ref()
    }
    /// <p>The last point in time that the requested task run was updated.</p>
    pub fn last_modified_on(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_modified_on.as_ref()
    }
    /// <p>The last point in time that the requested task run was completed.</p>
    pub fn completed_on(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.completed_on.as_ref()
    }
    /// <p>The amount of time (in seconds) that the task run consumed resources.</p>
    pub fn execution_time(&self) -> i32 {
        self.execution_time
    }
}
/// See [`TaskRun`](crate::model::TaskRun).
pub mod task_run {

    /// A builder for [`TaskRun`](crate::model::TaskRun).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) transform_id: std::option::Option<std::string::String>,
        pub(crate) task_run_id: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::TaskStatusType>,
        pub(crate) log_group_name: std::option::Option<std::string::String>,
        pub(crate) properties: std::option::Option<crate::model::TaskRunProperties>,
        pub(crate) error_string: std::option::Option<std::string::String>,
        pub(crate) started_on: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_modified_on: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) completed_on: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) execution_time: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The unique identifier for the transform.</p>
        pub fn transform_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.transform_id = Some(input.into());
            self
        }
        /// <p>The unique identifier for the transform.</p>
        pub fn set_transform_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.transform_id = input;
            self
        }
        /// <p>The unique identifier for this task run.</p>
        pub fn task_run_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.task_run_id = Some(input.into());
            self
        }
        /// <p>The unique identifier for this task run.</p>
        pub fn set_task_run_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.task_run_id = input;
            self
        }
        /// <p>The current status of the requested task run.</p>
        pub fn status(mut self, input: crate::model::TaskStatusType) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The current status of the requested task run.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::TaskStatusType>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>The names of the log group for secure logging, associated with this task run.</p>
        pub fn log_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.log_group_name = Some(input.into());
            self
        }
        /// <p>The names of the log group for secure logging, associated with this task run.</p>
        pub fn set_log_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.log_group_name = input;
            self
        }
        /// <p>Specifies configuration properties associated with this task run.</p>
        pub fn properties(mut self, input: crate::model::TaskRunProperties) -> Self {
            self.properties = Some(input);
            self
        }
        /// <p>Specifies configuration properties associated with this task run.</p>
        pub fn set_properties(
            mut self,
            input: std::option::Option<crate::model::TaskRunProperties>,
        ) -> Self {
            self.properties = input;
            self
        }
        /// <p>The list of error strings associated with this task run.</p>
        pub fn error_string(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_string = Some(input.into());
            self
        }
        /// <p>The list of error strings associated with this task run.</p>
        pub fn set_error_string(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.error_string = input;
            self
        }
        /// <p>The date and time that this task run started.</p>
        pub fn started_on(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.started_on = Some(input);
            self
        }
        /// <p>The date and time that this task run started.</p>
        pub fn set_started_on(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.started_on = input;
            self
        }
        /// <p>The last point in time that the requested task run was updated.</p>
        pub fn last_modified_on(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_modified_on = Some(input);
            self
        }
        /// <p>The last point in time that the requested task run was updated.</p>
        pub fn set_last_modified_on(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_modified_on = input;
            self
        }
        /// <p>The last point in time that the requested task run was completed.</p>
        pub fn completed_on(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.completed_on = Some(input);
            self
        }
        /// <p>The last point in time that the requested task run was completed.</p>
        pub fn set_completed_on(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.completed_on = input;
            self
        }
        /// <p>The amount of time (in seconds) that the task run consumed resources.</p>
        pub fn execution_time(mut self, input: i32) -> Self {
            self.execution_time = Some(input);
            self
        }
        /// <p>The amount of time (in seconds) that the task run consumed resources.</p>
        pub fn set_execution_time(mut self, input: std::option::Option<i32>) -> Self {
            self.execution_time = input;
            self
        }
        /// Consumes the builder and constructs a [`TaskRun`](crate::model::TaskRun).
        pub fn build(self) -> crate::model::TaskRun {
            crate::model::TaskRun {
                transform_id: self.transform_id,
                task_run_id: self.task_run_id,
                status: self.status,
                log_group_name: self.log_group_name,
                properties: self.properties,
                error_string: self.error_string,
                started_on: self.started_on,
                last_modified_on: self.last_modified_on,
                completed_on: self.completed_on,
                execution_time: self.execution_time.unwrap_or_default(),
            }
        }
    }
}
impl TaskRun {
    /// Creates a new builder-style object to manufacture [`TaskRun`](crate::model::TaskRun).
    pub fn builder() -> crate::model::task_run::Builder {
        crate::model::task_run::Builder::default()
    }
}

/// <p>The configuration properties for the task run.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TaskRunProperties {
    /// <p>The type of task run.</p>
    #[doc(hidden)]
    pub task_type: std::option::Option<crate::model::TaskType>,
    /// <p>The configuration properties for an importing labels task run.</p>
    #[doc(hidden)]
    pub import_labels_task_run_properties:
        std::option::Option<crate::model::ImportLabelsTaskRunProperties>,
    /// <p>The configuration properties for an exporting labels task run.</p>
    #[doc(hidden)]
    pub export_labels_task_run_properties:
        std::option::Option<crate::model::ExportLabelsTaskRunProperties>,
    /// <p>The configuration properties for a labeling set generation task run.</p>
    #[doc(hidden)]
    pub labeling_set_generation_task_run_properties:
        std::option::Option<crate::model::LabelingSetGenerationTaskRunProperties>,
    /// <p>The configuration properties for a find matches task run.</p>
    #[doc(hidden)]
    pub find_matches_task_run_properties:
        std::option::Option<crate::model::FindMatchesTaskRunProperties>,
}
impl TaskRunProperties {
    /// <p>The type of task run.</p>
    pub fn task_type(&self) -> std::option::Option<&crate::model::TaskType> {
        self.task_type.as_ref()
    }
    /// <p>The configuration properties for an importing labels task run.</p>
    pub fn import_labels_task_run_properties(
        &self,
    ) -> std::option::Option<&crate::model::ImportLabelsTaskRunProperties> {
        self.import_labels_task_run_properties.as_ref()
    }
    /// <p>The configuration properties for an exporting labels task run.</p>
    pub fn export_labels_task_run_properties(
        &self,
    ) -> std::option::Option<&crate::model::ExportLabelsTaskRunProperties> {
        self.export_labels_task_run_properties.as_ref()
    }
    /// <p>The configuration properties for a labeling set generation task run.</p>
    pub fn labeling_set_generation_task_run_properties(
        &self,
    ) -> std::option::Option<&crate::model::LabelingSetGenerationTaskRunProperties> {
        self.labeling_set_generation_task_run_properties.as_ref()
    }
    /// <p>The configuration properties for a find matches task run.</p>
    pub fn find_matches_task_run_properties(
        &self,
    ) -> std::option::Option<&crate::model::FindMatchesTaskRunProperties> {
        self.find_matches_task_run_properties.as_ref()
    }
}
/// See [`TaskRunProperties`](crate::model::TaskRunProperties).
pub mod task_run_properties {

    /// A builder for [`TaskRunProperties`](crate::model::TaskRunProperties).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) task_type: std::option::Option<crate::model::TaskType>,
        pub(crate) import_labels_task_run_properties:
            std::option::Option<crate::model::ImportLabelsTaskRunProperties>,
        pub(crate) export_labels_task_run_properties:
            std::option::Option<crate::model::ExportLabelsTaskRunProperties>,
        pub(crate) labeling_set_generation_task_run_properties:
            std::option::Option<crate::model::LabelingSetGenerationTaskRunProperties>,
        pub(crate) find_matches_task_run_properties:
            std::option::Option<crate::model::FindMatchesTaskRunProperties>,
    }
    impl Builder {
        /// <p>The type of task run.</p>
        pub fn task_type(mut self, input: crate::model::TaskType) -> Self {
            self.task_type = Some(input);
            self
        }
        /// <p>The type of task run.</p>
        pub fn set_task_type(mut self, input: std::option::Option<crate::model::TaskType>) -> Self {
            self.task_type = input;
            self
        }
        /// <p>The configuration properties for an importing labels task run.</p>
        pub fn import_labels_task_run_properties(
            mut self,
            input: crate::model::ImportLabelsTaskRunProperties,
        ) -> Self {
            self.import_labels_task_run_properties = Some(input);
            self
        }
        /// <p>The configuration properties for an importing labels task run.</p>
        pub fn set_import_labels_task_run_properties(
            mut self,
            input: std::option::Option<crate::model::ImportLabelsTaskRunProperties>,
        ) -> Self {
            self.import_labels_task_run_properties = input;
            self
        }
        /// <p>The configuration properties for an exporting labels task run.</p>
        pub fn export_labels_task_run_properties(
            mut self,
            input: crate::model::ExportLabelsTaskRunProperties,
        ) -> Self {
            self.export_labels_task_run_properties = Some(input);
            self
        }
        /// <p>The configuration properties for an exporting labels task run.</p>
        pub fn set_export_labels_task_run_properties(
            mut self,
            input: std::option::Option<crate::model::ExportLabelsTaskRunProperties>,
        ) -> Self {
            self.export_labels_task_run_properties = input;
            self
        }
        /// <p>The configuration properties for a labeling set generation task run.</p>
        pub fn labeling_set_generation_task_run_properties(
            mut self,
            input: crate::model::LabelingSetGenerationTaskRunProperties,
        ) -> Self {
            self.labeling_set_generation_task_run_properties = Some(input);
            self
        }
        /// <p>The configuration properties for a labeling set generation task run.</p>
        pub fn set_labeling_set_generation_task_run_properties(
            mut self,
            input: std::option::Option<crate::model::LabelingSetGenerationTaskRunProperties>,
        ) -> Self {
            self.labeling_set_generation_task_run_properties = input;
            self
        }
        /// <p>The configuration properties for a find matches task run.</p>
        pub fn find_matches_task_run_properties(
            mut self,
            input: crate::model::FindMatchesTaskRunProperties,
        ) -> Self {
            self.find_matches_task_run_properties = Some(input);
            self
        }
        /// <p>The configuration properties for a find matches task run.</p>
        pub fn set_find_matches_task_run_properties(
            mut self,
            input: std::option::Option<crate::model::FindMatchesTaskRunProperties>,
        ) -> Self {
            self.find_matches_task_run_properties = input;
            self
        }
        /// Consumes the builder and constructs a [`TaskRunProperties`](crate::model::TaskRunProperties).
        pub fn build(self) -> crate::model::TaskRunProperties {
            crate::model::TaskRunProperties {
                task_type: self.task_type,
                import_labels_task_run_properties: self.import_labels_task_run_properties,
                export_labels_task_run_properties: self.export_labels_task_run_properties,
                labeling_set_generation_task_run_properties: self
                    .labeling_set_generation_task_run_properties,
                find_matches_task_run_properties: self.find_matches_task_run_properties,
            }
        }
    }
}
impl TaskRunProperties {
    /// Creates a new builder-style object to manufacture [`TaskRunProperties`](crate::model::TaskRunProperties).
    pub fn builder() -> crate::model::task_run_properties::Builder {
        crate::model::task_run_properties::Builder::default()
    }
}

/// <p>Specifies configuration properties for a Find Matches task run.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FindMatchesTaskRunProperties {
    /// <p>The job ID for the Find Matches task run.</p>
    #[doc(hidden)]
    pub job_id: std::option::Option<std::string::String>,
    /// <p>The name assigned to the job for the Find Matches task run.</p>
    #[doc(hidden)]
    pub job_name: std::option::Option<std::string::String>,
    /// <p>The job run ID for the Find Matches task run.</p>
    #[doc(hidden)]
    pub job_run_id: std::option::Option<std::string::String>,
}
impl FindMatchesTaskRunProperties {
    /// <p>The job ID for the Find Matches task run.</p>
    pub fn job_id(&self) -> std::option::Option<&str> {
        self.job_id.as_deref()
    }
    /// <p>The name assigned to the job for the Find Matches task run.</p>
    pub fn job_name(&self) -> std::option::Option<&str> {
        self.job_name.as_deref()
    }
    /// <p>The job run ID for the Find Matches task run.</p>
    pub fn job_run_id(&self) -> std::option::Option<&str> {
        self.job_run_id.as_deref()
    }
}
/// See [`FindMatchesTaskRunProperties`](crate::model::FindMatchesTaskRunProperties).
pub mod find_matches_task_run_properties {

    /// A builder for [`FindMatchesTaskRunProperties`](crate::model::FindMatchesTaskRunProperties).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) job_id: std::option::Option<std::string::String>,
        pub(crate) job_name: std::option::Option<std::string::String>,
        pub(crate) job_run_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The job ID for the Find Matches task run.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_id = Some(input.into());
            self
        }
        /// <p>The job ID for the Find Matches task run.</p>
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_id = input;
            self
        }
        /// <p>The name assigned to the job for the Find Matches task run.</p>
        pub fn job_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_name = Some(input.into());
            self
        }
        /// <p>The name assigned to the job for the Find Matches task run.</p>
        pub fn set_job_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_name = input;
            self
        }
        /// <p>The job run ID for the Find Matches task run.</p>
        pub fn job_run_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_run_id = Some(input.into());
            self
        }
        /// <p>The job run ID for the Find Matches task run.</p>
        pub fn set_job_run_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_run_id = input;
            self
        }
        /// Consumes the builder and constructs a [`FindMatchesTaskRunProperties`](crate::model::FindMatchesTaskRunProperties).
        pub fn build(self) -> crate::model::FindMatchesTaskRunProperties {
            crate::model::FindMatchesTaskRunProperties {
                job_id: self.job_id,
                job_name: self.job_name,
                job_run_id: self.job_run_id,
            }
        }
    }
}
impl FindMatchesTaskRunProperties {
    /// Creates a new builder-style object to manufacture [`FindMatchesTaskRunProperties`](crate::model::FindMatchesTaskRunProperties).
    pub fn builder() -> crate::model::find_matches_task_run_properties::Builder {
        crate::model::find_matches_task_run_properties::Builder::default()
    }
}

/// <p>Specifies configuration properties for a labeling set generation task run.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LabelingSetGenerationTaskRunProperties {
    /// <p>The Amazon Simple Storage Service (Amazon S3) path where you will generate the labeling set.</p>
    #[doc(hidden)]
    pub output_s3_path: std::option::Option<std::string::String>,
}
impl LabelingSetGenerationTaskRunProperties {
    /// <p>The Amazon Simple Storage Service (Amazon S3) path where you will generate the labeling set.</p>
    pub fn output_s3_path(&self) -> std::option::Option<&str> {
        self.output_s3_path.as_deref()
    }
}
/// See [`LabelingSetGenerationTaskRunProperties`](crate::model::LabelingSetGenerationTaskRunProperties).
pub mod labeling_set_generation_task_run_properties {

    /// A builder for [`LabelingSetGenerationTaskRunProperties`](crate::model::LabelingSetGenerationTaskRunProperties).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) output_s3_path: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Simple Storage Service (Amazon S3) path where you will generate the labeling set.</p>
        pub fn output_s3_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.output_s3_path = Some(input.into());
            self
        }
        /// <p>The Amazon Simple Storage Service (Amazon S3) path where you will generate the labeling set.</p>
        pub fn set_output_s3_path(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.output_s3_path = input;
            self
        }
        /// Consumes the builder and constructs a [`LabelingSetGenerationTaskRunProperties`](crate::model::LabelingSetGenerationTaskRunProperties).
        pub fn build(self) -> crate::model::LabelingSetGenerationTaskRunProperties {
            crate::model::LabelingSetGenerationTaskRunProperties {
                output_s3_path: self.output_s3_path,
            }
        }
    }
}
impl LabelingSetGenerationTaskRunProperties {
    /// Creates a new builder-style object to manufacture [`LabelingSetGenerationTaskRunProperties`](crate::model::LabelingSetGenerationTaskRunProperties).
    pub fn builder() -> crate::model::labeling_set_generation_task_run_properties::Builder {
        crate::model::labeling_set_generation_task_run_properties::Builder::default()
    }
}

/// <p>Specifies configuration properties for an exporting labels task run.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ExportLabelsTaskRunProperties {
    /// <p>The Amazon Simple Storage Service (Amazon S3) path where you will export the labels.</p>
    #[doc(hidden)]
    pub output_s3_path: std::option::Option<std::string::String>,
}
impl ExportLabelsTaskRunProperties {
    /// <p>The Amazon Simple Storage Service (Amazon S3) path where you will export the labels.</p>
    pub fn output_s3_path(&self) -> std::option::Option<&str> {
        self.output_s3_path.as_deref()
    }
}
/// See [`ExportLabelsTaskRunProperties`](crate::model::ExportLabelsTaskRunProperties).
pub mod export_labels_task_run_properties {

    /// A builder for [`ExportLabelsTaskRunProperties`](crate::model::ExportLabelsTaskRunProperties).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) output_s3_path: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Simple Storage Service (Amazon S3) path where you will export the labels.</p>
        pub fn output_s3_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.output_s3_path = Some(input.into());
            self
        }
        /// <p>The Amazon Simple Storage Service (Amazon S3) path where you will export the labels.</p>
        pub fn set_output_s3_path(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.output_s3_path = input;
            self
        }
        /// Consumes the builder and constructs a [`ExportLabelsTaskRunProperties`](crate::model::ExportLabelsTaskRunProperties).
        pub fn build(self) -> crate::model::ExportLabelsTaskRunProperties {
            crate::model::ExportLabelsTaskRunProperties {
                output_s3_path: self.output_s3_path,
            }
        }
    }
}
impl ExportLabelsTaskRunProperties {
    /// Creates a new builder-style object to manufacture [`ExportLabelsTaskRunProperties`](crate::model::ExportLabelsTaskRunProperties).
    pub fn builder() -> crate::model::export_labels_task_run_properties::Builder {
        crate::model::export_labels_task_run_properties::Builder::default()
    }
}

/// <p>Specifies configuration properties for an importing labels task run.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ImportLabelsTaskRunProperties {
    /// <p>The Amazon Simple Storage Service (Amazon S3) path from where you will import the labels.</p>
    #[doc(hidden)]
    pub input_s3_path: std::option::Option<std::string::String>,
    /// <p>Indicates whether to overwrite your existing labels.</p>
    #[doc(hidden)]
    pub replace: bool,
}
impl ImportLabelsTaskRunProperties {
    /// <p>The Amazon Simple Storage Service (Amazon S3) path from where you will import the labels.</p>
    pub fn input_s3_path(&self) -> std::option::Option<&str> {
        self.input_s3_path.as_deref()
    }
    /// <p>Indicates whether to overwrite your existing labels.</p>
    pub fn replace(&self) -> bool {
        self.replace
    }
}
/// See [`ImportLabelsTaskRunProperties`](crate::model::ImportLabelsTaskRunProperties).
pub mod import_labels_task_run_properties {

    /// A builder for [`ImportLabelsTaskRunProperties`](crate::model::ImportLabelsTaskRunProperties).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) input_s3_path: std::option::Option<std::string::String>,
        pub(crate) replace: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The Amazon Simple Storage Service (Amazon S3) path from where you will import the labels.</p>
        pub fn input_s3_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.input_s3_path = Some(input.into());
            self
        }
        /// <p>The Amazon Simple Storage Service (Amazon S3) path from where you will import the labels.</p>
        pub fn set_input_s3_path(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.input_s3_path = input;
            self
        }
        /// <p>Indicates whether to overwrite your existing labels.</p>
        pub fn replace(mut self, input: bool) -> Self {
            self.replace = Some(input);
            self
        }
        /// <p>Indicates whether to overwrite your existing labels.</p>
        pub fn set_replace(mut self, input: std::option::Option<bool>) -> Self {
            self.replace = input;
            self
        }
        /// Consumes the builder and constructs a [`ImportLabelsTaskRunProperties`](crate::model::ImportLabelsTaskRunProperties).
        pub fn build(self) -> crate::model::ImportLabelsTaskRunProperties {
            crate::model::ImportLabelsTaskRunProperties {
                input_s3_path: self.input_s3_path,
                replace: self.replace.unwrap_or_default(),
            }
        }
    }
}
impl ImportLabelsTaskRunProperties {
    /// Creates a new builder-style object to manufacture [`ImportLabelsTaskRunProperties`](crate::model::ImportLabelsTaskRunProperties).
    pub fn builder() -> crate::model::import_labels_task_run_properties::Builder {
        crate::model::import_labels_task_run_properties::Builder::default()
    }
}

/// When writing a match expression against `TaskType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let tasktype = unimplemented!();
/// match tasktype {
///     TaskType::Evaluation => { /* ... */ },
///     TaskType::ExportLabels => { /* ... */ },
///     TaskType::FindMatches => { /* ... */ },
///     TaskType::ImportLabels => { /* ... */ },
///     TaskType::LabelingSetGeneration => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `tasktype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `TaskType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `TaskType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `TaskType::NewFeature` is defined.
/// Specifically, when `tasktype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `TaskType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TaskType {
    #[allow(missing_docs)] // documentation missing in model
    Evaluation,
    #[allow(missing_docs)] // documentation missing in model
    ExportLabels,
    #[allow(missing_docs)] // documentation missing in model
    FindMatches,
    #[allow(missing_docs)] // documentation missing in model
    ImportLabels,
    #[allow(missing_docs)] // documentation missing in model
    LabelingSetGeneration,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for TaskType {
    fn from(s: &str) -> Self {
        match s {
            "EVALUATION" => TaskType::Evaluation,
            "EXPORT_LABELS" => TaskType::ExportLabels,
            "FIND_MATCHES" => TaskType::FindMatches,
            "IMPORT_LABELS" => TaskType::ImportLabels,
            "LABELING_SET_GENERATION" => TaskType::LabelingSetGeneration,
            other => TaskType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for TaskType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TaskType::from(s))
    }
}
impl TaskType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            TaskType::Evaluation => "EVALUATION",
            TaskType::ExportLabels => "EXPORT_LABELS",
            TaskType::FindMatches => "FIND_MATCHES",
            TaskType::ImportLabels => "IMPORT_LABELS",
            TaskType::LabelingSetGeneration => "LABELING_SET_GENERATION",
            TaskType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "EVALUATION",
            "EXPORT_LABELS",
            "FIND_MATCHES",
            "IMPORT_LABELS",
            "LABELING_SET_GENERATION",
        ]
    }
}
impl AsRef<str> for TaskType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The sorting criteria that are used to sort the list of task runs for the machine learning transform.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TaskRunSortCriteria {
    /// <p>The column to be used to sort the list of task runs for the machine learning transform.</p>
    #[doc(hidden)]
    pub column: std::option::Option<crate::model::TaskRunSortColumnType>,
    /// <p>The sort direction to be used to sort the list of task runs for the machine learning transform.</p>
    #[doc(hidden)]
    pub sort_direction: std::option::Option<crate::model::SortDirectionType>,
}
impl TaskRunSortCriteria {
    /// <p>The column to be used to sort the list of task runs for the machine learning transform.</p>
    pub fn column(&self) -> std::option::Option<&crate::model::TaskRunSortColumnType> {
        self.column.as_ref()
    }
    /// <p>The sort direction to be used to sort the list of task runs for the machine learning transform.</p>
    pub fn sort_direction(&self) -> std::option::Option<&crate::model::SortDirectionType> {
        self.sort_direction.as_ref()
    }
}
/// See [`TaskRunSortCriteria`](crate::model::TaskRunSortCriteria).
pub mod task_run_sort_criteria {

    /// A builder for [`TaskRunSortCriteria`](crate::model::TaskRunSortCriteria).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) column: std::option::Option<crate::model::TaskRunSortColumnType>,
        pub(crate) sort_direction: std::option::Option<crate::model::SortDirectionType>,
    }
    impl Builder {
        /// <p>The column to be used to sort the list of task runs for the machine learning transform.</p>
        pub fn column(mut self, input: crate::model::TaskRunSortColumnType) -> Self {
            self.column = Some(input);
            self
        }
        /// <p>The column to be used to sort the list of task runs for the machine learning transform.</p>
        pub fn set_column(
            mut self,
            input: std::option::Option<crate::model::TaskRunSortColumnType>,
        ) -> Self {
            self.column = input;
            self
        }
        /// <p>The sort direction to be used to sort the list of task runs for the machine learning transform.</p>
        pub fn sort_direction(mut self, input: crate::model::SortDirectionType) -> Self {
            self.sort_direction = Some(input);
            self
        }
        /// <p>The sort direction to be used to sort the list of task runs for the machine learning transform.</p>
        pub fn set_sort_direction(
            mut self,
            input: std::option::Option<crate::model::SortDirectionType>,
        ) -> Self {
            self.sort_direction = input;
            self
        }
        /// Consumes the builder and constructs a [`TaskRunSortCriteria`](crate::model::TaskRunSortCriteria).
        pub fn build(self) -> crate::model::TaskRunSortCriteria {
            crate::model::TaskRunSortCriteria {
                column: self.column,
                sort_direction: self.sort_direction,
            }
        }
    }
}
impl TaskRunSortCriteria {
    /// Creates a new builder-style object to manufacture [`TaskRunSortCriteria`](crate::model::TaskRunSortCriteria).
    pub fn builder() -> crate::model::task_run_sort_criteria::Builder {
        crate::model::task_run_sort_criteria::Builder::default()
    }
}

/// When writing a match expression against `TaskRunSortColumnType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let taskrunsortcolumntype = unimplemented!();
/// match taskrunsortcolumntype {
///     TaskRunSortColumnType::Started => { /* ... */ },
///     TaskRunSortColumnType::Status => { /* ... */ },
///     TaskRunSortColumnType::TaskRunType => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `taskrunsortcolumntype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `TaskRunSortColumnType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `TaskRunSortColumnType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `TaskRunSortColumnType::NewFeature` is defined.
/// Specifically, when `taskrunsortcolumntype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `TaskRunSortColumnType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TaskRunSortColumnType {
    #[allow(missing_docs)] // documentation missing in model
    Started,
    #[allow(missing_docs)] // documentation missing in model
    Status,
    #[allow(missing_docs)] // documentation missing in model
    TaskRunType,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for TaskRunSortColumnType {
    fn from(s: &str) -> Self {
        match s {
            "STARTED" => TaskRunSortColumnType::Started,
            "STATUS" => TaskRunSortColumnType::Status,
            "TASK_RUN_TYPE" => TaskRunSortColumnType::TaskRunType,
            other => {
                TaskRunSortColumnType::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for TaskRunSortColumnType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TaskRunSortColumnType::from(s))
    }
}
impl TaskRunSortColumnType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            TaskRunSortColumnType::Started => "STARTED",
            TaskRunSortColumnType::Status => "STATUS",
            TaskRunSortColumnType::TaskRunType => "TASK_RUN_TYPE",
            TaskRunSortColumnType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["STARTED", "STATUS", "TASK_RUN_TYPE"]
    }
}
impl AsRef<str> for TaskRunSortColumnType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The criteria that are used to filter the task runs for the machine learning transform.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TaskRunFilterCriteria {
    /// <p>The type of task run.</p>
    #[doc(hidden)]
    pub task_run_type: std::option::Option<crate::model::TaskType>,
    /// <p>The current status of the task run.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::TaskStatusType>,
    /// <p>Filter on task runs started before this date.</p>
    #[doc(hidden)]
    pub started_before: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Filter on task runs started after this date.</p>
    #[doc(hidden)]
    pub started_after: std::option::Option<aws_smithy_types::DateTime>,
}
impl TaskRunFilterCriteria {
    /// <p>The type of task run.</p>
    pub fn task_run_type(&self) -> std::option::Option<&crate::model::TaskType> {
        self.task_run_type.as_ref()
    }
    /// <p>The current status of the task run.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::TaskStatusType> {
        self.status.as_ref()
    }
    /// <p>Filter on task runs started before this date.</p>
    pub fn started_before(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.started_before.as_ref()
    }
    /// <p>Filter on task runs started after this date.</p>
    pub fn started_after(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.started_after.as_ref()
    }
}
/// See [`TaskRunFilterCriteria`](crate::model::TaskRunFilterCriteria).
pub mod task_run_filter_criteria {

    /// A builder for [`TaskRunFilterCriteria`](crate::model::TaskRunFilterCriteria).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) task_run_type: std::option::Option<crate::model::TaskType>,
        pub(crate) status: std::option::Option<crate::model::TaskStatusType>,
        pub(crate) started_before: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) started_after: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The type of task run.</p>
        pub fn task_run_type(mut self, input: crate::model::TaskType) -> Self {
            self.task_run_type = Some(input);
            self
        }
        /// <p>The type of task run.</p>
        pub fn set_task_run_type(
            mut self,
            input: std::option::Option<crate::model::TaskType>,
        ) -> Self {
            self.task_run_type = input;
            self
        }
        /// <p>The current status of the task run.</p>
        pub fn status(mut self, input: crate::model::TaskStatusType) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The current status of the task run.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::TaskStatusType>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>Filter on task runs started before this date.</p>
        pub fn started_before(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.started_before = Some(input);
            self
        }
        /// <p>Filter on task runs started before this date.</p>
        pub fn set_started_before(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.started_before = input;
            self
        }
        /// <p>Filter on task runs started after this date.</p>
        pub fn started_after(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.started_after = Some(input);
            self
        }
        /// <p>Filter on task runs started after this date.</p>
        pub fn set_started_after(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.started_after = input;
            self
        }
        /// Consumes the builder and constructs a [`TaskRunFilterCriteria`](crate::model::TaskRunFilterCriteria).
        pub fn build(self) -> crate::model::TaskRunFilterCriteria {
            crate::model::TaskRunFilterCriteria {
                task_run_type: self.task_run_type,
                status: self.status,
                started_before: self.started_before,
                started_after: self.started_after,
            }
        }
    }
}
impl TaskRunFilterCriteria {
    /// Creates a new builder-style object to manufacture [`TaskRunFilterCriteria`](crate::model::TaskRunFilterCriteria).
    pub fn builder() -> crate::model::task_run_filter_criteria::Builder {
        crate::model::task_run_filter_criteria::Builder::default()
    }
}

/// <p>Specifies a job definition.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Job {
    /// <p>The name you assign to this job definition.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>A description of the job.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>This field is reserved for future use.</p>
    #[doc(hidden)]
    pub log_uri: std::option::Option<std::string::String>,
    /// <p>The name or Amazon Resource Name (ARN) of the IAM role associated with this job.</p>
    #[doc(hidden)]
    pub role: std::option::Option<std::string::String>,
    /// <p>The time and date that this job definition was created.</p>
    #[doc(hidden)]
    pub created_on: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The last point in time when this job definition was modified.</p>
    #[doc(hidden)]
    pub last_modified_on: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>An <code>ExecutionProperty</code> specifying the maximum number of concurrent runs allowed for this job.</p>
    #[doc(hidden)]
    pub execution_property: std::option::Option<crate::model::ExecutionProperty>,
    /// <p>The <code>JobCommand</code> that runs this job.</p>
    #[doc(hidden)]
    pub command: std::option::Option<crate::model::JobCommand>,
    /// <p>The default arguments for this job, specified as name-value pairs.</p>
    /// <p>You can specify arguments here that your own job-execution script consumes, as well as arguments that Glue itself consumes.</p>
    /// <p>For information about how to specify and consume your own Job arguments, see the <a href="https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-python-calling.html">Calling Glue APIs in Python</a> topic in the developer guide.</p>
    /// <p>For information about the key-value pairs that Glue consumes to set up your job, see the <a href="https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-etl-glue-arguments.html">Special Parameters Used by Glue</a> topic in the developer guide.</p>
    #[doc(hidden)]
    pub default_arguments:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>Non-overridable arguments for this job, specified as name-value pairs.</p>
    #[doc(hidden)]
    pub non_overridable_arguments:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The connections used for this job.</p>
    #[doc(hidden)]
    pub connections: std::option::Option<crate::model::ConnectionsList>,
    /// <p>The maximum number of times to retry this job after a JobRun fails.</p>
    #[doc(hidden)]
    pub max_retries: i32,
    /// <p>This field is deprecated. Use <code>MaxCapacity</code> instead.</p>
    /// <p>The number of Glue data processing units (DPUs) allocated to runs of this job. You can allocate a minimum of 2 DPUs; the default is 10. A DPU is a relative measure of processing power that consists of 4 vCPUs of compute capacity and 16 GB of memory. For more information, see the <a href="https://aws.amazon.com/glue/pricing/">Glue pricing page</a>.</p>
    /// <p></p>
    #[deprecated(note = "This property is deprecated, use MaxCapacity instead.")]
    #[doc(hidden)]
    pub allocated_capacity: i32,
    /// <p>The job timeout in minutes. This is the maximum time that a job run can consume resources before it is terminated and enters <code>TIMEOUT</code> status. The default is 2,880 minutes (48 hours).</p>
    #[doc(hidden)]
    pub timeout: std::option::Option<i32>,
    /// <p>For Glue version 1.0 or earlier jobs, using the standard worker type, the number of Glue data processing units (DPUs) that can be allocated when this job runs. A DPU is a relative measure of processing power that consists of 4 vCPUs of compute capacity and 16 GB of memory. For more information, see the <a href="https://aws.amazon.com/glue/pricing/">Glue pricing page</a>.</p>
    /// <p>Do not set <code>Max Capacity</code> if using <code>WorkerType</code> and <code>NumberOfWorkers</code>.</p>
    /// <p>The value that can be allocated for <code>MaxCapacity</code> depends on whether you are running a Python shell job, an Apache Spark ETL job, or an Apache Spark streaming ETL job:</p>
    /// <ul>
    /// <li> <p>When you specify a Python shell job (<code>JobCommand.Name</code>="pythonshell"), you can allocate either 0.0625 or 1 DPU. The default is 0.0625 DPU.</p> </li>
    /// <li> <p>When you specify an Apache Spark ETL job (<code>JobCommand.Name</code>="glueetl") or Apache Spark streaming ETL job (<code>JobCommand.Name</code>="gluestreaming"), you can allocate a minimum of 2 DPUs. The default is 10 DPUs. This job type cannot have a fractional DPU allocation.</p> </li>
    /// </ul>
    /// <p>For Glue version 2.0 jobs, you cannot instead specify a <code>Maximum capacity</code>. Instead, you should specify a <code>Worker type</code> and the <code>Number of workers</code>.</p>
    #[doc(hidden)]
    pub max_capacity: std::option::Option<f64>,
    /// <p>The type of predefined worker that is allocated when a job runs. Accepts a value of Standard, G.1X, G.2X, or G.025X.</p>
    /// <ul>
    /// <li> <p>For the <code>Standard</code> worker type, each worker provides 4 vCPU, 16 GB of memory and a 50GB disk, and 2 executors per worker.</p> </li>
    /// <li> <p>For the <code>G.1X</code> worker type, each worker maps to 1 DPU (4 vCPU, 16 GB of memory, 64 GB disk), and provides 1 executor per worker. We recommend this worker type for memory-intensive jobs.</p> </li>
    /// <li> <p>For the <code>G.2X</code> worker type, each worker maps to 2 DPU (8 vCPU, 32 GB of memory, 128 GB disk), and provides 1 executor per worker. We recommend this worker type for memory-intensive jobs.</p> </li>
    /// <li> <p>For the <code>G.025X</code> worker type, each worker maps to 0.25 DPU (2 vCPU, 4 GB of memory, 64 GB disk), and provides 1 executor per worker. We recommend this worker type for low volume streaming jobs. This worker type is only available for Glue version 3.0 streaming jobs.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub worker_type: std::option::Option<crate::model::WorkerType>,
    /// <p>The number of workers of a defined <code>workerType</code> that are allocated when a job runs.</p>
    #[doc(hidden)]
    pub number_of_workers: std::option::Option<i32>,
    /// <p>The name of the <code>SecurityConfiguration</code> structure to be used with this job.</p>
    #[doc(hidden)]
    pub security_configuration: std::option::Option<std::string::String>,
    /// <p>Specifies configuration properties of a job notification.</p>
    #[doc(hidden)]
    pub notification_property: std::option::Option<crate::model::NotificationProperty>,
    /// <p>Glue version determines the versions of Apache Spark and Python that Glue supports. The Python version indicates the version supported for jobs of type Spark. </p>
    /// <p>For more information about the available Glue versions and corresponding Spark and Python versions, see <a href="https://docs.aws.amazon.com/glue/latest/dg/add-job.html">Glue version</a> in the developer guide.</p>
    /// <p>Jobs that are created without specifying a Glue version default to Glue 0.9.</p>
    #[doc(hidden)]
    pub glue_version: std::option::Option<std::string::String>,
    /// <p>The representation of a directed acyclic graph on which both the Glue Studio visual component and Glue Studio code generation is based.</p>
    #[doc(hidden)]
    pub code_gen_configuration_nodes: std::option::Option<
        std::collections::HashMap<std::string::String, crate::model::CodeGenConfigurationNode>,
    >,
    /// <p>Indicates whether the job is run with a standard or flexible execution class. The standard execution class is ideal for time-sensitive workloads that require fast job startup and dedicated resources.</p>
    /// <p>The flexible execution class is appropriate for time-insensitive jobs whose start and completion times may vary. </p>
    /// <p>Only jobs with Glue version 3.0 and above and command type <code>glueetl</code> will be allowed to set <code>ExecutionClass</code> to <code>FLEX</code>. The flexible execution class is available for Spark jobs.</p>
    #[doc(hidden)]
    pub execution_class: std::option::Option<crate::model::ExecutionClass>,
    /// <p>The details for a source control configuration for a job, allowing synchronization of job artifacts to or from a remote repository.</p>
    #[doc(hidden)]
    pub source_control_details: std::option::Option<crate::model::SourceControlDetails>,
}
impl Job {
    /// <p>The name you assign to this job definition.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>A description of the job.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>This field is reserved for future use.</p>
    pub fn log_uri(&self) -> std::option::Option<&str> {
        self.log_uri.as_deref()
    }
    /// <p>The name or Amazon Resource Name (ARN) of the IAM role associated with this job.</p>
    pub fn role(&self) -> std::option::Option<&str> {
        self.role.as_deref()
    }
    /// <p>The time and date that this job definition was created.</p>
    pub fn created_on(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_on.as_ref()
    }
    /// <p>The last point in time when this job definition was modified.</p>
    pub fn last_modified_on(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_modified_on.as_ref()
    }
    /// <p>An <code>ExecutionProperty</code> specifying the maximum number of concurrent runs allowed for this job.</p>
    pub fn execution_property(&self) -> std::option::Option<&crate::model::ExecutionProperty> {
        self.execution_property.as_ref()
    }
    /// <p>The <code>JobCommand</code> that runs this job.</p>
    pub fn command(&self) -> std::option::Option<&crate::model::JobCommand> {
        self.command.as_ref()
    }
    /// <p>The default arguments for this job, specified as name-value pairs.</p>
    /// <p>You can specify arguments here that your own job-execution script consumes, as well as arguments that Glue itself consumes.</p>
    /// <p>For information about how to specify and consume your own Job arguments, see the <a href="https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-python-calling.html">Calling Glue APIs in Python</a> topic in the developer guide.</p>
    /// <p>For information about the key-value pairs that Glue consumes to set up your job, see the <a href="https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-etl-glue-arguments.html">Special Parameters Used by Glue</a> topic in the developer guide.</p>
    pub fn default_arguments(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.default_arguments.as_ref()
    }
    /// <p>Non-overridable arguments for this job, specified as name-value pairs.</p>
    pub fn non_overridable_arguments(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.non_overridable_arguments.as_ref()
    }
    /// <p>The connections used for this job.</p>
    pub fn connections(&self) -> std::option::Option<&crate::model::ConnectionsList> {
        self.connections.as_ref()
    }
    /// <p>The maximum number of times to retry this job after a JobRun fails.</p>
    pub fn max_retries(&self) -> i32 {
        self.max_retries
    }
    /// <p>This field is deprecated. Use <code>MaxCapacity</code> instead.</p>
    /// <p>The number of Glue data processing units (DPUs) allocated to runs of this job. You can allocate a minimum of 2 DPUs; the default is 10. A DPU is a relative measure of processing power that consists of 4 vCPUs of compute capacity and 16 GB of memory. For more information, see the <a href="https://aws.amazon.com/glue/pricing/">Glue pricing page</a>.</p>
    /// <p></p>
    #[deprecated(note = "This property is deprecated, use MaxCapacity instead.")]
    pub fn allocated_capacity(&self) -> i32 {
        self.allocated_capacity
    }
    /// <p>The job timeout in minutes. This is the maximum time that a job run can consume resources before it is terminated and enters <code>TIMEOUT</code> status. The default is 2,880 minutes (48 hours).</p>
    pub fn timeout(&self) -> std::option::Option<i32> {
        self.timeout
    }
    /// <p>For Glue version 1.0 or earlier jobs, using the standard worker type, the number of Glue data processing units (DPUs) that can be allocated when this job runs. A DPU is a relative measure of processing power that consists of 4 vCPUs of compute capacity and 16 GB of memory. For more information, see the <a href="https://aws.amazon.com/glue/pricing/">Glue pricing page</a>.</p>
    /// <p>Do not set <code>Max Capacity</code> if using <code>WorkerType</code> and <code>NumberOfWorkers</code>.</p>
    /// <p>The value that can be allocated for <code>MaxCapacity</code> depends on whether you are running a Python shell job, an Apache Spark ETL job, or an Apache Spark streaming ETL job:</p>
    /// <ul>
    /// <li> <p>When you specify a Python shell job (<code>JobCommand.Name</code>="pythonshell"), you can allocate either 0.0625 or 1 DPU. The default is 0.0625 DPU.</p> </li>
    /// <li> <p>When you specify an Apache Spark ETL job (<code>JobCommand.Name</code>="glueetl") or Apache Spark streaming ETL job (<code>JobCommand.Name</code>="gluestreaming"), you can allocate a minimum of 2 DPUs. The default is 10 DPUs. This job type cannot have a fractional DPU allocation.</p> </li>
    /// </ul>
    /// <p>For Glue version 2.0 jobs, you cannot instead specify a <code>Maximum capacity</code>. Instead, you should specify a <code>Worker type</code> and the <code>Number of workers</code>.</p>
    pub fn max_capacity(&self) -> std::option::Option<f64> {
        self.max_capacity
    }
    /// <p>The type of predefined worker that is allocated when a job runs. Accepts a value of Standard, G.1X, G.2X, or G.025X.</p>
    /// <ul>
    /// <li> <p>For the <code>Standard</code> worker type, each worker provides 4 vCPU, 16 GB of memory and a 50GB disk, and 2 executors per worker.</p> </li>
    /// <li> <p>For the <code>G.1X</code> worker type, each worker maps to 1 DPU (4 vCPU, 16 GB of memory, 64 GB disk), and provides 1 executor per worker. We recommend this worker type for memory-intensive jobs.</p> </li>
    /// <li> <p>For the <code>G.2X</code> worker type, each worker maps to 2 DPU (8 vCPU, 32 GB of memory, 128 GB disk), and provides 1 executor per worker. We recommend this worker type for memory-intensive jobs.</p> </li>
    /// <li> <p>For the <code>G.025X</code> worker type, each worker maps to 0.25 DPU (2 vCPU, 4 GB of memory, 64 GB disk), and provides 1 executor per worker. We recommend this worker type for low volume streaming jobs. This worker type is only available for Glue version 3.0 streaming jobs.</p> </li>
    /// </ul>
    pub fn worker_type(&self) -> std::option::Option<&crate::model::WorkerType> {
        self.worker_type.as_ref()
    }
    /// <p>The number of workers of a defined <code>workerType</code> that are allocated when a job runs.</p>
    pub fn number_of_workers(&self) -> std::option::Option<i32> {
        self.number_of_workers
    }
    /// <p>The name of the <code>SecurityConfiguration</code> structure to be used with this job.</p>
    pub fn security_configuration(&self) -> std::option::Option<&str> {
        self.security_configuration.as_deref()
    }
    /// <p>Specifies configuration properties of a job notification.</p>
    pub fn notification_property(
        &self,
    ) -> std::option::Option<&crate::model::NotificationProperty> {
        self.notification_property.as_ref()
    }
    /// <p>Glue version determines the versions of Apache Spark and Python that Glue supports. The Python version indicates the version supported for jobs of type Spark. </p>
    /// <p>For more information about the available Glue versions and corresponding Spark and Python versions, see <a href="https://docs.aws.amazon.com/glue/latest/dg/add-job.html">Glue version</a> in the developer guide.</p>
    /// <p>Jobs that are created without specifying a Glue version default to Glue 0.9.</p>
    pub fn glue_version(&self) -> std::option::Option<&str> {
        self.glue_version.as_deref()
    }
    /// <p>The representation of a directed acyclic graph on which both the Glue Studio visual component and Glue Studio code generation is based.</p>
    pub fn code_gen_configuration_nodes(
        &self,
    ) -> std::option::Option<
        &std::collections::HashMap<std::string::String, crate::model::CodeGenConfigurationNode>,
    > {
        self.code_gen_configuration_nodes.as_ref()
    }
    /// <p>Indicates whether the job is run with a standard or flexible execution class. The standard execution class is ideal for time-sensitive workloads that require fast job startup and dedicated resources.</p>
    /// <p>The flexible execution class is appropriate for time-insensitive jobs whose start and completion times may vary. </p>
    /// <p>Only jobs with Glue version 3.0 and above and command type <code>glueetl</code> will be allowed to set <code>ExecutionClass</code> to <code>FLEX</code>. The flexible execution class is available for Spark jobs.</p>
    pub fn execution_class(&self) -> std::option::Option<&crate::model::ExecutionClass> {
        self.execution_class.as_ref()
    }
    /// <p>The details for a source control configuration for a job, allowing synchronization of job artifacts to or from a remote repository.</p>
    pub fn source_control_details(
        &self,
    ) -> std::option::Option<&crate::model::SourceControlDetails> {
        self.source_control_details.as_ref()
    }
}
impl std::fmt::Debug for Job {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Job");
        formatter.field("name", &self.name);
        formatter.field("description", &self.description);
        formatter.field("log_uri", &self.log_uri);
        formatter.field("role", &self.role);
        formatter.field("created_on", &self.created_on);
        formatter.field("last_modified_on", &self.last_modified_on);
        formatter.field("execution_property", &self.execution_property);
        formatter.field("command", &self.command);
        formatter.field("default_arguments", &self.default_arguments);
        formatter.field("non_overridable_arguments", &self.non_overridable_arguments);
        formatter.field("connections", &self.connections);
        formatter.field("max_retries", &self.max_retries);
        formatter.field("allocated_capacity", &self.allocated_capacity);
        formatter.field("timeout", &self.timeout);
        formatter.field("max_capacity", &self.max_capacity);
        formatter.field("worker_type", &self.worker_type);
        formatter.field("number_of_workers", &self.number_of_workers);
        formatter.field("security_configuration", &self.security_configuration);
        formatter.field("notification_property", &self.notification_property);
        formatter.field("glue_version", &self.glue_version);
        formatter.field(
            "code_gen_configuration_nodes",
            &"*** Sensitive Data Redacted ***",
        );
        formatter.field("execution_class", &self.execution_class);
        formatter.field("source_control_details", &self.source_control_details);
        formatter.finish()
    }
}
/// See [`Job`](crate::model::Job).
pub mod job {

    /// A builder for [`Job`](crate::model::Job).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) log_uri: std::option::Option<std::string::String>,
        pub(crate) role: std::option::Option<std::string::String>,
        pub(crate) created_on: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_modified_on: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) execution_property: std::option::Option<crate::model::ExecutionProperty>,
        pub(crate) command: std::option::Option<crate::model::JobCommand>,
        pub(crate) default_arguments: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) non_overridable_arguments: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) connections: std::option::Option<crate::model::ConnectionsList>,
        pub(crate) max_retries: std::option::Option<i32>,
        pub(crate) allocated_capacity: std::option::Option<i32>,
        pub(crate) timeout: std::option::Option<i32>,
        pub(crate) max_capacity: std::option::Option<f64>,
        pub(crate) worker_type: std::option::Option<crate::model::WorkerType>,
        pub(crate) number_of_workers: std::option::Option<i32>,
        pub(crate) security_configuration: std::option::Option<std::string::String>,
        pub(crate) notification_property: std::option::Option<crate::model::NotificationProperty>,
        pub(crate) glue_version: std::option::Option<std::string::String>,
        pub(crate) code_gen_configuration_nodes: std::option::Option<
            std::collections::HashMap<std::string::String, crate::model::CodeGenConfigurationNode>,
        >,
        pub(crate) execution_class: std::option::Option<crate::model::ExecutionClass>,
        pub(crate) source_control_details: std::option::Option<crate::model::SourceControlDetails>,
    }
    impl Builder {
        /// <p>The name you assign to this job definition.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name you assign to this job definition.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>A description of the job.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A description of the job.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>This field is reserved for future use.</p>
        pub fn log_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.log_uri = Some(input.into());
            self
        }
        /// <p>This field is reserved for future use.</p>
        pub fn set_log_uri(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.log_uri = input;
            self
        }
        /// <p>The name or Amazon Resource Name (ARN) of the IAM role associated with this job.</p>
        pub fn role(mut self, input: impl Into<std::string::String>) -> Self {
            self.role = Some(input.into());
            self
        }
        /// <p>The name or Amazon Resource Name (ARN) of the IAM role associated with this job.</p>
        pub fn set_role(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.role = input;
            self
        }
        /// <p>The time and date that this job definition was created.</p>
        pub fn created_on(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_on = Some(input);
            self
        }
        /// <p>The time and date that this job definition was created.</p>
        pub fn set_created_on(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_on = input;
            self
        }
        /// <p>The last point in time when this job definition was modified.</p>
        pub fn last_modified_on(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_modified_on = Some(input);
            self
        }
        /// <p>The last point in time when this job definition was modified.</p>
        pub fn set_last_modified_on(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_modified_on = input;
            self
        }
        /// <p>An <code>ExecutionProperty</code> specifying the maximum number of concurrent runs allowed for this job.</p>
        pub fn execution_property(mut self, input: crate::model::ExecutionProperty) -> Self {
            self.execution_property = Some(input);
            self
        }
        /// <p>An <code>ExecutionProperty</code> specifying the maximum number of concurrent runs allowed for this job.</p>
        pub fn set_execution_property(
            mut self,
            input: std::option::Option<crate::model::ExecutionProperty>,
        ) -> Self {
            self.execution_property = input;
            self
        }
        /// <p>The <code>JobCommand</code> that runs this job.</p>
        pub fn command(mut self, input: crate::model::JobCommand) -> Self {
            self.command = Some(input);
            self
        }
        /// <p>The <code>JobCommand</code> that runs this job.</p>
        pub fn set_command(mut self, input: std::option::Option<crate::model::JobCommand>) -> Self {
            self.command = input;
            self
        }
        /// Adds a key-value pair to `default_arguments`.
        ///
        /// To override the contents of this collection use [`set_default_arguments`](Self::set_default_arguments).
        ///
        /// <p>The default arguments for this job, specified as name-value pairs.</p>
        /// <p>You can specify arguments here that your own job-execution script consumes, as well as arguments that Glue itself consumes.</p>
        /// <p>For information about how to specify and consume your own Job arguments, see the <a href="https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-python-calling.html">Calling Glue APIs in Python</a> topic in the developer guide.</p>
        /// <p>For information about the key-value pairs that Glue consumes to set up your job, see the <a href="https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-etl-glue-arguments.html">Special Parameters Used by Glue</a> topic in the developer guide.</p>
        pub fn default_arguments(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.default_arguments.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.default_arguments = Some(hash_map);
            self
        }
        /// <p>The default arguments for this job, specified as name-value pairs.</p>
        /// <p>You can specify arguments here that your own job-execution script consumes, as well as arguments that Glue itself consumes.</p>
        /// <p>For information about how to specify and consume your own Job arguments, see the <a href="https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-python-calling.html">Calling Glue APIs in Python</a> topic in the developer guide.</p>
        /// <p>For information about the key-value pairs that Glue consumes to set up your job, see the <a href="https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-etl-glue-arguments.html">Special Parameters Used by Glue</a> topic in the developer guide.</p>
        pub fn set_default_arguments(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.default_arguments = input;
            self
        }
        /// Adds a key-value pair to `non_overridable_arguments`.
        ///
        /// To override the contents of this collection use [`set_non_overridable_arguments`](Self::set_non_overridable_arguments).
        ///
        /// <p>Non-overridable arguments for this job, specified as name-value pairs.</p>
        pub fn non_overridable_arguments(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.non_overridable_arguments.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.non_overridable_arguments = Some(hash_map);
            self
        }
        /// <p>Non-overridable arguments for this job, specified as name-value pairs.</p>
        pub fn set_non_overridable_arguments(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.non_overridable_arguments = input;
            self
        }
        /// <p>The connections used for this job.</p>
        pub fn connections(mut self, input: crate::model::ConnectionsList) -> Self {
            self.connections = Some(input);
            self
        }
        /// <p>The connections used for this job.</p>
        pub fn set_connections(
            mut self,
            input: std::option::Option<crate::model::ConnectionsList>,
        ) -> Self {
            self.connections = input;
            self
        }
        /// <p>The maximum number of times to retry this job after a JobRun fails.</p>
        pub fn max_retries(mut self, input: i32) -> Self {
            self.max_retries = Some(input);
            self
        }
        /// <p>The maximum number of times to retry this job after a JobRun fails.</p>
        pub fn set_max_retries(mut self, input: std::option::Option<i32>) -> Self {
            self.max_retries = input;
            self
        }
        /// <p>This field is deprecated. Use <code>MaxCapacity</code> instead.</p>
        /// <p>The number of Glue data processing units (DPUs) allocated to runs of this job. You can allocate a minimum of 2 DPUs; the default is 10. A DPU is a relative measure of processing power that consists of 4 vCPUs of compute capacity and 16 GB of memory. For more information, see the <a href="https://aws.amazon.com/glue/pricing/">Glue pricing page</a>.</p>
        /// <p></p>
        #[deprecated(note = "This property is deprecated, use MaxCapacity instead.")]
        pub fn allocated_capacity(mut self, input: i32) -> Self {
            self.allocated_capacity = Some(input);
            self
        }
        /// <p>This field is deprecated. Use <code>MaxCapacity</code> instead.</p>
        /// <p>The number of Glue data processing units (DPUs) allocated to runs of this job. You can allocate a minimum of 2 DPUs; the default is 10. A DPU is a relative measure of processing power that consists of 4 vCPUs of compute capacity and 16 GB of memory. For more information, see the <a href="https://aws.amazon.com/glue/pricing/">Glue pricing page</a>.</p>
        /// <p></p>
        #[deprecated(note = "This property is deprecated, use MaxCapacity instead.")]
        pub fn set_allocated_capacity(mut self, input: std::option::Option<i32>) -> Self {
            self.allocated_capacity = input;
            self
        }
        /// <p>The job timeout in minutes. This is the maximum time that a job run can consume resources before it is terminated and enters <code>TIMEOUT</code> status. The default is 2,880 minutes (48 hours).</p>
        pub fn timeout(mut self, input: i32) -> Self {
            self.timeout = Some(input);
            self
        }
        /// <p>The job timeout in minutes. This is the maximum time that a job run can consume resources before it is terminated and enters <code>TIMEOUT</code> status. The default is 2,880 minutes (48 hours).</p>
        pub fn set_timeout(mut self, input: std::option::Option<i32>) -> Self {
            self.timeout = input;
            self
        }
        /// <p>For Glue version 1.0 or earlier jobs, using the standard worker type, the number of Glue data processing units (DPUs) that can be allocated when this job runs. A DPU is a relative measure of processing power that consists of 4 vCPUs of compute capacity and 16 GB of memory. For more information, see the <a href="https://aws.amazon.com/glue/pricing/">Glue pricing page</a>.</p>
        /// <p>Do not set <code>Max Capacity</code> if using <code>WorkerType</code> and <code>NumberOfWorkers</code>.</p>
        /// <p>The value that can be allocated for <code>MaxCapacity</code> depends on whether you are running a Python shell job, an Apache Spark ETL job, or an Apache Spark streaming ETL job:</p>
        /// <ul>
        /// <li> <p>When you specify a Python shell job (<code>JobCommand.Name</code>="pythonshell"), you can allocate either 0.0625 or 1 DPU. The default is 0.0625 DPU.</p> </li>
        /// <li> <p>When you specify an Apache Spark ETL job (<code>JobCommand.Name</code>="glueetl") or Apache Spark streaming ETL job (<code>JobCommand.Name</code>="gluestreaming"), you can allocate a minimum of 2 DPUs. The default is 10 DPUs. This job type cannot have a fractional DPU allocation.</p> </li>
        /// </ul>
        /// <p>For Glue version 2.0 jobs, you cannot instead specify a <code>Maximum capacity</code>. Instead, you should specify a <code>Worker type</code> and the <code>Number of workers</code>.</p>
        pub fn max_capacity(mut self, input: f64) -> Self {
            self.max_capacity = Some(input);
            self
        }
        /// <p>For Glue version 1.0 or earlier jobs, using the standard worker type, the number of Glue data processing units (DPUs) that can be allocated when this job runs. A DPU is a relative measure of processing power that consists of 4 vCPUs of compute capacity and 16 GB of memory. For more information, see the <a href="https://aws.amazon.com/glue/pricing/">Glue pricing page</a>.</p>
        /// <p>Do not set <code>Max Capacity</code> if using <code>WorkerType</code> and <code>NumberOfWorkers</code>.</p>
        /// <p>The value that can be allocated for <code>MaxCapacity</code> depends on whether you are running a Python shell job, an Apache Spark ETL job, or an Apache Spark streaming ETL job:</p>
        /// <ul>
        /// <li> <p>When you specify a Python shell job (<code>JobCommand.Name</code>="pythonshell"), you can allocate either 0.0625 or 1 DPU. The default is 0.0625 DPU.</p> </li>
        /// <li> <p>When you specify an Apache Spark ETL job (<code>JobCommand.Name</code>="glueetl") or Apache Spark streaming ETL job (<code>JobCommand.Name</code>="gluestreaming"), you can allocate a minimum of 2 DPUs. The default is 10 DPUs. This job type cannot have a fractional DPU allocation.</p> </li>
        /// </ul>
        /// <p>For Glue version 2.0 jobs, you cannot instead specify a <code>Maximum capacity</code>. Instead, you should specify a <code>Worker type</code> and the <code>Number of workers</code>.</p>
        pub fn set_max_capacity(mut self, input: std::option::Option<f64>) -> Self {
            self.max_capacity = input;
            self
        }
        /// <p>The type of predefined worker that is allocated when a job runs. Accepts a value of Standard, G.1X, G.2X, or G.025X.</p>
        /// <ul>
        /// <li> <p>For the <code>Standard</code> worker type, each worker provides 4 vCPU, 16 GB of memory and a 50GB disk, and 2 executors per worker.</p> </li>
        /// <li> <p>For the <code>G.1X</code> worker type, each worker maps to 1 DPU (4 vCPU, 16 GB of memory, 64 GB disk), and provides 1 executor per worker. We recommend this worker type for memory-intensive jobs.</p> </li>
        /// <li> <p>For the <code>G.2X</code> worker type, each worker maps to 2 DPU (8 vCPU, 32 GB of memory, 128 GB disk), and provides 1 executor per worker. We recommend this worker type for memory-intensive jobs.</p> </li>
        /// <li> <p>For the <code>G.025X</code> worker type, each worker maps to 0.25 DPU (2 vCPU, 4 GB of memory, 64 GB disk), and provides 1 executor per worker. We recommend this worker type for low volume streaming jobs. This worker type is only available for Glue version 3.0 streaming jobs.</p> </li>
        /// </ul>
        pub fn worker_type(mut self, input: crate::model::WorkerType) -> Self {
            self.worker_type = Some(input);
            self
        }
        /// <p>The type of predefined worker that is allocated when a job runs. Accepts a value of Standard, G.1X, G.2X, or G.025X.</p>
        /// <ul>
        /// <li> <p>For the <code>Standard</code> worker type, each worker provides 4 vCPU, 16 GB of memory and a 50GB disk, and 2 executors per worker.</p> </li>
        /// <li> <p>For the <code>G.1X</code> worker type, each worker maps to 1 DPU (4 vCPU, 16 GB of memory, 64 GB disk), and provides 1 executor per worker. We recommend this worker type for memory-intensive jobs.</p> </li>
        /// <li> <p>For the <code>G.2X</code> worker type, each worker maps to 2 DPU (8 vCPU, 32 GB of memory, 128 GB disk), and provides 1 executor per worker. We recommend this worker type for memory-intensive jobs.</p> </li>
        /// <li> <p>For the <code>G.025X</code> worker type, each worker maps to 0.25 DPU (2 vCPU, 4 GB of memory, 64 GB disk), and provides 1 executor per worker. We recommend this worker type for low volume streaming jobs. This worker type is only available for Glue version 3.0 streaming jobs.</p> </li>
        /// </ul>
        pub fn set_worker_type(
            mut self,
            input: std::option::Option<crate::model::WorkerType>,
        ) -> Self {
            self.worker_type = input;
            self
        }
        /// <p>The number of workers of a defined <code>workerType</code> that are allocated when a job runs.</p>
        pub fn number_of_workers(mut self, input: i32) -> Self {
            self.number_of_workers = Some(input);
            self
        }
        /// <p>The number of workers of a defined <code>workerType</code> that are allocated when a job runs.</p>
        pub fn set_number_of_workers(mut self, input: std::option::Option<i32>) -> Self {
            self.number_of_workers = input;
            self
        }
        /// <p>The name of the <code>SecurityConfiguration</code> structure to be used with this job.</p>
        pub fn security_configuration(mut self, input: impl Into<std::string::String>) -> Self {
            self.security_configuration = Some(input.into());
            self
        }
        /// <p>The name of the <code>SecurityConfiguration</code> structure to be used with this job.</p>
        pub fn set_security_configuration(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.security_configuration = input;
            self
        }
        /// <p>Specifies configuration properties of a job notification.</p>
        pub fn notification_property(mut self, input: crate::model::NotificationProperty) -> Self {
            self.notification_property = Some(input);
            self
        }
        /// <p>Specifies configuration properties of a job notification.</p>
        pub fn set_notification_property(
            mut self,
            input: std::option::Option<crate::model::NotificationProperty>,
        ) -> Self {
            self.notification_property = input;
            self
        }
        /// <p>Glue version determines the versions of Apache Spark and Python that Glue supports. The Python version indicates the version supported for jobs of type Spark. </p>
        /// <p>For more information about the available Glue versions and corresponding Spark and Python versions, see <a href="https://docs.aws.amazon.com/glue/latest/dg/add-job.html">Glue version</a> in the developer guide.</p>
        /// <p>Jobs that are created without specifying a Glue version default to Glue 0.9.</p>
        pub fn glue_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.glue_version = Some(input.into());
            self
        }
        /// <p>Glue version determines the versions of Apache Spark and Python that Glue supports. The Python version indicates the version supported for jobs of type Spark. </p>
        /// <p>For more information about the available Glue versions and corresponding Spark and Python versions, see <a href="https://docs.aws.amazon.com/glue/latest/dg/add-job.html">Glue version</a> in the developer guide.</p>
        /// <p>Jobs that are created without specifying a Glue version default to Glue 0.9.</p>
        pub fn set_glue_version(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.glue_version = input;
            self
        }
        /// Adds a key-value pair to `code_gen_configuration_nodes`.
        ///
        /// To override the contents of this collection use [`set_code_gen_configuration_nodes`](Self::set_code_gen_configuration_nodes).
        ///
        /// <p>The representation of a directed acyclic graph on which both the Glue Studio visual component and Glue Studio code generation is based.</p>
        pub fn code_gen_configuration_nodes(
            mut self,
            k: impl Into<std::string::String>,
            v: crate::model::CodeGenConfigurationNode,
        ) -> Self {
            let mut hash_map = self.code_gen_configuration_nodes.unwrap_or_default();
            hash_map.insert(k.into(), v);
            self.code_gen_configuration_nodes = Some(hash_map);
            self
        }
        /// <p>The representation of a directed acyclic graph on which both the Glue Studio visual component and Glue Studio code generation is based.</p>
        pub fn set_code_gen_configuration_nodes(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<
                    std::string::String,
                    crate::model::CodeGenConfigurationNode,
                >,
            >,
        ) -> Self {
            self.code_gen_configuration_nodes = input;
            self
        }
        /// <p>Indicates whether the job is run with a standard or flexible execution class. The standard execution class is ideal for time-sensitive workloads that require fast job startup and dedicated resources.</p>
        /// <p>The flexible execution class is appropriate for time-insensitive jobs whose start and completion times may vary. </p>
        /// <p>Only jobs with Glue version 3.0 and above and command type <code>glueetl</code> will be allowed to set <code>ExecutionClass</code> to <code>FLEX</code>. The flexible execution class is available for Spark jobs.</p>
        pub fn execution_class(mut self, input: crate::model::ExecutionClass) -> Self {
            self.execution_class = Some(input);
            self
        }
        /// <p>Indicates whether the job is run with a standard or flexible execution class. The standard execution class is ideal for time-sensitive workloads that require fast job startup and dedicated resources.</p>
        /// <p>The flexible execution class is appropriate for time-insensitive jobs whose start and completion times may vary. </p>
        /// <p>Only jobs with Glue version 3.0 and above and command type <code>glueetl</code> will be allowed to set <code>ExecutionClass</code> to <code>FLEX</code>. The flexible execution class is available for Spark jobs.</p>
        pub fn set_execution_class(
            mut self,
            input: std::option::Option<crate::model::ExecutionClass>,
        ) -> Self {
            self.execution_class = input;
            self
        }
        /// <p>The details for a source control configuration for a job, allowing synchronization of job artifacts to or from a remote repository.</p>
        pub fn source_control_details(mut self, input: crate::model::SourceControlDetails) -> Self {
            self.source_control_details = Some(input);
            self
        }
        /// <p>The details for a source control configuration for a job, allowing synchronization of job artifacts to or from a remote repository.</p>
        pub fn set_source_control_details(
            mut self,
            input: std::option::Option<crate::model::SourceControlDetails>,
        ) -> Self {
            self.source_control_details = input;
            self
        }
        /// Consumes the builder and constructs a [`Job`](crate::model::Job).
        pub fn build(self) -> crate::model::Job {
            crate::model::Job {
                name: self.name,
                description: self.description,
                log_uri: self.log_uri,
                role: self.role,
                created_on: self.created_on,
                last_modified_on: self.last_modified_on,
                execution_property: self.execution_property,
                command: self.command,
                default_arguments: self.default_arguments,
                non_overridable_arguments: self.non_overridable_arguments,
                connections: self.connections,
                max_retries: self.max_retries.unwrap_or_default(),
                allocated_capacity: self.allocated_capacity.unwrap_or_default(),
                timeout: self.timeout,
                max_capacity: self.max_capacity,
                worker_type: self.worker_type,
                number_of_workers: self.number_of_workers,
                security_configuration: self.security_configuration,
                notification_property: self.notification_property,
                glue_version: self.glue_version,
                code_gen_configuration_nodes: self.code_gen_configuration_nodes,
                execution_class: self.execution_class,
                source_control_details: self.source_control_details,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("name", &self.name);
            formatter.field("description", &self.description);
            formatter.field("log_uri", &self.log_uri);
            formatter.field("role", &self.role);
            formatter.field("created_on", &self.created_on);
            formatter.field("last_modified_on", &self.last_modified_on);
            formatter.field("execution_property", &self.execution_property);
            formatter.field("command", &self.command);
            formatter.field("default_arguments", &self.default_arguments);
            formatter.field("non_overridable_arguments", &self.non_overridable_arguments);
            formatter.field("connections", &self.connections);
            formatter.field("max_retries", &self.max_retries);
            formatter.field("allocated_capacity", &self.allocated_capacity);
            formatter.field("timeout", &self.timeout);
            formatter.field("max_capacity", &self.max_capacity);
            formatter.field("worker_type", &self.worker_type);
            formatter.field("number_of_workers", &self.number_of_workers);
            formatter.field("security_configuration", &self.security_configuration);
            formatter.field("notification_property", &self.notification_property);
            formatter.field("glue_version", &self.glue_version);
            formatter.field(
                "code_gen_configuration_nodes",
                &"*** Sensitive Data Redacted ***",
            );
            formatter.field("execution_class", &self.execution_class);
            formatter.field("source_control_details", &self.source_control_details);
            formatter.finish()
        }
    }
}
impl Job {
    /// Creates a new builder-style object to manufacture [`Job`](crate::model::Job).
    pub fn builder() -> crate::model::job::Builder {
        crate::model::job::Builder::default()
    }
}

/// <p>A development endpoint where a developer can remotely debug extract, transform, and load (ETL) scripts.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DevEndpoint {
    /// <p>The name of the <code>DevEndpoint</code>.</p>
    #[doc(hidden)]
    pub endpoint_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the IAM role used in this <code>DevEndpoint</code>.</p>
    #[doc(hidden)]
    pub role_arn: std::option::Option<std::string::String>,
    /// <p>A list of security group identifiers used in this <code>DevEndpoint</code>.</p>
    #[doc(hidden)]
    pub security_group_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The subnet ID for this <code>DevEndpoint</code>.</p>
    #[doc(hidden)]
    pub subnet_id: std::option::Option<std::string::String>,
    /// <p>The YARN endpoint address used by this <code>DevEndpoint</code>.</p>
    #[doc(hidden)]
    pub yarn_endpoint_address: std::option::Option<std::string::String>,
    /// <p>A private IP address to access the <code>DevEndpoint</code> within a VPC if the <code>DevEndpoint</code> is created within one. The <code>PrivateAddress</code> field is present only when you create the <code>DevEndpoint</code> within your VPC.</p>
    #[doc(hidden)]
    pub private_address: std::option::Option<std::string::String>,
    /// <p>The Apache Zeppelin port for the remote Apache Spark interpreter.</p>
    #[doc(hidden)]
    pub zeppelin_remote_spark_interpreter_port: i32,
    /// <p>The public IP address used by this <code>DevEndpoint</code>. The <code>PublicAddress</code> field is present only when you create a non-virtual private cloud (VPC) <code>DevEndpoint</code>.</p>
    #[doc(hidden)]
    pub public_address: std::option::Option<std::string::String>,
    /// <p>The current status of this <code>DevEndpoint</code>.</p>
    #[doc(hidden)]
    pub status: std::option::Option<std::string::String>,
    /// <p>The type of predefined worker that is allocated to the development endpoint. Accepts a value of Standard, G.1X, or G.2X.</p>
    /// <ul>
    /// <li> <p>For the <code>Standard</code> worker type, each worker provides 4 vCPU, 16 GB of memory and a 50GB disk, and 2 executors per worker.</p> </li>
    /// <li> <p>For the <code>G.1X</code> worker type, each worker maps to 1 DPU (4 vCPU, 16 GB of memory, 64 GB disk), and provides 1 executor per worker. We recommend this worker type for memory-intensive jobs.</p> </li>
    /// <li> <p>For the <code>G.2X</code> worker type, each worker maps to 2 DPU (8 vCPU, 32 GB of memory, 128 GB disk), and provides 1 executor per worker. We recommend this worker type for memory-intensive jobs.</p> </li>
    /// </ul>
    /// <p>Known issue: when a development endpoint is created with the <code>G.2X</code> <code>WorkerType</code> configuration, the Spark drivers for the development endpoint will run on 4 vCPU, 16 GB of memory, and a 64 GB disk. </p>
    #[doc(hidden)]
    pub worker_type: std::option::Option<crate::model::WorkerType>,
    /// <p>Glue version determines the versions of Apache Spark and Python that Glue supports. The Python version indicates the version supported for running your ETL scripts on development endpoints. </p>
    /// <p>For more information about the available Glue versions and corresponding Spark and Python versions, see <a href="https://docs.aws.amazon.com/glue/latest/dg/add-job.html">Glue version</a> in the developer guide.</p>
    /// <p>Development endpoints that are created without specifying a Glue version default to Glue 0.9.</p>
    /// <p>You can specify a version of Python support for development endpoints by using the <code>Arguments</code> parameter in the <code>CreateDevEndpoint</code> or <code>UpdateDevEndpoint</code> APIs. If no arguments are provided, the version defaults to Python 2.</p>
    #[doc(hidden)]
    pub glue_version: std::option::Option<std::string::String>,
    /// <p>The number of workers of a defined <code>workerType</code> that are allocated to the development endpoint.</p>
    /// <p>The maximum number of workers you can define are 299 for <code>G.1X</code>, and 149 for <code>G.2X</code>. </p>
    #[doc(hidden)]
    pub number_of_workers: std::option::Option<i32>,
    /// <p>The number of Glue Data Processing Units (DPUs) allocated to this <code>DevEndpoint</code>.</p>
    #[doc(hidden)]
    pub number_of_nodes: i32,
    /// <p>The Amazon Web Services Availability Zone where this <code>DevEndpoint</code> is located.</p>
    #[doc(hidden)]
    pub availability_zone: std::option::Option<std::string::String>,
    /// <p>The ID of the virtual private cloud (VPC) used by this <code>DevEndpoint</code>.</p>
    #[doc(hidden)]
    pub vpc_id: std::option::Option<std::string::String>,
    /// <p>The paths to one or more Python libraries in an Amazon S3 bucket that should be loaded in your <code>DevEndpoint</code>. Multiple values must be complete paths separated by a comma.</p> <note>
    /// <p>You can only use pure Python libraries with a <code>DevEndpoint</code>. Libraries that rely on C extensions, such as the <a href="http://pandas.pydata.org/">pandas</a> Python data analysis library, are not currently supported.</p>
    /// </note>
    #[doc(hidden)]
    pub extra_python_libs_s3_path: std::option::Option<std::string::String>,
    /// <p>The path to one or more Java <code>.jar</code> files in an S3 bucket that should be loaded in your <code>DevEndpoint</code>.</p> <note>
    /// <p>You can only use pure Java/Scala libraries with a <code>DevEndpoint</code>.</p>
    /// </note>
    #[doc(hidden)]
    pub extra_jars_s3_path: std::option::Option<std::string::String>,
    /// <p>The reason for a current failure in this <code>DevEndpoint</code>.</p>
    #[doc(hidden)]
    pub failure_reason: std::option::Option<std::string::String>,
    /// <p>The status of the last update.</p>
    #[doc(hidden)]
    pub last_update_status: std::option::Option<std::string::String>,
    /// <p>The point in time at which this DevEndpoint was created.</p>
    #[doc(hidden)]
    pub created_timestamp: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The point in time at which this <code>DevEndpoint</code> was last modified.</p>
    #[doc(hidden)]
    pub last_modified_timestamp: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The public key to be used by this <code>DevEndpoint</code> for authentication. This attribute is provided for backward compatibility because the recommended attribute to use is public keys.</p>
    #[doc(hidden)]
    pub public_key: std::option::Option<std::string::String>,
    /// <p>A list of public keys to be used by the <code>DevEndpoints</code> for authentication. Using this attribute is preferred over a single public key because the public keys allow you to have a different private key per client.</p> <note>
    /// <p>If you previously created an endpoint with a public key, you must remove that key to be able to set a list of public keys. Call the <code>UpdateDevEndpoint</code> API operation with the public key content in the <code>deletePublicKeys</code> attribute, and the list of new keys in the <code>addPublicKeys</code> attribute.</p>
    /// </note>
    #[doc(hidden)]
    pub public_keys: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The name of the <code>SecurityConfiguration</code> structure to be used with this <code>DevEndpoint</code>.</p>
    #[doc(hidden)]
    pub security_configuration: std::option::Option<std::string::String>,
    /// <p>A map of arguments used to configure the <code>DevEndpoint</code>.</p>
    /// <p>Valid arguments are:</p>
    /// <ul>
    /// <li> <p> <code>"--enable-glue-datacatalog": ""</code> </p> </li>
    /// </ul>
    /// <p>You can specify a version of Python support for development endpoints by using the <code>Arguments</code> parameter in the <code>CreateDevEndpoint</code> or <code>UpdateDevEndpoint</code> APIs. If no arguments are provided, the version defaults to Python 2.</p>
    #[doc(hidden)]
    pub arguments:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl DevEndpoint {
    /// <p>The name of the <code>DevEndpoint</code>.</p>
    pub fn endpoint_name(&self) -> std::option::Option<&str> {
        self.endpoint_name.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the IAM role used in this <code>DevEndpoint</code>.</p>
    pub fn role_arn(&self) -> std::option::Option<&str> {
        self.role_arn.as_deref()
    }
    /// <p>A list of security group identifiers used in this <code>DevEndpoint</code>.</p>
    pub fn security_group_ids(&self) -> std::option::Option<&[std::string::String]> {
        self.security_group_ids.as_deref()
    }
    /// <p>The subnet ID for this <code>DevEndpoint</code>.</p>
    pub fn subnet_id(&self) -> std::option::Option<&str> {
        self.subnet_id.as_deref()
    }
    /// <p>The YARN endpoint address used by this <code>DevEndpoint</code>.</p>
    pub fn yarn_endpoint_address(&self) -> std::option::Option<&str> {
        self.yarn_endpoint_address.as_deref()
    }
    /// <p>A private IP address to access the <code>DevEndpoint</code> within a VPC if the <code>DevEndpoint</code> is created within one. The <code>PrivateAddress</code> field is present only when you create the <code>DevEndpoint</code> within your VPC.</p>
    pub fn private_address(&self) -> std::option::Option<&str> {
        self.private_address.as_deref()
    }
    /// <p>The Apache Zeppelin port for the remote Apache Spark interpreter.</p>
    pub fn zeppelin_remote_spark_interpreter_port(&self) -> i32 {
        self.zeppelin_remote_spark_interpreter_port
    }
    /// <p>The public IP address used by this <code>DevEndpoint</code>. The <code>PublicAddress</code> field is present only when you create a non-virtual private cloud (VPC) <code>DevEndpoint</code>.</p>
    pub fn public_address(&self) -> std::option::Option<&str> {
        self.public_address.as_deref()
    }
    /// <p>The current status of this <code>DevEndpoint</code>.</p>
    pub fn status(&self) -> std::option::Option<&str> {
        self.status.as_deref()
    }
    /// <p>The type of predefined worker that is allocated to the development endpoint. Accepts a value of Standard, G.1X, or G.2X.</p>
    /// <ul>
    /// <li> <p>For the <code>Standard</code> worker type, each worker provides 4 vCPU, 16 GB of memory and a 50GB disk, and 2 executors per worker.</p> </li>
    /// <li> <p>For the <code>G.1X</code> worker type, each worker maps to 1 DPU (4 vCPU, 16 GB of memory, 64 GB disk), and provides 1 executor per worker. We recommend this worker type for memory-intensive jobs.</p> </li>
    /// <li> <p>For the <code>G.2X</code> worker type, each worker maps to 2 DPU (8 vCPU, 32 GB of memory, 128 GB disk), and provides 1 executor per worker. We recommend this worker type for memory-intensive jobs.</p> </li>
    /// </ul>
    /// <p>Known issue: when a development endpoint is created with the <code>G.2X</code> <code>WorkerType</code> configuration, the Spark drivers for the development endpoint will run on 4 vCPU, 16 GB of memory, and a 64 GB disk. </p>
    pub fn worker_type(&self) -> std::option::Option<&crate::model::WorkerType> {
        self.worker_type.as_ref()
    }
    /// <p>Glue version determines the versions of Apache Spark and Python that Glue supports. The Python version indicates the version supported for running your ETL scripts on development endpoints. </p>
    /// <p>For more information about the available Glue versions and corresponding Spark and Python versions, see <a href="https://docs.aws.amazon.com/glue/latest/dg/add-job.html">Glue version</a> in the developer guide.</p>
    /// <p>Development endpoints that are created without specifying a Glue version default to Glue 0.9.</p>
    /// <p>You can specify a version of Python support for development endpoints by using the <code>Arguments</code> parameter in the <code>CreateDevEndpoint</code> or <code>UpdateDevEndpoint</code> APIs. If no arguments are provided, the version defaults to Python 2.</p>
    pub fn glue_version(&self) -> std::option::Option<&str> {
        self.glue_version.as_deref()
    }
    /// <p>The number of workers of a defined <code>workerType</code> that are allocated to the development endpoint.</p>
    /// <p>The maximum number of workers you can define are 299 for <code>G.1X</code>, and 149 for <code>G.2X</code>. </p>
    pub fn number_of_workers(&self) -> std::option::Option<i32> {
        self.number_of_workers
    }
    /// <p>The number of Glue Data Processing Units (DPUs) allocated to this <code>DevEndpoint</code>.</p>
    pub fn number_of_nodes(&self) -> i32 {
        self.number_of_nodes
    }
    /// <p>The Amazon Web Services Availability Zone where this <code>DevEndpoint</code> is located.</p>
    pub fn availability_zone(&self) -> std::option::Option<&str> {
        self.availability_zone.as_deref()
    }
    /// <p>The ID of the virtual private cloud (VPC) used by this <code>DevEndpoint</code>.</p>
    pub fn vpc_id(&self) -> std::option::Option<&str> {
        self.vpc_id.as_deref()
    }
    /// <p>The paths to one or more Python libraries in an Amazon S3 bucket that should be loaded in your <code>DevEndpoint</code>. Multiple values must be complete paths separated by a comma.</p> <note>
    /// <p>You can only use pure Python libraries with a <code>DevEndpoint</code>. Libraries that rely on C extensions, such as the <a href="http://pandas.pydata.org/">pandas</a> Python data analysis library, are not currently supported.</p>
    /// </note>
    pub fn extra_python_libs_s3_path(&self) -> std::option::Option<&str> {
        self.extra_python_libs_s3_path.as_deref()
    }
    /// <p>The path to one or more Java <code>.jar</code> files in an S3 bucket that should be loaded in your <code>DevEndpoint</code>.</p> <note>
    /// <p>You can only use pure Java/Scala libraries with a <code>DevEndpoint</code>.</p>
    /// </note>
    pub fn extra_jars_s3_path(&self) -> std::option::Option<&str> {
        self.extra_jars_s3_path.as_deref()
    }
    /// <p>The reason for a current failure in this <code>DevEndpoint</code>.</p>
    pub fn failure_reason(&self) -> std::option::Option<&str> {
        self.failure_reason.as_deref()
    }
    /// <p>The status of the last update.</p>
    pub fn last_update_status(&self) -> std::option::Option<&str> {
        self.last_update_status.as_deref()
    }
    /// <p>The point in time at which this DevEndpoint was created.</p>
    pub fn created_timestamp(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_timestamp.as_ref()
    }
    /// <p>The point in time at which this <code>DevEndpoint</code> was last modified.</p>
    pub fn last_modified_timestamp(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_modified_timestamp.as_ref()
    }
    /// <p>The public key to be used by this <code>DevEndpoint</code> for authentication. This attribute is provided for backward compatibility because the recommended attribute to use is public keys.</p>
    pub fn public_key(&self) -> std::option::Option<&str> {
        self.public_key.as_deref()
    }
    /// <p>A list of public keys to be used by the <code>DevEndpoints</code> for authentication. Using this attribute is preferred over a single public key because the public keys allow you to have a different private key per client.</p> <note>
    /// <p>If you previously created an endpoint with a public key, you must remove that key to be able to set a list of public keys. Call the <code>UpdateDevEndpoint</code> API operation with the public key content in the <code>deletePublicKeys</code> attribute, and the list of new keys in the <code>addPublicKeys</code> attribute.</p>
    /// </note>
    pub fn public_keys(&self) -> std::option::Option<&[std::string::String]> {
        self.public_keys.as_deref()
    }
    /// <p>The name of the <code>SecurityConfiguration</code> structure to be used with this <code>DevEndpoint</code>.</p>
    pub fn security_configuration(&self) -> std::option::Option<&str> {
        self.security_configuration.as_deref()
    }
    /// <p>A map of arguments used to configure the <code>DevEndpoint</code>.</p>
    /// <p>Valid arguments are:</p>
    /// <ul>
    /// <li> <p> <code>"--enable-glue-datacatalog": ""</code> </p> </li>
    /// </ul>
    /// <p>You can specify a version of Python support for development endpoints by using the <code>Arguments</code> parameter in the <code>CreateDevEndpoint</code> or <code>UpdateDevEndpoint</code> APIs. If no arguments are provided, the version defaults to Python 2.</p>
    pub fn arguments(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.arguments.as_ref()
    }
}
/// See [`DevEndpoint`](crate::model::DevEndpoint).
pub mod dev_endpoint {

    /// A builder for [`DevEndpoint`](crate::model::DevEndpoint).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) endpoint_name: std::option::Option<std::string::String>,
        pub(crate) role_arn: std::option::Option<std::string::String>,
        pub(crate) security_group_ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) subnet_id: std::option::Option<std::string::String>,
        pub(crate) yarn_endpoint_address: std::option::Option<std::string::String>,
        pub(crate) private_address: std::option::Option<std::string::String>,
        pub(crate) zeppelin_remote_spark_interpreter_port: std::option::Option<i32>,
        pub(crate) public_address: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<std::string::String>,
        pub(crate) worker_type: std::option::Option<crate::model::WorkerType>,
        pub(crate) glue_version: std::option::Option<std::string::String>,
        pub(crate) number_of_workers: std::option::Option<i32>,
        pub(crate) number_of_nodes: std::option::Option<i32>,
        pub(crate) availability_zone: std::option::Option<std::string::String>,
        pub(crate) vpc_id: std::option::Option<std::string::String>,
        pub(crate) extra_python_libs_s3_path: std::option::Option<std::string::String>,
        pub(crate) extra_jars_s3_path: std::option::Option<std::string::String>,
        pub(crate) failure_reason: std::option::Option<std::string::String>,
        pub(crate) last_update_status: std::option::Option<std::string::String>,
        pub(crate) created_timestamp: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_modified_timestamp: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) public_key: std::option::Option<std::string::String>,
        pub(crate) public_keys: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) security_configuration: std::option::Option<std::string::String>,
        pub(crate) arguments: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The name of the <code>DevEndpoint</code>.</p>
        pub fn endpoint_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.endpoint_name = Some(input.into());
            self
        }
        /// <p>The name of the <code>DevEndpoint</code>.</p>
        pub fn set_endpoint_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.endpoint_name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the IAM role used in this <code>DevEndpoint</code>.</p>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.role_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the IAM role used in this <code>DevEndpoint</code>.</p>
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.role_arn = input;
            self
        }
        /// Appends an item to `security_group_ids`.
        ///
        /// To override the contents of this collection use [`set_security_group_ids`](Self::set_security_group_ids).
        ///
        /// <p>A list of security group identifiers used in this <code>DevEndpoint</code>.</p>
        pub fn security_group_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.security_group_ids.unwrap_or_default();
            v.push(input.into());
            self.security_group_ids = Some(v);
            self
        }
        /// <p>A list of security group identifiers used in this <code>DevEndpoint</code>.</p>
        pub fn set_security_group_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.security_group_ids = input;
            self
        }
        /// <p>The subnet ID for this <code>DevEndpoint</code>.</p>
        pub fn subnet_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.subnet_id = Some(input.into());
            self
        }
        /// <p>The subnet ID for this <code>DevEndpoint</code>.</p>
        pub fn set_subnet_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.subnet_id = input;
            self
        }
        /// <p>The YARN endpoint address used by this <code>DevEndpoint</code>.</p>
        pub fn yarn_endpoint_address(mut self, input: impl Into<std::string::String>) -> Self {
            self.yarn_endpoint_address = Some(input.into());
            self
        }
        /// <p>The YARN endpoint address used by this <code>DevEndpoint</code>.</p>
        pub fn set_yarn_endpoint_address(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.yarn_endpoint_address = input;
            self
        }
        /// <p>A private IP address to access the <code>DevEndpoint</code> within a VPC if the <code>DevEndpoint</code> is created within one. The <code>PrivateAddress</code> field is present only when you create the <code>DevEndpoint</code> within your VPC.</p>
        pub fn private_address(mut self, input: impl Into<std::string::String>) -> Self {
            self.private_address = Some(input.into());
            self
        }
        /// <p>A private IP address to access the <code>DevEndpoint</code> within a VPC if the <code>DevEndpoint</code> is created within one. The <code>PrivateAddress</code> field is present only when you create the <code>DevEndpoint</code> within your VPC.</p>
        pub fn set_private_address(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.private_address = input;
            self
        }
        /// <p>The Apache Zeppelin port for the remote Apache Spark interpreter.</p>
        pub fn zeppelin_remote_spark_interpreter_port(mut self, input: i32) -> Self {
            self.zeppelin_remote_spark_interpreter_port = Some(input);
            self
        }
        /// <p>The Apache Zeppelin port for the remote Apache Spark interpreter.</p>
        pub fn set_zeppelin_remote_spark_interpreter_port(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.zeppelin_remote_spark_interpreter_port = input;
            self
        }
        /// <p>The public IP address used by this <code>DevEndpoint</code>. The <code>PublicAddress</code> field is present only when you create a non-virtual private cloud (VPC) <code>DevEndpoint</code>.</p>
        pub fn public_address(mut self, input: impl Into<std::string::String>) -> Self {
            self.public_address = Some(input.into());
            self
        }
        /// <p>The public IP address used by this <code>DevEndpoint</code>. The <code>PublicAddress</code> field is present only when you create a non-virtual private cloud (VPC) <code>DevEndpoint</code>.</p>
        pub fn set_public_address(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.public_address = input;
            self
        }
        /// <p>The current status of this <code>DevEndpoint</code>.</p>
        pub fn status(mut self, input: impl Into<std::string::String>) -> Self {
            self.status = Some(input.into());
            self
        }
        /// <p>The current status of this <code>DevEndpoint</code>.</p>
        pub fn set_status(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.status = input;
            self
        }
        /// <p>The type of predefined worker that is allocated to the development endpoint. Accepts a value of Standard, G.1X, or G.2X.</p>
        /// <ul>
        /// <li> <p>For the <code>Standard</code> worker type, each worker provides 4 vCPU, 16 GB of memory and a 50GB disk, and 2 executors per worker.</p> </li>
        /// <li> <p>For the <code>G.1X</code> worker type, each worker maps to 1 DPU (4 vCPU, 16 GB of memory, 64 GB disk), and provides 1 executor per worker. We recommend this worker type for memory-intensive jobs.</p> </li>
        /// <li> <p>For the <code>G.2X</code> worker type, each worker maps to 2 DPU (8 vCPU, 32 GB of memory, 128 GB disk), and provides 1 executor per worker. We recommend this worker type for memory-intensive jobs.</p> </li>
        /// </ul>
        /// <p>Known issue: when a development endpoint is created with the <code>G.2X</code> <code>WorkerType</code> configuration, the Spark drivers for the development endpoint will run on 4 vCPU, 16 GB of memory, and a 64 GB disk. </p>
        pub fn worker_type(mut self, input: crate::model::WorkerType) -> Self {
            self.worker_type = Some(input);
            self
        }
        /// <p>The type of predefined worker that is allocated to the development endpoint. Accepts a value of Standard, G.1X, or G.2X.</p>
        /// <ul>
        /// <li> <p>For the <code>Standard</code> worker type, each worker provides 4 vCPU, 16 GB of memory and a 50GB disk, and 2 executors per worker.</p> </li>
        /// <li> <p>For the <code>G.1X</code> worker type, each worker maps to 1 DPU (4 vCPU, 16 GB of memory, 64 GB disk), and provides 1 executor per worker. We recommend this worker type for memory-intensive jobs.</p> </li>
        /// <li> <p>For the <code>G.2X</code> worker type, each worker maps to 2 DPU (8 vCPU, 32 GB of memory, 128 GB disk), and provides 1 executor per worker. We recommend this worker type for memory-intensive jobs.</p> </li>
        /// </ul>
        /// <p>Known issue: when a development endpoint is created with the <code>G.2X</code> <code>WorkerType</code> configuration, the Spark drivers for the development endpoint will run on 4 vCPU, 16 GB of memory, and a 64 GB disk. </p>
        pub fn set_worker_type(
            mut self,
            input: std::option::Option<crate::model::WorkerType>,
        ) -> Self {
            self.worker_type = input;
            self
        }
        /// <p>Glue version determines the versions of Apache Spark and Python that Glue supports. The Python version indicates the version supported for running your ETL scripts on development endpoints. </p>
        /// <p>For more information about the available Glue versions and corresponding Spark and Python versions, see <a href="https://docs.aws.amazon.com/glue/latest/dg/add-job.html">Glue version</a> in the developer guide.</p>
        /// <p>Development endpoints that are created without specifying a Glue version default to Glue 0.9.</p>
        /// <p>You can specify a version of Python support for development endpoints by using the <code>Arguments</code> parameter in the <code>CreateDevEndpoint</code> or <code>UpdateDevEndpoint</code> APIs. If no arguments are provided, the version defaults to Python 2.</p>
        pub fn glue_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.glue_version = Some(input.into());
            self
        }
        /// <p>Glue version determines the versions of Apache Spark and Python that Glue supports. The Python version indicates the version supported for running your ETL scripts on development endpoints. </p>
        /// <p>For more information about the available Glue versions and corresponding Spark and Python versions, see <a href="https://docs.aws.amazon.com/glue/latest/dg/add-job.html">Glue version</a> in the developer guide.</p>
        /// <p>Development endpoints that are created without specifying a Glue version default to Glue 0.9.</p>
        /// <p>You can specify a version of Python support for development endpoints by using the <code>Arguments</code> parameter in the <code>CreateDevEndpoint</code> or <code>UpdateDevEndpoint</code> APIs. If no arguments are provided, the version defaults to Python 2.</p>
        pub fn set_glue_version(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.glue_version = input;
            self
        }
        /// <p>The number of workers of a defined <code>workerType</code> that are allocated to the development endpoint.</p>
        /// <p>The maximum number of workers you can define are 299 for <code>G.1X</code>, and 149 for <code>G.2X</code>. </p>
        pub fn number_of_workers(mut self, input: i32) -> Self {
            self.number_of_workers = Some(input);
            self
        }
        /// <p>The number of workers of a defined <code>workerType</code> that are allocated to the development endpoint.</p>
        /// <p>The maximum number of workers you can define are 299 for <code>G.1X</code>, and 149 for <code>G.2X</code>. </p>
        pub fn set_number_of_workers(mut self, input: std::option::Option<i32>) -> Self {
            self.number_of_workers = input;
            self
        }
        /// <p>The number of Glue Data Processing Units (DPUs) allocated to this <code>DevEndpoint</code>.</p>
        pub fn number_of_nodes(mut self, input: i32) -> Self {
            self.number_of_nodes = Some(input);
            self
        }
        /// <p>The number of Glue Data Processing Units (DPUs) allocated to this <code>DevEndpoint</code>.</p>
        pub fn set_number_of_nodes(mut self, input: std::option::Option<i32>) -> Self {
            self.number_of_nodes = input;
            self
        }
        /// <p>The Amazon Web Services Availability Zone where this <code>DevEndpoint</code> is located.</p>
        pub fn availability_zone(mut self, input: impl Into<std::string::String>) -> Self {
            self.availability_zone = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services Availability Zone where this <code>DevEndpoint</code> is located.</p>
        pub fn set_availability_zone(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.availability_zone = input;
            self
        }
        /// <p>The ID of the virtual private cloud (VPC) used by this <code>DevEndpoint</code>.</p>
        pub fn vpc_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.vpc_id = Some(input.into());
            self
        }
        /// <p>The ID of the virtual private cloud (VPC) used by this <code>DevEndpoint</code>.</p>
        pub fn set_vpc_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.vpc_id = input;
            self
        }
        /// <p>The paths to one or more Python libraries in an Amazon S3 bucket that should be loaded in your <code>DevEndpoint</code>. Multiple values must be complete paths separated by a comma.</p> <note>
        /// <p>You can only use pure Python libraries with a <code>DevEndpoint</code>. Libraries that rely on C extensions, such as the <a href="http://pandas.pydata.org/">pandas</a> Python data analysis library, are not currently supported.</p>
        /// </note>
        pub fn extra_python_libs_s3_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.extra_python_libs_s3_path = Some(input.into());
            self
        }
        /// <p>The paths to one or more Python libraries in an Amazon S3 bucket that should be loaded in your <code>DevEndpoint</code>. Multiple values must be complete paths separated by a comma.</p> <note>
        /// <p>You can only use pure Python libraries with a <code>DevEndpoint</code>. Libraries that rely on C extensions, such as the <a href="http://pandas.pydata.org/">pandas</a> Python data analysis library, are not currently supported.</p>
        /// </note>
        pub fn set_extra_python_libs_s3_path(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.extra_python_libs_s3_path = input;
            self
        }
        /// <p>The path to one or more Java <code>.jar</code> files in an S3 bucket that should be loaded in your <code>DevEndpoint</code>.</p> <note>
        /// <p>You can only use pure Java/Scala libraries with a <code>DevEndpoint</code>.</p>
        /// </note>
        pub fn extra_jars_s3_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.extra_jars_s3_path = Some(input.into());
            self
        }
        /// <p>The path to one or more Java <code>.jar</code> files in an S3 bucket that should be loaded in your <code>DevEndpoint</code>.</p> <note>
        /// <p>You can only use pure Java/Scala libraries with a <code>DevEndpoint</code>.</p>
        /// </note>
        pub fn set_extra_jars_s3_path(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.extra_jars_s3_path = input;
            self
        }
        /// <p>The reason for a current failure in this <code>DevEndpoint</code>.</p>
        pub fn failure_reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.failure_reason = Some(input.into());
            self
        }
        /// <p>The reason for a current failure in this <code>DevEndpoint</code>.</p>
        pub fn set_failure_reason(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.failure_reason = input;
            self
        }
        /// <p>The status of the last update.</p>
        pub fn last_update_status(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_update_status = Some(input.into());
            self
        }
        /// <p>The status of the last update.</p>
        pub fn set_last_update_status(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.last_update_status = input;
            self
        }
        /// <p>The point in time at which this DevEndpoint was created.</p>
        pub fn created_timestamp(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_timestamp = Some(input);
            self
        }
        /// <p>The point in time at which this DevEndpoint was created.</p>
        pub fn set_created_timestamp(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_timestamp = input;
            self
        }
        /// <p>The point in time at which this <code>DevEndpoint</code> was last modified.</p>
        pub fn last_modified_timestamp(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_modified_timestamp = Some(input);
            self
        }
        /// <p>The point in time at which this <code>DevEndpoint</code> was last modified.</p>
        pub fn set_last_modified_timestamp(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_modified_timestamp = input;
            self
        }
        /// <p>The public key to be used by this <code>DevEndpoint</code> for authentication. This attribute is provided for backward compatibility because the recommended attribute to use is public keys.</p>
        pub fn public_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.public_key = Some(input.into());
            self
        }
        /// <p>The public key to be used by this <code>DevEndpoint</code> for authentication. This attribute is provided for backward compatibility because the recommended attribute to use is public keys.</p>
        pub fn set_public_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.public_key = input;
            self
        }
        /// Appends an item to `public_keys`.
        ///
        /// To override the contents of this collection use [`set_public_keys`](Self::set_public_keys).
        ///
        /// <p>A list of public keys to be used by the <code>DevEndpoints</code> for authentication. Using this attribute is preferred over a single public key because the public keys allow you to have a different private key per client.</p> <note>
        /// <p>If you previously created an endpoint with a public key, you must remove that key to be able to set a list of public keys. Call the <code>UpdateDevEndpoint</code> API operation with the public key content in the <code>deletePublicKeys</code> attribute, and the list of new keys in the <code>addPublicKeys</code> attribute.</p>
        /// </note>
        pub fn public_keys(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.public_keys.unwrap_or_default();
            v.push(input.into());
            self.public_keys = Some(v);
            self
        }
        /// <p>A list of public keys to be used by the <code>DevEndpoints</code> for authentication. Using this attribute is preferred over a single public key because the public keys allow you to have a different private key per client.</p> <note>
        /// <p>If you previously created an endpoint with a public key, you must remove that key to be able to set a list of public keys. Call the <code>UpdateDevEndpoint</code> API operation with the public key content in the <code>deletePublicKeys</code> attribute, and the list of new keys in the <code>addPublicKeys</code> attribute.</p>
        /// </note>
        pub fn set_public_keys(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.public_keys = input;
            self
        }
        /// <p>The name of the <code>SecurityConfiguration</code> structure to be used with this <code>DevEndpoint</code>.</p>
        pub fn security_configuration(mut self, input: impl Into<std::string::String>) -> Self {
            self.security_configuration = Some(input.into());
            self
        }
        /// <p>The name of the <code>SecurityConfiguration</code> structure to be used with this <code>DevEndpoint</code>.</p>
        pub fn set_security_configuration(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.security_configuration = input;
            self
        }
        /// Adds a key-value pair to `arguments`.
        ///
        /// To override the contents of this collection use [`set_arguments`](Self::set_arguments).
        ///
        /// <p>A map of arguments used to configure the <code>DevEndpoint</code>.</p>
        /// <p>Valid arguments are:</p>
        /// <ul>
        /// <li> <p> <code>"--enable-glue-datacatalog": ""</code> </p> </li>
        /// </ul>
        /// <p>You can specify a version of Python support for development endpoints by using the <code>Arguments</code> parameter in the <code>CreateDevEndpoint</code> or <code>UpdateDevEndpoint</code> APIs. If no arguments are provided, the version defaults to Python 2.</p>
        pub fn arguments(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.arguments.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.arguments = Some(hash_map);
            self
        }
        /// <p>A map of arguments used to configure the <code>DevEndpoint</code>.</p>
        /// <p>Valid arguments are:</p>
        /// <ul>
        /// <li> <p> <code>"--enable-glue-datacatalog": ""</code> </p> </li>
        /// </ul>
        /// <p>You can specify a version of Python support for development endpoints by using the <code>Arguments</code> parameter in the <code>CreateDevEndpoint</code> or <code>UpdateDevEndpoint</code> APIs. If no arguments are provided, the version defaults to Python 2.</p>
        pub fn set_arguments(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.arguments = input;
            self
        }
        /// Consumes the builder and constructs a [`DevEndpoint`](crate::model::DevEndpoint).
        pub fn build(self) -> crate::model::DevEndpoint {
            crate::model::DevEndpoint {
                endpoint_name: self.endpoint_name,
                role_arn: self.role_arn,
                security_group_ids: self.security_group_ids,
                subnet_id: self.subnet_id,
                yarn_endpoint_address: self.yarn_endpoint_address,
                private_address: self.private_address,
                zeppelin_remote_spark_interpreter_port: self
                    .zeppelin_remote_spark_interpreter_port
                    .unwrap_or_default(),
                public_address: self.public_address,
                status: self.status,
                worker_type: self.worker_type,
                glue_version: self.glue_version,
                number_of_workers: self.number_of_workers,
                number_of_nodes: self.number_of_nodes.unwrap_or_default(),
                availability_zone: self.availability_zone,
                vpc_id: self.vpc_id,
                extra_python_libs_s3_path: self.extra_python_libs_s3_path,
                extra_jars_s3_path: self.extra_jars_s3_path,
                failure_reason: self.failure_reason,
                last_update_status: self.last_update_status,
                created_timestamp: self.created_timestamp,
                last_modified_timestamp: self.last_modified_timestamp,
                public_key: self.public_key,
                public_keys: self.public_keys,
                security_configuration: self.security_configuration,
                arguments: self.arguments,
            }
        }
    }
}
impl DevEndpoint {
    /// Creates a new builder-style object to manufacture [`DevEndpoint`](crate::model::DevEndpoint).
    pub fn builder() -> crate::model::dev_endpoint::Builder {
        crate::model::dev_endpoint::Builder::default()
    }
}

/// <p>Describes the result of the evaluation of a data quality rule.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DataQualityRuleResult {
    /// <p>The name of the data quality rule.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>A description of the data quality rule.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>An evaluation message.</p>
    #[doc(hidden)]
    pub evaluation_message: std::option::Option<std::string::String>,
    /// <p>A pass or fail status for the rule.</p>
    #[doc(hidden)]
    pub result: std::option::Option<crate::model::DataQualityRuleResultStatus>,
}
impl DataQualityRuleResult {
    /// <p>The name of the data quality rule.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>A description of the data quality rule.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>An evaluation message.</p>
    pub fn evaluation_message(&self) -> std::option::Option<&str> {
        self.evaluation_message.as_deref()
    }
    /// <p>A pass or fail status for the rule.</p>
    pub fn result(&self) -> std::option::Option<&crate::model::DataQualityRuleResultStatus> {
        self.result.as_ref()
    }
}
/// See [`DataQualityRuleResult`](crate::model::DataQualityRuleResult).
pub mod data_quality_rule_result {

    /// A builder for [`DataQualityRuleResult`](crate::model::DataQualityRuleResult).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) evaluation_message: std::option::Option<std::string::String>,
        pub(crate) result: std::option::Option<crate::model::DataQualityRuleResultStatus>,
    }
    impl Builder {
        /// <p>The name of the data quality rule.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the data quality rule.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>A description of the data quality rule.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A description of the data quality rule.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>An evaluation message.</p>
        pub fn evaluation_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.evaluation_message = Some(input.into());
            self
        }
        /// <p>An evaluation message.</p>
        pub fn set_evaluation_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.evaluation_message = input;
            self
        }
        /// <p>A pass or fail status for the rule.</p>
        pub fn result(mut self, input: crate::model::DataQualityRuleResultStatus) -> Self {
            self.result = Some(input);
            self
        }
        /// <p>A pass or fail status for the rule.</p>
        pub fn set_result(
            mut self,
            input: std::option::Option<crate::model::DataQualityRuleResultStatus>,
        ) -> Self {
            self.result = input;
            self
        }
        /// Consumes the builder and constructs a [`DataQualityRuleResult`](crate::model::DataQualityRuleResult).
        pub fn build(self) -> crate::model::DataQualityRuleResult {
            crate::model::DataQualityRuleResult {
                name: self.name,
                description: self.description,
                evaluation_message: self.evaluation_message,
                result: self.result,
            }
        }
    }
}
impl DataQualityRuleResult {
    /// Creates a new builder-style object to manufacture [`DataQualityRuleResult`](crate::model::DataQualityRuleResult).
    pub fn builder() -> crate::model::data_quality_rule_result::Builder {
        crate::model::data_quality_rule_result::Builder::default()
    }
}

/// When writing a match expression against `DataQualityRuleResultStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let dataqualityruleresultstatus = unimplemented!();
/// match dataqualityruleresultstatus {
///     DataQualityRuleResultStatus::Error => { /* ... */ },
///     DataQualityRuleResultStatus::Fail => { /* ... */ },
///     DataQualityRuleResultStatus::Pass => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `dataqualityruleresultstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `DataQualityRuleResultStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `DataQualityRuleResultStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `DataQualityRuleResultStatus::NewFeature` is defined.
/// Specifically, when `dataqualityruleresultstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `DataQualityRuleResultStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DataQualityRuleResultStatus {
    #[allow(missing_docs)] // documentation missing in model
    Error,
    #[allow(missing_docs)] // documentation missing in model
    Fail,
    #[allow(missing_docs)] // documentation missing in model
    Pass,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for DataQualityRuleResultStatus {
    fn from(s: &str) -> Self {
        match s {
            "ERROR" => DataQualityRuleResultStatus::Error,
            "FAIL" => DataQualityRuleResultStatus::Fail,
            "PASS" => DataQualityRuleResultStatus::Pass,
            other => DataQualityRuleResultStatus::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for DataQualityRuleResultStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DataQualityRuleResultStatus::from(s))
    }
}
impl DataQualityRuleResultStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            DataQualityRuleResultStatus::Error => "ERROR",
            DataQualityRuleResultStatus::Fail => "FAIL",
            DataQualityRuleResultStatus::Pass => "PASS",
            DataQualityRuleResultStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ERROR", "FAIL", "PASS"]
    }
}
impl AsRef<str> for DataQualityRuleResultStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Represents a directional edge in a directed acyclic graph (DAG).</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CodeGenEdge {
    /// <p>The ID of the node at which the edge starts.</p>
    #[doc(hidden)]
    pub source: std::option::Option<std::string::String>,
    /// <p>The ID of the node at which the edge ends.</p>
    #[doc(hidden)]
    pub target: std::option::Option<std::string::String>,
    /// <p>The target of the edge.</p>
    #[doc(hidden)]
    pub target_parameter: std::option::Option<std::string::String>,
}
impl CodeGenEdge {
    /// <p>The ID of the node at which the edge starts.</p>
    pub fn source(&self) -> std::option::Option<&str> {
        self.source.as_deref()
    }
    /// <p>The ID of the node at which the edge ends.</p>
    pub fn target(&self) -> std::option::Option<&str> {
        self.target.as_deref()
    }
    /// <p>The target of the edge.</p>
    pub fn target_parameter(&self) -> std::option::Option<&str> {
        self.target_parameter.as_deref()
    }
}
/// See [`CodeGenEdge`](crate::model::CodeGenEdge).
pub mod code_gen_edge {

    /// A builder for [`CodeGenEdge`](crate::model::CodeGenEdge).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) source: std::option::Option<std::string::String>,
        pub(crate) target: std::option::Option<std::string::String>,
        pub(crate) target_parameter: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the node at which the edge starts.</p>
        pub fn source(mut self, input: impl Into<std::string::String>) -> Self {
            self.source = Some(input.into());
            self
        }
        /// <p>The ID of the node at which the edge starts.</p>
        pub fn set_source(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.source = input;
            self
        }
        /// <p>The ID of the node at which the edge ends.</p>
        pub fn target(mut self, input: impl Into<std::string::String>) -> Self {
            self.target = Some(input.into());
            self
        }
        /// <p>The ID of the node at which the edge ends.</p>
        pub fn set_target(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.target = input;
            self
        }
        /// <p>The target of the edge.</p>
        pub fn target_parameter(mut self, input: impl Into<std::string::String>) -> Self {
            self.target_parameter = Some(input.into());
            self
        }
        /// <p>The target of the edge.</p>
        pub fn set_target_parameter(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.target_parameter = input;
            self
        }
        /// Consumes the builder and constructs a [`CodeGenEdge`](crate::model::CodeGenEdge).
        pub fn build(self) -> crate::model::CodeGenEdge {
            crate::model::CodeGenEdge {
                source: self.source,
                target: self.target,
                target_parameter: self.target_parameter,
            }
        }
    }
}
impl CodeGenEdge {
    /// Creates a new builder-style object to manufacture [`CodeGenEdge`](crate::model::CodeGenEdge).
    pub fn builder() -> crate::model::code_gen_edge::Builder {
        crate::model::code_gen_edge::Builder::default()
    }
}

/// <p>Represents a node in a directed acyclic graph (DAG)</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CodeGenNode {
    /// <p>A node identifier that is unique within the node's graph.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The type of node that this is.</p>
    #[doc(hidden)]
    pub node_type: std::option::Option<std::string::String>,
    /// <p>Properties of the node, in the form of name-value pairs.</p>
    #[doc(hidden)]
    pub args: std::option::Option<std::vec::Vec<crate::model::CodeGenNodeArg>>,
    /// <p>The line number of the node.</p>
    #[doc(hidden)]
    pub line_number: i32,
}
impl CodeGenNode {
    /// <p>A node identifier that is unique within the node's graph.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The type of node that this is.</p>
    pub fn node_type(&self) -> std::option::Option<&str> {
        self.node_type.as_deref()
    }
    /// <p>Properties of the node, in the form of name-value pairs.</p>
    pub fn args(&self) -> std::option::Option<&[crate::model::CodeGenNodeArg]> {
        self.args.as_deref()
    }
    /// <p>The line number of the node.</p>
    pub fn line_number(&self) -> i32 {
        self.line_number
    }
}
/// See [`CodeGenNode`](crate::model::CodeGenNode).
pub mod code_gen_node {

    /// A builder for [`CodeGenNode`](crate::model::CodeGenNode).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) node_type: std::option::Option<std::string::String>,
        pub(crate) args: std::option::Option<std::vec::Vec<crate::model::CodeGenNodeArg>>,
        pub(crate) line_number: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>A node identifier that is unique within the node's graph.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>A node identifier that is unique within the node's graph.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The type of node that this is.</p>
        pub fn node_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.node_type = Some(input.into());
            self
        }
        /// <p>The type of node that this is.</p>
        pub fn set_node_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.node_type = input;
            self
        }
        /// Appends an item to `args`.
        ///
        /// To override the contents of this collection use [`set_args`](Self::set_args).
        ///
        /// <p>Properties of the node, in the form of name-value pairs.</p>
        pub fn args(mut self, input: crate::model::CodeGenNodeArg) -> Self {
            let mut v = self.args.unwrap_or_default();
            v.push(input);
            self.args = Some(v);
            self
        }
        /// <p>Properties of the node, in the form of name-value pairs.</p>
        pub fn set_args(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::CodeGenNodeArg>>,
        ) -> Self {
            self.args = input;
            self
        }
        /// <p>The line number of the node.</p>
        pub fn line_number(mut self, input: i32) -> Self {
            self.line_number = Some(input);
            self
        }
        /// <p>The line number of the node.</p>
        pub fn set_line_number(mut self, input: std::option::Option<i32>) -> Self {
            self.line_number = input;
            self
        }
        /// Consumes the builder and constructs a [`CodeGenNode`](crate::model::CodeGenNode).
        pub fn build(self) -> crate::model::CodeGenNode {
            crate::model::CodeGenNode {
                id: self.id,
                node_type: self.node_type,
                args: self.args,
                line_number: self.line_number.unwrap_or_default(),
            }
        }
    }
}
impl CodeGenNode {
    /// Creates a new builder-style object to manufacture [`CodeGenNode`](crate::model::CodeGenNode).
    pub fn builder() -> crate::model::code_gen_node::Builder {
        crate::model::code_gen_node::Builder::default()
    }
}

/// <p>The <code>Database</code> object represents a logical grouping of tables that might reside in a Hive metastore or an RDBMS.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Database {
    /// <p>The name of the database. For Hive compatibility, this is folded to lowercase when it is stored.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>A description of the database.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The location of the database (for example, an HDFS path).</p>
    #[doc(hidden)]
    pub location_uri: std::option::Option<std::string::String>,
    /// <p>These key-value pairs define parameters and properties of the database.</p>
    #[doc(hidden)]
    pub parameters:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The time at which the metadata database was created in the catalog.</p>
    #[doc(hidden)]
    pub create_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Creates a set of default permissions on the table for principals. </p>
    #[doc(hidden)]
    pub create_table_default_permissions:
        std::option::Option<std::vec::Vec<crate::model::PrincipalPermissions>>,
    /// <p>A <code>DatabaseIdentifier</code> structure that describes a target database for resource linking.</p>
    #[doc(hidden)]
    pub target_database: std::option::Option<crate::model::DatabaseIdentifier>,
    /// <p>The ID of the Data Catalog in which the database resides.</p>
    #[doc(hidden)]
    pub catalog_id: std::option::Option<std::string::String>,
}
impl Database {
    /// <p>The name of the database. For Hive compatibility, this is folded to lowercase when it is stored.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>A description of the database.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The location of the database (for example, an HDFS path).</p>
    pub fn location_uri(&self) -> std::option::Option<&str> {
        self.location_uri.as_deref()
    }
    /// <p>These key-value pairs define parameters and properties of the database.</p>
    pub fn parameters(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.parameters.as_ref()
    }
    /// <p>The time at which the metadata database was created in the catalog.</p>
    pub fn create_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.create_time.as_ref()
    }
    /// <p>Creates a set of default permissions on the table for principals. </p>
    pub fn create_table_default_permissions(
        &self,
    ) -> std::option::Option<&[crate::model::PrincipalPermissions]> {
        self.create_table_default_permissions.as_deref()
    }
    /// <p>A <code>DatabaseIdentifier</code> structure that describes a target database for resource linking.</p>
    pub fn target_database(&self) -> std::option::Option<&crate::model::DatabaseIdentifier> {
        self.target_database.as_ref()
    }
    /// <p>The ID of the Data Catalog in which the database resides.</p>
    pub fn catalog_id(&self) -> std::option::Option<&str> {
        self.catalog_id.as_deref()
    }
}
/// See [`Database`](crate::model::Database).
pub mod database {

    /// A builder for [`Database`](crate::model::Database).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) location_uri: std::option::Option<std::string::String>,
        pub(crate) parameters: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) create_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) create_table_default_permissions:
            std::option::Option<std::vec::Vec<crate::model::PrincipalPermissions>>,
        pub(crate) target_database: std::option::Option<crate::model::DatabaseIdentifier>,
        pub(crate) catalog_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the database. For Hive compatibility, this is folded to lowercase when it is stored.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the database. For Hive compatibility, this is folded to lowercase when it is stored.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>A description of the database.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A description of the database.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The location of the database (for example, an HDFS path).</p>
        pub fn location_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.location_uri = Some(input.into());
            self
        }
        /// <p>The location of the database (for example, an HDFS path).</p>
        pub fn set_location_uri(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.location_uri = input;
            self
        }
        /// Adds a key-value pair to `parameters`.
        ///
        /// To override the contents of this collection use [`set_parameters`](Self::set_parameters).
        ///
        /// <p>These key-value pairs define parameters and properties of the database.</p>
        pub fn parameters(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.parameters.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.parameters = Some(hash_map);
            self
        }
        /// <p>These key-value pairs define parameters and properties of the database.</p>
        pub fn set_parameters(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.parameters = input;
            self
        }
        /// <p>The time at which the metadata database was created in the catalog.</p>
        pub fn create_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.create_time = Some(input);
            self
        }
        /// <p>The time at which the metadata database was created in the catalog.</p>
        pub fn set_create_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.create_time = input;
            self
        }
        /// Appends an item to `create_table_default_permissions`.
        ///
        /// To override the contents of this collection use [`set_create_table_default_permissions`](Self::set_create_table_default_permissions).
        ///
        /// <p>Creates a set of default permissions on the table for principals. </p>
        pub fn create_table_default_permissions(
            mut self,
            input: crate::model::PrincipalPermissions,
        ) -> Self {
            let mut v = self.create_table_default_permissions.unwrap_or_default();
            v.push(input);
            self.create_table_default_permissions = Some(v);
            self
        }
        /// <p>Creates a set of default permissions on the table for principals. </p>
        pub fn set_create_table_default_permissions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::PrincipalPermissions>>,
        ) -> Self {
            self.create_table_default_permissions = input;
            self
        }
        /// <p>A <code>DatabaseIdentifier</code> structure that describes a target database for resource linking.</p>
        pub fn target_database(mut self, input: crate::model::DatabaseIdentifier) -> Self {
            self.target_database = Some(input);
            self
        }
        /// <p>A <code>DatabaseIdentifier</code> structure that describes a target database for resource linking.</p>
        pub fn set_target_database(
            mut self,
            input: std::option::Option<crate::model::DatabaseIdentifier>,
        ) -> Self {
            self.target_database = input;
            self
        }
        /// <p>The ID of the Data Catalog in which the database resides.</p>
        pub fn catalog_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.catalog_id = Some(input.into());
            self
        }
        /// <p>The ID of the Data Catalog in which the database resides.</p>
        pub fn set_catalog_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.catalog_id = input;
            self
        }
        /// Consumes the builder and constructs a [`Database`](crate::model::Database).
        pub fn build(self) -> crate::model::Database {
            crate::model::Database {
                name: self.name,
                description: self.description,
                location_uri: self.location_uri,
                parameters: self.parameters,
                create_time: self.create_time,
                create_table_default_permissions: self.create_table_default_permissions,
                target_database: self.target_database,
                catalog_id: self.catalog_id,
            }
        }
    }
}
impl Database {
    /// Creates a new builder-style object to manufacture [`Database`](crate::model::Database).
    pub fn builder() -> crate::model::database::Builder {
        crate::model::database::Builder::default()
    }
}

/// <p>Specifies a crawler program that examines a data source and uses classifiers to try to determine its schema. If successful, the crawler records metadata concerning the data source in the Glue Data Catalog.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Crawler {
    /// <p>The name of the crawler.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of an IAM role that's used to access customer resources, such as Amazon Simple Storage Service (Amazon S3) data.</p>
    #[doc(hidden)]
    pub role: std::option::Option<std::string::String>,
    /// <p>A collection of targets to crawl.</p>
    #[doc(hidden)]
    pub targets: std::option::Option<crate::model::CrawlerTargets>,
    /// <p>The name of the database in which the crawler's output is stored.</p>
    #[doc(hidden)]
    pub database_name: std::option::Option<std::string::String>,
    /// <p>A description of the crawler.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>A list of UTF-8 strings that specify the custom classifiers that are associated with the crawler.</p>
    #[doc(hidden)]
    pub classifiers: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A policy that specifies whether to crawl the entire dataset again, or to crawl only folders that were added since the last crawler run.</p>
    #[doc(hidden)]
    pub recrawl_policy: std::option::Option<crate::model::RecrawlPolicy>,
    /// <p>The policy that specifies update and delete behaviors for the crawler.</p>
    #[doc(hidden)]
    pub schema_change_policy: std::option::Option<crate::model::SchemaChangePolicy>,
    /// <p>A configuration that specifies whether data lineage is enabled for the crawler.</p>
    #[doc(hidden)]
    pub lineage_configuration: std::option::Option<crate::model::LineageConfiguration>,
    /// <p>Indicates whether the crawler is running, or whether a run is pending.</p>
    #[doc(hidden)]
    pub state: std::option::Option<crate::model::CrawlerState>,
    /// <p>The prefix added to the names of tables that are created.</p>
    #[doc(hidden)]
    pub table_prefix: std::option::Option<std::string::String>,
    /// <p>For scheduled crawlers, the schedule when the crawler runs.</p>
    #[doc(hidden)]
    pub schedule: std::option::Option<crate::model::Schedule>,
    /// <p>If the crawler is running, contains the total time elapsed since the last crawl began.</p>
    #[doc(hidden)]
    pub crawl_elapsed_time: i64,
    /// <p>The time that the crawler was created.</p>
    #[doc(hidden)]
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The time that the crawler was last updated.</p>
    #[doc(hidden)]
    pub last_updated: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The status of the last crawl, and potentially error information if an error occurred.</p>
    #[doc(hidden)]
    pub last_crawl: std::option::Option<crate::model::LastCrawlInfo>,
    /// <p>The version of the crawler.</p>
    #[doc(hidden)]
    pub version: i64,
    /// <p>Crawler configuration information. This versioned JSON string allows users to specify aspects of a crawler's behavior. For more information, see <a href="https://docs.aws.amazon.com/glue/latest/dg/crawler-configuration.html">Setting crawler configuration options</a>.</p>
    #[doc(hidden)]
    pub configuration: std::option::Option<std::string::String>,
    /// <p>The name of the <code>SecurityConfiguration</code> structure to be used by this crawler.</p>
    #[doc(hidden)]
    pub crawler_security_configuration: std::option::Option<std::string::String>,
    /// <p>Specifies whether the crawler should use Lake Formation credentials for the crawler instead of the IAM role credentials.</p>
    #[doc(hidden)]
    pub lake_formation_configuration: std::option::Option<crate::model::LakeFormationConfiguration>,
}
impl Crawler {
    /// <p>The name of the crawler.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of an IAM role that's used to access customer resources, such as Amazon Simple Storage Service (Amazon S3) data.</p>
    pub fn role(&self) -> std::option::Option<&str> {
        self.role.as_deref()
    }
    /// <p>A collection of targets to crawl.</p>
    pub fn targets(&self) -> std::option::Option<&crate::model::CrawlerTargets> {
        self.targets.as_ref()
    }
    /// <p>The name of the database in which the crawler's output is stored.</p>
    pub fn database_name(&self) -> std::option::Option<&str> {
        self.database_name.as_deref()
    }
    /// <p>A description of the crawler.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>A list of UTF-8 strings that specify the custom classifiers that are associated with the crawler.</p>
    pub fn classifiers(&self) -> std::option::Option<&[std::string::String]> {
        self.classifiers.as_deref()
    }
    /// <p>A policy that specifies whether to crawl the entire dataset again, or to crawl only folders that were added since the last crawler run.</p>
    pub fn recrawl_policy(&self) -> std::option::Option<&crate::model::RecrawlPolicy> {
        self.recrawl_policy.as_ref()
    }
    /// <p>The policy that specifies update and delete behaviors for the crawler.</p>
    pub fn schema_change_policy(&self) -> std::option::Option<&crate::model::SchemaChangePolicy> {
        self.schema_change_policy.as_ref()
    }
    /// <p>A configuration that specifies whether data lineage is enabled for the crawler.</p>
    pub fn lineage_configuration(
        &self,
    ) -> std::option::Option<&crate::model::LineageConfiguration> {
        self.lineage_configuration.as_ref()
    }
    /// <p>Indicates whether the crawler is running, or whether a run is pending.</p>
    pub fn state(&self) -> std::option::Option<&crate::model::CrawlerState> {
        self.state.as_ref()
    }
    /// <p>The prefix added to the names of tables that are created.</p>
    pub fn table_prefix(&self) -> std::option::Option<&str> {
        self.table_prefix.as_deref()
    }
    /// <p>For scheduled crawlers, the schedule when the crawler runs.</p>
    pub fn schedule(&self) -> std::option::Option<&crate::model::Schedule> {
        self.schedule.as_ref()
    }
    /// <p>If the crawler is running, contains the total time elapsed since the last crawl began.</p>
    pub fn crawl_elapsed_time(&self) -> i64 {
        self.crawl_elapsed_time
    }
    /// <p>The time that the crawler was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>The time that the crawler was last updated.</p>
    pub fn last_updated(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_updated.as_ref()
    }
    /// <p>The status of the last crawl, and potentially error information if an error occurred.</p>
    pub fn last_crawl(&self) -> std::option::Option<&crate::model::LastCrawlInfo> {
        self.last_crawl.as_ref()
    }
    /// <p>The version of the crawler.</p>
    pub fn version(&self) -> i64 {
        self.version
    }
    /// <p>Crawler configuration information. This versioned JSON string allows users to specify aspects of a crawler's behavior. For more information, see <a href="https://docs.aws.amazon.com/glue/latest/dg/crawler-configuration.html">Setting crawler configuration options</a>.</p>
    pub fn configuration(&self) -> std::option::Option<&str> {
        self.configuration.as_deref()
    }
    /// <p>The name of the <code>SecurityConfiguration</code> structure to be used by this crawler.</p>
    pub fn crawler_security_configuration(&self) -> std::option::Option<&str> {
        self.crawler_security_configuration.as_deref()
    }
    /// <p>Specifies whether the crawler should use Lake Formation credentials for the crawler instead of the IAM role credentials.</p>
    pub fn lake_formation_configuration(
        &self,
    ) -> std::option::Option<&crate::model::LakeFormationConfiguration> {
        self.lake_formation_configuration.as_ref()
    }
}
/// See [`Crawler`](crate::model::Crawler).
pub mod crawler {

    /// A builder for [`Crawler`](crate::model::Crawler).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) role: std::option::Option<std::string::String>,
        pub(crate) targets: std::option::Option<crate::model::CrawlerTargets>,
        pub(crate) database_name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) classifiers: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) recrawl_policy: std::option::Option<crate::model::RecrawlPolicy>,
        pub(crate) schema_change_policy: std::option::Option<crate::model::SchemaChangePolicy>,
        pub(crate) lineage_configuration: std::option::Option<crate::model::LineageConfiguration>,
        pub(crate) state: std::option::Option<crate::model::CrawlerState>,
        pub(crate) table_prefix: std::option::Option<std::string::String>,
        pub(crate) schedule: std::option::Option<crate::model::Schedule>,
        pub(crate) crawl_elapsed_time: std::option::Option<i64>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_updated: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_crawl: std::option::Option<crate::model::LastCrawlInfo>,
        pub(crate) version: std::option::Option<i64>,
        pub(crate) configuration: std::option::Option<std::string::String>,
        pub(crate) crawler_security_configuration: std::option::Option<std::string::String>,
        pub(crate) lake_formation_configuration:
            std::option::Option<crate::model::LakeFormationConfiguration>,
    }
    impl Builder {
        /// <p>The name of the crawler.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the crawler.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of an IAM role that's used to access customer resources, such as Amazon Simple Storage Service (Amazon S3) data.</p>
        pub fn role(mut self, input: impl Into<std::string::String>) -> Self {
            self.role = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of an IAM role that's used to access customer resources, such as Amazon Simple Storage Service (Amazon S3) data.</p>
        pub fn set_role(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.role = input;
            self
        }
        /// <p>A collection of targets to crawl.</p>
        pub fn targets(mut self, input: crate::model::CrawlerTargets) -> Self {
            self.targets = Some(input);
            self
        }
        /// <p>A collection of targets to crawl.</p>
        pub fn set_targets(
            mut self,
            input: std::option::Option<crate::model::CrawlerTargets>,
        ) -> Self {
            self.targets = input;
            self
        }
        /// <p>The name of the database in which the crawler's output is stored.</p>
        pub fn database_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.database_name = Some(input.into());
            self
        }
        /// <p>The name of the database in which the crawler's output is stored.</p>
        pub fn set_database_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.database_name = input;
            self
        }
        /// <p>A description of the crawler.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A description of the crawler.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// Appends an item to `classifiers`.
        ///
        /// To override the contents of this collection use [`set_classifiers`](Self::set_classifiers).
        ///
        /// <p>A list of UTF-8 strings that specify the custom classifiers that are associated with the crawler.</p>
        pub fn classifiers(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.classifiers.unwrap_or_default();
            v.push(input.into());
            self.classifiers = Some(v);
            self
        }
        /// <p>A list of UTF-8 strings that specify the custom classifiers that are associated with the crawler.</p>
        pub fn set_classifiers(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.classifiers = input;
            self
        }
        /// <p>A policy that specifies whether to crawl the entire dataset again, or to crawl only folders that were added since the last crawler run.</p>
        pub fn recrawl_policy(mut self, input: crate::model::RecrawlPolicy) -> Self {
            self.recrawl_policy = Some(input);
            self
        }
        /// <p>A policy that specifies whether to crawl the entire dataset again, or to crawl only folders that were added since the last crawler run.</p>
        pub fn set_recrawl_policy(
            mut self,
            input: std::option::Option<crate::model::RecrawlPolicy>,
        ) -> Self {
            self.recrawl_policy = input;
            self
        }
        /// <p>The policy that specifies update and delete behaviors for the crawler.</p>
        pub fn schema_change_policy(mut self, input: crate::model::SchemaChangePolicy) -> Self {
            self.schema_change_policy = Some(input);
            self
        }
        /// <p>The policy that specifies update and delete behaviors for the crawler.</p>
        pub fn set_schema_change_policy(
            mut self,
            input: std::option::Option<crate::model::SchemaChangePolicy>,
        ) -> Self {
            self.schema_change_policy = input;
            self
        }
        /// <p>A configuration that specifies whether data lineage is enabled for the crawler.</p>
        pub fn lineage_configuration(mut self, input: crate::model::LineageConfiguration) -> Self {
            self.lineage_configuration = Some(input);
            self
        }
        /// <p>A configuration that specifies whether data lineage is enabled for the crawler.</p>
        pub fn set_lineage_configuration(
            mut self,
            input: std::option::Option<crate::model::LineageConfiguration>,
        ) -> Self {
            self.lineage_configuration = input;
            self
        }
        /// <p>Indicates whether the crawler is running, or whether a run is pending.</p>
        pub fn state(mut self, input: crate::model::CrawlerState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>Indicates whether the crawler is running, or whether a run is pending.</p>
        pub fn set_state(mut self, input: std::option::Option<crate::model::CrawlerState>) -> Self {
            self.state = input;
            self
        }
        /// <p>The prefix added to the names of tables that are created.</p>
        pub fn table_prefix(mut self, input: impl Into<std::string::String>) -> Self {
            self.table_prefix = Some(input.into());
            self
        }
        /// <p>The prefix added to the names of tables that are created.</p>
        pub fn set_table_prefix(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.table_prefix = input;
            self
        }
        /// <p>For scheduled crawlers, the schedule when the crawler runs.</p>
        pub fn schedule(mut self, input: crate::model::Schedule) -> Self {
            self.schedule = Some(input);
            self
        }
        /// <p>For scheduled crawlers, the schedule when the crawler runs.</p>
        pub fn set_schedule(mut self, input: std::option::Option<crate::model::Schedule>) -> Self {
            self.schedule = input;
            self
        }
        /// <p>If the crawler is running, contains the total time elapsed since the last crawl began.</p>
        pub fn crawl_elapsed_time(mut self, input: i64) -> Self {
            self.crawl_elapsed_time = Some(input);
            self
        }
        /// <p>If the crawler is running, contains the total time elapsed since the last crawl began.</p>
        pub fn set_crawl_elapsed_time(mut self, input: std::option::Option<i64>) -> Self {
            self.crawl_elapsed_time = input;
            self
        }
        /// <p>The time that the crawler was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>The time that the crawler was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>The time that the crawler was last updated.</p>
        pub fn last_updated(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_updated = Some(input);
            self
        }
        /// <p>The time that the crawler was last updated.</p>
        pub fn set_last_updated(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_updated = input;
            self
        }
        /// <p>The status of the last crawl, and potentially error information if an error occurred.</p>
        pub fn last_crawl(mut self, input: crate::model::LastCrawlInfo) -> Self {
            self.last_crawl = Some(input);
            self
        }
        /// <p>The status of the last crawl, and potentially error information if an error occurred.</p>
        pub fn set_last_crawl(
            mut self,
            input: std::option::Option<crate::model::LastCrawlInfo>,
        ) -> Self {
            self.last_crawl = input;
            self
        }
        /// <p>The version of the crawler.</p>
        pub fn version(mut self, input: i64) -> Self {
            self.version = Some(input);
            self
        }
        /// <p>The version of the crawler.</p>
        pub fn set_version(mut self, input: std::option::Option<i64>) -> Self {
            self.version = input;
            self
        }
        /// <p>Crawler configuration information. This versioned JSON string allows users to specify aspects of a crawler's behavior. For more information, see <a href="https://docs.aws.amazon.com/glue/latest/dg/crawler-configuration.html">Setting crawler configuration options</a>.</p>
        pub fn configuration(mut self, input: impl Into<std::string::String>) -> Self {
            self.configuration = Some(input.into());
            self
        }
        /// <p>Crawler configuration information. This versioned JSON string allows users to specify aspects of a crawler's behavior. For more information, see <a href="https://docs.aws.amazon.com/glue/latest/dg/crawler-configuration.html">Setting crawler configuration options</a>.</p>
        pub fn set_configuration(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.configuration = input;
            self
        }
        /// <p>The name of the <code>SecurityConfiguration</code> structure to be used by this crawler.</p>
        pub fn crawler_security_configuration(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.crawler_security_configuration = Some(input.into());
            self
        }
        /// <p>The name of the <code>SecurityConfiguration</code> structure to be used by this crawler.</p>
        pub fn set_crawler_security_configuration(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.crawler_security_configuration = input;
            self
        }
        /// <p>Specifies whether the crawler should use Lake Formation credentials for the crawler instead of the IAM role credentials.</p>
        pub fn lake_formation_configuration(
            mut self,
            input: crate::model::LakeFormationConfiguration,
        ) -> Self {
            self.lake_formation_configuration = Some(input);
            self
        }
        /// <p>Specifies whether the crawler should use Lake Formation credentials for the crawler instead of the IAM role credentials.</p>
        pub fn set_lake_formation_configuration(
            mut self,
            input: std::option::Option<crate::model::LakeFormationConfiguration>,
        ) -> Self {
            self.lake_formation_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`Crawler`](crate::model::Crawler).
        pub fn build(self) -> crate::model::Crawler {
            crate::model::Crawler {
                name: self.name,
                role: self.role,
                targets: self.targets,
                database_name: self.database_name,
                description: self.description,
                classifiers: self.classifiers,
                recrawl_policy: self.recrawl_policy,
                schema_change_policy: self.schema_change_policy,
                lineage_configuration: self.lineage_configuration,
                state: self.state,
                table_prefix: self.table_prefix,
                schedule: self.schedule,
                crawl_elapsed_time: self.crawl_elapsed_time.unwrap_or_default(),
                creation_time: self.creation_time,
                last_updated: self.last_updated,
                last_crawl: self.last_crawl,
                version: self.version.unwrap_or_default(),
                configuration: self.configuration,
                crawler_security_configuration: self.crawler_security_configuration,
                lake_formation_configuration: self.lake_formation_configuration,
            }
        }
    }
}
impl Crawler {
    /// Creates a new builder-style object to manufacture [`Crawler`](crate::model::Crawler).
    pub fn builder() -> crate::model::crawler::Builder {
        crate::model::crawler::Builder::default()
    }
}

/// <p>Status and error information about the most recent crawl.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LastCrawlInfo {
    /// <p>Status of the last crawl.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::LastCrawlStatus>,
    /// <p>If an error occurred, the error information about the last crawl.</p>
    #[doc(hidden)]
    pub error_message: std::option::Option<std::string::String>,
    /// <p>The log group for the last crawl.</p>
    #[doc(hidden)]
    pub log_group: std::option::Option<std::string::String>,
    /// <p>The log stream for the last crawl.</p>
    #[doc(hidden)]
    pub log_stream: std::option::Option<std::string::String>,
    /// <p>The prefix for a message about this crawl.</p>
    #[doc(hidden)]
    pub message_prefix: std::option::Option<std::string::String>,
    /// <p>The time at which the crawl started.</p>
    #[doc(hidden)]
    pub start_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl LastCrawlInfo {
    /// <p>Status of the last crawl.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::LastCrawlStatus> {
        self.status.as_ref()
    }
    /// <p>If an error occurred, the error information about the last crawl.</p>
    pub fn error_message(&self) -> std::option::Option<&str> {
        self.error_message.as_deref()
    }
    /// <p>The log group for the last crawl.</p>
    pub fn log_group(&self) -> std::option::Option<&str> {
        self.log_group.as_deref()
    }
    /// <p>The log stream for the last crawl.</p>
    pub fn log_stream(&self) -> std::option::Option<&str> {
        self.log_stream.as_deref()
    }
    /// <p>The prefix for a message about this crawl.</p>
    pub fn message_prefix(&self) -> std::option::Option<&str> {
        self.message_prefix.as_deref()
    }
    /// <p>The time at which the crawl started.</p>
    pub fn start_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.start_time.as_ref()
    }
}
/// See [`LastCrawlInfo`](crate::model::LastCrawlInfo).
pub mod last_crawl_info {

    /// A builder for [`LastCrawlInfo`](crate::model::LastCrawlInfo).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) status: std::option::Option<crate::model::LastCrawlStatus>,
        pub(crate) error_message: std::option::Option<std::string::String>,
        pub(crate) log_group: std::option::Option<std::string::String>,
        pub(crate) log_stream: std::option::Option<std::string::String>,
        pub(crate) message_prefix: std::option::Option<std::string::String>,
        pub(crate) start_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>Status of the last crawl.</p>
        pub fn status(mut self, input: crate::model::LastCrawlStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>Status of the last crawl.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::LastCrawlStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>If an error occurred, the error information about the last crawl.</p>
        pub fn error_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_message = Some(input.into());
            self
        }
        /// <p>If an error occurred, the error information about the last crawl.</p>
        pub fn set_error_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.error_message = input;
            self
        }
        /// <p>The log group for the last crawl.</p>
        pub fn log_group(mut self, input: impl Into<std::string::String>) -> Self {
            self.log_group = Some(input.into());
            self
        }
        /// <p>The log group for the last crawl.</p>
        pub fn set_log_group(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.log_group = input;
            self
        }
        /// <p>The log stream for the last crawl.</p>
        pub fn log_stream(mut self, input: impl Into<std::string::String>) -> Self {
            self.log_stream = Some(input.into());
            self
        }
        /// <p>The log stream for the last crawl.</p>
        pub fn set_log_stream(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.log_stream = input;
            self
        }
        /// <p>The prefix for a message about this crawl.</p>
        pub fn message_prefix(mut self, input: impl Into<std::string::String>) -> Self {
            self.message_prefix = Some(input.into());
            self
        }
        /// <p>The prefix for a message about this crawl.</p>
        pub fn set_message_prefix(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.message_prefix = input;
            self
        }
        /// <p>The time at which the crawl started.</p>
        pub fn start_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.start_time = Some(input);
            self
        }
        /// <p>The time at which the crawl started.</p>
        pub fn set_start_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.start_time = input;
            self
        }
        /// Consumes the builder and constructs a [`LastCrawlInfo`](crate::model::LastCrawlInfo).
        pub fn build(self) -> crate::model::LastCrawlInfo {
            crate::model::LastCrawlInfo {
                status: self.status,
                error_message: self.error_message,
                log_group: self.log_group,
                log_stream: self.log_stream,
                message_prefix: self.message_prefix,
                start_time: self.start_time,
            }
        }
    }
}
impl LastCrawlInfo {
    /// Creates a new builder-style object to manufacture [`LastCrawlInfo`](crate::model::LastCrawlInfo).
    pub fn builder() -> crate::model::last_crawl_info::Builder {
        crate::model::last_crawl_info::Builder::default()
    }
}

/// When writing a match expression against `LastCrawlStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let lastcrawlstatus = unimplemented!();
/// match lastcrawlstatus {
///     LastCrawlStatus::Cancelled => { /* ... */ },
///     LastCrawlStatus::Failed => { /* ... */ },
///     LastCrawlStatus::Succeeded => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `lastcrawlstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `LastCrawlStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `LastCrawlStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `LastCrawlStatus::NewFeature` is defined.
/// Specifically, when `lastcrawlstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `LastCrawlStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum LastCrawlStatus {
    #[allow(missing_docs)] // documentation missing in model
    Cancelled,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    Succeeded,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for LastCrawlStatus {
    fn from(s: &str) -> Self {
        match s {
            "CANCELLED" => LastCrawlStatus::Cancelled,
            "FAILED" => LastCrawlStatus::Failed,
            "SUCCEEDED" => LastCrawlStatus::Succeeded,
            other => LastCrawlStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for LastCrawlStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(LastCrawlStatus::from(s))
    }
}
impl LastCrawlStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            LastCrawlStatus::Cancelled => "CANCELLED",
            LastCrawlStatus::Failed => "FAILED",
            LastCrawlStatus::Succeeded => "SUCCEEDED",
            LastCrawlStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["CANCELLED", "FAILED", "SUCCEEDED"]
    }
}
impl AsRef<str> for LastCrawlStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A scheduling object using a <code>cron</code> statement to schedule an event.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Schedule {
    /// <p>A <code>cron</code> expression used to specify the schedule (see <a href="https://docs.aws.amazon.com/glue/latest/dg/monitor-data-warehouse-schedule.html">Time-Based Schedules for Jobs and Crawlers</a>. For example, to run something every day at 12:15 UTC, you would specify: <code>cron(15 12 * * ? *)</code>.</p>
    #[doc(hidden)]
    pub schedule_expression: std::option::Option<std::string::String>,
    /// <p>The state of the schedule.</p>
    #[doc(hidden)]
    pub state: std::option::Option<crate::model::ScheduleState>,
}
impl Schedule {
    /// <p>A <code>cron</code> expression used to specify the schedule (see <a href="https://docs.aws.amazon.com/glue/latest/dg/monitor-data-warehouse-schedule.html">Time-Based Schedules for Jobs and Crawlers</a>. For example, to run something every day at 12:15 UTC, you would specify: <code>cron(15 12 * * ? *)</code>.</p>
    pub fn schedule_expression(&self) -> std::option::Option<&str> {
        self.schedule_expression.as_deref()
    }
    /// <p>The state of the schedule.</p>
    pub fn state(&self) -> std::option::Option<&crate::model::ScheduleState> {
        self.state.as_ref()
    }
}
/// See [`Schedule`](crate::model::Schedule).
pub mod schedule {

    /// A builder for [`Schedule`](crate::model::Schedule).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) schedule_expression: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<crate::model::ScheduleState>,
    }
    impl Builder {
        /// <p>A <code>cron</code> expression used to specify the schedule (see <a href="https://docs.aws.amazon.com/glue/latest/dg/monitor-data-warehouse-schedule.html">Time-Based Schedules for Jobs and Crawlers</a>. For example, to run something every day at 12:15 UTC, you would specify: <code>cron(15 12 * * ? *)</code>.</p>
        pub fn schedule_expression(mut self, input: impl Into<std::string::String>) -> Self {
            self.schedule_expression = Some(input.into());
            self
        }
        /// <p>A <code>cron</code> expression used to specify the schedule (see <a href="https://docs.aws.amazon.com/glue/latest/dg/monitor-data-warehouse-schedule.html">Time-Based Schedules for Jobs and Crawlers</a>. For example, to run something every day at 12:15 UTC, you would specify: <code>cron(15 12 * * ? *)</code>.</p>
        pub fn set_schedule_expression(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.schedule_expression = input;
            self
        }
        /// <p>The state of the schedule.</p>
        pub fn state(mut self, input: crate::model::ScheduleState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The state of the schedule.</p>
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::ScheduleState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// Consumes the builder and constructs a [`Schedule`](crate::model::Schedule).
        pub fn build(self) -> crate::model::Schedule {
            crate::model::Schedule {
                schedule_expression: self.schedule_expression,
                state: self.state,
            }
        }
    }
}
impl Schedule {
    /// Creates a new builder-style object to manufacture [`Schedule`](crate::model::Schedule).
    pub fn builder() -> crate::model::schedule::Builder {
        crate::model::schedule::Builder::default()
    }
}

/// When writing a match expression against `ScheduleState`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let schedulestate = unimplemented!();
/// match schedulestate {
///     ScheduleState::NotScheduled => { /* ... */ },
///     ScheduleState::Scheduled => { /* ... */ },
///     ScheduleState::Transitioning => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `schedulestate` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ScheduleState::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ScheduleState::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ScheduleState::NewFeature` is defined.
/// Specifically, when `schedulestate` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ScheduleState::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ScheduleState {
    #[allow(missing_docs)] // documentation missing in model
    NotScheduled,
    #[allow(missing_docs)] // documentation missing in model
    Scheduled,
    #[allow(missing_docs)] // documentation missing in model
    Transitioning,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ScheduleState {
    fn from(s: &str) -> Self {
        match s {
            "NOT_SCHEDULED" => ScheduleState::NotScheduled,
            "SCHEDULED" => ScheduleState::Scheduled,
            "TRANSITIONING" => ScheduleState::Transitioning,
            other => ScheduleState::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ScheduleState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ScheduleState::from(s))
    }
}
impl ScheduleState {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ScheduleState::NotScheduled => "NOT_SCHEDULED",
            ScheduleState::Scheduled => "SCHEDULED",
            ScheduleState::Transitioning => "TRANSITIONING",
            ScheduleState::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["NOT_SCHEDULED", "SCHEDULED", "TRANSITIONING"]
    }
}
impl AsRef<str> for ScheduleState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `CrawlerState`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let crawlerstate = unimplemented!();
/// match crawlerstate {
///     CrawlerState::Ready => { /* ... */ },
///     CrawlerState::Running => { /* ... */ },
///     CrawlerState::Stopping => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `crawlerstate` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `CrawlerState::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `CrawlerState::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `CrawlerState::NewFeature` is defined.
/// Specifically, when `crawlerstate` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `CrawlerState::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum CrawlerState {
    #[allow(missing_docs)] // documentation missing in model
    Ready,
    #[allow(missing_docs)] // documentation missing in model
    Running,
    #[allow(missing_docs)] // documentation missing in model
    Stopping,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for CrawlerState {
    fn from(s: &str) -> Self {
        match s {
            "READY" => CrawlerState::Ready,
            "RUNNING" => CrawlerState::Running,
            "STOPPING" => CrawlerState::Stopping,
            other => CrawlerState::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for CrawlerState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(CrawlerState::from(s))
    }
}
impl CrawlerState {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            CrawlerState::Ready => "READY",
            CrawlerState::Running => "RUNNING",
            CrawlerState::Stopping => "STOPPING",
            CrawlerState::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["READY", "RUNNING", "STOPPING"]
    }
}
impl AsRef<str> for CrawlerState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Metrics for a specified crawler.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CrawlerMetrics {
    /// <p>The name of the crawler.</p>
    #[doc(hidden)]
    pub crawler_name: std::option::Option<std::string::String>,
    /// <p>The estimated time left to complete a running crawl.</p>
    #[doc(hidden)]
    pub time_left_seconds: f64,
    /// <p>True if the crawler is still estimating how long it will take to complete this run.</p>
    #[doc(hidden)]
    pub still_estimating: bool,
    /// <p>The duration of the crawler's most recent run, in seconds.</p>
    #[doc(hidden)]
    pub last_runtime_seconds: f64,
    /// <p>The median duration of this crawler's runs, in seconds.</p>
    #[doc(hidden)]
    pub median_runtime_seconds: f64,
    /// <p>The number of tables created by this crawler.</p>
    #[doc(hidden)]
    pub tables_created: i32,
    /// <p>The number of tables updated by this crawler.</p>
    #[doc(hidden)]
    pub tables_updated: i32,
    /// <p>The number of tables deleted by this crawler.</p>
    #[doc(hidden)]
    pub tables_deleted: i32,
}
impl CrawlerMetrics {
    /// <p>The name of the crawler.</p>
    pub fn crawler_name(&self) -> std::option::Option<&str> {
        self.crawler_name.as_deref()
    }
    /// <p>The estimated time left to complete a running crawl.</p>
    pub fn time_left_seconds(&self) -> f64 {
        self.time_left_seconds
    }
    /// <p>True if the crawler is still estimating how long it will take to complete this run.</p>
    pub fn still_estimating(&self) -> bool {
        self.still_estimating
    }
    /// <p>The duration of the crawler's most recent run, in seconds.</p>
    pub fn last_runtime_seconds(&self) -> f64 {
        self.last_runtime_seconds
    }
    /// <p>The median duration of this crawler's runs, in seconds.</p>
    pub fn median_runtime_seconds(&self) -> f64 {
        self.median_runtime_seconds
    }
    /// <p>The number of tables created by this crawler.</p>
    pub fn tables_created(&self) -> i32 {
        self.tables_created
    }
    /// <p>The number of tables updated by this crawler.</p>
    pub fn tables_updated(&self) -> i32 {
        self.tables_updated
    }
    /// <p>The number of tables deleted by this crawler.</p>
    pub fn tables_deleted(&self) -> i32 {
        self.tables_deleted
    }
}
/// See [`CrawlerMetrics`](crate::model::CrawlerMetrics).
pub mod crawler_metrics {

    /// A builder for [`CrawlerMetrics`](crate::model::CrawlerMetrics).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) crawler_name: std::option::Option<std::string::String>,
        pub(crate) time_left_seconds: std::option::Option<f64>,
        pub(crate) still_estimating: std::option::Option<bool>,
        pub(crate) last_runtime_seconds: std::option::Option<f64>,
        pub(crate) median_runtime_seconds: std::option::Option<f64>,
        pub(crate) tables_created: std::option::Option<i32>,
        pub(crate) tables_updated: std::option::Option<i32>,
        pub(crate) tables_deleted: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The name of the crawler.</p>
        pub fn crawler_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.crawler_name = Some(input.into());
            self
        }
        /// <p>The name of the crawler.</p>
        pub fn set_crawler_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.crawler_name = input;
            self
        }
        /// <p>The estimated time left to complete a running crawl.</p>
        pub fn time_left_seconds(mut self, input: f64) -> Self {
            self.time_left_seconds = Some(input);
            self
        }
        /// <p>The estimated time left to complete a running crawl.</p>
        pub fn set_time_left_seconds(mut self, input: std::option::Option<f64>) -> Self {
            self.time_left_seconds = input;
            self
        }
        /// <p>True if the crawler is still estimating how long it will take to complete this run.</p>
        pub fn still_estimating(mut self, input: bool) -> Self {
            self.still_estimating = Some(input);
            self
        }
        /// <p>True if the crawler is still estimating how long it will take to complete this run.</p>
        pub fn set_still_estimating(mut self, input: std::option::Option<bool>) -> Self {
            self.still_estimating = input;
            self
        }
        /// <p>The duration of the crawler's most recent run, in seconds.</p>
        pub fn last_runtime_seconds(mut self, input: f64) -> Self {
            self.last_runtime_seconds = Some(input);
            self
        }
        /// <p>The duration of the crawler's most recent run, in seconds.</p>
        pub fn set_last_runtime_seconds(mut self, input: std::option::Option<f64>) -> Self {
            self.last_runtime_seconds = input;
            self
        }
        /// <p>The median duration of this crawler's runs, in seconds.</p>
        pub fn median_runtime_seconds(mut self, input: f64) -> Self {
            self.median_runtime_seconds = Some(input);
            self
        }
        /// <p>The median duration of this crawler's runs, in seconds.</p>
        pub fn set_median_runtime_seconds(mut self, input: std::option::Option<f64>) -> Self {
            self.median_runtime_seconds = input;
            self
        }
        /// <p>The number of tables created by this crawler.</p>
        pub fn tables_created(mut self, input: i32) -> Self {
            self.tables_created = Some(input);
            self
        }
        /// <p>The number of tables created by this crawler.</p>
        pub fn set_tables_created(mut self, input: std::option::Option<i32>) -> Self {
            self.tables_created = input;
            self
        }
        /// <p>The number of tables updated by this crawler.</p>
        pub fn tables_updated(mut self, input: i32) -> Self {
            self.tables_updated = Some(input);
            self
        }
        /// <p>The number of tables updated by this crawler.</p>
        pub fn set_tables_updated(mut self, input: std::option::Option<i32>) -> Self {
            self.tables_updated = input;
            self
        }
        /// <p>The number of tables deleted by this crawler.</p>
        pub fn tables_deleted(mut self, input: i32) -> Self {
            self.tables_deleted = Some(input);
            self
        }
        /// <p>The number of tables deleted by this crawler.</p>
        pub fn set_tables_deleted(mut self, input: std::option::Option<i32>) -> Self {
            self.tables_deleted = input;
            self
        }
        /// Consumes the builder and constructs a [`CrawlerMetrics`](crate::model::CrawlerMetrics).
        pub fn build(self) -> crate::model::CrawlerMetrics {
            crate::model::CrawlerMetrics {
                crawler_name: self.crawler_name,
                time_left_seconds: self.time_left_seconds.unwrap_or_default(),
                still_estimating: self.still_estimating.unwrap_or_default(),
                last_runtime_seconds: self.last_runtime_seconds.unwrap_or_default(),
                median_runtime_seconds: self.median_runtime_seconds.unwrap_or_default(),
                tables_created: self.tables_created.unwrap_or_default(),
                tables_updated: self.tables_updated.unwrap_or_default(),
                tables_deleted: self.tables_deleted.unwrap_or_default(),
            }
        }
    }
}
impl CrawlerMetrics {
    /// Creates a new builder-style object to manufacture [`CrawlerMetrics`](crate::model::CrawlerMetrics).
    pub fn builder() -> crate::model::crawler_metrics::Builder {
        crate::model::crawler_metrics::Builder::default()
    }
}

/// <p>Defines a connection to a data source.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Connection {
    /// <p>The name of the connection definition.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The description of the connection.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The type of the connection. Currently, SFTP is not supported.</p>
    #[doc(hidden)]
    pub connection_type: std::option::Option<crate::model::ConnectionType>,
    /// <p>A list of criteria that can be used in selecting this connection.</p>
    #[doc(hidden)]
    pub match_criteria: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>These key-value pairs define parameters for the connection:</p>
    /// <ul>
    /// <li> <p> <code>HOST</code> - The host URI: either the fully qualified domain name (FQDN) or the IPv4 address of the database host.</p> </li>
    /// <li> <p> <code>PORT</code> - The port number, between 1024 and 65535, of the port on which the database host is listening for database connections.</p> </li>
    /// <li> <p> <code>USER_NAME</code> - The name under which to log in to the database. The value string for <code>USER_NAME</code> is "<code>USERNAME</code>".</p> </li>
    /// <li> <p> <code>PASSWORD</code> - A password, if one is used, for the user name.</p> </li>
    /// <li> <p> <code>ENCRYPTED_PASSWORD</code> - When you enable connection password protection by setting <code>ConnectionPasswordEncryption</code> in the Data Catalog encryption settings, this field stores the encrypted password.</p> </li>
    /// <li> <p> <code>JDBC_DRIVER_JAR_URI</code> - The Amazon Simple Storage Service (Amazon S3) path of the JAR file that contains the JDBC driver to use.</p> </li>
    /// <li> <p> <code>JDBC_DRIVER_CLASS_NAME</code> - The class name of the JDBC driver to use.</p> </li>
    /// <li> <p> <code>JDBC_ENGINE</code> - The name of the JDBC engine to use.</p> </li>
    /// <li> <p> <code>JDBC_ENGINE_VERSION</code> - The version of the JDBC engine to use.</p> </li>
    /// <li> <p> <code>CONFIG_FILES</code> - (Reserved for future use.)</p> </li>
    /// <li> <p> <code>INSTANCE_ID</code> - The instance ID to use.</p> </li>
    /// <li> <p> <code>JDBC_CONNECTION_URL</code> - The URL for connecting to a JDBC data source.</p> </li>
    /// <li> <p> <code>JDBC_ENFORCE_SSL</code> - A Boolean string (true, false) specifying whether Secure Sockets Layer (SSL) with hostname matching is enforced for the JDBC connection on the client. The default is false.</p> </li>
    /// <li> <p> <code>CUSTOM_JDBC_CERT</code> - An Amazon S3 location specifying the customer's root certificate. Glue uses this root certificate to validate the customer’s certificate when connecting to the customer database. Glue only handles X.509 certificates. The certificate provided must be DER-encoded and supplied in Base64 encoding PEM format.</p> </li>
    /// <li> <p> <code>SKIP_CUSTOM_JDBC_CERT_VALIDATION</code> - By default, this is <code>false</code>. Glue validates the Signature algorithm and Subject Public Key Algorithm for the customer certificate. The only permitted algorithms for the Signature algorithm are SHA256withRSA, SHA384withRSA or SHA512withRSA. For the Subject Public Key Algorithm, the key length must be at least 2048. You can set the value of this property to <code>true</code> to skip Glue’s validation of the customer certificate.</p> </li>
    /// <li> <p> <code>CUSTOM_JDBC_CERT_STRING</code> - A custom JDBC certificate string which is used for domain match or distinguished name match to prevent a man-in-the-middle attack. In Oracle database, this is used as the <code>SSL_SERVER_CERT_DN</code>; in Microsoft SQL Server, this is used as the <code>hostNameInCertificate</code>.</p> </li>
    /// <li> <p> <code>CONNECTION_URL</code> - The URL for connecting to a general (non-JDBC) data source.</p> </li>
    /// <li> <p> <code>SECRET_ID</code> - The secret ID used for the secret manager of credentials.</p> </li>
    /// <li> <p> <code>CONNECTOR_URL</code> - The connector URL for a MARKETPLACE or CUSTOM connection.</p> </li>
    /// <li> <p> <code>CONNECTOR_TYPE</code> - The connector type for a MARKETPLACE or CUSTOM connection.</p> </li>
    /// <li> <p> <code>CONNECTOR_CLASS_NAME</code> - The connector class name for a MARKETPLACE or CUSTOM connection.</p> </li>
    /// <li> <p> <code>KAFKA_BOOTSTRAP_SERVERS</code> - A comma-separated list of host and port pairs that are the addresses of the Apache Kafka brokers in a Kafka cluster to which a Kafka client will connect to and bootstrap itself.</p> </li>
    /// <li> <p> <code>KAFKA_SSL_ENABLED</code> - Whether to enable or disable SSL on an Apache Kafka connection. Default value is "true".</p> </li>
    /// <li> <p> <code>KAFKA_CUSTOM_CERT</code> - The Amazon S3 URL for the private CA cert file (.pem format). The default is an empty string.</p> </li>
    /// <li> <p> <code>KAFKA_SKIP_CUSTOM_CERT_VALIDATION</code> - Whether to skip the validation of the CA cert file or not. Glue validates for three algorithms: SHA256withRSA, SHA384withRSA and SHA512withRSA. Default value is "false".</p> </li>
    /// <li> <p> <code>KAFKA_CLIENT_KEYSTORE</code> - The Amazon S3 location of the client keystore file for Kafka client side authentication (Optional).</p> </li>
    /// <li> <p> <code>KAFKA_CLIENT_KEYSTORE_PASSWORD</code> - The password to access the provided keystore (Optional).</p> </li>
    /// <li> <p> <code>KAFKA_CLIENT_KEY_PASSWORD</code> - A keystore can consist of multiple keys, so this is the password to access the client key to be used with the Kafka server side key (Optional).</p> </li>
    /// <li> <p> <code>ENCRYPTED_KAFKA_CLIENT_KEYSTORE_PASSWORD</code> - The encrypted version of the Kafka client keystore password (if the user has the Glue encrypt passwords setting selected).</p> </li>
    /// <li> <p> <code>ENCRYPTED_KAFKA_CLIENT_KEY_PASSWORD</code> - The encrypted version of the Kafka client key password (if the user has the Glue encrypt passwords setting selected).</p> </li>
    /// <li> <p> <code>KAFKA_SASL_MECHANISM</code> - <code>"SCRAM-SHA-512"</code> or <code>"GSSAPI"</code>. These are the two supported <a href="https://www.iana.org/assignments/sasl-mechanisms/sasl-mechanisms.xhtml">SASL Mechanisms</a>.</p> </li>
    /// <li> <p> <code>KAFKA_SASL_SCRAM_USERNAME</code> - A plaintext username used to authenticate with the "SCRAM-SHA-512" mechanism.</p> </li>
    /// <li> <p> <code>KAFKA_SASL_SCRAM_PASSWORD</code> - A plaintext password used to authenticate with the "SCRAM-SHA-512" mechanism.</p> </li>
    /// <li> <p> <code>ENCRYPTED_KAFKA_SASL_SCRAM_PASSWORD</code> - The encrypted version of the Kafka SASL SCRAM password (if the user has the Glue encrypt passwords setting selected).</p> </li>
    /// <li> <p> <code>KAFKA_SASL_GSSAPI_KEYTAB</code> - The S3 location of a Kerberos <code>keytab</code> file. A keytab stores long-term keys for one or more principals. For more information, see <a href="https://web.mit.edu/kerberos/krb5-latest/doc/basic/keytab_def.html">MIT Kerberos Documentation: Keytab</a>.</p> </li>
    /// <li> <p> <code>KAFKA_SASL_GSSAPI_KRB5_CONF</code> - The S3 location of a Kerberos <code>krb5.conf</code> file. A krb5.conf stores Kerberos configuration information, such as the location of the KDC server. For more information, see <a href="https://web.mit.edu/kerberos/krb5-1.12/doc/admin/conf_files/krb5_conf.html">MIT Kerberos Documentation: krb5.conf</a>.</p> </li>
    /// <li> <p> <code>KAFKA_SASL_GSSAPI_SERVICE</code> - The Kerberos service name, as set with <code>sasl.kerberos.service.name</code> in your <a href="https://kafka.apache.org/documentation/#brokerconfigs_sasl.kerberos.service.name">Kafka Configuration</a>.</p> </li>
    /// <li> <p> <code>KAFKA_SASL_GSSAPI_PRINCIPAL</code> - The name of the Kerberos princial used by Glue. For more information, see <a href="https://kafka.apache.org/documentation/#security_sasl_kerberos_clientconfig">Kafka Documentation: Configuring Kafka Brokers</a>.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub connection_properties: std::option::Option<
        std::collections::HashMap<crate::model::ConnectionPropertyKey, std::string::String>,
    >,
    /// <p>A map of physical connection requirements, such as virtual private cloud (VPC) and <code>SecurityGroup</code>, that are needed to make this connection successfully.</p>
    #[doc(hidden)]
    pub physical_connection_requirements:
        std::option::Option<crate::model::PhysicalConnectionRequirements>,
    /// <p>The time that this connection definition was created.</p>
    #[doc(hidden)]
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The last time that this connection definition was updated.</p>
    #[doc(hidden)]
    pub last_updated_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The user, group, or role that last updated this connection definition.</p>
    #[doc(hidden)]
    pub last_updated_by: std::option::Option<std::string::String>,
}
impl Connection {
    /// <p>The name of the connection definition.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The description of the connection.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The type of the connection. Currently, SFTP is not supported.</p>
    pub fn connection_type(&self) -> std::option::Option<&crate::model::ConnectionType> {
        self.connection_type.as_ref()
    }
    /// <p>A list of criteria that can be used in selecting this connection.</p>
    pub fn match_criteria(&self) -> std::option::Option<&[std::string::String]> {
        self.match_criteria.as_deref()
    }
    /// <p>These key-value pairs define parameters for the connection:</p>
    /// <ul>
    /// <li> <p> <code>HOST</code> - The host URI: either the fully qualified domain name (FQDN) or the IPv4 address of the database host.</p> </li>
    /// <li> <p> <code>PORT</code> - The port number, between 1024 and 65535, of the port on which the database host is listening for database connections.</p> </li>
    /// <li> <p> <code>USER_NAME</code> - The name under which to log in to the database. The value string for <code>USER_NAME</code> is "<code>USERNAME</code>".</p> </li>
    /// <li> <p> <code>PASSWORD</code> - A password, if one is used, for the user name.</p> </li>
    /// <li> <p> <code>ENCRYPTED_PASSWORD</code> - When you enable connection password protection by setting <code>ConnectionPasswordEncryption</code> in the Data Catalog encryption settings, this field stores the encrypted password.</p> </li>
    /// <li> <p> <code>JDBC_DRIVER_JAR_URI</code> - The Amazon Simple Storage Service (Amazon S3) path of the JAR file that contains the JDBC driver to use.</p> </li>
    /// <li> <p> <code>JDBC_DRIVER_CLASS_NAME</code> - The class name of the JDBC driver to use.</p> </li>
    /// <li> <p> <code>JDBC_ENGINE</code> - The name of the JDBC engine to use.</p> </li>
    /// <li> <p> <code>JDBC_ENGINE_VERSION</code> - The version of the JDBC engine to use.</p> </li>
    /// <li> <p> <code>CONFIG_FILES</code> - (Reserved for future use.)</p> </li>
    /// <li> <p> <code>INSTANCE_ID</code> - The instance ID to use.</p> </li>
    /// <li> <p> <code>JDBC_CONNECTION_URL</code> - The URL for connecting to a JDBC data source.</p> </li>
    /// <li> <p> <code>JDBC_ENFORCE_SSL</code> - A Boolean string (true, false) specifying whether Secure Sockets Layer (SSL) with hostname matching is enforced for the JDBC connection on the client. The default is false.</p> </li>
    /// <li> <p> <code>CUSTOM_JDBC_CERT</code> - An Amazon S3 location specifying the customer's root certificate. Glue uses this root certificate to validate the customer’s certificate when connecting to the customer database. Glue only handles X.509 certificates. The certificate provided must be DER-encoded and supplied in Base64 encoding PEM format.</p> </li>
    /// <li> <p> <code>SKIP_CUSTOM_JDBC_CERT_VALIDATION</code> - By default, this is <code>false</code>. Glue validates the Signature algorithm and Subject Public Key Algorithm for the customer certificate. The only permitted algorithms for the Signature algorithm are SHA256withRSA, SHA384withRSA or SHA512withRSA. For the Subject Public Key Algorithm, the key length must be at least 2048. You can set the value of this property to <code>true</code> to skip Glue’s validation of the customer certificate.</p> </li>
    /// <li> <p> <code>CUSTOM_JDBC_CERT_STRING</code> - A custom JDBC certificate string which is used for domain match or distinguished name match to prevent a man-in-the-middle attack. In Oracle database, this is used as the <code>SSL_SERVER_CERT_DN</code>; in Microsoft SQL Server, this is used as the <code>hostNameInCertificate</code>.</p> </li>
    /// <li> <p> <code>CONNECTION_URL</code> - The URL for connecting to a general (non-JDBC) data source.</p> </li>
    /// <li> <p> <code>SECRET_ID</code> - The secret ID used for the secret manager of credentials.</p> </li>
    /// <li> <p> <code>CONNECTOR_URL</code> - The connector URL for a MARKETPLACE or CUSTOM connection.</p> </li>
    /// <li> <p> <code>CONNECTOR_TYPE</code> - The connector type for a MARKETPLACE or CUSTOM connection.</p> </li>
    /// <li> <p> <code>CONNECTOR_CLASS_NAME</code> - The connector class name for a MARKETPLACE or CUSTOM connection.</p> </li>
    /// <li> <p> <code>KAFKA_BOOTSTRAP_SERVERS</code> - A comma-separated list of host and port pairs that are the addresses of the Apache Kafka brokers in a Kafka cluster to which a Kafka client will connect to and bootstrap itself.</p> </li>
    /// <li> <p> <code>KAFKA_SSL_ENABLED</code> - Whether to enable or disable SSL on an Apache Kafka connection. Default value is "true".</p> </li>
    /// <li> <p> <code>KAFKA_CUSTOM_CERT</code> - The Amazon S3 URL for the private CA cert file (.pem format). The default is an empty string.</p> </li>
    /// <li> <p> <code>KAFKA_SKIP_CUSTOM_CERT_VALIDATION</code> - Whether to skip the validation of the CA cert file or not. Glue validates for three algorithms: SHA256withRSA, SHA384withRSA and SHA512withRSA. Default value is "false".</p> </li>
    /// <li> <p> <code>KAFKA_CLIENT_KEYSTORE</code> - The Amazon S3 location of the client keystore file for Kafka client side authentication (Optional).</p> </li>
    /// <li> <p> <code>KAFKA_CLIENT_KEYSTORE_PASSWORD</code> - The password to access the provided keystore (Optional).</p> </li>
    /// <li> <p> <code>KAFKA_CLIENT_KEY_PASSWORD</code> - A keystore can consist of multiple keys, so this is the password to access the client key to be used with the Kafka server side key (Optional).</p> </li>
    /// <li> <p> <code>ENCRYPTED_KAFKA_CLIENT_KEYSTORE_PASSWORD</code> - The encrypted version of the Kafka client keystore password (if the user has the Glue encrypt passwords setting selected).</p> </li>
    /// <li> <p> <code>ENCRYPTED_KAFKA_CLIENT_KEY_PASSWORD</code> - The encrypted version of the Kafka client key password (if the user has the Glue encrypt passwords setting selected).</p> </li>
    /// <li> <p> <code>KAFKA_SASL_MECHANISM</code> - <code>"SCRAM-SHA-512"</code> or <code>"GSSAPI"</code>. These are the two supported <a href="https://www.iana.org/assignments/sasl-mechanisms/sasl-mechanisms.xhtml">SASL Mechanisms</a>.</p> </li>
    /// <li> <p> <code>KAFKA_SASL_SCRAM_USERNAME</code> - A plaintext username used to authenticate with the "SCRAM-SHA-512" mechanism.</p> </li>
    /// <li> <p> <code>KAFKA_SASL_SCRAM_PASSWORD</code> - A plaintext password used to authenticate with the "SCRAM-SHA-512" mechanism.</p> </li>
    /// <li> <p> <code>ENCRYPTED_KAFKA_SASL_SCRAM_PASSWORD</code> - The encrypted version of the Kafka SASL SCRAM password (if the user has the Glue encrypt passwords setting selected).</p> </li>
    /// <li> <p> <code>KAFKA_SASL_GSSAPI_KEYTAB</code> - The S3 location of a Kerberos <code>keytab</code> file. A keytab stores long-term keys for one or more principals. For more information, see <a href="https://web.mit.edu/kerberos/krb5-latest/doc/basic/keytab_def.html">MIT Kerberos Documentation: Keytab</a>.</p> </li>
    /// <li> <p> <code>KAFKA_SASL_GSSAPI_KRB5_CONF</code> - The S3 location of a Kerberos <code>krb5.conf</code> file. A krb5.conf stores Kerberos configuration information, such as the location of the KDC server. For more information, see <a href="https://web.mit.edu/kerberos/krb5-1.12/doc/admin/conf_files/krb5_conf.html">MIT Kerberos Documentation: krb5.conf</a>.</p> </li>
    /// <li> <p> <code>KAFKA_SASL_GSSAPI_SERVICE</code> - The Kerberos service name, as set with <code>sasl.kerberos.service.name</code> in your <a href="https://kafka.apache.org/documentation/#brokerconfigs_sasl.kerberos.service.name">Kafka Configuration</a>.</p> </li>
    /// <li> <p> <code>KAFKA_SASL_GSSAPI_PRINCIPAL</code> - The name of the Kerberos princial used by Glue. For more information, see <a href="https://kafka.apache.org/documentation/#security_sasl_kerberos_clientconfig">Kafka Documentation: Configuring Kafka Brokers</a>.</p> </li>
    /// </ul>
    pub fn connection_properties(
        &self,
    ) -> std::option::Option<
        &std::collections::HashMap<crate::model::ConnectionPropertyKey, std::string::String>,
    > {
        self.connection_properties.as_ref()
    }
    /// <p>A map of physical connection requirements, such as virtual private cloud (VPC) and <code>SecurityGroup</code>, that are needed to make this connection successfully.</p>
    pub fn physical_connection_requirements(
        &self,
    ) -> std::option::Option<&crate::model::PhysicalConnectionRequirements> {
        self.physical_connection_requirements.as_ref()
    }
    /// <p>The time that this connection definition was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>The last time that this connection definition was updated.</p>
    pub fn last_updated_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_updated_time.as_ref()
    }
    /// <p>The user, group, or role that last updated this connection definition.</p>
    pub fn last_updated_by(&self) -> std::option::Option<&str> {
        self.last_updated_by.as_deref()
    }
}
/// See [`Connection`](crate::model::Connection).
pub mod connection {

    /// A builder for [`Connection`](crate::model::Connection).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) connection_type: std::option::Option<crate::model::ConnectionType>,
        pub(crate) match_criteria: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) connection_properties: std::option::Option<
            std::collections::HashMap<crate::model::ConnectionPropertyKey, std::string::String>,
        >,
        pub(crate) physical_connection_requirements:
            std::option::Option<crate::model::PhysicalConnectionRequirements>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_updated_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_updated_by: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the connection definition.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the connection definition.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The description of the connection.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the connection.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The type of the connection. Currently, SFTP is not supported.</p>
        pub fn connection_type(mut self, input: crate::model::ConnectionType) -> Self {
            self.connection_type = Some(input);
            self
        }
        /// <p>The type of the connection. Currently, SFTP is not supported.</p>
        pub fn set_connection_type(
            mut self,
            input: std::option::Option<crate::model::ConnectionType>,
        ) -> Self {
            self.connection_type = input;
            self
        }
        /// Appends an item to `match_criteria`.
        ///
        /// To override the contents of this collection use [`set_match_criteria`](Self::set_match_criteria).
        ///
        /// <p>A list of criteria that can be used in selecting this connection.</p>
        pub fn match_criteria(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.match_criteria.unwrap_or_default();
            v.push(input.into());
            self.match_criteria = Some(v);
            self
        }
        /// <p>A list of criteria that can be used in selecting this connection.</p>
        pub fn set_match_criteria(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.match_criteria = input;
            self
        }
        /// Adds a key-value pair to `connection_properties`.
        ///
        /// To override the contents of this collection use [`set_connection_properties`](Self::set_connection_properties).
        ///
        /// <p>These key-value pairs define parameters for the connection:</p>
        /// <ul>
        /// <li> <p> <code>HOST</code> - The host URI: either the fully qualified domain name (FQDN) or the IPv4 address of the database host.</p> </li>
        /// <li> <p> <code>PORT</code> - The port number, between 1024 and 65535, of the port on which the database host is listening for database connections.</p> </li>
        /// <li> <p> <code>USER_NAME</code> - The name under which to log in to the database. The value string for <code>USER_NAME</code> is "<code>USERNAME</code>".</p> </li>
        /// <li> <p> <code>PASSWORD</code> - A password, if one is used, for the user name.</p> </li>
        /// <li> <p> <code>ENCRYPTED_PASSWORD</code> - When you enable connection password protection by setting <code>ConnectionPasswordEncryption</code> in the Data Catalog encryption settings, this field stores the encrypted password.</p> </li>
        /// <li> <p> <code>JDBC_DRIVER_JAR_URI</code> - The Amazon Simple Storage Service (Amazon S3) path of the JAR file that contains the JDBC driver to use.</p> </li>
        /// <li> <p> <code>JDBC_DRIVER_CLASS_NAME</code> - The class name of the JDBC driver to use.</p> </li>
        /// <li> <p> <code>JDBC_ENGINE</code> - The name of the JDBC engine to use.</p> </li>
        /// <li> <p> <code>JDBC_ENGINE_VERSION</code> - The version of the JDBC engine to use.</p> </li>
        /// <li> <p> <code>CONFIG_FILES</code> - (Reserved for future use.)</p> </li>
        /// <li> <p> <code>INSTANCE_ID</code> - The instance ID to use.</p> </li>
        /// <li> <p> <code>JDBC_CONNECTION_URL</code> - The URL for connecting to a JDBC data source.</p> </li>
        /// <li> <p> <code>JDBC_ENFORCE_SSL</code> - A Boolean string (true, false) specifying whether Secure Sockets Layer (SSL) with hostname matching is enforced for the JDBC connection on the client. The default is false.</p> </li>
        /// <li> <p> <code>CUSTOM_JDBC_CERT</code> - An Amazon S3 location specifying the customer's root certificate. Glue uses this root certificate to validate the customer’s certificate when connecting to the customer database. Glue only handles X.509 certificates. The certificate provided must be DER-encoded and supplied in Base64 encoding PEM format.</p> </li>
        /// <li> <p> <code>SKIP_CUSTOM_JDBC_CERT_VALIDATION</code> - By default, this is <code>false</code>. Glue validates the Signature algorithm and Subject Public Key Algorithm for the customer certificate. The only permitted algorithms for the Signature algorithm are SHA256withRSA, SHA384withRSA or SHA512withRSA. For the Subject Public Key Algorithm, the key length must be at least 2048. You can set the value of this property to <code>true</code> to skip Glue’s validation of the customer certificate.</p> </li>
        /// <li> <p> <code>CUSTOM_JDBC_CERT_STRING</code> - A custom JDBC certificate string which is used for domain match or distinguished name match to prevent a man-in-the-middle attack. In Oracle database, this is used as the <code>SSL_SERVER_CERT_DN</code>; in Microsoft SQL Server, this is used as the <code>hostNameInCertificate</code>.</p> </li>
        /// <li> <p> <code>CONNECTION_URL</code> - The URL for connecting to a general (non-JDBC) data source.</p> </li>
        /// <li> <p> <code>SECRET_ID</code> - The secret ID used for the secret manager of credentials.</p> </li>
        /// <li> <p> <code>CONNECTOR_URL</code> - The connector URL for a MARKETPLACE or CUSTOM connection.</p> </li>
        /// <li> <p> <code>CONNECTOR_TYPE</code> - The connector type for a MARKETPLACE or CUSTOM connection.</p> </li>
        /// <li> <p> <code>CONNECTOR_CLASS_NAME</code> - The connector class name for a MARKETPLACE or CUSTOM connection.</p> </li>
        /// <li> <p> <code>KAFKA_BOOTSTRAP_SERVERS</code> - A comma-separated list of host and port pairs that are the addresses of the Apache Kafka brokers in a Kafka cluster to which a Kafka client will connect to and bootstrap itself.</p> </li>
        /// <li> <p> <code>KAFKA_SSL_ENABLED</code> - Whether to enable or disable SSL on an Apache Kafka connection. Default value is "true".</p> </li>
        /// <li> <p> <code>KAFKA_CUSTOM_CERT</code> - The Amazon S3 URL for the private CA cert file (.pem format). The default is an empty string.</p> </li>
        /// <li> <p> <code>KAFKA_SKIP_CUSTOM_CERT_VALIDATION</code> - Whether to skip the validation of the CA cert file or not. Glue validates for three algorithms: SHA256withRSA, SHA384withRSA and SHA512withRSA. Default value is "false".</p> </li>
        /// <li> <p> <code>KAFKA_CLIENT_KEYSTORE</code> - The Amazon S3 location of the client keystore file for Kafka client side authentication (Optional).</p> </li>
        /// <li> <p> <code>KAFKA_CLIENT_KEYSTORE_PASSWORD</code> - The password to access the provided keystore (Optional).</p> </li>
        /// <li> <p> <code>KAFKA_CLIENT_KEY_PASSWORD</code> - A keystore can consist of multiple keys, so this is the password to access the client key to be used with the Kafka server side key (Optional).</p> </li>
        /// <li> <p> <code>ENCRYPTED_KAFKA_CLIENT_KEYSTORE_PASSWORD</code> - The encrypted version of the Kafka client keystore password (if the user has the Glue encrypt passwords setting selected).</p> </li>
        /// <li> <p> <code>ENCRYPTED_KAFKA_CLIENT_KEY_PASSWORD</code> - The encrypted version of the Kafka client key password (if the user has the Glue encrypt passwords setting selected).</p> </li>
        /// <li> <p> <code>KAFKA_SASL_MECHANISM</code> - <code>"SCRAM-SHA-512"</code> or <code>"GSSAPI"</code>. These are the two supported <a href="https://www.iana.org/assignments/sasl-mechanisms/sasl-mechanisms.xhtml">SASL Mechanisms</a>.</p> </li>
        /// <li> <p> <code>KAFKA_SASL_SCRAM_USERNAME</code> - A plaintext username used to authenticate with the "SCRAM-SHA-512" mechanism.</p> </li>
        /// <li> <p> <code>KAFKA_SASL_SCRAM_PASSWORD</code> - A plaintext password used to authenticate with the "SCRAM-SHA-512" mechanism.</p> </li>
        /// <li> <p> <code>ENCRYPTED_KAFKA_SASL_SCRAM_PASSWORD</code> - The encrypted version of the Kafka SASL SCRAM password (if the user has the Glue encrypt passwords setting selected).</p> </li>
        /// <li> <p> <code>KAFKA_SASL_GSSAPI_KEYTAB</code> - The S3 location of a Kerberos <code>keytab</code> file. A keytab stores long-term keys for one or more principals. For more information, see <a href="https://web.mit.edu/kerberos/krb5-latest/doc/basic/keytab_def.html">MIT Kerberos Documentation: Keytab</a>.</p> </li>
        /// <li> <p> <code>KAFKA_SASL_GSSAPI_KRB5_CONF</code> - The S3 location of a Kerberos <code>krb5.conf</code> file. A krb5.conf stores Kerberos configuration information, such as the location of the KDC server. For more information, see <a href="https://web.mit.edu/kerberos/krb5-1.12/doc/admin/conf_files/krb5_conf.html">MIT Kerberos Documentation: krb5.conf</a>.</p> </li>
        /// <li> <p> <code>KAFKA_SASL_GSSAPI_SERVICE</code> - The Kerberos service name, as set with <code>sasl.kerberos.service.name</code> in your <a href="https://kafka.apache.org/documentation/#brokerconfigs_sasl.kerberos.service.name">Kafka Configuration</a>.</p> </li>
        /// <li> <p> <code>KAFKA_SASL_GSSAPI_PRINCIPAL</code> - The name of the Kerberos princial used by Glue. For more information, see <a href="https://kafka.apache.org/documentation/#security_sasl_kerberos_clientconfig">Kafka Documentation: Configuring Kafka Brokers</a>.</p> </li>
        /// </ul>
        pub fn connection_properties(
            mut self,
            k: crate::model::ConnectionPropertyKey,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.connection_properties.unwrap_or_default();
            hash_map.insert(k, v.into());
            self.connection_properties = Some(hash_map);
            self
        }
        /// <p>These key-value pairs define parameters for the connection:</p>
        /// <ul>
        /// <li> <p> <code>HOST</code> - The host URI: either the fully qualified domain name (FQDN) or the IPv4 address of the database host.</p> </li>
        /// <li> <p> <code>PORT</code> - The port number, between 1024 and 65535, of the port on which the database host is listening for database connections.</p> </li>
        /// <li> <p> <code>USER_NAME</code> - The name under which to log in to the database. The value string for <code>USER_NAME</code> is "<code>USERNAME</code>".</p> </li>
        /// <li> <p> <code>PASSWORD</code> - A password, if one is used, for the user name.</p> </li>
        /// <li> <p> <code>ENCRYPTED_PASSWORD</code> - When you enable connection password protection by setting <code>ConnectionPasswordEncryption</code> in the Data Catalog encryption settings, this field stores the encrypted password.</p> </li>
        /// <li> <p> <code>JDBC_DRIVER_JAR_URI</code> - The Amazon Simple Storage Service (Amazon S3) path of the JAR file that contains the JDBC driver to use.</p> </li>
        /// <li> <p> <code>JDBC_DRIVER_CLASS_NAME</code> - The class name of the JDBC driver to use.</p> </li>
        /// <li> <p> <code>JDBC_ENGINE</code> - The name of the JDBC engine to use.</p> </li>
        /// <li> <p> <code>JDBC_ENGINE_VERSION</code> - The version of the JDBC engine to use.</p> </li>
        /// <li> <p> <code>CONFIG_FILES</code> - (Reserved for future use.)</p> </li>
        /// <li> <p> <code>INSTANCE_ID</code> - The instance ID to use.</p> </li>
        /// <li> <p> <code>JDBC_CONNECTION_URL</code> - The URL for connecting to a JDBC data source.</p> </li>
        /// <li> <p> <code>JDBC_ENFORCE_SSL</code> - A Boolean string (true, false) specifying whether Secure Sockets Layer (SSL) with hostname matching is enforced for the JDBC connection on the client. The default is false.</p> </li>
        /// <li> <p> <code>CUSTOM_JDBC_CERT</code> - An Amazon S3 location specifying the customer's root certificate. Glue uses this root certificate to validate the customer’s certificate when connecting to the customer database. Glue only handles X.509 certificates. The certificate provided must be DER-encoded and supplied in Base64 encoding PEM format.</p> </li>
        /// <li> <p> <code>SKIP_CUSTOM_JDBC_CERT_VALIDATION</code> - By default, this is <code>false</code>. Glue validates the Signature algorithm and Subject Public Key Algorithm for the customer certificate. The only permitted algorithms for the Signature algorithm are SHA256withRSA, SHA384withRSA or SHA512withRSA. For the Subject Public Key Algorithm, the key length must be at least 2048. You can set the value of this property to <code>true</code> to skip Glue’s validation of the customer certificate.</p> </li>
        /// <li> <p> <code>CUSTOM_JDBC_CERT_STRING</code> - A custom JDBC certificate string which is used for domain match or distinguished name match to prevent a man-in-the-middle attack. In Oracle database, this is used as the <code>SSL_SERVER_CERT_DN</code>; in Microsoft SQL Server, this is used as the <code>hostNameInCertificate</code>.</p> </li>
        /// <li> <p> <code>CONNECTION_URL</code> - The URL for connecting to a general (non-JDBC) data source.</p> </li>
        /// <li> <p> <code>SECRET_ID</code> - The secret ID used for the secret manager of credentials.</p> </li>
        /// <li> <p> <code>CONNECTOR_URL</code> - The connector URL for a MARKETPLACE or CUSTOM connection.</p> </li>
        /// <li> <p> <code>CONNECTOR_TYPE</code> - The connector type for a MARKETPLACE or CUSTOM connection.</p> </li>
        /// <li> <p> <code>CONNECTOR_CLASS_NAME</code> - The connector class name for a MARKETPLACE or CUSTOM connection.</p> </li>
        /// <li> <p> <code>KAFKA_BOOTSTRAP_SERVERS</code> - A comma-separated list of host and port pairs that are the addresses of the Apache Kafka brokers in a Kafka cluster to which a Kafka client will connect to and bootstrap itself.</p> </li>
        /// <li> <p> <code>KAFKA_SSL_ENABLED</code> - Whether to enable or disable SSL on an Apache Kafka connection. Default value is "true".</p> </li>
        /// <li> <p> <code>KAFKA_CUSTOM_CERT</code> - The Amazon S3 URL for the private CA cert file (.pem format). The default is an empty string.</p> </li>
        /// <li> <p> <code>KAFKA_SKIP_CUSTOM_CERT_VALIDATION</code> - Whether to skip the validation of the CA cert file or not. Glue validates for three algorithms: SHA256withRSA, SHA384withRSA and SHA512withRSA. Default value is "false".</p> </li>
        /// <li> <p> <code>KAFKA_CLIENT_KEYSTORE</code> - The Amazon S3 location of the client keystore file for Kafka client side authentication (Optional).</p> </li>
        /// <li> <p> <code>KAFKA_CLIENT_KEYSTORE_PASSWORD</code> - The password to access the provided keystore (Optional).</p> </li>
        /// <li> <p> <code>KAFKA_CLIENT_KEY_PASSWORD</code> - A keystore can consist of multiple keys, so this is the password to access the client key to be used with the Kafka server side key (Optional).</p> </li>
        /// <li> <p> <code>ENCRYPTED_KAFKA_CLIENT_KEYSTORE_PASSWORD</code> - The encrypted version of the Kafka client keystore password (if the user has the Glue encrypt passwords setting selected).</p> </li>
        /// <li> <p> <code>ENCRYPTED_KAFKA_CLIENT_KEY_PASSWORD</code> - The encrypted version of the Kafka client key password (if the user has the Glue encrypt passwords setting selected).</p> </li>
        /// <li> <p> <code>KAFKA_SASL_MECHANISM</code> - <code>"SCRAM-SHA-512"</code> or <code>"GSSAPI"</code>. These are the two supported <a href="https://www.iana.org/assignments/sasl-mechanisms/sasl-mechanisms.xhtml">SASL Mechanisms</a>.</p> </li>
        /// <li> <p> <code>KAFKA_SASL_SCRAM_USERNAME</code> - A plaintext username used to authenticate with the "SCRAM-SHA-512" mechanism.</p> </li>
        /// <li> <p> <code>KAFKA_SASL_SCRAM_PASSWORD</code> - A plaintext password used to authenticate with the "SCRAM-SHA-512" mechanism.</p> </li>
        /// <li> <p> <code>ENCRYPTED_KAFKA_SASL_SCRAM_PASSWORD</code> - The encrypted version of the Kafka SASL SCRAM password (if the user has the Glue encrypt passwords setting selected).</p> </li>
        /// <li> <p> <code>KAFKA_SASL_GSSAPI_KEYTAB</code> - The S3 location of a Kerberos <code>keytab</code> file. A keytab stores long-term keys for one or more principals. For more information, see <a href="https://web.mit.edu/kerberos/krb5-latest/doc/basic/keytab_def.html">MIT Kerberos Documentation: Keytab</a>.</p> </li>
        /// <li> <p> <code>KAFKA_SASL_GSSAPI_KRB5_CONF</code> - The S3 location of a Kerberos <code>krb5.conf</code> file. A krb5.conf stores Kerberos configuration information, such as the location of the KDC server. For more information, see <a href="https://web.mit.edu/kerberos/krb5-1.12/doc/admin/conf_files/krb5_conf.html">MIT Kerberos Documentation: krb5.conf</a>.</p> </li>
        /// <li> <p> <code>KAFKA_SASL_GSSAPI_SERVICE</code> - The Kerberos service name, as set with <code>sasl.kerberos.service.name</code> in your <a href="https://kafka.apache.org/documentation/#brokerconfigs_sasl.kerberos.service.name">Kafka Configuration</a>.</p> </li>
        /// <li> <p> <code>KAFKA_SASL_GSSAPI_PRINCIPAL</code> - The name of the Kerberos princial used by Glue. For more information, see <a href="https://kafka.apache.org/documentation/#security_sasl_kerberos_clientconfig">Kafka Documentation: Configuring Kafka Brokers</a>.</p> </li>
        /// </ul>
        pub fn set_connection_properties(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<crate::model::ConnectionPropertyKey, std::string::String>,
            >,
        ) -> Self {
            self.connection_properties = input;
            self
        }
        /// <p>A map of physical connection requirements, such as virtual private cloud (VPC) and <code>SecurityGroup</code>, that are needed to make this connection successfully.</p>
        pub fn physical_connection_requirements(
            mut self,
            input: crate::model::PhysicalConnectionRequirements,
        ) -> Self {
            self.physical_connection_requirements = Some(input);
            self
        }
        /// <p>A map of physical connection requirements, such as virtual private cloud (VPC) and <code>SecurityGroup</code>, that are needed to make this connection successfully.</p>
        pub fn set_physical_connection_requirements(
            mut self,
            input: std::option::Option<crate::model::PhysicalConnectionRequirements>,
        ) -> Self {
            self.physical_connection_requirements = input;
            self
        }
        /// <p>The time that this connection definition was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>The time that this connection definition was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>The last time that this connection definition was updated.</p>
        pub fn last_updated_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_updated_time = Some(input);
            self
        }
        /// <p>The last time that this connection definition was updated.</p>
        pub fn set_last_updated_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_updated_time = input;
            self
        }
        /// <p>The user, group, or role that last updated this connection definition.</p>
        pub fn last_updated_by(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_updated_by = Some(input.into());
            self
        }
        /// <p>The user, group, or role that last updated this connection definition.</p>
        pub fn set_last_updated_by(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.last_updated_by = input;
            self
        }
        /// Consumes the builder and constructs a [`Connection`](crate::model::Connection).
        pub fn build(self) -> crate::model::Connection {
            crate::model::Connection {
                name: self.name,
                description: self.description,
                connection_type: self.connection_type,
                match_criteria: self.match_criteria,
                connection_properties: self.connection_properties,
                physical_connection_requirements: self.physical_connection_requirements,
                creation_time: self.creation_time,
                last_updated_time: self.last_updated_time,
                last_updated_by: self.last_updated_by,
            }
        }
    }
}
impl Connection {
    /// Creates a new builder-style object to manufacture [`Connection`](crate::model::Connection).
    pub fn builder() -> crate::model::connection::Builder {
        crate::model::connection::Builder::default()
    }
}

/// <p>Filters the connection definitions that are returned by the <code>GetConnections</code> API operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetConnectionsFilter {
    /// <p>A criteria string that must match the criteria recorded in the connection definition for that connection definition to be returned.</p>
    #[doc(hidden)]
    pub match_criteria: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The type of connections to return. Currently, SFTP is not supported.</p>
    #[doc(hidden)]
    pub connection_type: std::option::Option<crate::model::ConnectionType>,
}
impl GetConnectionsFilter {
    /// <p>A criteria string that must match the criteria recorded in the connection definition for that connection definition to be returned.</p>
    pub fn match_criteria(&self) -> std::option::Option<&[std::string::String]> {
        self.match_criteria.as_deref()
    }
    /// <p>The type of connections to return. Currently, SFTP is not supported.</p>
    pub fn connection_type(&self) -> std::option::Option<&crate::model::ConnectionType> {
        self.connection_type.as_ref()
    }
}
/// See [`GetConnectionsFilter`](crate::model::GetConnectionsFilter).
pub mod get_connections_filter {

    /// A builder for [`GetConnectionsFilter`](crate::model::GetConnectionsFilter).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) match_criteria: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) connection_type: std::option::Option<crate::model::ConnectionType>,
    }
    impl Builder {
        /// Appends an item to `match_criteria`.
        ///
        /// To override the contents of this collection use [`set_match_criteria`](Self::set_match_criteria).
        ///
        /// <p>A criteria string that must match the criteria recorded in the connection definition for that connection definition to be returned.</p>
        pub fn match_criteria(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.match_criteria.unwrap_or_default();
            v.push(input.into());
            self.match_criteria = Some(v);
            self
        }
        /// <p>A criteria string that must match the criteria recorded in the connection definition for that connection definition to be returned.</p>
        pub fn set_match_criteria(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.match_criteria = input;
            self
        }
        /// <p>The type of connections to return. Currently, SFTP is not supported.</p>
        pub fn connection_type(mut self, input: crate::model::ConnectionType) -> Self {
            self.connection_type = Some(input);
            self
        }
        /// <p>The type of connections to return. Currently, SFTP is not supported.</p>
        pub fn set_connection_type(
            mut self,
            input: std::option::Option<crate::model::ConnectionType>,
        ) -> Self {
            self.connection_type = input;
            self
        }
        /// Consumes the builder and constructs a [`GetConnectionsFilter`](crate::model::GetConnectionsFilter).
        pub fn build(self) -> crate::model::GetConnectionsFilter {
            crate::model::GetConnectionsFilter {
                match_criteria: self.match_criteria,
                connection_type: self.connection_type,
            }
        }
    }
}
impl GetConnectionsFilter {
    /// Creates a new builder-style object to manufacture [`GetConnectionsFilter`](crate::model::GetConnectionsFilter).
    pub fn builder() -> crate::model::get_connections_filter::Builder {
        crate::model::get_connections_filter::Builder::default()
    }
}

/// <p>Encapsulates a column name that failed and the reason for failure.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ColumnError {
    /// <p>The name of the column that failed.</p>
    #[doc(hidden)]
    pub column_name: std::option::Option<std::string::String>,
    /// <p>An error message with the reason for the failure of an operation.</p>
    #[doc(hidden)]
    pub error: std::option::Option<crate::model::ErrorDetail>,
}
impl ColumnError {
    /// <p>The name of the column that failed.</p>
    pub fn column_name(&self) -> std::option::Option<&str> {
        self.column_name.as_deref()
    }
    /// <p>An error message with the reason for the failure of an operation.</p>
    pub fn error(&self) -> std::option::Option<&crate::model::ErrorDetail> {
        self.error.as_ref()
    }
}
/// See [`ColumnError`](crate::model::ColumnError).
pub mod column_error {

    /// A builder for [`ColumnError`](crate::model::ColumnError).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) column_name: std::option::Option<std::string::String>,
        pub(crate) error: std::option::Option<crate::model::ErrorDetail>,
    }
    impl Builder {
        /// <p>The name of the column that failed.</p>
        pub fn column_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.column_name = Some(input.into());
            self
        }
        /// <p>The name of the column that failed.</p>
        pub fn set_column_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.column_name = input;
            self
        }
        /// <p>An error message with the reason for the failure of an operation.</p>
        pub fn error(mut self, input: crate::model::ErrorDetail) -> Self {
            self.error = Some(input);
            self
        }
        /// <p>An error message with the reason for the failure of an operation.</p>
        pub fn set_error(mut self, input: std::option::Option<crate::model::ErrorDetail>) -> Self {
            self.error = input;
            self
        }
        /// Consumes the builder and constructs a [`ColumnError`](crate::model::ColumnError).
        pub fn build(self) -> crate::model::ColumnError {
            crate::model::ColumnError {
                column_name: self.column_name,
                error: self.error,
            }
        }
    }
}
impl ColumnError {
    /// Creates a new builder-style object to manufacture [`ColumnError`](crate::model::ColumnError).
    pub fn builder() -> crate::model::column_error::Builder {
        crate::model::column_error::Builder::default()
    }
}

/// <p>Classifiers are triggered during a crawl task. A classifier checks whether a given file is in a format it can handle. If it is, the classifier creates a schema in the form of a <code>StructType</code> object that matches that data format.</p>
/// <p>You can use the standard classifiers that Glue provides, or you can write your own classifiers to best categorize your data sources and specify the appropriate schemas to use for them. A classifier can be a <code>grok</code> classifier, an <code>XML</code> classifier, a <code>JSON</code> classifier, or a custom <code>CSV</code> classifier, as specified in one of the fields in the <code>Classifier</code> object.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Classifier {
    /// <p>A classifier that uses <code>grok</code>.</p>
    #[doc(hidden)]
    pub grok_classifier: std::option::Option<crate::model::GrokClassifier>,
    /// <p>A classifier for XML content.</p>
    #[doc(hidden)]
    pub xml_classifier: std::option::Option<crate::model::XmlClassifier>,
    /// <p>A classifier for JSON content.</p>
    #[doc(hidden)]
    pub json_classifier: std::option::Option<crate::model::JsonClassifier>,
    /// <p>A classifier for comma-separated values (CSV).</p>
    #[doc(hidden)]
    pub csv_classifier: std::option::Option<crate::model::CsvClassifier>,
}
impl Classifier {
    /// <p>A classifier that uses <code>grok</code>.</p>
    pub fn grok_classifier(&self) -> std::option::Option<&crate::model::GrokClassifier> {
        self.grok_classifier.as_ref()
    }
    /// <p>A classifier for XML content.</p>
    pub fn xml_classifier(&self) -> std::option::Option<&crate::model::XmlClassifier> {
        self.xml_classifier.as_ref()
    }
    /// <p>A classifier for JSON content.</p>
    pub fn json_classifier(&self) -> std::option::Option<&crate::model::JsonClassifier> {
        self.json_classifier.as_ref()
    }
    /// <p>A classifier for comma-separated values (CSV).</p>
    pub fn csv_classifier(&self) -> std::option::Option<&crate::model::CsvClassifier> {
        self.csv_classifier.as_ref()
    }
}
/// See [`Classifier`](crate::model::Classifier).
pub mod classifier {

    /// A builder for [`Classifier`](crate::model::Classifier).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) grok_classifier: std::option::Option<crate::model::GrokClassifier>,
        pub(crate) xml_classifier: std::option::Option<crate::model::XmlClassifier>,
        pub(crate) json_classifier: std::option::Option<crate::model::JsonClassifier>,
        pub(crate) csv_classifier: std::option::Option<crate::model::CsvClassifier>,
    }
    impl Builder {
        /// <p>A classifier that uses <code>grok</code>.</p>
        pub fn grok_classifier(mut self, input: crate::model::GrokClassifier) -> Self {
            self.grok_classifier = Some(input);
            self
        }
        /// <p>A classifier that uses <code>grok</code>.</p>
        pub fn set_grok_classifier(
            mut self,
            input: std::option::Option<crate::model::GrokClassifier>,
        ) -> Self {
            self.grok_classifier = input;
            self
        }
        /// <p>A classifier for XML content.</p>
        pub fn xml_classifier(mut self, input: crate::model::XmlClassifier) -> Self {
            self.xml_classifier = Some(input);
            self
        }
        /// <p>A classifier for XML content.</p>
        pub fn set_xml_classifier(
            mut self,
            input: std::option::Option<crate::model::XmlClassifier>,
        ) -> Self {
            self.xml_classifier = input;
            self
        }
        /// <p>A classifier for JSON content.</p>
        pub fn json_classifier(mut self, input: crate::model::JsonClassifier) -> Self {
            self.json_classifier = Some(input);
            self
        }
        /// <p>A classifier for JSON content.</p>
        pub fn set_json_classifier(
            mut self,
            input: std::option::Option<crate::model::JsonClassifier>,
        ) -> Self {
            self.json_classifier = input;
            self
        }
        /// <p>A classifier for comma-separated values (CSV).</p>
        pub fn csv_classifier(mut self, input: crate::model::CsvClassifier) -> Self {
            self.csv_classifier = Some(input);
            self
        }
        /// <p>A classifier for comma-separated values (CSV).</p>
        pub fn set_csv_classifier(
            mut self,
            input: std::option::Option<crate::model::CsvClassifier>,
        ) -> Self {
            self.csv_classifier = input;
            self
        }
        /// Consumes the builder and constructs a [`Classifier`](crate::model::Classifier).
        pub fn build(self) -> crate::model::Classifier {
            crate::model::Classifier {
                grok_classifier: self.grok_classifier,
                xml_classifier: self.xml_classifier,
                json_classifier: self.json_classifier,
                csv_classifier: self.csv_classifier,
            }
        }
    }
}
impl Classifier {
    /// Creates a new builder-style object to manufacture [`Classifier`](crate::model::Classifier).
    pub fn builder() -> crate::model::classifier::Builder {
        crate::model::classifier::Builder::default()
    }
}

/// <p>A classifier for custom <code>CSV</code> content.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CsvClassifier {
    /// <p>The name of the classifier.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The time that this classifier was registered.</p>
    #[doc(hidden)]
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The time that this classifier was last updated.</p>
    #[doc(hidden)]
    pub last_updated: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The version of this classifier.</p>
    #[doc(hidden)]
    pub version: i64,
    /// <p>A custom symbol to denote what separates each column entry in the row.</p>
    #[doc(hidden)]
    pub delimiter: std::option::Option<std::string::String>,
    /// <p>A custom symbol to denote what combines content into a single column value. It must be different from the column delimiter.</p>
    #[doc(hidden)]
    pub quote_symbol: std::option::Option<std::string::String>,
    /// <p>Indicates whether the CSV file contains a header.</p>
    #[doc(hidden)]
    pub contains_header: std::option::Option<crate::model::CsvHeaderOption>,
    /// <p>A list of strings representing column names.</p>
    #[doc(hidden)]
    pub header: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Specifies not to trim values before identifying the type of column values. The default value is <code>true</code>.</p>
    #[doc(hidden)]
    pub disable_value_trimming: std::option::Option<bool>,
    /// <p>Enables the processing of files that contain only one column.</p>
    #[doc(hidden)]
    pub allow_single_column: std::option::Option<bool>,
    /// <p>Enables the custom datatype to be configured.</p>
    #[doc(hidden)]
    pub custom_datatype_configured: std::option::Option<bool>,
    /// <p>A list of custom datatypes including "BINARY", "BOOLEAN", "DATE", "DECIMAL", "DOUBLE", "FLOAT", "INT", "LONG", "SHORT", "STRING", "TIMESTAMP".</p>
    #[doc(hidden)]
    pub custom_datatypes: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl CsvClassifier {
    /// <p>The name of the classifier.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The time that this classifier was registered.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>The time that this classifier was last updated.</p>
    pub fn last_updated(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_updated.as_ref()
    }
    /// <p>The version of this classifier.</p>
    pub fn version(&self) -> i64 {
        self.version
    }
    /// <p>A custom symbol to denote what separates each column entry in the row.</p>
    pub fn delimiter(&self) -> std::option::Option<&str> {
        self.delimiter.as_deref()
    }
    /// <p>A custom symbol to denote what combines content into a single column value. It must be different from the column delimiter.</p>
    pub fn quote_symbol(&self) -> std::option::Option<&str> {
        self.quote_symbol.as_deref()
    }
    /// <p>Indicates whether the CSV file contains a header.</p>
    pub fn contains_header(&self) -> std::option::Option<&crate::model::CsvHeaderOption> {
        self.contains_header.as_ref()
    }
    /// <p>A list of strings representing column names.</p>
    pub fn header(&self) -> std::option::Option<&[std::string::String]> {
        self.header.as_deref()
    }
    /// <p>Specifies not to trim values before identifying the type of column values. The default value is <code>true</code>.</p>
    pub fn disable_value_trimming(&self) -> std::option::Option<bool> {
        self.disable_value_trimming
    }
    /// <p>Enables the processing of files that contain only one column.</p>
    pub fn allow_single_column(&self) -> std::option::Option<bool> {
        self.allow_single_column
    }
    /// <p>Enables the custom datatype to be configured.</p>
    pub fn custom_datatype_configured(&self) -> std::option::Option<bool> {
        self.custom_datatype_configured
    }
    /// <p>A list of custom datatypes including "BINARY", "BOOLEAN", "DATE", "DECIMAL", "DOUBLE", "FLOAT", "INT", "LONG", "SHORT", "STRING", "TIMESTAMP".</p>
    pub fn custom_datatypes(&self) -> std::option::Option<&[std::string::String]> {
        self.custom_datatypes.as_deref()
    }
}
/// See [`CsvClassifier`](crate::model::CsvClassifier).
pub mod csv_classifier {

    /// A builder for [`CsvClassifier`](crate::model::CsvClassifier).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_updated: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) version: std::option::Option<i64>,
        pub(crate) delimiter: std::option::Option<std::string::String>,
        pub(crate) quote_symbol: std::option::Option<std::string::String>,
        pub(crate) contains_header: std::option::Option<crate::model::CsvHeaderOption>,
        pub(crate) header: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) disable_value_trimming: std::option::Option<bool>,
        pub(crate) allow_single_column: std::option::Option<bool>,
        pub(crate) custom_datatype_configured: std::option::Option<bool>,
        pub(crate) custom_datatypes: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The name of the classifier.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the classifier.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The time that this classifier was registered.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>The time that this classifier was registered.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>The time that this classifier was last updated.</p>
        pub fn last_updated(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_updated = Some(input);
            self
        }
        /// <p>The time that this classifier was last updated.</p>
        pub fn set_last_updated(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_updated = input;
            self
        }
        /// <p>The version of this classifier.</p>
        pub fn version(mut self, input: i64) -> Self {
            self.version = Some(input);
            self
        }
        /// <p>The version of this classifier.</p>
        pub fn set_version(mut self, input: std::option::Option<i64>) -> Self {
            self.version = input;
            self
        }
        /// <p>A custom symbol to denote what separates each column entry in the row.</p>
        pub fn delimiter(mut self, input: impl Into<std::string::String>) -> Self {
            self.delimiter = Some(input.into());
            self
        }
        /// <p>A custom symbol to denote what separates each column entry in the row.</p>
        pub fn set_delimiter(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.delimiter = input;
            self
        }
        /// <p>A custom symbol to denote what combines content into a single column value. It must be different from the column delimiter.</p>
        pub fn quote_symbol(mut self, input: impl Into<std::string::String>) -> Self {
            self.quote_symbol = Some(input.into());
            self
        }
        /// <p>A custom symbol to denote what combines content into a single column value. It must be different from the column delimiter.</p>
        pub fn set_quote_symbol(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.quote_symbol = input;
            self
        }
        /// <p>Indicates whether the CSV file contains a header.</p>
        pub fn contains_header(mut self, input: crate::model::CsvHeaderOption) -> Self {
            self.contains_header = Some(input);
            self
        }
        /// <p>Indicates whether the CSV file contains a header.</p>
        pub fn set_contains_header(
            mut self,
            input: std::option::Option<crate::model::CsvHeaderOption>,
        ) -> Self {
            self.contains_header = input;
            self
        }
        /// Appends an item to `header`.
        ///
        /// To override the contents of this collection use [`set_header`](Self::set_header).
        ///
        /// <p>A list of strings representing column names.</p>
        pub fn header(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.header.unwrap_or_default();
            v.push(input.into());
            self.header = Some(v);
            self
        }
        /// <p>A list of strings representing column names.</p>
        pub fn set_header(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.header = input;
            self
        }
        /// <p>Specifies not to trim values before identifying the type of column values. The default value is <code>true</code>.</p>
        pub fn disable_value_trimming(mut self, input: bool) -> Self {
            self.disable_value_trimming = Some(input);
            self
        }
        /// <p>Specifies not to trim values before identifying the type of column values. The default value is <code>true</code>.</p>
        pub fn set_disable_value_trimming(mut self, input: std::option::Option<bool>) -> Self {
            self.disable_value_trimming = input;
            self
        }
        /// <p>Enables the processing of files that contain only one column.</p>
        pub fn allow_single_column(mut self, input: bool) -> Self {
            self.allow_single_column = Some(input);
            self
        }
        /// <p>Enables the processing of files that contain only one column.</p>
        pub fn set_allow_single_column(mut self, input: std::option::Option<bool>) -> Self {
            self.allow_single_column = input;
            self
        }
        /// <p>Enables the custom datatype to be configured.</p>
        pub fn custom_datatype_configured(mut self, input: bool) -> Self {
            self.custom_datatype_configured = Some(input);
            self
        }
        /// <p>Enables the custom datatype to be configured.</p>
        pub fn set_custom_datatype_configured(mut self, input: std::option::Option<bool>) -> Self {
            self.custom_datatype_configured = input;
            self
        }
        /// Appends an item to `custom_datatypes`.
        ///
        /// To override the contents of this collection use [`set_custom_datatypes`](Self::set_custom_datatypes).
        ///
        /// <p>A list of custom datatypes including "BINARY", "BOOLEAN", "DATE", "DECIMAL", "DOUBLE", "FLOAT", "INT", "LONG", "SHORT", "STRING", "TIMESTAMP".</p>
        pub fn custom_datatypes(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.custom_datatypes.unwrap_or_default();
            v.push(input.into());
            self.custom_datatypes = Some(v);
            self
        }
        /// <p>A list of custom datatypes including "BINARY", "BOOLEAN", "DATE", "DECIMAL", "DOUBLE", "FLOAT", "INT", "LONG", "SHORT", "STRING", "TIMESTAMP".</p>
        pub fn set_custom_datatypes(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.custom_datatypes = input;
            self
        }
        /// Consumes the builder and constructs a [`CsvClassifier`](crate::model::CsvClassifier).
        pub fn build(self) -> crate::model::CsvClassifier {
            crate::model::CsvClassifier {
                name: self.name,
                creation_time: self.creation_time,
                last_updated: self.last_updated,
                version: self.version.unwrap_or_default(),
                delimiter: self.delimiter,
                quote_symbol: self.quote_symbol,
                contains_header: self.contains_header,
                header: self.header,
                disable_value_trimming: self.disable_value_trimming,
                allow_single_column: self.allow_single_column,
                custom_datatype_configured: self.custom_datatype_configured,
                custom_datatypes: self.custom_datatypes,
            }
        }
    }
}
impl CsvClassifier {
    /// Creates a new builder-style object to manufacture [`CsvClassifier`](crate::model::CsvClassifier).
    pub fn builder() -> crate::model::csv_classifier::Builder {
        crate::model::csv_classifier::Builder::default()
    }
}

/// <p>A classifier for <code>JSON</code> content.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct JsonClassifier {
    /// <p>The name of the classifier.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The time that this classifier was registered.</p>
    #[doc(hidden)]
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The time that this classifier was last updated.</p>
    #[doc(hidden)]
    pub last_updated: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The version of this classifier.</p>
    #[doc(hidden)]
    pub version: i64,
    /// <p>A <code>JsonPath</code> string defining the JSON data for the classifier to classify. Glue supports a subset of JsonPath, as described in <a href="https://docs.aws.amazon.com/glue/latest/dg/custom-classifier.html#custom-classifier-json">Writing JsonPath Custom Classifiers</a>.</p>
    #[doc(hidden)]
    pub json_path: std::option::Option<std::string::String>,
}
impl JsonClassifier {
    /// <p>The name of the classifier.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The time that this classifier was registered.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>The time that this classifier was last updated.</p>
    pub fn last_updated(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_updated.as_ref()
    }
    /// <p>The version of this classifier.</p>
    pub fn version(&self) -> i64 {
        self.version
    }
    /// <p>A <code>JsonPath</code> string defining the JSON data for the classifier to classify. Glue supports a subset of JsonPath, as described in <a href="https://docs.aws.amazon.com/glue/latest/dg/custom-classifier.html#custom-classifier-json">Writing JsonPath Custom Classifiers</a>.</p>
    pub fn json_path(&self) -> std::option::Option<&str> {
        self.json_path.as_deref()
    }
}
/// See [`JsonClassifier`](crate::model::JsonClassifier).
pub mod json_classifier {

    /// A builder for [`JsonClassifier`](crate::model::JsonClassifier).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_updated: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) version: std::option::Option<i64>,
        pub(crate) json_path: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the classifier.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the classifier.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The time that this classifier was registered.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>The time that this classifier was registered.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>The time that this classifier was last updated.</p>
        pub fn last_updated(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_updated = Some(input);
            self
        }
        /// <p>The time that this classifier was last updated.</p>
        pub fn set_last_updated(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_updated = input;
            self
        }
        /// <p>The version of this classifier.</p>
        pub fn version(mut self, input: i64) -> Self {
            self.version = Some(input);
            self
        }
        /// <p>The version of this classifier.</p>
        pub fn set_version(mut self, input: std::option::Option<i64>) -> Self {
            self.version = input;
            self
        }
        /// <p>A <code>JsonPath</code> string defining the JSON data for the classifier to classify. Glue supports a subset of JsonPath, as described in <a href="https://docs.aws.amazon.com/glue/latest/dg/custom-classifier.html#custom-classifier-json">Writing JsonPath Custom Classifiers</a>.</p>
        pub fn json_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.json_path = Some(input.into());
            self
        }
        /// <p>A <code>JsonPath</code> string defining the JSON data for the classifier to classify. Glue supports a subset of JsonPath, as described in <a href="https://docs.aws.amazon.com/glue/latest/dg/custom-classifier.html#custom-classifier-json">Writing JsonPath Custom Classifiers</a>.</p>
        pub fn set_json_path(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.json_path = input;
            self
        }
        /// Consumes the builder and constructs a [`JsonClassifier`](crate::model::JsonClassifier).
        pub fn build(self) -> crate::model::JsonClassifier {
            crate::model::JsonClassifier {
                name: self.name,
                creation_time: self.creation_time,
                last_updated: self.last_updated,
                version: self.version.unwrap_or_default(),
                json_path: self.json_path,
            }
        }
    }
}
impl JsonClassifier {
    /// Creates a new builder-style object to manufacture [`JsonClassifier`](crate::model::JsonClassifier).
    pub fn builder() -> crate::model::json_classifier::Builder {
        crate::model::json_classifier::Builder::default()
    }
}

/// <p>A classifier for <code>XML</code> content.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct XmlClassifier {
    /// <p>The name of the classifier.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>An identifier of the data format that the classifier matches.</p>
    #[doc(hidden)]
    pub classification: std::option::Option<std::string::String>,
    /// <p>The time that this classifier was registered.</p>
    #[doc(hidden)]
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The time that this classifier was last updated.</p>
    #[doc(hidden)]
    pub last_updated: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The version of this classifier.</p>
    #[doc(hidden)]
    pub version: i64,
    /// <p>The XML tag designating the element that contains each record in an XML document being parsed. This can't identify a self-closing element (closed by <code>/&gt;</code>). An empty row element that contains only attributes can be parsed as long as it ends with a closing tag (for example, <code>
    /// <row item_a="A" item_b="B" /></code> is okay, but <code>
    /// <row item_a="A" item_b="B" /></code> is not).</p>
    #[doc(hidden)]
    pub row_tag: std::option::Option<std::string::String>,
}
impl XmlClassifier {
    /// <p>The name of the classifier.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>An identifier of the data format that the classifier matches.</p>
    pub fn classification(&self) -> std::option::Option<&str> {
        self.classification.as_deref()
    }
    /// <p>The time that this classifier was registered.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>The time that this classifier was last updated.</p>
    pub fn last_updated(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_updated.as_ref()
    }
    /// <p>The version of this classifier.</p>
    pub fn version(&self) -> i64 {
        self.version
    }
    /// <p>The XML tag designating the element that contains each record in an XML document being parsed. This can't identify a self-closing element (closed by <code>/&gt;</code>). An empty row element that contains only attributes can be parsed as long as it ends with a closing tag (for example, <code>
    /// <row item_a="A" item_b="B" /></code> is okay, but <code>
    /// <row item_a="A" item_b="B" /></code> is not).</p>
    pub fn row_tag(&self) -> std::option::Option<&str> {
        self.row_tag.as_deref()
    }
}
/// See [`XmlClassifier`](crate::model::XmlClassifier).
pub mod xml_classifier {

    /// A builder for [`XmlClassifier`](crate::model::XmlClassifier).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) classification: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_updated: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) version: std::option::Option<i64>,
        pub(crate) row_tag: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the classifier.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the classifier.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>An identifier of the data format that the classifier matches.</p>
        pub fn classification(mut self, input: impl Into<std::string::String>) -> Self {
            self.classification = Some(input.into());
            self
        }
        /// <p>An identifier of the data format that the classifier matches.</p>
        pub fn set_classification(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.classification = input;
            self
        }
        /// <p>The time that this classifier was registered.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>The time that this classifier was registered.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>The time that this classifier was last updated.</p>
        pub fn last_updated(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_updated = Some(input);
            self
        }
        /// <p>The time that this classifier was last updated.</p>
        pub fn set_last_updated(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_updated = input;
            self
        }
        /// <p>The version of this classifier.</p>
        pub fn version(mut self, input: i64) -> Self {
            self.version = Some(input);
            self
        }
        /// <p>The version of this classifier.</p>
        pub fn set_version(mut self, input: std::option::Option<i64>) -> Self {
            self.version = input;
            self
        }
        /// <p>The XML tag designating the element that contains each record in an XML document being parsed. This can't identify a self-closing element (closed by <code>/&gt;</code>). An empty row element that contains only attributes can be parsed as long as it ends with a closing tag (for example, <code>
        /// <row item_a="A" item_b="B" /></code> is okay, but <code>
        /// <row item_a="A" item_b="B" /></code> is not).</p>
        pub fn row_tag(mut self, input: impl Into<std::string::String>) -> Self {
            self.row_tag = Some(input.into());
            self
        }
        /// <p>The XML tag designating the element that contains each record in an XML document being parsed. This can't identify a self-closing element (closed by <code>/&gt;</code>). An empty row element that contains only attributes can be parsed as long as it ends with a closing tag (for example, <code>
        /// <row item_a="A" item_b="B" /></code> is okay, but <code>
        /// <row item_a="A" item_b="B" /></code> is not).</p>
        pub fn set_row_tag(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.row_tag = input;
            self
        }
        /// Consumes the builder and constructs a [`XmlClassifier`](crate::model::XmlClassifier).
        pub fn build(self) -> crate::model::XmlClassifier {
            crate::model::XmlClassifier {
                name: self.name,
                classification: self.classification,
                creation_time: self.creation_time,
                last_updated: self.last_updated,
                version: self.version.unwrap_or_default(),
                row_tag: self.row_tag,
            }
        }
    }
}
impl XmlClassifier {
    /// Creates a new builder-style object to manufacture [`XmlClassifier`](crate::model::XmlClassifier).
    pub fn builder() -> crate::model::xml_classifier::Builder {
        crate::model::xml_classifier::Builder::default()
    }
}

/// <p>A classifier that uses <code>grok</code> patterns.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GrokClassifier {
    /// <p>The name of the classifier.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>An identifier of the data format that the classifier matches, such as Twitter, JSON, Omniture logs, and so on.</p>
    #[doc(hidden)]
    pub classification: std::option::Option<std::string::String>,
    /// <p>The time that this classifier was registered.</p>
    #[doc(hidden)]
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The time that this classifier was last updated.</p>
    #[doc(hidden)]
    pub last_updated: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The version of this classifier.</p>
    #[doc(hidden)]
    pub version: i64,
    /// <p>The grok pattern applied to a data store by this classifier. For more information, see built-in patterns in <a href="https://docs.aws.amazon.com/glue/latest/dg/custom-classifier.html">Writing Custom Classifiers</a>.</p>
    #[doc(hidden)]
    pub grok_pattern: std::option::Option<std::string::String>,
    /// <p>Optional custom grok patterns defined by this classifier. For more information, see custom patterns in <a href="https://docs.aws.amazon.com/glue/latest/dg/custom-classifier.html">Writing Custom Classifiers</a>.</p>
    #[doc(hidden)]
    pub custom_patterns: std::option::Option<std::string::String>,
}
impl GrokClassifier {
    /// <p>The name of the classifier.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>An identifier of the data format that the classifier matches, such as Twitter, JSON, Omniture logs, and so on.</p>
    pub fn classification(&self) -> std::option::Option<&str> {
        self.classification.as_deref()
    }
    /// <p>The time that this classifier was registered.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>The time that this classifier was last updated.</p>
    pub fn last_updated(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_updated.as_ref()
    }
    /// <p>The version of this classifier.</p>
    pub fn version(&self) -> i64 {
        self.version
    }
    /// <p>The grok pattern applied to a data store by this classifier. For more information, see built-in patterns in <a href="https://docs.aws.amazon.com/glue/latest/dg/custom-classifier.html">Writing Custom Classifiers</a>.</p>
    pub fn grok_pattern(&self) -> std::option::Option<&str> {
        self.grok_pattern.as_deref()
    }
    /// <p>Optional custom grok patterns defined by this classifier. For more information, see custom patterns in <a href="https://docs.aws.amazon.com/glue/latest/dg/custom-classifier.html">Writing Custom Classifiers</a>.</p>
    pub fn custom_patterns(&self) -> std::option::Option<&str> {
        self.custom_patterns.as_deref()
    }
}
/// See [`GrokClassifier`](crate::model::GrokClassifier).
pub mod grok_classifier {

    /// A builder for [`GrokClassifier`](crate::model::GrokClassifier).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) classification: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_updated: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) version: std::option::Option<i64>,
        pub(crate) grok_pattern: std::option::Option<std::string::String>,
        pub(crate) custom_patterns: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the classifier.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the classifier.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>An identifier of the data format that the classifier matches, such as Twitter, JSON, Omniture logs, and so on.</p>
        pub fn classification(mut self, input: impl Into<std::string::String>) -> Self {
            self.classification = Some(input.into());
            self
        }
        /// <p>An identifier of the data format that the classifier matches, such as Twitter, JSON, Omniture logs, and so on.</p>
        pub fn set_classification(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.classification = input;
            self
        }
        /// <p>The time that this classifier was registered.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>The time that this classifier was registered.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>The time that this classifier was last updated.</p>
        pub fn last_updated(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_updated = Some(input);
            self
        }
        /// <p>The time that this classifier was last updated.</p>
        pub fn set_last_updated(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_updated = input;
            self
        }
        /// <p>The version of this classifier.</p>
        pub fn version(mut self, input: i64) -> Self {
            self.version = Some(input);
            self
        }
        /// <p>The version of this classifier.</p>
        pub fn set_version(mut self, input: std::option::Option<i64>) -> Self {
            self.version = input;
            self
        }
        /// <p>The grok pattern applied to a data store by this classifier. For more information, see built-in patterns in <a href="https://docs.aws.amazon.com/glue/latest/dg/custom-classifier.html">Writing Custom Classifiers</a>.</p>
        pub fn grok_pattern(mut self, input: impl Into<std::string::String>) -> Self {
            self.grok_pattern = Some(input.into());
            self
        }
        /// <p>The grok pattern applied to a data store by this classifier. For more information, see built-in patterns in <a href="https://docs.aws.amazon.com/glue/latest/dg/custom-classifier.html">Writing Custom Classifiers</a>.</p>
        pub fn set_grok_pattern(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.grok_pattern = input;
            self
        }
        /// <p>Optional custom grok patterns defined by this classifier. For more information, see custom patterns in <a href="https://docs.aws.amazon.com/glue/latest/dg/custom-classifier.html">Writing Custom Classifiers</a>.</p>
        pub fn custom_patterns(mut self, input: impl Into<std::string::String>) -> Self {
            self.custom_patterns = Some(input.into());
            self
        }
        /// <p>Optional custom grok patterns defined by this classifier. For more information, see custom patterns in <a href="https://docs.aws.amazon.com/glue/latest/dg/custom-classifier.html">Writing Custom Classifiers</a>.</p>
        pub fn set_custom_patterns(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.custom_patterns = input;
            self
        }
        /// Consumes the builder and constructs a [`GrokClassifier`](crate::model::GrokClassifier).
        pub fn build(self) -> crate::model::GrokClassifier {
            crate::model::GrokClassifier {
                name: self.name,
                classification: self.classification,
                creation_time: self.creation_time,
                last_updated: self.last_updated,
                version: self.version.unwrap_or_default(),
                grok_pattern: self.grok_pattern,
                custom_patterns: self.custom_patterns,
            }
        }
    }
}
impl GrokClassifier {
    /// Creates a new builder-style object to manufacture [`GrokClassifier`](crate::model::GrokClassifier).
    pub fn builder() -> crate::model::grok_classifier::Builder {
        crate::model::grok_classifier::Builder::default()
    }
}

/// <p>A structure containing migration status information.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CatalogImportStatus {
    /// <p> <code>True</code> if the migration has completed, or <code>False</code> otherwise.</p>
    #[doc(hidden)]
    pub import_completed: bool,
    /// <p>The time that the migration was started.</p>
    #[doc(hidden)]
    pub import_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The name of the person who initiated the migration.</p>
    #[doc(hidden)]
    pub imported_by: std::option::Option<std::string::String>,
}
impl CatalogImportStatus {
    /// <p> <code>True</code> if the migration has completed, or <code>False</code> otherwise.</p>
    pub fn import_completed(&self) -> bool {
        self.import_completed
    }
    /// <p>The time that the migration was started.</p>
    pub fn import_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.import_time.as_ref()
    }
    /// <p>The name of the person who initiated the migration.</p>
    pub fn imported_by(&self) -> std::option::Option<&str> {
        self.imported_by.as_deref()
    }
}
/// See [`CatalogImportStatus`](crate::model::CatalogImportStatus).
pub mod catalog_import_status {

    /// A builder for [`CatalogImportStatus`](crate::model::CatalogImportStatus).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) import_completed: std::option::Option<bool>,
        pub(crate) import_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) imported_by: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> <code>True</code> if the migration has completed, or <code>False</code> otherwise.</p>
        pub fn import_completed(mut self, input: bool) -> Self {
            self.import_completed = Some(input);
            self
        }
        /// <p> <code>True</code> if the migration has completed, or <code>False</code> otherwise.</p>
        pub fn set_import_completed(mut self, input: std::option::Option<bool>) -> Self {
            self.import_completed = input;
            self
        }
        /// <p>The time that the migration was started.</p>
        pub fn import_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.import_time = Some(input);
            self
        }
        /// <p>The time that the migration was started.</p>
        pub fn set_import_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.import_time = input;
            self
        }
        /// <p>The name of the person who initiated the migration.</p>
        pub fn imported_by(mut self, input: impl Into<std::string::String>) -> Self {
            self.imported_by = Some(input.into());
            self
        }
        /// <p>The name of the person who initiated the migration.</p>
        pub fn set_imported_by(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.imported_by = input;
            self
        }
        /// Consumes the builder and constructs a [`CatalogImportStatus`](crate::model::CatalogImportStatus).
        pub fn build(self) -> crate::model::CatalogImportStatus {
            crate::model::CatalogImportStatus {
                import_completed: self.import_completed.unwrap_or_default(),
                import_time: self.import_time,
                imported_by: self.imported_by,
            }
        }
    }
}
impl CatalogImportStatus {
    /// Creates a new builder-style object to manufacture [`CatalogImportStatus`](crate::model::CatalogImportStatus).
    pub fn builder() -> crate::model::catalog_import_status::Builder {
        crate::model::catalog_import_status::Builder::default()
    }
}

/// <p>The details of a blueprint run.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BlueprintRun {
    /// <p>The name of the blueprint.</p>
    #[doc(hidden)]
    pub blueprint_name: std::option::Option<std::string::String>,
    /// <p>The run ID for this blueprint run.</p>
    #[doc(hidden)]
    pub run_id: std::option::Option<std::string::String>,
    /// <p>The name of a workflow that is created as a result of a successful blueprint run. If a blueprint run has an error, there will not be a workflow created.</p>
    #[doc(hidden)]
    pub workflow_name: std::option::Option<std::string::String>,
    /// <p>The state of the blueprint run. Possible values are:</p>
    /// <ul>
    /// <li> <p>Running — The blueprint run is in progress.</p> </li>
    /// <li> <p>Succeeded — The blueprint run completed successfully.</p> </li>
    /// <li> <p>Failed — The blueprint run failed and rollback is complete.</p> </li>
    /// <li> <p>Rolling Back — The blueprint run failed and rollback is in progress.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub state: std::option::Option<crate::model::BlueprintRunState>,
    /// <p>The date and time that the blueprint run started.</p>
    #[doc(hidden)]
    pub started_on: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The date and time that the blueprint run completed.</p>
    #[doc(hidden)]
    pub completed_on: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Indicates any errors that are seen while running the blueprint.</p>
    #[doc(hidden)]
    pub error_message: std::option::Option<std::string::String>,
    /// <p>If there are any errors while creating the entities of a workflow, we try to roll back the created entities until that point and delete them. This attribute indicates the errors seen while trying to delete the entities that are created.</p>
    #[doc(hidden)]
    pub rollback_error_message: std::option::Option<std::string::String>,
    /// <p>The blueprint parameters as a string. You will have to provide a value for each key that is required from the parameter spec that is defined in the <code>Blueprint$ParameterSpec</code>.</p>
    #[doc(hidden)]
    pub parameters: std::option::Option<std::string::String>,
    /// <p>The role ARN. This role will be assumed by the Glue service and will be used to create the workflow and other entities of a workflow.</p>
    #[doc(hidden)]
    pub role_arn: std::option::Option<std::string::String>,
}
impl BlueprintRun {
    /// <p>The name of the blueprint.</p>
    pub fn blueprint_name(&self) -> std::option::Option<&str> {
        self.blueprint_name.as_deref()
    }
    /// <p>The run ID for this blueprint run.</p>
    pub fn run_id(&self) -> std::option::Option<&str> {
        self.run_id.as_deref()
    }
    /// <p>The name of a workflow that is created as a result of a successful blueprint run. If a blueprint run has an error, there will not be a workflow created.</p>
    pub fn workflow_name(&self) -> std::option::Option<&str> {
        self.workflow_name.as_deref()
    }
    /// <p>The state of the blueprint run. Possible values are:</p>
    /// <ul>
    /// <li> <p>Running — The blueprint run is in progress.</p> </li>
    /// <li> <p>Succeeded — The blueprint run completed successfully.</p> </li>
    /// <li> <p>Failed — The blueprint run failed and rollback is complete.</p> </li>
    /// <li> <p>Rolling Back — The blueprint run failed and rollback is in progress.</p> </li>
    /// </ul>
    pub fn state(&self) -> std::option::Option<&crate::model::BlueprintRunState> {
        self.state.as_ref()
    }
    /// <p>The date and time that the blueprint run started.</p>
    pub fn started_on(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.started_on.as_ref()
    }
    /// <p>The date and time that the blueprint run completed.</p>
    pub fn completed_on(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.completed_on.as_ref()
    }
    /// <p>Indicates any errors that are seen while running the blueprint.</p>
    pub fn error_message(&self) -> std::option::Option<&str> {
        self.error_message.as_deref()
    }
    /// <p>If there are any errors while creating the entities of a workflow, we try to roll back the created entities until that point and delete them. This attribute indicates the errors seen while trying to delete the entities that are created.</p>
    pub fn rollback_error_message(&self) -> std::option::Option<&str> {
        self.rollback_error_message.as_deref()
    }
    /// <p>The blueprint parameters as a string. You will have to provide a value for each key that is required from the parameter spec that is defined in the <code>Blueprint$ParameterSpec</code>.</p>
    pub fn parameters(&self) -> std::option::Option<&str> {
        self.parameters.as_deref()
    }
    /// <p>The role ARN. This role will be assumed by the Glue service and will be used to create the workflow and other entities of a workflow.</p>
    pub fn role_arn(&self) -> std::option::Option<&str> {
        self.role_arn.as_deref()
    }
}
/// See [`BlueprintRun`](crate::model::BlueprintRun).
pub mod blueprint_run {

    /// A builder for [`BlueprintRun`](crate::model::BlueprintRun).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) blueprint_name: std::option::Option<std::string::String>,
        pub(crate) run_id: std::option::Option<std::string::String>,
        pub(crate) workflow_name: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<crate::model::BlueprintRunState>,
        pub(crate) started_on: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) completed_on: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) error_message: std::option::Option<std::string::String>,
        pub(crate) rollback_error_message: std::option::Option<std::string::String>,
        pub(crate) parameters: std::option::Option<std::string::String>,
        pub(crate) role_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the blueprint.</p>
        pub fn blueprint_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.blueprint_name = Some(input.into());
            self
        }
        /// <p>The name of the blueprint.</p>
        pub fn set_blueprint_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.blueprint_name = input;
            self
        }
        /// <p>The run ID for this blueprint run.</p>
        pub fn run_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.run_id = Some(input.into());
            self
        }
        /// <p>The run ID for this blueprint run.</p>
        pub fn set_run_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.run_id = input;
            self
        }
        /// <p>The name of a workflow that is created as a result of a successful blueprint run. If a blueprint run has an error, there will not be a workflow created.</p>
        pub fn workflow_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.workflow_name = Some(input.into());
            self
        }
        /// <p>The name of a workflow that is created as a result of a successful blueprint run. If a blueprint run has an error, there will not be a workflow created.</p>
        pub fn set_workflow_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.workflow_name = input;
            self
        }
        /// <p>The state of the blueprint run. Possible values are:</p>
        /// <ul>
        /// <li> <p>Running — The blueprint run is in progress.</p> </li>
        /// <li> <p>Succeeded — The blueprint run completed successfully.</p> </li>
        /// <li> <p>Failed — The blueprint run failed and rollback is complete.</p> </li>
        /// <li> <p>Rolling Back — The blueprint run failed and rollback is in progress.</p> </li>
        /// </ul>
        pub fn state(mut self, input: crate::model::BlueprintRunState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The state of the blueprint run. Possible values are:</p>
        /// <ul>
        /// <li> <p>Running — The blueprint run is in progress.</p> </li>
        /// <li> <p>Succeeded — The blueprint run completed successfully.</p> </li>
        /// <li> <p>Failed — The blueprint run failed and rollback is complete.</p> </li>
        /// <li> <p>Rolling Back — The blueprint run failed and rollback is in progress.</p> </li>
        /// </ul>
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::BlueprintRunState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// <p>The date and time that the blueprint run started.</p>
        pub fn started_on(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.started_on = Some(input);
            self
        }
        /// <p>The date and time that the blueprint run started.</p>
        pub fn set_started_on(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.started_on = input;
            self
        }
        /// <p>The date and time that the blueprint run completed.</p>
        pub fn completed_on(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.completed_on = Some(input);
            self
        }
        /// <p>The date and time that the blueprint run completed.</p>
        pub fn set_completed_on(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.completed_on = input;
            self
        }
        /// <p>Indicates any errors that are seen while running the blueprint.</p>
        pub fn error_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_message = Some(input.into());
            self
        }
        /// <p>Indicates any errors that are seen while running the blueprint.</p>
        pub fn set_error_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.error_message = input;
            self
        }
        /// <p>If there are any errors while creating the entities of a workflow, we try to roll back the created entities until that point and delete them. This attribute indicates the errors seen while trying to delete the entities that are created.</p>
        pub fn rollback_error_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.rollback_error_message = Some(input.into());
            self
        }
        /// <p>If there are any errors while creating the entities of a workflow, we try to roll back the created entities until that point and delete them. This attribute indicates the errors seen while trying to delete the entities that are created.</p>
        pub fn set_rollback_error_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.rollback_error_message = input;
            self
        }
        /// <p>The blueprint parameters as a string. You will have to provide a value for each key that is required from the parameter spec that is defined in the <code>Blueprint$ParameterSpec</code>.</p>
        pub fn parameters(mut self, input: impl Into<std::string::String>) -> Self {
            self.parameters = Some(input.into());
            self
        }
        /// <p>The blueprint parameters as a string. You will have to provide a value for each key that is required from the parameter spec that is defined in the <code>Blueprint$ParameterSpec</code>.</p>
        pub fn set_parameters(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.parameters = input;
            self
        }
        /// <p>The role ARN. This role will be assumed by the Glue service and will be used to create the workflow and other entities of a workflow.</p>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.role_arn = Some(input.into());
            self
        }
        /// <p>The role ARN. This role will be assumed by the Glue service and will be used to create the workflow and other entities of a workflow.</p>
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.role_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`BlueprintRun`](crate::model::BlueprintRun).
        pub fn build(self) -> crate::model::BlueprintRun {
            crate::model::BlueprintRun {
                blueprint_name: self.blueprint_name,
                run_id: self.run_id,
                workflow_name: self.workflow_name,
                state: self.state,
                started_on: self.started_on,
                completed_on: self.completed_on,
                error_message: self.error_message,
                rollback_error_message: self.rollback_error_message,
                parameters: self.parameters,
                role_arn: self.role_arn,
            }
        }
    }
}
impl BlueprintRun {
    /// Creates a new builder-style object to manufacture [`BlueprintRun`](crate::model::BlueprintRun).
    pub fn builder() -> crate::model::blueprint_run::Builder {
        crate::model::blueprint_run::Builder::default()
    }
}

/// When writing a match expression against `BlueprintRunState`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let blueprintrunstate = unimplemented!();
/// match blueprintrunstate {
///     BlueprintRunState::Failed => { /* ... */ },
///     BlueprintRunState::RollingBack => { /* ... */ },
///     BlueprintRunState::Running => { /* ... */ },
///     BlueprintRunState::Succeeded => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `blueprintrunstate` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `BlueprintRunState::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `BlueprintRunState::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `BlueprintRunState::NewFeature` is defined.
/// Specifically, when `blueprintrunstate` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `BlueprintRunState::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum BlueprintRunState {
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    RollingBack,
    #[allow(missing_docs)] // documentation missing in model
    Running,
    #[allow(missing_docs)] // documentation missing in model
    Succeeded,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for BlueprintRunState {
    fn from(s: &str) -> Self {
        match s {
            "FAILED" => BlueprintRunState::Failed,
            "ROLLING_BACK" => BlueprintRunState::RollingBack,
            "RUNNING" => BlueprintRunState::Running,
            "SUCCEEDED" => BlueprintRunState::Succeeded,
            other => {
                BlueprintRunState::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for BlueprintRunState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(BlueprintRunState::from(s))
    }
}
impl BlueprintRunState {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            BlueprintRunState::Failed => "FAILED",
            BlueprintRunState::RollingBack => "ROLLING_BACK",
            BlueprintRunState::Running => "RUNNING",
            BlueprintRunState::Succeeded => "SUCCEEDED",
            BlueprintRunState::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["FAILED", "ROLLING_BACK", "RUNNING", "SUCCEEDED"]
    }
}
impl AsRef<str> for BlueprintRunState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The details of a blueprint.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Blueprint {
    /// <p>The name of the blueprint.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The description of the blueprint.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The date and time the blueprint was registered.</p>
    #[doc(hidden)]
    pub created_on: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The date and time the blueprint was last modified.</p>
    #[doc(hidden)]
    pub last_modified_on: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>A JSON string that indicates the list of parameter specifications for the blueprint.</p>
    #[doc(hidden)]
    pub parameter_spec: std::option::Option<std::string::String>,
    /// <p>Specifies the path in Amazon S3 where the blueprint is published.</p>
    #[doc(hidden)]
    pub blueprint_location: std::option::Option<std::string::String>,
    /// <p>Specifies a path in Amazon S3 where the blueprint is copied when you call <code>CreateBlueprint/UpdateBlueprint</code> to register the blueprint in Glue.</p>
    #[doc(hidden)]
    pub blueprint_service_location: std::option::Option<std::string::String>,
    /// <p>The status of the blueprint registration.</p>
    /// <ul>
    /// <li> <p>Creating — The blueprint registration is in progress.</p> </li>
    /// <li> <p>Active — The blueprint has been successfully registered.</p> </li>
    /// <li> <p>Updating — An update to the blueprint registration is in progress.</p> </li>
    /// <li> <p>Failed — The blueprint registration failed.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::BlueprintStatus>,
    /// <p>An error message.</p>
    #[doc(hidden)]
    pub error_message: std::option::Option<std::string::String>,
    /// <p>When there are multiple versions of a blueprint and the latest version has some errors, this attribute indicates the last successful blueprint definition that is available with the service.</p>
    #[doc(hidden)]
    pub last_active_definition: std::option::Option<crate::model::LastActiveDefinition>,
}
impl Blueprint {
    /// <p>The name of the blueprint.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The description of the blueprint.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The date and time the blueprint was registered.</p>
    pub fn created_on(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_on.as_ref()
    }
    /// <p>The date and time the blueprint was last modified.</p>
    pub fn last_modified_on(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_modified_on.as_ref()
    }
    /// <p>A JSON string that indicates the list of parameter specifications for the blueprint.</p>
    pub fn parameter_spec(&self) -> std::option::Option<&str> {
        self.parameter_spec.as_deref()
    }
    /// <p>Specifies the path in Amazon S3 where the blueprint is published.</p>
    pub fn blueprint_location(&self) -> std::option::Option<&str> {
        self.blueprint_location.as_deref()
    }
    /// <p>Specifies a path in Amazon S3 where the blueprint is copied when you call <code>CreateBlueprint/UpdateBlueprint</code> to register the blueprint in Glue.</p>
    pub fn blueprint_service_location(&self) -> std::option::Option<&str> {
        self.blueprint_service_location.as_deref()
    }
    /// <p>The status of the blueprint registration.</p>
    /// <ul>
    /// <li> <p>Creating — The blueprint registration is in progress.</p> </li>
    /// <li> <p>Active — The blueprint has been successfully registered.</p> </li>
    /// <li> <p>Updating — An update to the blueprint registration is in progress.</p> </li>
    /// <li> <p>Failed — The blueprint registration failed.</p> </li>
    /// </ul>
    pub fn status(&self) -> std::option::Option<&crate::model::BlueprintStatus> {
        self.status.as_ref()
    }
    /// <p>An error message.</p>
    pub fn error_message(&self) -> std::option::Option<&str> {
        self.error_message.as_deref()
    }
    /// <p>When there are multiple versions of a blueprint and the latest version has some errors, this attribute indicates the last successful blueprint definition that is available with the service.</p>
    pub fn last_active_definition(
        &self,
    ) -> std::option::Option<&crate::model::LastActiveDefinition> {
        self.last_active_definition.as_ref()
    }
}
/// See [`Blueprint`](crate::model::Blueprint).
pub mod blueprint {

    /// A builder for [`Blueprint`](crate::model::Blueprint).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) created_on: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_modified_on: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) parameter_spec: std::option::Option<std::string::String>,
        pub(crate) blueprint_location: std::option::Option<std::string::String>,
        pub(crate) blueprint_service_location: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::BlueprintStatus>,
        pub(crate) error_message: std::option::Option<std::string::String>,
        pub(crate) last_active_definition: std::option::Option<crate::model::LastActiveDefinition>,
    }
    impl Builder {
        /// <p>The name of the blueprint.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the blueprint.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The description of the blueprint.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the blueprint.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The date and time the blueprint was registered.</p>
        pub fn created_on(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_on = Some(input);
            self
        }
        /// <p>The date and time the blueprint was registered.</p>
        pub fn set_created_on(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_on = input;
            self
        }
        /// <p>The date and time the blueprint was last modified.</p>
        pub fn last_modified_on(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_modified_on = Some(input);
            self
        }
        /// <p>The date and time the blueprint was last modified.</p>
        pub fn set_last_modified_on(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_modified_on = input;
            self
        }
        /// <p>A JSON string that indicates the list of parameter specifications for the blueprint.</p>
        pub fn parameter_spec(mut self, input: impl Into<std::string::String>) -> Self {
            self.parameter_spec = Some(input.into());
            self
        }
        /// <p>A JSON string that indicates the list of parameter specifications for the blueprint.</p>
        pub fn set_parameter_spec(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.parameter_spec = input;
            self
        }
        /// <p>Specifies the path in Amazon S3 where the blueprint is published.</p>
        pub fn blueprint_location(mut self, input: impl Into<std::string::String>) -> Self {
            self.blueprint_location = Some(input.into());
            self
        }
        /// <p>Specifies the path in Amazon S3 where the blueprint is published.</p>
        pub fn set_blueprint_location(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.blueprint_location = input;
            self
        }
        /// <p>Specifies a path in Amazon S3 where the blueprint is copied when you call <code>CreateBlueprint/UpdateBlueprint</code> to register the blueprint in Glue.</p>
        pub fn blueprint_service_location(mut self, input: impl Into<std::string::String>) -> Self {
            self.blueprint_service_location = Some(input.into());
            self
        }
        /// <p>Specifies a path in Amazon S3 where the blueprint is copied when you call <code>CreateBlueprint/UpdateBlueprint</code> to register the blueprint in Glue.</p>
        pub fn set_blueprint_service_location(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.blueprint_service_location = input;
            self
        }
        /// <p>The status of the blueprint registration.</p>
        /// <ul>
        /// <li> <p>Creating — The blueprint registration is in progress.</p> </li>
        /// <li> <p>Active — The blueprint has been successfully registered.</p> </li>
        /// <li> <p>Updating — An update to the blueprint registration is in progress.</p> </li>
        /// <li> <p>Failed — The blueprint registration failed.</p> </li>
        /// </ul>
        pub fn status(mut self, input: crate::model::BlueprintStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the blueprint registration.</p>
        /// <ul>
        /// <li> <p>Creating — The blueprint registration is in progress.</p> </li>
        /// <li> <p>Active — The blueprint has been successfully registered.</p> </li>
        /// <li> <p>Updating — An update to the blueprint registration is in progress.</p> </li>
        /// <li> <p>Failed — The blueprint registration failed.</p> </li>
        /// </ul>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::BlueprintStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>An error message.</p>
        pub fn error_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_message = Some(input.into());
            self
        }
        /// <p>An error message.</p>
        pub fn set_error_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.error_message = input;
            self
        }
        /// <p>When there are multiple versions of a blueprint and the latest version has some errors, this attribute indicates the last successful blueprint definition that is available with the service.</p>
        pub fn last_active_definition(mut self, input: crate::model::LastActiveDefinition) -> Self {
            self.last_active_definition = Some(input);
            self
        }
        /// <p>When there are multiple versions of a blueprint and the latest version has some errors, this attribute indicates the last successful blueprint definition that is available with the service.</p>
        pub fn set_last_active_definition(
            mut self,
            input: std::option::Option<crate::model::LastActiveDefinition>,
        ) -> Self {
            self.last_active_definition = input;
            self
        }
        /// Consumes the builder and constructs a [`Blueprint`](crate::model::Blueprint).
        pub fn build(self) -> crate::model::Blueprint {
            crate::model::Blueprint {
                name: self.name,
                description: self.description,
                created_on: self.created_on,
                last_modified_on: self.last_modified_on,
                parameter_spec: self.parameter_spec,
                blueprint_location: self.blueprint_location,
                blueprint_service_location: self.blueprint_service_location,
                status: self.status,
                error_message: self.error_message,
                last_active_definition: self.last_active_definition,
            }
        }
    }
}
impl Blueprint {
    /// Creates a new builder-style object to manufacture [`Blueprint`](crate::model::Blueprint).
    pub fn builder() -> crate::model::blueprint::Builder {
        crate::model::blueprint::Builder::default()
    }
}

/// <p>When there are multiple versions of a blueprint and the latest version has some errors, this attribute indicates the last successful blueprint definition that is available with the service.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LastActiveDefinition {
    /// <p>The description of the blueprint.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The date and time the blueprint was last modified.</p>
    #[doc(hidden)]
    pub last_modified_on: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>A JSON string specifying the parameters for the blueprint.</p>
    #[doc(hidden)]
    pub parameter_spec: std::option::Option<std::string::String>,
    /// <p>Specifies a path in Amazon S3 where the blueprint is published by the Glue developer.</p>
    #[doc(hidden)]
    pub blueprint_location: std::option::Option<std::string::String>,
    /// <p>Specifies a path in Amazon S3 where the blueprint is copied when you create or update the blueprint.</p>
    #[doc(hidden)]
    pub blueprint_service_location: std::option::Option<std::string::String>,
}
impl LastActiveDefinition {
    /// <p>The description of the blueprint.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The date and time the blueprint was last modified.</p>
    pub fn last_modified_on(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_modified_on.as_ref()
    }
    /// <p>A JSON string specifying the parameters for the blueprint.</p>
    pub fn parameter_spec(&self) -> std::option::Option<&str> {
        self.parameter_spec.as_deref()
    }
    /// <p>Specifies a path in Amazon S3 where the blueprint is published by the Glue developer.</p>
    pub fn blueprint_location(&self) -> std::option::Option<&str> {
        self.blueprint_location.as_deref()
    }
    /// <p>Specifies a path in Amazon S3 where the blueprint is copied when you create or update the blueprint.</p>
    pub fn blueprint_service_location(&self) -> std::option::Option<&str> {
        self.blueprint_service_location.as_deref()
    }
}
/// See [`LastActiveDefinition`](crate::model::LastActiveDefinition).
pub mod last_active_definition {

    /// A builder for [`LastActiveDefinition`](crate::model::LastActiveDefinition).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) last_modified_on: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) parameter_spec: std::option::Option<std::string::String>,
        pub(crate) blueprint_location: std::option::Option<std::string::String>,
        pub(crate) blueprint_service_location: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The description of the blueprint.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the blueprint.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The date and time the blueprint was last modified.</p>
        pub fn last_modified_on(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_modified_on = Some(input);
            self
        }
        /// <p>The date and time the blueprint was last modified.</p>
        pub fn set_last_modified_on(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_modified_on = input;
            self
        }
        /// <p>A JSON string specifying the parameters for the blueprint.</p>
        pub fn parameter_spec(mut self, input: impl Into<std::string::String>) -> Self {
            self.parameter_spec = Some(input.into());
            self
        }
        /// <p>A JSON string specifying the parameters for the blueprint.</p>
        pub fn set_parameter_spec(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.parameter_spec = input;
            self
        }
        /// <p>Specifies a path in Amazon S3 where the blueprint is published by the Glue developer.</p>
        pub fn blueprint_location(mut self, input: impl Into<std::string::String>) -> Self {
            self.blueprint_location = Some(input.into());
            self
        }
        /// <p>Specifies a path in Amazon S3 where the blueprint is published by the Glue developer.</p>
        pub fn set_blueprint_location(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.blueprint_location = input;
            self
        }
        /// <p>Specifies a path in Amazon S3 where the blueprint is copied when you create or update the blueprint.</p>
        pub fn blueprint_service_location(mut self, input: impl Into<std::string::String>) -> Self {
            self.blueprint_service_location = Some(input.into());
            self
        }
        /// <p>Specifies a path in Amazon S3 where the blueprint is copied when you create or update the blueprint.</p>
        pub fn set_blueprint_service_location(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.blueprint_service_location = input;
            self
        }
        /// Consumes the builder and constructs a [`LastActiveDefinition`](crate::model::LastActiveDefinition).
        pub fn build(self) -> crate::model::LastActiveDefinition {
            crate::model::LastActiveDefinition {
                description: self.description,
                last_modified_on: self.last_modified_on,
                parameter_spec: self.parameter_spec,
                blueprint_location: self.blueprint_location,
                blueprint_service_location: self.blueprint_service_location,
            }
        }
    }
}
impl LastActiveDefinition {
    /// Creates a new builder-style object to manufacture [`LastActiveDefinition`](crate::model::LastActiveDefinition).
    pub fn builder() -> crate::model::last_active_definition::Builder {
        crate::model::last_active_definition::Builder::default()
    }
}

/// When writing a match expression against `BlueprintStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let blueprintstatus = unimplemented!();
/// match blueprintstatus {
///     BlueprintStatus::Active => { /* ... */ },
///     BlueprintStatus::Creating => { /* ... */ },
///     BlueprintStatus::Failed => { /* ... */ },
///     BlueprintStatus::Updating => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `blueprintstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `BlueprintStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `BlueprintStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `BlueprintStatus::NewFeature` is defined.
/// Specifically, when `blueprintstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `BlueprintStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum BlueprintStatus {
    #[allow(missing_docs)] // documentation missing in model
    Active,
    #[allow(missing_docs)] // documentation missing in model
    Creating,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    Updating,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for BlueprintStatus {
    fn from(s: &str) -> Self {
        match s {
            "ACTIVE" => BlueprintStatus::Active,
            "CREATING" => BlueprintStatus::Creating,
            "FAILED" => BlueprintStatus::Failed,
            "UPDATING" => BlueprintStatus::Updating,
            other => BlueprintStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for BlueprintStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(BlueprintStatus::from(s))
    }
}
impl BlueprintStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            BlueprintStatus::Active => "ACTIVE",
            BlueprintStatus::Creating => "CREATING",
            BlueprintStatus::Failed => "FAILED",
            BlueprintStatus::Updating => "UPDATING",
            BlueprintStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ACTIVE", "CREATING", "FAILED", "UPDATING"]
    }
}
impl AsRef<str> for BlueprintStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>An object that contains the error details for an operation on a schema version.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SchemaVersionErrorItem {
    /// <p>The version number of the schema.</p>
    #[doc(hidden)]
    pub version_number: i64,
    /// <p>The details of the error for the schema version.</p>
    #[doc(hidden)]
    pub error_details: std::option::Option<crate::model::ErrorDetails>,
}
impl SchemaVersionErrorItem {
    /// <p>The version number of the schema.</p>
    pub fn version_number(&self) -> i64 {
        self.version_number
    }
    /// <p>The details of the error for the schema version.</p>
    pub fn error_details(&self) -> std::option::Option<&crate::model::ErrorDetails> {
        self.error_details.as_ref()
    }
}
/// See [`SchemaVersionErrorItem`](crate::model::SchemaVersionErrorItem).
pub mod schema_version_error_item {

    /// A builder for [`SchemaVersionErrorItem`](crate::model::SchemaVersionErrorItem).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) version_number: std::option::Option<i64>,
        pub(crate) error_details: std::option::Option<crate::model::ErrorDetails>,
    }
    impl Builder {
        /// <p>The version number of the schema.</p>
        pub fn version_number(mut self, input: i64) -> Self {
            self.version_number = Some(input);
            self
        }
        /// <p>The version number of the schema.</p>
        pub fn set_version_number(mut self, input: std::option::Option<i64>) -> Self {
            self.version_number = input;
            self
        }
        /// <p>The details of the error for the schema version.</p>
        pub fn error_details(mut self, input: crate::model::ErrorDetails) -> Self {
            self.error_details = Some(input);
            self
        }
        /// <p>The details of the error for the schema version.</p>
        pub fn set_error_details(
            mut self,
            input: std::option::Option<crate::model::ErrorDetails>,
        ) -> Self {
            self.error_details = input;
            self
        }
        /// Consumes the builder and constructs a [`SchemaVersionErrorItem`](crate::model::SchemaVersionErrorItem).
        pub fn build(self) -> crate::model::SchemaVersionErrorItem {
            crate::model::SchemaVersionErrorItem {
                version_number: self.version_number.unwrap_or_default(),
                error_details: self.error_details,
            }
        }
    }
}
impl SchemaVersionErrorItem {
    /// Creates a new builder-style object to manufacture [`SchemaVersionErrorItem`](crate::model::SchemaVersionErrorItem).
    pub fn builder() -> crate::model::schema_version_error_item::Builder {
        crate::model::schema_version_error_item::Builder::default()
    }
}

/// <p>An object containing error details.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ErrorDetails {
    /// <p>The error code for an error.</p>
    #[doc(hidden)]
    pub error_code: std::option::Option<std::string::String>,
    /// <p>The error message for an error.</p>
    #[doc(hidden)]
    pub error_message: std::option::Option<std::string::String>,
}
impl ErrorDetails {
    /// <p>The error code for an error.</p>
    pub fn error_code(&self) -> std::option::Option<&str> {
        self.error_code.as_deref()
    }
    /// <p>The error message for an error.</p>
    pub fn error_message(&self) -> std::option::Option<&str> {
        self.error_message.as_deref()
    }
}
/// See [`ErrorDetails`](crate::model::ErrorDetails).
pub mod error_details {

    /// A builder for [`ErrorDetails`](crate::model::ErrorDetails).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) error_code: std::option::Option<std::string::String>,
        pub(crate) error_message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The error code for an error.</p>
        pub fn error_code(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_code = Some(input.into());
            self
        }
        /// <p>The error code for an error.</p>
        pub fn set_error_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.error_code = input;
            self
        }
        /// <p>The error message for an error.</p>
        pub fn error_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_message = Some(input.into());
            self
        }
        /// <p>The error message for an error.</p>
        pub fn set_error_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.error_message = input;
            self
        }
        /// Consumes the builder and constructs a [`ErrorDetails`](crate::model::ErrorDetails).
        pub fn build(self) -> crate::model::ErrorDetails {
            crate::model::ErrorDetails {
                error_code: self.error_code,
                error_message: self.error_message,
            }
        }
    }
}
impl ErrorDetails {
    /// Creates a new builder-style object to manufacture [`ErrorDetails`](crate::model::ErrorDetails).
    pub fn builder() -> crate::model::error_details::Builder {
        crate::model::error_details::Builder::default()
    }
}

/// <p>A structure for a partition index.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PartitionIndex {
    /// <p>The keys for the partition index.</p>
    #[doc(hidden)]
    pub keys: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The name of the partition index.</p>
    #[doc(hidden)]
    pub index_name: std::option::Option<std::string::String>,
}
impl PartitionIndex {
    /// <p>The keys for the partition index.</p>
    pub fn keys(&self) -> std::option::Option<&[std::string::String]> {
        self.keys.as_deref()
    }
    /// <p>The name of the partition index.</p>
    pub fn index_name(&self) -> std::option::Option<&str> {
        self.index_name.as_deref()
    }
}
/// See [`PartitionIndex`](crate::model::PartitionIndex).
pub mod partition_index {

    /// A builder for [`PartitionIndex`](crate::model::PartitionIndex).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) keys: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) index_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `keys`.
        ///
        /// To override the contents of this collection use [`set_keys`](Self::set_keys).
        ///
        /// <p>The keys for the partition index.</p>
        pub fn keys(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.keys.unwrap_or_default();
            v.push(input.into());
            self.keys = Some(v);
            self
        }
        /// <p>The keys for the partition index.</p>
        pub fn set_keys(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.keys = input;
            self
        }
        /// <p>The name of the partition index.</p>
        pub fn index_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.index_name = Some(input.into());
            self
        }
        /// <p>The name of the partition index.</p>
        pub fn set_index_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.index_name = input;
            self
        }
        /// Consumes the builder and constructs a [`PartitionIndex`](crate::model::PartitionIndex).
        pub fn build(self) -> crate::model::PartitionIndex {
            crate::model::PartitionIndex {
                keys: self.keys,
                index_name: self.index_name,
            }
        }
    }
}
impl PartitionIndex {
    /// Creates a new builder-style object to manufacture [`PartitionIndex`](crate::model::PartitionIndex).
    pub fn builder() -> crate::model::partition_index::Builder {
        crate::model::partition_index::Builder::default()
    }
}

/// <p>Specifies a custom CSV classifier for <code>CreateClassifier</code> to create.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateCsvClassifierRequest {
    /// <p>The name of the classifier.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>A custom symbol to denote what separates each column entry in the row.</p>
    #[doc(hidden)]
    pub delimiter: std::option::Option<std::string::String>,
    /// <p>A custom symbol to denote what combines content into a single column value. Must be different from the column delimiter.</p>
    #[doc(hidden)]
    pub quote_symbol: std::option::Option<std::string::String>,
    /// <p>Indicates whether the CSV file contains a header.</p>
    #[doc(hidden)]
    pub contains_header: std::option::Option<crate::model::CsvHeaderOption>,
    /// <p>A list of strings representing column names.</p>
    #[doc(hidden)]
    pub header: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Specifies not to trim values before identifying the type of column values. The default value is true.</p>
    #[doc(hidden)]
    pub disable_value_trimming: std::option::Option<bool>,
    /// <p>Enables the processing of files that contain only one column.</p>
    #[doc(hidden)]
    pub allow_single_column: std::option::Option<bool>,
    /// <p>Enables the configuration of custom datatypes.</p>
    #[doc(hidden)]
    pub custom_datatype_configured: std::option::Option<bool>,
    /// <p>Creates a list of supported custom datatypes.</p>
    #[doc(hidden)]
    pub custom_datatypes: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl CreateCsvClassifierRequest {
    /// <p>The name of the classifier.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>A custom symbol to denote what separates each column entry in the row.</p>
    pub fn delimiter(&self) -> std::option::Option<&str> {
        self.delimiter.as_deref()
    }
    /// <p>A custom symbol to denote what combines content into a single column value. Must be different from the column delimiter.</p>
    pub fn quote_symbol(&self) -> std::option::Option<&str> {
        self.quote_symbol.as_deref()
    }
    /// <p>Indicates whether the CSV file contains a header.</p>
    pub fn contains_header(&self) -> std::option::Option<&crate::model::CsvHeaderOption> {
        self.contains_header.as_ref()
    }
    /// <p>A list of strings representing column names.</p>
    pub fn header(&self) -> std::option::Option<&[std::string::String]> {
        self.header.as_deref()
    }
    /// <p>Specifies not to trim values before identifying the type of column values. The default value is true.</p>
    pub fn disable_value_trimming(&self) -> std::option::Option<bool> {
        self.disable_value_trimming
    }
    /// <p>Enables the processing of files that contain only one column.</p>
    pub fn allow_single_column(&self) -> std::option::Option<bool> {
        self.allow_single_column
    }
    /// <p>Enables the configuration of custom datatypes.</p>
    pub fn custom_datatype_configured(&self) -> std::option::Option<bool> {
        self.custom_datatype_configured
    }
    /// <p>Creates a list of supported custom datatypes.</p>
    pub fn custom_datatypes(&self) -> std::option::Option<&[std::string::String]> {
        self.custom_datatypes.as_deref()
    }
}
/// See [`CreateCsvClassifierRequest`](crate::model::CreateCsvClassifierRequest).
pub mod create_csv_classifier_request {

    /// A builder for [`CreateCsvClassifierRequest`](crate::model::CreateCsvClassifierRequest).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) delimiter: std::option::Option<std::string::String>,
        pub(crate) quote_symbol: std::option::Option<std::string::String>,
        pub(crate) contains_header: std::option::Option<crate::model::CsvHeaderOption>,
        pub(crate) header: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) disable_value_trimming: std::option::Option<bool>,
        pub(crate) allow_single_column: std::option::Option<bool>,
        pub(crate) custom_datatype_configured: std::option::Option<bool>,
        pub(crate) custom_datatypes: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The name of the classifier.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the classifier.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>A custom symbol to denote what separates each column entry in the row.</p>
        pub fn delimiter(mut self, input: impl Into<std::string::String>) -> Self {
            self.delimiter = Some(input.into());
            self
        }
        /// <p>A custom symbol to denote what separates each column entry in the row.</p>
        pub fn set_delimiter(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.delimiter = input;
            self
        }
        /// <p>A custom symbol to denote what combines content into a single column value. Must be different from the column delimiter.</p>
        pub fn quote_symbol(mut self, input: impl Into<std::string::String>) -> Self {
            self.quote_symbol = Some(input.into());
            self
        }
        /// <p>A custom symbol to denote what combines content into a single column value. Must be different from the column delimiter.</p>
        pub fn set_quote_symbol(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.quote_symbol = input;
            self
        }
        /// <p>Indicates whether the CSV file contains a header.</p>
        pub fn contains_header(mut self, input: crate::model::CsvHeaderOption) -> Self {
            self.contains_header = Some(input);
            self
        }
        /// <p>Indicates whether the CSV file contains a header.</p>
        pub fn set_contains_header(
            mut self,
            input: std::option::Option<crate::model::CsvHeaderOption>,
        ) -> Self {
            self.contains_header = input;
            self
        }
        /// Appends an item to `header`.
        ///
        /// To override the contents of this collection use [`set_header`](Self::set_header).
        ///
        /// <p>A list of strings representing column names.</p>
        pub fn header(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.header.unwrap_or_default();
            v.push(input.into());
            self.header = Some(v);
            self
        }
        /// <p>A list of strings representing column names.</p>
        pub fn set_header(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.header = input;
            self
        }
        /// <p>Specifies not to trim values before identifying the type of column values. The default value is true.</p>
        pub fn disable_value_trimming(mut self, input: bool) -> Self {
            self.disable_value_trimming = Some(input);
            self
        }
        /// <p>Specifies not to trim values before identifying the type of column values. The default value is true.</p>
        pub fn set_disable_value_trimming(mut self, input: std::option::Option<bool>) -> Self {
            self.disable_value_trimming = input;
            self
        }
        /// <p>Enables the processing of files that contain only one column.</p>
        pub fn allow_single_column(mut self, input: bool) -> Self {
            self.allow_single_column = Some(input);
            self
        }
        /// <p>Enables the processing of files that contain only one column.</p>
        pub fn set_allow_single_column(mut self, input: std::option::Option<bool>) -> Self {
            self.allow_single_column = input;
            self
        }
        /// <p>Enables the configuration of custom datatypes.</p>
        pub fn custom_datatype_configured(mut self, input: bool) -> Self {
            self.custom_datatype_configured = Some(input);
            self
        }
        /// <p>Enables the configuration of custom datatypes.</p>
        pub fn set_custom_datatype_configured(mut self, input: std::option::Option<bool>) -> Self {
            self.custom_datatype_configured = input;
            self
        }
        /// Appends an item to `custom_datatypes`.
        ///
        /// To override the contents of this collection use [`set_custom_datatypes`](Self::set_custom_datatypes).
        ///
        /// <p>Creates a list of supported custom datatypes.</p>
        pub fn custom_datatypes(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.custom_datatypes.unwrap_or_default();
            v.push(input.into());
            self.custom_datatypes = Some(v);
            self
        }
        /// <p>Creates a list of supported custom datatypes.</p>
        pub fn set_custom_datatypes(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.custom_datatypes = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateCsvClassifierRequest`](crate::model::CreateCsvClassifierRequest).
        pub fn build(self) -> crate::model::CreateCsvClassifierRequest {
            crate::model::CreateCsvClassifierRequest {
                name: self.name,
                delimiter: self.delimiter,
                quote_symbol: self.quote_symbol,
                contains_header: self.contains_header,
                header: self.header,
                disable_value_trimming: self.disable_value_trimming,
                allow_single_column: self.allow_single_column,
                custom_datatype_configured: self.custom_datatype_configured,
                custom_datatypes: self.custom_datatypes,
            }
        }
    }
}
impl CreateCsvClassifierRequest {
    /// Creates a new builder-style object to manufacture [`CreateCsvClassifierRequest`](crate::model::CreateCsvClassifierRequest).
    pub fn builder() -> crate::model::create_csv_classifier_request::Builder {
        crate::model::create_csv_classifier_request::Builder::default()
    }
}

/// <p>Specifies a JSON classifier for <code>CreateClassifier</code> to create.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateJsonClassifierRequest {
    /// <p>The name of the classifier.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>A <code>JsonPath</code> string defining the JSON data for the classifier to classify. Glue supports a subset of JsonPath, as described in <a href="https://docs.aws.amazon.com/glue/latest/dg/custom-classifier.html#custom-classifier-json">Writing JsonPath Custom Classifiers</a>.</p>
    #[doc(hidden)]
    pub json_path: std::option::Option<std::string::String>,
}
impl CreateJsonClassifierRequest {
    /// <p>The name of the classifier.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>A <code>JsonPath</code> string defining the JSON data for the classifier to classify. Glue supports a subset of JsonPath, as described in <a href="https://docs.aws.amazon.com/glue/latest/dg/custom-classifier.html#custom-classifier-json">Writing JsonPath Custom Classifiers</a>.</p>
    pub fn json_path(&self) -> std::option::Option<&str> {
        self.json_path.as_deref()
    }
}
/// See [`CreateJsonClassifierRequest`](crate::model::CreateJsonClassifierRequest).
pub mod create_json_classifier_request {

    /// A builder for [`CreateJsonClassifierRequest`](crate::model::CreateJsonClassifierRequest).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) json_path: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the classifier.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the classifier.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>A <code>JsonPath</code> string defining the JSON data for the classifier to classify. Glue supports a subset of JsonPath, as described in <a href="https://docs.aws.amazon.com/glue/latest/dg/custom-classifier.html#custom-classifier-json">Writing JsonPath Custom Classifiers</a>.</p>
        pub fn json_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.json_path = Some(input.into());
            self
        }
        /// <p>A <code>JsonPath</code> string defining the JSON data for the classifier to classify. Glue supports a subset of JsonPath, as described in <a href="https://docs.aws.amazon.com/glue/latest/dg/custom-classifier.html#custom-classifier-json">Writing JsonPath Custom Classifiers</a>.</p>
        pub fn set_json_path(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.json_path = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateJsonClassifierRequest`](crate::model::CreateJsonClassifierRequest).
        pub fn build(self) -> crate::model::CreateJsonClassifierRequest {
            crate::model::CreateJsonClassifierRequest {
                name: self.name,
                json_path: self.json_path,
            }
        }
    }
}
impl CreateJsonClassifierRequest {
    /// Creates a new builder-style object to manufacture [`CreateJsonClassifierRequest`](crate::model::CreateJsonClassifierRequest).
    pub fn builder() -> crate::model::create_json_classifier_request::Builder {
        crate::model::create_json_classifier_request::Builder::default()
    }
}

/// <p>Specifies an XML classifier for <code>CreateClassifier</code> to create.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateXmlClassifierRequest {
    /// <p>An identifier of the data format that the classifier matches.</p>
    #[doc(hidden)]
    pub classification: std::option::Option<std::string::String>,
    /// <p>The name of the classifier.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The XML tag designating the element that contains each record in an XML document being parsed. This can't identify a self-closing element (closed by <code>/&gt;</code>). An empty row element that contains only attributes can be parsed as long as it ends with a closing tag (for example, <code>
    /// <row item_a="A" item_b="B" /></code> is okay, but <code>
    /// <row item_a="A" item_b="B" /></code> is not).</p>
    #[doc(hidden)]
    pub row_tag: std::option::Option<std::string::String>,
}
impl CreateXmlClassifierRequest {
    /// <p>An identifier of the data format that the classifier matches.</p>
    pub fn classification(&self) -> std::option::Option<&str> {
        self.classification.as_deref()
    }
    /// <p>The name of the classifier.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The XML tag designating the element that contains each record in an XML document being parsed. This can't identify a self-closing element (closed by <code>/&gt;</code>). An empty row element that contains only attributes can be parsed as long as it ends with a closing tag (for example, <code>
    /// <row item_a="A" item_b="B" /></code> is okay, but <code>
    /// <row item_a="A" item_b="B" /></code> is not).</p>
    pub fn row_tag(&self) -> std::option::Option<&str> {
        self.row_tag.as_deref()
    }
}
/// See [`CreateXmlClassifierRequest`](crate::model::CreateXmlClassifierRequest).
pub mod create_xml_classifier_request {

    /// A builder for [`CreateXmlClassifierRequest`](crate::model::CreateXmlClassifierRequest).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) classification: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) row_tag: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>An identifier of the data format that the classifier matches.</p>
        pub fn classification(mut self, input: impl Into<std::string::String>) -> Self {
            self.classification = Some(input.into());
            self
        }
        /// <p>An identifier of the data format that the classifier matches.</p>
        pub fn set_classification(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.classification = input;
            self
        }
        /// <p>The name of the classifier.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the classifier.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The XML tag designating the element that contains each record in an XML document being parsed. This can't identify a self-closing element (closed by <code>/&gt;</code>). An empty row element that contains only attributes can be parsed as long as it ends with a closing tag (for example, <code>
        /// <row item_a="A" item_b="B" /></code> is okay, but <code>
        /// <row item_a="A" item_b="B" /></code> is not).</p>
        pub fn row_tag(mut self, input: impl Into<std::string::String>) -> Self {
            self.row_tag = Some(input.into());
            self
        }
        /// <p>The XML tag designating the element that contains each record in an XML document being parsed. This can't identify a self-closing element (closed by <code>/&gt;</code>). An empty row element that contains only attributes can be parsed as long as it ends with a closing tag (for example, <code>
        /// <row item_a="A" item_b="B" /></code> is okay, but <code>
        /// <row item_a="A" item_b="B" /></code> is not).</p>
        pub fn set_row_tag(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.row_tag = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateXmlClassifierRequest`](crate::model::CreateXmlClassifierRequest).
        pub fn build(self) -> crate::model::CreateXmlClassifierRequest {
            crate::model::CreateXmlClassifierRequest {
                classification: self.classification,
                name: self.name,
                row_tag: self.row_tag,
            }
        }
    }
}
impl CreateXmlClassifierRequest {
    /// Creates a new builder-style object to manufacture [`CreateXmlClassifierRequest`](crate::model::CreateXmlClassifierRequest).
    pub fn builder() -> crate::model::create_xml_classifier_request::Builder {
        crate::model::create_xml_classifier_request::Builder::default()
    }
}

/// <p>Specifies a <code>grok</code> classifier for <code>CreateClassifier</code> to create.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateGrokClassifierRequest {
    /// <p>An identifier of the data format that the classifier matches, such as Twitter, JSON, Omniture logs, Amazon CloudWatch Logs, and so on.</p>
    #[doc(hidden)]
    pub classification: std::option::Option<std::string::String>,
    /// <p>The name of the new classifier.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The grok pattern used by this classifier.</p>
    #[doc(hidden)]
    pub grok_pattern: std::option::Option<std::string::String>,
    /// <p>Optional custom grok patterns used by this classifier.</p>
    #[doc(hidden)]
    pub custom_patterns: std::option::Option<std::string::String>,
}
impl CreateGrokClassifierRequest {
    /// <p>An identifier of the data format that the classifier matches, such as Twitter, JSON, Omniture logs, Amazon CloudWatch Logs, and so on.</p>
    pub fn classification(&self) -> std::option::Option<&str> {
        self.classification.as_deref()
    }
    /// <p>The name of the new classifier.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The grok pattern used by this classifier.</p>
    pub fn grok_pattern(&self) -> std::option::Option<&str> {
        self.grok_pattern.as_deref()
    }
    /// <p>Optional custom grok patterns used by this classifier.</p>
    pub fn custom_patterns(&self) -> std::option::Option<&str> {
        self.custom_patterns.as_deref()
    }
}
/// See [`CreateGrokClassifierRequest`](crate::model::CreateGrokClassifierRequest).
pub mod create_grok_classifier_request {

    /// A builder for [`CreateGrokClassifierRequest`](crate::model::CreateGrokClassifierRequest).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) classification: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) grok_pattern: std::option::Option<std::string::String>,
        pub(crate) custom_patterns: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>An identifier of the data format that the classifier matches, such as Twitter, JSON, Omniture logs, Amazon CloudWatch Logs, and so on.</p>
        pub fn classification(mut self, input: impl Into<std::string::String>) -> Self {
            self.classification = Some(input.into());
            self
        }
        /// <p>An identifier of the data format that the classifier matches, such as Twitter, JSON, Omniture logs, Amazon CloudWatch Logs, and so on.</p>
        pub fn set_classification(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.classification = input;
            self
        }
        /// <p>The name of the new classifier.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the new classifier.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The grok pattern used by this classifier.</p>
        pub fn grok_pattern(mut self, input: impl Into<std::string::String>) -> Self {
            self.grok_pattern = Some(input.into());
            self
        }
        /// <p>The grok pattern used by this classifier.</p>
        pub fn set_grok_pattern(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.grok_pattern = input;
            self
        }
        /// <p>Optional custom grok patterns used by this classifier.</p>
        pub fn custom_patterns(mut self, input: impl Into<std::string::String>) -> Self {
            self.custom_patterns = Some(input.into());
            self
        }
        /// <p>Optional custom grok patterns used by this classifier.</p>
        pub fn set_custom_patterns(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.custom_patterns = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateGrokClassifierRequest`](crate::model::CreateGrokClassifierRequest).
        pub fn build(self) -> crate::model::CreateGrokClassifierRequest {
            crate::model::CreateGrokClassifierRequest {
                classification: self.classification,
                name: self.name,
                grok_pattern: self.grok_pattern,
                custom_patterns: self.custom_patterns,
            }
        }
    }
}
impl CreateGrokClassifierRequest {
    /// Creates a new builder-style object to manufacture [`CreateGrokClassifierRequest`](crate::model::CreateGrokClassifierRequest).
    pub fn builder() -> crate::model::create_grok_classifier_request::Builder {
        crate::model::create_grok_classifier_request::Builder::default()
    }
}

/// <p>Contains information about a batch update partition error.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BatchUpdatePartitionFailureEntry {
    /// <p>A list of values defining the partitions.</p>
    #[doc(hidden)]
    pub partition_value_list: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The details about the batch update partition error.</p>
    #[doc(hidden)]
    pub error_detail: std::option::Option<crate::model::ErrorDetail>,
}
impl BatchUpdatePartitionFailureEntry {
    /// <p>A list of values defining the partitions.</p>
    pub fn partition_value_list(&self) -> std::option::Option<&[std::string::String]> {
        self.partition_value_list.as_deref()
    }
    /// <p>The details about the batch update partition error.</p>
    pub fn error_detail(&self) -> std::option::Option<&crate::model::ErrorDetail> {
        self.error_detail.as_ref()
    }
}
/// See [`BatchUpdatePartitionFailureEntry`](crate::model::BatchUpdatePartitionFailureEntry).
pub mod batch_update_partition_failure_entry {

    /// A builder for [`BatchUpdatePartitionFailureEntry`](crate::model::BatchUpdatePartitionFailureEntry).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) partition_value_list: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) error_detail: std::option::Option<crate::model::ErrorDetail>,
    }
    impl Builder {
        /// Appends an item to `partition_value_list`.
        ///
        /// To override the contents of this collection use [`set_partition_value_list`](Self::set_partition_value_list).
        ///
        /// <p>A list of values defining the partitions.</p>
        pub fn partition_value_list(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.partition_value_list.unwrap_or_default();
            v.push(input.into());
            self.partition_value_list = Some(v);
            self
        }
        /// <p>A list of values defining the partitions.</p>
        pub fn set_partition_value_list(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.partition_value_list = input;
            self
        }
        /// <p>The details about the batch update partition error.</p>
        pub fn error_detail(mut self, input: crate::model::ErrorDetail) -> Self {
            self.error_detail = Some(input);
            self
        }
        /// <p>The details about the batch update partition error.</p>
        pub fn set_error_detail(
            mut self,
            input: std::option::Option<crate::model::ErrorDetail>,
        ) -> Self {
            self.error_detail = input;
            self
        }
        /// Consumes the builder and constructs a [`BatchUpdatePartitionFailureEntry`](crate::model::BatchUpdatePartitionFailureEntry).
        pub fn build(self) -> crate::model::BatchUpdatePartitionFailureEntry {
            crate::model::BatchUpdatePartitionFailureEntry {
                partition_value_list: self.partition_value_list,
                error_detail: self.error_detail,
            }
        }
    }
}
impl BatchUpdatePartitionFailureEntry {
    /// Creates a new builder-style object to manufacture [`BatchUpdatePartitionFailureEntry`](crate::model::BatchUpdatePartitionFailureEntry).
    pub fn builder() -> crate::model::batch_update_partition_failure_entry::Builder {
        crate::model::batch_update_partition_failure_entry::Builder::default()
    }
}

/// <p>A structure that contains the values and structure used to update a partition.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BatchUpdatePartitionRequestEntry {
    /// <p>A list of values defining the partitions.</p>
    #[doc(hidden)]
    pub partition_value_list: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The structure used to update a partition.</p>
    #[doc(hidden)]
    pub partition_input: std::option::Option<crate::model::PartitionInput>,
}
impl BatchUpdatePartitionRequestEntry {
    /// <p>A list of values defining the partitions.</p>
    pub fn partition_value_list(&self) -> std::option::Option<&[std::string::String]> {
        self.partition_value_list.as_deref()
    }
    /// <p>The structure used to update a partition.</p>
    pub fn partition_input(&self) -> std::option::Option<&crate::model::PartitionInput> {
        self.partition_input.as_ref()
    }
}
/// See [`BatchUpdatePartitionRequestEntry`](crate::model::BatchUpdatePartitionRequestEntry).
pub mod batch_update_partition_request_entry {

    /// A builder for [`BatchUpdatePartitionRequestEntry`](crate::model::BatchUpdatePartitionRequestEntry).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) partition_value_list: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) partition_input: std::option::Option<crate::model::PartitionInput>,
    }
    impl Builder {
        /// Appends an item to `partition_value_list`.
        ///
        /// To override the contents of this collection use [`set_partition_value_list`](Self::set_partition_value_list).
        ///
        /// <p>A list of values defining the partitions.</p>
        pub fn partition_value_list(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.partition_value_list.unwrap_or_default();
            v.push(input.into());
            self.partition_value_list = Some(v);
            self
        }
        /// <p>A list of values defining the partitions.</p>
        pub fn set_partition_value_list(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.partition_value_list = input;
            self
        }
        /// <p>The structure used to update a partition.</p>
        pub fn partition_input(mut self, input: crate::model::PartitionInput) -> Self {
            self.partition_input = Some(input);
            self
        }
        /// <p>The structure used to update a partition.</p>
        pub fn set_partition_input(
            mut self,
            input: std::option::Option<crate::model::PartitionInput>,
        ) -> Self {
            self.partition_input = input;
            self
        }
        /// Consumes the builder and constructs a [`BatchUpdatePartitionRequestEntry`](crate::model::BatchUpdatePartitionRequestEntry).
        pub fn build(self) -> crate::model::BatchUpdatePartitionRequestEntry {
            crate::model::BatchUpdatePartitionRequestEntry {
                partition_value_list: self.partition_value_list,
                partition_input: self.partition_input,
            }
        }
    }
}
impl BatchUpdatePartitionRequestEntry {
    /// Creates a new builder-style object to manufacture [`BatchUpdatePartitionRequestEntry`](crate::model::BatchUpdatePartitionRequestEntry).
    pub fn builder() -> crate::model::batch_update_partition_request_entry::Builder {
        crate::model::batch_update_partition_request_entry::Builder::default()
    }
}

/// <p>Records an error that occurred when attempting to stop a specified job run.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BatchStopJobRunError {
    /// <p>The name of the job definition that is used in the job run in question.</p>
    #[doc(hidden)]
    pub job_name: std::option::Option<std::string::String>,
    /// <p>The <code>JobRunId</code> of the job run in question.</p>
    #[doc(hidden)]
    pub job_run_id: std::option::Option<std::string::String>,
    /// <p>Specifies details about the error that was encountered.</p>
    #[doc(hidden)]
    pub error_detail: std::option::Option<crate::model::ErrorDetail>,
}
impl BatchStopJobRunError {
    /// <p>The name of the job definition that is used in the job run in question.</p>
    pub fn job_name(&self) -> std::option::Option<&str> {
        self.job_name.as_deref()
    }
    /// <p>The <code>JobRunId</code> of the job run in question.</p>
    pub fn job_run_id(&self) -> std::option::Option<&str> {
        self.job_run_id.as_deref()
    }
    /// <p>Specifies details about the error that was encountered.</p>
    pub fn error_detail(&self) -> std::option::Option<&crate::model::ErrorDetail> {
        self.error_detail.as_ref()
    }
}
/// See [`BatchStopJobRunError`](crate::model::BatchStopJobRunError).
pub mod batch_stop_job_run_error {

    /// A builder for [`BatchStopJobRunError`](crate::model::BatchStopJobRunError).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) job_name: std::option::Option<std::string::String>,
        pub(crate) job_run_id: std::option::Option<std::string::String>,
        pub(crate) error_detail: std::option::Option<crate::model::ErrorDetail>,
    }
    impl Builder {
        /// <p>The name of the job definition that is used in the job run in question.</p>
        pub fn job_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_name = Some(input.into());
            self
        }
        /// <p>The name of the job definition that is used in the job run in question.</p>
        pub fn set_job_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_name = input;
            self
        }
        /// <p>The <code>JobRunId</code> of the job run in question.</p>
        pub fn job_run_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_run_id = Some(input.into());
            self
        }
        /// <p>The <code>JobRunId</code> of the job run in question.</p>
        pub fn set_job_run_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_run_id = input;
            self
        }
        /// <p>Specifies details about the error that was encountered.</p>
        pub fn error_detail(mut self, input: crate::model::ErrorDetail) -> Self {
            self.error_detail = Some(input);
            self
        }
        /// <p>Specifies details about the error that was encountered.</p>
        pub fn set_error_detail(
            mut self,
            input: std::option::Option<crate::model::ErrorDetail>,
        ) -> Self {
            self.error_detail = input;
            self
        }
        /// Consumes the builder and constructs a [`BatchStopJobRunError`](crate::model::BatchStopJobRunError).
        pub fn build(self) -> crate::model::BatchStopJobRunError {
            crate::model::BatchStopJobRunError {
                job_name: self.job_name,
                job_run_id: self.job_run_id,
                error_detail: self.error_detail,
            }
        }
    }
}
impl BatchStopJobRunError {
    /// Creates a new builder-style object to manufacture [`BatchStopJobRunError`](crate::model::BatchStopJobRunError).
    pub fn builder() -> crate::model::batch_stop_job_run_error::Builder {
        crate::model::batch_stop_job_run_error::Builder::default()
    }
}

/// <p>Records a successful request to stop a specified <code>JobRun</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BatchStopJobRunSuccessfulSubmission {
    /// <p>The name of the job definition used in the job run that was stopped.</p>
    #[doc(hidden)]
    pub job_name: std::option::Option<std::string::String>,
    /// <p>The <code>JobRunId</code> of the job run that was stopped.</p>
    #[doc(hidden)]
    pub job_run_id: std::option::Option<std::string::String>,
}
impl BatchStopJobRunSuccessfulSubmission {
    /// <p>The name of the job definition used in the job run that was stopped.</p>
    pub fn job_name(&self) -> std::option::Option<&str> {
        self.job_name.as_deref()
    }
    /// <p>The <code>JobRunId</code> of the job run that was stopped.</p>
    pub fn job_run_id(&self) -> std::option::Option<&str> {
        self.job_run_id.as_deref()
    }
}
/// See [`BatchStopJobRunSuccessfulSubmission`](crate::model::BatchStopJobRunSuccessfulSubmission).
pub mod batch_stop_job_run_successful_submission {

    /// A builder for [`BatchStopJobRunSuccessfulSubmission`](crate::model::BatchStopJobRunSuccessfulSubmission).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) job_name: std::option::Option<std::string::String>,
        pub(crate) job_run_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the job definition used in the job run that was stopped.</p>
        pub fn job_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_name = Some(input.into());
            self
        }
        /// <p>The name of the job definition used in the job run that was stopped.</p>
        pub fn set_job_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_name = input;
            self
        }
        /// <p>The <code>JobRunId</code> of the job run that was stopped.</p>
        pub fn job_run_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_run_id = Some(input.into());
            self
        }
        /// <p>The <code>JobRunId</code> of the job run that was stopped.</p>
        pub fn set_job_run_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_run_id = input;
            self
        }
        /// Consumes the builder and constructs a [`BatchStopJobRunSuccessfulSubmission`](crate::model::BatchStopJobRunSuccessfulSubmission).
        pub fn build(self) -> crate::model::BatchStopJobRunSuccessfulSubmission {
            crate::model::BatchStopJobRunSuccessfulSubmission {
                job_name: self.job_name,
                job_run_id: self.job_run_id,
            }
        }
    }
}
impl BatchStopJobRunSuccessfulSubmission {
    /// Creates a new builder-style object to manufacture [`BatchStopJobRunSuccessfulSubmission`](crate::model::BatchStopJobRunSuccessfulSubmission).
    pub fn builder() -> crate::model::batch_stop_job_run_successful_submission::Builder {
        crate::model::batch_stop_job_run_successful_submission::Builder::default()
    }
}

/// <p>Describes a data quality result.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DataQualityResult {
    /// <p>A unique result ID for the data quality result.</p>
    #[doc(hidden)]
    pub result_id: std::option::Option<std::string::String>,
    /// <p>An aggregate data quality score. Represents the ratio of rules that passed to the total number of rules.</p>
    #[doc(hidden)]
    pub score: std::option::Option<f64>,
    /// <p>The table associated with the data quality result, if any.</p>
    #[doc(hidden)]
    pub data_source: std::option::Option<crate::model::DataSource>,
    /// <p>The name of the ruleset associated with the data quality result.</p>
    #[doc(hidden)]
    pub ruleset_name: std::option::Option<std::string::String>,
    /// <p>In the context of a job in Glue Studio, each node in the canvas is typically assigned some sort of name and data quality nodes will have names. In the case of multiple nodes, the <code>evaluationContext</code> can differentiate the nodes.</p>
    #[doc(hidden)]
    pub evaluation_context: std::option::Option<std::string::String>,
    /// <p>The date and time when this data quality run started.</p>
    #[doc(hidden)]
    pub started_on: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The date and time when this data quality run completed.</p>
    #[doc(hidden)]
    pub completed_on: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The job name associated with the data quality result, if any.</p>
    #[doc(hidden)]
    pub job_name: std::option::Option<std::string::String>,
    /// <p>The job run ID associated with the data quality result, if any.</p>
    #[doc(hidden)]
    pub job_run_id: std::option::Option<std::string::String>,
    /// <p>The unique run ID for the ruleset evaluation for this data quality result.</p>
    #[doc(hidden)]
    pub ruleset_evaluation_run_id: std::option::Option<std::string::String>,
    /// <p>A list of <code>DataQualityRuleResult</code> objects representing the results for each rule. </p>
    #[doc(hidden)]
    pub rule_results: std::option::Option<std::vec::Vec<crate::model::DataQualityRuleResult>>,
}
impl DataQualityResult {
    /// <p>A unique result ID for the data quality result.</p>
    pub fn result_id(&self) -> std::option::Option<&str> {
        self.result_id.as_deref()
    }
    /// <p>An aggregate data quality score. Represents the ratio of rules that passed to the total number of rules.</p>
    pub fn score(&self) -> std::option::Option<f64> {
        self.score
    }
    /// <p>The table associated with the data quality result, if any.</p>
    pub fn data_source(&self) -> std::option::Option<&crate::model::DataSource> {
        self.data_source.as_ref()
    }
    /// <p>The name of the ruleset associated with the data quality result.</p>
    pub fn ruleset_name(&self) -> std::option::Option<&str> {
        self.ruleset_name.as_deref()
    }
    /// <p>In the context of a job in Glue Studio, each node in the canvas is typically assigned some sort of name and data quality nodes will have names. In the case of multiple nodes, the <code>evaluationContext</code> can differentiate the nodes.</p>
    pub fn evaluation_context(&self) -> std::option::Option<&str> {
        self.evaluation_context.as_deref()
    }
    /// <p>The date and time when this data quality run started.</p>
    pub fn started_on(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.started_on.as_ref()
    }
    /// <p>The date and time when this data quality run completed.</p>
    pub fn completed_on(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.completed_on.as_ref()
    }
    /// <p>The job name associated with the data quality result, if any.</p>
    pub fn job_name(&self) -> std::option::Option<&str> {
        self.job_name.as_deref()
    }
    /// <p>The job run ID associated with the data quality result, if any.</p>
    pub fn job_run_id(&self) -> std::option::Option<&str> {
        self.job_run_id.as_deref()
    }
    /// <p>The unique run ID for the ruleset evaluation for this data quality result.</p>
    pub fn ruleset_evaluation_run_id(&self) -> std::option::Option<&str> {
        self.ruleset_evaluation_run_id.as_deref()
    }
    /// <p>A list of <code>DataQualityRuleResult</code> objects representing the results for each rule. </p>
    pub fn rule_results(&self) -> std::option::Option<&[crate::model::DataQualityRuleResult]> {
        self.rule_results.as_deref()
    }
}
/// See [`DataQualityResult`](crate::model::DataQualityResult).
pub mod data_quality_result {

    /// A builder for [`DataQualityResult`](crate::model::DataQualityResult).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) result_id: std::option::Option<std::string::String>,
        pub(crate) score: std::option::Option<f64>,
        pub(crate) data_source: std::option::Option<crate::model::DataSource>,
        pub(crate) ruleset_name: std::option::Option<std::string::String>,
        pub(crate) evaluation_context: std::option::Option<std::string::String>,
        pub(crate) started_on: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) completed_on: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) job_name: std::option::Option<std::string::String>,
        pub(crate) job_run_id: std::option::Option<std::string::String>,
        pub(crate) ruleset_evaluation_run_id: std::option::Option<std::string::String>,
        pub(crate) rule_results:
            std::option::Option<std::vec::Vec<crate::model::DataQualityRuleResult>>,
    }
    impl Builder {
        /// <p>A unique result ID for the data quality result.</p>
        pub fn result_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.result_id = Some(input.into());
            self
        }
        /// <p>A unique result ID for the data quality result.</p>
        pub fn set_result_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.result_id = input;
            self
        }
        /// <p>An aggregate data quality score. Represents the ratio of rules that passed to the total number of rules.</p>
        pub fn score(mut self, input: f64) -> Self {
            self.score = Some(input);
            self
        }
        /// <p>An aggregate data quality score. Represents the ratio of rules that passed to the total number of rules.</p>
        pub fn set_score(mut self, input: std::option::Option<f64>) -> Self {
            self.score = input;
            self
        }
        /// <p>The table associated with the data quality result, if any.</p>
        pub fn data_source(mut self, input: crate::model::DataSource) -> Self {
            self.data_source = Some(input);
            self
        }
        /// <p>The table associated with the data quality result, if any.</p>
        pub fn set_data_source(
            mut self,
            input: std::option::Option<crate::model::DataSource>,
        ) -> Self {
            self.data_source = input;
            self
        }
        /// <p>The name of the ruleset associated with the data quality result.</p>
        pub fn ruleset_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.ruleset_name = Some(input.into());
            self
        }
        /// <p>The name of the ruleset associated with the data quality result.</p>
        pub fn set_ruleset_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.ruleset_name = input;
            self
        }
        /// <p>In the context of a job in Glue Studio, each node in the canvas is typically assigned some sort of name and data quality nodes will have names. In the case of multiple nodes, the <code>evaluationContext</code> can differentiate the nodes.</p>
        pub fn evaluation_context(mut self, input: impl Into<std::string::String>) -> Self {
            self.evaluation_context = Some(input.into());
            self
        }
        /// <p>In the context of a job in Glue Studio, each node in the canvas is typically assigned some sort of name and data quality nodes will have names. In the case of multiple nodes, the <code>evaluationContext</code> can differentiate the nodes.</p>
        pub fn set_evaluation_context(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.evaluation_context = input;
            self
        }
        /// <p>The date and time when this data quality run started.</p>
        pub fn started_on(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.started_on = Some(input);
            self
        }
        /// <p>The date and time when this data quality run started.</p>
        pub fn set_started_on(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.started_on = input;
            self
        }
        /// <p>The date and time when this data quality run completed.</p>
        pub fn completed_on(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.completed_on = Some(input);
            self
        }
        /// <p>The date and time when this data quality run completed.</p>
        pub fn set_completed_on(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.completed_on = input;
            self
        }
        /// <p>The job name associated with the data quality result, if any.</p>
        pub fn job_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_name = Some(input.into());
            self
        }
        /// <p>The job name associated with the data quality result, if any.</p>
        pub fn set_job_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_name = input;
            self
        }
        /// <p>The job run ID associated with the data quality result, if any.</p>
        pub fn job_run_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_run_id = Some(input.into());
            self
        }
        /// <p>The job run ID associated with the data quality result, if any.</p>
        pub fn set_job_run_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_run_id = input;
            self
        }
        /// <p>The unique run ID for the ruleset evaluation for this data quality result.</p>
        pub fn ruleset_evaluation_run_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.ruleset_evaluation_run_id = Some(input.into());
            self
        }
        /// <p>The unique run ID for the ruleset evaluation for this data quality result.</p>
        pub fn set_ruleset_evaluation_run_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.ruleset_evaluation_run_id = input;
            self
        }
        /// Appends an item to `rule_results`.
        ///
        /// To override the contents of this collection use [`set_rule_results`](Self::set_rule_results).
        ///
        /// <p>A list of <code>DataQualityRuleResult</code> objects representing the results for each rule. </p>
        pub fn rule_results(mut self, input: crate::model::DataQualityRuleResult) -> Self {
            let mut v = self.rule_results.unwrap_or_default();
            v.push(input);
            self.rule_results = Some(v);
            self
        }
        /// <p>A list of <code>DataQualityRuleResult</code> objects representing the results for each rule. </p>
        pub fn set_rule_results(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DataQualityRuleResult>>,
        ) -> Self {
            self.rule_results = input;
            self
        }
        /// Consumes the builder and constructs a [`DataQualityResult`](crate::model::DataQualityResult).
        pub fn build(self) -> crate::model::DataQualityResult {
            crate::model::DataQualityResult {
                result_id: self.result_id,
                score: self.score,
                data_source: self.data_source,
                ruleset_name: self.ruleset_name,
                evaluation_context: self.evaluation_context,
                started_on: self.started_on,
                completed_on: self.completed_on,
                job_name: self.job_name,
                job_run_id: self.job_run_id,
                ruleset_evaluation_run_id: self.ruleset_evaluation_run_id,
                rule_results: self.rule_results,
            }
        }
    }
}
impl DataQualityResult {
    /// Creates a new builder-style object to manufacture [`DataQualityResult`](crate::model::DataQualityResult).
    pub fn builder() -> crate::model::data_quality_result::Builder {
        crate::model::data_quality_result::Builder::default()
    }
}

/// <p>An error record for table-version operations.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TableVersionError {
    /// <p>The name of the table in question.</p>
    #[doc(hidden)]
    pub table_name: std::option::Option<std::string::String>,
    /// <p>The ID value of the version in question. A <code>VersionID</code> is a string representation of an integer. Each version is incremented by 1.</p>
    #[doc(hidden)]
    pub version_id: std::option::Option<std::string::String>,
    /// <p>The details about the error.</p>
    #[doc(hidden)]
    pub error_detail: std::option::Option<crate::model::ErrorDetail>,
}
impl TableVersionError {
    /// <p>The name of the table in question.</p>
    pub fn table_name(&self) -> std::option::Option<&str> {
        self.table_name.as_deref()
    }
    /// <p>The ID value of the version in question. A <code>VersionID</code> is a string representation of an integer. Each version is incremented by 1.</p>
    pub fn version_id(&self) -> std::option::Option<&str> {
        self.version_id.as_deref()
    }
    /// <p>The details about the error.</p>
    pub fn error_detail(&self) -> std::option::Option<&crate::model::ErrorDetail> {
        self.error_detail.as_ref()
    }
}
/// See [`TableVersionError`](crate::model::TableVersionError).
pub mod table_version_error {

    /// A builder for [`TableVersionError`](crate::model::TableVersionError).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) table_name: std::option::Option<std::string::String>,
        pub(crate) version_id: std::option::Option<std::string::String>,
        pub(crate) error_detail: std::option::Option<crate::model::ErrorDetail>,
    }
    impl Builder {
        /// <p>The name of the table in question.</p>
        pub fn table_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.table_name = Some(input.into());
            self
        }
        /// <p>The name of the table in question.</p>
        pub fn set_table_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.table_name = input;
            self
        }
        /// <p>The ID value of the version in question. A <code>VersionID</code> is a string representation of an integer. Each version is incremented by 1.</p>
        pub fn version_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.version_id = Some(input.into());
            self
        }
        /// <p>The ID value of the version in question. A <code>VersionID</code> is a string representation of an integer. Each version is incremented by 1.</p>
        pub fn set_version_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.version_id = input;
            self
        }
        /// <p>The details about the error.</p>
        pub fn error_detail(mut self, input: crate::model::ErrorDetail) -> Self {
            self.error_detail = Some(input);
            self
        }
        /// <p>The details about the error.</p>
        pub fn set_error_detail(
            mut self,
            input: std::option::Option<crate::model::ErrorDetail>,
        ) -> Self {
            self.error_detail = input;
            self
        }
        /// Consumes the builder and constructs a [`TableVersionError`](crate::model::TableVersionError).
        pub fn build(self) -> crate::model::TableVersionError {
            crate::model::TableVersionError {
                table_name: self.table_name,
                version_id: self.version_id,
                error_detail: self.error_detail,
            }
        }
    }
}
impl TableVersionError {
    /// Creates a new builder-style object to manufacture [`TableVersionError`](crate::model::TableVersionError).
    pub fn builder() -> crate::model::table_version_error::Builder {
        crate::model::table_version_error::Builder::default()
    }
}

/// <p>An error record for table operations.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TableError {
    /// <p>The name of the table. For Hive compatibility, this must be entirely lowercase.</p>
    #[doc(hidden)]
    pub table_name: std::option::Option<std::string::String>,
    /// <p>The details about the error.</p>
    #[doc(hidden)]
    pub error_detail: std::option::Option<crate::model::ErrorDetail>,
}
impl TableError {
    /// <p>The name of the table. For Hive compatibility, this must be entirely lowercase.</p>
    pub fn table_name(&self) -> std::option::Option<&str> {
        self.table_name.as_deref()
    }
    /// <p>The details about the error.</p>
    pub fn error_detail(&self) -> std::option::Option<&crate::model::ErrorDetail> {
        self.error_detail.as_ref()
    }
}
/// See [`TableError`](crate::model::TableError).
pub mod table_error {

    /// A builder for [`TableError`](crate::model::TableError).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) table_name: std::option::Option<std::string::String>,
        pub(crate) error_detail: std::option::Option<crate::model::ErrorDetail>,
    }
    impl Builder {
        /// <p>The name of the table. For Hive compatibility, this must be entirely lowercase.</p>
        pub fn table_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.table_name = Some(input.into());
            self
        }
        /// <p>The name of the table. For Hive compatibility, this must be entirely lowercase.</p>
        pub fn set_table_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.table_name = input;
            self
        }
        /// <p>The details about the error.</p>
        pub fn error_detail(mut self, input: crate::model::ErrorDetail) -> Self {
            self.error_detail = Some(input);
            self
        }
        /// <p>The details about the error.</p>
        pub fn set_error_detail(
            mut self,
            input: std::option::Option<crate::model::ErrorDetail>,
        ) -> Self {
            self.error_detail = input;
            self
        }
        /// Consumes the builder and constructs a [`TableError`](crate::model::TableError).
        pub fn build(self) -> crate::model::TableError {
            crate::model::TableError {
                table_name: self.table_name,
                error_detail: self.error_detail,
            }
        }
    }
}
impl TableError {
    /// Creates a new builder-style object to manufacture [`TableError`](crate::model::TableError).
    pub fn builder() -> crate::model::table_error::Builder {
        crate::model::table_error::Builder::default()
    }
}

/// <p>Contains information about a partition error.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PartitionError {
    /// <p>The values that define the partition.</p>
    #[doc(hidden)]
    pub partition_values: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The details about the partition error.</p>
    #[doc(hidden)]
    pub error_detail: std::option::Option<crate::model::ErrorDetail>,
}
impl PartitionError {
    /// <p>The values that define the partition.</p>
    pub fn partition_values(&self) -> std::option::Option<&[std::string::String]> {
        self.partition_values.as_deref()
    }
    /// <p>The details about the partition error.</p>
    pub fn error_detail(&self) -> std::option::Option<&crate::model::ErrorDetail> {
        self.error_detail.as_ref()
    }
}
/// See [`PartitionError`](crate::model::PartitionError).
pub mod partition_error {

    /// A builder for [`PartitionError`](crate::model::PartitionError).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) partition_values: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) error_detail: std::option::Option<crate::model::ErrorDetail>,
    }
    impl Builder {
        /// Appends an item to `partition_values`.
        ///
        /// To override the contents of this collection use [`set_partition_values`](Self::set_partition_values).
        ///
        /// <p>The values that define the partition.</p>
        pub fn partition_values(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.partition_values.unwrap_or_default();
            v.push(input.into());
            self.partition_values = Some(v);
            self
        }
        /// <p>The values that define the partition.</p>
        pub fn set_partition_values(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.partition_values = input;
            self
        }
        /// <p>The details about the partition error.</p>
        pub fn error_detail(mut self, input: crate::model::ErrorDetail) -> Self {
            self.error_detail = Some(input);
            self
        }
        /// <p>The details about the partition error.</p>
        pub fn set_error_detail(
            mut self,
            input: std::option::Option<crate::model::ErrorDetail>,
        ) -> Self {
            self.error_detail = input;
            self
        }
        /// Consumes the builder and constructs a [`PartitionError`](crate::model::PartitionError).
        pub fn build(self) -> crate::model::PartitionError {
            crate::model::PartitionError {
                partition_values: self.partition_values,
                error_detail: self.error_detail,
            }
        }
    }
}
impl PartitionError {
    /// Creates a new builder-style object to manufacture [`PartitionError`](crate::model::PartitionError).
    pub fn builder() -> crate::model::partition_error::Builder {
        crate::model::partition_error::Builder::default()
    }
}
