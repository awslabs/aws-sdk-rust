// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[derive(std::fmt::Debug)]
pub(crate) struct Handle<C = aws_hyper::DynConnector> {
    client: aws_hyper::Client<C>,
    conf: crate::Config,
}

#[derive(Clone, std::fmt::Debug)]
pub struct Client<C = aws_hyper::DynConnector> {
    handle: std::sync::Arc<Handle<C>>,
}
impl<C> Client<C> {
    pub fn from_conf_conn(conf: crate::Config, conn: C) -> Self {
        let client = aws_hyper::Client::new(conn);
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }

    pub fn conf(&self) -> &crate::Config {
        &self.handle.conf
    }
}
impl Client {
    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_env() -> Self {
        Self::from_conf(crate::Config::builder().build())
    }

    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_conf(conf: crate::Config) -> Self {
        let client = aws_hyper::Client::https();
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }
}
impl<C> Client<C>
where
    C: aws_hyper::SmithyConnector,
{
    pub fn batch_create_partition(&self) -> fluent_builders::BatchCreatePartition<C> {
        fluent_builders::BatchCreatePartition::new(self.handle.clone())
    }
    pub fn batch_delete_connection(&self) -> fluent_builders::BatchDeleteConnection<C> {
        fluent_builders::BatchDeleteConnection::new(self.handle.clone())
    }
    pub fn batch_delete_partition(&self) -> fluent_builders::BatchDeletePartition<C> {
        fluent_builders::BatchDeletePartition::new(self.handle.clone())
    }
    pub fn batch_delete_table(&self) -> fluent_builders::BatchDeleteTable<C> {
        fluent_builders::BatchDeleteTable::new(self.handle.clone())
    }
    pub fn batch_delete_table_version(&self) -> fluent_builders::BatchDeleteTableVersion<C> {
        fluent_builders::BatchDeleteTableVersion::new(self.handle.clone())
    }
    pub fn batch_get_crawlers(&self) -> fluent_builders::BatchGetCrawlers<C> {
        fluent_builders::BatchGetCrawlers::new(self.handle.clone())
    }
    pub fn batch_get_dev_endpoints(&self) -> fluent_builders::BatchGetDevEndpoints<C> {
        fluent_builders::BatchGetDevEndpoints::new(self.handle.clone())
    }
    pub fn batch_get_jobs(&self) -> fluent_builders::BatchGetJobs<C> {
        fluent_builders::BatchGetJobs::new(self.handle.clone())
    }
    pub fn batch_get_partition(&self) -> fluent_builders::BatchGetPartition<C> {
        fluent_builders::BatchGetPartition::new(self.handle.clone())
    }
    pub fn batch_get_triggers(&self) -> fluent_builders::BatchGetTriggers<C> {
        fluent_builders::BatchGetTriggers::new(self.handle.clone())
    }
    pub fn batch_get_workflows(&self) -> fluent_builders::BatchGetWorkflows<C> {
        fluent_builders::BatchGetWorkflows::new(self.handle.clone())
    }
    pub fn batch_stop_job_run(&self) -> fluent_builders::BatchStopJobRun<C> {
        fluent_builders::BatchStopJobRun::new(self.handle.clone())
    }
    pub fn batch_update_partition(&self) -> fluent_builders::BatchUpdatePartition<C> {
        fluent_builders::BatchUpdatePartition::new(self.handle.clone())
    }
    pub fn cancel_ml_task_run(&self) -> fluent_builders::CancelMLTaskRun<C> {
        fluent_builders::CancelMLTaskRun::new(self.handle.clone())
    }
    pub fn check_schema_version_validity(&self) -> fluent_builders::CheckSchemaVersionValidity<C> {
        fluent_builders::CheckSchemaVersionValidity::new(self.handle.clone())
    }
    pub fn create_classifier(&self) -> fluent_builders::CreateClassifier<C> {
        fluent_builders::CreateClassifier::new(self.handle.clone())
    }
    pub fn create_connection(&self) -> fluent_builders::CreateConnection<C> {
        fluent_builders::CreateConnection::new(self.handle.clone())
    }
    pub fn create_crawler(&self) -> fluent_builders::CreateCrawler<C> {
        fluent_builders::CreateCrawler::new(self.handle.clone())
    }
    pub fn create_database(&self) -> fluent_builders::CreateDatabase<C> {
        fluent_builders::CreateDatabase::new(self.handle.clone())
    }
    pub fn create_dev_endpoint(&self) -> fluent_builders::CreateDevEndpoint<C> {
        fluent_builders::CreateDevEndpoint::new(self.handle.clone())
    }
    pub fn create_job(&self) -> fluent_builders::CreateJob<C> {
        fluent_builders::CreateJob::new(self.handle.clone())
    }
    pub fn create_ml_transform(&self) -> fluent_builders::CreateMLTransform<C> {
        fluent_builders::CreateMLTransform::new(self.handle.clone())
    }
    pub fn create_partition(&self) -> fluent_builders::CreatePartition<C> {
        fluent_builders::CreatePartition::new(self.handle.clone())
    }
    pub fn create_partition_index(&self) -> fluent_builders::CreatePartitionIndex<C> {
        fluent_builders::CreatePartitionIndex::new(self.handle.clone())
    }
    pub fn create_registry(&self) -> fluent_builders::CreateRegistry<C> {
        fluent_builders::CreateRegistry::new(self.handle.clone())
    }
    pub fn create_schema(&self) -> fluent_builders::CreateSchema<C> {
        fluent_builders::CreateSchema::new(self.handle.clone())
    }
    pub fn create_script(&self) -> fluent_builders::CreateScript<C> {
        fluent_builders::CreateScript::new(self.handle.clone())
    }
    pub fn create_security_configuration(&self) -> fluent_builders::CreateSecurityConfiguration<C> {
        fluent_builders::CreateSecurityConfiguration::new(self.handle.clone())
    }
    pub fn create_table(&self) -> fluent_builders::CreateTable<C> {
        fluent_builders::CreateTable::new(self.handle.clone())
    }
    pub fn create_trigger(&self) -> fluent_builders::CreateTrigger<C> {
        fluent_builders::CreateTrigger::new(self.handle.clone())
    }
    pub fn create_user_defined_function(&self) -> fluent_builders::CreateUserDefinedFunction<C> {
        fluent_builders::CreateUserDefinedFunction::new(self.handle.clone())
    }
    pub fn create_workflow(&self) -> fluent_builders::CreateWorkflow<C> {
        fluent_builders::CreateWorkflow::new(self.handle.clone())
    }
    pub fn delete_classifier(&self) -> fluent_builders::DeleteClassifier<C> {
        fluent_builders::DeleteClassifier::new(self.handle.clone())
    }
    pub fn delete_column_statistics_for_partition(
        &self,
    ) -> fluent_builders::DeleteColumnStatisticsForPartition<C> {
        fluent_builders::DeleteColumnStatisticsForPartition::new(self.handle.clone())
    }
    pub fn delete_column_statistics_for_table(
        &self,
    ) -> fluent_builders::DeleteColumnStatisticsForTable<C> {
        fluent_builders::DeleteColumnStatisticsForTable::new(self.handle.clone())
    }
    pub fn delete_connection(&self) -> fluent_builders::DeleteConnection<C> {
        fluent_builders::DeleteConnection::new(self.handle.clone())
    }
    pub fn delete_crawler(&self) -> fluent_builders::DeleteCrawler<C> {
        fluent_builders::DeleteCrawler::new(self.handle.clone())
    }
    pub fn delete_database(&self) -> fluent_builders::DeleteDatabase<C> {
        fluent_builders::DeleteDatabase::new(self.handle.clone())
    }
    pub fn delete_dev_endpoint(&self) -> fluent_builders::DeleteDevEndpoint<C> {
        fluent_builders::DeleteDevEndpoint::new(self.handle.clone())
    }
    pub fn delete_job(&self) -> fluent_builders::DeleteJob<C> {
        fluent_builders::DeleteJob::new(self.handle.clone())
    }
    pub fn delete_ml_transform(&self) -> fluent_builders::DeleteMLTransform<C> {
        fluent_builders::DeleteMLTransform::new(self.handle.clone())
    }
    pub fn delete_partition(&self) -> fluent_builders::DeletePartition<C> {
        fluent_builders::DeletePartition::new(self.handle.clone())
    }
    pub fn delete_partition_index(&self) -> fluent_builders::DeletePartitionIndex<C> {
        fluent_builders::DeletePartitionIndex::new(self.handle.clone())
    }
    pub fn delete_registry(&self) -> fluent_builders::DeleteRegistry<C> {
        fluent_builders::DeleteRegistry::new(self.handle.clone())
    }
    pub fn delete_resource_policy(&self) -> fluent_builders::DeleteResourcePolicy<C> {
        fluent_builders::DeleteResourcePolicy::new(self.handle.clone())
    }
    pub fn delete_schema(&self) -> fluent_builders::DeleteSchema<C> {
        fluent_builders::DeleteSchema::new(self.handle.clone())
    }
    pub fn delete_schema_versions(&self) -> fluent_builders::DeleteSchemaVersions<C> {
        fluent_builders::DeleteSchemaVersions::new(self.handle.clone())
    }
    pub fn delete_security_configuration(&self) -> fluent_builders::DeleteSecurityConfiguration<C> {
        fluent_builders::DeleteSecurityConfiguration::new(self.handle.clone())
    }
    pub fn delete_table(&self) -> fluent_builders::DeleteTable<C> {
        fluent_builders::DeleteTable::new(self.handle.clone())
    }
    pub fn delete_table_version(&self) -> fluent_builders::DeleteTableVersion<C> {
        fluent_builders::DeleteTableVersion::new(self.handle.clone())
    }
    pub fn delete_trigger(&self) -> fluent_builders::DeleteTrigger<C> {
        fluent_builders::DeleteTrigger::new(self.handle.clone())
    }
    pub fn delete_user_defined_function(&self) -> fluent_builders::DeleteUserDefinedFunction<C> {
        fluent_builders::DeleteUserDefinedFunction::new(self.handle.clone())
    }
    pub fn delete_workflow(&self) -> fluent_builders::DeleteWorkflow<C> {
        fluent_builders::DeleteWorkflow::new(self.handle.clone())
    }
    pub fn get_catalog_import_status(&self) -> fluent_builders::GetCatalogImportStatus<C> {
        fluent_builders::GetCatalogImportStatus::new(self.handle.clone())
    }
    pub fn get_classifier(&self) -> fluent_builders::GetClassifier<C> {
        fluent_builders::GetClassifier::new(self.handle.clone())
    }
    pub fn get_classifiers(&self) -> fluent_builders::GetClassifiers<C> {
        fluent_builders::GetClassifiers::new(self.handle.clone())
    }
    pub fn get_column_statistics_for_partition(
        &self,
    ) -> fluent_builders::GetColumnStatisticsForPartition<C> {
        fluent_builders::GetColumnStatisticsForPartition::new(self.handle.clone())
    }
    pub fn get_column_statistics_for_table(
        &self,
    ) -> fluent_builders::GetColumnStatisticsForTable<C> {
        fluent_builders::GetColumnStatisticsForTable::new(self.handle.clone())
    }
    pub fn get_connection(&self) -> fluent_builders::GetConnection<C> {
        fluent_builders::GetConnection::new(self.handle.clone())
    }
    pub fn get_connections(&self) -> fluent_builders::GetConnections<C> {
        fluent_builders::GetConnections::new(self.handle.clone())
    }
    pub fn get_crawler(&self) -> fluent_builders::GetCrawler<C> {
        fluent_builders::GetCrawler::new(self.handle.clone())
    }
    pub fn get_crawler_metrics(&self) -> fluent_builders::GetCrawlerMetrics<C> {
        fluent_builders::GetCrawlerMetrics::new(self.handle.clone())
    }
    pub fn get_crawlers(&self) -> fluent_builders::GetCrawlers<C> {
        fluent_builders::GetCrawlers::new(self.handle.clone())
    }
    pub fn get_database(&self) -> fluent_builders::GetDatabase<C> {
        fluent_builders::GetDatabase::new(self.handle.clone())
    }
    pub fn get_databases(&self) -> fluent_builders::GetDatabases<C> {
        fluent_builders::GetDatabases::new(self.handle.clone())
    }
    pub fn get_data_catalog_encryption_settings(
        &self,
    ) -> fluent_builders::GetDataCatalogEncryptionSettings<C> {
        fluent_builders::GetDataCatalogEncryptionSettings::new(self.handle.clone())
    }
    pub fn get_dataflow_graph(&self) -> fluent_builders::GetDataflowGraph<C> {
        fluent_builders::GetDataflowGraph::new(self.handle.clone())
    }
    pub fn get_dev_endpoint(&self) -> fluent_builders::GetDevEndpoint<C> {
        fluent_builders::GetDevEndpoint::new(self.handle.clone())
    }
    pub fn get_dev_endpoints(&self) -> fluent_builders::GetDevEndpoints<C> {
        fluent_builders::GetDevEndpoints::new(self.handle.clone())
    }
    pub fn get_job(&self) -> fluent_builders::GetJob<C> {
        fluent_builders::GetJob::new(self.handle.clone())
    }
    pub fn get_job_bookmark(&self) -> fluent_builders::GetJobBookmark<C> {
        fluent_builders::GetJobBookmark::new(self.handle.clone())
    }
    pub fn get_job_run(&self) -> fluent_builders::GetJobRun<C> {
        fluent_builders::GetJobRun::new(self.handle.clone())
    }
    pub fn get_job_runs(&self) -> fluent_builders::GetJobRuns<C> {
        fluent_builders::GetJobRuns::new(self.handle.clone())
    }
    pub fn get_jobs(&self) -> fluent_builders::GetJobs<C> {
        fluent_builders::GetJobs::new(self.handle.clone())
    }
    pub fn get_mapping(&self) -> fluent_builders::GetMapping<C> {
        fluent_builders::GetMapping::new(self.handle.clone())
    }
    pub fn get_ml_task_run(&self) -> fluent_builders::GetMLTaskRun<C> {
        fluent_builders::GetMLTaskRun::new(self.handle.clone())
    }
    pub fn get_ml_task_runs(&self) -> fluent_builders::GetMLTaskRuns<C> {
        fluent_builders::GetMLTaskRuns::new(self.handle.clone())
    }
    pub fn get_ml_transform(&self) -> fluent_builders::GetMLTransform<C> {
        fluent_builders::GetMLTransform::new(self.handle.clone())
    }
    pub fn get_ml_transforms(&self) -> fluent_builders::GetMLTransforms<C> {
        fluent_builders::GetMLTransforms::new(self.handle.clone())
    }
    pub fn get_partition(&self) -> fluent_builders::GetPartition<C> {
        fluent_builders::GetPartition::new(self.handle.clone())
    }
    pub fn get_partition_indexes(&self) -> fluent_builders::GetPartitionIndexes<C> {
        fluent_builders::GetPartitionIndexes::new(self.handle.clone())
    }
    pub fn get_partitions(&self) -> fluent_builders::GetPartitions<C> {
        fluent_builders::GetPartitions::new(self.handle.clone())
    }
    pub fn get_plan(&self) -> fluent_builders::GetPlan<C> {
        fluent_builders::GetPlan::new(self.handle.clone())
    }
    pub fn get_registry(&self) -> fluent_builders::GetRegistry<C> {
        fluent_builders::GetRegistry::new(self.handle.clone())
    }
    pub fn get_resource_policies(&self) -> fluent_builders::GetResourcePolicies<C> {
        fluent_builders::GetResourcePolicies::new(self.handle.clone())
    }
    pub fn get_resource_policy(&self) -> fluent_builders::GetResourcePolicy<C> {
        fluent_builders::GetResourcePolicy::new(self.handle.clone())
    }
    pub fn get_schema(&self) -> fluent_builders::GetSchema<C> {
        fluent_builders::GetSchema::new(self.handle.clone())
    }
    pub fn get_schema_by_definition(&self) -> fluent_builders::GetSchemaByDefinition<C> {
        fluent_builders::GetSchemaByDefinition::new(self.handle.clone())
    }
    pub fn get_schema_version(&self) -> fluent_builders::GetSchemaVersion<C> {
        fluent_builders::GetSchemaVersion::new(self.handle.clone())
    }
    pub fn get_schema_versions_diff(&self) -> fluent_builders::GetSchemaVersionsDiff<C> {
        fluent_builders::GetSchemaVersionsDiff::new(self.handle.clone())
    }
    pub fn get_security_configuration(&self) -> fluent_builders::GetSecurityConfiguration<C> {
        fluent_builders::GetSecurityConfiguration::new(self.handle.clone())
    }
    pub fn get_security_configurations(&self) -> fluent_builders::GetSecurityConfigurations<C> {
        fluent_builders::GetSecurityConfigurations::new(self.handle.clone())
    }
    pub fn get_table(&self) -> fluent_builders::GetTable<C> {
        fluent_builders::GetTable::new(self.handle.clone())
    }
    pub fn get_tables(&self) -> fluent_builders::GetTables<C> {
        fluent_builders::GetTables::new(self.handle.clone())
    }
    pub fn get_table_version(&self) -> fluent_builders::GetTableVersion<C> {
        fluent_builders::GetTableVersion::new(self.handle.clone())
    }
    pub fn get_table_versions(&self) -> fluent_builders::GetTableVersions<C> {
        fluent_builders::GetTableVersions::new(self.handle.clone())
    }
    pub fn get_tags(&self) -> fluent_builders::GetTags<C> {
        fluent_builders::GetTags::new(self.handle.clone())
    }
    pub fn get_trigger(&self) -> fluent_builders::GetTrigger<C> {
        fluent_builders::GetTrigger::new(self.handle.clone())
    }
    pub fn get_triggers(&self) -> fluent_builders::GetTriggers<C> {
        fluent_builders::GetTriggers::new(self.handle.clone())
    }
    pub fn get_user_defined_function(&self) -> fluent_builders::GetUserDefinedFunction<C> {
        fluent_builders::GetUserDefinedFunction::new(self.handle.clone())
    }
    pub fn get_user_defined_functions(&self) -> fluent_builders::GetUserDefinedFunctions<C> {
        fluent_builders::GetUserDefinedFunctions::new(self.handle.clone())
    }
    pub fn get_workflow(&self) -> fluent_builders::GetWorkflow<C> {
        fluent_builders::GetWorkflow::new(self.handle.clone())
    }
    pub fn get_workflow_run(&self) -> fluent_builders::GetWorkflowRun<C> {
        fluent_builders::GetWorkflowRun::new(self.handle.clone())
    }
    pub fn get_workflow_run_properties(&self) -> fluent_builders::GetWorkflowRunProperties<C> {
        fluent_builders::GetWorkflowRunProperties::new(self.handle.clone())
    }
    pub fn get_workflow_runs(&self) -> fluent_builders::GetWorkflowRuns<C> {
        fluent_builders::GetWorkflowRuns::new(self.handle.clone())
    }
    pub fn import_catalog_to_glue(&self) -> fluent_builders::ImportCatalogToGlue<C> {
        fluent_builders::ImportCatalogToGlue::new(self.handle.clone())
    }
    pub fn list_crawlers(&self) -> fluent_builders::ListCrawlers<C> {
        fluent_builders::ListCrawlers::new(self.handle.clone())
    }
    pub fn list_dev_endpoints(&self) -> fluent_builders::ListDevEndpoints<C> {
        fluent_builders::ListDevEndpoints::new(self.handle.clone())
    }
    pub fn list_jobs(&self) -> fluent_builders::ListJobs<C> {
        fluent_builders::ListJobs::new(self.handle.clone())
    }
    pub fn list_ml_transforms(&self) -> fluent_builders::ListMLTransforms<C> {
        fluent_builders::ListMLTransforms::new(self.handle.clone())
    }
    pub fn list_registries(&self) -> fluent_builders::ListRegistries<C> {
        fluent_builders::ListRegistries::new(self.handle.clone())
    }
    pub fn list_schemas(&self) -> fluent_builders::ListSchemas<C> {
        fluent_builders::ListSchemas::new(self.handle.clone())
    }
    pub fn list_schema_versions(&self) -> fluent_builders::ListSchemaVersions<C> {
        fluent_builders::ListSchemaVersions::new(self.handle.clone())
    }
    pub fn list_triggers(&self) -> fluent_builders::ListTriggers<C> {
        fluent_builders::ListTriggers::new(self.handle.clone())
    }
    pub fn list_workflows(&self) -> fluent_builders::ListWorkflows<C> {
        fluent_builders::ListWorkflows::new(self.handle.clone())
    }
    pub fn put_data_catalog_encryption_settings(
        &self,
    ) -> fluent_builders::PutDataCatalogEncryptionSettings<C> {
        fluent_builders::PutDataCatalogEncryptionSettings::new(self.handle.clone())
    }
    pub fn put_resource_policy(&self) -> fluent_builders::PutResourcePolicy<C> {
        fluent_builders::PutResourcePolicy::new(self.handle.clone())
    }
    pub fn put_schema_version_metadata(&self) -> fluent_builders::PutSchemaVersionMetadata<C> {
        fluent_builders::PutSchemaVersionMetadata::new(self.handle.clone())
    }
    pub fn put_workflow_run_properties(&self) -> fluent_builders::PutWorkflowRunProperties<C> {
        fluent_builders::PutWorkflowRunProperties::new(self.handle.clone())
    }
    pub fn query_schema_version_metadata(&self) -> fluent_builders::QuerySchemaVersionMetadata<C> {
        fluent_builders::QuerySchemaVersionMetadata::new(self.handle.clone())
    }
    pub fn register_schema_version(&self) -> fluent_builders::RegisterSchemaVersion<C> {
        fluent_builders::RegisterSchemaVersion::new(self.handle.clone())
    }
    pub fn remove_schema_version_metadata(
        &self,
    ) -> fluent_builders::RemoveSchemaVersionMetadata<C> {
        fluent_builders::RemoveSchemaVersionMetadata::new(self.handle.clone())
    }
    pub fn reset_job_bookmark(&self) -> fluent_builders::ResetJobBookmark<C> {
        fluent_builders::ResetJobBookmark::new(self.handle.clone())
    }
    pub fn resume_workflow_run(&self) -> fluent_builders::ResumeWorkflowRun<C> {
        fluent_builders::ResumeWorkflowRun::new(self.handle.clone())
    }
    pub fn search_tables(&self) -> fluent_builders::SearchTables<C> {
        fluent_builders::SearchTables::new(self.handle.clone())
    }
    pub fn start_crawler(&self) -> fluent_builders::StartCrawler<C> {
        fluent_builders::StartCrawler::new(self.handle.clone())
    }
    pub fn start_crawler_schedule(&self) -> fluent_builders::StartCrawlerSchedule<C> {
        fluent_builders::StartCrawlerSchedule::new(self.handle.clone())
    }
    pub fn start_export_labels_task_run(&self) -> fluent_builders::StartExportLabelsTaskRun<C> {
        fluent_builders::StartExportLabelsTaskRun::new(self.handle.clone())
    }
    pub fn start_import_labels_task_run(&self) -> fluent_builders::StartImportLabelsTaskRun<C> {
        fluent_builders::StartImportLabelsTaskRun::new(self.handle.clone())
    }
    pub fn start_job_run(&self) -> fluent_builders::StartJobRun<C> {
        fluent_builders::StartJobRun::new(self.handle.clone())
    }
    pub fn start_ml_evaluation_task_run(&self) -> fluent_builders::StartMLEvaluationTaskRun<C> {
        fluent_builders::StartMLEvaluationTaskRun::new(self.handle.clone())
    }
    pub fn start_ml_labeling_set_generation_task_run(
        &self,
    ) -> fluent_builders::StartMLLabelingSetGenerationTaskRun<C> {
        fluent_builders::StartMLLabelingSetGenerationTaskRun::new(self.handle.clone())
    }
    pub fn start_trigger(&self) -> fluent_builders::StartTrigger<C> {
        fluent_builders::StartTrigger::new(self.handle.clone())
    }
    pub fn start_workflow_run(&self) -> fluent_builders::StartWorkflowRun<C> {
        fluent_builders::StartWorkflowRun::new(self.handle.clone())
    }
    pub fn stop_crawler(&self) -> fluent_builders::StopCrawler<C> {
        fluent_builders::StopCrawler::new(self.handle.clone())
    }
    pub fn stop_crawler_schedule(&self) -> fluent_builders::StopCrawlerSchedule<C> {
        fluent_builders::StopCrawlerSchedule::new(self.handle.clone())
    }
    pub fn stop_trigger(&self) -> fluent_builders::StopTrigger<C> {
        fluent_builders::StopTrigger::new(self.handle.clone())
    }
    pub fn stop_workflow_run(&self) -> fluent_builders::StopWorkflowRun<C> {
        fluent_builders::StopWorkflowRun::new(self.handle.clone())
    }
    pub fn tag_resource(&self) -> fluent_builders::TagResource<C> {
        fluent_builders::TagResource::new(self.handle.clone())
    }
    pub fn untag_resource(&self) -> fluent_builders::UntagResource<C> {
        fluent_builders::UntagResource::new(self.handle.clone())
    }
    pub fn update_classifier(&self) -> fluent_builders::UpdateClassifier<C> {
        fluent_builders::UpdateClassifier::new(self.handle.clone())
    }
    pub fn update_column_statistics_for_partition(
        &self,
    ) -> fluent_builders::UpdateColumnStatisticsForPartition<C> {
        fluent_builders::UpdateColumnStatisticsForPartition::new(self.handle.clone())
    }
    pub fn update_column_statistics_for_table(
        &self,
    ) -> fluent_builders::UpdateColumnStatisticsForTable<C> {
        fluent_builders::UpdateColumnStatisticsForTable::new(self.handle.clone())
    }
    pub fn update_connection(&self) -> fluent_builders::UpdateConnection<C> {
        fluent_builders::UpdateConnection::new(self.handle.clone())
    }
    pub fn update_crawler(&self) -> fluent_builders::UpdateCrawler<C> {
        fluent_builders::UpdateCrawler::new(self.handle.clone())
    }
    pub fn update_crawler_schedule(&self) -> fluent_builders::UpdateCrawlerSchedule<C> {
        fluent_builders::UpdateCrawlerSchedule::new(self.handle.clone())
    }
    pub fn update_database(&self) -> fluent_builders::UpdateDatabase<C> {
        fluent_builders::UpdateDatabase::new(self.handle.clone())
    }
    pub fn update_dev_endpoint(&self) -> fluent_builders::UpdateDevEndpoint<C> {
        fluent_builders::UpdateDevEndpoint::new(self.handle.clone())
    }
    pub fn update_job(&self) -> fluent_builders::UpdateJob<C> {
        fluent_builders::UpdateJob::new(self.handle.clone())
    }
    pub fn update_ml_transform(&self) -> fluent_builders::UpdateMLTransform<C> {
        fluent_builders::UpdateMLTransform::new(self.handle.clone())
    }
    pub fn update_partition(&self) -> fluent_builders::UpdatePartition<C> {
        fluent_builders::UpdatePartition::new(self.handle.clone())
    }
    pub fn update_registry(&self) -> fluent_builders::UpdateRegistry<C> {
        fluent_builders::UpdateRegistry::new(self.handle.clone())
    }
    pub fn update_schema(&self) -> fluent_builders::UpdateSchema<C> {
        fluent_builders::UpdateSchema::new(self.handle.clone())
    }
    pub fn update_table(&self) -> fluent_builders::UpdateTable<C> {
        fluent_builders::UpdateTable::new(self.handle.clone())
    }
    pub fn update_trigger(&self) -> fluent_builders::UpdateTrigger<C> {
        fluent_builders::UpdateTrigger::new(self.handle.clone())
    }
    pub fn update_user_defined_function(&self) -> fluent_builders::UpdateUserDefinedFunction<C> {
        fluent_builders::UpdateUserDefinedFunction::new(self.handle.clone())
    }
    pub fn update_workflow(&self) -> fluent_builders::UpdateWorkflow<C> {
        fluent_builders::UpdateWorkflow::new(self.handle.clone())
    }
}
pub mod fluent_builders {
    #[derive(std::fmt::Debug)]
    pub struct BatchCreatePartition<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::batch_create_partition_input::Builder,
    }
    impl<C> BatchCreatePartition<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::BatchCreatePartitionOutput,
            smithy_http::result::SdkError<crate::error::BatchCreatePartitionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the catalog in which the partition is to be created. Currently, this should be
        /// the Amazon Web Services account ID.</p>
        pub fn catalog_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.catalog_id(input);
            self
        }
        pub fn set_catalog_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_catalog_id(input);
            self
        }
        /// <p>The name of the metadata database in which the partition is
        /// to be created.</p>
        pub fn database_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.database_name(input);
            self
        }
        pub fn set_database_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_database_name(input);
            self
        }
        /// <p>The name of the metadata table in which the partition is to be created.</p>
        pub fn table_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.table_name(input);
            self
        }
        pub fn set_table_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_table_name(input);
            self
        }
        /// <p>A list of <code>PartitionInput</code> structures that define
        /// the partitions to be created.</p>
        pub fn partition_input_list(
            mut self,
            inp: impl Into<crate::model::PartitionInput>,
        ) -> Self {
            self.inner = self.inner.partition_input_list(inp);
            self
        }
        pub fn set_partition_input_list(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::PartitionInput>>,
        ) -> Self {
            self.inner = self.inner.set_partition_input_list(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct BatchDeleteConnection<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::batch_delete_connection_input::Builder,
    }
    impl<C> BatchDeleteConnection<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::BatchDeleteConnectionOutput,
            smithy_http::result::SdkError<crate::error::BatchDeleteConnectionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the Data Catalog in which the connections reside. If none is provided, the Amazon Web Services
        /// account ID is used by default.</p>
        pub fn catalog_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.catalog_id(input);
            self
        }
        pub fn set_catalog_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_catalog_id(input);
            self
        }
        /// <p>A list of names of the connections to delete.</p>
        pub fn connection_name_list(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.connection_name_list(inp);
            self
        }
        pub fn set_connection_name_list(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_connection_name_list(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct BatchDeletePartition<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::batch_delete_partition_input::Builder,
    }
    impl<C> BatchDeletePartition<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::BatchDeletePartitionOutput,
            smithy_http::result::SdkError<crate::error::BatchDeletePartitionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the Data Catalog where the partition to be deleted resides. If none is provided,
        /// the Amazon Web Services account ID is used by default.</p>
        pub fn catalog_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.catalog_id(input);
            self
        }
        pub fn set_catalog_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_catalog_id(input);
            self
        }
        /// <p>The name of the catalog database in which the table in question
        /// resides.</p>
        pub fn database_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.database_name(input);
            self
        }
        pub fn set_database_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_database_name(input);
            self
        }
        /// <p>The name of the table that contains the partitions to be deleted.</p>
        pub fn table_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.table_name(input);
            self
        }
        pub fn set_table_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_table_name(input);
            self
        }
        /// <p>A list of <code>PartitionInput</code> structures that define
        /// the partitions to be deleted.</p>
        pub fn partitions_to_delete(
            mut self,
            inp: impl Into<crate::model::PartitionValueList>,
        ) -> Self {
            self.inner = self.inner.partitions_to_delete(inp);
            self
        }
        pub fn set_partitions_to_delete(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::PartitionValueList>>,
        ) -> Self {
            self.inner = self.inner.set_partitions_to_delete(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct BatchDeleteTable<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::batch_delete_table_input::Builder,
    }
    impl<C> BatchDeleteTable<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::BatchDeleteTableOutput,
            smithy_http::result::SdkError<crate::error::BatchDeleteTableError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the Data Catalog where the table resides. If none is provided, the Amazon Web Services account
        /// ID is used by default.</p>
        pub fn catalog_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.catalog_id(input);
            self
        }
        pub fn set_catalog_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_catalog_id(input);
            self
        }
        /// <p>The name of the catalog database in which the tables to delete reside. For Hive
        /// compatibility, this name is entirely lowercase.</p>
        pub fn database_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.database_name(input);
            self
        }
        pub fn set_database_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_database_name(input);
            self
        }
        /// <p>A list of the table to delete.</p>
        pub fn tables_to_delete(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.tables_to_delete(inp);
            self
        }
        pub fn set_tables_to_delete(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_tables_to_delete(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct BatchDeleteTableVersion<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::batch_delete_table_version_input::Builder,
    }
    impl<C> BatchDeleteTableVersion<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::BatchDeleteTableVersionOutput,
            smithy_http::result::SdkError<crate::error::BatchDeleteTableVersionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the Data Catalog where the tables reside. If none is provided, the Amazon Web Services account
        /// ID is used by default.</p>
        pub fn catalog_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.catalog_id(input);
            self
        }
        pub fn set_catalog_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_catalog_id(input);
            self
        }
        /// <p>The database in the catalog in which the table resides. For Hive
        /// compatibility, this name is entirely lowercase.</p>
        pub fn database_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.database_name(input);
            self
        }
        pub fn set_database_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_database_name(input);
            self
        }
        /// <p>The name of the table. For Hive compatibility,
        /// this name is entirely lowercase.</p>
        pub fn table_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.table_name(input);
            self
        }
        pub fn set_table_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_table_name(input);
            self
        }
        /// <p>A list of the IDs of versions to be deleted. A <code>VersionId</code> is a string representation of an integer. Each version is incremented by 1.</p>
        pub fn version_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.version_ids(inp);
            self
        }
        pub fn set_version_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_version_ids(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct BatchGetCrawlers<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::batch_get_crawlers_input::Builder,
    }
    impl<C> BatchGetCrawlers<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::BatchGetCrawlersOutput,
            smithy_http::result::SdkError<crate::error::BatchGetCrawlersError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A list of crawler names, which might be the names returned from the
        /// <code>ListCrawlers</code> operation.</p>
        pub fn crawler_names(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.crawler_names(inp);
            self
        }
        pub fn set_crawler_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_crawler_names(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct BatchGetDevEndpoints<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::batch_get_dev_endpoints_input::Builder,
    }
    impl<C> BatchGetDevEndpoints<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::BatchGetDevEndpointsOutput,
            smithy_http::result::SdkError<crate::error::BatchGetDevEndpointsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The list of <code>DevEndpoint</code> names, which might be the names returned from the
        /// <code>ListDevEndpoint</code> operation.</p>
        pub fn dev_endpoint_names(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.dev_endpoint_names(inp);
            self
        }
        pub fn set_dev_endpoint_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_dev_endpoint_names(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct BatchGetJobs<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::batch_get_jobs_input::Builder,
    }
    impl<C> BatchGetJobs<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::BatchGetJobsOutput,
            smithy_http::result::SdkError<crate::error::BatchGetJobsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A list of job names, which might be the names returned from the <code>ListJobs</code>
        /// operation.</p>
        pub fn job_names(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.job_names(inp);
            self
        }
        pub fn set_job_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_job_names(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct BatchGetPartition<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::batch_get_partition_input::Builder,
    }
    impl<C> BatchGetPartition<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::BatchGetPartitionOutput,
            smithy_http::result::SdkError<crate::error::BatchGetPartitionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the Data Catalog where the partitions in question reside.
        /// If none is supplied, the Amazon Web Services account ID is used by default.</p>
        pub fn catalog_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.catalog_id(input);
            self
        }
        pub fn set_catalog_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_catalog_id(input);
            self
        }
        /// <p>The name of the catalog database where the partitions reside.</p>
        pub fn database_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.database_name(input);
            self
        }
        pub fn set_database_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_database_name(input);
            self
        }
        /// <p>The name of the partitions' table.</p>
        pub fn table_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.table_name(input);
            self
        }
        pub fn set_table_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_table_name(input);
            self
        }
        /// <p>A list of partition values identifying the partitions to retrieve.</p>
        pub fn partitions_to_get(
            mut self,
            inp: impl Into<crate::model::PartitionValueList>,
        ) -> Self {
            self.inner = self.inner.partitions_to_get(inp);
            self
        }
        pub fn set_partitions_to_get(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::PartitionValueList>>,
        ) -> Self {
            self.inner = self.inner.set_partitions_to_get(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct BatchGetTriggers<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::batch_get_triggers_input::Builder,
    }
    impl<C> BatchGetTriggers<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::BatchGetTriggersOutput,
            smithy_http::result::SdkError<crate::error::BatchGetTriggersError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A list of trigger names, which may be the names returned from the <code>ListTriggers</code> operation.</p>
        pub fn trigger_names(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.trigger_names(inp);
            self
        }
        pub fn set_trigger_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_trigger_names(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct BatchGetWorkflows<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::batch_get_workflows_input::Builder,
    }
    impl<C> BatchGetWorkflows<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::BatchGetWorkflowsOutput,
            smithy_http::result::SdkError<crate::error::BatchGetWorkflowsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A list of workflow names, which may be the names returned from the <code>ListWorkflows</code> operation.</p>
        pub fn names(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.names(inp);
            self
        }
        pub fn set_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_names(input);
            self
        }
        /// <p>Specifies whether to include a graph when returning the workflow resource metadata.</p>
        pub fn include_graph(mut self, input: bool) -> Self {
            self.inner = self.inner.include_graph(input);
            self
        }
        pub fn set_include_graph(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_include_graph(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct BatchStopJobRun<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::batch_stop_job_run_input::Builder,
    }
    impl<C> BatchStopJobRun<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::BatchStopJobRunOutput,
            smithy_http::result::SdkError<crate::error::BatchStopJobRunError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the job definition for which to stop job runs.</p>
        pub fn job_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.job_name(input);
            self
        }
        pub fn set_job_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_job_name(input);
            self
        }
        /// <p>A list of the <code>JobRunIds</code> that should be stopped for that job
        /// definition.</p>
        pub fn job_run_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.job_run_ids(inp);
            self
        }
        pub fn set_job_run_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_job_run_ids(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct BatchUpdatePartition<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::batch_update_partition_input::Builder,
    }
    impl<C> BatchUpdatePartition<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::BatchUpdatePartitionOutput,
            smithy_http::result::SdkError<crate::error::BatchUpdatePartitionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the catalog in which the partition is to be updated. Currently, this should be
        /// the Amazon Web Services account ID.</p>
        pub fn catalog_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.catalog_id(input);
            self
        }
        pub fn set_catalog_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_catalog_id(input);
            self
        }
        /// <p>The name of the metadata database in which the partition is
        /// to be updated.</p>
        pub fn database_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.database_name(input);
            self
        }
        pub fn set_database_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_database_name(input);
            self
        }
        /// <p>The name of the metadata table in which the partition is to be updated.</p>
        pub fn table_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.table_name(input);
            self
        }
        pub fn set_table_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_table_name(input);
            self
        }
        /// <p>A list of up to 100 <code>BatchUpdatePartitionRequestEntry</code> objects to update.</p>
        pub fn entries(
            mut self,
            inp: impl Into<crate::model::BatchUpdatePartitionRequestEntry>,
        ) -> Self {
            self.inner = self.inner.entries(inp);
            self
        }
        pub fn set_entries(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::BatchUpdatePartitionRequestEntry>,
            >,
        ) -> Self {
            self.inner = self.inner.set_entries(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CancelMLTaskRun<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::cancel_ml_task_run_input::Builder,
    }
    impl<C> CancelMLTaskRun<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CancelMlTaskRunOutput,
            smithy_http::result::SdkError<crate::error::CancelMLTaskRunError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The unique identifier of the machine learning transform.</p>
        pub fn transform_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.transform_id(input);
            self
        }
        pub fn set_transform_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_transform_id(input);
            self
        }
        /// <p>A unique identifier for the task run.</p>
        pub fn task_run_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.task_run_id(input);
            self
        }
        pub fn set_task_run_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_task_run_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CheckSchemaVersionValidity<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::check_schema_version_validity_input::Builder,
    }
    impl<C> CheckSchemaVersionValidity<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CheckSchemaVersionValidityOutput,
            smithy_http::result::SdkError<crate::error::CheckSchemaVersionValidityError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The data format of the schema definition. Currently <code>AVRO</code> and <code>JSON</code> are supported.</p>
        pub fn data_format(mut self, input: crate::model::DataFormat) -> Self {
            self.inner = self.inner.data_format(input);
            self
        }
        pub fn set_data_format(
            mut self,
            input: std::option::Option<crate::model::DataFormat>,
        ) -> Self {
            self.inner = self.inner.set_data_format(input);
            self
        }
        /// <p>The definition of the schema that has to be validated.</p>
        pub fn schema_definition(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.schema_definition(input);
            self
        }
        pub fn set_schema_definition(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_schema_definition(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateClassifier<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_classifier_input::Builder,
    }
    impl<C> CreateClassifier<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateClassifierOutput,
            smithy_http::result::SdkError<crate::error::CreateClassifierError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A <code>GrokClassifier</code> object specifying the classifier
        /// to create.</p>
        pub fn grok_classifier(mut self, input: crate::model::CreateGrokClassifierRequest) -> Self {
            self.inner = self.inner.grok_classifier(input);
            self
        }
        pub fn set_grok_classifier(
            mut self,
            input: std::option::Option<crate::model::CreateGrokClassifierRequest>,
        ) -> Self {
            self.inner = self.inner.set_grok_classifier(input);
            self
        }
        /// <p>An <code>XMLClassifier</code> object specifying the classifier
        /// to create.</p>
        pub fn xml_classifier(mut self, input: crate::model::CreateXmlClassifierRequest) -> Self {
            self.inner = self.inner.xml_classifier(input);
            self
        }
        pub fn set_xml_classifier(
            mut self,
            input: std::option::Option<crate::model::CreateXmlClassifierRequest>,
        ) -> Self {
            self.inner = self.inner.set_xml_classifier(input);
            self
        }
        /// <p>A <code>JsonClassifier</code> object specifying the classifier
        /// to create.</p>
        pub fn json_classifier(mut self, input: crate::model::CreateJsonClassifierRequest) -> Self {
            self.inner = self.inner.json_classifier(input);
            self
        }
        pub fn set_json_classifier(
            mut self,
            input: std::option::Option<crate::model::CreateJsonClassifierRequest>,
        ) -> Self {
            self.inner = self.inner.set_json_classifier(input);
            self
        }
        /// <p>A <code>CsvClassifier</code> object specifying the classifier
        /// to create.</p>
        pub fn csv_classifier(mut self, input: crate::model::CreateCsvClassifierRequest) -> Self {
            self.inner = self.inner.csv_classifier(input);
            self
        }
        pub fn set_csv_classifier(
            mut self,
            input: std::option::Option<crate::model::CreateCsvClassifierRequest>,
        ) -> Self {
            self.inner = self.inner.set_csv_classifier(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateConnection<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_connection_input::Builder,
    }
    impl<C> CreateConnection<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateConnectionOutput,
            smithy_http::result::SdkError<crate::error::CreateConnectionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the Data Catalog in which to create the connection. If none is provided, the Amazon Web Services
        /// account ID is used by default.</p>
        pub fn catalog_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.catalog_id(input);
            self
        }
        pub fn set_catalog_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_catalog_id(input);
            self
        }
        /// <p>A <code>ConnectionInput</code> object defining the connection
        /// to create.</p>
        pub fn connection_input(mut self, input: crate::model::ConnectionInput) -> Self {
            self.inner = self.inner.connection_input(input);
            self
        }
        pub fn set_connection_input(
            mut self,
            input: std::option::Option<crate::model::ConnectionInput>,
        ) -> Self {
            self.inner = self.inner.set_connection_input(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateCrawler<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_crawler_input::Builder,
    }
    impl<C> CreateCrawler<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateCrawlerOutput,
            smithy_http::result::SdkError<crate::error::CreateCrawlerError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Name of the new crawler.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>The IAM role or Amazon Resource Name (ARN) of an IAM role used by the new crawler to
        /// access customer resources.</p>
        pub fn role(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.role(input);
            self
        }
        pub fn set_role(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_role(input);
            self
        }
        /// <p>The Glue database where results are written, such as:
        /// <code>arn:aws:daylight:us-east-1::database/sometable/*</code>.</p>
        pub fn database_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.database_name(input);
            self
        }
        pub fn set_database_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_database_name(input);
            self
        }
        /// <p>A description of the new crawler.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>A list of collection of targets to crawl.</p>
        pub fn targets(mut self, input: crate::model::CrawlerTargets) -> Self {
            self.inner = self.inner.targets(input);
            self
        }
        pub fn set_targets(
            mut self,
            input: std::option::Option<crate::model::CrawlerTargets>,
        ) -> Self {
            self.inner = self.inner.set_targets(input);
            self
        }
        /// <p>A <code>cron</code> expression used to specify the schedule (see <a href="https://docs.aws.amazon.com/glue/latest/dg/monitor-data-warehouse-schedule.html">Time-Based Schedules for Jobs and Crawlers</a>. For example, to run
        /// something every day at 12:15 UTC, you would specify:
        /// <code>cron(15 12 * * ? *)</code>.</p>
        pub fn schedule(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.schedule(input);
            self
        }
        pub fn set_schedule(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_schedule(input);
            self
        }
        /// <p>A list of custom classifiers that the user has registered. By default, all built-in
        /// classifiers are included in a crawl, but these custom classifiers always override the default
        /// classifiers for a given classification.</p>
        pub fn classifiers(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.classifiers(inp);
            self
        }
        pub fn set_classifiers(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_classifiers(input);
            self
        }
        /// <p>The table prefix used for catalog tables that are created.</p>
        pub fn table_prefix(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.table_prefix(input);
            self
        }
        pub fn set_table_prefix(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_table_prefix(input);
            self
        }
        /// <p>The policy for the crawler's update and deletion behavior.</p>
        pub fn schema_change_policy(mut self, input: crate::model::SchemaChangePolicy) -> Self {
            self.inner = self.inner.schema_change_policy(input);
            self
        }
        pub fn set_schema_change_policy(
            mut self,
            input: std::option::Option<crate::model::SchemaChangePolicy>,
        ) -> Self {
            self.inner = self.inner.set_schema_change_policy(input);
            self
        }
        /// <p>A policy that specifies whether to crawl the entire dataset again, or to crawl only folders that were added since the last crawler run.</p>
        pub fn recrawl_policy(mut self, input: crate::model::RecrawlPolicy) -> Self {
            self.inner = self.inner.recrawl_policy(input);
            self
        }
        pub fn set_recrawl_policy(
            mut self,
            input: std::option::Option<crate::model::RecrawlPolicy>,
        ) -> Self {
            self.inner = self.inner.set_recrawl_policy(input);
            self
        }
        /// <p>Specifies data lineage configuration settings for the crawler.</p>
        pub fn lineage_configuration(mut self, input: crate::model::LineageConfiguration) -> Self {
            self.inner = self.inner.lineage_configuration(input);
            self
        }
        pub fn set_lineage_configuration(
            mut self,
            input: std::option::Option<crate::model::LineageConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_lineage_configuration(input);
            self
        }
        /// <p>Crawler configuration information. This versioned JSON
        /// string allows users to specify aspects of a crawler's behavior.
        /// For more information, see <a href="https://docs.aws.amazon.com/glue/latest/dg/crawler-configuration.html">Configuring a Crawler</a>.</p>
        pub fn configuration(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.configuration(input);
            self
        }
        pub fn set_configuration(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_configuration(input);
            self
        }
        /// <p>The name of the <code>SecurityConfiguration</code> structure to be used by this
        /// crawler.</p>
        pub fn crawler_security_configuration(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.crawler_security_configuration(input);
            self
        }
        pub fn set_crawler_security_configuration(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_crawler_security_configuration(input);
            self
        }
        /// <p>The tags to use with this crawler request. You may use tags to limit access to the
        /// crawler. For more information about tags in Glue, see <a href="https://docs.aws.amazon.com/glue/latest/dg/monitor-tags.html">Amazon Web Services Tags in Glue</a> in the developer
        /// guide.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.tags(k, v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateDatabase<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_database_input::Builder,
    }
    impl<C> CreateDatabase<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateDatabaseOutput,
            smithy_http::result::SdkError<crate::error::CreateDatabaseError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the Data Catalog in which to create the database. If none is provided, the Amazon Web Services
        /// account ID is used by default.</p>
        pub fn catalog_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.catalog_id(input);
            self
        }
        pub fn set_catalog_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_catalog_id(input);
            self
        }
        /// <p>The metadata for the database.</p>
        pub fn database_input(mut self, input: crate::model::DatabaseInput) -> Self {
            self.inner = self.inner.database_input(input);
            self
        }
        pub fn set_database_input(
            mut self,
            input: std::option::Option<crate::model::DatabaseInput>,
        ) -> Self {
            self.inner = self.inner.set_database_input(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateDevEndpoint<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_dev_endpoint_input::Builder,
    }
    impl<C> CreateDevEndpoint<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateDevEndpointOutput,
            smithy_http::result::SdkError<crate::error::CreateDevEndpointError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name to be assigned to the new <code>DevEndpoint</code>.</p>
        pub fn endpoint_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.endpoint_name(input);
            self
        }
        pub fn set_endpoint_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_endpoint_name(input);
            self
        }
        /// <p>The IAM role for the <code>DevEndpoint</code>.</p>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.role_arn(input);
            self
        }
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_role_arn(input);
            self
        }
        /// <p>Security group IDs for the security groups to be used by the new
        /// <code>DevEndpoint</code>.</p>
        pub fn security_group_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.security_group_ids(inp);
            self
        }
        pub fn set_security_group_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_security_group_ids(input);
            self
        }
        /// <p>The subnet ID for the new <code>DevEndpoint</code> to use.</p>
        pub fn subnet_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.subnet_id(input);
            self
        }
        pub fn set_subnet_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_subnet_id(input);
            self
        }
        /// <p>The public key to be used by this <code>DevEndpoint</code> for authentication. This
        /// attribute is provided for backward compatibility because the recommended attribute to use is
        /// public keys.</p>
        pub fn public_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.public_key(input);
            self
        }
        pub fn set_public_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_public_key(input);
            self
        }
        /// <p>A list of public keys to be used by the development endpoints for authentication. The use
        /// of this attribute is preferred over a single public key because the public keys allow you to
        /// have a different private key per client.</p>
        /// <note>
        /// <p>If you previously created an endpoint with a public key, you must remove that key to be able
        /// to set a list of public keys. Call the <code>UpdateDevEndpoint</code> API with the public
        /// key content in the <code>deletePublicKeys</code> attribute, and the list of new keys in the
        /// <code>addPublicKeys</code> attribute.</p>
        /// </note>
        pub fn public_keys(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.public_keys(inp);
            self
        }
        pub fn set_public_keys(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_public_keys(input);
            self
        }
        /// <p>The number of Glue Data Processing Units (DPUs) to allocate to this
        /// <code>DevEndpoint</code>.</p>
        pub fn number_of_nodes(mut self, input: i32) -> Self {
            self.inner = self.inner.number_of_nodes(input);
            self
        }
        pub fn set_number_of_nodes(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_number_of_nodes(input);
            self
        }
        /// <p>The type of predefined worker that is allocated to the development endpoint. Accepts a value of Standard, G.1X, or G.2X.</p>
        /// <ul>
        /// <li>
        /// <p>For the <code>Standard</code> worker type, each worker provides 4 vCPU, 16 GB of memory and a 50GB disk, and 2 executors per worker.</p>
        /// </li>
        /// <li>
        /// <p>For the <code>G.1X</code> worker type, each worker maps to 1 DPU (4 vCPU, 16 GB of memory, 64 GB disk), and provides 1 executor per worker. We recommend this worker type for memory-intensive jobs.</p>
        /// </li>
        /// <li>
        /// <p>For the <code>G.2X</code> worker type, each worker maps to 2 DPU (8 vCPU, 32 GB of memory, 128 GB disk), and provides 1 executor per worker. We recommend this worker type for memory-intensive jobs.</p>
        /// </li>
        /// </ul>
        /// <p>Known issue: when a development endpoint is created with the <code>G.2X</code>
        /// <code>WorkerType</code> configuration, the Spark drivers for the development endpoint will run on 4 vCPU, 16 GB of memory, and a 64 GB disk. </p>
        pub fn worker_type(mut self, input: crate::model::WorkerType) -> Self {
            self.inner = self.inner.worker_type(input);
            self
        }
        pub fn set_worker_type(
            mut self,
            input: std::option::Option<crate::model::WorkerType>,
        ) -> Self {
            self.inner = self.inner.set_worker_type(input);
            self
        }
        /// <p>Glue version determines the versions of Apache Spark and Python that Glue supports. The Python version indicates the version supported for running your ETL scripts on development endpoints. </p>
        /// <p>For more information about the available Glue versions and corresponding Spark and Python versions, see <a href="https://docs.aws.amazon.com/glue/latest/dg/add-job.html">Glue version</a> in the developer guide.</p>
        /// <p>Development endpoints that are created without specifying a Glue version default to Glue 0.9.</p>  
        /// <p>You can specify a version of Python support for development endpoints by using the <code>Arguments</code> parameter in the <code>CreateDevEndpoint</code> or <code>UpdateDevEndpoint</code> APIs. If no arguments are provided, the version defaults to Python 2.</p>
        pub fn glue_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.glue_version(input);
            self
        }
        pub fn set_glue_version(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_glue_version(input);
            self
        }
        /// <p>The number of workers of a defined <code>workerType</code> that are allocated to the development endpoint.</p>
        /// <p>The maximum number of workers you can define are 299 for <code>G.1X</code>, and 149 for <code>G.2X</code>. </p>
        pub fn number_of_workers(mut self, input: i32) -> Self {
            self.inner = self.inner.number_of_workers(input);
            self
        }
        pub fn set_number_of_workers(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_number_of_workers(input);
            self
        }
        /// <p>The paths to one or more Python libraries in an Amazon S3 bucket that should be loaded in
        /// your <code>DevEndpoint</code>. Multiple values must be complete paths separated by a
        /// comma.</p>
        /// <note>
        /// <p>You can only use pure Python libraries with a <code>DevEndpoint</code>. Libraries that rely on
        /// C extensions, such as the <a href="http://pandas.pydata.org/">pandas</a> Python data
        /// analysis library, are not yet supported.</p>
        /// </note>
        pub fn extra_python_libs_s3_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.extra_python_libs_s3_path(input);
            self
        }
        pub fn set_extra_python_libs_s3_path(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_extra_python_libs_s3_path(input);
            self
        }
        /// <p>The path to one or more Java <code>.jar</code> files in an S3 bucket that should be loaded
        /// in your <code>DevEndpoint</code>.</p>
        pub fn extra_jars_s3_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.extra_jars_s3_path(input);
            self
        }
        pub fn set_extra_jars_s3_path(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_extra_jars_s3_path(input);
            self
        }
        /// <p>The name of the <code>SecurityConfiguration</code> structure to be used with this
        /// <code>DevEndpoint</code>.</p>
        pub fn security_configuration(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.security_configuration(input);
            self
        }
        pub fn set_security_configuration(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_security_configuration(input);
            self
        }
        /// <p>The tags to use with this DevEndpoint. You may use tags to limit access to the DevEndpoint. For more information about tags in Glue, see <a href="https://docs.aws.amazon.com/glue/latest/dg/monitor-tags.html">Amazon Web Services Tags in Glue</a> in the developer guide.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.tags(k, v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
        /// <p>A map of arguments used to configure the <code>DevEndpoint</code>.</p>
        pub fn arguments(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.arguments(k, v);
            self
        }
        pub fn set_arguments(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_arguments(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateJob<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_job_input::Builder,
    }
    impl<C> CreateJob<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateJobOutput,
            smithy_http::result::SdkError<crate::error::CreateJobError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name you assign to this job definition. It must be unique in your account.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>Description of the job being defined.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>This field is reserved for future use.</p>
        pub fn log_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.log_uri(input);
            self
        }
        pub fn set_log_uri(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_log_uri(input);
            self
        }
        /// <p>The name or Amazon Resource Name (ARN) of the IAM role associated with this job.</p>
        pub fn role(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.role(input);
            self
        }
        pub fn set_role(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_role(input);
            self
        }
        /// <p>An <code>ExecutionProperty</code> specifying the maximum number of concurrent runs allowed
        /// for this job.</p>
        pub fn execution_property(mut self, input: crate::model::ExecutionProperty) -> Self {
            self.inner = self.inner.execution_property(input);
            self
        }
        pub fn set_execution_property(
            mut self,
            input: std::option::Option<crate::model::ExecutionProperty>,
        ) -> Self {
            self.inner = self.inner.set_execution_property(input);
            self
        }
        /// <p>The <code>JobCommand</code> that runs this job.</p>
        pub fn command(mut self, input: crate::model::JobCommand) -> Self {
            self.inner = self.inner.command(input);
            self
        }
        pub fn set_command(mut self, input: std::option::Option<crate::model::JobCommand>) -> Self {
            self.inner = self.inner.set_command(input);
            self
        }
        /// <p>The default arguments for this job.</p>
        /// <p>You can specify arguments here that your own job-execution script
        /// consumes, as well as arguments that Glue itself consumes.</p>
        /// <p>For information about how to specify and consume your own Job arguments, see the <a href="https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-python-calling.html">Calling Glue APIs in Python</a> topic in the developer guide.</p>
        /// <p>For information about the key-value pairs that Glue consumes to set up your job, see the <a href="https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-etl-glue-arguments.html">Special Parameters Used by Glue</a> topic in the developer guide.</p>
        pub fn default_arguments(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.default_arguments(k, v);
            self
        }
        pub fn set_default_arguments(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_default_arguments(input);
            self
        }
        /// <p>Non-overridable arguments for this job, specified as name-value pairs.</p>
        pub fn non_overridable_arguments(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.non_overridable_arguments(k, v);
            self
        }
        pub fn set_non_overridable_arguments(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_non_overridable_arguments(input);
            self
        }
        /// <p>The connections used for this job.</p>
        pub fn connections(mut self, input: crate::model::ConnectionsList) -> Self {
            self.inner = self.inner.connections(input);
            self
        }
        pub fn set_connections(
            mut self,
            input: std::option::Option<crate::model::ConnectionsList>,
        ) -> Self {
            self.inner = self.inner.set_connections(input);
            self
        }
        /// <p>The maximum number of times to retry this job if it fails.</p>
        pub fn max_retries(mut self, input: i32) -> Self {
            self.inner = self.inner.max_retries(input);
            self
        }
        pub fn set_max_retries(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_retries(input);
            self
        }
        /// <p>This parameter is deprecated. Use <code>MaxCapacity</code> instead.</p>
        /// <p>The number of Glue data processing units (DPUs) to allocate to this Job. You can
        /// allocate from 2 to 100 DPUs; the default is 10. A DPU is a relative measure of processing
        /// power that consists of 4 vCPUs of compute capacity and 16 GB of memory. For more information,
        /// see the <a href="https://aws.amazon.com/glue/pricing/">Glue pricing
        /// page</a>.</p>
        pub fn allocated_capacity(mut self, input: i32) -> Self {
            self.inner = self.inner.allocated_capacity(input);
            self
        }
        pub fn set_allocated_capacity(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_allocated_capacity(input);
            self
        }
        /// <p>The job timeout in minutes.  This is the maximum time that a job run
        /// can consume resources before it is terminated and enters <code>TIMEOUT</code>
        /// status. The default is 2,880 minutes (48 hours).</p>
        pub fn timeout(mut self, input: i32) -> Self {
            self.inner = self.inner.timeout(input);
            self
        }
        pub fn set_timeout(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_timeout(input);
            self
        }
        /// <p>For Glue version 1.0 or earlier jobs, using the standard worker type, the number of Glue data processing units (DPUs) that can be allocated when this job runs. A DPU is a relative measure
        /// of processing power that consists of 4 vCPUs of compute capacity and 16 GB of memory.
        /// For more information, see the <a href="https://aws.amazon.com/glue/pricing/">Glue
        /// pricing page</a>.</p>
        /// <p>Do not set <code>Max Capacity</code> if using <code>WorkerType</code> and <code>NumberOfWorkers</code>.</p>
        /// <p>The value that can be allocated for <code>MaxCapacity</code> depends on whether you are
        /// running a Python shell job or an Apache Spark ETL job:</p>
        /// <ul>
        /// <li>
        /// <p>When you specify a Python shell job (<code>JobCommand.Name</code>="pythonshell"), you can
        /// allocate either 0.0625 or 1 DPU. The default is 0.0625 DPU.</p>
        /// </li>
        /// <li>
        /// <p>When you specify an Apache Spark ETL job (<code>JobCommand.Name</code>="glueetl") or Apache
        /// Spark streaming ETL job (<code>JobCommand.Name</code>="gluestreaming"), you can allocate from 2 to 100 DPUs.
        /// The default is 10 DPUs. This job type cannot have a fractional DPU allocation.</p>
        /// </li>
        /// </ul>
        /// <p>For Glue version 2.0 jobs, you cannot instead specify a <code>Maximum capacity</code>. Instead, you should specify a <code>Worker type</code> and the <code>Number of workers</code>.</p>
        pub fn max_capacity(mut self, input: f64) -> Self {
            self.inner = self.inner.max_capacity(input);
            self
        }
        pub fn set_max_capacity(mut self, input: std::option::Option<f64>) -> Self {
            self.inner = self.inner.set_max_capacity(input);
            self
        }
        /// <p>The name of the <code>SecurityConfiguration</code> structure to be used with this
        /// job.</p>
        pub fn security_configuration(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.security_configuration(input);
            self
        }
        pub fn set_security_configuration(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_security_configuration(input);
            self
        }
        /// <p>The tags to use with this job. You may use tags to limit access to the job. For more information about tags in Glue, see <a href="https://docs.aws.amazon.com/glue/latest/dg/monitor-tags.html">Amazon Web Services Tags in Glue</a> in the developer guide.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.tags(k, v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
        /// <p>Specifies configuration properties of a job notification.</p>
        pub fn notification_property(mut self, input: crate::model::NotificationProperty) -> Self {
            self.inner = self.inner.notification_property(input);
            self
        }
        pub fn set_notification_property(
            mut self,
            input: std::option::Option<crate::model::NotificationProperty>,
        ) -> Self {
            self.inner = self.inner.set_notification_property(input);
            self
        }
        /// <p>Glue version determines the versions of Apache Spark and Python that Glue supports. The Python version indicates the version supported for jobs of type Spark. </p>
        /// <p>For more information about the available Glue versions and corresponding Spark and Python versions, see <a href="https://docs.aws.amazon.com/glue/latest/dg/add-job.html">Glue version</a> in the developer guide.</p>
        /// <p>Jobs that are created without specifying a Glue version default to Glue 0.9.</p>
        pub fn glue_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.glue_version(input);
            self
        }
        pub fn set_glue_version(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_glue_version(input);
            self
        }
        /// <p>The number of workers of a defined <code>workerType</code> that are allocated when a job runs.</p>
        /// <p>The maximum number of workers you can define are 299 for <code>G.1X</code>, and 149 for <code>G.2X</code>. </p>
        pub fn number_of_workers(mut self, input: i32) -> Self {
            self.inner = self.inner.number_of_workers(input);
            self
        }
        pub fn set_number_of_workers(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_number_of_workers(input);
            self
        }
        /// <p>The type of predefined worker that is allocated when a job runs. Accepts a value of Standard, G.1X, or G.2X.</p>
        /// <ul>
        /// <li>
        /// <p>For the <code>Standard</code> worker type, each worker provides 4 vCPU, 16 GB of memory and a 50GB disk, and 2 executors per worker.</p>
        /// </li>
        /// <li>
        /// <p>For the <code>G.1X</code> worker type, each worker maps to 1 DPU (4 vCPU, 16 GB of memory, 64 GB disk), and provides 1 executor per worker. We recommend this worker type for memory-intensive jobs.</p>
        /// </li>
        /// <li>
        /// <p>For the <code>G.2X</code> worker type, each worker maps to 2 DPU (8 vCPU, 32 GB of memory, 128 GB disk), and provides 1 executor per worker. We recommend this worker type for memory-intensive jobs.</p>
        /// </li>
        /// </ul>
        pub fn worker_type(mut self, input: crate::model::WorkerType) -> Self {
            self.inner = self.inner.worker_type(input);
            self
        }
        pub fn set_worker_type(
            mut self,
            input: std::option::Option<crate::model::WorkerType>,
        ) -> Self {
            self.inner = self.inner.set_worker_type(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateMLTransform<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_ml_transform_input::Builder,
    }
    impl<C> CreateMLTransform<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateMlTransformOutput,
            smithy_http::result::SdkError<crate::error::CreateMLTransformError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The unique name that you give the transform when you create it.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>A description of the machine learning transform that is being defined. The default is an
        /// empty string.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>A list of Glue table definitions used by the transform.</p>
        pub fn input_record_tables(mut self, inp: impl Into<crate::model::GlueTable>) -> Self {
            self.inner = self.inner.input_record_tables(inp);
            self
        }
        pub fn set_input_record_tables(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::GlueTable>>,
        ) -> Self {
            self.inner = self.inner.set_input_record_tables(input);
            self
        }
        /// <p>The algorithmic parameters that are specific to the transform type used. Conditionally
        /// dependent on the transform type.</p>
        pub fn parameters(mut self, input: crate::model::TransformParameters) -> Self {
            self.inner = self.inner.parameters(input);
            self
        }
        pub fn set_parameters(
            mut self,
            input: std::option::Option<crate::model::TransformParameters>,
        ) -> Self {
            self.inner = self.inner.set_parameters(input);
            self
        }
        /// <p>The name or Amazon Resource Name (ARN) of the IAM role with the required permissions. The required permissions include both Glue service role permissions to Glue resources, and Amazon S3 permissions required by the transform. </p>
        /// <ul>
        /// <li>
        /// <p>This role needs Glue service role permissions to allow access to resources in Glue. See <a href="https://docs.aws.amazon.com/glue/latest/dg/attach-policy-iam-user.html">Attach a Policy to IAM Users That Access Glue</a>.</p>
        /// </li>
        /// <li>
        /// <p>This role needs permission to your Amazon Simple Storage Service (Amazon S3) sources, targets, temporary directory, scripts, and any libraries used by the task run for this transform.</p>
        /// </li>
        /// </ul>
        pub fn role(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.role(input);
            self
        }
        pub fn set_role(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_role(input);
            self
        }
        /// <p>This value determines which version of Glue this machine learning transform is compatible with. Glue 1.0 is recommended for most customers. If the value is not set, the Glue compatibility defaults to Glue 0.9.  For more information, see <a href="https://docs.aws.amazon.com/glue/latest/dg/release-notes.html#release-notes-versions">Glue Versions</a> in the developer guide.</p>
        pub fn glue_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.glue_version(input);
            self
        }
        pub fn set_glue_version(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_glue_version(input);
            self
        }
        /// <p>The number of Glue data processing units (DPUs) that are allocated to task runs for this transform. You can allocate from 2 to 100 DPUs; the default is 10. A DPU is a relative measure of
        /// processing power that consists of 4 vCPUs of compute capacity and 16 GB of memory. For more
        /// information, see the <a href="https://aws.amazon.com/glue/pricing/">Glue pricing
        /// page</a>. </p>
        /// <p>
        /// <code>MaxCapacity</code> is a mutually exclusive option with <code>NumberOfWorkers</code> and <code>WorkerType</code>.</p>
        /// <ul>
        /// <li>
        /// <p>If either <code>NumberOfWorkers</code> or <code>WorkerType</code> is set, then <code>MaxCapacity</code> cannot be set.</p>
        /// </li>
        /// <li>
        /// <p>If <code>MaxCapacity</code> is set then neither <code>NumberOfWorkers</code> or <code>WorkerType</code> can be set.</p>
        /// </li>
        /// <li>
        /// <p>If <code>WorkerType</code> is set, then <code>NumberOfWorkers</code> is required (and vice versa).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>MaxCapacity</code> and <code>NumberOfWorkers</code> must both be at least 1.</p>
        /// </li>
        /// </ul>
        /// <p>When the <code>WorkerType</code> field is set to a value other than <code>Standard</code>, the <code>MaxCapacity</code> field is set automatically and becomes read-only.</p>    
        /// <p>When the <code>WorkerType</code> field is set to a value other than <code>Standard</code>, the <code>MaxCapacity</code> field is set automatically and becomes read-only.</p>
        pub fn max_capacity(mut self, input: f64) -> Self {
            self.inner = self.inner.max_capacity(input);
            self
        }
        pub fn set_max_capacity(mut self, input: std::option::Option<f64>) -> Self {
            self.inner = self.inner.set_max_capacity(input);
            self
        }
        /// <p>The type of predefined worker that is allocated when this task runs. Accepts a value of Standard, G.1X, or G.2X.</p>
        /// <ul>
        /// <li>
        /// <p>For the <code>Standard</code> worker type, each worker provides 4 vCPU, 16 GB of memory and a 50GB disk, and 2 executors per worker.</p>
        /// </li>
        /// <li>
        /// <p>For the <code>G.1X</code> worker type, each worker provides 4 vCPU, 16 GB of memory and a 64GB disk, and 1 executor per worker.</p>
        /// </li>
        /// <li>
        /// <p>For the <code>G.2X</code> worker type, each worker provides 8 vCPU, 32 GB of memory and a 128GB disk, and 1 executor per worker.</p>
        /// </li>
        /// </ul>
        /// <p>
        /// <code>MaxCapacity</code> is a mutually exclusive option with <code>NumberOfWorkers</code> and <code>WorkerType</code>.</p>
        /// <ul>
        /// <li>
        /// <p>If either <code>NumberOfWorkers</code> or <code>WorkerType</code> is set, then <code>MaxCapacity</code> cannot be set.</p>
        /// </li>
        /// <li>
        /// <p>If <code>MaxCapacity</code> is set then neither <code>NumberOfWorkers</code> or <code>WorkerType</code> can be set.</p>
        /// </li>
        /// <li>
        /// <p>If <code>WorkerType</code> is set, then <code>NumberOfWorkers</code> is required (and vice versa).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>MaxCapacity</code> and <code>NumberOfWorkers</code> must both be at least 1.</p>
        /// </li>
        /// </ul>
        pub fn worker_type(mut self, input: crate::model::WorkerType) -> Self {
            self.inner = self.inner.worker_type(input);
            self
        }
        pub fn set_worker_type(
            mut self,
            input: std::option::Option<crate::model::WorkerType>,
        ) -> Self {
            self.inner = self.inner.set_worker_type(input);
            self
        }
        /// <p>The number of workers of a defined <code>workerType</code> that are allocated when this task runs.</p>
        /// <p>If <code>WorkerType</code> is set, then <code>NumberOfWorkers</code> is required (and vice versa).</p>
        pub fn number_of_workers(mut self, input: i32) -> Self {
            self.inner = self.inner.number_of_workers(input);
            self
        }
        pub fn set_number_of_workers(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_number_of_workers(input);
            self
        }
        /// <p>The timeout of the task run for this transform in minutes. This is the maximum time that a task run for this transform can consume resources before it is terminated and enters <code>TIMEOUT</code> status. The default is 2,880 minutes (48 hours).</p>
        pub fn timeout(mut self, input: i32) -> Self {
            self.inner = self.inner.timeout(input);
            self
        }
        pub fn set_timeout(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_timeout(input);
            self
        }
        /// <p>The maximum number of times to retry a task for this transform after a task run fails.</p>
        pub fn max_retries(mut self, input: i32) -> Self {
            self.inner = self.inner.max_retries(input);
            self
        }
        pub fn set_max_retries(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_retries(input);
            self
        }
        /// <p>The tags to use with this machine learning transform. You may use tags to limit access to the machine learning transform. For more information about tags in Glue, see <a href="https://docs.aws.amazon.com/glue/latest/dg/monitor-tags.html">Amazon Web Services Tags in Glue</a> in the developer guide.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.tags(k, v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
        /// <p>The encryption-at-rest settings of the transform that apply to accessing user data. Machine learning transforms can access user data encrypted in Amazon S3 using KMS.</p>
        pub fn transform_encryption(mut self, input: crate::model::TransformEncryption) -> Self {
            self.inner = self.inner.transform_encryption(input);
            self
        }
        pub fn set_transform_encryption(
            mut self,
            input: std::option::Option<crate::model::TransformEncryption>,
        ) -> Self {
            self.inner = self.inner.set_transform_encryption(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreatePartition<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_partition_input::Builder,
    }
    impl<C> CreatePartition<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreatePartitionOutput,
            smithy_http::result::SdkError<crate::error::CreatePartitionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Web Services account ID of the catalog in which the partition is to be created.</p>
        pub fn catalog_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.catalog_id(input);
            self
        }
        pub fn set_catalog_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_catalog_id(input);
            self
        }
        /// <p>The name of the metadata database in which the partition is
        /// to be created.</p>
        pub fn database_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.database_name(input);
            self
        }
        pub fn set_database_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_database_name(input);
            self
        }
        /// <p>The name of the metadata table in which the partition is to be created.</p>
        pub fn table_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.table_name(input);
            self
        }
        pub fn set_table_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_table_name(input);
            self
        }
        /// <p>A <code>PartitionInput</code> structure defining the partition
        /// to be created.</p>
        pub fn partition_input(mut self, input: crate::model::PartitionInput) -> Self {
            self.inner = self.inner.partition_input(input);
            self
        }
        pub fn set_partition_input(
            mut self,
            input: std::option::Option<crate::model::PartitionInput>,
        ) -> Self {
            self.inner = self.inner.set_partition_input(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreatePartitionIndex<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_partition_index_input::Builder,
    }
    impl<C> CreatePartitionIndex<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreatePartitionIndexOutput,
            smithy_http::result::SdkError<crate::error::CreatePartitionIndexError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The catalog ID where the table resides.</p>
        pub fn catalog_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.catalog_id(input);
            self
        }
        pub fn set_catalog_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_catalog_id(input);
            self
        }
        /// <p>Specifies the name of a database in which you want to create a partition index.</p>
        pub fn database_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.database_name(input);
            self
        }
        pub fn set_database_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_database_name(input);
            self
        }
        /// <p>Specifies the name of a table in which you want to create a partition index.</p>
        pub fn table_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.table_name(input);
            self
        }
        pub fn set_table_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_table_name(input);
            self
        }
        /// <p>Specifies a <code>PartitionIndex</code> structure to create a partition index in an existing table.</p>
        pub fn partition_index(mut self, input: crate::model::PartitionIndex) -> Self {
            self.inner = self.inner.partition_index(input);
            self
        }
        pub fn set_partition_index(
            mut self,
            input: std::option::Option<crate::model::PartitionIndex>,
        ) -> Self {
            self.inner = self.inner.set_partition_index(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateRegistry<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_registry_input::Builder,
    }
    impl<C> CreateRegistry<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateRegistryOutput,
            smithy_http::result::SdkError<crate::error::CreateRegistryError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Name of the registry to be created of max length of 255, and may only contain letters, numbers, hyphen, underscore, dollar sign, or hash mark.  No whitespace.</p>
        pub fn registry_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.registry_name(input);
            self
        }
        pub fn set_registry_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_registry_name(input);
            self
        }
        /// <p>A description of the registry. If description is not provided, there will not be any default value for this.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>Amazon Web Services tags that contain a key value pair and may be searched by console, command line, or API.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.tags(k, v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateSchema<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_schema_input::Builder,
    }
    impl<C> CreateSchema<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateSchemaOutput,
            smithy_http::result::SdkError<crate::error::CreateSchemaError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p> This is a wrapper shape to contain the registry identity fields. If this is not provided, the default registry will be used. The ARN format for the same will be: <code>arn:aws:glue:us-east-2:<customer id>:registry/default-registry:random-5-letter-id</code>.</p>
        pub fn registry_id(mut self, input: crate::model::RegistryId) -> Self {
            self.inner = self.inner.registry_id(input);
            self
        }
        pub fn set_registry_id(
            mut self,
            input: std::option::Option<crate::model::RegistryId>,
        ) -> Self {
            self.inner = self.inner.set_registry_id(input);
            self
        }
        /// <p>Name of the schema to be created of max length of 255, and may only contain letters, numbers, hyphen, underscore, dollar sign, or hash mark. No whitespace.</p>
        pub fn schema_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.schema_name(input);
            self
        }
        pub fn set_schema_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_schema_name(input);
            self
        }
        /// <p>The data format of the schema definition. Currently <code>AVRO</code> and <code>JSON</code> are supported.</p>
        pub fn data_format(mut self, input: crate::model::DataFormat) -> Self {
            self.inner = self.inner.data_format(input);
            self
        }
        pub fn set_data_format(
            mut self,
            input: std::option::Option<crate::model::DataFormat>,
        ) -> Self {
            self.inner = self.inner.set_data_format(input);
            self
        }
        /// <p>The compatibility mode of the schema. The possible values are:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <i>NONE</i>: No compatibility mode applies. You can use this choice in development scenarios or if you do not know the compatibility mode that you want to apply to schemas. Any new version added will be accepted without undergoing a compatibility check.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <i>DISABLED</i>: This compatibility choice prevents versioning for a particular schema. You can use this choice to prevent future versioning of a schema.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <i>BACKWARD</i>: This compatibility choice is recommended as it allows data receivers to read both the current and one previous schema version. This means that for instance, a new schema version cannot drop data fields or change the type of these fields, so they can't be read by readers using the previous version.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <i>BACKWARD_ALL</i>: This compatibility choice allows data receivers to read both the current and all previous schema versions. You can use this choice when you need to delete fields or add optional fields, and check compatibility against all previous schema versions. </p>
        /// </li>
        /// <li>
        /// <p>
        /// <i>FORWARD</i>: This compatibility choice allows data receivers to read both the current and one next schema version, but not necessarily later versions. You can use this choice when you need to add fields or delete optional fields, but only check compatibility against the last schema version.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <i>FORWARD_ALL</i>: This compatibility choice allows data receivers to read written by producers of any new registered schema. You can use this choice when you need to add fields or delete optional fields, and check compatibility against all previous schema versions.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <i>FULL</i>: This compatibility choice allows data receivers to read data written by producers using the previous or next version of the schema, but not necessarily earlier or later versions. You can use this choice when you need to add or remove optional fields, but only check compatibility against the last schema version.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <i>FULL_ALL</i>: This compatibility choice allows data receivers to read data written by producers using all previous schema versions. You can use this choice when you need to add or remove optional fields, and check compatibility against all previous schema versions.</p>
        /// </li>
        /// </ul>
        pub fn compatibility(mut self, input: crate::model::Compatibility) -> Self {
            self.inner = self.inner.compatibility(input);
            self
        }
        pub fn set_compatibility(
            mut self,
            input: std::option::Option<crate::model::Compatibility>,
        ) -> Self {
            self.inner = self.inner.set_compatibility(input);
            self
        }
        /// <p>An optional description of the schema. If description is not provided, there will not be any automatic default value for this.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>Amazon Web Services tags that contain a key value pair and may be searched by console, command line, or API. If specified, follows the Amazon Web Services tags-on-create pattern.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.tags(k, v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
        /// <p>The schema definition using the <code>DataFormat</code> setting for <code>SchemaName</code>.</p>
        pub fn schema_definition(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.schema_definition(input);
            self
        }
        pub fn set_schema_definition(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_schema_definition(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateScript<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_script_input::Builder,
    }
    impl<C> CreateScript<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateScriptOutput,
            smithy_http::result::SdkError<crate::error::CreateScriptError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A list of the nodes in the DAG.</p>
        pub fn dag_nodes(mut self, inp: impl Into<crate::model::CodeGenNode>) -> Self {
            self.inner = self.inner.dag_nodes(inp);
            self
        }
        pub fn set_dag_nodes(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::CodeGenNode>>,
        ) -> Self {
            self.inner = self.inner.set_dag_nodes(input);
            self
        }
        /// <p>A list of the edges in the DAG.</p>
        pub fn dag_edges(mut self, inp: impl Into<crate::model::CodeGenEdge>) -> Self {
            self.inner = self.inner.dag_edges(inp);
            self
        }
        pub fn set_dag_edges(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::CodeGenEdge>>,
        ) -> Self {
            self.inner = self.inner.set_dag_edges(input);
            self
        }
        /// <p>The programming language of the resulting code from the DAG.</p>
        pub fn language(mut self, input: crate::model::Language) -> Self {
            self.inner = self.inner.language(input);
            self
        }
        pub fn set_language(mut self, input: std::option::Option<crate::model::Language>) -> Self {
            self.inner = self.inner.set_language(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateSecurityConfiguration<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_security_configuration_input::Builder,
    }
    impl<C> CreateSecurityConfiguration<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateSecurityConfigurationOutput,
            smithy_http::result::SdkError<crate::error::CreateSecurityConfigurationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name for the new security configuration.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>The encryption configuration for the new security configuration.</p>
        pub fn encryption_configuration(
            mut self,
            input: crate::model::EncryptionConfiguration,
        ) -> Self {
            self.inner = self.inner.encryption_configuration(input);
            self
        }
        pub fn set_encryption_configuration(
            mut self,
            input: std::option::Option<crate::model::EncryptionConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_encryption_configuration(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateTable<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_table_input::Builder,
    }
    impl<C> CreateTable<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateTableOutput,
            smithy_http::result::SdkError<crate::error::CreateTableError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the Data Catalog in which to create the <code>Table</code>.
        /// If none is supplied, the Amazon Web Services account ID is used by default.</p>
        pub fn catalog_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.catalog_id(input);
            self
        }
        pub fn set_catalog_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_catalog_id(input);
            self
        }
        /// <p>The catalog database in which to create the new table. For Hive
        /// compatibility, this name is entirely lowercase.</p>
        pub fn database_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.database_name(input);
            self
        }
        pub fn set_database_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_database_name(input);
            self
        }
        /// <p>The <code>TableInput</code> object that defines the metadata table
        /// to create in the catalog.</p>
        pub fn table_input(mut self, input: crate::model::TableInput) -> Self {
            self.inner = self.inner.table_input(input);
            self
        }
        pub fn set_table_input(
            mut self,
            input: std::option::Option<crate::model::TableInput>,
        ) -> Self {
            self.inner = self.inner.set_table_input(input);
            self
        }
        /// <p>A list of partition indexes, <code>PartitionIndex</code> structures, to create in the table.</p>
        pub fn partition_indexes(mut self, inp: impl Into<crate::model::PartitionIndex>) -> Self {
            self.inner = self.inner.partition_indexes(inp);
            self
        }
        pub fn set_partition_indexes(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::PartitionIndex>>,
        ) -> Self {
            self.inner = self.inner.set_partition_indexes(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateTrigger<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_trigger_input::Builder,
    }
    impl<C> CreateTrigger<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateTriggerOutput,
            smithy_http::result::SdkError<crate::error::CreateTriggerError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the trigger.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>The name of the workflow associated with the trigger.</p>
        pub fn workflow_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.workflow_name(input);
            self
        }
        pub fn set_workflow_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_workflow_name(input);
            self
        }
        /// <p>The type of the new trigger.</p>
        pub fn r#type(mut self, input: crate::model::TriggerType) -> Self {
            self.inner = self.inner.r#type(input);
            self
        }
        pub fn set_type(mut self, input: std::option::Option<crate::model::TriggerType>) -> Self {
            self.inner = self.inner.set_type(input);
            self
        }
        /// <p>A <code>cron</code> expression used to specify the schedule (see <a href="https://docs.aws.amazon.com/glue/latest/dg/monitor-data-warehouse-schedule.html">Time-Based Schedules for Jobs and Crawlers</a>. For example, to run
        /// something every day at 12:15 UTC, you would specify:
        /// <code>cron(15 12 * * ? *)</code>.</p>
        /// <p>This field is required when the trigger type is SCHEDULED.</p>
        pub fn schedule(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.schedule(input);
            self
        }
        pub fn set_schedule(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_schedule(input);
            self
        }
        /// <p>A predicate to specify when the new trigger should fire.</p>
        /// <p>This field is required when the trigger type is <code>CONDITIONAL</code>.</p>
        pub fn predicate(mut self, input: crate::model::Predicate) -> Self {
            self.inner = self.inner.predicate(input);
            self
        }
        pub fn set_predicate(
            mut self,
            input: std::option::Option<crate::model::Predicate>,
        ) -> Self {
            self.inner = self.inner.set_predicate(input);
            self
        }
        /// <p>The actions initiated by this trigger when it fires.</p>
        pub fn actions(mut self, inp: impl Into<crate::model::Action>) -> Self {
            self.inner = self.inner.actions(inp);
            self
        }
        pub fn set_actions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Action>>,
        ) -> Self {
            self.inner = self.inner.set_actions(input);
            self
        }
        /// <p>A description of the new trigger.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>Set to <code>true</code> to start <code>SCHEDULED</code> and <code>CONDITIONAL</code>
        /// triggers when created. True is not supported for <code>ON_DEMAND</code> triggers.</p>
        pub fn start_on_creation(mut self, input: bool) -> Self {
            self.inner = self.inner.start_on_creation(input);
            self
        }
        pub fn set_start_on_creation(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_start_on_creation(input);
            self
        }
        /// <p>The tags to use with this trigger. You may use tags to limit access to the trigger.
        /// For more information about tags in Glue, see
        /// <a href="https://docs.aws.amazon.com/glue/latest/dg/monitor-tags.html">Amazon Web Services Tags in Glue</a> in the developer guide. </p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.tags(k, v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateUserDefinedFunction<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_user_defined_function_input::Builder,
    }
    impl<C> CreateUserDefinedFunction<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateUserDefinedFunctionOutput,
            smithy_http::result::SdkError<crate::error::CreateUserDefinedFunctionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the Data Catalog in which to create the function. If none is provided, the Amazon Web Services
        /// account ID is used by default.</p>
        pub fn catalog_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.catalog_id(input);
            self
        }
        pub fn set_catalog_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_catalog_id(input);
            self
        }
        /// <p>The name of the catalog database in which to create the function.</p>
        pub fn database_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.database_name(input);
            self
        }
        pub fn set_database_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_database_name(input);
            self
        }
        /// <p>A <code>FunctionInput</code> object that defines the function
        /// to create in the Data Catalog.</p>
        pub fn function_input(mut self, input: crate::model::UserDefinedFunctionInput) -> Self {
            self.inner = self.inner.function_input(input);
            self
        }
        pub fn set_function_input(
            mut self,
            input: std::option::Option<crate::model::UserDefinedFunctionInput>,
        ) -> Self {
            self.inner = self.inner.set_function_input(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateWorkflow<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_workflow_input::Builder,
    }
    impl<C> CreateWorkflow<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateWorkflowOutput,
            smithy_http::result::SdkError<crate::error::CreateWorkflowError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name to be assigned to the workflow. It should be unique within your account.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>A description of the workflow.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>A collection of properties to be used as part of each execution of the workflow.</p>
        pub fn default_run_properties(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.default_run_properties(k, v);
            self
        }
        pub fn set_default_run_properties(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_default_run_properties(input);
            self
        }
        /// <p>The tags to be used with this workflow.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.tags(k, v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
        /// <p>You can use this parameter to prevent unwanted multiple updates to data, to control costs, or in some cases, to prevent exceeding the maximum number of concurrent runs of any of the component jobs. If you leave this parameter blank, there is no limit to the number of concurrent workflow runs.</p>
        pub fn max_concurrent_runs(mut self, input: i32) -> Self {
            self.inner = self.inner.max_concurrent_runs(input);
            self
        }
        pub fn set_max_concurrent_runs(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_concurrent_runs(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteClassifier<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_classifier_input::Builder,
    }
    impl<C> DeleteClassifier<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteClassifierOutput,
            smithy_http::result::SdkError<crate::error::DeleteClassifierError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Name of the classifier to remove.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteColumnStatisticsForPartition<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_column_statistics_for_partition_input::Builder,
    }
    impl<C> DeleteColumnStatisticsForPartition<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteColumnStatisticsForPartitionOutput,
            smithy_http::result::SdkError<crate::error::DeleteColumnStatisticsForPartitionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the Data Catalog where the partitions in question reside.
        /// If none is supplied, the Amazon Web Services account ID is used by default.</p>
        pub fn catalog_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.catalog_id(input);
            self
        }
        pub fn set_catalog_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_catalog_id(input);
            self
        }
        /// <p>The name of the catalog database where the partitions reside.</p>
        pub fn database_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.database_name(input);
            self
        }
        pub fn set_database_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_database_name(input);
            self
        }
        /// <p>The name of the partitions' table.</p>
        pub fn table_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.table_name(input);
            self
        }
        pub fn set_table_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_table_name(input);
            self
        }
        /// <p>A list of partition values identifying the partition.</p>
        pub fn partition_values(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.partition_values(inp);
            self
        }
        pub fn set_partition_values(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_partition_values(input);
            self
        }
        /// <p>Name of the column.</p>
        pub fn column_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.column_name(input);
            self
        }
        pub fn set_column_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_column_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteColumnStatisticsForTable<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_column_statistics_for_table_input::Builder,
    }
    impl<C> DeleteColumnStatisticsForTable<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteColumnStatisticsForTableOutput,
            smithy_http::result::SdkError<crate::error::DeleteColumnStatisticsForTableError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the Data Catalog where the partitions in question reside.
        /// If none is supplied, the Amazon Web Services account ID is used by default.</p>
        pub fn catalog_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.catalog_id(input);
            self
        }
        pub fn set_catalog_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_catalog_id(input);
            self
        }
        /// <p>The name of the catalog database where the partitions reside.</p>
        pub fn database_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.database_name(input);
            self
        }
        pub fn set_database_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_database_name(input);
            self
        }
        /// <p>The name of the partitions' table.</p>
        pub fn table_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.table_name(input);
            self
        }
        pub fn set_table_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_table_name(input);
            self
        }
        /// <p>The name of the column.</p>
        pub fn column_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.column_name(input);
            self
        }
        pub fn set_column_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_column_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteConnection<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_connection_input::Builder,
    }
    impl<C> DeleteConnection<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteConnectionOutput,
            smithy_http::result::SdkError<crate::error::DeleteConnectionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the Data Catalog in which the connection resides. If none is provided, the Amazon Web Services
        /// account ID is used by default.</p>
        pub fn catalog_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.catalog_id(input);
            self
        }
        pub fn set_catalog_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_catalog_id(input);
            self
        }
        /// <p>The name of the connection to delete.</p>
        pub fn connection_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.connection_name(input);
            self
        }
        pub fn set_connection_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_connection_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteCrawler<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_crawler_input::Builder,
    }
    impl<C> DeleteCrawler<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteCrawlerOutput,
            smithy_http::result::SdkError<crate::error::DeleteCrawlerError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the crawler to remove.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteDatabase<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_database_input::Builder,
    }
    impl<C> DeleteDatabase<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteDatabaseOutput,
            smithy_http::result::SdkError<crate::error::DeleteDatabaseError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the Data Catalog in which the database resides. If none is provided, the Amazon Web Services
        /// account ID is used by default.</p>
        pub fn catalog_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.catalog_id(input);
            self
        }
        pub fn set_catalog_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_catalog_id(input);
            self
        }
        /// <p>The name of the database to delete. For Hive compatibility, this must be all
        /// lowercase.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteDevEndpoint<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_dev_endpoint_input::Builder,
    }
    impl<C> DeleteDevEndpoint<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteDevEndpointOutput,
            smithy_http::result::SdkError<crate::error::DeleteDevEndpointError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the <code>DevEndpoint</code>.</p>
        pub fn endpoint_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.endpoint_name(input);
            self
        }
        pub fn set_endpoint_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_endpoint_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteJob<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_job_input::Builder,
    }
    impl<C> DeleteJob<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteJobOutput,
            smithy_http::result::SdkError<crate::error::DeleteJobError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the job definition to delete.</p>
        pub fn job_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.job_name(input);
            self
        }
        pub fn set_job_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_job_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteMLTransform<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_ml_transform_input::Builder,
    }
    impl<C> DeleteMLTransform<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteMlTransformOutput,
            smithy_http::result::SdkError<crate::error::DeleteMLTransformError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The unique identifier of the transform to delete.</p>
        pub fn transform_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.transform_id(input);
            self
        }
        pub fn set_transform_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_transform_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeletePartition<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_partition_input::Builder,
    }
    impl<C> DeletePartition<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeletePartitionOutput,
            smithy_http::result::SdkError<crate::error::DeletePartitionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the Data Catalog where the partition to be deleted resides. If none is provided,
        /// the Amazon Web Services account ID is used by default.</p>
        pub fn catalog_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.catalog_id(input);
            self
        }
        pub fn set_catalog_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_catalog_id(input);
            self
        }
        /// <p>The name of the catalog database in which the table in question
        /// resides.</p>
        pub fn database_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.database_name(input);
            self
        }
        pub fn set_database_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_database_name(input);
            self
        }
        /// <p>The name of the table that contains the partition to be deleted.</p>
        pub fn table_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.table_name(input);
            self
        }
        pub fn set_table_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_table_name(input);
            self
        }
        /// <p>The values that define the partition.</p>
        pub fn partition_values(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.partition_values(inp);
            self
        }
        pub fn set_partition_values(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_partition_values(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeletePartitionIndex<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_partition_index_input::Builder,
    }
    impl<C> DeletePartitionIndex<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeletePartitionIndexOutput,
            smithy_http::result::SdkError<crate::error::DeletePartitionIndexError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The catalog ID where the table resides.</p>
        pub fn catalog_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.catalog_id(input);
            self
        }
        pub fn set_catalog_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_catalog_id(input);
            self
        }
        /// <p>Specifies the name of a database from which you want to delete a partition index.</p>
        pub fn database_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.database_name(input);
            self
        }
        pub fn set_database_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_database_name(input);
            self
        }
        /// <p>Specifies the name of a table from which you want to delete a partition index.</p>
        pub fn table_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.table_name(input);
            self
        }
        pub fn set_table_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_table_name(input);
            self
        }
        /// <p>The name of the partition index to be deleted.</p>
        pub fn index_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.index_name(input);
            self
        }
        pub fn set_index_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_index_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteRegistry<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_registry_input::Builder,
    }
    impl<C> DeleteRegistry<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteRegistryOutput,
            smithy_http::result::SdkError<crate::error::DeleteRegistryError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>This is a wrapper structure that may contain the registry name and Amazon Resource Name (ARN).</p>
        pub fn registry_id(mut self, input: crate::model::RegistryId) -> Self {
            self.inner = self.inner.registry_id(input);
            self
        }
        pub fn set_registry_id(
            mut self,
            input: std::option::Option<crate::model::RegistryId>,
        ) -> Self {
            self.inner = self.inner.set_registry_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteResourcePolicy<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_resource_policy_input::Builder,
    }
    impl<C> DeleteResourcePolicy<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteResourcePolicyOutput,
            smithy_http::result::SdkError<crate::error::DeleteResourcePolicyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The hash value returned when this policy was set.</p>
        pub fn policy_hash_condition(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy_hash_condition(input);
            self
        }
        pub fn set_policy_hash_condition(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_policy_hash_condition(input);
            self
        }
        /// <p>The ARN of the Glue resource for the resource policy to be deleted.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(input);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteSchema<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_schema_input::Builder,
    }
    impl<C> DeleteSchema<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteSchemaOutput,
            smithy_http::result::SdkError<crate::error::DeleteSchemaError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>This is a wrapper structure that may contain the schema name and Amazon Resource Name (ARN).</p>
        pub fn schema_id(mut self, input: crate::model::SchemaId) -> Self {
            self.inner = self.inner.schema_id(input);
            self
        }
        pub fn set_schema_id(mut self, input: std::option::Option<crate::model::SchemaId>) -> Self {
            self.inner = self.inner.set_schema_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteSchemaVersions<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_schema_versions_input::Builder,
    }
    impl<C> DeleteSchemaVersions<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteSchemaVersionsOutput,
            smithy_http::result::SdkError<crate::error::DeleteSchemaVersionsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>This is a wrapper structure that may contain the schema name and Amazon Resource Name (ARN).</p>
        pub fn schema_id(mut self, input: crate::model::SchemaId) -> Self {
            self.inner = self.inner.schema_id(input);
            self
        }
        pub fn set_schema_id(mut self, input: std::option::Option<crate::model::SchemaId>) -> Self {
            self.inner = self.inner.set_schema_id(input);
            self
        }
        /// <p>A version range may be supplied which may be of the format:</p>
        /// <ul>
        /// <li>
        /// <p>a single version number, 5</p>
        /// </li>
        /// <li>
        /// <p>a range, 5-8 : deletes versions 5, 6, 7, 8</p>
        /// </li>
        /// </ul>
        pub fn versions(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.versions(input);
            self
        }
        pub fn set_versions(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_versions(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteSecurityConfiguration<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_security_configuration_input::Builder,
    }
    impl<C> DeleteSecurityConfiguration<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteSecurityConfigurationOutput,
            smithy_http::result::SdkError<crate::error::DeleteSecurityConfigurationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the security configuration to delete.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteTable<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_table_input::Builder,
    }
    impl<C> DeleteTable<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteTableOutput,
            smithy_http::result::SdkError<crate::error::DeleteTableError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the Data Catalog where the table resides. If none is provided, the Amazon Web Services account
        /// ID is used by default.</p>
        pub fn catalog_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.catalog_id(input);
            self
        }
        pub fn set_catalog_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_catalog_id(input);
            self
        }
        /// <p>The name of the catalog database in which the table resides. For Hive
        /// compatibility, this name is entirely lowercase.</p>
        pub fn database_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.database_name(input);
            self
        }
        pub fn set_database_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_database_name(input);
            self
        }
        /// <p>The name of the table to be deleted. For Hive
        /// compatibility, this name is entirely lowercase.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteTableVersion<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_table_version_input::Builder,
    }
    impl<C> DeleteTableVersion<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteTableVersionOutput,
            smithy_http::result::SdkError<crate::error::DeleteTableVersionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the Data Catalog where the tables reside. If none is provided, the Amazon Web Services account
        /// ID is used by default.</p>
        pub fn catalog_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.catalog_id(input);
            self
        }
        pub fn set_catalog_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_catalog_id(input);
            self
        }
        /// <p>The database in the catalog in which the table resides. For Hive
        /// compatibility, this name is entirely lowercase.</p>
        pub fn database_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.database_name(input);
            self
        }
        pub fn set_database_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_database_name(input);
            self
        }
        /// <p>The name of the table. For Hive compatibility,
        /// this name is entirely lowercase.</p>
        pub fn table_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.table_name(input);
            self
        }
        pub fn set_table_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_table_name(input);
            self
        }
        /// <p>The ID of the table version to be deleted. A <code>VersionID</code> is a string representation of an integer. Each version is incremented by 1.</p>
        pub fn version_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.version_id(input);
            self
        }
        pub fn set_version_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_version_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteTrigger<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_trigger_input::Builder,
    }
    impl<C> DeleteTrigger<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteTriggerOutput,
            smithy_http::result::SdkError<crate::error::DeleteTriggerError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the trigger to delete.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteUserDefinedFunction<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_user_defined_function_input::Builder,
    }
    impl<C> DeleteUserDefinedFunction<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteUserDefinedFunctionOutput,
            smithy_http::result::SdkError<crate::error::DeleteUserDefinedFunctionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the Data Catalog where the function to be deleted is
        /// located. If none is supplied, the Amazon Web Services account ID is used by default.</p>
        pub fn catalog_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.catalog_id(input);
            self
        }
        pub fn set_catalog_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_catalog_id(input);
            self
        }
        /// <p>The name of the catalog database where the function is located.</p>
        pub fn database_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.database_name(input);
            self
        }
        pub fn set_database_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_database_name(input);
            self
        }
        /// <p>The name of the function definition to be deleted.</p>
        pub fn function_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.function_name(input);
            self
        }
        pub fn set_function_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_function_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteWorkflow<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_workflow_input::Builder,
    }
    impl<C> DeleteWorkflow<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteWorkflowOutput,
            smithy_http::result::SdkError<crate::error::DeleteWorkflowError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Name of the workflow to be deleted.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetCatalogImportStatus<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_catalog_import_status_input::Builder,
    }
    impl<C> GetCatalogImportStatus<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetCatalogImportStatusOutput,
            smithy_http::result::SdkError<crate::error::GetCatalogImportStatusError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the catalog to migrate. Currently, this should be the Amazon Web Services account ID.</p>
        pub fn catalog_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.catalog_id(input);
            self
        }
        pub fn set_catalog_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_catalog_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetClassifier<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_classifier_input::Builder,
    }
    impl<C> GetClassifier<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetClassifierOutput,
            smithy_http::result::SdkError<crate::error::GetClassifierError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Name of the classifier to retrieve.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetClassifiers<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_classifiers_input::Builder,
    }
    impl<C> GetClassifiers<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetClassifiersOutput,
            smithy_http::result::SdkError<crate::error::GetClassifiersError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The size of the list to return (optional).</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>An optional continuation token.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetColumnStatisticsForPartition<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_column_statistics_for_partition_input::Builder,
    }
    impl<C> GetColumnStatisticsForPartition<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetColumnStatisticsForPartitionOutput,
            smithy_http::result::SdkError<crate::error::GetColumnStatisticsForPartitionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the Data Catalog where the partitions in question reside.
        /// If none is supplied, the Amazon Web Services account ID is used by default.</p>
        pub fn catalog_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.catalog_id(input);
            self
        }
        pub fn set_catalog_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_catalog_id(input);
            self
        }
        /// <p>The name of the catalog database where the partitions reside.</p>
        pub fn database_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.database_name(input);
            self
        }
        pub fn set_database_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_database_name(input);
            self
        }
        /// <p>The name of the partitions' table.</p>
        pub fn table_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.table_name(input);
            self
        }
        pub fn set_table_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_table_name(input);
            self
        }
        /// <p>A list of partition values identifying the partition.</p>
        pub fn partition_values(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.partition_values(inp);
            self
        }
        pub fn set_partition_values(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_partition_values(input);
            self
        }
        /// <p>A list of the column names.</p>
        pub fn column_names(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.column_names(inp);
            self
        }
        pub fn set_column_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_column_names(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetColumnStatisticsForTable<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_column_statistics_for_table_input::Builder,
    }
    impl<C> GetColumnStatisticsForTable<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetColumnStatisticsForTableOutput,
            smithy_http::result::SdkError<crate::error::GetColumnStatisticsForTableError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the Data Catalog where the partitions in question reside.
        /// If none is supplied, the Amazon Web Services account ID is used by default.</p>
        pub fn catalog_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.catalog_id(input);
            self
        }
        pub fn set_catalog_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_catalog_id(input);
            self
        }
        /// <p>The name of the catalog database where the partitions reside.</p>
        pub fn database_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.database_name(input);
            self
        }
        pub fn set_database_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_database_name(input);
            self
        }
        /// <p>The name of the partitions' table.</p>
        pub fn table_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.table_name(input);
            self
        }
        pub fn set_table_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_table_name(input);
            self
        }
        /// <p>A list of the column names.</p>
        pub fn column_names(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.column_names(inp);
            self
        }
        pub fn set_column_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_column_names(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetConnection<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_connection_input::Builder,
    }
    impl<C> GetConnection<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetConnectionOutput,
            smithy_http::result::SdkError<crate::error::GetConnectionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the Data Catalog in which the connection resides. If none is provided, the Amazon Web Services
        /// account ID is used by default.</p>
        pub fn catalog_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.catalog_id(input);
            self
        }
        pub fn set_catalog_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_catalog_id(input);
            self
        }
        /// <p>The name of the connection definition to retrieve.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>Allows you to retrieve the connection metadata without returning the password. For
        /// instance, the AWS Glue console uses this flag to retrieve the connection, and does not display
        /// the password. Set this parameter when the caller might not have permission to use the KMS
        /// key to decrypt the password, but it does have permission to access the rest of the connection
        /// properties.</p>
        pub fn hide_password(mut self, input: bool) -> Self {
            self.inner = self.inner.hide_password(input);
            self
        }
        pub fn set_hide_password(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_hide_password(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetConnections<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_connections_input::Builder,
    }
    impl<C> GetConnections<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetConnectionsOutput,
            smithy_http::result::SdkError<crate::error::GetConnectionsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the Data Catalog in which the connections reside. If none is provided, the Amazon Web Services
        /// account ID is used by default.</p>
        pub fn catalog_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.catalog_id(input);
            self
        }
        pub fn set_catalog_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_catalog_id(input);
            self
        }
        /// <p>A filter that controls which connections are returned.</p>
        pub fn filter(mut self, input: crate::model::GetConnectionsFilter) -> Self {
            self.inner = self.inner.filter(input);
            self
        }
        pub fn set_filter(
            mut self,
            input: std::option::Option<crate::model::GetConnectionsFilter>,
        ) -> Self {
            self.inner = self.inner.set_filter(input);
            self
        }
        /// <p>Allows you to retrieve the connection metadata without returning the password. For
        /// instance, the AWS Glue console uses this flag to retrieve the connection, and does not display
        /// the password. Set this parameter when the caller might not have permission to use the KMS
        /// key to decrypt the password, but it does have permission to access the rest of the connection
        /// properties.</p>
        pub fn hide_password(mut self, input: bool) -> Self {
            self.inner = self.inner.hide_password(input);
            self
        }
        pub fn set_hide_password(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_hide_password(input);
            self
        }
        /// <p>A continuation token, if this is a continuation call.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of connections to return in one response.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetCrawler<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_crawler_input::Builder,
    }
    impl<C> GetCrawler<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetCrawlerOutput,
            smithy_http::result::SdkError<crate::error::GetCrawlerError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the crawler to retrieve metadata for.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetCrawlerMetrics<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_crawler_metrics_input::Builder,
    }
    impl<C> GetCrawlerMetrics<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetCrawlerMetricsOutput,
            smithy_http::result::SdkError<crate::error::GetCrawlerMetricsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A list of the names of crawlers about which to retrieve metrics.</p>
        pub fn crawler_name_list(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.crawler_name_list(inp);
            self
        }
        pub fn set_crawler_name_list(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_crawler_name_list(input);
            self
        }
        /// <p>The maximum size of a list to return.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>A continuation token, if this is a continuation call.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetCrawlers<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_crawlers_input::Builder,
    }
    impl<C> GetCrawlers<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetCrawlersOutput,
            smithy_http::result::SdkError<crate::error::GetCrawlersError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The number of crawlers to return on each call.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>A continuation token, if this is a continuation request.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetDatabase<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_database_input::Builder,
    }
    impl<C> GetDatabase<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetDatabaseOutput,
            smithy_http::result::SdkError<crate::error::GetDatabaseError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the Data Catalog in which the database resides. If none is provided, the Amazon Web Services
        /// account ID is used by default.</p>
        pub fn catalog_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.catalog_id(input);
            self
        }
        pub fn set_catalog_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_catalog_id(input);
            self
        }
        /// <p>The name of the database to retrieve. For Hive compatibility, this
        /// should be all lowercase.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetDatabases<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_databases_input::Builder,
    }
    impl<C> GetDatabases<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetDatabasesOutput,
            smithy_http::result::SdkError<crate::error::GetDatabasesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the Data Catalog from which to retrieve <code>Databases</code>. If none is
        /// provided, the Amazon Web Services account ID is used by default.</p>
        pub fn catalog_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.catalog_id(input);
            self
        }
        pub fn set_catalog_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_catalog_id(input);
            self
        }
        /// <p>A continuation token, if this is a continuation call.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of databases to return in one response.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>Allows you to specify that you want to list the databases shared with your account. The allowable values are <code>FOREIGN</code> or <code>ALL</code>. </p>
        /// <ul>
        /// <li>
        /// <p>If set to <code>FOREIGN</code>, will list the databases shared with your account. </p>
        /// </li>
        /// <li>
        /// <p>If set to <code>ALL</code>, will list the databases shared with your account, as well as the databases in yor local account. </p>
        /// </li>
        /// </ul>
        pub fn resource_share_type(mut self, input: crate::model::ResourceShareType) -> Self {
            self.inner = self.inner.resource_share_type(input);
            self
        }
        pub fn set_resource_share_type(
            mut self,
            input: std::option::Option<crate::model::ResourceShareType>,
        ) -> Self {
            self.inner = self.inner.set_resource_share_type(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetDataCatalogEncryptionSettings<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_data_catalog_encryption_settings_input::Builder,
    }
    impl<C> GetDataCatalogEncryptionSettings<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetDataCatalogEncryptionSettingsOutput,
            smithy_http::result::SdkError<crate::error::GetDataCatalogEncryptionSettingsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the Data Catalog to retrieve the security configuration for. If none is
        /// provided, the Amazon Web Services account ID is used by default.</p>
        pub fn catalog_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.catalog_id(input);
            self
        }
        pub fn set_catalog_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_catalog_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetDataflowGraph<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_dataflow_graph_input::Builder,
    }
    impl<C> GetDataflowGraph<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetDataflowGraphOutput,
            smithy_http::result::SdkError<crate::error::GetDataflowGraphError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Python script to transform.</p>
        pub fn python_script(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.python_script(input);
            self
        }
        pub fn set_python_script(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_python_script(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetDevEndpoint<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_dev_endpoint_input::Builder,
    }
    impl<C> GetDevEndpoint<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetDevEndpointOutput,
            smithy_http::result::SdkError<crate::error::GetDevEndpointError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Name of the <code>DevEndpoint</code> to retrieve information for.</p>
        pub fn endpoint_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.endpoint_name(input);
            self
        }
        pub fn set_endpoint_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_endpoint_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetDevEndpoints<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_dev_endpoints_input::Builder,
    }
    impl<C> GetDevEndpoints<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetDevEndpointsOutput,
            smithy_http::result::SdkError<crate::error::GetDevEndpointsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The maximum size of information to return.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>A continuation token, if this is a continuation call.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetJob<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_job_input::Builder,
    }
    impl<C> GetJob<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetJobOutput,
            smithy_http::result::SdkError<crate::error::GetJobError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the job definition to retrieve.</p>
        pub fn job_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.job_name(input);
            self
        }
        pub fn set_job_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_job_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetJobBookmark<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_job_bookmark_input::Builder,
    }
    impl<C> GetJobBookmark<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetJobBookmarkOutput,
            smithy_http::result::SdkError<crate::error::GetJobBookmarkError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the job in question.</p>
        pub fn job_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.job_name(input);
            self
        }
        pub fn set_job_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_job_name(input);
            self
        }
        /// <p>The unique run identifier associated with this job run.</p>
        pub fn run_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.run_id(input);
            self
        }
        pub fn set_run_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_run_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetJobRun<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_job_run_input::Builder,
    }
    impl<C> GetJobRun<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetJobRunOutput,
            smithy_http::result::SdkError<crate::error::GetJobRunError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Name of the job definition being run.</p>
        pub fn job_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.job_name(input);
            self
        }
        pub fn set_job_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_job_name(input);
            self
        }
        /// <p>The ID of the job run.</p>
        pub fn run_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.run_id(input);
            self
        }
        pub fn set_run_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_run_id(input);
            self
        }
        /// <p>True if a list of predecessor runs should be returned.</p>
        pub fn predecessors_included(mut self, input: bool) -> Self {
            self.inner = self.inner.predecessors_included(input);
            self
        }
        pub fn set_predecessors_included(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_predecessors_included(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetJobRuns<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_job_runs_input::Builder,
    }
    impl<C> GetJobRuns<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetJobRunsOutput,
            smithy_http::result::SdkError<crate::error::GetJobRunsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the job definition for which to retrieve all job runs.</p>
        pub fn job_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.job_name(input);
            self
        }
        pub fn set_job_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_job_name(input);
            self
        }
        /// <p>A continuation token, if this is a continuation call.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum size of the response.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetJobs<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_jobs_input::Builder,
    }
    impl<C> GetJobs<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetJobsOutput,
            smithy_http::result::SdkError<crate::error::GetJobsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A continuation token, if this is a continuation call.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum size of the response.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetMapping<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_mapping_input::Builder,
    }
    impl<C> GetMapping<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetMappingOutput,
            smithy_http::result::SdkError<crate::error::GetMappingError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Specifies the source table.</p>
        pub fn source(mut self, input: crate::model::CatalogEntry) -> Self {
            self.inner = self.inner.source(input);
            self
        }
        pub fn set_source(
            mut self,
            input: std::option::Option<crate::model::CatalogEntry>,
        ) -> Self {
            self.inner = self.inner.set_source(input);
            self
        }
        /// <p>A list of target tables.</p>
        pub fn sinks(mut self, inp: impl Into<crate::model::CatalogEntry>) -> Self {
            self.inner = self.inner.sinks(inp);
            self
        }
        pub fn set_sinks(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::CatalogEntry>>,
        ) -> Self {
            self.inner = self.inner.set_sinks(input);
            self
        }
        /// <p>Parameters for the mapping.</p>
        pub fn location(mut self, input: crate::model::Location) -> Self {
            self.inner = self.inner.location(input);
            self
        }
        pub fn set_location(mut self, input: std::option::Option<crate::model::Location>) -> Self {
            self.inner = self.inner.set_location(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetMLTaskRun<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_ml_task_run_input::Builder,
    }
    impl<C> GetMLTaskRun<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetMlTaskRunOutput,
            smithy_http::result::SdkError<crate::error::GetMLTaskRunError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The unique identifier of the machine learning transform.</p>
        pub fn transform_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.transform_id(input);
            self
        }
        pub fn set_transform_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_transform_id(input);
            self
        }
        /// <p>The unique identifier of the task run.</p>
        pub fn task_run_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.task_run_id(input);
            self
        }
        pub fn set_task_run_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_task_run_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetMLTaskRuns<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_ml_task_runs_input::Builder,
    }
    impl<C> GetMLTaskRuns<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetMlTaskRunsOutput,
            smithy_http::result::SdkError<crate::error::GetMLTaskRunsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The unique identifier of the machine learning transform.</p>
        pub fn transform_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.transform_id(input);
            self
        }
        pub fn set_transform_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_transform_id(input);
            self
        }
        /// <p>A token for pagination of the results. The default is empty.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of results to return. </p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The filter criteria, in the <code>TaskRunFilterCriteria</code> structure, for the task run.</p>
        pub fn filter(mut self, input: crate::model::TaskRunFilterCriteria) -> Self {
            self.inner = self.inner.filter(input);
            self
        }
        pub fn set_filter(
            mut self,
            input: std::option::Option<crate::model::TaskRunFilterCriteria>,
        ) -> Self {
            self.inner = self.inner.set_filter(input);
            self
        }
        /// <p>The sorting criteria, in the <code>TaskRunSortCriteria</code> structure, for the task run.</p>
        pub fn sort(mut self, input: crate::model::TaskRunSortCriteria) -> Self {
            self.inner = self.inner.sort(input);
            self
        }
        pub fn set_sort(
            mut self,
            input: std::option::Option<crate::model::TaskRunSortCriteria>,
        ) -> Self {
            self.inner = self.inner.set_sort(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetMLTransform<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_ml_transform_input::Builder,
    }
    impl<C> GetMLTransform<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetMlTransformOutput,
            smithy_http::result::SdkError<crate::error::GetMLTransformError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The unique identifier of the transform, generated at the time that the transform was
        /// created.</p>
        pub fn transform_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.transform_id(input);
            self
        }
        pub fn set_transform_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_transform_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetMLTransforms<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_ml_transforms_input::Builder,
    }
    impl<C> GetMLTransforms<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetMlTransformsOutput,
            smithy_http::result::SdkError<crate::error::GetMLTransformsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A paginated token to offset the results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of results to return.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The filter transformation criteria.</p>
        pub fn filter(mut self, input: crate::model::TransformFilterCriteria) -> Self {
            self.inner = self.inner.filter(input);
            self
        }
        pub fn set_filter(
            mut self,
            input: std::option::Option<crate::model::TransformFilterCriteria>,
        ) -> Self {
            self.inner = self.inner.set_filter(input);
            self
        }
        /// <p>The sorting criteria.</p>
        pub fn sort(mut self, input: crate::model::TransformSortCriteria) -> Self {
            self.inner = self.inner.sort(input);
            self
        }
        pub fn set_sort(
            mut self,
            input: std::option::Option<crate::model::TransformSortCriteria>,
        ) -> Self {
            self.inner = self.inner.set_sort(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetPartition<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_partition_input::Builder,
    }
    impl<C> GetPartition<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetPartitionOutput,
            smithy_http::result::SdkError<crate::error::GetPartitionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the Data Catalog where the partition in question resides. If none is provided,
        /// the Amazon Web Services account ID is used by default.</p>
        pub fn catalog_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.catalog_id(input);
            self
        }
        pub fn set_catalog_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_catalog_id(input);
            self
        }
        /// <p>The name of the catalog database where the partition resides.</p>
        pub fn database_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.database_name(input);
            self
        }
        pub fn set_database_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_database_name(input);
            self
        }
        /// <p>The name of the partition's table.</p>
        pub fn table_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.table_name(input);
            self
        }
        pub fn set_table_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_table_name(input);
            self
        }
        /// <p>The values that define the partition.</p>
        pub fn partition_values(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.partition_values(inp);
            self
        }
        pub fn set_partition_values(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_partition_values(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetPartitionIndexes<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_partition_indexes_input::Builder,
    }
    impl<C> GetPartitionIndexes<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetPartitionIndexesOutput,
            smithy_http::result::SdkError<crate::error::GetPartitionIndexesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The catalog ID where the table resides.</p>
        pub fn catalog_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.catalog_id(input);
            self
        }
        pub fn set_catalog_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_catalog_id(input);
            self
        }
        /// <p>Specifies the name of a database from which you want to retrieve partition indexes.</p>
        pub fn database_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.database_name(input);
            self
        }
        pub fn set_database_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_database_name(input);
            self
        }
        /// <p>Specifies the name of a table for which you want to retrieve the partition indexes.</p>
        pub fn table_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.table_name(input);
            self
        }
        pub fn set_table_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_table_name(input);
            self
        }
        /// <p>A continuation token, included if this is a continuation call.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetPartitions<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_partitions_input::Builder,
    }
    impl<C> GetPartitions<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetPartitionsOutput,
            smithy_http::result::SdkError<crate::error::GetPartitionsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the Data Catalog where the partitions in question reside. If none is provided,
        /// the Amazon Web Services account ID is used by default.</p>
        pub fn catalog_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.catalog_id(input);
            self
        }
        pub fn set_catalog_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_catalog_id(input);
            self
        }
        /// <p>The name of the catalog database where the partitions reside.</p>
        pub fn database_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.database_name(input);
            self
        }
        pub fn set_database_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_database_name(input);
            self
        }
        /// <p>The name of the partitions' table.</p>
        pub fn table_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.table_name(input);
            self
        }
        pub fn set_table_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_table_name(input);
            self
        }
        /// <p>An expression that filters the partitions to be returned.</p>
        /// <p>The expression uses SQL syntax similar to the SQL <code>WHERE</code> filter clause. The
        /// SQL statement parser <a href="http://jsqlparser.sourceforge.net/home.php">JSQLParser</a> parses the expression. </p>
        /// <p>
        /// <i>Operators</i>: The following are the operators that you can use in the
        /// <code>Expression</code> API call:</p>
        /// <dl>
        /// <dt>=</dt>
        /// <dd>
        /// <p>Checks whether the values of the two operands are equal; if yes, then the condition becomes
        /// true.</p>
        /// <p>Example: Assume 'variable a' holds 10 and 'variable b' holds 20. </p>
        /// <p>(a = b) is not true.</p>
        /// </dd>
        /// <dt>< ></dt>
        /// <dd>
        /// <p>Checks whether the values of two operands are equal; if the values are not equal,
        /// then the condition becomes true.</p>
        /// <p>Example: (a < > b) is true.</p>
        /// </dd>
        /// <dt>></dt>
        /// <dd>
        /// <p>Checks whether the value of the left operand is greater than the value of the right
        /// operand; if yes, then the condition becomes true.</p>
        /// <p>Example: (a > b) is not true.</p>
        /// </dd>
        /// <dt><</dt>
        /// <dd>
        /// <p>Checks whether the value of the left operand is less than the value of the right
        /// operand; if yes, then the condition becomes true.</p>
        /// <p>Example: (a < b) is true.</p>
        /// </dd>
        /// <dt>>=</dt>
        /// <dd>
        /// <p>Checks whether the value of the left operand is greater than or equal to the value
        /// of the right operand; if yes, then the condition becomes true.</p>
        /// <p>Example: (a >= b) is not true.</p>
        /// </dd>
        /// <dt><=</dt>
        /// <dd>
        /// <p>Checks whether the value of the left operand is less than or equal to the value of
        /// the right operand; if yes, then the condition becomes true.</p>
        /// <p>Example: (a <= b) is true.</p>
        /// </dd>
        /// <dt>AND, OR, IN, BETWEEN, LIKE, NOT, IS NULL</dt>
        /// <dd>
        /// <p>Logical operators.</p>
        /// </dd>
        /// </dl>
        /// <p>
        /// <i>Supported Partition Key Types</i>: The following are the supported
        /// partition keys.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>string</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>date</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>timestamp</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>int</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>bigint</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>long</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>tinyint</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>smallint</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>decimal</code>
        /// </p>
        /// </li>
        /// </ul>
        /// <p>If an type is encountered that is not valid, an exception is thrown. </p>
        /// <p>The following list shows the valid operators on each type. When you define a crawler, the
        /// <code>partitionKey</code> type is created as a <code>STRING</code>, to be compatible with the catalog
        /// partitions. </p>
        /// <p>
        /// <i>Sample API Call</i>: </p>
        pub fn expression(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.expression(input);
            self
        }
        pub fn set_expression(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_expression(input);
            self
        }
        /// <p>A continuation token, if this is not the first call to retrieve
        /// these partitions.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The segment of the table's partitions to scan in this request.</p>
        pub fn segment(mut self, input: crate::model::Segment) -> Self {
            self.inner = self.inner.segment(input);
            self
        }
        pub fn set_segment(mut self, input: std::option::Option<crate::model::Segment>) -> Self {
            self.inner = self.inner.set_segment(input);
            self
        }
        /// <p>The maximum number of partitions to return in a single response.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        pub fn exclude_column_schema(mut self, input: bool) -> Self {
            self.inner = self.inner.exclude_column_schema(input);
            self
        }
        pub fn set_exclude_column_schema(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_exclude_column_schema(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetPlan<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_plan_input::Builder,
    }
    impl<C> GetPlan<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetPlanOutput,
            smithy_http::result::SdkError<crate::error::GetPlanError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The list of mappings from a source table to target tables.</p>
        pub fn mapping(mut self, inp: impl Into<crate::model::MappingEntry>) -> Self {
            self.inner = self.inner.mapping(inp);
            self
        }
        pub fn set_mapping(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::MappingEntry>>,
        ) -> Self {
            self.inner = self.inner.set_mapping(input);
            self
        }
        /// <p>The source table.</p>
        pub fn source(mut self, input: crate::model::CatalogEntry) -> Self {
            self.inner = self.inner.source(input);
            self
        }
        pub fn set_source(
            mut self,
            input: std::option::Option<crate::model::CatalogEntry>,
        ) -> Self {
            self.inner = self.inner.set_source(input);
            self
        }
        /// <p>The target tables.</p>
        pub fn sinks(mut self, inp: impl Into<crate::model::CatalogEntry>) -> Self {
            self.inner = self.inner.sinks(inp);
            self
        }
        pub fn set_sinks(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::CatalogEntry>>,
        ) -> Self {
            self.inner = self.inner.set_sinks(input);
            self
        }
        /// <p>The parameters for the mapping.</p>
        pub fn location(mut self, input: crate::model::Location) -> Self {
            self.inner = self.inner.location(input);
            self
        }
        pub fn set_location(mut self, input: std::option::Option<crate::model::Location>) -> Self {
            self.inner = self.inner.set_location(input);
            self
        }
        /// <p>The programming language of the code to perform the mapping.</p>
        pub fn language(mut self, input: crate::model::Language) -> Self {
            self.inner = self.inner.language(input);
            self
        }
        pub fn set_language(mut self, input: std::option::Option<crate::model::Language>) -> Self {
            self.inner = self.inner.set_language(input);
            self
        }
        /// <p>A map to hold additional optional key-value parameters.</p>
        /// <p>Currently, these key-value pairs are supported:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>inferSchema</code>  —  Specifies whether to set <code>inferSchema</code> to true or false for the default script generated by an Glue job. For example, to set <code>inferSchema</code> to true, pass the following key value pair:</p>
        /// <p>
        /// <code>--additional-plan-options-map '{"inferSchema":"true"}'</code>
        /// </p>
        /// </li>
        /// </ul>
        pub fn additional_plan_options_map(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.additional_plan_options_map(k, v);
            self
        }
        pub fn set_additional_plan_options_map(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_additional_plan_options_map(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetRegistry<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_registry_input::Builder,
    }
    impl<C> GetRegistry<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetRegistryOutput,
            smithy_http::result::SdkError<crate::error::GetRegistryError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>This is a wrapper structure that may contain the registry name and Amazon Resource Name (ARN).</p>
        pub fn registry_id(mut self, input: crate::model::RegistryId) -> Self {
            self.inner = self.inner.registry_id(input);
            self
        }
        pub fn set_registry_id(
            mut self,
            input: std::option::Option<crate::model::RegistryId>,
        ) -> Self {
            self.inner = self.inner.set_registry_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetResourcePolicies<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_resource_policies_input::Builder,
    }
    impl<C> GetResourcePolicies<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetResourcePoliciesOutput,
            smithy_http::result::SdkError<crate::error::GetResourcePoliciesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A continuation token, if this is a continuation request.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum size of a list to return.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetResourcePolicy<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_resource_policy_input::Builder,
    }
    impl<C> GetResourcePolicy<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetResourcePolicyOutput,
            smithy_http::result::SdkError<crate::error::GetResourcePolicyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ARN of the Glue resource for which to retrieve the resource policy. If not
        /// supplied, the Data Catalog resource policy is returned. Use <code>GetResourcePolicies</code>
        /// to view all existing resource policies. For more information see <a href="https://docs.aws.amazon.com/glue/latest/dg/glue-specifying-resource-arns.html">Specifying Glue Resource ARNs</a>.
        /// </p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(input);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetSchema<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_schema_input::Builder,
    }
    impl<C> GetSchema<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetSchemaOutput,
            smithy_http::result::SdkError<crate::error::GetSchemaError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>This is a wrapper structure to contain schema identity fields. The structure contains:</p>
        /// <ul>
        /// <li>
        /// <p>SchemaId$SchemaArn: The Amazon Resource Name (ARN) of the schema. Either <code>SchemaArn</code> or <code>SchemaName</code> and <code>RegistryName</code> has to be provided.</p>
        /// </li>
        /// <li>
        /// <p>SchemaId$SchemaName: The name of the schema. Either <code>SchemaArn</code> or <code>SchemaName</code> and <code>RegistryName</code> has to be provided.</p>
        /// </li>
        /// </ul>
        pub fn schema_id(mut self, input: crate::model::SchemaId) -> Self {
            self.inner = self.inner.schema_id(input);
            self
        }
        pub fn set_schema_id(mut self, input: std::option::Option<crate::model::SchemaId>) -> Self {
            self.inner = self.inner.set_schema_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetSchemaByDefinition<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_schema_by_definition_input::Builder,
    }
    impl<C> GetSchemaByDefinition<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetSchemaByDefinitionOutput,
            smithy_http::result::SdkError<crate::error::GetSchemaByDefinitionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>This is a wrapper structure to contain schema identity fields. The structure contains:</p>
        /// <ul>
        /// <li>
        /// <p>SchemaId$SchemaArn: The Amazon Resource Name (ARN) of the schema. One of <code>SchemaArn</code> or <code>SchemaName</code> has to be provided.</p>
        /// </li>
        /// <li>
        /// <p>SchemaId$SchemaName: The name of the schema. One of <code>SchemaArn</code> or <code>SchemaName</code> has to be provided.</p>
        /// </li>
        /// </ul>
        pub fn schema_id(mut self, input: crate::model::SchemaId) -> Self {
            self.inner = self.inner.schema_id(input);
            self
        }
        pub fn set_schema_id(mut self, input: std::option::Option<crate::model::SchemaId>) -> Self {
            self.inner = self.inner.set_schema_id(input);
            self
        }
        /// <p>The definition of the schema for which schema details are required.</p>
        pub fn schema_definition(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.schema_definition(input);
            self
        }
        pub fn set_schema_definition(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_schema_definition(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetSchemaVersion<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_schema_version_input::Builder,
    }
    impl<C> GetSchemaVersion<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetSchemaVersionOutput,
            smithy_http::result::SdkError<crate::error::GetSchemaVersionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>This is a wrapper structure to contain schema identity fields. The structure contains:</p>
        /// <ul>
        /// <li>
        /// <p>SchemaId$SchemaArn: The Amazon Resource Name (ARN) of the schema. Either <code>SchemaArn</code> or <code>SchemaName</code> and <code>RegistryName</code> has to be provided.</p>
        /// </li>
        /// <li>
        /// <p>SchemaId$SchemaName: The name of the schema. Either <code>SchemaArn</code> or <code>SchemaName</code> and <code>RegistryName</code> has to be provided.</p>
        /// </li>
        /// </ul>
        pub fn schema_id(mut self, input: crate::model::SchemaId) -> Self {
            self.inner = self.inner.schema_id(input);
            self
        }
        pub fn set_schema_id(mut self, input: std::option::Option<crate::model::SchemaId>) -> Self {
            self.inner = self.inner.set_schema_id(input);
            self
        }
        /// <p>The <code>SchemaVersionId</code> of the schema version. This field is required for fetching by schema ID. Either this or the <code>SchemaId</code> wrapper has to be provided.</p>
        pub fn schema_version_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.schema_version_id(input);
            self
        }
        pub fn set_schema_version_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_schema_version_id(input);
            self
        }
        /// <p>The version number of the schema.</p>
        pub fn schema_version_number(mut self, input: crate::model::SchemaVersionNumber) -> Self {
            self.inner = self.inner.schema_version_number(input);
            self
        }
        pub fn set_schema_version_number(
            mut self,
            input: std::option::Option<crate::model::SchemaVersionNumber>,
        ) -> Self {
            self.inner = self.inner.set_schema_version_number(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetSchemaVersionsDiff<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_schema_versions_diff_input::Builder,
    }
    impl<C> GetSchemaVersionsDiff<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetSchemaVersionsDiffOutput,
            smithy_http::result::SdkError<crate::error::GetSchemaVersionsDiffError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>This is a wrapper structure to contain schema identity fields. The structure contains:</p>
        /// <ul>
        /// <li>
        /// <p>SchemaId$SchemaArn: The Amazon Resource Name (ARN) of the schema. One of <code>SchemaArn</code> or <code>SchemaName</code> has to be provided.</p>
        /// </li>
        /// <li>
        /// <p>SchemaId$SchemaName: The name of the schema. One of <code>SchemaArn</code> or <code>SchemaName</code> has to be provided.</p>
        /// </li>
        /// </ul>
        pub fn schema_id(mut self, input: crate::model::SchemaId) -> Self {
            self.inner = self.inner.schema_id(input);
            self
        }
        pub fn set_schema_id(mut self, input: std::option::Option<crate::model::SchemaId>) -> Self {
            self.inner = self.inner.set_schema_id(input);
            self
        }
        /// <p>The first of the two schema versions to be compared.</p>
        pub fn first_schema_version_number(
            mut self,
            input: crate::model::SchemaVersionNumber,
        ) -> Self {
            self.inner = self.inner.first_schema_version_number(input);
            self
        }
        pub fn set_first_schema_version_number(
            mut self,
            input: std::option::Option<crate::model::SchemaVersionNumber>,
        ) -> Self {
            self.inner = self.inner.set_first_schema_version_number(input);
            self
        }
        /// <p>The second of the two schema versions to be compared.</p>
        pub fn second_schema_version_number(
            mut self,
            input: crate::model::SchemaVersionNumber,
        ) -> Self {
            self.inner = self.inner.second_schema_version_number(input);
            self
        }
        pub fn set_second_schema_version_number(
            mut self,
            input: std::option::Option<crate::model::SchemaVersionNumber>,
        ) -> Self {
            self.inner = self.inner.set_second_schema_version_number(input);
            self
        }
        /// <p>Refers to <code>SYNTAX_DIFF</code>, which is the currently supported diff type.</p>
        pub fn schema_diff_type(mut self, input: crate::model::SchemaDiffType) -> Self {
            self.inner = self.inner.schema_diff_type(input);
            self
        }
        pub fn set_schema_diff_type(
            mut self,
            input: std::option::Option<crate::model::SchemaDiffType>,
        ) -> Self {
            self.inner = self.inner.set_schema_diff_type(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetSecurityConfiguration<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_security_configuration_input::Builder,
    }
    impl<C> GetSecurityConfiguration<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetSecurityConfigurationOutput,
            smithy_http::result::SdkError<crate::error::GetSecurityConfigurationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the security configuration to retrieve.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetSecurityConfigurations<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_security_configurations_input::Builder,
    }
    impl<C> GetSecurityConfigurations<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetSecurityConfigurationsOutput,
            smithy_http::result::SdkError<crate::error::GetSecurityConfigurationsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The maximum number of results to return.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>A continuation token, if this is a continuation call.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetTable<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_table_input::Builder,
    }
    impl<C> GetTable<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetTableOutput,
            smithy_http::result::SdkError<crate::error::GetTableError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the Data Catalog where the table resides. If none is provided, the Amazon Web Services account
        /// ID is used by default.</p>
        pub fn catalog_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.catalog_id(input);
            self
        }
        pub fn set_catalog_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_catalog_id(input);
            self
        }
        /// <p>The name of the database in the catalog in which the table resides.
        /// For Hive compatibility, this name is entirely lowercase.</p>
        pub fn database_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.database_name(input);
            self
        }
        pub fn set_database_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_database_name(input);
            self
        }
        /// <p>The name of the table for which to retrieve the definition. For Hive
        /// compatibility, this name is entirely lowercase.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetTables<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_tables_input::Builder,
    }
    impl<C> GetTables<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetTablesOutput,
            smithy_http::result::SdkError<crate::error::GetTablesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the Data Catalog where the tables reside. If none is provided, the Amazon Web Services account
        /// ID is used by default.</p>
        pub fn catalog_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.catalog_id(input);
            self
        }
        pub fn set_catalog_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_catalog_id(input);
            self
        }
        /// <p>The database in the catalog whose tables to list. For Hive
        /// compatibility, this name is entirely lowercase.</p>
        pub fn database_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.database_name(input);
            self
        }
        pub fn set_database_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_database_name(input);
            self
        }
        /// <p>A regular expression pattern. If present, only those tables
        /// whose names match the pattern are returned.</p>
        pub fn expression(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.expression(input);
            self
        }
        pub fn set_expression(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_expression(input);
            self
        }
        /// <p>A continuation token, included if this is a continuation call.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of tables to return in a single response.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetTableVersion<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_table_version_input::Builder,
    }
    impl<C> GetTableVersion<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetTableVersionOutput,
            smithy_http::result::SdkError<crate::error::GetTableVersionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the Data Catalog where the tables reside. If none is provided, the Amazon Web Services account
        /// ID is used by default.</p>
        pub fn catalog_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.catalog_id(input);
            self
        }
        pub fn set_catalog_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_catalog_id(input);
            self
        }
        /// <p>The database in the catalog in which the table resides. For Hive
        /// compatibility, this name is entirely lowercase.</p>
        pub fn database_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.database_name(input);
            self
        }
        pub fn set_database_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_database_name(input);
            self
        }
        /// <p>The name of the table. For Hive compatibility,
        /// this name is entirely lowercase.</p>
        pub fn table_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.table_name(input);
            self
        }
        pub fn set_table_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_table_name(input);
            self
        }
        /// <p>The ID value of the table version to be retrieved. A <code>VersionID</code> is a string representation of an integer. Each version is incremented by 1. </p>
        pub fn version_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.version_id(input);
            self
        }
        pub fn set_version_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_version_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetTableVersions<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_table_versions_input::Builder,
    }
    impl<C> GetTableVersions<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetTableVersionsOutput,
            smithy_http::result::SdkError<crate::error::GetTableVersionsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the Data Catalog where the tables reside. If none is provided, the Amazon Web Services account
        /// ID is used by default.</p>
        pub fn catalog_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.catalog_id(input);
            self
        }
        pub fn set_catalog_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_catalog_id(input);
            self
        }
        /// <p>The database in the catalog in which the table resides. For Hive
        /// compatibility, this name is entirely lowercase.</p>
        pub fn database_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.database_name(input);
            self
        }
        pub fn set_database_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_database_name(input);
            self
        }
        /// <p>The name of the table. For Hive
        /// compatibility, this name is entirely lowercase.</p>
        pub fn table_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.table_name(input);
            self
        }
        pub fn set_table_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_table_name(input);
            self
        }
        /// <p>A continuation token, if this is not the first call.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of table versions to return in one response.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetTags<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_tags_input::Builder,
    }
    impl<C> GetTags<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetTagsOutput,
            smithy_http::result::SdkError<crate::error::GetTagsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the resource for which to retrieve tags.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(input);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetTrigger<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_trigger_input::Builder,
    }
    impl<C> GetTrigger<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetTriggerOutput,
            smithy_http::result::SdkError<crate::error::GetTriggerError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the trigger to retrieve.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetTriggers<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_triggers_input::Builder,
    }
    impl<C> GetTriggers<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetTriggersOutput,
            smithy_http::result::SdkError<crate::error::GetTriggersError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A continuation token, if this is a continuation call.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The name of the job to retrieve triggers for. The trigger that can start this job is
        /// returned, and if there is no such trigger, all triggers are returned.</p>
        pub fn dependent_job_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.dependent_job_name(input);
            self
        }
        pub fn set_dependent_job_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_dependent_job_name(input);
            self
        }
        /// <p>The maximum size of the response.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetUserDefinedFunction<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_user_defined_function_input::Builder,
    }
    impl<C> GetUserDefinedFunction<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetUserDefinedFunctionOutput,
            smithy_http::result::SdkError<crate::error::GetUserDefinedFunctionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the Data Catalog where the function to be retrieved is located. If none is
        /// provided, the Amazon Web Services account ID is used by default.</p>
        pub fn catalog_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.catalog_id(input);
            self
        }
        pub fn set_catalog_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_catalog_id(input);
            self
        }
        /// <p>The name of the catalog database where the function is located.</p>
        pub fn database_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.database_name(input);
            self
        }
        pub fn set_database_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_database_name(input);
            self
        }
        /// <p>The name of the function.</p>
        pub fn function_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.function_name(input);
            self
        }
        pub fn set_function_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_function_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetUserDefinedFunctions<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_user_defined_functions_input::Builder,
    }
    impl<C> GetUserDefinedFunctions<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetUserDefinedFunctionsOutput,
            smithy_http::result::SdkError<crate::error::GetUserDefinedFunctionsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the Data Catalog where the functions to be retrieved are located. If none is
        /// provided, the Amazon Web Services account ID is used by default.</p>
        pub fn catalog_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.catalog_id(input);
            self
        }
        pub fn set_catalog_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_catalog_id(input);
            self
        }
        /// <p>The name of the catalog database where the functions are located. If none is provided, functions from all the
        /// databases across the catalog will be returned.</p>
        pub fn database_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.database_name(input);
            self
        }
        pub fn set_database_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_database_name(input);
            self
        }
        /// <p>An optional function-name pattern string that filters the function
        /// definitions returned.</p>
        pub fn pattern(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.pattern(input);
            self
        }
        pub fn set_pattern(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_pattern(input);
            self
        }
        /// <p>A continuation token, if this is a continuation call.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of functions to return in one response.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetWorkflow<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_workflow_input::Builder,
    }
    impl<C> GetWorkflow<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetWorkflowOutput,
            smithy_http::result::SdkError<crate::error::GetWorkflowError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the workflow to retrieve.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>Specifies whether to include a graph when returning the workflow resource metadata.</p>
        pub fn include_graph(mut self, input: bool) -> Self {
            self.inner = self.inner.include_graph(input);
            self
        }
        pub fn set_include_graph(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_include_graph(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetWorkflowRun<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_workflow_run_input::Builder,
    }
    impl<C> GetWorkflowRun<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetWorkflowRunOutput,
            smithy_http::result::SdkError<crate::error::GetWorkflowRunError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Name of the workflow being run.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>The ID of the workflow run.</p>
        pub fn run_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.run_id(input);
            self
        }
        pub fn set_run_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_run_id(input);
            self
        }
        /// <p>Specifies whether to include the workflow graph in response or not.</p>
        pub fn include_graph(mut self, input: bool) -> Self {
            self.inner = self.inner.include_graph(input);
            self
        }
        pub fn set_include_graph(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_include_graph(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetWorkflowRunProperties<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_workflow_run_properties_input::Builder,
    }
    impl<C> GetWorkflowRunProperties<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetWorkflowRunPropertiesOutput,
            smithy_http::result::SdkError<crate::error::GetWorkflowRunPropertiesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Name of the workflow which was run.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>The ID of the workflow run whose run properties should be returned.</p>
        pub fn run_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.run_id(input);
            self
        }
        pub fn set_run_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_run_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetWorkflowRuns<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_workflow_runs_input::Builder,
    }
    impl<C> GetWorkflowRuns<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetWorkflowRunsOutput,
            smithy_http::result::SdkError<crate::error::GetWorkflowRunsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Name of the workflow whose metadata of runs should be returned.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>Specifies whether to include the workflow graph in response or not.</p>
        pub fn include_graph(mut self, input: bool) -> Self {
            self.inner = self.inner.include_graph(input);
            self
        }
        pub fn set_include_graph(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_include_graph(input);
            self
        }
        /// <p>The maximum size of the response.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of workflow runs to be included in the response.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ImportCatalogToGlue<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::import_catalog_to_glue_input::Builder,
    }
    impl<C> ImportCatalogToGlue<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ImportCatalogToGlueOutput,
            smithy_http::result::SdkError<crate::error::ImportCatalogToGlueError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the catalog to import. Currently, this should be the Amazon Web Services account ID.</p>
        pub fn catalog_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.catalog_id(input);
            self
        }
        pub fn set_catalog_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_catalog_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListCrawlers<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_crawlers_input::Builder,
    }
    impl<C> ListCrawlers<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListCrawlersOutput,
            smithy_http::result::SdkError<crate::error::ListCrawlersError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The maximum size of a list to return.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>A continuation token, if this is a continuation request.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>Specifies to return only these tagged resources.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.tags(k, v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListDevEndpoints<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_dev_endpoints_input::Builder,
    }
    impl<C> ListDevEndpoints<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListDevEndpointsOutput,
            smithy_http::result::SdkError<crate::error::ListDevEndpointsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A continuation token, if this is a continuation request.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum size of a list to return.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>Specifies to return only these tagged resources.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.tags(k, v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListJobs<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_jobs_input::Builder,
    }
    impl<C> ListJobs<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListJobsOutput,
            smithy_http::result::SdkError<crate::error::ListJobsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A continuation token, if this is a continuation request.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum size of a list to return.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>Specifies to return only these tagged resources.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.tags(k, v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListMLTransforms<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_ml_transforms_input::Builder,
    }
    impl<C> ListMLTransforms<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListMlTransformsOutput,
            smithy_http::result::SdkError<crate::error::ListMLTransformsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A continuation token, if this is a continuation request.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum size of a list to return.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>A <code>TransformFilterCriteria</code> used to filter the machine learning transforms.</p>
        pub fn filter(mut self, input: crate::model::TransformFilterCriteria) -> Self {
            self.inner = self.inner.filter(input);
            self
        }
        pub fn set_filter(
            mut self,
            input: std::option::Option<crate::model::TransformFilterCriteria>,
        ) -> Self {
            self.inner = self.inner.set_filter(input);
            self
        }
        /// <p>A <code>TransformSortCriteria</code> used to sort the machine learning transforms.</p>
        pub fn sort(mut self, input: crate::model::TransformSortCriteria) -> Self {
            self.inner = self.inner.sort(input);
            self
        }
        pub fn set_sort(
            mut self,
            input: std::option::Option<crate::model::TransformSortCriteria>,
        ) -> Self {
            self.inner = self.inner.set_sort(input);
            self
        }
        /// <p>Specifies to return only these tagged resources.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.tags(k, v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListRegistries<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_registries_input::Builder,
    }
    impl<C> ListRegistries<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListRegistriesOutput,
            smithy_http::result::SdkError<crate::error::ListRegistriesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Maximum number of results required per page. If the value is not supplied, this will be defaulted to 25 per page.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>A continuation token, if this is a continuation call.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListSchemas<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_schemas_input::Builder,
    }
    impl<C> ListSchemas<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListSchemasOutput,
            smithy_http::result::SdkError<crate::error::ListSchemasError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A wrapper structure that may contain the registry name and Amazon Resource Name (ARN).</p>
        pub fn registry_id(mut self, input: crate::model::RegistryId) -> Self {
            self.inner = self.inner.registry_id(input);
            self
        }
        pub fn set_registry_id(
            mut self,
            input: std::option::Option<crate::model::RegistryId>,
        ) -> Self {
            self.inner = self.inner.set_registry_id(input);
            self
        }
        /// <p>Maximum number of results required per page. If the value is not supplied, this will be defaulted to 25 per page.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>A continuation token, if this is a continuation call.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListSchemaVersions<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_schema_versions_input::Builder,
    }
    impl<C> ListSchemaVersions<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListSchemaVersionsOutput,
            smithy_http::result::SdkError<crate::error::ListSchemaVersionsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>This is a wrapper structure to contain schema identity fields. The structure contains:</p>
        /// <ul>
        /// <li>
        /// <p>SchemaId$SchemaArn: The Amazon Resource Name (ARN) of the schema. Either <code>SchemaArn</code> or <code>SchemaName</code> and <code>RegistryName</code> has to be provided.</p>
        /// </li>
        /// <li>
        /// <p>SchemaId$SchemaName: The name of the schema. Either <code>SchemaArn</code> or <code>SchemaName</code> and <code>RegistryName</code> has to be provided.</p>
        /// </li>
        /// </ul>
        pub fn schema_id(mut self, input: crate::model::SchemaId) -> Self {
            self.inner = self.inner.schema_id(input);
            self
        }
        pub fn set_schema_id(mut self, input: std::option::Option<crate::model::SchemaId>) -> Self {
            self.inner = self.inner.set_schema_id(input);
            self
        }
        /// <p>Maximum number of results required per page. If the value is not supplied, this will be defaulted to 25 per page.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>A continuation token, if this is a continuation call.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListTriggers<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_triggers_input::Builder,
    }
    impl<C> ListTriggers<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListTriggersOutput,
            smithy_http::result::SdkError<crate::error::ListTriggersError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A continuation token, if this is a continuation request.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p> The name of the job for which to retrieve triggers. The trigger that can start this job
        /// is returned. If there is no such trigger, all triggers are returned.</p>
        pub fn dependent_job_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.dependent_job_name(input);
            self
        }
        pub fn set_dependent_job_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_dependent_job_name(input);
            self
        }
        /// <p>The maximum size of a list to return.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>Specifies to return only these tagged resources.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.tags(k, v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListWorkflows<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_workflows_input::Builder,
    }
    impl<C> ListWorkflows<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListWorkflowsOutput,
            smithy_http::result::SdkError<crate::error::ListWorkflowsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A continuation token, if this is a continuation request.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum size of a list to return.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutDataCatalogEncryptionSettings<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::put_data_catalog_encryption_settings_input::Builder,
    }
    impl<C> PutDataCatalogEncryptionSettings<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PutDataCatalogEncryptionSettingsOutput,
            smithy_http::result::SdkError<crate::error::PutDataCatalogEncryptionSettingsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the Data Catalog to set the security configuration for. If none is provided, the
        /// Amazon Web Services account ID is used by default.</p>
        pub fn catalog_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.catalog_id(input);
            self
        }
        pub fn set_catalog_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_catalog_id(input);
            self
        }
        /// <p>The security configuration to set.</p>
        pub fn data_catalog_encryption_settings(
            mut self,
            input: crate::model::DataCatalogEncryptionSettings,
        ) -> Self {
            self.inner = self.inner.data_catalog_encryption_settings(input);
            self
        }
        pub fn set_data_catalog_encryption_settings(
            mut self,
            input: std::option::Option<crate::model::DataCatalogEncryptionSettings>,
        ) -> Self {
            self.inner = self.inner.set_data_catalog_encryption_settings(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutResourcePolicy<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::put_resource_policy_input::Builder,
    }
    impl<C> PutResourcePolicy<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PutResourcePolicyOutput,
            smithy_http::result::SdkError<crate::error::PutResourcePolicyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Contains the policy document to set, in JSON format.</p>
        pub fn policy_in_json(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy_in_json(input);
            self
        }
        pub fn set_policy_in_json(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_policy_in_json(input);
            self
        }
        /// <p>Do not use. For internal use only.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(input);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
        /// <p>The hash value returned when the previous policy was set using
        /// <code>PutResourcePolicy</code>. Its purpose is to prevent concurrent modifications of a
        /// policy. Do not use this parameter if no previous policy has been set.</p>
        pub fn policy_hash_condition(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy_hash_condition(input);
            self
        }
        pub fn set_policy_hash_condition(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_policy_hash_condition(input);
            self
        }
        /// <p>A value of <code>MUST_EXIST</code> is used to update a policy. A value of
        /// <code>NOT_EXIST</code> is used to create a new policy. If a value of <code>NONE</code> or a
        /// null value is used, the call does not depend on the existence of a policy.</p>
        pub fn policy_exists_condition(mut self, input: crate::model::ExistCondition) -> Self {
            self.inner = self.inner.policy_exists_condition(input);
            self
        }
        pub fn set_policy_exists_condition(
            mut self,
            input: std::option::Option<crate::model::ExistCondition>,
        ) -> Self {
            self.inner = self.inner.set_policy_exists_condition(input);
            self
        }
        /// <p>If <code>'TRUE'</code>, indicates that you are using both methods to grant cross-account
        /// access to Data Catalog resources:</p>
        /// <ul>
        /// <li>
        /// <p>By directly updating the resource policy with <code>PutResourePolicy</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>By using the <b>Grant permissions</b> command on the Management Console.</p>
        /// </li>
        /// </ul>
        /// <p>Must be set to <code>'TRUE'</code> if you have already used the Management Console to
        /// grant cross-account access, otherwise the call fails. Default is 'FALSE'.</p>
        pub fn enable_hybrid(mut self, input: crate::model::EnableHybridValues) -> Self {
            self.inner = self.inner.enable_hybrid(input);
            self
        }
        pub fn set_enable_hybrid(
            mut self,
            input: std::option::Option<crate::model::EnableHybridValues>,
        ) -> Self {
            self.inner = self.inner.set_enable_hybrid(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutSchemaVersionMetadata<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::put_schema_version_metadata_input::Builder,
    }
    impl<C> PutSchemaVersionMetadata<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PutSchemaVersionMetadataOutput,
            smithy_http::result::SdkError<crate::error::PutSchemaVersionMetadataError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The unique ID for the schema.</p>
        pub fn schema_id(mut self, input: crate::model::SchemaId) -> Self {
            self.inner = self.inner.schema_id(input);
            self
        }
        pub fn set_schema_id(mut self, input: std::option::Option<crate::model::SchemaId>) -> Self {
            self.inner = self.inner.set_schema_id(input);
            self
        }
        /// <p>The version number of the schema.</p>
        pub fn schema_version_number(mut self, input: crate::model::SchemaVersionNumber) -> Self {
            self.inner = self.inner.schema_version_number(input);
            self
        }
        pub fn set_schema_version_number(
            mut self,
            input: std::option::Option<crate::model::SchemaVersionNumber>,
        ) -> Self {
            self.inner = self.inner.set_schema_version_number(input);
            self
        }
        /// <p>The unique version ID of the schema version.</p>
        pub fn schema_version_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.schema_version_id(input);
            self
        }
        pub fn set_schema_version_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_schema_version_id(input);
            self
        }
        /// <p>The metadata key's corresponding value.</p>
        pub fn metadata_key_value(mut self, input: crate::model::MetadataKeyValuePair) -> Self {
            self.inner = self.inner.metadata_key_value(input);
            self
        }
        pub fn set_metadata_key_value(
            mut self,
            input: std::option::Option<crate::model::MetadataKeyValuePair>,
        ) -> Self {
            self.inner = self.inner.set_metadata_key_value(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutWorkflowRunProperties<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::put_workflow_run_properties_input::Builder,
    }
    impl<C> PutWorkflowRunProperties<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PutWorkflowRunPropertiesOutput,
            smithy_http::result::SdkError<crate::error::PutWorkflowRunPropertiesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Name of the workflow which was run.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>The ID of the workflow run for which the run properties should be updated.</p>
        pub fn run_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.run_id(input);
            self
        }
        pub fn set_run_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_run_id(input);
            self
        }
        /// <p>The properties to put for the specified run.</p>
        pub fn run_properties(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.run_properties(k, v);
            self
        }
        pub fn set_run_properties(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_run_properties(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct QuerySchemaVersionMetadata<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::query_schema_version_metadata_input::Builder,
    }
    impl<C> QuerySchemaVersionMetadata<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::QuerySchemaVersionMetadataOutput,
            smithy_http::result::SdkError<crate::error::QuerySchemaVersionMetadataError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A wrapper structure that may contain the schema name and Amazon Resource Name (ARN).</p>
        pub fn schema_id(mut self, input: crate::model::SchemaId) -> Self {
            self.inner = self.inner.schema_id(input);
            self
        }
        pub fn set_schema_id(mut self, input: std::option::Option<crate::model::SchemaId>) -> Self {
            self.inner = self.inner.set_schema_id(input);
            self
        }
        /// <p>The version number of the schema.</p>
        pub fn schema_version_number(mut self, input: crate::model::SchemaVersionNumber) -> Self {
            self.inner = self.inner.schema_version_number(input);
            self
        }
        pub fn set_schema_version_number(
            mut self,
            input: std::option::Option<crate::model::SchemaVersionNumber>,
        ) -> Self {
            self.inner = self.inner.set_schema_version_number(input);
            self
        }
        /// <p>The unique version ID of the schema version.</p>
        pub fn schema_version_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.schema_version_id(input);
            self
        }
        pub fn set_schema_version_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_schema_version_id(input);
            self
        }
        /// <p>Search key-value pairs for metadata, if they are not provided all the metadata information will be fetched.</p>
        pub fn metadata_list(mut self, inp: impl Into<crate::model::MetadataKeyValuePair>) -> Self {
            self.inner = self.inner.metadata_list(inp);
            self
        }
        pub fn set_metadata_list(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::MetadataKeyValuePair>>,
        ) -> Self {
            self.inner = self.inner.set_metadata_list(input);
            self
        }
        /// <p>Maximum number of results required per page. If the value is not supplied, this will be defaulted to 25 per page.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>A continuation token, if this is a continuation call.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RegisterSchemaVersion<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::register_schema_version_input::Builder,
    }
    impl<C> RegisterSchemaVersion<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::RegisterSchemaVersionOutput,
            smithy_http::result::SdkError<crate::error::RegisterSchemaVersionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>This is a wrapper structure to contain schema identity fields. The structure contains:</p>
        /// <ul>
        /// <li>
        /// <p>SchemaId$SchemaArn: The Amazon Resource Name (ARN) of the schema. Either <code>SchemaArn</code> or <code>SchemaName</code> and <code>RegistryName</code> has to be provided.</p>
        /// </li>
        /// <li>
        /// <p>SchemaId$SchemaName: The name of the schema. Either <code>SchemaArn</code> or <code>SchemaName</code> and <code>RegistryName</code> has to be provided.</p>
        /// </li>
        /// </ul>
        pub fn schema_id(mut self, input: crate::model::SchemaId) -> Self {
            self.inner = self.inner.schema_id(input);
            self
        }
        pub fn set_schema_id(mut self, input: std::option::Option<crate::model::SchemaId>) -> Self {
            self.inner = self.inner.set_schema_id(input);
            self
        }
        /// <p>The schema definition using the <code>DataFormat</code> setting for the <code>SchemaName</code>.</p>
        pub fn schema_definition(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.schema_definition(input);
            self
        }
        pub fn set_schema_definition(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_schema_definition(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RemoveSchemaVersionMetadata<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::remove_schema_version_metadata_input::Builder,
    }
    impl<C> RemoveSchemaVersionMetadata<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::RemoveSchemaVersionMetadataOutput,
            smithy_http::result::SdkError<crate::error::RemoveSchemaVersionMetadataError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A wrapper structure that may contain the schema name and Amazon Resource Name (ARN).</p>
        pub fn schema_id(mut self, input: crate::model::SchemaId) -> Self {
            self.inner = self.inner.schema_id(input);
            self
        }
        pub fn set_schema_id(mut self, input: std::option::Option<crate::model::SchemaId>) -> Self {
            self.inner = self.inner.set_schema_id(input);
            self
        }
        /// <p>The version number of the schema.</p>
        pub fn schema_version_number(mut self, input: crate::model::SchemaVersionNumber) -> Self {
            self.inner = self.inner.schema_version_number(input);
            self
        }
        pub fn set_schema_version_number(
            mut self,
            input: std::option::Option<crate::model::SchemaVersionNumber>,
        ) -> Self {
            self.inner = self.inner.set_schema_version_number(input);
            self
        }
        /// <p>The unique version ID of the schema version.</p>
        pub fn schema_version_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.schema_version_id(input);
            self
        }
        pub fn set_schema_version_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_schema_version_id(input);
            self
        }
        /// <p>The value of the metadata key.</p>
        pub fn metadata_key_value(mut self, input: crate::model::MetadataKeyValuePair) -> Self {
            self.inner = self.inner.metadata_key_value(input);
            self
        }
        pub fn set_metadata_key_value(
            mut self,
            input: std::option::Option<crate::model::MetadataKeyValuePair>,
        ) -> Self {
            self.inner = self.inner.set_metadata_key_value(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ResetJobBookmark<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::reset_job_bookmark_input::Builder,
    }
    impl<C> ResetJobBookmark<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ResetJobBookmarkOutput,
            smithy_http::result::SdkError<crate::error::ResetJobBookmarkError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the job in question.</p>
        pub fn job_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.job_name(input);
            self
        }
        pub fn set_job_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_job_name(input);
            self
        }
        /// <p>The unique run identifier associated with this job run.</p>
        pub fn run_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.run_id(input);
            self
        }
        pub fn set_run_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_run_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ResumeWorkflowRun<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::resume_workflow_run_input::Builder,
    }
    impl<C> ResumeWorkflowRun<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ResumeWorkflowRunOutput,
            smithy_http::result::SdkError<crate::error::ResumeWorkflowRunError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the workflow to resume.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>The ID of the workflow run to resume.</p>
        pub fn run_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.run_id(input);
            self
        }
        pub fn set_run_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_run_id(input);
            self
        }
        /// <p>A list of the node IDs for the nodes you want to restart. The nodes that are to be restarted must have a run attempt in the original run.</p>
        pub fn node_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.node_ids(inp);
            self
        }
        pub fn set_node_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_node_ids(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct SearchTables<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::search_tables_input::Builder,
    }
    impl<C> SearchTables<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::SearchTablesOutput,
            smithy_http::result::SdkError<crate::error::SearchTablesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A unique identifier, consisting of <code>
        /// <i>account_id</i>
        /// </code>.</p>
        pub fn catalog_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.catalog_id(input);
            self
        }
        pub fn set_catalog_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_catalog_id(input);
            self
        }
        /// <p>A continuation token, included if this is a continuation call.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>A list of key-value pairs, and a comparator used to filter the search results. Returns all entities matching the predicate.</p>
        /// <p>The <code>Comparator</code> member of the <code>PropertyPredicate</code> struct is used only for time fields, and can be omitted for other field types. Also, when comparing string values, such as when <code>Key=Name</code>, a fuzzy match algorithm is used. The <code>Key</code> field (for example, the value of the <code>Name</code> field) is split on certain punctuation characters, for example, -, :, #, etc. into tokens. Then each token is exact-match compared with the <code>Value</code> member of <code>PropertyPredicate</code>. For example, if <code>Key=Name</code> and <code>Value=link</code>, tables named <code>customer-link</code> and <code>xx-link-yy</code> are returned, but <code>xxlinkyy</code> is not returned.</p>
        pub fn filters(mut self, inp: impl Into<crate::model::PropertyPredicate>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::PropertyPredicate>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p>A string used for a text search.</p>
        /// <p>Specifying a value in quotes filters based on an exact match to the value.</p>
        pub fn search_text(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.search_text(input);
            self
        }
        pub fn set_search_text(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_search_text(input);
            self
        }
        /// <p>A list of criteria for sorting the results by a field name, in an ascending or descending order.</p>
        pub fn sort_criteria(mut self, inp: impl Into<crate::model::SortCriterion>) -> Self {
            self.inner = self.inner.sort_criteria(inp);
            self
        }
        pub fn set_sort_criteria(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::SortCriterion>>,
        ) -> Self {
            self.inner = self.inner.set_sort_criteria(input);
            self
        }
        /// <p>The maximum number of tables to return in a single response.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>Allows you to specify that you want to search the tables shared with your account. The allowable values are <code>FOREIGN</code> or <code>ALL</code>. </p>
        /// <ul>
        /// <li>
        /// <p>If set to <code>FOREIGN</code>, will search the tables shared with your account. </p>
        /// </li>
        /// <li>
        /// <p>If set to <code>ALL</code>, will search the tables shared with your account, as well as the tables in yor local account. </p>
        /// </li>
        /// </ul>
        pub fn resource_share_type(mut self, input: crate::model::ResourceShareType) -> Self {
            self.inner = self.inner.resource_share_type(input);
            self
        }
        pub fn set_resource_share_type(
            mut self,
            input: std::option::Option<crate::model::ResourceShareType>,
        ) -> Self {
            self.inner = self.inner.set_resource_share_type(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct StartCrawler<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::start_crawler_input::Builder,
    }
    impl<C> StartCrawler<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::StartCrawlerOutput,
            smithy_http::result::SdkError<crate::error::StartCrawlerError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Name of the crawler to start.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct StartCrawlerSchedule<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::start_crawler_schedule_input::Builder,
    }
    impl<C> StartCrawlerSchedule<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::StartCrawlerScheduleOutput,
            smithy_http::result::SdkError<crate::error::StartCrawlerScheduleError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Name of the crawler to schedule.</p>
        pub fn crawler_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.crawler_name(input);
            self
        }
        pub fn set_crawler_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_crawler_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct StartExportLabelsTaskRun<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::start_export_labels_task_run_input::Builder,
    }
    impl<C> StartExportLabelsTaskRun<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::StartExportLabelsTaskRunOutput,
            smithy_http::result::SdkError<crate::error::StartExportLabelsTaskRunError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The unique identifier of the machine learning transform.</p>
        pub fn transform_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.transform_id(input);
            self
        }
        pub fn set_transform_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_transform_id(input);
            self
        }
        /// <p>The Amazon S3 path where you export the labels.</p>
        pub fn output_s3_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.output_s3_path(input);
            self
        }
        pub fn set_output_s3_path(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_output_s3_path(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct StartImportLabelsTaskRun<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::start_import_labels_task_run_input::Builder,
    }
    impl<C> StartImportLabelsTaskRun<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::StartImportLabelsTaskRunOutput,
            smithy_http::result::SdkError<crate::error::StartImportLabelsTaskRunError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The unique identifier of the machine learning transform.</p>
        pub fn transform_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.transform_id(input);
            self
        }
        pub fn set_transform_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_transform_id(input);
            self
        }
        /// <p>The Amazon Simple Storage Service (Amazon S3) path from where you import the
        /// labels.</p>
        pub fn input_s3_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.input_s3_path(input);
            self
        }
        pub fn set_input_s3_path(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_input_s3_path(input);
            self
        }
        /// <p>Indicates whether to overwrite your existing labels.</p>
        pub fn replace_all_labels(mut self, input: bool) -> Self {
            self.inner = self.inner.replace_all_labels(input);
            self
        }
        pub fn set_replace_all_labels(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_replace_all_labels(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct StartJobRun<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::start_job_run_input::Builder,
    }
    impl<C> StartJobRun<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::StartJobRunOutput,
            smithy_http::result::SdkError<crate::error::StartJobRunError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the job definition to use.</p>
        pub fn job_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.job_name(input);
            self
        }
        pub fn set_job_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_job_name(input);
            self
        }
        /// <p>The ID of a previous <code>JobRun</code> to retry.</p>
        pub fn job_run_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.job_run_id(input);
            self
        }
        pub fn set_job_run_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_job_run_id(input);
            self
        }
        /// <p>The job arguments specifically for this run. For this job run, they replace the default arguments set in the job definition itself.</p>
        /// <p>You can specify arguments here that your own job-execution script
        /// consumes, as well as arguments that Glue itself consumes.</p>
        /// <p>For information about how to specify and consume your own Job arguments, see the <a href="https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-python-calling.html">Calling Glue APIs in Python</a> topic in the developer guide.</p>
        /// <p>For information about the key-value pairs that Glue consumes to set up your job, see the <a href="https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-etl-glue-arguments.html">Special Parameters Used by Glue</a> topic in the developer guide.</p>
        pub fn arguments(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.arguments(k, v);
            self
        }
        pub fn set_arguments(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_arguments(input);
            self
        }
        /// <p>This field is deprecated. Use <code>MaxCapacity</code> instead.</p>
        /// <p>The number of Glue data processing units (DPUs) to allocate to this JobRun.
        /// From 2 to 100 DPUs can be allocated; the default is 10. A DPU is a relative measure
        /// of processing power that consists of 4 vCPUs of compute capacity and 16 GB of memory.
        /// For more information, see the <a href="https://aws.amazon.com/glue/pricing/">Glue
        /// pricing page</a>.</p>
        pub fn allocated_capacity(mut self, input: i32) -> Self {
            self.inner = self.inner.allocated_capacity(input);
            self
        }
        pub fn set_allocated_capacity(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_allocated_capacity(input);
            self
        }
        /// <p>The <code>JobRun</code> timeout in minutes. This is the maximum time that a job run can
        /// consume resources before it is terminated and enters <code>TIMEOUT</code> status. The default
        /// is 2,880 minutes (48 hours). This overrides the timeout value set in the parent job.</p>
        pub fn timeout(mut self, input: i32) -> Self {
            self.inner = self.inner.timeout(input);
            self
        }
        pub fn set_timeout(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_timeout(input);
            self
        }
        /// <p>The number of Glue data processing units (DPUs) that can be allocated when this job runs. A DPU is a relative measure
        /// of processing power that consists of 4 vCPUs of compute capacity and 16 GB of memory.
        /// For more information, see the <a href="https://aws.amazon.com/glue/pricing/">Glue
        /// pricing page</a>.</p>
        /// <p>Do not set <code>Max Capacity</code> if using <code>WorkerType</code> and <code>NumberOfWorkers</code>.</p>
        /// <p>The value that can be allocated for <code>MaxCapacity</code> depends on whether you are
        /// running a Python shell job, or an Apache Spark ETL job:</p>
        /// <ul>
        /// <li>
        /// <p>When you specify a Python shell job (<code>JobCommand.Name</code>="pythonshell"), you can
        /// allocate either 0.0625 or 1 DPU. The default is 0.0625 DPU.</p>
        /// </li>
        /// <li>
        /// <p>When you specify an Apache Spark ETL job (<code>JobCommand.Name</code>="glueetl"), you can allocate from 2 to 100 DPUs. The default is 10 DPUs. This job type cannot have a fractional DPU allocation.</p>
        /// </li>
        /// </ul>
        pub fn max_capacity(mut self, input: f64) -> Self {
            self.inner = self.inner.max_capacity(input);
            self
        }
        pub fn set_max_capacity(mut self, input: std::option::Option<f64>) -> Self {
            self.inner = self.inner.set_max_capacity(input);
            self
        }
        /// <p>The name of the <code>SecurityConfiguration</code> structure to be used with this job
        /// run.</p>
        pub fn security_configuration(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.security_configuration(input);
            self
        }
        pub fn set_security_configuration(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_security_configuration(input);
            self
        }
        /// <p>Specifies configuration properties of a job run notification.</p>
        pub fn notification_property(mut self, input: crate::model::NotificationProperty) -> Self {
            self.inner = self.inner.notification_property(input);
            self
        }
        pub fn set_notification_property(
            mut self,
            input: std::option::Option<crate::model::NotificationProperty>,
        ) -> Self {
            self.inner = self.inner.set_notification_property(input);
            self
        }
        /// <p>The type of predefined worker that is allocated when a job runs. Accepts a value of Standard, G.1X, or G.2X.</p>
        /// <ul>
        /// <li>
        /// <p>For the <code>Standard</code> worker type, each worker provides 4 vCPU, 16 GB of memory and a 50GB disk, and 2 executors per worker.</p>
        /// </li>
        /// <li>
        /// <p>For the <code>G.1X</code> worker type, each worker provides 4 vCPU, 16 GB of memory and a 64GB disk, and 1 executor per worker.</p>
        /// </li>
        /// <li>
        /// <p>For the <code>G.2X</code> worker type, each worker provides 8 vCPU, 32 GB of memory and a 128GB disk, and 1 executor per worker.</p>
        /// </li>
        /// </ul>
        pub fn worker_type(mut self, input: crate::model::WorkerType) -> Self {
            self.inner = self.inner.worker_type(input);
            self
        }
        pub fn set_worker_type(
            mut self,
            input: std::option::Option<crate::model::WorkerType>,
        ) -> Self {
            self.inner = self.inner.set_worker_type(input);
            self
        }
        /// <p>The number of workers of a defined <code>workerType</code> that are allocated when a job runs.</p>
        /// <p>The maximum number of workers you can define are 299 for <code>G.1X</code>, and 149 for <code>G.2X</code>. </p>
        pub fn number_of_workers(mut self, input: i32) -> Self {
            self.inner = self.inner.number_of_workers(input);
            self
        }
        pub fn set_number_of_workers(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_number_of_workers(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct StartMLEvaluationTaskRun<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::start_ml_evaluation_task_run_input::Builder,
    }
    impl<C> StartMLEvaluationTaskRun<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::StartMlEvaluationTaskRunOutput,
            smithy_http::result::SdkError<crate::error::StartMLEvaluationTaskRunError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The unique identifier of the machine learning transform.</p>
        pub fn transform_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.transform_id(input);
            self
        }
        pub fn set_transform_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_transform_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct StartMLLabelingSetGenerationTaskRun<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::start_ml_labeling_set_generation_task_run_input::Builder,
    }
    impl<C> StartMLLabelingSetGenerationTaskRun<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::StartMlLabelingSetGenerationTaskRunOutput,
            smithy_http::result::SdkError<crate::error::StartMLLabelingSetGenerationTaskRunError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The unique identifier of the machine learning transform.</p>
        pub fn transform_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.transform_id(input);
            self
        }
        pub fn set_transform_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_transform_id(input);
            self
        }
        /// <p>The Amazon Simple Storage Service (Amazon S3) path where you generate the labeling
        /// set.</p>
        pub fn output_s3_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.output_s3_path(input);
            self
        }
        pub fn set_output_s3_path(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_output_s3_path(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct StartTrigger<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::start_trigger_input::Builder,
    }
    impl<C> StartTrigger<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::StartTriggerOutput,
            smithy_http::result::SdkError<crate::error::StartTriggerError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the trigger to start.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct StartWorkflowRun<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::start_workflow_run_input::Builder,
    }
    impl<C> StartWorkflowRun<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::StartWorkflowRunOutput,
            smithy_http::result::SdkError<crate::error::StartWorkflowRunError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the workflow to start.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct StopCrawler<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::stop_crawler_input::Builder,
    }
    impl<C> StopCrawler<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::StopCrawlerOutput,
            smithy_http::result::SdkError<crate::error::StopCrawlerError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Name of the crawler to stop.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct StopCrawlerSchedule<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::stop_crawler_schedule_input::Builder,
    }
    impl<C> StopCrawlerSchedule<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::StopCrawlerScheduleOutput,
            smithy_http::result::SdkError<crate::error::StopCrawlerScheduleError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Name of the crawler whose schedule state to set.</p>
        pub fn crawler_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.crawler_name(input);
            self
        }
        pub fn set_crawler_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_crawler_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct StopTrigger<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::stop_trigger_input::Builder,
    }
    impl<C> StopTrigger<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::StopTriggerOutput,
            smithy_http::result::SdkError<crate::error::StopTriggerError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the trigger to stop.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct StopWorkflowRun<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::stop_workflow_run_input::Builder,
    }
    impl<C> StopWorkflowRun<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::StopWorkflowRunOutput,
            smithy_http::result::SdkError<crate::error::StopWorkflowRunError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the workflow to stop.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>The ID of the workflow run to stop.</p>
        pub fn run_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.run_id(input);
            self
        }
        pub fn set_run_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_run_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct TagResource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::tag_resource_input::Builder,
    }
    impl<C> TagResource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::TagResourceOutput,
            smithy_http::result::SdkError<crate::error::TagResourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ARN of the Glue resource to which to add the tags. For more
        /// information about Glue resource ARNs, see the <a href="https://docs.aws.amazon.com/glue/latest/dg/aws-glue-api-common.html#aws-glue-api-regex-aws-glue-arn-id">Glue ARN string pattern</a>.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(input);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
        /// <p>Tags to add to this resource.</p>
        pub fn tags_to_add(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.tags_to_add(k, v);
            self
        }
        pub fn set_tags_to_add(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_tags_to_add(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UntagResource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::untag_resource_input::Builder,
    }
    impl<C> UntagResource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UntagResourceOutput,
            smithy_http::result::SdkError<crate::error::UntagResourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the resource from which to remove the tags.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(input);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
        /// <p>Tags to remove from this resource.</p>
        pub fn tags_to_remove(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.tags_to_remove(inp);
            self
        }
        pub fn set_tags_to_remove(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_tags_to_remove(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateClassifier<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_classifier_input::Builder,
    }
    impl<C> UpdateClassifier<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateClassifierOutput,
            smithy_http::result::SdkError<crate::error::UpdateClassifierError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A <code>GrokClassifier</code> object with updated fields.</p>
        pub fn grok_classifier(mut self, input: crate::model::UpdateGrokClassifierRequest) -> Self {
            self.inner = self.inner.grok_classifier(input);
            self
        }
        pub fn set_grok_classifier(
            mut self,
            input: std::option::Option<crate::model::UpdateGrokClassifierRequest>,
        ) -> Self {
            self.inner = self.inner.set_grok_classifier(input);
            self
        }
        /// <p>An <code>XMLClassifier</code> object with updated fields.</p>
        pub fn xml_classifier(mut self, input: crate::model::UpdateXmlClassifierRequest) -> Self {
            self.inner = self.inner.xml_classifier(input);
            self
        }
        pub fn set_xml_classifier(
            mut self,
            input: std::option::Option<crate::model::UpdateXmlClassifierRequest>,
        ) -> Self {
            self.inner = self.inner.set_xml_classifier(input);
            self
        }
        /// <p>A <code>JsonClassifier</code> object with updated fields.</p>
        pub fn json_classifier(mut self, input: crate::model::UpdateJsonClassifierRequest) -> Self {
            self.inner = self.inner.json_classifier(input);
            self
        }
        pub fn set_json_classifier(
            mut self,
            input: std::option::Option<crate::model::UpdateJsonClassifierRequest>,
        ) -> Self {
            self.inner = self.inner.set_json_classifier(input);
            self
        }
        /// <p>A <code>CsvClassifier</code> object with updated fields.</p>
        pub fn csv_classifier(mut self, input: crate::model::UpdateCsvClassifierRequest) -> Self {
            self.inner = self.inner.csv_classifier(input);
            self
        }
        pub fn set_csv_classifier(
            mut self,
            input: std::option::Option<crate::model::UpdateCsvClassifierRequest>,
        ) -> Self {
            self.inner = self.inner.set_csv_classifier(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateColumnStatisticsForPartition<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_column_statistics_for_partition_input::Builder,
    }
    impl<C> UpdateColumnStatisticsForPartition<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateColumnStatisticsForPartitionOutput,
            smithy_http::result::SdkError<crate::error::UpdateColumnStatisticsForPartitionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the Data Catalog where the partitions in question reside.
        /// If none is supplied, the Amazon Web Services account ID is used by default.</p>
        pub fn catalog_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.catalog_id(input);
            self
        }
        pub fn set_catalog_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_catalog_id(input);
            self
        }
        /// <p>The name of the catalog database where the partitions reside.</p>
        pub fn database_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.database_name(input);
            self
        }
        pub fn set_database_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_database_name(input);
            self
        }
        /// <p>The name of the partitions' table.</p>
        pub fn table_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.table_name(input);
            self
        }
        pub fn set_table_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_table_name(input);
            self
        }
        /// <p>A list of partition values identifying the partition.</p>
        pub fn partition_values(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.partition_values(inp);
            self
        }
        pub fn set_partition_values(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_partition_values(input);
            self
        }
        /// <p>A list of the column statistics.</p>
        pub fn column_statistics_list(
            mut self,
            inp: impl Into<crate::model::ColumnStatistics>,
        ) -> Self {
            self.inner = self.inner.column_statistics_list(inp);
            self
        }
        pub fn set_column_statistics_list(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ColumnStatistics>>,
        ) -> Self {
            self.inner = self.inner.set_column_statistics_list(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateColumnStatisticsForTable<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_column_statistics_for_table_input::Builder,
    }
    impl<C> UpdateColumnStatisticsForTable<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateColumnStatisticsForTableOutput,
            smithy_http::result::SdkError<crate::error::UpdateColumnStatisticsForTableError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the Data Catalog where the partitions in question reside.
        /// If none is supplied, the Amazon Web Services account ID is used by default.</p>
        pub fn catalog_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.catalog_id(input);
            self
        }
        pub fn set_catalog_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_catalog_id(input);
            self
        }
        /// <p>The name of the catalog database where the partitions reside.</p>
        pub fn database_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.database_name(input);
            self
        }
        pub fn set_database_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_database_name(input);
            self
        }
        /// <p>The name of the partitions' table.</p>
        pub fn table_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.table_name(input);
            self
        }
        pub fn set_table_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_table_name(input);
            self
        }
        /// <p>A list of the column statistics.</p>
        pub fn column_statistics_list(
            mut self,
            inp: impl Into<crate::model::ColumnStatistics>,
        ) -> Self {
            self.inner = self.inner.column_statistics_list(inp);
            self
        }
        pub fn set_column_statistics_list(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ColumnStatistics>>,
        ) -> Self {
            self.inner = self.inner.set_column_statistics_list(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateConnection<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_connection_input::Builder,
    }
    impl<C> UpdateConnection<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateConnectionOutput,
            smithy_http::result::SdkError<crate::error::UpdateConnectionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the Data Catalog in which the connection resides. If none is provided, the Amazon Web Services
        /// account ID is used by default.</p>
        pub fn catalog_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.catalog_id(input);
            self
        }
        pub fn set_catalog_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_catalog_id(input);
            self
        }
        /// <p>The name of the connection definition to update.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>A <code>ConnectionInput</code> object that redefines the connection
        /// in question.</p>
        pub fn connection_input(mut self, input: crate::model::ConnectionInput) -> Self {
            self.inner = self.inner.connection_input(input);
            self
        }
        pub fn set_connection_input(
            mut self,
            input: std::option::Option<crate::model::ConnectionInput>,
        ) -> Self {
            self.inner = self.inner.set_connection_input(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateCrawler<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_crawler_input::Builder,
    }
    impl<C> UpdateCrawler<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateCrawlerOutput,
            smithy_http::result::SdkError<crate::error::UpdateCrawlerError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Name of the new crawler.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>The IAM role or Amazon Resource Name (ARN) of an IAM role that is used by the new crawler
        /// to access customer resources.</p>
        pub fn role(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.role(input);
            self
        }
        pub fn set_role(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_role(input);
            self
        }
        /// <p>The Glue database where results are stored, such as:
        /// <code>arn:aws:daylight:us-east-1::database/sometable/*</code>.</p>
        pub fn database_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.database_name(input);
            self
        }
        pub fn set_database_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_database_name(input);
            self
        }
        /// <p>A description of the new crawler.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>A list of targets to crawl.</p>
        pub fn targets(mut self, input: crate::model::CrawlerTargets) -> Self {
            self.inner = self.inner.targets(input);
            self
        }
        pub fn set_targets(
            mut self,
            input: std::option::Option<crate::model::CrawlerTargets>,
        ) -> Self {
            self.inner = self.inner.set_targets(input);
            self
        }
        /// <p>A <code>cron</code> expression used to specify the schedule (see <a href="https://docs.aws.amazon.com/glue/latest/dg/monitor-data-warehouse-schedule.html">Time-Based Schedules for Jobs and Crawlers</a>. For example, to run
        /// something every day at 12:15 UTC, you would specify:
        /// <code>cron(15 12 * * ? *)</code>.</p>
        pub fn schedule(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.schedule(input);
            self
        }
        pub fn set_schedule(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_schedule(input);
            self
        }
        /// <p>A list of custom classifiers that the user
        /// has registered. By default, all built-in classifiers are included in a crawl,
        /// but these custom classifiers always override the default classifiers
        /// for a given classification.</p>
        pub fn classifiers(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.classifiers(inp);
            self
        }
        pub fn set_classifiers(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_classifiers(input);
            self
        }
        /// <p>The table prefix used for catalog tables that are created.</p>
        pub fn table_prefix(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.table_prefix(input);
            self
        }
        pub fn set_table_prefix(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_table_prefix(input);
            self
        }
        /// <p>The policy for the crawler's update and deletion behavior.</p>
        pub fn schema_change_policy(mut self, input: crate::model::SchemaChangePolicy) -> Self {
            self.inner = self.inner.schema_change_policy(input);
            self
        }
        pub fn set_schema_change_policy(
            mut self,
            input: std::option::Option<crate::model::SchemaChangePolicy>,
        ) -> Self {
            self.inner = self.inner.set_schema_change_policy(input);
            self
        }
        /// <p>A policy that specifies whether to crawl the entire dataset again, or to crawl only folders that were added since the last crawler run.</p>
        pub fn recrawl_policy(mut self, input: crate::model::RecrawlPolicy) -> Self {
            self.inner = self.inner.recrawl_policy(input);
            self
        }
        pub fn set_recrawl_policy(
            mut self,
            input: std::option::Option<crate::model::RecrawlPolicy>,
        ) -> Self {
            self.inner = self.inner.set_recrawl_policy(input);
            self
        }
        /// <p>Specifies data lineage configuration settings for the crawler.</p>
        pub fn lineage_configuration(mut self, input: crate::model::LineageConfiguration) -> Self {
            self.inner = self.inner.lineage_configuration(input);
            self
        }
        pub fn set_lineage_configuration(
            mut self,
            input: std::option::Option<crate::model::LineageConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_lineage_configuration(input);
            self
        }
        /// <p>Crawler configuration information. This versioned JSON string allows users
        /// to specify aspects of a crawler's behavior.
        /// For more information, see <a href="https://docs.aws.amazon.com/glue/latest/dg/crawler-configuration.html">Configuring a Crawler</a>.</p>
        pub fn configuration(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.configuration(input);
            self
        }
        pub fn set_configuration(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_configuration(input);
            self
        }
        /// <p>The name of the <code>SecurityConfiguration</code> structure to be used by this
        /// crawler.</p>
        pub fn crawler_security_configuration(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.crawler_security_configuration(input);
            self
        }
        pub fn set_crawler_security_configuration(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_crawler_security_configuration(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateCrawlerSchedule<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_crawler_schedule_input::Builder,
    }
    impl<C> UpdateCrawlerSchedule<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateCrawlerScheduleOutput,
            smithy_http::result::SdkError<crate::error::UpdateCrawlerScheduleError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the crawler whose schedule to update.</p>
        pub fn crawler_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.crawler_name(input);
            self
        }
        pub fn set_crawler_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_crawler_name(input);
            self
        }
        /// <p>The updated <code>cron</code> expression used to specify the schedule (see <a href="https://docs.aws.amazon.com/glue/latest/dg/monitor-data-warehouse-schedule.html">Time-Based Schedules for Jobs and Crawlers</a>. For example, to run
        /// something every day at 12:15 UTC, you would specify:
        /// <code>cron(15 12 * * ? *)</code>.</p>
        pub fn schedule(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.schedule(input);
            self
        }
        pub fn set_schedule(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_schedule(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateDatabase<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_database_input::Builder,
    }
    impl<C> UpdateDatabase<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateDatabaseOutput,
            smithy_http::result::SdkError<crate::error::UpdateDatabaseError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the Data Catalog in which the metadata database resides. If none is provided,
        /// the Amazon Web Services account ID is used by default.</p>
        pub fn catalog_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.catalog_id(input);
            self
        }
        pub fn set_catalog_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_catalog_id(input);
            self
        }
        /// <p>The name of the database to update in the catalog. For Hive
        /// compatibility, this is folded to lowercase.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>A <code>DatabaseInput</code> object specifying the new definition
        /// of the metadata database in the catalog.</p>
        pub fn database_input(mut self, input: crate::model::DatabaseInput) -> Self {
            self.inner = self.inner.database_input(input);
            self
        }
        pub fn set_database_input(
            mut self,
            input: std::option::Option<crate::model::DatabaseInput>,
        ) -> Self {
            self.inner = self.inner.set_database_input(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateDevEndpoint<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_dev_endpoint_input::Builder,
    }
    impl<C> UpdateDevEndpoint<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateDevEndpointOutput,
            smithy_http::result::SdkError<crate::error::UpdateDevEndpointError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the <code>DevEndpoint</code> to be updated.</p>
        pub fn endpoint_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.endpoint_name(input);
            self
        }
        pub fn set_endpoint_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_endpoint_name(input);
            self
        }
        /// <p>The public key for the <code>DevEndpoint</code> to use.</p>
        pub fn public_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.public_key(input);
            self
        }
        pub fn set_public_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_public_key(input);
            self
        }
        /// <p>The list of public keys for the <code>DevEndpoint</code> to use.</p>
        pub fn add_public_keys(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.add_public_keys(inp);
            self
        }
        pub fn set_add_public_keys(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_add_public_keys(input);
            self
        }
        /// <p>The list of public keys to be deleted from the <code>DevEndpoint</code>.</p>
        pub fn delete_public_keys(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.delete_public_keys(inp);
            self
        }
        pub fn set_delete_public_keys(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_delete_public_keys(input);
            self
        }
        /// <p>Custom Python or Java libraries to be loaded in the <code>DevEndpoint</code>.</p>
        pub fn custom_libraries(mut self, input: crate::model::DevEndpointCustomLibraries) -> Self {
            self.inner = self.inner.custom_libraries(input);
            self
        }
        pub fn set_custom_libraries(
            mut self,
            input: std::option::Option<crate::model::DevEndpointCustomLibraries>,
        ) -> Self {
            self.inner = self.inner.set_custom_libraries(input);
            self
        }
        /// <p>
        /// <code>True</code> if the list of custom libraries to be loaded in the development endpoint
        /// needs to be updated, or <code>False</code> if otherwise.</p>
        pub fn update_etl_libraries(mut self, input: bool) -> Self {
            self.inner = self.inner.update_etl_libraries(input);
            self
        }
        pub fn set_update_etl_libraries(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_update_etl_libraries(input);
            self
        }
        /// <p>The list of argument keys to be deleted from the map of arguments used to configure the
        /// <code>DevEndpoint</code>.</p>
        pub fn delete_arguments(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.delete_arguments(inp);
            self
        }
        pub fn set_delete_arguments(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_delete_arguments(input);
            self
        }
        /// <p>The map of arguments to add the map of arguments used to configure the
        /// <code>DevEndpoint</code>.</p>
        /// <p>Valid arguments are:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>"--enable-glue-datacatalog": ""</code>
        /// </p>
        /// </li>
        /// </ul>
        /// <p>You can specify a version of Python support for development endpoints by using the <code>Arguments</code> parameter in the <code>CreateDevEndpoint</code> or <code>UpdateDevEndpoint</code> APIs. If no arguments are provided, the version defaults to Python 2.</p>
        pub fn add_arguments(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.add_arguments(k, v);
            self
        }
        pub fn set_add_arguments(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_add_arguments(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateJob<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_job_input::Builder,
    }
    impl<C> UpdateJob<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateJobOutput,
            smithy_http::result::SdkError<crate::error::UpdateJobError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the job definition to update.</p>
        pub fn job_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.job_name(input);
            self
        }
        pub fn set_job_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_job_name(input);
            self
        }
        /// <p>Specifies the values with which to update the job definition.</p>
        pub fn job_update(mut self, input: crate::model::JobUpdate) -> Self {
            self.inner = self.inner.job_update(input);
            self
        }
        pub fn set_job_update(
            mut self,
            input: std::option::Option<crate::model::JobUpdate>,
        ) -> Self {
            self.inner = self.inner.set_job_update(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateMLTransform<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_ml_transform_input::Builder,
    }
    impl<C> UpdateMLTransform<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateMlTransformOutput,
            smithy_http::result::SdkError<crate::error::UpdateMLTransformError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A unique identifier that was generated when the transform was created.</p>
        pub fn transform_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.transform_id(input);
            self
        }
        pub fn set_transform_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_transform_id(input);
            self
        }
        /// <p>The unique name that you gave the transform when you created it.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>A description of the transform. The default is an empty string.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>The configuration parameters that are specific to the transform type (algorithm) used.
        /// Conditionally dependent on the transform type.</p>
        pub fn parameters(mut self, input: crate::model::TransformParameters) -> Self {
            self.inner = self.inner.parameters(input);
            self
        }
        pub fn set_parameters(
            mut self,
            input: std::option::Option<crate::model::TransformParameters>,
        ) -> Self {
            self.inner = self.inner.set_parameters(input);
            self
        }
        /// <p>The name or Amazon Resource Name (ARN) of the IAM role with the required
        /// permissions.</p>
        pub fn role(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.role(input);
            self
        }
        pub fn set_role(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_role(input);
            self
        }
        /// <p>This value determines which version of Glue this machine learning transform is compatible with. Glue 1.0 is recommended for most customers. If the value is not set, the Glue compatibility defaults to Glue 0.9.  For more information, see <a href="https://docs.aws.amazon.com/glue/latest/dg/release-notes.html#release-notes-versions">Glue Versions</a> in the developer guide.</p>
        pub fn glue_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.glue_version(input);
            self
        }
        pub fn set_glue_version(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_glue_version(input);
            self
        }
        /// <p>The number of Glue data processing units (DPUs) that are allocated to task runs for this transform. You can allocate from 2 to 100 DPUs; the default is 10. A DPU is a relative measure of
        /// processing power that consists of 4 vCPUs of compute capacity and 16 GB of memory. For more
        /// information, see the <a href="https://aws.amazon.com/glue/pricing/">Glue pricing
        /// page</a>. </p>
        /// <p>When the <code>WorkerType</code> field is set to a value other than <code>Standard</code>, the <code>MaxCapacity</code> field is set automatically and becomes read-only.</p>
        pub fn max_capacity(mut self, input: f64) -> Self {
            self.inner = self.inner.max_capacity(input);
            self
        }
        pub fn set_max_capacity(mut self, input: std::option::Option<f64>) -> Self {
            self.inner = self.inner.set_max_capacity(input);
            self
        }
        /// <p>The type of predefined worker that is allocated when this task runs. Accepts a value of Standard, G.1X, or G.2X.</p>
        /// <ul>
        /// <li>
        /// <p>For the <code>Standard</code> worker type, each worker provides 4 vCPU, 16 GB of memory and a 50GB disk, and 2 executors per worker.</p>
        /// </li>
        /// <li>
        /// <p>For the <code>G.1X</code> worker type, each worker provides 4 vCPU, 16 GB of memory and a 64GB disk, and 1 executor per worker.</p>
        /// </li>
        /// <li>
        /// <p>For the <code>G.2X</code> worker type, each worker provides 8 vCPU, 32 GB of memory and a 128GB disk, and 1 executor per worker.</p>
        /// </li>
        /// </ul>
        pub fn worker_type(mut self, input: crate::model::WorkerType) -> Self {
            self.inner = self.inner.worker_type(input);
            self
        }
        pub fn set_worker_type(
            mut self,
            input: std::option::Option<crate::model::WorkerType>,
        ) -> Self {
            self.inner = self.inner.set_worker_type(input);
            self
        }
        /// <p>The number of workers of a defined <code>workerType</code> that are allocated when this task runs.</p>
        pub fn number_of_workers(mut self, input: i32) -> Self {
            self.inner = self.inner.number_of_workers(input);
            self
        }
        pub fn set_number_of_workers(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_number_of_workers(input);
            self
        }
        /// <p>The timeout for a task run for this transform in minutes. This is the maximum time that a task run for this transform can consume resources before it is terminated and enters <code>TIMEOUT</code> status. The default is 2,880 minutes (48 hours).</p>
        pub fn timeout(mut self, input: i32) -> Self {
            self.inner = self.inner.timeout(input);
            self
        }
        pub fn set_timeout(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_timeout(input);
            self
        }
        /// <p>The maximum number of times to retry a task for this transform after a task run fails.</p>
        pub fn max_retries(mut self, input: i32) -> Self {
            self.inner = self.inner.max_retries(input);
            self
        }
        pub fn set_max_retries(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_retries(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdatePartition<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_partition_input::Builder,
    }
    impl<C> UpdatePartition<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdatePartitionOutput,
            smithy_http::result::SdkError<crate::error::UpdatePartitionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the Data Catalog where the partition to be updated resides. If none is provided,
        /// the Amazon Web Services account ID is used by default.</p>
        pub fn catalog_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.catalog_id(input);
            self
        }
        pub fn set_catalog_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_catalog_id(input);
            self
        }
        /// <p>The name of the catalog database in which the table in question
        /// resides.</p>
        pub fn database_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.database_name(input);
            self
        }
        pub fn set_database_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_database_name(input);
            self
        }
        /// <p>The name of the table in which the partition to be updated is located.</p>
        pub fn table_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.table_name(input);
            self
        }
        pub fn set_table_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_table_name(input);
            self
        }
        /// <p>List of partition key values that define the partition to update.</p>
        pub fn partition_value_list(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.partition_value_list(inp);
            self
        }
        pub fn set_partition_value_list(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_partition_value_list(input);
            self
        }
        /// <p>The new partition object to update the partition to.</p>
        /// <p>The <code>Values</code> property can't be changed. If you want to change the partition key values for a partition, delete and recreate the partition.</p>
        pub fn partition_input(mut self, input: crate::model::PartitionInput) -> Self {
            self.inner = self.inner.partition_input(input);
            self
        }
        pub fn set_partition_input(
            mut self,
            input: std::option::Option<crate::model::PartitionInput>,
        ) -> Self {
            self.inner = self.inner.set_partition_input(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateRegistry<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_registry_input::Builder,
    }
    impl<C> UpdateRegistry<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateRegistryOutput,
            smithy_http::result::SdkError<crate::error::UpdateRegistryError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>This is a wrapper structure that may contain the registry name and Amazon Resource Name (ARN).</p>
        pub fn registry_id(mut self, input: crate::model::RegistryId) -> Self {
            self.inner = self.inner.registry_id(input);
            self
        }
        pub fn set_registry_id(
            mut self,
            input: std::option::Option<crate::model::RegistryId>,
        ) -> Self {
            self.inner = self.inner.set_registry_id(input);
            self
        }
        /// <p>A description of the registry. If description is not provided, this field will not be updated.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateSchema<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_schema_input::Builder,
    }
    impl<C> UpdateSchema<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateSchemaOutput,
            smithy_http::result::SdkError<crate::error::UpdateSchemaError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>This is a wrapper structure to contain schema identity fields. The structure contains:</p>
        /// <ul>
        /// <li>
        /// <p>SchemaId$SchemaArn: The Amazon Resource Name (ARN) of the schema. One of <code>SchemaArn</code> or <code>SchemaName</code> has to be provided.</p>
        /// </li>
        /// <li>
        /// <p>SchemaId$SchemaName: The name of the schema. One of <code>SchemaArn</code> or <code>SchemaName</code> has to be provided.</p>
        /// </li>
        /// </ul>
        pub fn schema_id(mut self, input: crate::model::SchemaId) -> Self {
            self.inner = self.inner.schema_id(input);
            self
        }
        pub fn set_schema_id(mut self, input: std::option::Option<crate::model::SchemaId>) -> Self {
            self.inner = self.inner.set_schema_id(input);
            self
        }
        /// <p>Version number required for check pointing. One of <code>VersionNumber</code> or <code>Compatibility</code> has to be provided.</p>
        pub fn schema_version_number(mut self, input: crate::model::SchemaVersionNumber) -> Self {
            self.inner = self.inner.schema_version_number(input);
            self
        }
        pub fn set_schema_version_number(
            mut self,
            input: std::option::Option<crate::model::SchemaVersionNumber>,
        ) -> Self {
            self.inner = self.inner.set_schema_version_number(input);
            self
        }
        /// <p>The new compatibility setting for the schema.</p>
        pub fn compatibility(mut self, input: crate::model::Compatibility) -> Self {
            self.inner = self.inner.compatibility(input);
            self
        }
        pub fn set_compatibility(
            mut self,
            input: std::option::Option<crate::model::Compatibility>,
        ) -> Self {
            self.inner = self.inner.set_compatibility(input);
            self
        }
        /// <p>The new description for the schema.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateTable<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_table_input::Builder,
    }
    impl<C> UpdateTable<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateTableOutput,
            smithy_http::result::SdkError<crate::error::UpdateTableError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the Data Catalog where the table resides. If none is provided, the Amazon Web Services account
        /// ID is used by default.</p>
        pub fn catalog_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.catalog_id(input);
            self
        }
        pub fn set_catalog_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_catalog_id(input);
            self
        }
        /// <p>The name of the catalog database in which the table resides. For Hive
        /// compatibility, this name is entirely lowercase.</p>
        pub fn database_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.database_name(input);
            self
        }
        pub fn set_database_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_database_name(input);
            self
        }
        /// <p>An updated <code>TableInput</code> object to define the metadata table
        /// in the catalog.</p>
        pub fn table_input(mut self, input: crate::model::TableInput) -> Self {
            self.inner = self.inner.table_input(input);
            self
        }
        pub fn set_table_input(
            mut self,
            input: std::option::Option<crate::model::TableInput>,
        ) -> Self {
            self.inner = self.inner.set_table_input(input);
            self
        }
        /// <p>By default, <code>UpdateTable</code> always creates an archived version of the table
        /// before updating it. However, if <code>skipArchive</code> is set to true,
        /// <code>UpdateTable</code> does not create the archived version.</p>
        pub fn skip_archive(mut self, input: bool) -> Self {
            self.inner = self.inner.skip_archive(input);
            self
        }
        pub fn set_skip_archive(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_skip_archive(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateTrigger<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_trigger_input::Builder,
    }
    impl<C> UpdateTrigger<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateTriggerOutput,
            smithy_http::result::SdkError<crate::error::UpdateTriggerError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the trigger to update.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>The new values with which to update the trigger.</p>
        pub fn trigger_update(mut self, input: crate::model::TriggerUpdate) -> Self {
            self.inner = self.inner.trigger_update(input);
            self
        }
        pub fn set_trigger_update(
            mut self,
            input: std::option::Option<crate::model::TriggerUpdate>,
        ) -> Self {
            self.inner = self.inner.set_trigger_update(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateUserDefinedFunction<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_user_defined_function_input::Builder,
    }
    impl<C> UpdateUserDefinedFunction<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateUserDefinedFunctionOutput,
            smithy_http::result::SdkError<crate::error::UpdateUserDefinedFunctionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the Data Catalog where the function to be updated is located. If none is
        /// provided, the Amazon Web Services account ID is used by default.</p>
        pub fn catalog_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.catalog_id(input);
            self
        }
        pub fn set_catalog_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_catalog_id(input);
            self
        }
        /// <p>The name of the catalog database where the function to be updated is
        /// located.</p>
        pub fn database_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.database_name(input);
            self
        }
        pub fn set_database_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_database_name(input);
            self
        }
        /// <p>The name of the function.</p>
        pub fn function_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.function_name(input);
            self
        }
        pub fn set_function_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_function_name(input);
            self
        }
        /// <p>A <code>FunctionInput</code> object that redefines the function in the Data
        /// Catalog.</p>
        pub fn function_input(mut self, input: crate::model::UserDefinedFunctionInput) -> Self {
            self.inner = self.inner.function_input(input);
            self
        }
        pub fn set_function_input(
            mut self,
            input: std::option::Option<crate::model::UserDefinedFunctionInput>,
        ) -> Self {
            self.inner = self.inner.set_function_input(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateWorkflow<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_workflow_input::Builder,
    }
    impl<C> UpdateWorkflow<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateWorkflowOutput,
            smithy_http::result::SdkError<crate::error::UpdateWorkflowError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Name of the workflow to be updated.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>The description of the workflow.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>A collection of properties to be used as part of each execution of the workflow.</p>
        pub fn default_run_properties(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.default_run_properties(k, v);
            self
        }
        pub fn set_default_run_properties(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_default_run_properties(input);
            self
        }
        /// <p>You can use this parameter to prevent unwanted multiple updates to data, to control costs, or in some cases, to prevent exceeding the maximum number of concurrent runs of any of the component jobs. If you leave this parameter blank, there is no limit to the number of concurrent workflow runs.</p>
        pub fn max_concurrent_runs(mut self, input: i32) -> Self {
            self.inner = self.inner.max_concurrent_runs(input);
            self
        }
        pub fn set_max_concurrent_runs(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_concurrent_runs(input);
            self
        }
    }
}
