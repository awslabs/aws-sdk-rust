// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// <p>Creates one or more partitions in a batch operation.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct BatchCreatePartition {
    _private: (),
}
impl BatchCreatePartition {
    /// Creates a new builder-style object to manufacture [`BatchCreatePartitionInput`](crate::input::BatchCreatePartitionInput)
    pub fn builder() -> crate::input::batch_create_partition_input::Builder {
        crate::input::batch_create_partition_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for BatchCreatePartition {
    type Output = std::result::Result<
        crate::output::BatchCreatePartitionOutput,
        crate::error::BatchCreatePartitionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_batch_create_partition_error(response)
        } else {
            crate::operation_deser::parse_batch_create_partition_response(response)
        }
    }
}

/// <p>Deletes a list of connection definitions from the Data Catalog.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct BatchDeleteConnection {
    _private: (),
}
impl BatchDeleteConnection {
    /// Creates a new builder-style object to manufacture [`BatchDeleteConnectionInput`](crate::input::BatchDeleteConnectionInput)
    pub fn builder() -> crate::input::batch_delete_connection_input::Builder {
        crate::input::batch_delete_connection_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for BatchDeleteConnection {
    type Output = std::result::Result<
        crate::output::BatchDeleteConnectionOutput,
        crate::error::BatchDeleteConnectionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_batch_delete_connection_error(response)
        } else {
            crate::operation_deser::parse_batch_delete_connection_response(response)
        }
    }
}

/// <p>Deletes one or more partitions in a batch operation.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct BatchDeletePartition {
    _private: (),
}
impl BatchDeletePartition {
    /// Creates a new builder-style object to manufacture [`BatchDeletePartitionInput`](crate::input::BatchDeletePartitionInput)
    pub fn builder() -> crate::input::batch_delete_partition_input::Builder {
        crate::input::batch_delete_partition_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for BatchDeletePartition {
    type Output = std::result::Result<
        crate::output::BatchDeletePartitionOutput,
        crate::error::BatchDeletePartitionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_batch_delete_partition_error(response)
        } else {
            crate::operation_deser::parse_batch_delete_partition_response(response)
        }
    }
}

/// <p>Deletes multiple tables at once.</p>
/// <note>
/// <p>After completing this operation, you no longer have access to the table versions and
/// partitions that belong to the deleted table. Glue deletes these "orphaned" resources
/// asynchronously in a timely manner, at the discretion of the service.</p>
/// <p>To ensure the immediate deletion of all related resources, before calling
/// <code>BatchDeleteTable</code>, use <code>DeleteTableVersion</code> or
/// <code>BatchDeleteTableVersion</code>, and <code>DeletePartition</code> or
/// <code>BatchDeletePartition</code>, to delete any resources that belong to the
/// table.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct BatchDeleteTable {
    _private: (),
}
impl BatchDeleteTable {
    /// Creates a new builder-style object to manufacture [`BatchDeleteTableInput`](crate::input::BatchDeleteTableInput)
    pub fn builder() -> crate::input::batch_delete_table_input::Builder {
        crate::input::batch_delete_table_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for BatchDeleteTable {
    type Output = std::result::Result<
        crate::output::BatchDeleteTableOutput,
        crate::error::BatchDeleteTableError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_batch_delete_table_error(response)
        } else {
            crate::operation_deser::parse_batch_delete_table_response(response)
        }
    }
}

/// <p>Deletes a specified batch of versions of a table.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct BatchDeleteTableVersion {
    _private: (),
}
impl BatchDeleteTableVersion {
    /// Creates a new builder-style object to manufacture [`BatchDeleteTableVersionInput`](crate::input::BatchDeleteTableVersionInput)
    pub fn builder() -> crate::input::batch_delete_table_version_input::Builder {
        crate::input::batch_delete_table_version_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for BatchDeleteTableVersion {
    type Output = std::result::Result<
        crate::output::BatchDeleteTableVersionOutput,
        crate::error::BatchDeleteTableVersionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_batch_delete_table_version_error(response)
        } else {
            crate::operation_deser::parse_batch_delete_table_version_response(response)
        }
    }
}

/// <p>Returns a list of resource metadata for a given list of crawler names. After calling the <code>ListCrawlers</code> operation, you can call this operation to access the data to which you have been granted permissions. This operation supports all IAM permissions, including permission conditions that uses tags.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct BatchGetCrawlers {
    _private: (),
}
impl BatchGetCrawlers {
    /// Creates a new builder-style object to manufacture [`BatchGetCrawlersInput`](crate::input::BatchGetCrawlersInput)
    pub fn builder() -> crate::input::batch_get_crawlers_input::Builder {
        crate::input::batch_get_crawlers_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for BatchGetCrawlers {
    type Output = std::result::Result<
        crate::output::BatchGetCrawlersOutput,
        crate::error::BatchGetCrawlersError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_batch_get_crawlers_error(response)
        } else {
            crate::operation_deser::parse_batch_get_crawlers_response(response)
        }
    }
}

/// <p>Returns a list of resource metadata for a given list of development endpoint names. After
/// calling the <code>ListDevEndpoints</code> operation, you can call this operation to access the
/// data to which you have been granted permissions. This operation supports all IAM permissions,
/// including permission conditions that uses tags.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct BatchGetDevEndpoints {
    _private: (),
}
impl BatchGetDevEndpoints {
    /// Creates a new builder-style object to manufacture [`BatchGetDevEndpointsInput`](crate::input::BatchGetDevEndpointsInput)
    pub fn builder() -> crate::input::batch_get_dev_endpoints_input::Builder {
        crate::input::batch_get_dev_endpoints_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for BatchGetDevEndpoints {
    type Output = std::result::Result<
        crate::output::BatchGetDevEndpointsOutput,
        crate::error::BatchGetDevEndpointsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_batch_get_dev_endpoints_error(response)
        } else {
            crate::operation_deser::parse_batch_get_dev_endpoints_response(response)
        }
    }
}

/// <p>Returns a list of resource metadata for a given list of job names. After calling the <code>ListJobs</code> operation, you can call this operation to access the data to which you have been granted permissions. This operation supports all IAM permissions, including permission conditions that uses tags.
/// </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct BatchGetJobs {
    _private: (),
}
impl BatchGetJobs {
    /// Creates a new builder-style object to manufacture [`BatchGetJobsInput`](crate::input::BatchGetJobsInput)
    pub fn builder() -> crate::input::batch_get_jobs_input::Builder {
        crate::input::batch_get_jobs_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for BatchGetJobs {
    type Output =
        std::result::Result<crate::output::BatchGetJobsOutput, crate::error::BatchGetJobsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_batch_get_jobs_error(response)
        } else {
            crate::operation_deser::parse_batch_get_jobs_response(response)
        }
    }
}

/// <p>Retrieves partitions in a batch request.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct BatchGetPartition {
    _private: (),
}
impl BatchGetPartition {
    /// Creates a new builder-style object to manufacture [`BatchGetPartitionInput`](crate::input::BatchGetPartitionInput)
    pub fn builder() -> crate::input::batch_get_partition_input::Builder {
        crate::input::batch_get_partition_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for BatchGetPartition {
    type Output = std::result::Result<
        crate::output::BatchGetPartitionOutput,
        crate::error::BatchGetPartitionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_batch_get_partition_error(response)
        } else {
            crate::operation_deser::parse_batch_get_partition_response(response)
        }
    }
}

/// <p>Returns a list of resource metadata for a given list of trigger names. After calling the <code>ListTriggers</code> operation, you can call this operation to access the data to which you have been granted permissions. This operation supports all IAM permissions, including permission conditions that uses tags.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct BatchGetTriggers {
    _private: (),
}
impl BatchGetTriggers {
    /// Creates a new builder-style object to manufacture [`BatchGetTriggersInput`](crate::input::BatchGetTriggersInput)
    pub fn builder() -> crate::input::batch_get_triggers_input::Builder {
        crate::input::batch_get_triggers_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for BatchGetTriggers {
    type Output = std::result::Result<
        crate::output::BatchGetTriggersOutput,
        crate::error::BatchGetTriggersError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_batch_get_triggers_error(response)
        } else {
            crate::operation_deser::parse_batch_get_triggers_response(response)
        }
    }
}

/// <p>Returns a list of resource metadata for a given list of workflow names. After calling the <code>ListWorkflows</code> operation, you can call this operation to access the data to which you have been granted permissions. This operation supports all IAM permissions, including permission conditions that uses tags.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct BatchGetWorkflows {
    _private: (),
}
impl BatchGetWorkflows {
    /// Creates a new builder-style object to manufacture [`BatchGetWorkflowsInput`](crate::input::BatchGetWorkflowsInput)
    pub fn builder() -> crate::input::batch_get_workflows_input::Builder {
        crate::input::batch_get_workflows_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for BatchGetWorkflows {
    type Output = std::result::Result<
        crate::output::BatchGetWorkflowsOutput,
        crate::error::BatchGetWorkflowsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_batch_get_workflows_error(response)
        } else {
            crate::operation_deser::parse_batch_get_workflows_response(response)
        }
    }
}

/// <p>Stops one or more job runs for a specified job definition.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct BatchStopJobRun {
    _private: (),
}
impl BatchStopJobRun {
    /// Creates a new builder-style object to manufacture [`BatchStopJobRunInput`](crate::input::BatchStopJobRunInput)
    pub fn builder() -> crate::input::batch_stop_job_run_input::Builder {
        crate::input::batch_stop_job_run_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for BatchStopJobRun {
    type Output = std::result::Result<
        crate::output::BatchStopJobRunOutput,
        crate::error::BatchStopJobRunError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_batch_stop_job_run_error(response)
        } else {
            crate::operation_deser::parse_batch_stop_job_run_response(response)
        }
    }
}

/// <p>Updates one or more partitions in a batch operation.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct BatchUpdatePartition {
    _private: (),
}
impl BatchUpdatePartition {
    /// Creates a new builder-style object to manufacture [`BatchUpdatePartitionInput`](crate::input::BatchUpdatePartitionInput)
    pub fn builder() -> crate::input::batch_update_partition_input::Builder {
        crate::input::batch_update_partition_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for BatchUpdatePartition {
    type Output = std::result::Result<
        crate::output::BatchUpdatePartitionOutput,
        crate::error::BatchUpdatePartitionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_batch_update_partition_error(response)
        } else {
            crate::operation_deser::parse_batch_update_partition_response(response)
        }
    }
}

/// <p>Cancels (stops) a task run. Machine learning task runs are asynchronous tasks that Glue runs on your behalf as part of various machine learning workflows. You can cancel a
/// machine learning task run at any time by calling <code>CancelMLTaskRun</code> with a task
/// run's parent transform's <code>TransformID</code> and the task run's <code>TaskRunId</code>. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CancelMLTaskRun {
    _private: (),
}
impl CancelMLTaskRun {
    /// Creates a new builder-style object to manufacture [`CancelMlTaskRunInput`](crate::input::CancelMlTaskRunInput)
    pub fn builder() -> crate::input::cancel_ml_task_run_input::Builder {
        crate::input::cancel_ml_task_run_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CancelMLTaskRun {
    type Output = std::result::Result<
        crate::output::CancelMlTaskRunOutput,
        crate::error::CancelMLTaskRunError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_cancel_ml_task_run_error(response)
        } else {
            crate::operation_deser::parse_cancel_ml_task_run_response(response)
        }
    }
}

/// <p>Validates the supplied schema. This call has no side effects, it simply validates using the supplied schema using <code>DataFormat</code> as the format. Since it does not take a schema set name, no compatibility checks are performed.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CheckSchemaVersionValidity {
    _private: (),
}
impl CheckSchemaVersionValidity {
    /// Creates a new builder-style object to manufacture [`CheckSchemaVersionValidityInput`](crate::input::CheckSchemaVersionValidityInput)
    pub fn builder() -> crate::input::check_schema_version_validity_input::Builder {
        crate::input::check_schema_version_validity_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CheckSchemaVersionValidity {
    type Output = std::result::Result<
        crate::output::CheckSchemaVersionValidityOutput,
        crate::error::CheckSchemaVersionValidityError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_check_schema_version_validity_error(response)
        } else {
            crate::operation_deser::parse_check_schema_version_validity_response(response)
        }
    }
}

/// <p>Creates a classifier in the user's account. This can be a <code>GrokClassifier</code>, an
/// <code>XMLClassifier</code>, a <code>JsonClassifier</code>, or a <code>CsvClassifier</code>,
/// depending on which field of the request is present.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateClassifier {
    _private: (),
}
impl CreateClassifier {
    /// Creates a new builder-style object to manufacture [`CreateClassifierInput`](crate::input::CreateClassifierInput)
    pub fn builder() -> crate::input::create_classifier_input::Builder {
        crate::input::create_classifier_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateClassifier {
    type Output = std::result::Result<
        crate::output::CreateClassifierOutput,
        crate::error::CreateClassifierError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_classifier_error(response)
        } else {
            crate::operation_deser::parse_create_classifier_response(response)
        }
    }
}

/// <p>Creates a connection definition in the Data Catalog.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateConnection {
    _private: (),
}
impl CreateConnection {
    /// Creates a new builder-style object to manufacture [`CreateConnectionInput`](crate::input::CreateConnectionInput)
    pub fn builder() -> crate::input::create_connection_input::Builder {
        crate::input::create_connection_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateConnection {
    type Output = std::result::Result<
        crate::output::CreateConnectionOutput,
        crate::error::CreateConnectionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_connection_error(response)
        } else {
            crate::operation_deser::parse_create_connection_response(response)
        }
    }
}

/// <p>Creates a new crawler with specified targets, role, configuration, and optional schedule.
/// At least one crawl target must be specified, in the <code>s3Targets</code> field, the
/// <code>jdbcTargets</code> field, or the <code>DynamoDBTargets</code> field.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateCrawler {
    _private: (),
}
impl CreateCrawler {
    /// Creates a new builder-style object to manufacture [`CreateCrawlerInput`](crate::input::CreateCrawlerInput)
    pub fn builder() -> crate::input::create_crawler_input::Builder {
        crate::input::create_crawler_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateCrawler {
    type Output =
        std::result::Result<crate::output::CreateCrawlerOutput, crate::error::CreateCrawlerError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_crawler_error(response)
        } else {
            crate::operation_deser::parse_create_crawler_response(response)
        }
    }
}

/// <p>Creates a new database in a Data Catalog.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateDatabase {
    _private: (),
}
impl CreateDatabase {
    /// Creates a new builder-style object to manufacture [`CreateDatabaseInput`](crate::input::CreateDatabaseInput)
    pub fn builder() -> crate::input::create_database_input::Builder {
        crate::input::create_database_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateDatabase {
    type Output =
        std::result::Result<crate::output::CreateDatabaseOutput, crate::error::CreateDatabaseError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_database_error(response)
        } else {
            crate::operation_deser::parse_create_database_response(response)
        }
    }
}

/// <p>Creates a new development endpoint.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateDevEndpoint {
    _private: (),
}
impl CreateDevEndpoint {
    /// Creates a new builder-style object to manufacture [`CreateDevEndpointInput`](crate::input::CreateDevEndpointInput)
    pub fn builder() -> crate::input::create_dev_endpoint_input::Builder {
        crate::input::create_dev_endpoint_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateDevEndpoint {
    type Output = std::result::Result<
        crate::output::CreateDevEndpointOutput,
        crate::error::CreateDevEndpointError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_dev_endpoint_error(response)
        } else {
            crate::operation_deser::parse_create_dev_endpoint_response(response)
        }
    }
}

/// <p>Creates a new job definition.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateJob {
    _private: (),
}
impl CreateJob {
    /// Creates a new builder-style object to manufacture [`CreateJobInput`](crate::input::CreateJobInput)
    pub fn builder() -> crate::input::create_job_input::Builder {
        crate::input::create_job_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateJob {
    type Output = std::result::Result<crate::output::CreateJobOutput, crate::error::CreateJobError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_job_error(response)
        } else {
            crate::operation_deser::parse_create_job_response(response)
        }
    }
}

/// <p>Creates an Glue machine learning transform. This operation creates the transform and
/// all the necessary parameters to train it.</p>
/// <p>Call this operation as the first step in the process of using a machine learning transform
/// (such as the <code>FindMatches</code> transform) for deduplicating data. You can provide an
/// optional <code>Description</code>, in addition to the parameters that you want to use for your
/// algorithm.</p>
/// <p>You must also specify certain parameters for the tasks that Glue runs on your
/// behalf as part of learning from your data and creating a high-quality machine learning
/// transform. These parameters include <code>Role</code>, and optionally,
/// <code>AllocatedCapacity</code>, <code>Timeout</code>, and <code>MaxRetries</code>. For more
/// information, see <a href="https://docs.aws.amazon.com/glue/latest/dg/aws-glue-api-jobs-job.html">Jobs</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateMLTransform {
    _private: (),
}
impl CreateMLTransform {
    /// Creates a new builder-style object to manufacture [`CreateMlTransformInput`](crate::input::CreateMlTransformInput)
    pub fn builder() -> crate::input::create_ml_transform_input::Builder {
        crate::input::create_ml_transform_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateMLTransform {
    type Output = std::result::Result<
        crate::output::CreateMlTransformOutput,
        crate::error::CreateMLTransformError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_ml_transform_error(response)
        } else {
            crate::operation_deser::parse_create_ml_transform_response(response)
        }
    }
}

/// <p>Creates a new partition.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreatePartition {
    _private: (),
}
impl CreatePartition {
    /// Creates a new builder-style object to manufacture [`CreatePartitionInput`](crate::input::CreatePartitionInput)
    pub fn builder() -> crate::input::create_partition_input::Builder {
        crate::input::create_partition_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreatePartition {
    type Output = std::result::Result<
        crate::output::CreatePartitionOutput,
        crate::error::CreatePartitionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_partition_error(response)
        } else {
            crate::operation_deser::parse_create_partition_response(response)
        }
    }
}

/// <p>Creates a specified partition index in an existing table.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreatePartitionIndex {
    _private: (),
}
impl CreatePartitionIndex {
    /// Creates a new builder-style object to manufacture [`CreatePartitionIndexInput`](crate::input::CreatePartitionIndexInput)
    pub fn builder() -> crate::input::create_partition_index_input::Builder {
        crate::input::create_partition_index_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreatePartitionIndex {
    type Output = std::result::Result<
        crate::output::CreatePartitionIndexOutput,
        crate::error::CreatePartitionIndexError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_partition_index_error(response)
        } else {
            crate::operation_deser::parse_create_partition_index_response(response)
        }
    }
}

/// <p>Creates a new registry which may be used to hold a collection of schemas.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateRegistry {
    _private: (),
}
impl CreateRegistry {
    /// Creates a new builder-style object to manufacture [`CreateRegistryInput`](crate::input::CreateRegistryInput)
    pub fn builder() -> crate::input::create_registry_input::Builder {
        crate::input::create_registry_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateRegistry {
    type Output =
        std::result::Result<crate::output::CreateRegistryOutput, crate::error::CreateRegistryError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_registry_error(response)
        } else {
            crate::operation_deser::parse_create_registry_response(response)
        }
    }
}

/// <p>Creates a new schema set and registers the schema definition. Returns an error if the schema set already exists without actually registering the version.</p>
/// <p>When the schema set is created, a version checkpoint will be set to the first version. Compatibility mode "DISABLED" restricts any additional schema versions from being added after the first schema version. For all other compatibility modes, validation of compatibility settings will be applied only from the second version onwards when the <code>RegisterSchemaVersion</code> API is used.</p>
/// <p>When this API is called without a <code>RegistryId</code>, this will create an entry for a "default-registry" in the registry database tables, if it is not already present.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateSchema {
    _private: (),
}
impl CreateSchema {
    /// Creates a new builder-style object to manufacture [`CreateSchemaInput`](crate::input::CreateSchemaInput)
    pub fn builder() -> crate::input::create_schema_input::Builder {
        crate::input::create_schema_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateSchema {
    type Output =
        std::result::Result<crate::output::CreateSchemaOutput, crate::error::CreateSchemaError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_schema_error(response)
        } else {
            crate::operation_deser::parse_create_schema_response(response)
        }
    }
}

/// <p>Transforms a directed acyclic graph (DAG) into code.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateScript {
    _private: (),
}
impl CreateScript {
    /// Creates a new builder-style object to manufacture [`CreateScriptInput`](crate::input::CreateScriptInput)
    pub fn builder() -> crate::input::create_script_input::Builder {
        crate::input::create_script_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateScript {
    type Output =
        std::result::Result<crate::output::CreateScriptOutput, crate::error::CreateScriptError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_script_error(response)
        } else {
            crate::operation_deser::parse_create_script_response(response)
        }
    }
}

/// <p>Creates a new security configuration. A security configuration is a set of security properties that can be used by Glue. You can use a security configuration to encrypt data at rest. For information about using security configurations in Glue, see <a href="https://docs.aws.amazon.com/glue/latest/dg/encryption-security-configuration.html">Encrypting Data Written by Crawlers, Jobs, and Development Endpoints</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateSecurityConfiguration {
    _private: (),
}
impl CreateSecurityConfiguration {
    /// Creates a new builder-style object to manufacture [`CreateSecurityConfigurationInput`](crate::input::CreateSecurityConfigurationInput)
    pub fn builder() -> crate::input::create_security_configuration_input::Builder {
        crate::input::create_security_configuration_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateSecurityConfiguration {
    type Output = std::result::Result<
        crate::output::CreateSecurityConfigurationOutput,
        crate::error::CreateSecurityConfigurationError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_security_configuration_error(response)
        } else {
            crate::operation_deser::parse_create_security_configuration_response(response)
        }
    }
}

/// <p>Creates a new table definition in the Data Catalog.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateTable {
    _private: (),
}
impl CreateTable {
    /// Creates a new builder-style object to manufacture [`CreateTableInput`](crate::input::CreateTableInput)
    pub fn builder() -> crate::input::create_table_input::Builder {
        crate::input::create_table_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateTable {
    type Output =
        std::result::Result<crate::output::CreateTableOutput, crate::error::CreateTableError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_table_error(response)
        } else {
            crate::operation_deser::parse_create_table_response(response)
        }
    }
}

/// <p>Creates a new trigger.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateTrigger {
    _private: (),
}
impl CreateTrigger {
    /// Creates a new builder-style object to manufacture [`CreateTriggerInput`](crate::input::CreateTriggerInput)
    pub fn builder() -> crate::input::create_trigger_input::Builder {
        crate::input::create_trigger_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateTrigger {
    type Output =
        std::result::Result<crate::output::CreateTriggerOutput, crate::error::CreateTriggerError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_trigger_error(response)
        } else {
            crate::operation_deser::parse_create_trigger_response(response)
        }
    }
}

/// <p>Creates a new function definition in the Data Catalog.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateUserDefinedFunction {
    _private: (),
}
impl CreateUserDefinedFunction {
    /// Creates a new builder-style object to manufacture [`CreateUserDefinedFunctionInput`](crate::input::CreateUserDefinedFunctionInput)
    pub fn builder() -> crate::input::create_user_defined_function_input::Builder {
        crate::input::create_user_defined_function_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateUserDefinedFunction {
    type Output = std::result::Result<
        crate::output::CreateUserDefinedFunctionOutput,
        crate::error::CreateUserDefinedFunctionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_user_defined_function_error(response)
        } else {
            crate::operation_deser::parse_create_user_defined_function_response(response)
        }
    }
}

/// <p>Creates a new workflow.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateWorkflow {
    _private: (),
}
impl CreateWorkflow {
    /// Creates a new builder-style object to manufacture [`CreateWorkflowInput`](crate::input::CreateWorkflowInput)
    pub fn builder() -> crate::input::create_workflow_input::Builder {
        crate::input::create_workflow_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateWorkflow {
    type Output =
        std::result::Result<crate::output::CreateWorkflowOutput, crate::error::CreateWorkflowError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_workflow_error(response)
        } else {
            crate::operation_deser::parse_create_workflow_response(response)
        }
    }
}

/// <p>Removes a classifier from the Data Catalog.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteClassifier {
    _private: (),
}
impl DeleteClassifier {
    /// Creates a new builder-style object to manufacture [`DeleteClassifierInput`](crate::input::DeleteClassifierInput)
    pub fn builder() -> crate::input::delete_classifier_input::Builder {
        crate::input::delete_classifier_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteClassifier {
    type Output = std::result::Result<
        crate::output::DeleteClassifierOutput,
        crate::error::DeleteClassifierError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_classifier_error(response)
        } else {
            crate::operation_deser::parse_delete_classifier_response(response)
        }
    }
}

/// <p>Delete the partition column statistics of a column.</p>
/// <p>The Identity and Access Management (IAM) permission required for this operation is <code>DeletePartition</code>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteColumnStatisticsForPartition {
    _private: (),
}
impl DeleteColumnStatisticsForPartition {
    /// Creates a new builder-style object to manufacture [`DeleteColumnStatisticsForPartitionInput`](crate::input::DeleteColumnStatisticsForPartitionInput)
    pub fn builder() -> crate::input::delete_column_statistics_for_partition_input::Builder {
        crate::input::delete_column_statistics_for_partition_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteColumnStatisticsForPartition {
    type Output = std::result::Result<
        crate::output::DeleteColumnStatisticsForPartitionOutput,
        crate::error::DeleteColumnStatisticsForPartitionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_column_statistics_for_partition_error(response)
        } else {
            crate::operation_deser::parse_delete_column_statistics_for_partition_response(response)
        }
    }
}

/// <p>Retrieves table statistics of columns.</p>
/// <p>The Identity and Access Management (IAM) permission required for this operation is <code>DeleteTable</code>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteColumnStatisticsForTable {
    _private: (),
}
impl DeleteColumnStatisticsForTable {
    /// Creates a new builder-style object to manufacture [`DeleteColumnStatisticsForTableInput`](crate::input::DeleteColumnStatisticsForTableInput)
    pub fn builder() -> crate::input::delete_column_statistics_for_table_input::Builder {
        crate::input::delete_column_statistics_for_table_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteColumnStatisticsForTable {
    type Output = std::result::Result<
        crate::output::DeleteColumnStatisticsForTableOutput,
        crate::error::DeleteColumnStatisticsForTableError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_column_statistics_for_table_error(response)
        } else {
            crate::operation_deser::parse_delete_column_statistics_for_table_response(response)
        }
    }
}

/// <p>Deletes a connection from the Data Catalog.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteConnection {
    _private: (),
}
impl DeleteConnection {
    /// Creates a new builder-style object to manufacture [`DeleteConnectionInput`](crate::input::DeleteConnectionInput)
    pub fn builder() -> crate::input::delete_connection_input::Builder {
        crate::input::delete_connection_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteConnection {
    type Output = std::result::Result<
        crate::output::DeleteConnectionOutput,
        crate::error::DeleteConnectionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_connection_error(response)
        } else {
            crate::operation_deser::parse_delete_connection_response(response)
        }
    }
}

/// <p>Removes a specified crawler from the Glue Data Catalog, unless the crawler state is
/// <code>RUNNING</code>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteCrawler {
    _private: (),
}
impl DeleteCrawler {
    /// Creates a new builder-style object to manufacture [`DeleteCrawlerInput`](crate::input::DeleteCrawlerInput)
    pub fn builder() -> crate::input::delete_crawler_input::Builder {
        crate::input::delete_crawler_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteCrawler {
    type Output =
        std::result::Result<crate::output::DeleteCrawlerOutput, crate::error::DeleteCrawlerError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_crawler_error(response)
        } else {
            crate::operation_deser::parse_delete_crawler_response(response)
        }
    }
}

/// <p>Removes a specified database from a Data Catalog.</p>
/// <note>
/// <p>After completing this operation, you no longer have access to the tables (and all table
/// versions and partitions that might belong to the tables) and the user-defined functions in
/// the deleted database. Glue deletes these "orphaned" resources asynchronously in a timely
/// manner, at the discretion of the service.</p>
/// <p>To ensure the immediate deletion of all related resources, before calling
/// <code>DeleteDatabase</code>, use <code>DeleteTableVersion</code> or
/// <code>BatchDeleteTableVersion</code>, <code>DeletePartition</code> or
/// <code>BatchDeletePartition</code>, <code>DeleteUserDefinedFunction</code>, and
/// <code>DeleteTable</code> or <code>BatchDeleteTable</code>, to delete any resources that
/// belong to the database.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteDatabase {
    _private: (),
}
impl DeleteDatabase {
    /// Creates a new builder-style object to manufacture [`DeleteDatabaseInput`](crate::input::DeleteDatabaseInput)
    pub fn builder() -> crate::input::delete_database_input::Builder {
        crate::input::delete_database_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteDatabase {
    type Output =
        std::result::Result<crate::output::DeleteDatabaseOutput, crate::error::DeleteDatabaseError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_database_error(response)
        } else {
            crate::operation_deser::parse_delete_database_response(response)
        }
    }
}

/// <p>Deletes a specified development endpoint.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteDevEndpoint {
    _private: (),
}
impl DeleteDevEndpoint {
    /// Creates a new builder-style object to manufacture [`DeleteDevEndpointInput`](crate::input::DeleteDevEndpointInput)
    pub fn builder() -> crate::input::delete_dev_endpoint_input::Builder {
        crate::input::delete_dev_endpoint_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteDevEndpoint {
    type Output = std::result::Result<
        crate::output::DeleteDevEndpointOutput,
        crate::error::DeleteDevEndpointError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_dev_endpoint_error(response)
        } else {
            crate::operation_deser::parse_delete_dev_endpoint_response(response)
        }
    }
}

/// <p>Deletes a specified job definition. If the job definition
/// is not found, no exception is thrown.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteJob {
    _private: (),
}
impl DeleteJob {
    /// Creates a new builder-style object to manufacture [`DeleteJobInput`](crate::input::DeleteJobInput)
    pub fn builder() -> crate::input::delete_job_input::Builder {
        crate::input::delete_job_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteJob {
    type Output = std::result::Result<crate::output::DeleteJobOutput, crate::error::DeleteJobError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_job_error(response)
        } else {
            crate::operation_deser::parse_delete_job_response(response)
        }
    }
}

/// <p>Deletes an Glue machine learning transform. Machine learning transforms are a special
/// type of transform that use machine learning to learn the details of the transformation to be
/// performed by learning from examples provided by humans. These transformations are then saved
/// by Glue. If you no longer need a transform, you can delete it by calling
/// <code>DeleteMLTransforms</code>. However, any Glue jobs that still reference the deleted
/// transform will no longer succeed.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteMLTransform {
    _private: (),
}
impl DeleteMLTransform {
    /// Creates a new builder-style object to manufacture [`DeleteMlTransformInput`](crate::input::DeleteMlTransformInput)
    pub fn builder() -> crate::input::delete_ml_transform_input::Builder {
        crate::input::delete_ml_transform_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteMLTransform {
    type Output = std::result::Result<
        crate::output::DeleteMlTransformOutput,
        crate::error::DeleteMLTransformError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_ml_transform_error(response)
        } else {
            crate::operation_deser::parse_delete_ml_transform_response(response)
        }
    }
}

/// <p>Deletes a specified partition.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeletePartition {
    _private: (),
}
impl DeletePartition {
    /// Creates a new builder-style object to manufacture [`DeletePartitionInput`](crate::input::DeletePartitionInput)
    pub fn builder() -> crate::input::delete_partition_input::Builder {
        crate::input::delete_partition_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeletePartition {
    type Output = std::result::Result<
        crate::output::DeletePartitionOutput,
        crate::error::DeletePartitionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_partition_error(response)
        } else {
            crate::operation_deser::parse_delete_partition_response(response)
        }
    }
}

/// <p>Deletes a specified partition index from an existing table.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeletePartitionIndex {
    _private: (),
}
impl DeletePartitionIndex {
    /// Creates a new builder-style object to manufacture [`DeletePartitionIndexInput`](crate::input::DeletePartitionIndexInput)
    pub fn builder() -> crate::input::delete_partition_index_input::Builder {
        crate::input::delete_partition_index_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeletePartitionIndex {
    type Output = std::result::Result<
        crate::output::DeletePartitionIndexOutput,
        crate::error::DeletePartitionIndexError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_partition_index_error(response)
        } else {
            crate::operation_deser::parse_delete_partition_index_response(response)
        }
    }
}

/// <p>Delete the entire registry including schema and all of its versions. To get the status of the delete operation, you can call the <code>GetRegistry</code> API after the asynchronous call. Deleting a registry will deactivate all online operations for the registry such as the <code>UpdateRegistry</code>, <code>CreateSchema</code>, <code>UpdateSchema</code>, and <code>RegisterSchemaVersion</code> APIs. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteRegistry {
    _private: (),
}
impl DeleteRegistry {
    /// Creates a new builder-style object to manufacture [`DeleteRegistryInput`](crate::input::DeleteRegistryInput)
    pub fn builder() -> crate::input::delete_registry_input::Builder {
        crate::input::delete_registry_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteRegistry {
    type Output =
        std::result::Result<crate::output::DeleteRegistryOutput, crate::error::DeleteRegistryError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_registry_error(response)
        } else {
            crate::operation_deser::parse_delete_registry_response(response)
        }
    }
}

/// <p>Deletes a specified policy.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteResourcePolicy {
    _private: (),
}
impl DeleteResourcePolicy {
    /// Creates a new builder-style object to manufacture [`DeleteResourcePolicyInput`](crate::input::DeleteResourcePolicyInput)
    pub fn builder() -> crate::input::delete_resource_policy_input::Builder {
        crate::input::delete_resource_policy_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteResourcePolicy {
    type Output = std::result::Result<
        crate::output::DeleteResourcePolicyOutput,
        crate::error::DeleteResourcePolicyError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_resource_policy_error(response)
        } else {
            crate::operation_deser::parse_delete_resource_policy_response(response)
        }
    }
}

/// <p>Deletes the entire schema set, including the schema set and all of its versions. To get the status of the delete operation, you can call <code>GetSchema</code> API after the asynchronous call. Deleting a registry will deactivate all online operations for the schema, such as the <code>GetSchemaByDefinition</code>, and <code>RegisterSchemaVersion</code> APIs.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteSchema {
    _private: (),
}
impl DeleteSchema {
    /// Creates a new builder-style object to manufacture [`DeleteSchemaInput`](crate::input::DeleteSchemaInput)
    pub fn builder() -> crate::input::delete_schema_input::Builder {
        crate::input::delete_schema_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteSchema {
    type Output =
        std::result::Result<crate::output::DeleteSchemaOutput, crate::error::DeleteSchemaError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_schema_error(response)
        } else {
            crate::operation_deser::parse_delete_schema_response(response)
        }
    }
}

/// <p>Remove versions from the specified schema. A version number or range may be supplied. If the compatibility mode forbids deleting of a version that is necessary, such as BACKWARDS_FULL, an error is returned.  Calling the <code>GetSchemaVersions</code> API after this call will list the status of the deleted versions.</p>
/// <p>When the range of version numbers contain check pointed version, the API will return a 409 conflict and will not proceed with the deletion. You have to remove the checkpoint first using the <code>DeleteSchemaCheckpoint</code> API before using this API.</p>
/// <p>You cannot use the <code>DeleteSchemaVersions</code> API to delete the first schema version in the schema set. The first schema version can only be deleted by the <code>DeleteSchema</code> API. This operation will also delete the attached <code>SchemaVersionMetadata</code> under the schema versions. Hard deletes will be enforced on the database.</p>
/// <p>If the compatibility mode forbids deleting of a version that is necessary, such as BACKWARDS_FULL, an error is returned.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteSchemaVersions {
    _private: (),
}
impl DeleteSchemaVersions {
    /// Creates a new builder-style object to manufacture [`DeleteSchemaVersionsInput`](crate::input::DeleteSchemaVersionsInput)
    pub fn builder() -> crate::input::delete_schema_versions_input::Builder {
        crate::input::delete_schema_versions_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteSchemaVersions {
    type Output = std::result::Result<
        crate::output::DeleteSchemaVersionsOutput,
        crate::error::DeleteSchemaVersionsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_schema_versions_error(response)
        } else {
            crate::operation_deser::parse_delete_schema_versions_response(response)
        }
    }
}

/// <p>Deletes a specified security configuration.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteSecurityConfiguration {
    _private: (),
}
impl DeleteSecurityConfiguration {
    /// Creates a new builder-style object to manufacture [`DeleteSecurityConfigurationInput`](crate::input::DeleteSecurityConfigurationInput)
    pub fn builder() -> crate::input::delete_security_configuration_input::Builder {
        crate::input::delete_security_configuration_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteSecurityConfiguration {
    type Output = std::result::Result<
        crate::output::DeleteSecurityConfigurationOutput,
        crate::error::DeleteSecurityConfigurationError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_security_configuration_error(response)
        } else {
            crate::operation_deser::parse_delete_security_configuration_response(response)
        }
    }
}

/// <p>Removes a table definition from the Data Catalog.</p>
/// <note>
/// <p>After completing this operation, you no longer have access to the table versions and
/// partitions that belong to the deleted table. Glue deletes these "orphaned" resources
/// asynchronously in a timely manner, at the discretion of the service.</p>
/// <p>To ensure the immediate deletion of all related resources, before calling
/// <code>DeleteTable</code>, use <code>DeleteTableVersion</code> or
/// <code>BatchDeleteTableVersion</code>, and <code>DeletePartition</code> or
/// <code>BatchDeletePartition</code>, to delete any resources that belong to the
/// table.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteTable {
    _private: (),
}
impl DeleteTable {
    /// Creates a new builder-style object to manufacture [`DeleteTableInput`](crate::input::DeleteTableInput)
    pub fn builder() -> crate::input::delete_table_input::Builder {
        crate::input::delete_table_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteTable {
    type Output =
        std::result::Result<crate::output::DeleteTableOutput, crate::error::DeleteTableError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_table_error(response)
        } else {
            crate::operation_deser::parse_delete_table_response(response)
        }
    }
}

/// <p>Deletes a specified version of a table.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteTableVersion {
    _private: (),
}
impl DeleteTableVersion {
    /// Creates a new builder-style object to manufacture [`DeleteTableVersionInput`](crate::input::DeleteTableVersionInput)
    pub fn builder() -> crate::input::delete_table_version_input::Builder {
        crate::input::delete_table_version_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteTableVersion {
    type Output = std::result::Result<
        crate::output::DeleteTableVersionOutput,
        crate::error::DeleteTableVersionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_table_version_error(response)
        } else {
            crate::operation_deser::parse_delete_table_version_response(response)
        }
    }
}

/// <p>Deletes a specified trigger. If the trigger is not found, no
/// exception is thrown.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteTrigger {
    _private: (),
}
impl DeleteTrigger {
    /// Creates a new builder-style object to manufacture [`DeleteTriggerInput`](crate::input::DeleteTriggerInput)
    pub fn builder() -> crate::input::delete_trigger_input::Builder {
        crate::input::delete_trigger_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteTrigger {
    type Output =
        std::result::Result<crate::output::DeleteTriggerOutput, crate::error::DeleteTriggerError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_trigger_error(response)
        } else {
            crate::operation_deser::parse_delete_trigger_response(response)
        }
    }
}

/// <p>Deletes an existing function definition from the Data Catalog.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteUserDefinedFunction {
    _private: (),
}
impl DeleteUserDefinedFunction {
    /// Creates a new builder-style object to manufacture [`DeleteUserDefinedFunctionInput`](crate::input::DeleteUserDefinedFunctionInput)
    pub fn builder() -> crate::input::delete_user_defined_function_input::Builder {
        crate::input::delete_user_defined_function_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteUserDefinedFunction {
    type Output = std::result::Result<
        crate::output::DeleteUserDefinedFunctionOutput,
        crate::error::DeleteUserDefinedFunctionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_user_defined_function_error(response)
        } else {
            crate::operation_deser::parse_delete_user_defined_function_response(response)
        }
    }
}

/// <p>Deletes a workflow.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteWorkflow {
    _private: (),
}
impl DeleteWorkflow {
    /// Creates a new builder-style object to manufacture [`DeleteWorkflowInput`](crate::input::DeleteWorkflowInput)
    pub fn builder() -> crate::input::delete_workflow_input::Builder {
        crate::input::delete_workflow_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteWorkflow {
    type Output =
        std::result::Result<crate::output::DeleteWorkflowOutput, crate::error::DeleteWorkflowError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_workflow_error(response)
        } else {
            crate::operation_deser::parse_delete_workflow_response(response)
        }
    }
}

/// <p>Retrieves the status of a migration operation.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetCatalogImportStatus {
    _private: (),
}
impl GetCatalogImportStatus {
    /// Creates a new builder-style object to manufacture [`GetCatalogImportStatusInput`](crate::input::GetCatalogImportStatusInput)
    pub fn builder() -> crate::input::get_catalog_import_status_input::Builder {
        crate::input::get_catalog_import_status_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetCatalogImportStatus {
    type Output = std::result::Result<
        crate::output::GetCatalogImportStatusOutput,
        crate::error::GetCatalogImportStatusError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_catalog_import_status_error(response)
        } else {
            crate::operation_deser::parse_get_catalog_import_status_response(response)
        }
    }
}

/// <p>Retrieve a classifier by name.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetClassifier {
    _private: (),
}
impl GetClassifier {
    /// Creates a new builder-style object to manufacture [`GetClassifierInput`](crate::input::GetClassifierInput)
    pub fn builder() -> crate::input::get_classifier_input::Builder {
        crate::input::get_classifier_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetClassifier {
    type Output =
        std::result::Result<crate::output::GetClassifierOutput, crate::error::GetClassifierError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_classifier_error(response)
        } else {
            crate::operation_deser::parse_get_classifier_response(response)
        }
    }
}

/// <p>Lists all classifier objects in the Data Catalog.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetClassifiers {
    _private: (),
}
impl GetClassifiers {
    /// Creates a new builder-style object to manufacture [`GetClassifiersInput`](crate::input::GetClassifiersInput)
    pub fn builder() -> crate::input::get_classifiers_input::Builder {
        crate::input::get_classifiers_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetClassifiers {
    type Output =
        std::result::Result<crate::output::GetClassifiersOutput, crate::error::GetClassifiersError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_classifiers_error(response)
        } else {
            crate::operation_deser::parse_get_classifiers_response(response)
        }
    }
}

/// <p>Retrieves partition statistics of columns.</p>
/// <p>The Identity and Access Management (IAM) permission required for this operation is <code>GetPartition</code>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetColumnStatisticsForPartition {
    _private: (),
}
impl GetColumnStatisticsForPartition {
    /// Creates a new builder-style object to manufacture [`GetColumnStatisticsForPartitionInput`](crate::input::GetColumnStatisticsForPartitionInput)
    pub fn builder() -> crate::input::get_column_statistics_for_partition_input::Builder {
        crate::input::get_column_statistics_for_partition_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetColumnStatisticsForPartition {
    type Output = std::result::Result<
        crate::output::GetColumnStatisticsForPartitionOutput,
        crate::error::GetColumnStatisticsForPartitionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_column_statistics_for_partition_error(response)
        } else {
            crate::operation_deser::parse_get_column_statistics_for_partition_response(response)
        }
    }
}

/// <p>Retrieves table statistics of columns.</p>
/// <p>The Identity and Access Management (IAM) permission required for this operation is <code>GetTable</code>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetColumnStatisticsForTable {
    _private: (),
}
impl GetColumnStatisticsForTable {
    /// Creates a new builder-style object to manufacture [`GetColumnStatisticsForTableInput`](crate::input::GetColumnStatisticsForTableInput)
    pub fn builder() -> crate::input::get_column_statistics_for_table_input::Builder {
        crate::input::get_column_statistics_for_table_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetColumnStatisticsForTable {
    type Output = std::result::Result<
        crate::output::GetColumnStatisticsForTableOutput,
        crate::error::GetColumnStatisticsForTableError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_column_statistics_for_table_error(response)
        } else {
            crate::operation_deser::parse_get_column_statistics_for_table_response(response)
        }
    }
}

/// <p>Retrieves a connection definition from the Data Catalog.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetConnection {
    _private: (),
}
impl GetConnection {
    /// Creates a new builder-style object to manufacture [`GetConnectionInput`](crate::input::GetConnectionInput)
    pub fn builder() -> crate::input::get_connection_input::Builder {
        crate::input::get_connection_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetConnection {
    type Output =
        std::result::Result<crate::output::GetConnectionOutput, crate::error::GetConnectionError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_connection_error(response)
        } else {
            crate::operation_deser::parse_get_connection_response(response)
        }
    }
}

/// <p>Retrieves a list of connection definitions from the Data Catalog.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetConnections {
    _private: (),
}
impl GetConnections {
    /// Creates a new builder-style object to manufacture [`GetConnectionsInput`](crate::input::GetConnectionsInput)
    pub fn builder() -> crate::input::get_connections_input::Builder {
        crate::input::get_connections_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetConnections {
    type Output =
        std::result::Result<crate::output::GetConnectionsOutput, crate::error::GetConnectionsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_connections_error(response)
        } else {
            crate::operation_deser::parse_get_connections_response(response)
        }
    }
}

/// <p>Retrieves metadata for a specified crawler.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetCrawler {
    _private: (),
}
impl GetCrawler {
    /// Creates a new builder-style object to manufacture [`GetCrawlerInput`](crate::input::GetCrawlerInput)
    pub fn builder() -> crate::input::get_crawler_input::Builder {
        crate::input::get_crawler_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetCrawler {
    type Output =
        std::result::Result<crate::output::GetCrawlerOutput, crate::error::GetCrawlerError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_crawler_error(response)
        } else {
            crate::operation_deser::parse_get_crawler_response(response)
        }
    }
}

/// <p>Retrieves metrics about specified crawlers.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetCrawlerMetrics {
    _private: (),
}
impl GetCrawlerMetrics {
    /// Creates a new builder-style object to manufacture [`GetCrawlerMetricsInput`](crate::input::GetCrawlerMetricsInput)
    pub fn builder() -> crate::input::get_crawler_metrics_input::Builder {
        crate::input::get_crawler_metrics_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetCrawlerMetrics {
    type Output = std::result::Result<
        crate::output::GetCrawlerMetricsOutput,
        crate::error::GetCrawlerMetricsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_crawler_metrics_error(response)
        } else {
            crate::operation_deser::parse_get_crawler_metrics_response(response)
        }
    }
}

/// <p>Retrieves metadata for all crawlers defined in the customer
/// account.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetCrawlers {
    _private: (),
}
impl GetCrawlers {
    /// Creates a new builder-style object to manufacture [`GetCrawlersInput`](crate::input::GetCrawlersInput)
    pub fn builder() -> crate::input::get_crawlers_input::Builder {
        crate::input::get_crawlers_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetCrawlers {
    type Output =
        std::result::Result<crate::output::GetCrawlersOutput, crate::error::GetCrawlersError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_crawlers_error(response)
        } else {
            crate::operation_deser::parse_get_crawlers_response(response)
        }
    }
}

/// <p>Retrieves the definition of a specified database.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetDatabase {
    _private: (),
}
impl GetDatabase {
    /// Creates a new builder-style object to manufacture [`GetDatabaseInput`](crate::input::GetDatabaseInput)
    pub fn builder() -> crate::input::get_database_input::Builder {
        crate::input::get_database_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetDatabase {
    type Output =
        std::result::Result<crate::output::GetDatabaseOutput, crate::error::GetDatabaseError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_database_error(response)
        } else {
            crate::operation_deser::parse_get_database_response(response)
        }
    }
}

/// <p>Retrieves all databases defined in a given Data Catalog.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetDatabases {
    _private: (),
}
impl GetDatabases {
    /// Creates a new builder-style object to manufacture [`GetDatabasesInput`](crate::input::GetDatabasesInput)
    pub fn builder() -> crate::input::get_databases_input::Builder {
        crate::input::get_databases_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetDatabases {
    type Output =
        std::result::Result<crate::output::GetDatabasesOutput, crate::error::GetDatabasesError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_databases_error(response)
        } else {
            crate::operation_deser::parse_get_databases_response(response)
        }
    }
}

/// <p>Retrieves the security configuration for a specified catalog.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetDataCatalogEncryptionSettings {
    _private: (),
}
impl GetDataCatalogEncryptionSettings {
    /// Creates a new builder-style object to manufacture [`GetDataCatalogEncryptionSettingsInput`](crate::input::GetDataCatalogEncryptionSettingsInput)
    pub fn builder() -> crate::input::get_data_catalog_encryption_settings_input::Builder {
        crate::input::get_data_catalog_encryption_settings_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetDataCatalogEncryptionSettings {
    type Output = std::result::Result<
        crate::output::GetDataCatalogEncryptionSettingsOutput,
        crate::error::GetDataCatalogEncryptionSettingsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_data_catalog_encryption_settings_error(response)
        } else {
            crate::operation_deser::parse_get_data_catalog_encryption_settings_response(response)
        }
    }
}

/// <p>Transforms a Python script into a directed acyclic graph (DAG). </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetDataflowGraph {
    _private: (),
}
impl GetDataflowGraph {
    /// Creates a new builder-style object to manufacture [`GetDataflowGraphInput`](crate::input::GetDataflowGraphInput)
    pub fn builder() -> crate::input::get_dataflow_graph_input::Builder {
        crate::input::get_dataflow_graph_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetDataflowGraph {
    type Output = std::result::Result<
        crate::output::GetDataflowGraphOutput,
        crate::error::GetDataflowGraphError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_dataflow_graph_error(response)
        } else {
            crate::operation_deser::parse_get_dataflow_graph_response(response)
        }
    }
}

/// <p>Retrieves information about a specified development endpoint.</p>
/// <note>
/// <p>When you create a development endpoint in a virtual private cloud (VPC), Glue returns only
/// a private IP address, and the public IP address field is not populated. When you create a
/// non-VPC development endpoint, Glue returns only a public IP address.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetDevEndpoint {
    _private: (),
}
impl GetDevEndpoint {
    /// Creates a new builder-style object to manufacture [`GetDevEndpointInput`](crate::input::GetDevEndpointInput)
    pub fn builder() -> crate::input::get_dev_endpoint_input::Builder {
        crate::input::get_dev_endpoint_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetDevEndpoint {
    type Output =
        std::result::Result<crate::output::GetDevEndpointOutput, crate::error::GetDevEndpointError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_dev_endpoint_error(response)
        } else {
            crate::operation_deser::parse_get_dev_endpoint_response(response)
        }
    }
}

/// <p>Retrieves all the development endpoints in this AWS account.</p>
/// <note>
/// <p>When you create a development endpoint in a virtual private cloud (VPC), Glue returns only a private IP address
/// and the public IP address field is not populated. When you create a non-VPC development
/// endpoint, Glue returns only a public IP address.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetDevEndpoints {
    _private: (),
}
impl GetDevEndpoints {
    /// Creates a new builder-style object to manufacture [`GetDevEndpointsInput`](crate::input::GetDevEndpointsInput)
    pub fn builder() -> crate::input::get_dev_endpoints_input::Builder {
        crate::input::get_dev_endpoints_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetDevEndpoints {
    type Output = std::result::Result<
        crate::output::GetDevEndpointsOutput,
        crate::error::GetDevEndpointsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_dev_endpoints_error(response)
        } else {
            crate::operation_deser::parse_get_dev_endpoints_response(response)
        }
    }
}

/// <p>Retrieves an existing job definition.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetJob {
    _private: (),
}
impl GetJob {
    /// Creates a new builder-style object to manufacture [`GetJobInput`](crate::input::GetJobInput)
    pub fn builder() -> crate::input::get_job_input::Builder {
        crate::input::get_job_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetJob {
    type Output = std::result::Result<crate::output::GetJobOutput, crate::error::GetJobError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_job_error(response)
        } else {
            crate::operation_deser::parse_get_job_response(response)
        }
    }
}

/// <p>Returns information on a job bookmark entry.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetJobBookmark {
    _private: (),
}
impl GetJobBookmark {
    /// Creates a new builder-style object to manufacture [`GetJobBookmarkInput`](crate::input::GetJobBookmarkInput)
    pub fn builder() -> crate::input::get_job_bookmark_input::Builder {
        crate::input::get_job_bookmark_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetJobBookmark {
    type Output =
        std::result::Result<crate::output::GetJobBookmarkOutput, crate::error::GetJobBookmarkError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_job_bookmark_error(response)
        } else {
            crate::operation_deser::parse_get_job_bookmark_response(response)
        }
    }
}

/// <p>Retrieves the metadata for a given job run.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetJobRun {
    _private: (),
}
impl GetJobRun {
    /// Creates a new builder-style object to manufacture [`GetJobRunInput`](crate::input::GetJobRunInput)
    pub fn builder() -> crate::input::get_job_run_input::Builder {
        crate::input::get_job_run_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetJobRun {
    type Output = std::result::Result<crate::output::GetJobRunOutput, crate::error::GetJobRunError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_job_run_error(response)
        } else {
            crate::operation_deser::parse_get_job_run_response(response)
        }
    }
}

/// <p>Retrieves metadata for all runs of a given job definition.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetJobRuns {
    _private: (),
}
impl GetJobRuns {
    /// Creates a new builder-style object to manufacture [`GetJobRunsInput`](crate::input::GetJobRunsInput)
    pub fn builder() -> crate::input::get_job_runs_input::Builder {
        crate::input::get_job_runs_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetJobRuns {
    type Output =
        std::result::Result<crate::output::GetJobRunsOutput, crate::error::GetJobRunsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_job_runs_error(response)
        } else {
            crate::operation_deser::parse_get_job_runs_response(response)
        }
    }
}

/// <p>Retrieves all current job definitions.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetJobs {
    _private: (),
}
impl GetJobs {
    /// Creates a new builder-style object to manufacture [`GetJobsInput`](crate::input::GetJobsInput)
    pub fn builder() -> crate::input::get_jobs_input::Builder {
        crate::input::get_jobs_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetJobs {
    type Output = std::result::Result<crate::output::GetJobsOutput, crate::error::GetJobsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_jobs_error(response)
        } else {
            crate::operation_deser::parse_get_jobs_response(response)
        }
    }
}

/// <p>Creates mappings.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetMapping {
    _private: (),
}
impl GetMapping {
    /// Creates a new builder-style object to manufacture [`GetMappingInput`](crate::input::GetMappingInput)
    pub fn builder() -> crate::input::get_mapping_input::Builder {
        crate::input::get_mapping_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetMapping {
    type Output =
        std::result::Result<crate::output::GetMappingOutput, crate::error::GetMappingError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_mapping_error(response)
        } else {
            crate::operation_deser::parse_get_mapping_response(response)
        }
    }
}

/// <p>Gets details for a specific task run on a machine learning transform. Machine learning
/// task runs are asynchronous tasks that Glue runs on your behalf as part of various machine
/// learning workflows. You can check the stats of any task run by calling
/// <code>GetMLTaskRun</code> with the <code>TaskRunID</code> and its parent transform's
/// <code>TransformID</code>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetMLTaskRun {
    _private: (),
}
impl GetMLTaskRun {
    /// Creates a new builder-style object to manufacture [`GetMlTaskRunInput`](crate::input::GetMlTaskRunInput)
    pub fn builder() -> crate::input::get_ml_task_run_input::Builder {
        crate::input::get_ml_task_run_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetMLTaskRun {
    type Output =
        std::result::Result<crate::output::GetMlTaskRunOutput, crate::error::GetMLTaskRunError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_ml_task_run_error(response)
        } else {
            crate::operation_deser::parse_get_ml_task_run_response(response)
        }
    }
}

/// <p>Gets a list of runs for a machine learning transform. Machine learning task runs are
/// asynchronous tasks that Glue runs on your behalf as part of various machine learning
/// workflows. You can get a sortable, filterable list of machine learning task runs by calling
/// <code>GetMLTaskRuns</code> with their parent transform's <code>TransformID</code> and other
/// optional parameters as documented in this section.</p>
/// <p>This operation returns a list of historic runs and must be paginated.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetMLTaskRuns {
    _private: (),
}
impl GetMLTaskRuns {
    /// Creates a new builder-style object to manufacture [`GetMlTaskRunsInput`](crate::input::GetMlTaskRunsInput)
    pub fn builder() -> crate::input::get_ml_task_runs_input::Builder {
        crate::input::get_ml_task_runs_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetMLTaskRuns {
    type Output =
        std::result::Result<crate::output::GetMlTaskRunsOutput, crate::error::GetMLTaskRunsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_ml_task_runs_error(response)
        } else {
            crate::operation_deser::parse_get_ml_task_runs_response(response)
        }
    }
}

/// <p>Gets an Glue machine learning transform artifact and all its corresponding metadata.
/// Machine learning transforms are a special type of transform that use machine learning to learn
/// the details of the transformation to be performed by learning from examples provided by
/// humans. These transformations are then saved by Glue. You can retrieve their metadata by
/// calling <code>GetMLTransform</code>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetMLTransform {
    _private: (),
}
impl GetMLTransform {
    /// Creates a new builder-style object to manufacture [`GetMlTransformInput`](crate::input::GetMlTransformInput)
    pub fn builder() -> crate::input::get_ml_transform_input::Builder {
        crate::input::get_ml_transform_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetMLTransform {
    type Output =
        std::result::Result<crate::output::GetMlTransformOutput, crate::error::GetMLTransformError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_ml_transform_error(response)
        } else {
            crate::operation_deser::parse_get_ml_transform_response(response)
        }
    }
}

/// <p>Gets a sortable, filterable list of existing Glue machine learning transforms. Machine
/// learning transforms are a special type of transform that use machine learning to learn the
/// details of the transformation to be performed by learning from examples provided by humans.
/// These transformations are then saved by Glue, and you can retrieve their metadata by
/// calling <code>GetMLTransforms</code>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetMLTransforms {
    _private: (),
}
impl GetMLTransforms {
    /// Creates a new builder-style object to manufacture [`GetMlTransformsInput`](crate::input::GetMlTransformsInput)
    pub fn builder() -> crate::input::get_ml_transforms_input::Builder {
        crate::input::get_ml_transforms_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetMLTransforms {
    type Output = std::result::Result<
        crate::output::GetMlTransformsOutput,
        crate::error::GetMLTransformsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_ml_transforms_error(response)
        } else {
            crate::operation_deser::parse_get_ml_transforms_response(response)
        }
    }
}

/// <p>Retrieves information about a specified partition.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetPartition {
    _private: (),
}
impl GetPartition {
    /// Creates a new builder-style object to manufacture [`GetPartitionInput`](crate::input::GetPartitionInput)
    pub fn builder() -> crate::input::get_partition_input::Builder {
        crate::input::get_partition_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetPartition {
    type Output =
        std::result::Result<crate::output::GetPartitionOutput, crate::error::GetPartitionError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_partition_error(response)
        } else {
            crate::operation_deser::parse_get_partition_response(response)
        }
    }
}

/// <p>Retrieves the partition indexes associated with a table.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetPartitionIndexes {
    _private: (),
}
impl GetPartitionIndexes {
    /// Creates a new builder-style object to manufacture [`GetPartitionIndexesInput`](crate::input::GetPartitionIndexesInput)
    pub fn builder() -> crate::input::get_partition_indexes_input::Builder {
        crate::input::get_partition_indexes_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetPartitionIndexes {
    type Output = std::result::Result<
        crate::output::GetPartitionIndexesOutput,
        crate::error::GetPartitionIndexesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_partition_indexes_error(response)
        } else {
            crate::operation_deser::parse_get_partition_indexes_response(response)
        }
    }
}

/// <p>Retrieves information about the partitions in a table.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetPartitions {
    _private: (),
}
impl GetPartitions {
    /// Creates a new builder-style object to manufacture [`GetPartitionsInput`](crate::input::GetPartitionsInput)
    pub fn builder() -> crate::input::get_partitions_input::Builder {
        crate::input::get_partitions_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetPartitions {
    type Output =
        std::result::Result<crate::output::GetPartitionsOutput, crate::error::GetPartitionsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_partitions_error(response)
        } else {
            crate::operation_deser::parse_get_partitions_response(response)
        }
    }
}

/// <p>Gets code to perform a specified mapping.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetPlan {
    _private: (),
}
impl GetPlan {
    /// Creates a new builder-style object to manufacture [`GetPlanInput`](crate::input::GetPlanInput)
    pub fn builder() -> crate::input::get_plan_input::Builder {
        crate::input::get_plan_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetPlan {
    type Output = std::result::Result<crate::output::GetPlanOutput, crate::error::GetPlanError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_plan_error(response)
        } else {
            crate::operation_deser::parse_get_plan_response(response)
        }
    }
}

/// <p>Describes the specified registry in detail.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetRegistry {
    _private: (),
}
impl GetRegistry {
    /// Creates a new builder-style object to manufacture [`GetRegistryInput`](crate::input::GetRegistryInput)
    pub fn builder() -> crate::input::get_registry_input::Builder {
        crate::input::get_registry_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetRegistry {
    type Output =
        std::result::Result<crate::output::GetRegistryOutput, crate::error::GetRegistryError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_registry_error(response)
        } else {
            crate::operation_deser::parse_get_registry_response(response)
        }
    }
}

/// <p>Retrieves the resource policies set on individual resources by Resource Access Manager
/// during cross-account permission grants. Also retrieves the Data Catalog resource
/// policy.</p>
/// <p>If you enabled metadata encryption in Data Catalog settings, and you do not have
/// permission on the KMS key, the operation can't return the Data Catalog resource
/// policy.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetResourcePolicies {
    _private: (),
}
impl GetResourcePolicies {
    /// Creates a new builder-style object to manufacture [`GetResourcePoliciesInput`](crate::input::GetResourcePoliciesInput)
    pub fn builder() -> crate::input::get_resource_policies_input::Builder {
        crate::input::get_resource_policies_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetResourcePolicies {
    type Output = std::result::Result<
        crate::output::GetResourcePoliciesOutput,
        crate::error::GetResourcePoliciesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_resource_policies_error(response)
        } else {
            crate::operation_deser::parse_get_resource_policies_response(response)
        }
    }
}

/// <p>Retrieves a specified resource policy.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetResourcePolicy {
    _private: (),
}
impl GetResourcePolicy {
    /// Creates a new builder-style object to manufacture [`GetResourcePolicyInput`](crate::input::GetResourcePolicyInput)
    pub fn builder() -> crate::input::get_resource_policy_input::Builder {
        crate::input::get_resource_policy_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetResourcePolicy {
    type Output = std::result::Result<
        crate::output::GetResourcePolicyOutput,
        crate::error::GetResourcePolicyError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_resource_policy_error(response)
        } else {
            crate::operation_deser::parse_get_resource_policy_response(response)
        }
    }
}

/// <p>Describes the specified schema in detail.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetSchema {
    _private: (),
}
impl GetSchema {
    /// Creates a new builder-style object to manufacture [`GetSchemaInput`](crate::input::GetSchemaInput)
    pub fn builder() -> crate::input::get_schema_input::Builder {
        crate::input::get_schema_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetSchema {
    type Output = std::result::Result<crate::output::GetSchemaOutput, crate::error::GetSchemaError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_schema_error(response)
        } else {
            crate::operation_deser::parse_get_schema_response(response)
        }
    }
}

/// <p>Retrieves a schema by the <code>SchemaDefinition</code>. The schema definition is sent to the Schema Registry, canonicalized, and hashed. If the hash is matched within the scope of the <code>SchemaName</code> or ARN (or the default registry, if none is supplied), that schemas metadata is returned. Otherwise, a 404 or NotFound error is returned. Schema versions in <code>Deleted</code> statuses will not be included in the results.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetSchemaByDefinition {
    _private: (),
}
impl GetSchemaByDefinition {
    /// Creates a new builder-style object to manufacture [`GetSchemaByDefinitionInput`](crate::input::GetSchemaByDefinitionInput)
    pub fn builder() -> crate::input::get_schema_by_definition_input::Builder {
        crate::input::get_schema_by_definition_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetSchemaByDefinition {
    type Output = std::result::Result<
        crate::output::GetSchemaByDefinitionOutput,
        crate::error::GetSchemaByDefinitionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_schema_by_definition_error(response)
        } else {
            crate::operation_deser::parse_get_schema_by_definition_response(response)
        }
    }
}

/// <p>Get the specified schema by its unique ID assigned when a version of the schema is created or registered. Schema versions in Deleted status will not be included in the results.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetSchemaVersion {
    _private: (),
}
impl GetSchemaVersion {
    /// Creates a new builder-style object to manufacture [`GetSchemaVersionInput`](crate::input::GetSchemaVersionInput)
    pub fn builder() -> crate::input::get_schema_version_input::Builder {
        crate::input::get_schema_version_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetSchemaVersion {
    type Output = std::result::Result<
        crate::output::GetSchemaVersionOutput,
        crate::error::GetSchemaVersionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_schema_version_error(response)
        } else {
            crate::operation_deser::parse_get_schema_version_response(response)
        }
    }
}

/// <p>Fetches the schema version difference in the specified difference type between two stored schema versions in the Schema Registry.</p>
/// <p>This API allows you to compare two schema versions between two schema definitions under the same schema.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetSchemaVersionsDiff {
    _private: (),
}
impl GetSchemaVersionsDiff {
    /// Creates a new builder-style object to manufacture [`GetSchemaVersionsDiffInput`](crate::input::GetSchemaVersionsDiffInput)
    pub fn builder() -> crate::input::get_schema_versions_diff_input::Builder {
        crate::input::get_schema_versions_diff_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetSchemaVersionsDiff {
    type Output = std::result::Result<
        crate::output::GetSchemaVersionsDiffOutput,
        crate::error::GetSchemaVersionsDiffError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_schema_versions_diff_error(response)
        } else {
            crate::operation_deser::parse_get_schema_versions_diff_response(response)
        }
    }
}

/// <p>Retrieves a specified security configuration.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetSecurityConfiguration {
    _private: (),
}
impl GetSecurityConfiguration {
    /// Creates a new builder-style object to manufacture [`GetSecurityConfigurationInput`](crate::input::GetSecurityConfigurationInput)
    pub fn builder() -> crate::input::get_security_configuration_input::Builder {
        crate::input::get_security_configuration_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetSecurityConfiguration {
    type Output = std::result::Result<
        crate::output::GetSecurityConfigurationOutput,
        crate::error::GetSecurityConfigurationError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_security_configuration_error(response)
        } else {
            crate::operation_deser::parse_get_security_configuration_response(response)
        }
    }
}

/// <p>Retrieves a list of all security configurations.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetSecurityConfigurations {
    _private: (),
}
impl GetSecurityConfigurations {
    /// Creates a new builder-style object to manufacture [`GetSecurityConfigurationsInput`](crate::input::GetSecurityConfigurationsInput)
    pub fn builder() -> crate::input::get_security_configurations_input::Builder {
        crate::input::get_security_configurations_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetSecurityConfigurations {
    type Output = std::result::Result<
        crate::output::GetSecurityConfigurationsOutput,
        crate::error::GetSecurityConfigurationsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_security_configurations_error(response)
        } else {
            crate::operation_deser::parse_get_security_configurations_response(response)
        }
    }
}

/// <p>Retrieves the <code>Table</code> definition in a Data Catalog for
/// a specified table.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetTable {
    _private: (),
}
impl GetTable {
    /// Creates a new builder-style object to manufacture [`GetTableInput`](crate::input::GetTableInput)
    pub fn builder() -> crate::input::get_table_input::Builder {
        crate::input::get_table_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetTable {
    type Output = std::result::Result<crate::output::GetTableOutput, crate::error::GetTableError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_table_error(response)
        } else {
            crate::operation_deser::parse_get_table_response(response)
        }
    }
}

/// <p>Retrieves the definitions of some or all of the tables in a given
/// <code>Database</code>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetTables {
    _private: (),
}
impl GetTables {
    /// Creates a new builder-style object to manufacture [`GetTablesInput`](crate::input::GetTablesInput)
    pub fn builder() -> crate::input::get_tables_input::Builder {
        crate::input::get_tables_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetTables {
    type Output = std::result::Result<crate::output::GetTablesOutput, crate::error::GetTablesError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_tables_error(response)
        } else {
            crate::operation_deser::parse_get_tables_response(response)
        }
    }
}

/// <p>Retrieves a specified version of a table.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetTableVersion {
    _private: (),
}
impl GetTableVersion {
    /// Creates a new builder-style object to manufacture [`GetTableVersionInput`](crate::input::GetTableVersionInput)
    pub fn builder() -> crate::input::get_table_version_input::Builder {
        crate::input::get_table_version_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetTableVersion {
    type Output = std::result::Result<
        crate::output::GetTableVersionOutput,
        crate::error::GetTableVersionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_table_version_error(response)
        } else {
            crate::operation_deser::parse_get_table_version_response(response)
        }
    }
}

/// <p>Retrieves a list of strings that identify available versions of
/// a specified table.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetTableVersions {
    _private: (),
}
impl GetTableVersions {
    /// Creates a new builder-style object to manufacture [`GetTableVersionsInput`](crate::input::GetTableVersionsInput)
    pub fn builder() -> crate::input::get_table_versions_input::Builder {
        crate::input::get_table_versions_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetTableVersions {
    type Output = std::result::Result<
        crate::output::GetTableVersionsOutput,
        crate::error::GetTableVersionsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_table_versions_error(response)
        } else {
            crate::operation_deser::parse_get_table_versions_response(response)
        }
    }
}

/// <p>Retrieves a list of tags associated with a resource.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetTags {
    _private: (),
}
impl GetTags {
    /// Creates a new builder-style object to manufacture [`GetTagsInput`](crate::input::GetTagsInput)
    pub fn builder() -> crate::input::get_tags_input::Builder {
        crate::input::get_tags_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetTags {
    type Output = std::result::Result<crate::output::GetTagsOutput, crate::error::GetTagsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_tags_error(response)
        } else {
            crate::operation_deser::parse_get_tags_response(response)
        }
    }
}

/// <p>Retrieves the definition of a trigger.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetTrigger {
    _private: (),
}
impl GetTrigger {
    /// Creates a new builder-style object to manufacture [`GetTriggerInput`](crate::input::GetTriggerInput)
    pub fn builder() -> crate::input::get_trigger_input::Builder {
        crate::input::get_trigger_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetTrigger {
    type Output =
        std::result::Result<crate::output::GetTriggerOutput, crate::error::GetTriggerError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_trigger_error(response)
        } else {
            crate::operation_deser::parse_get_trigger_response(response)
        }
    }
}

/// <p>Gets all the triggers associated with a job.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetTriggers {
    _private: (),
}
impl GetTriggers {
    /// Creates a new builder-style object to manufacture [`GetTriggersInput`](crate::input::GetTriggersInput)
    pub fn builder() -> crate::input::get_triggers_input::Builder {
        crate::input::get_triggers_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetTriggers {
    type Output =
        std::result::Result<crate::output::GetTriggersOutput, crate::error::GetTriggersError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_triggers_error(response)
        } else {
            crate::operation_deser::parse_get_triggers_response(response)
        }
    }
}

/// <p>Retrieves a specified function definition from the Data Catalog.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetUserDefinedFunction {
    _private: (),
}
impl GetUserDefinedFunction {
    /// Creates a new builder-style object to manufacture [`GetUserDefinedFunctionInput`](crate::input::GetUserDefinedFunctionInput)
    pub fn builder() -> crate::input::get_user_defined_function_input::Builder {
        crate::input::get_user_defined_function_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetUserDefinedFunction {
    type Output = std::result::Result<
        crate::output::GetUserDefinedFunctionOutput,
        crate::error::GetUserDefinedFunctionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_user_defined_function_error(response)
        } else {
            crate::operation_deser::parse_get_user_defined_function_response(response)
        }
    }
}

/// <p>Retrieves multiple function definitions from the Data Catalog.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetUserDefinedFunctions {
    _private: (),
}
impl GetUserDefinedFunctions {
    /// Creates a new builder-style object to manufacture [`GetUserDefinedFunctionsInput`](crate::input::GetUserDefinedFunctionsInput)
    pub fn builder() -> crate::input::get_user_defined_functions_input::Builder {
        crate::input::get_user_defined_functions_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetUserDefinedFunctions {
    type Output = std::result::Result<
        crate::output::GetUserDefinedFunctionsOutput,
        crate::error::GetUserDefinedFunctionsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_user_defined_functions_error(response)
        } else {
            crate::operation_deser::parse_get_user_defined_functions_response(response)
        }
    }
}

/// <p>Retrieves resource metadata for a workflow.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetWorkflow {
    _private: (),
}
impl GetWorkflow {
    /// Creates a new builder-style object to manufacture [`GetWorkflowInput`](crate::input::GetWorkflowInput)
    pub fn builder() -> crate::input::get_workflow_input::Builder {
        crate::input::get_workflow_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetWorkflow {
    type Output =
        std::result::Result<crate::output::GetWorkflowOutput, crate::error::GetWorkflowError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_workflow_error(response)
        } else {
            crate::operation_deser::parse_get_workflow_response(response)
        }
    }
}

/// <p>Retrieves the metadata for a given workflow run. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetWorkflowRun {
    _private: (),
}
impl GetWorkflowRun {
    /// Creates a new builder-style object to manufacture [`GetWorkflowRunInput`](crate::input::GetWorkflowRunInput)
    pub fn builder() -> crate::input::get_workflow_run_input::Builder {
        crate::input::get_workflow_run_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetWorkflowRun {
    type Output =
        std::result::Result<crate::output::GetWorkflowRunOutput, crate::error::GetWorkflowRunError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_workflow_run_error(response)
        } else {
            crate::operation_deser::parse_get_workflow_run_response(response)
        }
    }
}

/// <p>Retrieves the workflow run properties which were set during the run.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetWorkflowRunProperties {
    _private: (),
}
impl GetWorkflowRunProperties {
    /// Creates a new builder-style object to manufacture [`GetWorkflowRunPropertiesInput`](crate::input::GetWorkflowRunPropertiesInput)
    pub fn builder() -> crate::input::get_workflow_run_properties_input::Builder {
        crate::input::get_workflow_run_properties_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetWorkflowRunProperties {
    type Output = std::result::Result<
        crate::output::GetWorkflowRunPropertiesOutput,
        crate::error::GetWorkflowRunPropertiesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_workflow_run_properties_error(response)
        } else {
            crate::operation_deser::parse_get_workflow_run_properties_response(response)
        }
    }
}

/// <p>Retrieves metadata for all runs of a given workflow.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetWorkflowRuns {
    _private: (),
}
impl GetWorkflowRuns {
    /// Creates a new builder-style object to manufacture [`GetWorkflowRunsInput`](crate::input::GetWorkflowRunsInput)
    pub fn builder() -> crate::input::get_workflow_runs_input::Builder {
        crate::input::get_workflow_runs_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetWorkflowRuns {
    type Output = std::result::Result<
        crate::output::GetWorkflowRunsOutput,
        crate::error::GetWorkflowRunsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_workflow_runs_error(response)
        } else {
            crate::operation_deser::parse_get_workflow_runs_response(response)
        }
    }
}

/// <p>Imports an existing Amazon Athena Data Catalog to Glue.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ImportCatalogToGlue {
    _private: (),
}
impl ImportCatalogToGlue {
    /// Creates a new builder-style object to manufacture [`ImportCatalogToGlueInput`](crate::input::ImportCatalogToGlueInput)
    pub fn builder() -> crate::input::import_catalog_to_glue_input::Builder {
        crate::input::import_catalog_to_glue_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ImportCatalogToGlue {
    type Output = std::result::Result<
        crate::output::ImportCatalogToGlueOutput,
        crate::error::ImportCatalogToGlueError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_import_catalog_to_glue_error(response)
        } else {
            crate::operation_deser::parse_import_catalog_to_glue_response(response)
        }
    }
}

/// <p>Retrieves the names of all crawler resources in this Amazon Web Services account, or the
/// resources with the specified tag. This operation allows you to see which
/// resources are available in your account, and their names.</p>
/// <p>This operation takes the optional <code>Tags</code> field, which you can use as a filter on
/// the response so that tagged resources can be retrieved as a group. If you choose to use tags
/// filtering, only resources with the tag are retrieved.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListCrawlers {
    _private: (),
}
impl ListCrawlers {
    /// Creates a new builder-style object to manufacture [`ListCrawlersInput`](crate::input::ListCrawlersInput)
    pub fn builder() -> crate::input::list_crawlers_input::Builder {
        crate::input::list_crawlers_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListCrawlers {
    type Output =
        std::result::Result<crate::output::ListCrawlersOutput, crate::error::ListCrawlersError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_crawlers_error(response)
        } else {
            crate::operation_deser::parse_list_crawlers_response(response)
        }
    }
}

/// <p>Retrieves the names of all <code>DevEndpoint</code> resources in this Amazon Web Services account, or the
/// resources with the specified tag. This operation allows you to see which resources are
/// available in your account, and their names.</p>
/// <p>This operation takes the optional <code>Tags</code> field, which you can use as a filter on
/// the response so that tagged resources can be retrieved as a group. If you choose to use tags
/// filtering, only resources with the tag are retrieved.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListDevEndpoints {
    _private: (),
}
impl ListDevEndpoints {
    /// Creates a new builder-style object to manufacture [`ListDevEndpointsInput`](crate::input::ListDevEndpointsInput)
    pub fn builder() -> crate::input::list_dev_endpoints_input::Builder {
        crate::input::list_dev_endpoints_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListDevEndpoints {
    type Output = std::result::Result<
        crate::output::ListDevEndpointsOutput,
        crate::error::ListDevEndpointsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_dev_endpoints_error(response)
        } else {
            crate::operation_deser::parse_list_dev_endpoints_response(response)
        }
    }
}

/// <p>Retrieves the names of all job resources in this Amazon Web Services account, or the resources with the specified tag. This operation allows you to see which resources are available in your account, and their names.</p>
/// <p>This operation takes the optional <code>Tags</code> field, which you can use as a filter on
/// the response so that tagged resources can be retrieved as a group. If you choose to use tags
/// filtering, only resources with the tag are retrieved.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListJobs {
    _private: (),
}
impl ListJobs {
    /// Creates a new builder-style object to manufacture [`ListJobsInput`](crate::input::ListJobsInput)
    pub fn builder() -> crate::input::list_jobs_input::Builder {
        crate::input::list_jobs_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListJobs {
    type Output = std::result::Result<crate::output::ListJobsOutput, crate::error::ListJobsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_jobs_error(response)
        } else {
            crate::operation_deser::parse_list_jobs_response(response)
        }
    }
}

/// <p> Retrieves a sortable, filterable list of existing Glue machine learning transforms in this Amazon Web Services account,
/// or the resources with the specified tag. This operation takes the optional <code>Tags</code> field, which you can use as
/// a filter of the responses so that tagged resources can be retrieved as a group. If you choose to use tag
/// filtering, only resources with the tags are retrieved.
/// </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListMLTransforms {
    _private: (),
}
impl ListMLTransforms {
    /// Creates a new builder-style object to manufacture [`ListMlTransformsInput`](crate::input::ListMlTransformsInput)
    pub fn builder() -> crate::input::list_ml_transforms_input::Builder {
        crate::input::list_ml_transforms_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListMLTransforms {
    type Output = std::result::Result<
        crate::output::ListMlTransformsOutput,
        crate::error::ListMLTransformsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_ml_transforms_error(response)
        } else {
            crate::operation_deser::parse_list_ml_transforms_response(response)
        }
    }
}

/// <p>Returns a list of registries that you have created, with minimal registry information. Registries in the <code>Deleting</code> status will not be included in the results. Empty results will be returned if there are no registries available.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListRegistries {
    _private: (),
}
impl ListRegistries {
    /// Creates a new builder-style object to manufacture [`ListRegistriesInput`](crate::input::ListRegistriesInput)
    pub fn builder() -> crate::input::list_registries_input::Builder {
        crate::input::list_registries_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListRegistries {
    type Output =
        std::result::Result<crate::output::ListRegistriesOutput, crate::error::ListRegistriesError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_registries_error(response)
        } else {
            crate::operation_deser::parse_list_registries_response(response)
        }
    }
}

/// <p>Returns a list of schemas with minimal details. Schemas in Deleting status will not be included in the results. Empty results will be returned if there are no schemas available.</p>
/// <p>When the <code>RegistryId</code> is not provided, all the schemas across registries will be part of the API response.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListSchemas {
    _private: (),
}
impl ListSchemas {
    /// Creates a new builder-style object to manufacture [`ListSchemasInput`](crate::input::ListSchemasInput)
    pub fn builder() -> crate::input::list_schemas_input::Builder {
        crate::input::list_schemas_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListSchemas {
    type Output =
        std::result::Result<crate::output::ListSchemasOutput, crate::error::ListSchemasError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_schemas_error(response)
        } else {
            crate::operation_deser::parse_list_schemas_response(response)
        }
    }
}

/// <p>Returns a list of schema versions that you have created, with minimal information. Schema versions in Deleted status will not be included in the results. Empty results will be returned if there are no schema versions available.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListSchemaVersions {
    _private: (),
}
impl ListSchemaVersions {
    /// Creates a new builder-style object to manufacture [`ListSchemaVersionsInput`](crate::input::ListSchemaVersionsInput)
    pub fn builder() -> crate::input::list_schema_versions_input::Builder {
        crate::input::list_schema_versions_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListSchemaVersions {
    type Output = std::result::Result<
        crate::output::ListSchemaVersionsOutput,
        crate::error::ListSchemaVersionsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_schema_versions_error(response)
        } else {
            crate::operation_deser::parse_list_schema_versions_response(response)
        }
    }
}

/// <p>Retrieves the names of all trigger resources in this Amazon Web Services account, or the resources with the specified tag. This operation allows you to see which resources are available in your account, and their names.</p>
/// <p>This operation takes the optional <code>Tags</code> field, which you can use as a filter on
/// the response so that tagged resources can be retrieved as a group. If you choose to use tags
/// filtering, only resources with the tag are retrieved.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListTriggers {
    _private: (),
}
impl ListTriggers {
    /// Creates a new builder-style object to manufacture [`ListTriggersInput`](crate::input::ListTriggersInput)
    pub fn builder() -> crate::input::list_triggers_input::Builder {
        crate::input::list_triggers_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListTriggers {
    type Output =
        std::result::Result<crate::output::ListTriggersOutput, crate::error::ListTriggersError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_triggers_error(response)
        } else {
            crate::operation_deser::parse_list_triggers_response(response)
        }
    }
}

/// <p>Lists names of workflows created in the account.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListWorkflows {
    _private: (),
}
impl ListWorkflows {
    /// Creates a new builder-style object to manufacture [`ListWorkflowsInput`](crate::input::ListWorkflowsInput)
    pub fn builder() -> crate::input::list_workflows_input::Builder {
        crate::input::list_workflows_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListWorkflows {
    type Output =
        std::result::Result<crate::output::ListWorkflowsOutput, crate::error::ListWorkflowsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_workflows_error(response)
        } else {
            crate::operation_deser::parse_list_workflows_response(response)
        }
    }
}

/// <p>Sets the security configuration for a specified catalog. After the configuration has been
/// set, the specified encryption is applied to every catalog write thereafter.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PutDataCatalogEncryptionSettings {
    _private: (),
}
impl PutDataCatalogEncryptionSettings {
    /// Creates a new builder-style object to manufacture [`PutDataCatalogEncryptionSettingsInput`](crate::input::PutDataCatalogEncryptionSettingsInput)
    pub fn builder() -> crate::input::put_data_catalog_encryption_settings_input::Builder {
        crate::input::put_data_catalog_encryption_settings_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PutDataCatalogEncryptionSettings {
    type Output = std::result::Result<
        crate::output::PutDataCatalogEncryptionSettingsOutput,
        crate::error::PutDataCatalogEncryptionSettingsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_put_data_catalog_encryption_settings_error(response)
        } else {
            crate::operation_deser::parse_put_data_catalog_encryption_settings_response(response)
        }
    }
}

/// <p>Sets the Data Catalog resource policy for access control.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PutResourcePolicy {
    _private: (),
}
impl PutResourcePolicy {
    /// Creates a new builder-style object to manufacture [`PutResourcePolicyInput`](crate::input::PutResourcePolicyInput)
    pub fn builder() -> crate::input::put_resource_policy_input::Builder {
        crate::input::put_resource_policy_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PutResourcePolicy {
    type Output = std::result::Result<
        crate::output::PutResourcePolicyOutput,
        crate::error::PutResourcePolicyError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_put_resource_policy_error(response)
        } else {
            crate::operation_deser::parse_put_resource_policy_response(response)
        }
    }
}

/// <p>Puts the metadata key value pair for a specified schema version ID. A maximum of 10 key value pairs will be allowed per schema version. They can be added over one or more calls.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PutSchemaVersionMetadata {
    _private: (),
}
impl PutSchemaVersionMetadata {
    /// Creates a new builder-style object to manufacture [`PutSchemaVersionMetadataInput`](crate::input::PutSchemaVersionMetadataInput)
    pub fn builder() -> crate::input::put_schema_version_metadata_input::Builder {
        crate::input::put_schema_version_metadata_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PutSchemaVersionMetadata {
    type Output = std::result::Result<
        crate::output::PutSchemaVersionMetadataOutput,
        crate::error::PutSchemaVersionMetadataError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_put_schema_version_metadata_error(response)
        } else {
            crate::operation_deser::parse_put_schema_version_metadata_response(response)
        }
    }
}

/// <p>Puts the specified workflow run properties for the given workflow run. If a property already exists for the specified run, then it overrides the value otherwise adds the property to existing properties.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PutWorkflowRunProperties {
    _private: (),
}
impl PutWorkflowRunProperties {
    /// Creates a new builder-style object to manufacture [`PutWorkflowRunPropertiesInput`](crate::input::PutWorkflowRunPropertiesInput)
    pub fn builder() -> crate::input::put_workflow_run_properties_input::Builder {
        crate::input::put_workflow_run_properties_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PutWorkflowRunProperties {
    type Output = std::result::Result<
        crate::output::PutWorkflowRunPropertiesOutput,
        crate::error::PutWorkflowRunPropertiesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_put_workflow_run_properties_error(response)
        } else {
            crate::operation_deser::parse_put_workflow_run_properties_response(response)
        }
    }
}

/// <p>Queries for the schema version metadata information. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct QuerySchemaVersionMetadata {
    _private: (),
}
impl QuerySchemaVersionMetadata {
    /// Creates a new builder-style object to manufacture [`QuerySchemaVersionMetadataInput`](crate::input::QuerySchemaVersionMetadataInput)
    pub fn builder() -> crate::input::query_schema_version_metadata_input::Builder {
        crate::input::query_schema_version_metadata_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for QuerySchemaVersionMetadata {
    type Output = std::result::Result<
        crate::output::QuerySchemaVersionMetadataOutput,
        crate::error::QuerySchemaVersionMetadataError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_query_schema_version_metadata_error(response)
        } else {
            crate::operation_deser::parse_query_schema_version_metadata_response(response)
        }
    }
}

/// <p>Adds a new version to the existing schema. Returns an error if new version of schema does not meet the compatibility requirements of the schema set. This API will not create a new schema set and will return a 404 error if the schema set is not already present in the Schema Registry.</p>
/// <p>If this is the first schema definition to be registered in the Schema Registry, this API will store the schema version and return immediately. Otherwise, this call has the potential to run longer than other operations due to compatibility modes. You can call the <code>GetSchemaVersion</code> API with the <code>SchemaVersionId</code> to check compatibility modes.</p>
/// <p>If the same schema definition is already stored in Schema Registry as a version, the schema ID of the existing schema is returned to the caller.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct RegisterSchemaVersion {
    _private: (),
}
impl RegisterSchemaVersion {
    /// Creates a new builder-style object to manufacture [`RegisterSchemaVersionInput`](crate::input::RegisterSchemaVersionInput)
    pub fn builder() -> crate::input::register_schema_version_input::Builder {
        crate::input::register_schema_version_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for RegisterSchemaVersion {
    type Output = std::result::Result<
        crate::output::RegisterSchemaVersionOutput,
        crate::error::RegisterSchemaVersionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_register_schema_version_error(response)
        } else {
            crate::operation_deser::parse_register_schema_version_response(response)
        }
    }
}

/// <p>Removes a key value pair from the schema version metadata for the specified schema version ID.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct RemoveSchemaVersionMetadata {
    _private: (),
}
impl RemoveSchemaVersionMetadata {
    /// Creates a new builder-style object to manufacture [`RemoveSchemaVersionMetadataInput`](crate::input::RemoveSchemaVersionMetadataInput)
    pub fn builder() -> crate::input::remove_schema_version_metadata_input::Builder {
        crate::input::remove_schema_version_metadata_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for RemoveSchemaVersionMetadata {
    type Output = std::result::Result<
        crate::output::RemoveSchemaVersionMetadataOutput,
        crate::error::RemoveSchemaVersionMetadataError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_remove_schema_version_metadata_error(response)
        } else {
            crate::operation_deser::parse_remove_schema_version_metadata_response(response)
        }
    }
}

/// <p>Resets a bookmark entry.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ResetJobBookmark {
    _private: (),
}
impl ResetJobBookmark {
    /// Creates a new builder-style object to manufacture [`ResetJobBookmarkInput`](crate::input::ResetJobBookmarkInput)
    pub fn builder() -> crate::input::reset_job_bookmark_input::Builder {
        crate::input::reset_job_bookmark_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ResetJobBookmark {
    type Output = std::result::Result<
        crate::output::ResetJobBookmarkOutput,
        crate::error::ResetJobBookmarkError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_reset_job_bookmark_error(response)
        } else {
            crate::operation_deser::parse_reset_job_bookmark_response(response)
        }
    }
}

/// <p>Restarts selected nodes of a previous partially completed workflow run and resumes the workflow run. The selected nodes and all nodes that are downstream from the selected nodes are run.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ResumeWorkflowRun {
    _private: (),
}
impl ResumeWorkflowRun {
    /// Creates a new builder-style object to manufacture [`ResumeWorkflowRunInput`](crate::input::ResumeWorkflowRunInput)
    pub fn builder() -> crate::input::resume_workflow_run_input::Builder {
        crate::input::resume_workflow_run_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ResumeWorkflowRun {
    type Output = std::result::Result<
        crate::output::ResumeWorkflowRunOutput,
        crate::error::ResumeWorkflowRunError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_resume_workflow_run_error(response)
        } else {
            crate::operation_deser::parse_resume_workflow_run_response(response)
        }
    }
}

/// <p>Searches a set of tables based on properties in the table metadata as well as on the parent database. You can search against text or filter conditions. </p>
/// <p>You can only get tables that you have access to based on the security policies defined in Lake Formation. You need at least a read-only access to the table for it to be returned. If you do not have access to all the columns in the table, these columns will not be searched against when returning the list of tables back to you. If you have access to the columns but not the data in the columns, those columns and the associated metadata for those columns will be included in the search. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct SearchTables {
    _private: (),
}
impl SearchTables {
    /// Creates a new builder-style object to manufacture [`SearchTablesInput`](crate::input::SearchTablesInput)
    pub fn builder() -> crate::input::search_tables_input::Builder {
        crate::input::search_tables_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for SearchTables {
    type Output =
        std::result::Result<crate::output::SearchTablesOutput, crate::error::SearchTablesError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_search_tables_error(response)
        } else {
            crate::operation_deser::parse_search_tables_response(response)
        }
    }
}

/// <p>Starts a crawl using the specified crawler, regardless
/// of what is scheduled. If the crawler is already running, returns a
/// <a href="https://docs.aws.amazon.com/glue/latest/dg/aws-glue-api-exceptions.html#aws-glue-api-exceptions-CrawlerRunningException">CrawlerRunningException</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct StartCrawler {
    _private: (),
}
impl StartCrawler {
    /// Creates a new builder-style object to manufacture [`StartCrawlerInput`](crate::input::StartCrawlerInput)
    pub fn builder() -> crate::input::start_crawler_input::Builder {
        crate::input::start_crawler_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for StartCrawler {
    type Output =
        std::result::Result<crate::output::StartCrawlerOutput, crate::error::StartCrawlerError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_start_crawler_error(response)
        } else {
            crate::operation_deser::parse_start_crawler_response(response)
        }
    }
}

/// <p>Changes the schedule state of the specified crawler to
/// <code>SCHEDULED</code>, unless the crawler is already running or the
/// schedule state is already <code>SCHEDULED</code>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct StartCrawlerSchedule {
    _private: (),
}
impl StartCrawlerSchedule {
    /// Creates a new builder-style object to manufacture [`StartCrawlerScheduleInput`](crate::input::StartCrawlerScheduleInput)
    pub fn builder() -> crate::input::start_crawler_schedule_input::Builder {
        crate::input::start_crawler_schedule_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for StartCrawlerSchedule {
    type Output = std::result::Result<
        crate::output::StartCrawlerScheduleOutput,
        crate::error::StartCrawlerScheduleError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_start_crawler_schedule_error(response)
        } else {
            crate::operation_deser::parse_start_crawler_schedule_response(response)
        }
    }
}

/// <p>Begins an asynchronous task to export all labeled data for a particular transform. This
/// task is the only label-related API call that is not part of the typical active learning
/// workflow. You typically use <code>StartExportLabelsTaskRun</code> when you want to work with
/// all of your existing labels at the same time, such as when you want to remove or change labels
/// that were previously submitted as truth. This API operation accepts the
/// <code>TransformId</code> whose labels you want to export and an Amazon Simple Storage
/// Service (Amazon S3) path to export the labels to. The operation returns a
/// <code>TaskRunId</code>. You can check on the status of your task run by calling the
/// <code>GetMLTaskRun</code> API.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct StartExportLabelsTaskRun {
    _private: (),
}
impl StartExportLabelsTaskRun {
    /// Creates a new builder-style object to manufacture [`StartExportLabelsTaskRunInput`](crate::input::StartExportLabelsTaskRunInput)
    pub fn builder() -> crate::input::start_export_labels_task_run_input::Builder {
        crate::input::start_export_labels_task_run_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for StartExportLabelsTaskRun {
    type Output = std::result::Result<
        crate::output::StartExportLabelsTaskRunOutput,
        crate::error::StartExportLabelsTaskRunError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_start_export_labels_task_run_error(response)
        } else {
            crate::operation_deser::parse_start_export_labels_task_run_response(response)
        }
    }
}

/// <p>Enables you to provide additional labels (examples of truth) to be used to teach the
/// machine learning transform and improve its quality. This API operation is generally used as
/// part of the active learning workflow that starts with the
/// <code>StartMLLabelingSetGenerationTaskRun</code> call and that ultimately results in
/// improving the quality of your machine learning transform. </p>
/// <p>After the <code>StartMLLabelingSetGenerationTaskRun</code> finishes, Glue machine learning
/// will have generated a series of questions for humans to answer. (Answering these questions is
/// often called 'labeling' in the machine learning workflows). In the case of the
/// <code>FindMatches</code> transform, these questions are of the form, What is the correct
/// way to group these rows together into groups composed entirely of matching records? After the
/// labeling process is finished, users upload their answers/labels with a call to
/// <code>StartImportLabelsTaskRun</code>. After <code>StartImportLabelsTaskRun</code> finishes,
/// all future runs of the machine learning transform use the new and improved labels and perform
/// a higher-quality transformation.</p>
/// <p>By default, <code>StartMLLabelingSetGenerationTaskRun</code> continually learns from and
/// combines all labels that you upload unless you set <code>Replace</code> to true. If you set
/// <code>Replace</code> to true, <code>StartImportLabelsTaskRun</code> deletes and forgets all
/// previously uploaded labels and learns only from the exact set that you upload. Replacing
/// labels can be helpful if you realize that you previously uploaded incorrect labels, and you
/// believe that they are having a negative effect on your transform quality.</p>
/// <p>You can check on the status of your task run by calling the <code>GetMLTaskRun</code>
/// operation. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct StartImportLabelsTaskRun {
    _private: (),
}
impl StartImportLabelsTaskRun {
    /// Creates a new builder-style object to manufacture [`StartImportLabelsTaskRunInput`](crate::input::StartImportLabelsTaskRunInput)
    pub fn builder() -> crate::input::start_import_labels_task_run_input::Builder {
        crate::input::start_import_labels_task_run_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for StartImportLabelsTaskRun {
    type Output = std::result::Result<
        crate::output::StartImportLabelsTaskRunOutput,
        crate::error::StartImportLabelsTaskRunError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_start_import_labels_task_run_error(response)
        } else {
            crate::operation_deser::parse_start_import_labels_task_run_response(response)
        }
    }
}

/// <p>Starts a job run using a job definition.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct StartJobRun {
    _private: (),
}
impl StartJobRun {
    /// Creates a new builder-style object to manufacture [`StartJobRunInput`](crate::input::StartJobRunInput)
    pub fn builder() -> crate::input::start_job_run_input::Builder {
        crate::input::start_job_run_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for StartJobRun {
    type Output =
        std::result::Result<crate::output::StartJobRunOutput, crate::error::StartJobRunError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_start_job_run_error(response)
        } else {
            crate::operation_deser::parse_start_job_run_response(response)
        }
    }
}

/// <p>Starts a task to estimate the quality of the transform. </p>
/// <p>When you provide label sets as examples of truth, Glue machine learning uses some of
/// those examples to learn from them. The rest of the labels are used as a test to estimate
/// quality.</p>
/// <p>Returns a unique identifier for the run. You can call <code>GetMLTaskRun</code> to get more
/// information about the stats of the <code>EvaluationTaskRun</code>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct StartMLEvaluationTaskRun {
    _private: (),
}
impl StartMLEvaluationTaskRun {
    /// Creates a new builder-style object to manufacture [`StartMlEvaluationTaskRunInput`](crate::input::StartMlEvaluationTaskRunInput)
    pub fn builder() -> crate::input::start_ml_evaluation_task_run_input::Builder {
        crate::input::start_ml_evaluation_task_run_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for StartMLEvaluationTaskRun {
    type Output = std::result::Result<
        crate::output::StartMlEvaluationTaskRunOutput,
        crate::error::StartMLEvaluationTaskRunError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_start_ml_evaluation_task_run_error(response)
        } else {
            crate::operation_deser::parse_start_ml_evaluation_task_run_response(response)
        }
    }
}

/// <p>Starts the active learning workflow for your machine learning transform to improve the
/// transform's quality by generating label sets and adding labels.</p>
/// <p>When the <code>StartMLLabelingSetGenerationTaskRun</code> finishes, Glue will have
/// generated a "labeling set" or a set of questions for humans to answer.</p>
/// <p>In the case of the <code>FindMatches</code> transform, these questions are of the form,
/// What is the correct way to group these rows together into groups composed entirely of
/// matching records? </p>
/// <p>After the labeling process is finished, you can upload your labels with a call to
/// <code>StartImportLabelsTaskRun</code>. After <code>StartImportLabelsTaskRun</code> finishes,
/// all future runs of the machine learning transform will use the new and improved labels and
/// perform a higher-quality transformation.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct StartMLLabelingSetGenerationTaskRun {
    _private: (),
}
impl StartMLLabelingSetGenerationTaskRun {
    /// Creates a new builder-style object to manufacture [`StartMlLabelingSetGenerationTaskRunInput`](crate::input::StartMlLabelingSetGenerationTaskRunInput)
    pub fn builder() -> crate::input::start_ml_labeling_set_generation_task_run_input::Builder {
        crate::input::start_ml_labeling_set_generation_task_run_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for StartMLLabelingSetGenerationTaskRun {
    type Output = std::result::Result<
        crate::output::StartMlLabelingSetGenerationTaskRunOutput,
        crate::error::StartMLLabelingSetGenerationTaskRunError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_start_ml_labeling_set_generation_task_run_error(response)
        } else {
            crate::operation_deser::parse_start_ml_labeling_set_generation_task_run_response(
                response,
            )
        }
    }
}

/// <p>Starts an existing trigger. See <a href="https://docs.aws.amazon.com/glue/latest/dg/trigger-job.html">Triggering
/// Jobs</a> for information about how different types of trigger are
/// started.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct StartTrigger {
    _private: (),
}
impl StartTrigger {
    /// Creates a new builder-style object to manufacture [`StartTriggerInput`](crate::input::StartTriggerInput)
    pub fn builder() -> crate::input::start_trigger_input::Builder {
        crate::input::start_trigger_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for StartTrigger {
    type Output =
        std::result::Result<crate::output::StartTriggerOutput, crate::error::StartTriggerError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_start_trigger_error(response)
        } else {
            crate::operation_deser::parse_start_trigger_response(response)
        }
    }
}

/// <p>Starts a new run of the specified workflow.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct StartWorkflowRun {
    _private: (),
}
impl StartWorkflowRun {
    /// Creates a new builder-style object to manufacture [`StartWorkflowRunInput`](crate::input::StartWorkflowRunInput)
    pub fn builder() -> crate::input::start_workflow_run_input::Builder {
        crate::input::start_workflow_run_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for StartWorkflowRun {
    type Output = std::result::Result<
        crate::output::StartWorkflowRunOutput,
        crate::error::StartWorkflowRunError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_start_workflow_run_error(response)
        } else {
            crate::operation_deser::parse_start_workflow_run_response(response)
        }
    }
}

/// <p>If the specified crawler is running, stops the crawl.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct StopCrawler {
    _private: (),
}
impl StopCrawler {
    /// Creates a new builder-style object to manufacture [`StopCrawlerInput`](crate::input::StopCrawlerInput)
    pub fn builder() -> crate::input::stop_crawler_input::Builder {
        crate::input::stop_crawler_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for StopCrawler {
    type Output =
        std::result::Result<crate::output::StopCrawlerOutput, crate::error::StopCrawlerError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_stop_crawler_error(response)
        } else {
            crate::operation_deser::parse_stop_crawler_response(response)
        }
    }
}

/// <p>Sets the schedule state of the specified crawler to
/// <code>NOT_SCHEDULED</code>, but does not stop the crawler if it is
/// already running.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct StopCrawlerSchedule {
    _private: (),
}
impl StopCrawlerSchedule {
    /// Creates a new builder-style object to manufacture [`StopCrawlerScheduleInput`](crate::input::StopCrawlerScheduleInput)
    pub fn builder() -> crate::input::stop_crawler_schedule_input::Builder {
        crate::input::stop_crawler_schedule_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for StopCrawlerSchedule {
    type Output = std::result::Result<
        crate::output::StopCrawlerScheduleOutput,
        crate::error::StopCrawlerScheduleError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_stop_crawler_schedule_error(response)
        } else {
            crate::operation_deser::parse_stop_crawler_schedule_response(response)
        }
    }
}

/// <p>Stops a specified trigger.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct StopTrigger {
    _private: (),
}
impl StopTrigger {
    /// Creates a new builder-style object to manufacture [`StopTriggerInput`](crate::input::StopTriggerInput)
    pub fn builder() -> crate::input::stop_trigger_input::Builder {
        crate::input::stop_trigger_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for StopTrigger {
    type Output =
        std::result::Result<crate::output::StopTriggerOutput, crate::error::StopTriggerError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_stop_trigger_error(response)
        } else {
            crate::operation_deser::parse_stop_trigger_response(response)
        }
    }
}

/// <p>Stops the execution of the specified workflow run.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct StopWorkflowRun {
    _private: (),
}
impl StopWorkflowRun {
    /// Creates a new builder-style object to manufacture [`StopWorkflowRunInput`](crate::input::StopWorkflowRunInput)
    pub fn builder() -> crate::input::stop_workflow_run_input::Builder {
        crate::input::stop_workflow_run_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for StopWorkflowRun {
    type Output = std::result::Result<
        crate::output::StopWorkflowRunOutput,
        crate::error::StopWorkflowRunError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_stop_workflow_run_error(response)
        } else {
            crate::operation_deser::parse_stop_workflow_run_response(response)
        }
    }
}

/// <p>Adds tags to a resource. A tag is a label you can assign to an Amazon Web Services resource.
/// In Glue, you can tag only certain resources. For information about what
/// resources you can tag, see <a href="https://docs.aws.amazon.com/glue/latest/dg/monitor-tags.html">Amazon Web Services Tags in Glue</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct TagResource {
    _private: (),
}
impl TagResource {
    /// Creates a new builder-style object to manufacture [`TagResourceInput`](crate::input::TagResourceInput)
    pub fn builder() -> crate::input::tag_resource_input::Builder {
        crate::input::tag_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for TagResource {
    type Output =
        std::result::Result<crate::output::TagResourceOutput, crate::error::TagResourceError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_tag_resource_error(response)
        } else {
            crate::operation_deser::parse_tag_resource_response(response)
        }
    }
}

/// <p>Removes tags from a resource.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UntagResource {
    _private: (),
}
impl UntagResource {
    /// Creates a new builder-style object to manufacture [`UntagResourceInput`](crate::input::UntagResourceInput)
    pub fn builder() -> crate::input::untag_resource_input::Builder {
        crate::input::untag_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UntagResource {
    type Output =
        std::result::Result<crate::output::UntagResourceOutput, crate::error::UntagResourceError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_untag_resource_error(response)
        } else {
            crate::operation_deser::parse_untag_resource_response(response)
        }
    }
}

/// <p>Modifies an existing classifier (a <code>GrokClassifier</code>,
/// an <code>XMLClassifier</code>, a <code>JsonClassifier</code>, or a <code>CsvClassifier</code>, depending on
/// which field is present).</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateClassifier {
    _private: (),
}
impl UpdateClassifier {
    /// Creates a new builder-style object to manufacture [`UpdateClassifierInput`](crate::input::UpdateClassifierInput)
    pub fn builder() -> crate::input::update_classifier_input::Builder {
        crate::input::update_classifier_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateClassifier {
    type Output = std::result::Result<
        crate::output::UpdateClassifierOutput,
        crate::error::UpdateClassifierError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_classifier_error(response)
        } else {
            crate::operation_deser::parse_update_classifier_response(response)
        }
    }
}

/// <p>Creates or updates partition statistics of columns.</p>
/// <p>The Identity and Access Management (IAM) permission required for this operation is <code>UpdatePartition</code>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateColumnStatisticsForPartition {
    _private: (),
}
impl UpdateColumnStatisticsForPartition {
    /// Creates a new builder-style object to manufacture [`UpdateColumnStatisticsForPartitionInput`](crate::input::UpdateColumnStatisticsForPartitionInput)
    pub fn builder() -> crate::input::update_column_statistics_for_partition_input::Builder {
        crate::input::update_column_statistics_for_partition_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateColumnStatisticsForPartition {
    type Output = std::result::Result<
        crate::output::UpdateColumnStatisticsForPartitionOutput,
        crate::error::UpdateColumnStatisticsForPartitionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_column_statistics_for_partition_error(response)
        } else {
            crate::operation_deser::parse_update_column_statistics_for_partition_response(response)
        }
    }
}

/// <p>Creates or updates table statistics of columns.</p>
/// <p>The Identity and Access Management (IAM) permission required for this operation is <code>UpdateTable</code>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateColumnStatisticsForTable {
    _private: (),
}
impl UpdateColumnStatisticsForTable {
    /// Creates a new builder-style object to manufacture [`UpdateColumnStatisticsForTableInput`](crate::input::UpdateColumnStatisticsForTableInput)
    pub fn builder() -> crate::input::update_column_statistics_for_table_input::Builder {
        crate::input::update_column_statistics_for_table_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateColumnStatisticsForTable {
    type Output = std::result::Result<
        crate::output::UpdateColumnStatisticsForTableOutput,
        crate::error::UpdateColumnStatisticsForTableError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_column_statistics_for_table_error(response)
        } else {
            crate::operation_deser::parse_update_column_statistics_for_table_response(response)
        }
    }
}

/// <p>Updates a connection definition in the Data Catalog.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateConnection {
    _private: (),
}
impl UpdateConnection {
    /// Creates a new builder-style object to manufacture [`UpdateConnectionInput`](crate::input::UpdateConnectionInput)
    pub fn builder() -> crate::input::update_connection_input::Builder {
        crate::input::update_connection_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateConnection {
    type Output = std::result::Result<
        crate::output::UpdateConnectionOutput,
        crate::error::UpdateConnectionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_connection_error(response)
        } else {
            crate::operation_deser::parse_update_connection_response(response)
        }
    }
}

/// <p>Updates a crawler. If a crawler is
/// running, you must stop it using <code>StopCrawler</code> before updating
/// it.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateCrawler {
    _private: (),
}
impl UpdateCrawler {
    /// Creates a new builder-style object to manufacture [`UpdateCrawlerInput`](crate::input::UpdateCrawlerInput)
    pub fn builder() -> crate::input::update_crawler_input::Builder {
        crate::input::update_crawler_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateCrawler {
    type Output =
        std::result::Result<crate::output::UpdateCrawlerOutput, crate::error::UpdateCrawlerError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_crawler_error(response)
        } else {
            crate::operation_deser::parse_update_crawler_response(response)
        }
    }
}

/// <p>Updates the schedule of a crawler using a <code>cron</code> expression. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateCrawlerSchedule {
    _private: (),
}
impl UpdateCrawlerSchedule {
    /// Creates a new builder-style object to manufacture [`UpdateCrawlerScheduleInput`](crate::input::UpdateCrawlerScheduleInput)
    pub fn builder() -> crate::input::update_crawler_schedule_input::Builder {
        crate::input::update_crawler_schedule_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateCrawlerSchedule {
    type Output = std::result::Result<
        crate::output::UpdateCrawlerScheduleOutput,
        crate::error::UpdateCrawlerScheduleError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_crawler_schedule_error(response)
        } else {
            crate::operation_deser::parse_update_crawler_schedule_response(response)
        }
    }
}

/// <p>Updates an existing database definition in a Data Catalog.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateDatabase {
    _private: (),
}
impl UpdateDatabase {
    /// Creates a new builder-style object to manufacture [`UpdateDatabaseInput`](crate::input::UpdateDatabaseInput)
    pub fn builder() -> crate::input::update_database_input::Builder {
        crate::input::update_database_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateDatabase {
    type Output =
        std::result::Result<crate::output::UpdateDatabaseOutput, crate::error::UpdateDatabaseError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_database_error(response)
        } else {
            crate::operation_deser::parse_update_database_response(response)
        }
    }
}

/// <p>Updates a specified development endpoint.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateDevEndpoint {
    _private: (),
}
impl UpdateDevEndpoint {
    /// Creates a new builder-style object to manufacture [`UpdateDevEndpointInput`](crate::input::UpdateDevEndpointInput)
    pub fn builder() -> crate::input::update_dev_endpoint_input::Builder {
        crate::input::update_dev_endpoint_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateDevEndpoint {
    type Output = std::result::Result<
        crate::output::UpdateDevEndpointOutput,
        crate::error::UpdateDevEndpointError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_dev_endpoint_error(response)
        } else {
            crate::operation_deser::parse_update_dev_endpoint_response(response)
        }
    }
}

/// <p>Updates an existing job definition.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateJob {
    _private: (),
}
impl UpdateJob {
    /// Creates a new builder-style object to manufacture [`UpdateJobInput`](crate::input::UpdateJobInput)
    pub fn builder() -> crate::input::update_job_input::Builder {
        crate::input::update_job_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateJob {
    type Output = std::result::Result<crate::output::UpdateJobOutput, crate::error::UpdateJobError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_job_error(response)
        } else {
            crate::operation_deser::parse_update_job_response(response)
        }
    }
}

/// <p>Updates an existing machine learning transform. Call this operation to tune the algorithm parameters to achieve better results.</p>
/// <p>After calling this operation, you can call the <code>StartMLEvaluationTaskRun</code>
/// operation to assess how well your new parameters achieved your goals (such as improving the
/// quality of your machine learning transform, or making it more cost-effective).</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateMLTransform {
    _private: (),
}
impl UpdateMLTransform {
    /// Creates a new builder-style object to manufacture [`UpdateMlTransformInput`](crate::input::UpdateMlTransformInput)
    pub fn builder() -> crate::input::update_ml_transform_input::Builder {
        crate::input::update_ml_transform_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateMLTransform {
    type Output = std::result::Result<
        crate::output::UpdateMlTransformOutput,
        crate::error::UpdateMLTransformError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_ml_transform_error(response)
        } else {
            crate::operation_deser::parse_update_ml_transform_response(response)
        }
    }
}

/// <p>Updates a partition.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdatePartition {
    _private: (),
}
impl UpdatePartition {
    /// Creates a new builder-style object to manufacture [`UpdatePartitionInput`](crate::input::UpdatePartitionInput)
    pub fn builder() -> crate::input::update_partition_input::Builder {
        crate::input::update_partition_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdatePartition {
    type Output = std::result::Result<
        crate::output::UpdatePartitionOutput,
        crate::error::UpdatePartitionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_partition_error(response)
        } else {
            crate::operation_deser::parse_update_partition_response(response)
        }
    }
}

/// <p>Updates an existing registry which is used to hold a collection of schemas. The updated properties relate to the registry, and do not modify any of the schemas within the registry. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateRegistry {
    _private: (),
}
impl UpdateRegistry {
    /// Creates a new builder-style object to manufacture [`UpdateRegistryInput`](crate::input::UpdateRegistryInput)
    pub fn builder() -> crate::input::update_registry_input::Builder {
        crate::input::update_registry_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateRegistry {
    type Output =
        std::result::Result<crate::output::UpdateRegistryOutput, crate::error::UpdateRegistryError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_registry_error(response)
        } else {
            crate::operation_deser::parse_update_registry_response(response)
        }
    }
}

/// <p>Updates the description, compatibility setting, or version checkpoint for a schema set.</p>
/// <p>For updating the compatibility setting, the call will not validate compatibility for the entire set of schema versions with the new compatibility setting. If the value for <code>Compatibility</code> is provided, the <code>VersionNumber</code> (a checkpoint) is also required. The API will validate the checkpoint version number for consistency.</p>
/// <p>If the value for the <code>VersionNumber</code> (checkpoint) is provided, <code>Compatibility</code> is optional and this can be used to set/reset a checkpoint for the schema.</p>
/// <p>This update will happen only if the schema is in the AVAILABLE state.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateSchema {
    _private: (),
}
impl UpdateSchema {
    /// Creates a new builder-style object to manufacture [`UpdateSchemaInput`](crate::input::UpdateSchemaInput)
    pub fn builder() -> crate::input::update_schema_input::Builder {
        crate::input::update_schema_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateSchema {
    type Output =
        std::result::Result<crate::output::UpdateSchemaOutput, crate::error::UpdateSchemaError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_schema_error(response)
        } else {
            crate::operation_deser::parse_update_schema_response(response)
        }
    }
}

/// <p>Updates a metadata table in the Data Catalog.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateTable {
    _private: (),
}
impl UpdateTable {
    /// Creates a new builder-style object to manufacture [`UpdateTableInput`](crate::input::UpdateTableInput)
    pub fn builder() -> crate::input::update_table_input::Builder {
        crate::input::update_table_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateTable {
    type Output =
        std::result::Result<crate::output::UpdateTableOutput, crate::error::UpdateTableError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_table_error(response)
        } else {
            crate::operation_deser::parse_update_table_response(response)
        }
    }
}

/// <p>Updates a trigger definition.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateTrigger {
    _private: (),
}
impl UpdateTrigger {
    /// Creates a new builder-style object to manufacture [`UpdateTriggerInput`](crate::input::UpdateTriggerInput)
    pub fn builder() -> crate::input::update_trigger_input::Builder {
        crate::input::update_trigger_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateTrigger {
    type Output =
        std::result::Result<crate::output::UpdateTriggerOutput, crate::error::UpdateTriggerError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_trigger_error(response)
        } else {
            crate::operation_deser::parse_update_trigger_response(response)
        }
    }
}

/// <p>Updates an existing function definition in the Data Catalog.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateUserDefinedFunction {
    _private: (),
}
impl UpdateUserDefinedFunction {
    /// Creates a new builder-style object to manufacture [`UpdateUserDefinedFunctionInput`](crate::input::UpdateUserDefinedFunctionInput)
    pub fn builder() -> crate::input::update_user_defined_function_input::Builder {
        crate::input::update_user_defined_function_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateUserDefinedFunction {
    type Output = std::result::Result<
        crate::output::UpdateUserDefinedFunctionOutput,
        crate::error::UpdateUserDefinedFunctionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_user_defined_function_error(response)
        } else {
            crate::operation_deser::parse_update_user_defined_function_response(response)
        }
    }
}

/// <p>Updates an existing workflow.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateWorkflow {
    _private: (),
}
impl UpdateWorkflow {
    /// Creates a new builder-style object to manufacture [`UpdateWorkflowInput`](crate::input::UpdateWorkflowInput)
    pub fn builder() -> crate::input::update_workflow_input::Builder {
        crate::input::update_workflow_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateWorkflow {
    type Output =
        std::result::Result<crate::output::UpdateWorkflowOutput, crate::error::UpdateWorkflowError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_workflow_error(response)
        } else {
            crate::operation_deser::parse_update_workflow_response(response)
        }
    }
}
