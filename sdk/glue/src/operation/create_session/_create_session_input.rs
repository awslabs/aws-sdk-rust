// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Request to create a new session.</p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct CreateSessionInput {
    /// <p>The ID of the session request.</p>
    pub id: ::std::option::Option<::std::string::String>,
    /// <p>The description of the session.</p>
    pub description: ::std::option::Option<::std::string::String>,
    /// <p>The IAM Role ARN</p>
    pub role: ::std::option::Option<::std::string::String>,
    /// <p>The <code>SessionCommand</code> that runs the job.</p>
    pub command: ::std::option::Option<crate::types::SessionCommand>,
    /// <p>The number of minutes before session times out. Default for Spark ETL jobs is 48 hours (2880 minutes), the maximum session lifetime for this job type. Consult the documentation for other job types.</p>
    pub timeout: ::std::option::Option<i32>,
    /// <p>The number of minutes when idle before session times out. Default for Spark ETL jobs is value of Timeout. Consult the documentation for other job types.</p>
    pub idle_timeout: ::std::option::Option<i32>,
    /// <p>A map array of key-value pairs. Max is 75 pairs.</p>
    pub default_arguments: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>,
    /// <p>The number of connections to use for the session.</p>
    pub connections: ::std::option::Option<crate::types::ConnectionsList>,
    /// <p>The number of Glue data processing units (DPUs) that can be allocated when the job runs. A DPU is a relative measure of processing power that consists of 4 vCPUs of compute capacity and 16 GB memory.</p>
    pub max_capacity: ::std::option::Option<f64>,
    /// <p>The number of workers of a defined <code>WorkerType</code> to use for the session.</p>
    pub number_of_workers: ::std::option::Option<i32>,
    /// <p>The type of predefined worker that is allocated when a job runs. Accepts a value of G.1X, G.2X, G.4X, or G.8X for Spark jobs. Accepts the value Z.2X for Ray notebooks.</p>
    /// <ul>
    /// <li>
    /// <p>For the <code>G.1X</code> worker type, each worker maps to 1 DPU (4 vCPUs, 16 GB of memory) with 84GB disk (approximately 34GB free), and provides 1 executor per worker. We recommend this worker type for workloads such as data transforms, joins, and queries, to offers a scalable and cost effective way to run most jobs.</p></li>
    /// <li>
    /// <p>For the <code>G.2X</code> worker type, each worker maps to 2 DPU (8 vCPUs, 32 GB of memory) with 128GB disk (approximately 77GB free), and provides 1 executor per worker. We recommend this worker type for workloads such as data transforms, joins, and queries, to offers a scalable and cost effective way to run most jobs.</p></li>
    /// <li>
    /// <p>For the <code>G.4X</code> worker type, each worker maps to 4 DPU (16 vCPUs, 64 GB of memory) with 256GB disk (approximately 235GB free), and provides 1 executor per worker. We recommend this worker type for jobs whose workloads contain your most demanding transforms, aggregations, joins, and queries. This worker type is available only for Glue version 3.0 or later Spark ETL jobs in the following Amazon Web Services Regions: US East (Ohio), US East (N. Virginia), US West (Oregon), Asia Pacific (Singapore), Asia Pacific (Sydney), Asia Pacific (Tokyo), Canada (Central), Europe (Frankfurt), Europe (Ireland), and Europe (Stockholm).</p></li>
    /// <li>
    /// <p>For the <code>G.8X</code> worker type, each worker maps to 8 DPU (32 vCPUs, 128 GB of memory) with 512GB disk (approximately 487GB free), and provides 1 executor per worker. We recommend this worker type for jobs whose workloads contain your most demanding transforms, aggregations, joins, and queries. This worker type is available only for Glue version 3.0 or later Spark ETL jobs, in the same Amazon Web Services Regions as supported for the <code>G.4X</code> worker type.</p></li>
    /// <li>
    /// <p>For the <code>Z.2X</code> worker type, each worker maps to 2 M-DPU (8vCPUs, 64 GB of memory) with 128 GB disk (approximately 120GB free), and provides up to 8 Ray workers based on the autoscaler.</p></li>
    /// </ul>
    pub worker_type: ::std::option::Option<crate::types::WorkerType>,
    /// <p>The name of the SecurityConfiguration structure to be used with the session</p>
    pub security_configuration: ::std::option::Option<::std::string::String>,
    /// <p>The Glue version determines the versions of Apache Spark and Python that Glue supports. The GlueVersion must be greater than 2.0.</p>
    pub glue_version: ::std::option::Option<::std::string::String>,
    /// <p>The map of key value pairs (tags) belonging to the session.</p>
    pub tags: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>,
    /// <p>The origin of the request.</p>
    pub request_origin: ::std::option::Option<::std::string::String>,
}
impl CreateSessionInput {
    /// <p>The ID of the session request.</p>
    pub fn id(&self) -> ::std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The description of the session.</p>
    pub fn description(&self) -> ::std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The IAM Role ARN</p>
    pub fn role(&self) -> ::std::option::Option<&str> {
        self.role.as_deref()
    }
    /// <p>The <code>SessionCommand</code> that runs the job.</p>
    pub fn command(&self) -> ::std::option::Option<&crate::types::SessionCommand> {
        self.command.as_ref()
    }
    /// <p>The number of minutes before session times out. Default for Spark ETL jobs is 48 hours (2880 minutes), the maximum session lifetime for this job type. Consult the documentation for other job types.</p>
    pub fn timeout(&self) -> ::std::option::Option<i32> {
        self.timeout
    }
    /// <p>The number of minutes when idle before session times out. Default for Spark ETL jobs is value of Timeout. Consult the documentation for other job types.</p>
    pub fn idle_timeout(&self) -> ::std::option::Option<i32> {
        self.idle_timeout
    }
    /// <p>A map array of key-value pairs. Max is 75 pairs.</p>
    pub fn default_arguments(&self) -> ::std::option::Option<&::std::collections::HashMap<::std::string::String, ::std::string::String>> {
        self.default_arguments.as_ref()
    }
    /// <p>The number of connections to use for the session.</p>
    pub fn connections(&self) -> ::std::option::Option<&crate::types::ConnectionsList> {
        self.connections.as_ref()
    }
    /// <p>The number of Glue data processing units (DPUs) that can be allocated when the job runs. A DPU is a relative measure of processing power that consists of 4 vCPUs of compute capacity and 16 GB memory.</p>
    pub fn max_capacity(&self) -> ::std::option::Option<f64> {
        self.max_capacity
    }
    /// <p>The number of workers of a defined <code>WorkerType</code> to use for the session.</p>
    pub fn number_of_workers(&self) -> ::std::option::Option<i32> {
        self.number_of_workers
    }
    /// <p>The type of predefined worker that is allocated when a job runs. Accepts a value of G.1X, G.2X, G.4X, or G.8X for Spark jobs. Accepts the value Z.2X for Ray notebooks.</p>
    /// <ul>
    /// <li>
    /// <p>For the <code>G.1X</code> worker type, each worker maps to 1 DPU (4 vCPUs, 16 GB of memory) with 84GB disk (approximately 34GB free), and provides 1 executor per worker. We recommend this worker type for workloads such as data transforms, joins, and queries, to offers a scalable and cost effective way to run most jobs.</p></li>
    /// <li>
    /// <p>For the <code>G.2X</code> worker type, each worker maps to 2 DPU (8 vCPUs, 32 GB of memory) with 128GB disk (approximately 77GB free), and provides 1 executor per worker. We recommend this worker type for workloads such as data transforms, joins, and queries, to offers a scalable and cost effective way to run most jobs.</p></li>
    /// <li>
    /// <p>For the <code>G.4X</code> worker type, each worker maps to 4 DPU (16 vCPUs, 64 GB of memory) with 256GB disk (approximately 235GB free), and provides 1 executor per worker. We recommend this worker type for jobs whose workloads contain your most demanding transforms, aggregations, joins, and queries. This worker type is available only for Glue version 3.0 or later Spark ETL jobs in the following Amazon Web Services Regions: US East (Ohio), US East (N. Virginia), US West (Oregon), Asia Pacific (Singapore), Asia Pacific (Sydney), Asia Pacific (Tokyo), Canada (Central), Europe (Frankfurt), Europe (Ireland), and Europe (Stockholm).</p></li>
    /// <li>
    /// <p>For the <code>G.8X</code> worker type, each worker maps to 8 DPU (32 vCPUs, 128 GB of memory) with 512GB disk (approximately 487GB free), and provides 1 executor per worker. We recommend this worker type for jobs whose workloads contain your most demanding transforms, aggregations, joins, and queries. This worker type is available only for Glue version 3.0 or later Spark ETL jobs, in the same Amazon Web Services Regions as supported for the <code>G.4X</code> worker type.</p></li>
    /// <li>
    /// <p>For the <code>Z.2X</code> worker type, each worker maps to 2 M-DPU (8vCPUs, 64 GB of memory) with 128 GB disk (approximately 120GB free), and provides up to 8 Ray workers based on the autoscaler.</p></li>
    /// </ul>
    pub fn worker_type(&self) -> ::std::option::Option<&crate::types::WorkerType> {
        self.worker_type.as_ref()
    }
    /// <p>The name of the SecurityConfiguration structure to be used with the session</p>
    pub fn security_configuration(&self) -> ::std::option::Option<&str> {
        self.security_configuration.as_deref()
    }
    /// <p>The Glue version determines the versions of Apache Spark and Python that Glue supports. The GlueVersion must be greater than 2.0.</p>
    pub fn glue_version(&self) -> ::std::option::Option<&str> {
        self.glue_version.as_deref()
    }
    /// <p>The map of key value pairs (tags) belonging to the session.</p>
    pub fn tags(&self) -> ::std::option::Option<&::std::collections::HashMap<::std::string::String, ::std::string::String>> {
        self.tags.as_ref()
    }
    /// <p>The origin of the request.</p>
    pub fn request_origin(&self) -> ::std::option::Option<&str> {
        self.request_origin.as_deref()
    }
}
impl CreateSessionInput {
    /// Creates a new builder-style object to manufacture [`CreateSessionInput`](crate::operation::create_session::CreateSessionInput).
    pub fn builder() -> crate::operation::create_session::builders::CreateSessionInputBuilder {
        crate::operation::create_session::builders::CreateSessionInputBuilder::default()
    }
}

/// A builder for [`CreateSessionInput`](crate::operation::create_session::CreateSessionInput).
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
pub struct CreateSessionInputBuilder {
    pub(crate) id: ::std::option::Option<::std::string::String>,
    pub(crate) description: ::std::option::Option<::std::string::String>,
    pub(crate) role: ::std::option::Option<::std::string::String>,
    pub(crate) command: ::std::option::Option<crate::types::SessionCommand>,
    pub(crate) timeout: ::std::option::Option<i32>,
    pub(crate) idle_timeout: ::std::option::Option<i32>,
    pub(crate) default_arguments: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>,
    pub(crate) connections: ::std::option::Option<crate::types::ConnectionsList>,
    pub(crate) max_capacity: ::std::option::Option<f64>,
    pub(crate) number_of_workers: ::std::option::Option<i32>,
    pub(crate) worker_type: ::std::option::Option<crate::types::WorkerType>,
    pub(crate) security_configuration: ::std::option::Option<::std::string::String>,
    pub(crate) glue_version: ::std::option::Option<::std::string::String>,
    pub(crate) tags: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>,
    pub(crate) request_origin: ::std::option::Option<::std::string::String>,
}
impl CreateSessionInputBuilder {
    /// <p>The ID of the session request.</p>
    /// This field is required.
    pub fn id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The ID of the session request.</p>
    pub fn set_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.id = input;
        self
    }
    /// <p>The ID of the session request.</p>
    pub fn get_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.id
    }
    /// <p>The description of the session.</p>
    pub fn description(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.description = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The description of the session.</p>
    pub fn set_description(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.description = input;
        self
    }
    /// <p>The description of the session.</p>
    pub fn get_description(&self) -> &::std::option::Option<::std::string::String> {
        &self.description
    }
    /// <p>The IAM Role ARN</p>
    /// This field is required.
    pub fn role(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.role = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The IAM Role ARN</p>
    pub fn set_role(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.role = input;
        self
    }
    /// <p>The IAM Role ARN</p>
    pub fn get_role(&self) -> &::std::option::Option<::std::string::String> {
        &self.role
    }
    /// <p>The <code>SessionCommand</code> that runs the job.</p>
    /// This field is required.
    pub fn command(mut self, input: crate::types::SessionCommand) -> Self {
        self.command = ::std::option::Option::Some(input);
        self
    }
    /// <p>The <code>SessionCommand</code> that runs the job.</p>
    pub fn set_command(mut self, input: ::std::option::Option<crate::types::SessionCommand>) -> Self {
        self.command = input;
        self
    }
    /// <p>The <code>SessionCommand</code> that runs the job.</p>
    pub fn get_command(&self) -> &::std::option::Option<crate::types::SessionCommand> {
        &self.command
    }
    /// <p>The number of minutes before session times out. Default for Spark ETL jobs is 48 hours (2880 minutes), the maximum session lifetime for this job type. Consult the documentation for other job types.</p>
    pub fn timeout(mut self, input: i32) -> Self {
        self.timeout = ::std::option::Option::Some(input);
        self
    }
    /// <p>The number of minutes before session times out. Default for Spark ETL jobs is 48 hours (2880 minutes), the maximum session lifetime for this job type. Consult the documentation for other job types.</p>
    pub fn set_timeout(mut self, input: ::std::option::Option<i32>) -> Self {
        self.timeout = input;
        self
    }
    /// <p>The number of minutes before session times out. Default for Spark ETL jobs is 48 hours (2880 minutes), the maximum session lifetime for this job type. Consult the documentation for other job types.</p>
    pub fn get_timeout(&self) -> &::std::option::Option<i32> {
        &self.timeout
    }
    /// <p>The number of minutes when idle before session times out. Default for Spark ETL jobs is value of Timeout. Consult the documentation for other job types.</p>
    pub fn idle_timeout(mut self, input: i32) -> Self {
        self.idle_timeout = ::std::option::Option::Some(input);
        self
    }
    /// <p>The number of minutes when idle before session times out. Default for Spark ETL jobs is value of Timeout. Consult the documentation for other job types.</p>
    pub fn set_idle_timeout(mut self, input: ::std::option::Option<i32>) -> Self {
        self.idle_timeout = input;
        self
    }
    /// <p>The number of minutes when idle before session times out. Default for Spark ETL jobs is value of Timeout. Consult the documentation for other job types.</p>
    pub fn get_idle_timeout(&self) -> &::std::option::Option<i32> {
        &self.idle_timeout
    }
    /// Adds a key-value pair to `default_arguments`.
    ///
    /// To override the contents of this collection use [`set_default_arguments`](Self::set_default_arguments).
    ///
    /// <p>A map array of key-value pairs. Max is 75 pairs.</p>
    pub fn default_arguments(
        mut self,
        k: impl ::std::convert::Into<::std::string::String>,
        v: impl ::std::convert::Into<::std::string::String>,
    ) -> Self {
        let mut hash_map = self.default_arguments.unwrap_or_default();
        hash_map.insert(k.into(), v.into());
        self.default_arguments = ::std::option::Option::Some(hash_map);
        self
    }
    /// <p>A map array of key-value pairs. Max is 75 pairs.</p>
    pub fn set_default_arguments(
        mut self,
        input: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>,
    ) -> Self {
        self.default_arguments = input;
        self
    }
    /// <p>A map array of key-value pairs. Max is 75 pairs.</p>
    pub fn get_default_arguments(&self) -> &::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>> {
        &self.default_arguments
    }
    /// <p>The number of connections to use for the session.</p>
    pub fn connections(mut self, input: crate::types::ConnectionsList) -> Self {
        self.connections = ::std::option::Option::Some(input);
        self
    }
    /// <p>The number of connections to use for the session.</p>
    pub fn set_connections(mut self, input: ::std::option::Option<crate::types::ConnectionsList>) -> Self {
        self.connections = input;
        self
    }
    /// <p>The number of connections to use for the session.</p>
    pub fn get_connections(&self) -> &::std::option::Option<crate::types::ConnectionsList> {
        &self.connections
    }
    /// <p>The number of Glue data processing units (DPUs) that can be allocated when the job runs. A DPU is a relative measure of processing power that consists of 4 vCPUs of compute capacity and 16 GB memory.</p>
    pub fn max_capacity(mut self, input: f64) -> Self {
        self.max_capacity = ::std::option::Option::Some(input);
        self
    }
    /// <p>The number of Glue data processing units (DPUs) that can be allocated when the job runs. A DPU is a relative measure of processing power that consists of 4 vCPUs of compute capacity and 16 GB memory.</p>
    pub fn set_max_capacity(mut self, input: ::std::option::Option<f64>) -> Self {
        self.max_capacity = input;
        self
    }
    /// <p>The number of Glue data processing units (DPUs) that can be allocated when the job runs. A DPU is a relative measure of processing power that consists of 4 vCPUs of compute capacity and 16 GB memory.</p>
    pub fn get_max_capacity(&self) -> &::std::option::Option<f64> {
        &self.max_capacity
    }
    /// <p>The number of workers of a defined <code>WorkerType</code> to use for the session.</p>
    pub fn number_of_workers(mut self, input: i32) -> Self {
        self.number_of_workers = ::std::option::Option::Some(input);
        self
    }
    /// <p>The number of workers of a defined <code>WorkerType</code> to use for the session.</p>
    pub fn set_number_of_workers(mut self, input: ::std::option::Option<i32>) -> Self {
        self.number_of_workers = input;
        self
    }
    /// <p>The number of workers of a defined <code>WorkerType</code> to use for the session.</p>
    pub fn get_number_of_workers(&self) -> &::std::option::Option<i32> {
        &self.number_of_workers
    }
    /// <p>The type of predefined worker that is allocated when a job runs. Accepts a value of G.1X, G.2X, G.4X, or G.8X for Spark jobs. Accepts the value Z.2X for Ray notebooks.</p>
    /// <ul>
    /// <li>
    /// <p>For the <code>G.1X</code> worker type, each worker maps to 1 DPU (4 vCPUs, 16 GB of memory) with 84GB disk (approximately 34GB free), and provides 1 executor per worker. We recommend this worker type for workloads such as data transforms, joins, and queries, to offers a scalable and cost effective way to run most jobs.</p></li>
    /// <li>
    /// <p>For the <code>G.2X</code> worker type, each worker maps to 2 DPU (8 vCPUs, 32 GB of memory) with 128GB disk (approximately 77GB free), and provides 1 executor per worker. We recommend this worker type for workloads such as data transforms, joins, and queries, to offers a scalable and cost effective way to run most jobs.</p></li>
    /// <li>
    /// <p>For the <code>G.4X</code> worker type, each worker maps to 4 DPU (16 vCPUs, 64 GB of memory) with 256GB disk (approximately 235GB free), and provides 1 executor per worker. We recommend this worker type for jobs whose workloads contain your most demanding transforms, aggregations, joins, and queries. This worker type is available only for Glue version 3.0 or later Spark ETL jobs in the following Amazon Web Services Regions: US East (Ohio), US East (N. Virginia), US West (Oregon), Asia Pacific (Singapore), Asia Pacific (Sydney), Asia Pacific (Tokyo), Canada (Central), Europe (Frankfurt), Europe (Ireland), and Europe (Stockholm).</p></li>
    /// <li>
    /// <p>For the <code>G.8X</code> worker type, each worker maps to 8 DPU (32 vCPUs, 128 GB of memory) with 512GB disk (approximately 487GB free), and provides 1 executor per worker. We recommend this worker type for jobs whose workloads contain your most demanding transforms, aggregations, joins, and queries. This worker type is available only for Glue version 3.0 or later Spark ETL jobs, in the same Amazon Web Services Regions as supported for the <code>G.4X</code> worker type.</p></li>
    /// <li>
    /// <p>For the <code>Z.2X</code> worker type, each worker maps to 2 M-DPU (8vCPUs, 64 GB of memory) with 128 GB disk (approximately 120GB free), and provides up to 8 Ray workers based on the autoscaler.</p></li>
    /// </ul>
    pub fn worker_type(mut self, input: crate::types::WorkerType) -> Self {
        self.worker_type = ::std::option::Option::Some(input);
        self
    }
    /// <p>The type of predefined worker that is allocated when a job runs. Accepts a value of G.1X, G.2X, G.4X, or G.8X for Spark jobs. Accepts the value Z.2X for Ray notebooks.</p>
    /// <ul>
    /// <li>
    /// <p>For the <code>G.1X</code> worker type, each worker maps to 1 DPU (4 vCPUs, 16 GB of memory) with 84GB disk (approximately 34GB free), and provides 1 executor per worker. We recommend this worker type for workloads such as data transforms, joins, and queries, to offers a scalable and cost effective way to run most jobs.</p></li>
    /// <li>
    /// <p>For the <code>G.2X</code> worker type, each worker maps to 2 DPU (8 vCPUs, 32 GB of memory) with 128GB disk (approximately 77GB free), and provides 1 executor per worker. We recommend this worker type for workloads such as data transforms, joins, and queries, to offers a scalable and cost effective way to run most jobs.</p></li>
    /// <li>
    /// <p>For the <code>G.4X</code> worker type, each worker maps to 4 DPU (16 vCPUs, 64 GB of memory) with 256GB disk (approximately 235GB free), and provides 1 executor per worker. We recommend this worker type for jobs whose workloads contain your most demanding transforms, aggregations, joins, and queries. This worker type is available only for Glue version 3.0 or later Spark ETL jobs in the following Amazon Web Services Regions: US East (Ohio), US East (N. Virginia), US West (Oregon), Asia Pacific (Singapore), Asia Pacific (Sydney), Asia Pacific (Tokyo), Canada (Central), Europe (Frankfurt), Europe (Ireland), and Europe (Stockholm).</p></li>
    /// <li>
    /// <p>For the <code>G.8X</code> worker type, each worker maps to 8 DPU (32 vCPUs, 128 GB of memory) with 512GB disk (approximately 487GB free), and provides 1 executor per worker. We recommend this worker type for jobs whose workloads contain your most demanding transforms, aggregations, joins, and queries. This worker type is available only for Glue version 3.0 or later Spark ETL jobs, in the same Amazon Web Services Regions as supported for the <code>G.4X</code> worker type.</p></li>
    /// <li>
    /// <p>For the <code>Z.2X</code> worker type, each worker maps to 2 M-DPU (8vCPUs, 64 GB of memory) with 128 GB disk (approximately 120GB free), and provides up to 8 Ray workers based on the autoscaler.</p></li>
    /// </ul>
    pub fn set_worker_type(mut self, input: ::std::option::Option<crate::types::WorkerType>) -> Self {
        self.worker_type = input;
        self
    }
    /// <p>The type of predefined worker that is allocated when a job runs. Accepts a value of G.1X, G.2X, G.4X, or G.8X for Spark jobs. Accepts the value Z.2X for Ray notebooks.</p>
    /// <ul>
    /// <li>
    /// <p>For the <code>G.1X</code> worker type, each worker maps to 1 DPU (4 vCPUs, 16 GB of memory) with 84GB disk (approximately 34GB free), and provides 1 executor per worker. We recommend this worker type for workloads such as data transforms, joins, and queries, to offers a scalable and cost effective way to run most jobs.</p></li>
    /// <li>
    /// <p>For the <code>G.2X</code> worker type, each worker maps to 2 DPU (8 vCPUs, 32 GB of memory) with 128GB disk (approximately 77GB free), and provides 1 executor per worker. We recommend this worker type for workloads such as data transforms, joins, and queries, to offers a scalable and cost effective way to run most jobs.</p></li>
    /// <li>
    /// <p>For the <code>G.4X</code> worker type, each worker maps to 4 DPU (16 vCPUs, 64 GB of memory) with 256GB disk (approximately 235GB free), and provides 1 executor per worker. We recommend this worker type for jobs whose workloads contain your most demanding transforms, aggregations, joins, and queries. This worker type is available only for Glue version 3.0 or later Spark ETL jobs in the following Amazon Web Services Regions: US East (Ohio), US East (N. Virginia), US West (Oregon), Asia Pacific (Singapore), Asia Pacific (Sydney), Asia Pacific (Tokyo), Canada (Central), Europe (Frankfurt), Europe (Ireland), and Europe (Stockholm).</p></li>
    /// <li>
    /// <p>For the <code>G.8X</code> worker type, each worker maps to 8 DPU (32 vCPUs, 128 GB of memory) with 512GB disk (approximately 487GB free), and provides 1 executor per worker. We recommend this worker type for jobs whose workloads contain your most demanding transforms, aggregations, joins, and queries. This worker type is available only for Glue version 3.0 or later Spark ETL jobs, in the same Amazon Web Services Regions as supported for the <code>G.4X</code> worker type.</p></li>
    /// <li>
    /// <p>For the <code>Z.2X</code> worker type, each worker maps to 2 M-DPU (8vCPUs, 64 GB of memory) with 128 GB disk (approximately 120GB free), and provides up to 8 Ray workers based on the autoscaler.</p></li>
    /// </ul>
    pub fn get_worker_type(&self) -> &::std::option::Option<crate::types::WorkerType> {
        &self.worker_type
    }
    /// <p>The name of the SecurityConfiguration structure to be used with the session</p>
    pub fn security_configuration(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.security_configuration = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The name of the SecurityConfiguration structure to be used with the session</p>
    pub fn set_security_configuration(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.security_configuration = input;
        self
    }
    /// <p>The name of the SecurityConfiguration structure to be used with the session</p>
    pub fn get_security_configuration(&self) -> &::std::option::Option<::std::string::String> {
        &self.security_configuration
    }
    /// <p>The Glue version determines the versions of Apache Spark and Python that Glue supports. The GlueVersion must be greater than 2.0.</p>
    pub fn glue_version(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.glue_version = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The Glue version determines the versions of Apache Spark and Python that Glue supports. The GlueVersion must be greater than 2.0.</p>
    pub fn set_glue_version(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.glue_version = input;
        self
    }
    /// <p>The Glue version determines the versions of Apache Spark and Python that Glue supports. The GlueVersion must be greater than 2.0.</p>
    pub fn get_glue_version(&self) -> &::std::option::Option<::std::string::String> {
        &self.glue_version
    }
    /// Adds a key-value pair to `tags`.
    ///
    /// To override the contents of this collection use [`set_tags`](Self::set_tags).
    ///
    /// <p>The map of key value pairs (tags) belonging to the session.</p>
    pub fn tags(mut self, k: impl ::std::convert::Into<::std::string::String>, v: impl ::std::convert::Into<::std::string::String>) -> Self {
        let mut hash_map = self.tags.unwrap_or_default();
        hash_map.insert(k.into(), v.into());
        self.tags = ::std::option::Option::Some(hash_map);
        self
    }
    /// <p>The map of key value pairs (tags) belonging to the session.</p>
    pub fn set_tags(mut self, input: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>) -> Self {
        self.tags = input;
        self
    }
    /// <p>The map of key value pairs (tags) belonging to the session.</p>
    pub fn get_tags(&self) -> &::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>> {
        &self.tags
    }
    /// <p>The origin of the request.</p>
    pub fn request_origin(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.request_origin = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The origin of the request.</p>
    pub fn set_request_origin(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.request_origin = input;
        self
    }
    /// <p>The origin of the request.</p>
    pub fn get_request_origin(&self) -> &::std::option::Option<::std::string::String> {
        &self.request_origin
    }
    /// Consumes the builder and constructs a [`CreateSessionInput`](crate::operation::create_session::CreateSessionInput).
    pub fn build(
        self,
    ) -> ::std::result::Result<crate::operation::create_session::CreateSessionInput, ::aws_smithy_types::error::operation::BuildError> {
        ::std::result::Result::Ok(crate::operation::create_session::CreateSessionInput {
            id: self.id,
            description: self.description,
            role: self.role,
            command: self.command,
            timeout: self.timeout,
            idle_timeout: self.idle_timeout,
            default_arguments: self.default_arguments,
            connections: self.connections,
            max_capacity: self.max_capacity,
            number_of_workers: self.number_of_workers,
            worker_type: self.worker_type,
            security_configuration: self.security_configuration,
            glue_version: self.glue_version,
            tags: self.tags,
            request_origin: self.request_origin,
        })
    }
}
