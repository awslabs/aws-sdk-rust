// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
pub use crate::operation::update_ml_transform::_update_ml_transform_output::UpdateMlTransformOutputBuilder;

pub use crate::operation::update_ml_transform::_update_ml_transform_input::UpdateMlTransformInputBuilder;

impl UpdateMlTransformInputBuilder {
    /// Sends a request with this input using the given client.
    pub async fn send_with(
        self,
        client: &crate::Client,
    ) -> ::std::result::Result<
        crate::operation::update_ml_transform::UpdateMlTransformOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::update_ml_transform::UpdateMLTransformError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let mut fluent_builder = client.update_ml_transform();
        fluent_builder.inner = self;
        fluent_builder.send().await
    }
}
/// Fluent builder constructing a request to `UpdateMLTransform`.
///
/// <p>Updates an existing machine learning transform. Call this operation to tune the algorithm parameters to achieve better results.</p>
/// <p>After calling this operation, you can call the <code>StartMLEvaluationTaskRun</code> operation to assess how well your new parameters achieved your goals (such as improving the quality of your machine learning transform, or making it more cost-effective).</p>
#[derive(::std::clone::Clone, ::std::fmt::Debug)]
pub struct UpdateMLTransformFluentBuilder {
    handle: ::std::sync::Arc<crate::client::Handle>,
    inner: crate::operation::update_ml_transform::builders::UpdateMlTransformInputBuilder,
    config_override: ::std::option::Option<crate::config::Builder>,
}
impl
    crate::client::customize::internal::CustomizableSend<
        crate::operation::update_ml_transform::UpdateMlTransformOutput,
        crate::operation::update_ml_transform::UpdateMLTransformError,
    > for UpdateMLTransformFluentBuilder
{
    fn send(
        self,
        config_override: crate::config::Builder,
    ) -> crate::client::customize::internal::BoxFuture<
        crate::client::customize::internal::SendResult<
            crate::operation::update_ml_transform::UpdateMlTransformOutput,
            crate::operation::update_ml_transform::UpdateMLTransformError,
        >,
    > {
        ::std::boxed::Box::pin(async move { self.config_override(config_override).send().await })
    }
}
impl UpdateMLTransformFluentBuilder {
    /// Creates a new `UpdateMLTransform`.
    pub(crate) fn new(handle: ::std::sync::Arc<crate::client::Handle>) -> Self {
        Self {
            handle,
            inner: ::std::default::Default::default(),
            config_override: ::std::option::Option::None,
        }
    }
    /// Access the UpdateMLTransform as a reference.
    pub fn as_input(&self) -> &crate::operation::update_ml_transform::builders::UpdateMlTransformInputBuilder {
        &self.inner
    }
    /// Sends the request and returns the response.
    ///
    /// If an error occurs, an `SdkError` will be returned with additional details that
    /// can be matched against.
    ///
    /// By default, any retryable failures will be retried twice. Retry behavior
    /// is configurable with the [RetryConfig](aws_smithy_types::retry::RetryConfig), which can be
    /// set when configuring the client.
    pub async fn send(
        self,
    ) -> ::std::result::Result<
        crate::operation::update_ml_transform::UpdateMlTransformOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::update_ml_transform::UpdateMLTransformError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let input = self
            .inner
            .build()
            .map_err(::aws_smithy_runtime_api::client::result::SdkError::construction_failure)?;
        let runtime_plugins = crate::operation::update_ml_transform::UpdateMLTransform::operation_runtime_plugins(
            self.handle.runtime_plugins.clone(),
            &self.handle.conf,
            self.config_override,
        );
        crate::operation::update_ml_transform::UpdateMLTransform::orchestrate(&runtime_plugins, input).await
    }

    /// Consumes this builder, creating a customizable operation that can be modified before being sent.
    pub fn customize(
        self,
    ) -> crate::client::customize::CustomizableOperation<
        crate::operation::update_ml_transform::UpdateMlTransformOutput,
        crate::operation::update_ml_transform::UpdateMLTransformError,
        Self,
    > {
        crate::client::customize::CustomizableOperation::new(self)
    }
    pub(crate) fn config_override(mut self, config_override: impl Into<crate::config::Builder>) -> Self {
        self.set_config_override(Some(config_override.into()));
        self
    }

    pub(crate) fn set_config_override(&mut self, config_override: Option<crate::config::Builder>) -> &mut Self {
        self.config_override = config_override;
        self
    }
    /// <p>A unique identifier that was generated when the transform was created.</p>
    pub fn transform_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.transform_id(input.into());
        self
    }
    /// <p>A unique identifier that was generated when the transform was created.</p>
    pub fn set_transform_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_transform_id(input);
        self
    }
    /// <p>A unique identifier that was generated when the transform was created.</p>
    pub fn get_transform_id(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_transform_id()
    }
    /// <p>The unique name that you gave the transform when you created it.</p>
    pub fn name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.name(input.into());
        self
    }
    /// <p>The unique name that you gave the transform when you created it.</p>
    pub fn set_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_name(input);
        self
    }
    /// <p>The unique name that you gave the transform when you created it.</p>
    pub fn get_name(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_name()
    }
    /// <p>A description of the transform. The default is an empty string.</p>
    pub fn description(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.description(input.into());
        self
    }
    /// <p>A description of the transform. The default is an empty string.</p>
    pub fn set_description(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_description(input);
        self
    }
    /// <p>A description of the transform. The default is an empty string.</p>
    pub fn get_description(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_description()
    }
    /// <p>The configuration parameters that are specific to the transform type (algorithm) used. Conditionally dependent on the transform type.</p>
    pub fn parameters(mut self, input: crate::types::TransformParameters) -> Self {
        self.inner = self.inner.parameters(input);
        self
    }
    /// <p>The configuration parameters that are specific to the transform type (algorithm) used. Conditionally dependent on the transform type.</p>
    pub fn set_parameters(mut self, input: ::std::option::Option<crate::types::TransformParameters>) -> Self {
        self.inner = self.inner.set_parameters(input);
        self
    }
    /// <p>The configuration parameters that are specific to the transform type (algorithm) used. Conditionally dependent on the transform type.</p>
    pub fn get_parameters(&self) -> &::std::option::Option<crate::types::TransformParameters> {
        self.inner.get_parameters()
    }
    /// <p>The name or Amazon Resource Name (ARN) of the IAM role with the required permissions.</p>
    pub fn role(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.role(input.into());
        self
    }
    /// <p>The name or Amazon Resource Name (ARN) of the IAM role with the required permissions.</p>
    pub fn set_role(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_role(input);
        self
    }
    /// <p>The name or Amazon Resource Name (ARN) of the IAM role with the required permissions.</p>
    pub fn get_role(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_role()
    }
    /// <p>This value determines which version of Glue this machine learning transform is compatible with. Glue 1.0 is recommended for most customers. If the value is not set, the Glue compatibility defaults to Glue 0.9. For more information, see <a href="https://docs.aws.amazon.com/glue/latest/dg/release-notes.html#release-notes-versions">Glue Versions</a> in the developer guide.</p>
    pub fn glue_version(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.glue_version(input.into());
        self
    }
    /// <p>This value determines which version of Glue this machine learning transform is compatible with. Glue 1.0 is recommended for most customers. If the value is not set, the Glue compatibility defaults to Glue 0.9. For more information, see <a href="https://docs.aws.amazon.com/glue/latest/dg/release-notes.html#release-notes-versions">Glue Versions</a> in the developer guide.</p>
    pub fn set_glue_version(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_glue_version(input);
        self
    }
    /// <p>This value determines which version of Glue this machine learning transform is compatible with. Glue 1.0 is recommended for most customers. If the value is not set, the Glue compatibility defaults to Glue 0.9. For more information, see <a href="https://docs.aws.amazon.com/glue/latest/dg/release-notes.html#release-notes-versions">Glue Versions</a> in the developer guide.</p>
    pub fn get_glue_version(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_glue_version()
    }
    /// <p>The number of Glue data processing units (DPUs) that are allocated to task runs for this transform. You can allocate from 2 to 100 DPUs; the default is 10. A DPU is a relative measure of processing power that consists of 4 vCPUs of compute capacity and 16 GB of memory. For more information, see the <a href="https://aws.amazon.com/glue/pricing/">Glue pricing page</a>. </p>
    /// <p>When the <code>WorkerType</code> field is set to a value other than <code>Standard</code>, the <code>MaxCapacity</code> field is set automatically and becomes read-only.</p>
    pub fn max_capacity(mut self, input: f64) -> Self {
        self.inner = self.inner.max_capacity(input);
        self
    }
    /// <p>The number of Glue data processing units (DPUs) that are allocated to task runs for this transform. You can allocate from 2 to 100 DPUs; the default is 10. A DPU is a relative measure of processing power that consists of 4 vCPUs of compute capacity and 16 GB of memory. For more information, see the <a href="https://aws.amazon.com/glue/pricing/">Glue pricing page</a>. </p>
    /// <p>When the <code>WorkerType</code> field is set to a value other than <code>Standard</code>, the <code>MaxCapacity</code> field is set automatically and becomes read-only.</p>
    pub fn set_max_capacity(mut self, input: ::std::option::Option<f64>) -> Self {
        self.inner = self.inner.set_max_capacity(input);
        self
    }
    /// <p>The number of Glue data processing units (DPUs) that are allocated to task runs for this transform. You can allocate from 2 to 100 DPUs; the default is 10. A DPU is a relative measure of processing power that consists of 4 vCPUs of compute capacity and 16 GB of memory. For more information, see the <a href="https://aws.amazon.com/glue/pricing/">Glue pricing page</a>. </p>
    /// <p>When the <code>WorkerType</code> field is set to a value other than <code>Standard</code>, the <code>MaxCapacity</code> field is set automatically and becomes read-only.</p>
    pub fn get_max_capacity(&self) -> &::std::option::Option<f64> {
        self.inner.get_max_capacity()
    }
    /// <p>The type of predefined worker that is allocated when this task runs. Accepts a value of Standard, G.1X, or G.2X.</p>
    /// <ul>
    /// <li> <p>For the <code>Standard</code> worker type, each worker provides 4 vCPU, 16 GB of memory and a 50GB disk, and 2 executors per worker.</p> </li>
    /// <li> <p>For the <code>G.1X</code> worker type, each worker provides 4 vCPU, 16 GB of memory and a 64GB disk, and 1 executor per worker.</p> </li>
    /// <li> <p>For the <code>G.2X</code> worker type, each worker provides 8 vCPU, 32 GB of memory and a 128GB disk, and 1 executor per worker.</p> </li>
    /// </ul>
    pub fn worker_type(mut self, input: crate::types::WorkerType) -> Self {
        self.inner = self.inner.worker_type(input);
        self
    }
    /// <p>The type of predefined worker that is allocated when this task runs. Accepts a value of Standard, G.1X, or G.2X.</p>
    /// <ul>
    /// <li> <p>For the <code>Standard</code> worker type, each worker provides 4 vCPU, 16 GB of memory and a 50GB disk, and 2 executors per worker.</p> </li>
    /// <li> <p>For the <code>G.1X</code> worker type, each worker provides 4 vCPU, 16 GB of memory and a 64GB disk, and 1 executor per worker.</p> </li>
    /// <li> <p>For the <code>G.2X</code> worker type, each worker provides 8 vCPU, 32 GB of memory and a 128GB disk, and 1 executor per worker.</p> </li>
    /// </ul>
    pub fn set_worker_type(mut self, input: ::std::option::Option<crate::types::WorkerType>) -> Self {
        self.inner = self.inner.set_worker_type(input);
        self
    }
    /// <p>The type of predefined worker that is allocated when this task runs. Accepts a value of Standard, G.1X, or G.2X.</p>
    /// <ul>
    /// <li> <p>For the <code>Standard</code> worker type, each worker provides 4 vCPU, 16 GB of memory and a 50GB disk, and 2 executors per worker.</p> </li>
    /// <li> <p>For the <code>G.1X</code> worker type, each worker provides 4 vCPU, 16 GB of memory and a 64GB disk, and 1 executor per worker.</p> </li>
    /// <li> <p>For the <code>G.2X</code> worker type, each worker provides 8 vCPU, 32 GB of memory and a 128GB disk, and 1 executor per worker.</p> </li>
    /// </ul>
    pub fn get_worker_type(&self) -> &::std::option::Option<crate::types::WorkerType> {
        self.inner.get_worker_type()
    }
    /// <p>The number of workers of a defined <code>workerType</code> that are allocated when this task runs.</p>
    pub fn number_of_workers(mut self, input: i32) -> Self {
        self.inner = self.inner.number_of_workers(input);
        self
    }
    /// <p>The number of workers of a defined <code>workerType</code> that are allocated when this task runs.</p>
    pub fn set_number_of_workers(mut self, input: ::std::option::Option<i32>) -> Self {
        self.inner = self.inner.set_number_of_workers(input);
        self
    }
    /// <p>The number of workers of a defined <code>workerType</code> that are allocated when this task runs.</p>
    pub fn get_number_of_workers(&self) -> &::std::option::Option<i32> {
        self.inner.get_number_of_workers()
    }
    /// <p>The timeout for a task run for this transform in minutes. This is the maximum time that a task run for this transform can consume resources before it is terminated and enters <code>TIMEOUT</code> status. The default is 2,880 minutes (48 hours).</p>
    pub fn timeout(mut self, input: i32) -> Self {
        self.inner = self.inner.timeout(input);
        self
    }
    /// <p>The timeout for a task run for this transform in minutes. This is the maximum time that a task run for this transform can consume resources before it is terminated and enters <code>TIMEOUT</code> status. The default is 2,880 minutes (48 hours).</p>
    pub fn set_timeout(mut self, input: ::std::option::Option<i32>) -> Self {
        self.inner = self.inner.set_timeout(input);
        self
    }
    /// <p>The timeout for a task run for this transform in minutes. This is the maximum time that a task run for this transform can consume resources before it is terminated and enters <code>TIMEOUT</code> status. The default is 2,880 minutes (48 hours).</p>
    pub fn get_timeout(&self) -> &::std::option::Option<i32> {
        self.inner.get_timeout()
    }
    /// <p>The maximum number of times to retry a task for this transform after a task run fails.</p>
    pub fn max_retries(mut self, input: i32) -> Self {
        self.inner = self.inner.max_retries(input);
        self
    }
    /// <p>The maximum number of times to retry a task for this transform after a task run fails.</p>
    pub fn set_max_retries(mut self, input: ::std::option::Option<i32>) -> Self {
        self.inner = self.inner.set_max_retries(input);
        self
    }
    /// <p>The maximum number of times to retry a task for this transform after a task run fails.</p>
    pub fn get_max_retries(&self) -> &::std::option::Option<i32> {
        self.inner.get_max_retries()
    }
}
