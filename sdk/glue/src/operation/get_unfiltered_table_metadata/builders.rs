// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
pub use crate::operation::get_unfiltered_table_metadata::_get_unfiltered_table_metadata_output::GetUnfilteredTableMetadataOutputBuilder;

pub use crate::operation::get_unfiltered_table_metadata::_get_unfiltered_table_metadata_input::GetUnfilteredTableMetadataInputBuilder;

impl crate::operation::get_unfiltered_table_metadata::builders::GetUnfilteredTableMetadataInputBuilder {
    /// Sends a request with this input using the given client.
    pub async fn send_with(
        self,
        client: &crate::Client,
    ) -> ::std::result::Result<
        crate::operation::get_unfiltered_table_metadata::GetUnfilteredTableMetadataOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::get_unfiltered_table_metadata::GetUnfilteredTableMetadataError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let mut fluent_builder = client.get_unfiltered_table_metadata();
        fluent_builder.inner = self;
        fluent_builder.send().await
    }
}
/// Fluent builder constructing a request to `GetUnfilteredTableMetadata`.
///
/// <p>Allows a third-party analytical engine to retrieve unfiltered table metadata from the Data Catalog.</p>
/// <p>For IAM authorization, the public IAM action associated with this API is <code>glue:GetTable</code>.</p>
#[derive(::std::clone::Clone, ::std::fmt::Debug)]
pub struct GetUnfilteredTableMetadataFluentBuilder {
    handle: ::std::sync::Arc<crate::client::Handle>,
    inner: crate::operation::get_unfiltered_table_metadata::builders::GetUnfilteredTableMetadataInputBuilder,
    config_override: ::std::option::Option<crate::config::Builder>,
}
impl
    crate::client::customize::internal::CustomizableSend<
        crate::operation::get_unfiltered_table_metadata::GetUnfilteredTableMetadataOutput,
        crate::operation::get_unfiltered_table_metadata::GetUnfilteredTableMetadataError,
    > for GetUnfilteredTableMetadataFluentBuilder
{
    fn send(
        self,
        config_override: crate::config::Builder,
    ) -> crate::client::customize::internal::BoxFuture<
        crate::client::customize::internal::SendResult<
            crate::operation::get_unfiltered_table_metadata::GetUnfilteredTableMetadataOutput,
            crate::operation::get_unfiltered_table_metadata::GetUnfilteredTableMetadataError,
        >,
    > {
        ::std::boxed::Box::pin(async move { self.config_override(config_override).send().await })
    }
}
impl GetUnfilteredTableMetadataFluentBuilder {
    /// Creates a new `GetUnfilteredTableMetadata`.
    pub(crate) fn new(handle: ::std::sync::Arc<crate::client::Handle>) -> Self {
        Self {
            handle,
            inner: ::std::default::Default::default(),
            config_override: ::std::option::Option::None,
        }
    }
    /// Access the GetUnfilteredTableMetadata as a reference.
    pub fn as_input(&self) -> &crate::operation::get_unfiltered_table_metadata::builders::GetUnfilteredTableMetadataInputBuilder {
        &self.inner
    }
    /// Sends the request and returns the response.
    ///
    /// If an error occurs, an `SdkError` will be returned with additional details that
    /// can be matched against.
    ///
    /// By default, any retryable failures will be retried twice. Retry behavior
    /// is configurable with the [RetryConfig](aws_smithy_types::retry::RetryConfig), which can be
    /// set when configuring the client.
    pub async fn send(
        self,
    ) -> ::std::result::Result<
        crate::operation::get_unfiltered_table_metadata::GetUnfilteredTableMetadataOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::get_unfiltered_table_metadata::GetUnfilteredTableMetadataError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let input = self
            .inner
            .build()
            .map_err(::aws_smithy_runtime_api::client::result::SdkError::construction_failure)?;
        let runtime_plugins = crate::operation::get_unfiltered_table_metadata::GetUnfilteredTableMetadata::operation_runtime_plugins(
            self.handle.runtime_plugins.clone(),
            &self.handle.conf,
            self.config_override,
        );
        crate::operation::get_unfiltered_table_metadata::GetUnfilteredTableMetadata::orchestrate(&runtime_plugins, input).await
    }

    /// Consumes this builder, creating a customizable operation that can be modified before being sent.
    pub fn customize(
        self,
    ) -> crate::client::customize::CustomizableOperation<
        crate::operation::get_unfiltered_table_metadata::GetUnfilteredTableMetadataOutput,
        crate::operation::get_unfiltered_table_metadata::GetUnfilteredTableMetadataError,
        Self,
    > {
        crate::client::customize::CustomizableOperation::new(self)
    }
    pub(crate) fn config_override(mut self, config_override: impl ::std::convert::Into<crate::config::Builder>) -> Self {
        self.set_config_override(::std::option::Option::Some(config_override.into()));
        self
    }

    pub(crate) fn set_config_override(&mut self, config_override: ::std::option::Option<crate::config::Builder>) -> &mut Self {
        self.config_override = config_override;
        self
    }
    /// <p>Specified only if the base tables belong to a different Amazon Web Services Region.</p>
    pub fn region(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.region(input.into());
        self
    }
    /// <p>Specified only if the base tables belong to a different Amazon Web Services Region.</p>
    pub fn set_region(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_region(input);
        self
    }
    /// <p>Specified only if the base tables belong to a different Amazon Web Services Region.</p>
    pub fn get_region(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_region()
    }
    /// <p>The catalog ID where the table resides.</p>
    pub fn catalog_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.catalog_id(input.into());
        self
    }
    /// <p>The catalog ID where the table resides.</p>
    pub fn set_catalog_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_catalog_id(input);
        self
    }
    /// <p>The catalog ID where the table resides.</p>
    pub fn get_catalog_id(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_catalog_id()
    }
    /// <p>(Required) Specifies the name of a database that contains the table.</p>
    pub fn database_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.database_name(input.into());
        self
    }
    /// <p>(Required) Specifies the name of a database that contains the table.</p>
    pub fn set_database_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_database_name(input);
        self
    }
    /// <p>(Required) Specifies the name of a database that contains the table.</p>
    pub fn get_database_name(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_database_name()
    }
    /// <p>(Required) Specifies the name of a table for which you are requesting metadata.</p>
    pub fn name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.name(input.into());
        self
    }
    /// <p>(Required) Specifies the name of a table for which you are requesting metadata.</p>
    pub fn set_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_name(input);
        self
    }
    /// <p>(Required) Specifies the name of a table for which you are requesting metadata.</p>
    pub fn get_name(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_name()
    }
    /// <p>A structure containing Lake Formation audit context information.</p>
    pub fn audit_context(mut self, input: crate::types::AuditContext) -> Self {
        self.inner = self.inner.audit_context(input);
        self
    }
    /// <p>A structure containing Lake Formation audit context information.</p>
    pub fn set_audit_context(mut self, input: ::std::option::Option<crate::types::AuditContext>) -> Self {
        self.inner = self.inner.set_audit_context(input);
        self
    }
    /// <p>A structure containing Lake Formation audit context information.</p>
    pub fn get_audit_context(&self) -> &::std::option::Option<crate::types::AuditContext> {
        self.inner.get_audit_context()
    }
    ///
    /// Appends an item to `SupportedPermissionTypes`.
    ///
    /// To override the contents of this collection use [`set_supported_permission_types`](Self::set_supported_permission_types).
    ///
    /// <p>Indicates the level of filtering a third-party analytical engine is capable of enforcing when calling the <code>GetUnfilteredTableMetadata</code> API operation. Accepted values are:</p>
    /// <ul>
    /// <li>
    /// <p><code>COLUMN_PERMISSION</code> - Column permissions ensure that users can access only specific columns in the table. If there are particular columns contain sensitive data, data lake administrators can define column filters that exclude access to specific columns.</p></li>
    /// <li>
    /// <p><code>CELL_FILTER_PERMISSION</code> - Cell-level filtering combines column filtering (include or exclude columns) and row filter expressions to restrict access to individual elements in the table.</p></li>
    /// <li>
    /// <p><code>NESTED_PERMISSION</code> - Nested permissions combines cell-level filtering and nested column filtering to restrict access to columns and/or nested columns in specific rows based on row filter expressions.</p></li>
    /// <li>
    /// <p><code>NESTED_CELL_PERMISSION</code> - Nested cell permissions combines nested permission with nested cell-level filtering. This allows different subsets of nested columns to be restricted based on an array of row filter expressions.</p></li>
    /// </ul>
    /// <p>Note: Each of these permission types follows a hierarchical order where each subsequent permission type includes all permission of the previous type.</p>
    /// <p>Important: If you provide a supported permission type that doesn't match the user's level of permissions on the table, then Lake Formation raises an exception. For example, if the third-party engine calling the <code>GetUnfilteredTableMetadata</code> operation can enforce only column-level filtering, and the user has nested cell filtering applied on the table, Lake Formation throws an exception, and will not return unfiltered table metadata and data access credentials.</p>
    pub fn supported_permission_types(mut self, input: crate::types::PermissionType) -> Self {
        self.inner = self.inner.supported_permission_types(input);
        self
    }
    /// <p>Indicates the level of filtering a third-party analytical engine is capable of enforcing when calling the <code>GetUnfilteredTableMetadata</code> API operation. Accepted values are:</p>
    /// <ul>
    /// <li>
    /// <p><code>COLUMN_PERMISSION</code> - Column permissions ensure that users can access only specific columns in the table. If there are particular columns contain sensitive data, data lake administrators can define column filters that exclude access to specific columns.</p></li>
    /// <li>
    /// <p><code>CELL_FILTER_PERMISSION</code> - Cell-level filtering combines column filtering (include or exclude columns) and row filter expressions to restrict access to individual elements in the table.</p></li>
    /// <li>
    /// <p><code>NESTED_PERMISSION</code> - Nested permissions combines cell-level filtering and nested column filtering to restrict access to columns and/or nested columns in specific rows based on row filter expressions.</p></li>
    /// <li>
    /// <p><code>NESTED_CELL_PERMISSION</code> - Nested cell permissions combines nested permission with nested cell-level filtering. This allows different subsets of nested columns to be restricted based on an array of row filter expressions.</p></li>
    /// </ul>
    /// <p>Note: Each of these permission types follows a hierarchical order where each subsequent permission type includes all permission of the previous type.</p>
    /// <p>Important: If you provide a supported permission type that doesn't match the user's level of permissions on the table, then Lake Formation raises an exception. For example, if the third-party engine calling the <code>GetUnfilteredTableMetadata</code> operation can enforce only column-level filtering, and the user has nested cell filtering applied on the table, Lake Formation throws an exception, and will not return unfiltered table metadata and data access credentials.</p>
    pub fn set_supported_permission_types(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::PermissionType>>) -> Self {
        self.inner = self.inner.set_supported_permission_types(input);
        self
    }
    /// <p>Indicates the level of filtering a third-party analytical engine is capable of enforcing when calling the <code>GetUnfilteredTableMetadata</code> API operation. Accepted values are:</p>
    /// <ul>
    /// <li>
    /// <p><code>COLUMN_PERMISSION</code> - Column permissions ensure that users can access only specific columns in the table. If there are particular columns contain sensitive data, data lake administrators can define column filters that exclude access to specific columns.</p></li>
    /// <li>
    /// <p><code>CELL_FILTER_PERMISSION</code> - Cell-level filtering combines column filtering (include or exclude columns) and row filter expressions to restrict access to individual elements in the table.</p></li>
    /// <li>
    /// <p><code>NESTED_PERMISSION</code> - Nested permissions combines cell-level filtering and nested column filtering to restrict access to columns and/or nested columns in specific rows based on row filter expressions.</p></li>
    /// <li>
    /// <p><code>NESTED_CELL_PERMISSION</code> - Nested cell permissions combines nested permission with nested cell-level filtering. This allows different subsets of nested columns to be restricted based on an array of row filter expressions.</p></li>
    /// </ul>
    /// <p>Note: Each of these permission types follows a hierarchical order where each subsequent permission type includes all permission of the previous type.</p>
    /// <p>Important: If you provide a supported permission type that doesn't match the user's level of permissions on the table, then Lake Formation raises an exception. For example, if the third-party engine calling the <code>GetUnfilteredTableMetadata</code> operation can enforce only column-level filtering, and the user has nested cell filtering applied on the table, Lake Formation throws an exception, and will not return unfiltered table metadata and data access credentials.</p>
    pub fn get_supported_permission_types(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::PermissionType>> {
        self.inner.get_supported_permission_types()
    }
    /// <p>The resource ARN of the view.</p>
    pub fn parent_resource_arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.parent_resource_arn(input.into());
        self
    }
    /// <p>The resource ARN of the view.</p>
    pub fn set_parent_resource_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_parent_resource_arn(input);
        self
    }
    /// <p>The resource ARN of the view.</p>
    pub fn get_parent_resource_arn(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_parent_resource_arn()
    }
    /// <p>The resource ARN of the root view in a chain of nested views.</p>
    pub fn root_resource_arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.root_resource_arn(input.into());
        self
    }
    /// <p>The resource ARN of the root view in a chain of nested views.</p>
    pub fn set_root_resource_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_root_resource_arn(input);
        self
    }
    /// <p>The resource ARN of the root view in a chain of nested views.</p>
    pub fn get_root_resource_arn(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_root_resource_arn()
    }
    /// <p>A structure specifying the dialect and dialect version used by the query engine.</p>
    pub fn supported_dialect(mut self, input: crate::types::SupportedDialect) -> Self {
        self.inner = self.inner.supported_dialect(input);
        self
    }
    /// <p>A structure specifying the dialect and dialect version used by the query engine.</p>
    pub fn set_supported_dialect(mut self, input: ::std::option::Option<crate::types::SupportedDialect>) -> Self {
        self.inner = self.inner.set_supported_dialect(input);
        self
    }
    /// <p>A structure specifying the dialect and dialect version used by the query engine.</p>
    pub fn get_supported_dialect(&self) -> &::std::option::Option<crate::types::SupportedDialect> {
        self.inner.get_supported_dialect()
    }
    ///
    /// Appends an item to `Permissions`.
    ///
    /// To override the contents of this collection use [`set_permissions`](Self::set_permissions).
    ///
    /// <p>The Lake Formation data permissions of the caller on the table. Used to authorize the call when no view context is found.</p>
    pub fn permissions(mut self, input: crate::types::Permission) -> Self {
        self.inner = self.inner.permissions(input);
        self
    }
    /// <p>The Lake Formation data permissions of the caller on the table. Used to authorize the call when no view context is found.</p>
    pub fn set_permissions(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::Permission>>) -> Self {
        self.inner = self.inner.set_permissions(input);
        self
    }
    /// <p>The Lake Formation data permissions of the caller on the table. Used to authorize the call when no view context is found.</p>
    pub fn get_permissions(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::Permission>> {
        self.inner.get_permissions()
    }
    /// <p>A structure used as a protocol between query engines and Lake Formation or Glue. Contains both a Lake Formation generated authorization identifier and information from the request's authorization context.</p>
    pub fn query_session_context(mut self, input: crate::types::QuerySessionContext) -> Self {
        self.inner = self.inner.query_session_context(input);
        self
    }
    /// <p>A structure used as a protocol between query engines and Lake Formation or Glue. Contains both a Lake Formation generated authorization identifier and information from the request's authorization context.</p>
    pub fn set_query_session_context(mut self, input: ::std::option::Option<crate::types::QuerySessionContext>) -> Self {
        self.inner = self.inner.set_query_session_context(input);
        self
    }
    /// <p>A structure used as a protocol between query engines and Lake Formation or Glue. Contains both a Lake Formation generated authorization identifier and information from the request's authorization context.</p>
    pub fn get_query_session_context(&self) -> &::std::option::Option<crate::types::QuerySessionContext> {
        self.inner.get_query_session_context()
    }
}
