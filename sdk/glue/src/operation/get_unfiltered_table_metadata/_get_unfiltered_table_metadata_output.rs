// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct GetUnfilteredTableMetadataOutput {
    /// <p>A Table object containing the table metadata.</p>
    pub table: ::std::option::Option<crate::types::Table>,
    /// <p>A list of column names that the user has been granted access to.</p>
    pub authorized_columns: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    /// <p>A Boolean value that indicates whether the partition location is registered with Lake Formation.</p>
    pub is_registered_with_lake_formation: bool,
    /// <p>A list of column row filters.</p>
    pub cell_filters: ::std::option::Option<::std::vec::Vec<crate::types::ColumnRowFilter>>,
    /// <p>A cryptographically generated query identifier generated by Glue or Lake Formation.</p>
    pub query_authorization_id: ::std::option::Option<::std::string::String>,
    /// <p>Specifies whether the view supports the SQL dialects of one or more different query engines and can therefore be read by those engines.</p>
    pub is_multi_dialect_view: bool,
    /// <p>The resource ARN of the parent resource extracted from the request.</p>
    pub resource_arn: ::std::option::Option<::std::string::String>,
    /// <p>A flag that instructs the engine not to push user-provided operations into the logical plan of the view during query planning. However, if set this flag does not guarantee that the engine will comply. Refer to the engine's documentation to understand the guarantees provided, if any.</p>
    pub is_protected: bool,
    /// <p>The Lake Formation data permissions of the caller on the table. Used to authorize the call when no view context is found.</p>
    pub permissions: ::std::option::Option<::std::vec::Vec<crate::types::Permission>>,
    /// <p>The filter that applies to the table. For example when applying the filter in SQL, it would go in the <code>WHERE</code> clause and can be evaluated by using an <code>AND</code> operator with any other predicates applied by the user querying the table.</p>
    pub row_filter: ::std::option::Option<::std::string::String>,
    _request_id: Option<String>,
}
impl GetUnfilteredTableMetadataOutput {
    /// <p>A Table object containing the table metadata.</p>
    pub fn table(&self) -> ::std::option::Option<&crate::types::Table> {
        self.table.as_ref()
    }
    /// <p>A list of column names that the user has been granted access to.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.authorized_columns.is_none()`.
    pub fn authorized_columns(&self) -> &[::std::string::String] {
        self.authorized_columns.as_deref().unwrap_or_default()
    }
    /// <p>A Boolean value that indicates whether the partition location is registered with Lake Formation.</p>
    pub fn is_registered_with_lake_formation(&self) -> bool {
        self.is_registered_with_lake_formation
    }
    /// <p>A list of column row filters.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.cell_filters.is_none()`.
    pub fn cell_filters(&self) -> &[crate::types::ColumnRowFilter] {
        self.cell_filters.as_deref().unwrap_or_default()
    }
    /// <p>A cryptographically generated query identifier generated by Glue or Lake Formation.</p>
    pub fn query_authorization_id(&self) -> ::std::option::Option<&str> {
        self.query_authorization_id.as_deref()
    }
    /// <p>Specifies whether the view supports the SQL dialects of one or more different query engines and can therefore be read by those engines.</p>
    pub fn is_multi_dialect_view(&self) -> bool {
        self.is_multi_dialect_view
    }
    /// <p>The resource ARN of the parent resource extracted from the request.</p>
    pub fn resource_arn(&self) -> ::std::option::Option<&str> {
        self.resource_arn.as_deref()
    }
    /// <p>A flag that instructs the engine not to push user-provided operations into the logical plan of the view during query planning. However, if set this flag does not guarantee that the engine will comply. Refer to the engine's documentation to understand the guarantees provided, if any.</p>
    pub fn is_protected(&self) -> bool {
        self.is_protected
    }
    /// <p>The Lake Formation data permissions of the caller on the table. Used to authorize the call when no view context is found.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.permissions.is_none()`.
    pub fn permissions(&self) -> &[crate::types::Permission] {
        self.permissions.as_deref().unwrap_or_default()
    }
    /// <p>The filter that applies to the table. For example when applying the filter in SQL, it would go in the <code>WHERE</code> clause and can be evaluated by using an <code>AND</code> operator with any other predicates applied by the user querying the table.</p>
    pub fn row_filter(&self) -> ::std::option::Option<&str> {
        self.row_filter.as_deref()
    }
}
impl ::aws_types::request_id::RequestId for GetUnfilteredTableMetadataOutput {
    fn request_id(&self) -> Option<&str> {
        self._request_id.as_deref()
    }
}
impl GetUnfilteredTableMetadataOutput {
    /// Creates a new builder-style object to manufacture [`GetUnfilteredTableMetadataOutput`](crate::operation::get_unfiltered_table_metadata::GetUnfilteredTableMetadataOutput).
    pub fn builder() -> crate::operation::get_unfiltered_table_metadata::builders::GetUnfilteredTableMetadataOutputBuilder {
        crate::operation::get_unfiltered_table_metadata::builders::GetUnfilteredTableMetadataOutputBuilder::default()
    }
}

/// A builder for [`GetUnfilteredTableMetadataOutput`](crate::operation::get_unfiltered_table_metadata::GetUnfilteredTableMetadataOutput).
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
pub struct GetUnfilteredTableMetadataOutputBuilder {
    pub(crate) table: ::std::option::Option<crate::types::Table>,
    pub(crate) authorized_columns: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    pub(crate) is_registered_with_lake_formation: ::std::option::Option<bool>,
    pub(crate) cell_filters: ::std::option::Option<::std::vec::Vec<crate::types::ColumnRowFilter>>,
    pub(crate) query_authorization_id: ::std::option::Option<::std::string::String>,
    pub(crate) is_multi_dialect_view: ::std::option::Option<bool>,
    pub(crate) resource_arn: ::std::option::Option<::std::string::String>,
    pub(crate) is_protected: ::std::option::Option<bool>,
    pub(crate) permissions: ::std::option::Option<::std::vec::Vec<crate::types::Permission>>,
    pub(crate) row_filter: ::std::option::Option<::std::string::String>,
    _request_id: Option<String>,
}
impl GetUnfilteredTableMetadataOutputBuilder {
    /// <p>A Table object containing the table metadata.</p>
    pub fn table(mut self, input: crate::types::Table) -> Self {
        self.table = ::std::option::Option::Some(input);
        self
    }
    /// <p>A Table object containing the table metadata.</p>
    pub fn set_table(mut self, input: ::std::option::Option<crate::types::Table>) -> Self {
        self.table = input;
        self
    }
    /// <p>A Table object containing the table metadata.</p>
    pub fn get_table(&self) -> &::std::option::Option<crate::types::Table> {
        &self.table
    }
    /// Appends an item to `authorized_columns`.
    ///
    /// To override the contents of this collection use [`set_authorized_columns`](Self::set_authorized_columns).
    ///
    /// <p>A list of column names that the user has been granted access to.</p>
    pub fn authorized_columns(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        let mut v = self.authorized_columns.unwrap_or_default();
        v.push(input.into());
        self.authorized_columns = ::std::option::Option::Some(v);
        self
    }
    /// <p>A list of column names that the user has been granted access to.</p>
    pub fn set_authorized_columns(mut self, input: ::std::option::Option<::std::vec::Vec<::std::string::String>>) -> Self {
        self.authorized_columns = input;
        self
    }
    /// <p>A list of column names that the user has been granted access to.</p>
    pub fn get_authorized_columns(&self) -> &::std::option::Option<::std::vec::Vec<::std::string::String>> {
        &self.authorized_columns
    }
    /// <p>A Boolean value that indicates whether the partition location is registered with Lake Formation.</p>
    pub fn is_registered_with_lake_formation(mut self, input: bool) -> Self {
        self.is_registered_with_lake_formation = ::std::option::Option::Some(input);
        self
    }
    /// <p>A Boolean value that indicates whether the partition location is registered with Lake Formation.</p>
    pub fn set_is_registered_with_lake_formation(mut self, input: ::std::option::Option<bool>) -> Self {
        self.is_registered_with_lake_formation = input;
        self
    }
    /// <p>A Boolean value that indicates whether the partition location is registered with Lake Formation.</p>
    pub fn get_is_registered_with_lake_formation(&self) -> &::std::option::Option<bool> {
        &self.is_registered_with_lake_formation
    }
    /// Appends an item to `cell_filters`.
    ///
    /// To override the contents of this collection use [`set_cell_filters`](Self::set_cell_filters).
    ///
    /// <p>A list of column row filters.</p>
    pub fn cell_filters(mut self, input: crate::types::ColumnRowFilter) -> Self {
        let mut v = self.cell_filters.unwrap_or_default();
        v.push(input);
        self.cell_filters = ::std::option::Option::Some(v);
        self
    }
    /// <p>A list of column row filters.</p>
    pub fn set_cell_filters(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::ColumnRowFilter>>) -> Self {
        self.cell_filters = input;
        self
    }
    /// <p>A list of column row filters.</p>
    pub fn get_cell_filters(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::ColumnRowFilter>> {
        &self.cell_filters
    }
    /// <p>A cryptographically generated query identifier generated by Glue or Lake Formation.</p>
    pub fn query_authorization_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.query_authorization_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>A cryptographically generated query identifier generated by Glue or Lake Formation.</p>
    pub fn set_query_authorization_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.query_authorization_id = input;
        self
    }
    /// <p>A cryptographically generated query identifier generated by Glue or Lake Formation.</p>
    pub fn get_query_authorization_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.query_authorization_id
    }
    /// <p>Specifies whether the view supports the SQL dialects of one or more different query engines and can therefore be read by those engines.</p>
    pub fn is_multi_dialect_view(mut self, input: bool) -> Self {
        self.is_multi_dialect_view = ::std::option::Option::Some(input);
        self
    }
    /// <p>Specifies whether the view supports the SQL dialects of one or more different query engines and can therefore be read by those engines.</p>
    pub fn set_is_multi_dialect_view(mut self, input: ::std::option::Option<bool>) -> Self {
        self.is_multi_dialect_view = input;
        self
    }
    /// <p>Specifies whether the view supports the SQL dialects of one or more different query engines and can therefore be read by those engines.</p>
    pub fn get_is_multi_dialect_view(&self) -> &::std::option::Option<bool> {
        &self.is_multi_dialect_view
    }
    /// <p>The resource ARN of the parent resource extracted from the request.</p>
    pub fn resource_arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.resource_arn = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The resource ARN of the parent resource extracted from the request.</p>
    pub fn set_resource_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.resource_arn = input;
        self
    }
    /// <p>The resource ARN of the parent resource extracted from the request.</p>
    pub fn get_resource_arn(&self) -> &::std::option::Option<::std::string::String> {
        &self.resource_arn
    }
    /// <p>A flag that instructs the engine not to push user-provided operations into the logical plan of the view during query planning. However, if set this flag does not guarantee that the engine will comply. Refer to the engine's documentation to understand the guarantees provided, if any.</p>
    pub fn is_protected(mut self, input: bool) -> Self {
        self.is_protected = ::std::option::Option::Some(input);
        self
    }
    /// <p>A flag that instructs the engine not to push user-provided operations into the logical plan of the view during query planning. However, if set this flag does not guarantee that the engine will comply. Refer to the engine's documentation to understand the guarantees provided, if any.</p>
    pub fn set_is_protected(mut self, input: ::std::option::Option<bool>) -> Self {
        self.is_protected = input;
        self
    }
    /// <p>A flag that instructs the engine not to push user-provided operations into the logical plan of the view during query planning. However, if set this flag does not guarantee that the engine will comply. Refer to the engine's documentation to understand the guarantees provided, if any.</p>
    pub fn get_is_protected(&self) -> &::std::option::Option<bool> {
        &self.is_protected
    }
    /// Appends an item to `permissions`.
    ///
    /// To override the contents of this collection use [`set_permissions`](Self::set_permissions).
    ///
    /// <p>The Lake Formation data permissions of the caller on the table. Used to authorize the call when no view context is found.</p>
    pub fn permissions(mut self, input: crate::types::Permission) -> Self {
        let mut v = self.permissions.unwrap_or_default();
        v.push(input);
        self.permissions = ::std::option::Option::Some(v);
        self
    }
    /// <p>The Lake Formation data permissions of the caller on the table. Used to authorize the call when no view context is found.</p>
    pub fn set_permissions(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::Permission>>) -> Self {
        self.permissions = input;
        self
    }
    /// <p>The Lake Formation data permissions of the caller on the table. Used to authorize the call when no view context is found.</p>
    pub fn get_permissions(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::Permission>> {
        &self.permissions
    }
    /// <p>The filter that applies to the table. For example when applying the filter in SQL, it would go in the <code>WHERE</code> clause and can be evaluated by using an <code>AND</code> operator with any other predicates applied by the user querying the table.</p>
    pub fn row_filter(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.row_filter = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The filter that applies to the table. For example when applying the filter in SQL, it would go in the <code>WHERE</code> clause and can be evaluated by using an <code>AND</code> operator with any other predicates applied by the user querying the table.</p>
    pub fn set_row_filter(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.row_filter = input;
        self
    }
    /// <p>The filter that applies to the table. For example when applying the filter in SQL, it would go in the <code>WHERE</code> clause and can be evaluated by using an <code>AND</code> operator with any other predicates applied by the user querying the table.</p>
    pub fn get_row_filter(&self) -> &::std::option::Option<::std::string::String> {
        &self.row_filter
    }
    pub(crate) fn _request_id(mut self, request_id: impl Into<String>) -> Self {
        self._request_id = Some(request_id.into());
        self
    }

    pub(crate) fn _set_request_id(&mut self, request_id: Option<String>) -> &mut Self {
        self._request_id = request_id;
        self
    }
    /// Consumes the builder and constructs a [`GetUnfilteredTableMetadataOutput`](crate::operation::get_unfiltered_table_metadata::GetUnfilteredTableMetadataOutput).
    pub fn build(self) -> crate::operation::get_unfiltered_table_metadata::GetUnfilteredTableMetadataOutput {
        crate::operation::get_unfiltered_table_metadata::GetUnfilteredTableMetadataOutput {
            table: self.table,
            authorized_columns: self.authorized_columns,
            is_registered_with_lake_formation: self.is_registered_with_lake_formation.unwrap_or_default(),
            cell_filters: self.cell_filters,
            query_authorization_id: self.query_authorization_id,
            is_multi_dialect_view: self.is_multi_dialect_view.unwrap_or_default(),
            resource_arn: self.resource_arn,
            is_protected: self.is_protected.unwrap_or_default(),
            permissions: self.permissions,
            row_filter: self.row_filter,
            _request_id: self._request_id,
        }
    }
}
