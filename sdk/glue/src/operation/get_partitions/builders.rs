// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
pub use crate::operation::get_partitions::_get_partitions_output::GetPartitionsOutputBuilder;

pub use crate::operation::get_partitions::_get_partitions_input::GetPartitionsInputBuilder;

/// Fluent builder constructing a request to `GetPartitions`.
/// 
/// <p>Retrieves information about the partitions in a table.</p>
#[derive(std::clone::Clone, std::fmt::Debug)]
pub struct GetPartitionsFluentBuilder {
                handle: std::sync::Arc<crate::client::Handle>,
                inner: crate::operation::get_partitions::builders::GetPartitionsInputBuilder
            }
impl GetPartitionsFluentBuilder  {
    /// Creates a new `GetPartitions`.
                    pub(crate) fn new(handle: std::sync::Arc<crate::client::Handle>) -> Self {
                        Self { handle, inner: Default::default() }
                    }
    
                    /// Consume this builder, creating a customizable operation that can be modified before being
                    /// sent. The operation's inner [http::Request] can be modified as well.
                    pub async fn customize(self) -> std::result::Result<
                        crate::client::customize::CustomizableOperation<crate::operation::get_partitions::GetPartitions, aws_http::retry::AwsResponseRetryClassifier,>,
                        aws_smithy_http::result::SdkError<crate::operation::get_partitions::GetPartitionsError>
                    >  {
                        let handle = self.handle.clone();
                        let operation = self.inner.build().map_err(aws_smithy_http::result::SdkError::construction_failure)?
                            .make_operation(&handle.conf)
                            .await
                            .map_err(aws_smithy_http::result::SdkError::construction_failure)?;
                        Ok(crate::client::customize::CustomizableOperation { handle, operation })
                    }
    
                    /// Sends the request and returns the response.
                    ///
                    /// If an error occurs, an `SdkError` will be returned with additional details that
                    /// can be matched against.
                    ///
                    /// By default, any retryable failures will be retried twice. Retry behavior
                    /// is configurable with the [RetryConfig](aws_smithy_types::retry::RetryConfig), which can be
                    /// set when configuring the client.
                    pub async fn send(self) -> std::result::Result<crate::operation::get_partitions::GetPartitionsOutput, aws_smithy_http::result::SdkError<crate::operation::get_partitions::GetPartitionsError>>
                     {
                        let op = self.inner.build().map_err(aws_smithy_http::result::SdkError::construction_failure)?
                            .make_operation(&self.handle.conf)
                            .await
                            .map_err(aws_smithy_http::result::SdkError::construction_failure)?;
                        self.handle.client.call(op).await
                    }
    /// Create a paginator for this request
                        ///
                        /// Paginators are used by calling [`send().await`](crate::operation::get_partitions::paginator::GetPartitionsPaginator::send) which returns a `Stream`.
                        pub fn into_paginator(self) -> crate::operation::get_partitions::paginator::GetPartitionsPaginator {
                            crate::operation::get_partitions::paginator::GetPartitionsPaginator::new(self.handle, self.inner)
                        }
    /// <p>The ID of the Data Catalog where the partitions in question reside. If none is provided, the Amazon Web Services account ID is used by default.</p>
    pub fn catalog_id(mut self, input: impl Into<std::string::String>) -> Self {
        self.inner = self.inner.catalog_id(input.into());
        self
    }
    /// <p>The ID of the Data Catalog where the partitions in question reside. If none is provided, the Amazon Web Services account ID is used by default.</p>
    pub fn set_catalog_id(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.inner = self.inner.set_catalog_id(input);
        self
    }
    /// <p>The name of the catalog database where the partitions reside.</p>
    pub fn database_name(mut self, input: impl Into<std::string::String>) -> Self {
        self.inner = self.inner.database_name(input.into());
        self
    }
    /// <p>The name of the catalog database where the partitions reside.</p>
    pub fn set_database_name(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.inner = self.inner.set_database_name(input);
        self
    }
    /// <p>The name of the partitions' table.</p>
    pub fn table_name(mut self, input: impl Into<std::string::String>) -> Self {
        self.inner = self.inner.table_name(input.into());
        self
    }
    /// <p>The name of the partitions' table.</p>
    pub fn set_table_name(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.inner = self.inner.set_table_name(input);
        self
    }
    /// <p>An expression that filters the partitions to be returned.</p> 
    /// <p>The expression uses SQL syntax similar to the SQL <code>WHERE</code> filter clause. The SQL statement parser <a href="http://jsqlparser.sourceforge.net/home.php">JSQLParser</a> parses the expression. </p> 
    /// <p> <i>Operators</i>: The following are the operators that you can use in the <code>Expression</code> API call:</p> 
    /// <dl> 
    /// <dt>
    /// =
    /// </dt> 
    /// <dd> 
    /// <p>Checks whether the values of the two operands are equal; if yes, then the condition becomes true.</p> 
    /// <p>Example: Assume 'variable a' holds 10 and 'variable b' holds 20. </p> 
    /// <p>(a = b) is not true.</p> 
    /// </dd> 
    /// <dt>
    /// &lt; &gt;
    /// </dt> 
    /// <dd> 
    /// <p>Checks whether the values of two operands are equal; if the values are not equal, then the condition becomes true.</p> 
    /// <p>Example: (a &lt; &gt; b) is true.</p> 
    /// </dd> 
    /// <dt>
    /// &gt;
    /// </dt> 
    /// <dd> 
    /// <p>Checks whether the value of the left operand is greater than the value of the right operand; if yes, then the condition becomes true.</p> 
    /// <p>Example: (a &gt; b) is not true.</p> 
    /// </dd> 
    /// <dt>
    /// &lt;
    /// </dt> 
    /// <dd> 
    /// <p>Checks whether the value of the left operand is less than the value of the right operand; if yes, then the condition becomes true.</p> 
    /// <p>Example: (a &lt; b) is true.</p> 
    /// </dd> 
    /// <dt>
    /// &gt;=
    /// </dt> 
    /// <dd> 
    /// <p>Checks whether the value of the left operand is greater than or equal to the value of the right operand; if yes, then the condition becomes true.</p> 
    /// <p>Example: (a &gt;= b) is not true.</p> 
    /// </dd> 
    /// <dt>
    /// &lt;=
    /// </dt> 
    /// <dd> 
    /// <p>Checks whether the value of the left operand is less than or equal to the value of the right operand; if yes, then the condition becomes true.</p> 
    /// <p>Example: (a &lt;= b) is true.</p> 
    /// </dd> 
    /// <dt>
    /// AND, OR, IN, BETWEEN, LIKE, NOT, IS NULL
    /// </dt> 
    /// <dd> 
    /// <p>Logical operators.</p> 
    /// </dd> 
    /// </dl> 
    /// <p> <i>Supported Partition Key Types</i>: The following are the supported partition keys.</p> 
    /// <ul> 
    /// <li> <p> <code>string</code> </p> </li> 
    /// <li> <p> <code>date</code> </p> </li> 
    /// <li> <p> <code>timestamp</code> </p> </li> 
    /// <li> <p> <code>int</code> </p> </li> 
    /// <li> <p> <code>bigint</code> </p> </li> 
    /// <li> <p> <code>long</code> </p> </li> 
    /// <li> <p> <code>tinyint</code> </p> </li> 
    /// <li> <p> <code>smallint</code> </p> </li> 
    /// <li> <p> <code>decimal</code> </p> </li> 
    /// </ul> 
    /// <p>If an type is encountered that is not valid, an exception is thrown. </p> 
    /// <p>The following list shows the valid operators on each type. When you define a crawler, the <code>partitionKey</code> type is created as a <code>STRING</code>, to be compatible with the catalog partitions. </p> 
    /// <p> <i>Sample API Call</i>: </p>
    pub fn expression(mut self, input: impl Into<std::string::String>) -> Self {
        self.inner = self.inner.expression(input.into());
        self
    }
    /// <p>An expression that filters the partitions to be returned.</p> 
    /// <p>The expression uses SQL syntax similar to the SQL <code>WHERE</code> filter clause. The SQL statement parser <a href="http://jsqlparser.sourceforge.net/home.php">JSQLParser</a> parses the expression. </p> 
    /// <p> <i>Operators</i>: The following are the operators that you can use in the <code>Expression</code> API call:</p> 
    /// <dl> 
    /// <dt>
    /// =
    /// </dt> 
    /// <dd> 
    /// <p>Checks whether the values of the two operands are equal; if yes, then the condition becomes true.</p> 
    /// <p>Example: Assume 'variable a' holds 10 and 'variable b' holds 20. </p> 
    /// <p>(a = b) is not true.</p> 
    /// </dd> 
    /// <dt>
    /// &lt; &gt;
    /// </dt> 
    /// <dd> 
    /// <p>Checks whether the values of two operands are equal; if the values are not equal, then the condition becomes true.</p> 
    /// <p>Example: (a &lt; &gt; b) is true.</p> 
    /// </dd> 
    /// <dt>
    /// &gt;
    /// </dt> 
    /// <dd> 
    /// <p>Checks whether the value of the left operand is greater than the value of the right operand; if yes, then the condition becomes true.</p> 
    /// <p>Example: (a &gt; b) is not true.</p> 
    /// </dd> 
    /// <dt>
    /// &lt;
    /// </dt> 
    /// <dd> 
    /// <p>Checks whether the value of the left operand is less than the value of the right operand; if yes, then the condition becomes true.</p> 
    /// <p>Example: (a &lt; b) is true.</p> 
    /// </dd> 
    /// <dt>
    /// &gt;=
    /// </dt> 
    /// <dd> 
    /// <p>Checks whether the value of the left operand is greater than or equal to the value of the right operand; if yes, then the condition becomes true.</p> 
    /// <p>Example: (a &gt;= b) is not true.</p> 
    /// </dd> 
    /// <dt>
    /// &lt;=
    /// </dt> 
    /// <dd> 
    /// <p>Checks whether the value of the left operand is less than or equal to the value of the right operand; if yes, then the condition becomes true.</p> 
    /// <p>Example: (a &lt;= b) is true.</p> 
    /// </dd> 
    /// <dt>
    /// AND, OR, IN, BETWEEN, LIKE, NOT, IS NULL
    /// </dt> 
    /// <dd> 
    /// <p>Logical operators.</p> 
    /// </dd> 
    /// </dl> 
    /// <p> <i>Supported Partition Key Types</i>: The following are the supported partition keys.</p> 
    /// <ul> 
    /// <li> <p> <code>string</code> </p> </li> 
    /// <li> <p> <code>date</code> </p> </li> 
    /// <li> <p> <code>timestamp</code> </p> </li> 
    /// <li> <p> <code>int</code> </p> </li> 
    /// <li> <p> <code>bigint</code> </p> </li> 
    /// <li> <p> <code>long</code> </p> </li> 
    /// <li> <p> <code>tinyint</code> </p> </li> 
    /// <li> <p> <code>smallint</code> </p> </li> 
    /// <li> <p> <code>decimal</code> </p> </li> 
    /// </ul> 
    /// <p>If an type is encountered that is not valid, an exception is thrown. </p> 
    /// <p>The following list shows the valid operators on each type. When you define a crawler, the <code>partitionKey</code> type is created as a <code>STRING</code>, to be compatible with the catalog partitions. </p> 
    /// <p> <i>Sample API Call</i>: </p>
    pub fn set_expression(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.inner = self.inner.set_expression(input);
        self
    }
    /// <p>A continuation token, if this is not the first call to retrieve these partitions.</p>
    pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
        self.inner = self.inner.next_token(input.into());
        self
    }
    /// <p>A continuation token, if this is not the first call to retrieve these partitions.</p>
    pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.inner = self.inner.set_next_token(input);
        self
    }
    /// <p>The segment of the table's partitions to scan in this request.</p>
    pub fn segment(mut self, input: crate::types::Segment) -> Self {
        self.inner = self.inner.segment(input);
        self
    }
    /// <p>The segment of the table's partitions to scan in this request.</p>
    pub fn set_segment(mut self, input: std::option::Option<crate::types::Segment>) -> Self {
        self.inner = self.inner.set_segment(input);
        self
    }
    /// <p>The maximum number of partitions to return in a single response.</p>
    pub fn max_results(mut self, input: i32) -> Self {
        self.inner = self.inner.max_results(input);
        self
    }
    /// <p>The maximum number of partitions to return in a single response.</p>
    pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
        self.inner = self.inner.set_max_results(input);
        self
    }
    /// <p>When true, specifies not returning the partition column schema. Useful when you are interested only in other partition attributes such as partition values or location. This approach avoids the problem of a large response by not returning duplicate data.</p>
    pub fn exclude_column_schema(mut self, input: bool) -> Self {
        self.inner = self.inner.exclude_column_schema(input);
        self
    }
    /// <p>When true, specifies not returning the partition column schema. Useful when you are interested only in other partition attributes such as partition values or location. This approach avoids the problem of a large response by not returning duplicate data.</p>
    pub fn set_exclude_column_schema(mut self, input: std::option::Option<bool>) -> Self {
        self.inner = self.inner.set_exclude_column_schema(input);
        self
    }
    /// <p>The transaction ID at which to read the partition contents.</p>
    pub fn transaction_id(mut self, input: impl Into<std::string::String>) -> Self {
        self.inner = self.inner.transaction_id(input.into());
        self
    }
    /// <p>The transaction ID at which to read the partition contents.</p>
    pub fn set_transaction_id(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.inner = self.inner.set_transaction_id(input);
        self
    }
    /// <p>The time as of when to read the partition contents. If not set, the most recent transaction commit time will be used. Cannot be specified along with <code>TransactionId</code>.</p>
    pub fn query_as_of_time(mut self, input: aws_smithy_types::DateTime) -> Self {
        self.inner = self.inner.query_as_of_time(input);
        self
    }
    /// <p>The time as of when to read the partition contents. If not set, the most recent transaction commit time will be used. Cannot be specified along with <code>TransactionId</code>.</p>
    pub fn set_query_as_of_time(mut self, input: std::option::Option<aws_smithy_types::DateTime>) -> Self {
        self.inner = self.inner.set_query_as_of_time(input);
        self
    }
}

