// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
pub use crate::operation::get_partitions::_get_partitions_output::GetPartitionsOutputBuilder;

pub use crate::operation::get_partitions::_get_partitions_input::GetPartitionsInputBuilder;

impl crate::operation::get_partitions::builders::GetPartitionsInputBuilder {
    /// Sends a request with this input using the given client.
    pub async fn send_with(
        self,
        client: &crate::Client,
    ) -> ::std::result::Result<
        crate::operation::get_partitions::GetPartitionsOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::get_partitions::GetPartitionsError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let mut fluent_builder = client.get_partitions();
        fluent_builder.inner = self;
        fluent_builder.send().await
    }
}
/// Fluent builder constructing a request to `GetPartitions`.
///
/// <p>Retrieves information about the partitions in a table.</p>
#[derive(::std::clone::Clone, ::std::fmt::Debug)]
pub struct GetPartitionsFluentBuilder {
    handle: ::std::sync::Arc<crate::client::Handle>,
    inner: crate::operation::get_partitions::builders::GetPartitionsInputBuilder,
    config_override: ::std::option::Option<crate::config::Builder>,
}
impl
    crate::client::customize::internal::CustomizableSend<
        crate::operation::get_partitions::GetPartitionsOutput,
        crate::operation::get_partitions::GetPartitionsError,
    > for GetPartitionsFluentBuilder
{
    fn send(
        self,
        config_override: crate::config::Builder,
    ) -> crate::client::customize::internal::BoxFuture<
        crate::client::customize::internal::SendResult<
            crate::operation::get_partitions::GetPartitionsOutput,
            crate::operation::get_partitions::GetPartitionsError,
        >,
    > {
        ::std::boxed::Box::pin(async move { self.config_override(config_override).send().await })
    }
}
impl GetPartitionsFluentBuilder {
    /// Creates a new `GetPartitions`.
    pub(crate) fn new(handle: ::std::sync::Arc<crate::client::Handle>) -> Self {
        Self {
            handle,
            inner: ::std::default::Default::default(),
            config_override: ::std::option::Option::None,
        }
    }
    /// Access the GetPartitions as a reference.
    pub fn as_input(&self) -> &crate::operation::get_partitions::builders::GetPartitionsInputBuilder {
        &self.inner
    }
    /// Sends the request and returns the response.
    ///
    /// If an error occurs, an `SdkError` will be returned with additional details that
    /// can be matched against.
    ///
    /// By default, any retryable failures will be retried twice. Retry behavior
    /// is configurable with the [RetryConfig](aws_smithy_types::retry::RetryConfig), which can be
    /// set when configuring the client.
    pub async fn send(
        self,
    ) -> ::std::result::Result<
        crate::operation::get_partitions::GetPartitionsOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::get_partitions::GetPartitionsError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let input = self
            .inner
            .build()
            .map_err(::aws_smithy_runtime_api::client::result::SdkError::construction_failure)?;
        let runtime_plugins = crate::operation::get_partitions::GetPartitions::operation_runtime_plugins(
            self.handle.runtime_plugins.clone(),
            &self.handle.conf,
            self.config_override,
        );
        crate::operation::get_partitions::GetPartitions::orchestrate(&runtime_plugins, input).await
    }

    /// Consumes this builder, creating a customizable operation that can be modified before being sent.
    pub fn customize(
        self,
    ) -> crate::client::customize::CustomizableOperation<
        crate::operation::get_partitions::GetPartitionsOutput,
        crate::operation::get_partitions::GetPartitionsError,
        Self,
    > {
        crate::client::customize::CustomizableOperation::new(self)
    }
    pub(crate) fn config_override(mut self, config_override: impl ::std::convert::Into<crate::config::Builder>) -> Self {
        self.set_config_override(::std::option::Option::Some(config_override.into()));
        self
    }

    pub(crate) fn set_config_override(&mut self, config_override: ::std::option::Option<crate::config::Builder>) -> &mut Self {
        self.config_override = config_override;
        self
    }
    /// Create a paginator for this request
    ///
    /// Paginators are used by calling [`send().await`](crate::operation::get_partitions::paginator::GetPartitionsPaginator::send) which returns a [`PaginationStream`](aws_smithy_async::future::pagination_stream::PaginationStream).
    pub fn into_paginator(self) -> crate::operation::get_partitions::paginator::GetPartitionsPaginator {
        crate::operation::get_partitions::paginator::GetPartitionsPaginator::new(self.handle, self.inner)
    }
    /// <p>The ID of the Data Catalog where the partitions in question reside. If none is provided, the Amazon Web Services account ID is used by default.</p>
    pub fn catalog_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.catalog_id(input.into());
        self
    }
    /// <p>The ID of the Data Catalog where the partitions in question reside. If none is provided, the Amazon Web Services account ID is used by default.</p>
    pub fn set_catalog_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_catalog_id(input);
        self
    }
    /// <p>The ID of the Data Catalog where the partitions in question reside. If none is provided, the Amazon Web Services account ID is used by default.</p>
    pub fn get_catalog_id(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_catalog_id()
    }
    /// <p>The name of the catalog database where the partitions reside.</p>
    pub fn database_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.database_name(input.into());
        self
    }
    /// <p>The name of the catalog database where the partitions reside.</p>
    pub fn set_database_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_database_name(input);
        self
    }
    /// <p>The name of the catalog database where the partitions reside.</p>
    pub fn get_database_name(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_database_name()
    }
    /// <p>The name of the partitions' table.</p>
    pub fn table_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.table_name(input.into());
        self
    }
    /// <p>The name of the partitions' table.</p>
    pub fn set_table_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_table_name(input);
        self
    }
    /// <p>The name of the partitions' table.</p>
    pub fn get_table_name(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_table_name()
    }
    /// <p>An expression that filters the partitions to be returned.</p>
    /// <p>The expression uses SQL syntax similar to the SQL <code>WHERE</code> filter clause. The SQL statement parser <a href="http://jsqlparser.sourceforge.net/home.php">JSQLParser</a> parses the expression.</p>
    /// <p><i>Operators</i>: The following are the operators that you can use in the <code>Expression</code> API call:</p>
    /// <dl>
    /// <dt>
    /// =
    /// </dt>
    /// <dd>
    /// <p>Checks whether the values of the two operands are equal; if yes, then the condition becomes true.</p>
    /// <p>Example: Assume 'variable a' holds 10 and 'variable b' holds 20.</p>
    /// <p>(a = b) is not true.</p>
    /// </dd>
    /// <dt>
    /// &lt; &gt;
    /// </dt>
    /// <dd>
    /// <p>Checks whether the values of two operands are equal; if the values are not equal, then the condition becomes true.</p>
    /// <p>Example: (a &lt; &gt; b) is true.</p>
    /// </dd>
    /// <dt>
    /// &gt;
    /// </dt>
    /// <dd>
    /// <p>Checks whether the value of the left operand is greater than the value of the right operand; if yes, then the condition becomes true.</p>
    /// <p>Example: (a &gt; b) is not true.</p>
    /// </dd>
    /// <dt>
    /// &lt;
    /// </dt>
    /// <dd>
    /// <p>Checks whether the value of the left operand is less than the value of the right operand; if yes, then the condition becomes true.</p>
    /// <p>Example: (a &lt; b) is true.</p>
    /// </dd>
    /// <dt>
    /// &gt;=
    /// </dt>
    /// <dd>
    /// <p>Checks whether the value of the left operand is greater than or equal to the value of the right operand; if yes, then the condition becomes true.</p>
    /// <p>Example: (a &gt;= b) is not true.</p>
    /// </dd>
    /// <dt>
    /// &lt;=
    /// </dt>
    /// <dd>
    /// <p>Checks whether the value of the left operand is less than or equal to the value of the right operand; if yes, then the condition becomes true.</p>
    /// <p>Example: (a &lt;= b) is true.</p>
    /// </dd>
    /// <dt>
    /// AND, OR, IN, BETWEEN, LIKE, NOT, IS NULL
    /// </dt>
    /// <dd>
    /// <p>Logical operators.</p>
    /// </dd>
    /// </dl>
    /// <p><i>Supported Partition Key Types</i>: The following are the supported partition keys.</p>
    /// <ul>
    /// <li>
    /// <p><code>string</code></p></li>
    /// <li>
    /// <p><code>date</code></p></li>
    /// <li>
    /// <p><code>timestamp</code></p></li>
    /// <li>
    /// <p><code>int</code></p></li>
    /// <li>
    /// <p><code>bigint</code></p></li>
    /// <li>
    /// <p><code>long</code></p></li>
    /// <li>
    /// <p><code>tinyint</code></p></li>
    /// <li>
    /// <p><code>smallint</code></p></li>
    /// <li>
    /// <p><code>decimal</code></p></li>
    /// </ul>
    /// <p>If an type is encountered that is not valid, an exception is thrown.</p>
    /// <p>The following list shows the valid operators on each type. When you define a crawler, the <code>partitionKey</code> type is created as a <code>STRING</code>, to be compatible with the catalog partitions.</p>
    /// <p><i>Sample API Call</i>:</p>
    pub fn expression(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.expression(input.into());
        self
    }
    /// <p>An expression that filters the partitions to be returned.</p>
    /// <p>The expression uses SQL syntax similar to the SQL <code>WHERE</code> filter clause. The SQL statement parser <a href="http://jsqlparser.sourceforge.net/home.php">JSQLParser</a> parses the expression.</p>
    /// <p><i>Operators</i>: The following are the operators that you can use in the <code>Expression</code> API call:</p>
    /// <dl>
    /// <dt>
    /// =
    /// </dt>
    /// <dd>
    /// <p>Checks whether the values of the two operands are equal; if yes, then the condition becomes true.</p>
    /// <p>Example: Assume 'variable a' holds 10 and 'variable b' holds 20.</p>
    /// <p>(a = b) is not true.</p>
    /// </dd>
    /// <dt>
    /// &lt; &gt;
    /// </dt>
    /// <dd>
    /// <p>Checks whether the values of two operands are equal; if the values are not equal, then the condition becomes true.</p>
    /// <p>Example: (a &lt; &gt; b) is true.</p>
    /// </dd>
    /// <dt>
    /// &gt;
    /// </dt>
    /// <dd>
    /// <p>Checks whether the value of the left operand is greater than the value of the right operand; if yes, then the condition becomes true.</p>
    /// <p>Example: (a &gt; b) is not true.</p>
    /// </dd>
    /// <dt>
    /// &lt;
    /// </dt>
    /// <dd>
    /// <p>Checks whether the value of the left operand is less than the value of the right operand; if yes, then the condition becomes true.</p>
    /// <p>Example: (a &lt; b) is true.</p>
    /// </dd>
    /// <dt>
    /// &gt;=
    /// </dt>
    /// <dd>
    /// <p>Checks whether the value of the left operand is greater than or equal to the value of the right operand; if yes, then the condition becomes true.</p>
    /// <p>Example: (a &gt;= b) is not true.</p>
    /// </dd>
    /// <dt>
    /// &lt;=
    /// </dt>
    /// <dd>
    /// <p>Checks whether the value of the left operand is less than or equal to the value of the right operand; if yes, then the condition becomes true.</p>
    /// <p>Example: (a &lt;= b) is true.</p>
    /// </dd>
    /// <dt>
    /// AND, OR, IN, BETWEEN, LIKE, NOT, IS NULL
    /// </dt>
    /// <dd>
    /// <p>Logical operators.</p>
    /// </dd>
    /// </dl>
    /// <p><i>Supported Partition Key Types</i>: The following are the supported partition keys.</p>
    /// <ul>
    /// <li>
    /// <p><code>string</code></p></li>
    /// <li>
    /// <p><code>date</code></p></li>
    /// <li>
    /// <p><code>timestamp</code></p></li>
    /// <li>
    /// <p><code>int</code></p></li>
    /// <li>
    /// <p><code>bigint</code></p></li>
    /// <li>
    /// <p><code>long</code></p></li>
    /// <li>
    /// <p><code>tinyint</code></p></li>
    /// <li>
    /// <p><code>smallint</code></p></li>
    /// <li>
    /// <p><code>decimal</code></p></li>
    /// </ul>
    /// <p>If an type is encountered that is not valid, an exception is thrown.</p>
    /// <p>The following list shows the valid operators on each type. When you define a crawler, the <code>partitionKey</code> type is created as a <code>STRING</code>, to be compatible with the catalog partitions.</p>
    /// <p><i>Sample API Call</i>:</p>
    pub fn set_expression(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_expression(input);
        self
    }
    /// <p>An expression that filters the partitions to be returned.</p>
    /// <p>The expression uses SQL syntax similar to the SQL <code>WHERE</code> filter clause. The SQL statement parser <a href="http://jsqlparser.sourceforge.net/home.php">JSQLParser</a> parses the expression.</p>
    /// <p><i>Operators</i>: The following are the operators that you can use in the <code>Expression</code> API call:</p>
    /// <dl>
    /// <dt>
    /// =
    /// </dt>
    /// <dd>
    /// <p>Checks whether the values of the two operands are equal; if yes, then the condition becomes true.</p>
    /// <p>Example: Assume 'variable a' holds 10 and 'variable b' holds 20.</p>
    /// <p>(a = b) is not true.</p>
    /// </dd>
    /// <dt>
    /// &lt; &gt;
    /// </dt>
    /// <dd>
    /// <p>Checks whether the values of two operands are equal; if the values are not equal, then the condition becomes true.</p>
    /// <p>Example: (a &lt; &gt; b) is true.</p>
    /// </dd>
    /// <dt>
    /// &gt;
    /// </dt>
    /// <dd>
    /// <p>Checks whether the value of the left operand is greater than the value of the right operand; if yes, then the condition becomes true.</p>
    /// <p>Example: (a &gt; b) is not true.</p>
    /// </dd>
    /// <dt>
    /// &lt;
    /// </dt>
    /// <dd>
    /// <p>Checks whether the value of the left operand is less than the value of the right operand; if yes, then the condition becomes true.</p>
    /// <p>Example: (a &lt; b) is true.</p>
    /// </dd>
    /// <dt>
    /// &gt;=
    /// </dt>
    /// <dd>
    /// <p>Checks whether the value of the left operand is greater than or equal to the value of the right operand; if yes, then the condition becomes true.</p>
    /// <p>Example: (a &gt;= b) is not true.</p>
    /// </dd>
    /// <dt>
    /// &lt;=
    /// </dt>
    /// <dd>
    /// <p>Checks whether the value of the left operand is less than or equal to the value of the right operand; if yes, then the condition becomes true.</p>
    /// <p>Example: (a &lt;= b) is true.</p>
    /// </dd>
    /// <dt>
    /// AND, OR, IN, BETWEEN, LIKE, NOT, IS NULL
    /// </dt>
    /// <dd>
    /// <p>Logical operators.</p>
    /// </dd>
    /// </dl>
    /// <p><i>Supported Partition Key Types</i>: The following are the supported partition keys.</p>
    /// <ul>
    /// <li>
    /// <p><code>string</code></p></li>
    /// <li>
    /// <p><code>date</code></p></li>
    /// <li>
    /// <p><code>timestamp</code></p></li>
    /// <li>
    /// <p><code>int</code></p></li>
    /// <li>
    /// <p><code>bigint</code></p></li>
    /// <li>
    /// <p><code>long</code></p></li>
    /// <li>
    /// <p><code>tinyint</code></p></li>
    /// <li>
    /// <p><code>smallint</code></p></li>
    /// <li>
    /// <p><code>decimal</code></p></li>
    /// </ul>
    /// <p>If an type is encountered that is not valid, an exception is thrown.</p>
    /// <p>The following list shows the valid operators on each type. When you define a crawler, the <code>partitionKey</code> type is created as a <code>STRING</code>, to be compatible with the catalog partitions.</p>
    /// <p><i>Sample API Call</i>:</p>
    pub fn get_expression(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_expression()
    }
    /// <p>A continuation token, if this is not the first call to retrieve these partitions.</p>
    pub fn next_token(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.next_token(input.into());
        self
    }
    /// <p>A continuation token, if this is not the first call to retrieve these partitions.</p>
    pub fn set_next_token(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_next_token(input);
        self
    }
    /// <p>A continuation token, if this is not the first call to retrieve these partitions.</p>
    pub fn get_next_token(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_next_token()
    }
    /// <p>The segment of the table's partitions to scan in this request.</p>
    pub fn segment(mut self, input: crate::types::Segment) -> Self {
        self.inner = self.inner.segment(input);
        self
    }
    /// <p>The segment of the table's partitions to scan in this request.</p>
    pub fn set_segment(mut self, input: ::std::option::Option<crate::types::Segment>) -> Self {
        self.inner = self.inner.set_segment(input);
        self
    }
    /// <p>The segment of the table's partitions to scan in this request.</p>
    pub fn get_segment(&self) -> &::std::option::Option<crate::types::Segment> {
        self.inner.get_segment()
    }
    /// <p>The maximum number of partitions to return in a single response.</p>
    pub fn max_results(mut self, input: i32) -> Self {
        self.inner = self.inner.max_results(input);
        self
    }
    /// <p>The maximum number of partitions to return in a single response.</p>
    pub fn set_max_results(mut self, input: ::std::option::Option<i32>) -> Self {
        self.inner = self.inner.set_max_results(input);
        self
    }
    /// <p>The maximum number of partitions to return in a single response.</p>
    pub fn get_max_results(&self) -> &::std::option::Option<i32> {
        self.inner.get_max_results()
    }
    /// <p>When true, specifies not returning the partition column schema. Useful when you are interested only in other partition attributes such as partition values or location. This approach avoids the problem of a large response by not returning duplicate data.</p>
    pub fn exclude_column_schema(mut self, input: bool) -> Self {
        self.inner = self.inner.exclude_column_schema(input);
        self
    }
    /// <p>When true, specifies not returning the partition column schema. Useful when you are interested only in other partition attributes such as partition values or location. This approach avoids the problem of a large response by not returning duplicate data.</p>
    pub fn set_exclude_column_schema(mut self, input: ::std::option::Option<bool>) -> Self {
        self.inner = self.inner.set_exclude_column_schema(input);
        self
    }
    /// <p>When true, specifies not returning the partition column schema. Useful when you are interested only in other partition attributes such as partition values or location. This approach avoids the problem of a large response by not returning duplicate data.</p>
    pub fn get_exclude_column_schema(&self) -> &::std::option::Option<bool> {
        self.inner.get_exclude_column_schema()
    }
    /// <p>The transaction ID at which to read the partition contents.</p>
    pub fn transaction_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.transaction_id(input.into());
        self
    }
    /// <p>The transaction ID at which to read the partition contents.</p>
    pub fn set_transaction_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_transaction_id(input);
        self
    }
    /// <p>The transaction ID at which to read the partition contents.</p>
    pub fn get_transaction_id(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_transaction_id()
    }
    /// <p>The time as of when to read the partition contents. If not set, the most recent transaction commit time will be used. Cannot be specified along with <code>TransactionId</code>.</p>
    pub fn query_as_of_time(mut self, input: ::aws_smithy_types::DateTime) -> Self {
        self.inner = self.inner.query_as_of_time(input);
        self
    }
    /// <p>The time as of when to read the partition contents. If not set, the most recent transaction commit time will be used. Cannot be specified along with <code>TransactionId</code>.</p>
    pub fn set_query_as_of_time(mut self, input: ::std::option::Option<::aws_smithy_types::DateTime>) -> Self {
        self.inner = self.inner.set_query_as_of_time(input);
        self
    }
    /// <p>The time as of when to read the partition contents. If not set, the most recent transaction commit time will be used. Cannot be specified along with <code>TransactionId</code>.</p>
    pub fn get_query_as_of_time(&self) -> &::std::option::Option<::aws_smithy_types::DateTime> {
        self.inner.get_query_as_of_time()
    }
}
