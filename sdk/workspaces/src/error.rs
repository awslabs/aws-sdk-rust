// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AssociateConnectionAliasError {
    pub kind: AssociateConnectionAliasErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AssociateConnectionAliasErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InvalidParameterValuesException(crate::error::InvalidParameterValuesException),
    InvalidResourceStateException(crate::error::InvalidResourceStateException),
    OperationNotSupportedException(crate::error::OperationNotSupportedException),
    ResourceAssociatedException(crate::error::ResourceAssociatedException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AssociateConnectionAliasError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AssociateConnectionAliasErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            AssociateConnectionAliasErrorKind::InvalidParameterValuesException(_inner) => {
                _inner.fmt(f)
            }
            AssociateConnectionAliasErrorKind::InvalidResourceStateException(_inner) => {
                _inner.fmt(f)
            }
            AssociateConnectionAliasErrorKind::OperationNotSupportedException(_inner) => {
                _inner.fmt(f)
            }
            AssociateConnectionAliasErrorKind::ResourceAssociatedException(_inner) => _inner.fmt(f),
            AssociateConnectionAliasErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            AssociateConnectionAliasErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AssociateConnectionAliasError {
    fn code(&self) -> Option<&str> {
        AssociateConnectionAliasError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AssociateConnectionAliasError {
    pub fn new(kind: AssociateConnectionAliasErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AssociateConnectionAliasErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AssociateConnectionAliasErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateConnectionAliasErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_invalid_parameter_values_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateConnectionAliasErrorKind::InvalidParameterValuesException(_)
        )
    }
    pub fn is_invalid_resource_state_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateConnectionAliasErrorKind::InvalidResourceStateException(_)
        )
    }
    pub fn is_operation_not_supported_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateConnectionAliasErrorKind::OperationNotSupportedException(_)
        )
    }
    pub fn is_resource_associated_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateConnectionAliasErrorKind::ResourceAssociatedException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateConnectionAliasErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for AssociateConnectionAliasError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AssociateConnectionAliasErrorKind::AccessDeniedException(_inner) => Some(_inner),
            AssociateConnectionAliasErrorKind::InvalidParameterValuesException(_inner) => {
                Some(_inner)
            }
            AssociateConnectionAliasErrorKind::InvalidResourceStateException(_inner) => {
                Some(_inner)
            }
            AssociateConnectionAliasErrorKind::OperationNotSupportedException(_inner) => {
                Some(_inner)
            }
            AssociateConnectionAliasErrorKind::ResourceAssociatedException(_inner) => Some(_inner),
            AssociateConnectionAliasErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            AssociateConnectionAliasErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AssociateIpGroupsError {
    pub kind: AssociateIpGroupsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AssociateIpGroupsErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InvalidParameterValuesException(crate::error::InvalidParameterValuesException),
    InvalidResourceStateException(crate::error::InvalidResourceStateException),
    OperationNotSupportedException(crate::error::OperationNotSupportedException),
    ResourceLimitExceededException(crate::error::ResourceLimitExceededException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AssociateIpGroupsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AssociateIpGroupsErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            AssociateIpGroupsErrorKind::InvalidParameterValuesException(_inner) => _inner.fmt(f),
            AssociateIpGroupsErrorKind::InvalidResourceStateException(_inner) => _inner.fmt(f),
            AssociateIpGroupsErrorKind::OperationNotSupportedException(_inner) => _inner.fmt(f),
            AssociateIpGroupsErrorKind::ResourceLimitExceededException(_inner) => _inner.fmt(f),
            AssociateIpGroupsErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            AssociateIpGroupsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AssociateIpGroupsError {
    fn code(&self) -> Option<&str> {
        AssociateIpGroupsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AssociateIpGroupsError {
    pub fn new(kind: AssociateIpGroupsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AssociateIpGroupsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AssociateIpGroupsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateIpGroupsErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_invalid_parameter_values_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateIpGroupsErrorKind::InvalidParameterValuesException(_)
        )
    }
    pub fn is_invalid_resource_state_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateIpGroupsErrorKind::InvalidResourceStateException(_)
        )
    }
    pub fn is_operation_not_supported_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateIpGroupsErrorKind::OperationNotSupportedException(_)
        )
    }
    pub fn is_resource_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateIpGroupsErrorKind::ResourceLimitExceededException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateIpGroupsErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for AssociateIpGroupsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AssociateIpGroupsErrorKind::AccessDeniedException(_inner) => Some(_inner),
            AssociateIpGroupsErrorKind::InvalidParameterValuesException(_inner) => Some(_inner),
            AssociateIpGroupsErrorKind::InvalidResourceStateException(_inner) => Some(_inner),
            AssociateIpGroupsErrorKind::OperationNotSupportedException(_inner) => Some(_inner),
            AssociateIpGroupsErrorKind::ResourceLimitExceededException(_inner) => Some(_inner),
            AssociateIpGroupsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            AssociateIpGroupsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AuthorizeIpRulesError {
    pub kind: AuthorizeIpRulesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AuthorizeIpRulesErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InvalidParameterValuesException(crate::error::InvalidParameterValuesException),
    InvalidResourceStateException(crate::error::InvalidResourceStateException),
    ResourceLimitExceededException(crate::error::ResourceLimitExceededException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AuthorizeIpRulesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AuthorizeIpRulesErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            AuthorizeIpRulesErrorKind::InvalidParameterValuesException(_inner) => _inner.fmt(f),
            AuthorizeIpRulesErrorKind::InvalidResourceStateException(_inner) => _inner.fmt(f),
            AuthorizeIpRulesErrorKind::ResourceLimitExceededException(_inner) => _inner.fmt(f),
            AuthorizeIpRulesErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            AuthorizeIpRulesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AuthorizeIpRulesError {
    fn code(&self) -> Option<&str> {
        AuthorizeIpRulesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AuthorizeIpRulesError {
    pub fn new(kind: AuthorizeIpRulesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AuthorizeIpRulesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AuthorizeIpRulesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            AuthorizeIpRulesErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_invalid_parameter_values_exception(&self) -> bool {
        matches!(
            &self.kind,
            AuthorizeIpRulesErrorKind::InvalidParameterValuesException(_)
        )
    }
    pub fn is_invalid_resource_state_exception(&self) -> bool {
        matches!(
            &self.kind,
            AuthorizeIpRulesErrorKind::InvalidResourceStateException(_)
        )
    }
    pub fn is_resource_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            AuthorizeIpRulesErrorKind::ResourceLimitExceededException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            AuthorizeIpRulesErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for AuthorizeIpRulesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AuthorizeIpRulesErrorKind::AccessDeniedException(_inner) => Some(_inner),
            AuthorizeIpRulesErrorKind::InvalidParameterValuesException(_inner) => Some(_inner),
            AuthorizeIpRulesErrorKind::InvalidResourceStateException(_inner) => Some(_inner),
            AuthorizeIpRulesErrorKind::ResourceLimitExceededException(_inner) => Some(_inner),
            AuthorizeIpRulesErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            AuthorizeIpRulesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CopyWorkspaceImageError {
    pub kind: CopyWorkspaceImageErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CopyWorkspaceImageErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InvalidParameterValuesException(crate::error::InvalidParameterValuesException),
    OperationNotSupportedException(crate::error::OperationNotSupportedException),
    ResourceAlreadyExistsException(crate::error::ResourceAlreadyExistsException),
    ResourceLimitExceededException(crate::error::ResourceLimitExceededException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ResourceUnavailableException(crate::error::ResourceUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CopyWorkspaceImageError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CopyWorkspaceImageErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            CopyWorkspaceImageErrorKind::InvalidParameterValuesException(_inner) => _inner.fmt(f),
            CopyWorkspaceImageErrorKind::OperationNotSupportedException(_inner) => _inner.fmt(f),
            CopyWorkspaceImageErrorKind::ResourceAlreadyExistsException(_inner) => _inner.fmt(f),
            CopyWorkspaceImageErrorKind::ResourceLimitExceededException(_inner) => _inner.fmt(f),
            CopyWorkspaceImageErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            CopyWorkspaceImageErrorKind::ResourceUnavailableException(_inner) => _inner.fmt(f),
            CopyWorkspaceImageErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CopyWorkspaceImageError {
    fn code(&self) -> Option<&str> {
        CopyWorkspaceImageError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CopyWorkspaceImageError {
    pub fn new(kind: CopyWorkspaceImageErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CopyWorkspaceImageErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CopyWorkspaceImageErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            CopyWorkspaceImageErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_invalid_parameter_values_exception(&self) -> bool {
        matches!(
            &self.kind,
            CopyWorkspaceImageErrorKind::InvalidParameterValuesException(_)
        )
    }
    pub fn is_operation_not_supported_exception(&self) -> bool {
        matches!(
            &self.kind,
            CopyWorkspaceImageErrorKind::OperationNotSupportedException(_)
        )
    }
    pub fn is_resource_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CopyWorkspaceImageErrorKind::ResourceAlreadyExistsException(_)
        )
    }
    pub fn is_resource_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CopyWorkspaceImageErrorKind::ResourceLimitExceededException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CopyWorkspaceImageErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_resource_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CopyWorkspaceImageErrorKind::ResourceUnavailableException(_)
        )
    }
}
impl std::error::Error for CopyWorkspaceImageError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CopyWorkspaceImageErrorKind::AccessDeniedException(_inner) => Some(_inner),
            CopyWorkspaceImageErrorKind::InvalidParameterValuesException(_inner) => Some(_inner),
            CopyWorkspaceImageErrorKind::OperationNotSupportedException(_inner) => Some(_inner),
            CopyWorkspaceImageErrorKind::ResourceAlreadyExistsException(_inner) => Some(_inner),
            CopyWorkspaceImageErrorKind::ResourceLimitExceededException(_inner) => Some(_inner),
            CopyWorkspaceImageErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            CopyWorkspaceImageErrorKind::ResourceUnavailableException(_inner) => Some(_inner),
            CopyWorkspaceImageErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateConnectionAliasError {
    pub kind: CreateConnectionAliasErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateConnectionAliasErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InvalidParameterValuesException(crate::error::InvalidParameterValuesException),
    InvalidResourceStateException(crate::error::InvalidResourceStateException),
    OperationNotSupportedException(crate::error::OperationNotSupportedException),
    ResourceAlreadyExistsException(crate::error::ResourceAlreadyExistsException),
    ResourceLimitExceededException(crate::error::ResourceLimitExceededException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateConnectionAliasError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateConnectionAliasErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            CreateConnectionAliasErrorKind::InvalidParameterValuesException(_inner) => {
                _inner.fmt(f)
            }
            CreateConnectionAliasErrorKind::InvalidResourceStateException(_inner) => _inner.fmt(f),
            CreateConnectionAliasErrorKind::OperationNotSupportedException(_inner) => _inner.fmt(f),
            CreateConnectionAliasErrorKind::ResourceAlreadyExistsException(_inner) => _inner.fmt(f),
            CreateConnectionAliasErrorKind::ResourceLimitExceededException(_inner) => _inner.fmt(f),
            CreateConnectionAliasErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateConnectionAliasError {
    fn code(&self) -> Option<&str> {
        CreateConnectionAliasError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateConnectionAliasError {
    pub fn new(kind: CreateConnectionAliasErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateConnectionAliasErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateConnectionAliasErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateConnectionAliasErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_invalid_parameter_values_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateConnectionAliasErrorKind::InvalidParameterValuesException(_)
        )
    }
    pub fn is_invalid_resource_state_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateConnectionAliasErrorKind::InvalidResourceStateException(_)
        )
    }
    pub fn is_operation_not_supported_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateConnectionAliasErrorKind::OperationNotSupportedException(_)
        )
    }
    pub fn is_resource_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateConnectionAliasErrorKind::ResourceAlreadyExistsException(_)
        )
    }
    pub fn is_resource_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateConnectionAliasErrorKind::ResourceLimitExceededException(_)
        )
    }
}
impl std::error::Error for CreateConnectionAliasError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateConnectionAliasErrorKind::AccessDeniedException(_inner) => Some(_inner),
            CreateConnectionAliasErrorKind::InvalidParameterValuesException(_inner) => Some(_inner),
            CreateConnectionAliasErrorKind::InvalidResourceStateException(_inner) => Some(_inner),
            CreateConnectionAliasErrorKind::OperationNotSupportedException(_inner) => Some(_inner),
            CreateConnectionAliasErrorKind::ResourceAlreadyExistsException(_inner) => Some(_inner),
            CreateConnectionAliasErrorKind::ResourceLimitExceededException(_inner) => Some(_inner),
            CreateConnectionAliasErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateIpGroupError {
    pub kind: CreateIpGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateIpGroupErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InvalidParameterValuesException(crate::error::InvalidParameterValuesException),
    ResourceAlreadyExistsException(crate::error::ResourceAlreadyExistsException),
    ResourceCreationFailedException(crate::error::ResourceCreationFailedException),
    ResourceLimitExceededException(crate::error::ResourceLimitExceededException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateIpGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateIpGroupErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            CreateIpGroupErrorKind::InvalidParameterValuesException(_inner) => _inner.fmt(f),
            CreateIpGroupErrorKind::ResourceAlreadyExistsException(_inner) => _inner.fmt(f),
            CreateIpGroupErrorKind::ResourceCreationFailedException(_inner) => _inner.fmt(f),
            CreateIpGroupErrorKind::ResourceLimitExceededException(_inner) => _inner.fmt(f),
            CreateIpGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateIpGroupError {
    fn code(&self) -> Option<&str> {
        CreateIpGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateIpGroupError {
    pub fn new(kind: CreateIpGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateIpGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateIpGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, CreateIpGroupErrorKind::AccessDeniedException(_))
    }
    pub fn is_invalid_parameter_values_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateIpGroupErrorKind::InvalidParameterValuesException(_)
        )
    }
    pub fn is_resource_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateIpGroupErrorKind::ResourceAlreadyExistsException(_)
        )
    }
    pub fn is_resource_creation_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateIpGroupErrorKind::ResourceCreationFailedException(_)
        )
    }
    pub fn is_resource_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateIpGroupErrorKind::ResourceLimitExceededException(_)
        )
    }
}
impl std::error::Error for CreateIpGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateIpGroupErrorKind::AccessDeniedException(_inner) => Some(_inner),
            CreateIpGroupErrorKind::InvalidParameterValuesException(_inner) => Some(_inner),
            CreateIpGroupErrorKind::ResourceAlreadyExistsException(_inner) => Some(_inner),
            CreateIpGroupErrorKind::ResourceCreationFailedException(_inner) => Some(_inner),
            CreateIpGroupErrorKind::ResourceLimitExceededException(_inner) => Some(_inner),
            CreateIpGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateTagsError {
    pub kind: CreateTagsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateTagsErrorKind {
    InvalidParameterValuesException(crate::error::InvalidParameterValuesException),
    ResourceLimitExceededException(crate::error::ResourceLimitExceededException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateTagsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateTagsErrorKind::InvalidParameterValuesException(_inner) => _inner.fmt(f),
            CreateTagsErrorKind::ResourceLimitExceededException(_inner) => _inner.fmt(f),
            CreateTagsErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            CreateTagsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateTagsError {
    fn code(&self) -> Option<&str> {
        CreateTagsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateTagsError {
    pub fn new(kind: CreateTagsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateTagsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateTagsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_values_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateTagsErrorKind::InvalidParameterValuesException(_)
        )
    }
    pub fn is_resource_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateTagsErrorKind::ResourceLimitExceededException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateTagsErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for CreateTagsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateTagsErrorKind::InvalidParameterValuesException(_inner) => Some(_inner),
            CreateTagsErrorKind::ResourceLimitExceededException(_inner) => Some(_inner),
            CreateTagsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            CreateTagsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateWorkspaceBundleError {
    pub kind: CreateWorkspaceBundleErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateWorkspaceBundleErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InvalidParameterValuesException(crate::error::InvalidParameterValuesException),
    ResourceAlreadyExistsException(crate::error::ResourceAlreadyExistsException),
    ResourceLimitExceededException(crate::error::ResourceLimitExceededException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ResourceUnavailableException(crate::error::ResourceUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateWorkspaceBundleError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateWorkspaceBundleErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            CreateWorkspaceBundleErrorKind::InvalidParameterValuesException(_inner) => {
                _inner.fmt(f)
            }
            CreateWorkspaceBundleErrorKind::ResourceAlreadyExistsException(_inner) => _inner.fmt(f),
            CreateWorkspaceBundleErrorKind::ResourceLimitExceededException(_inner) => _inner.fmt(f),
            CreateWorkspaceBundleErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            CreateWorkspaceBundleErrorKind::ResourceUnavailableException(_inner) => _inner.fmt(f),
            CreateWorkspaceBundleErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateWorkspaceBundleError {
    fn code(&self) -> Option<&str> {
        CreateWorkspaceBundleError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateWorkspaceBundleError {
    pub fn new(kind: CreateWorkspaceBundleErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateWorkspaceBundleErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateWorkspaceBundleErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateWorkspaceBundleErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_invalid_parameter_values_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateWorkspaceBundleErrorKind::InvalidParameterValuesException(_)
        )
    }
    pub fn is_resource_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateWorkspaceBundleErrorKind::ResourceAlreadyExistsException(_)
        )
    }
    pub fn is_resource_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateWorkspaceBundleErrorKind::ResourceLimitExceededException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateWorkspaceBundleErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_resource_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateWorkspaceBundleErrorKind::ResourceUnavailableException(_)
        )
    }
}
impl std::error::Error for CreateWorkspaceBundleError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateWorkspaceBundleErrorKind::AccessDeniedException(_inner) => Some(_inner),
            CreateWorkspaceBundleErrorKind::InvalidParameterValuesException(_inner) => Some(_inner),
            CreateWorkspaceBundleErrorKind::ResourceAlreadyExistsException(_inner) => Some(_inner),
            CreateWorkspaceBundleErrorKind::ResourceLimitExceededException(_inner) => Some(_inner),
            CreateWorkspaceBundleErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            CreateWorkspaceBundleErrorKind::ResourceUnavailableException(_inner) => Some(_inner),
            CreateWorkspaceBundleErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateWorkspacesError {
    pub kind: CreateWorkspacesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateWorkspacesErrorKind {
    InvalidParameterValuesException(crate::error::InvalidParameterValuesException),
    ResourceLimitExceededException(crate::error::ResourceLimitExceededException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateWorkspacesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateWorkspacesErrorKind::InvalidParameterValuesException(_inner) => _inner.fmt(f),
            CreateWorkspacesErrorKind::ResourceLimitExceededException(_inner) => _inner.fmt(f),
            CreateWorkspacesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateWorkspacesError {
    fn code(&self) -> Option<&str> {
        CreateWorkspacesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateWorkspacesError {
    pub fn new(kind: CreateWorkspacesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateWorkspacesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateWorkspacesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_values_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateWorkspacesErrorKind::InvalidParameterValuesException(_)
        )
    }
    pub fn is_resource_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateWorkspacesErrorKind::ResourceLimitExceededException(_)
        )
    }
}
impl std::error::Error for CreateWorkspacesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateWorkspacesErrorKind::InvalidParameterValuesException(_inner) => Some(_inner),
            CreateWorkspacesErrorKind::ResourceLimitExceededException(_inner) => Some(_inner),
            CreateWorkspacesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteConnectionAliasError {
    pub kind: DeleteConnectionAliasErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteConnectionAliasErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InvalidParameterValuesException(crate::error::InvalidParameterValuesException),
    InvalidResourceStateException(crate::error::InvalidResourceStateException),
    OperationNotSupportedException(crate::error::OperationNotSupportedException),
    ResourceAssociatedException(crate::error::ResourceAssociatedException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteConnectionAliasError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteConnectionAliasErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DeleteConnectionAliasErrorKind::InvalidParameterValuesException(_inner) => {
                _inner.fmt(f)
            }
            DeleteConnectionAliasErrorKind::InvalidResourceStateException(_inner) => _inner.fmt(f),
            DeleteConnectionAliasErrorKind::OperationNotSupportedException(_inner) => _inner.fmt(f),
            DeleteConnectionAliasErrorKind::ResourceAssociatedException(_inner) => _inner.fmt(f),
            DeleteConnectionAliasErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteConnectionAliasErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteConnectionAliasError {
    fn code(&self) -> Option<&str> {
        DeleteConnectionAliasError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteConnectionAliasError {
    pub fn new(kind: DeleteConnectionAliasErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteConnectionAliasErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteConnectionAliasErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteConnectionAliasErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_invalid_parameter_values_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteConnectionAliasErrorKind::InvalidParameterValuesException(_)
        )
    }
    pub fn is_invalid_resource_state_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteConnectionAliasErrorKind::InvalidResourceStateException(_)
        )
    }
    pub fn is_operation_not_supported_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteConnectionAliasErrorKind::OperationNotSupportedException(_)
        )
    }
    pub fn is_resource_associated_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteConnectionAliasErrorKind::ResourceAssociatedException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteConnectionAliasErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for DeleteConnectionAliasError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteConnectionAliasErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DeleteConnectionAliasErrorKind::InvalidParameterValuesException(_inner) => Some(_inner),
            DeleteConnectionAliasErrorKind::InvalidResourceStateException(_inner) => Some(_inner),
            DeleteConnectionAliasErrorKind::OperationNotSupportedException(_inner) => Some(_inner),
            DeleteConnectionAliasErrorKind::ResourceAssociatedException(_inner) => Some(_inner),
            DeleteConnectionAliasErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteConnectionAliasErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteIpGroupError {
    pub kind: DeleteIpGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteIpGroupErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InvalidParameterValuesException(crate::error::InvalidParameterValuesException),
    ResourceAssociatedException(crate::error::ResourceAssociatedException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteIpGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteIpGroupErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DeleteIpGroupErrorKind::InvalidParameterValuesException(_inner) => _inner.fmt(f),
            DeleteIpGroupErrorKind::ResourceAssociatedException(_inner) => _inner.fmt(f),
            DeleteIpGroupErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteIpGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteIpGroupError {
    fn code(&self) -> Option<&str> {
        DeleteIpGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteIpGroupError {
    pub fn new(kind: DeleteIpGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteIpGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteIpGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, DeleteIpGroupErrorKind::AccessDeniedException(_))
    }
    pub fn is_invalid_parameter_values_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteIpGroupErrorKind::InvalidParameterValuesException(_)
        )
    }
    pub fn is_resource_associated_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteIpGroupErrorKind::ResourceAssociatedException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteIpGroupErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for DeleteIpGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteIpGroupErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DeleteIpGroupErrorKind::InvalidParameterValuesException(_inner) => Some(_inner),
            DeleteIpGroupErrorKind::ResourceAssociatedException(_inner) => Some(_inner),
            DeleteIpGroupErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteIpGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteTagsError {
    pub kind: DeleteTagsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteTagsErrorKind {
    InvalidParameterValuesException(crate::error::InvalidParameterValuesException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteTagsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteTagsErrorKind::InvalidParameterValuesException(_inner) => _inner.fmt(f),
            DeleteTagsErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteTagsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteTagsError {
    fn code(&self) -> Option<&str> {
        DeleteTagsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteTagsError {
    pub fn new(kind: DeleteTagsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteTagsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteTagsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_values_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteTagsErrorKind::InvalidParameterValuesException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteTagsErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for DeleteTagsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteTagsErrorKind::InvalidParameterValuesException(_inner) => Some(_inner),
            DeleteTagsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteTagsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteWorkspaceBundleError {
    pub kind: DeleteWorkspaceBundleErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteWorkspaceBundleErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InvalidParameterValuesException(crate::error::InvalidParameterValuesException),
    ResourceAssociatedException(crate::error::ResourceAssociatedException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteWorkspaceBundleError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteWorkspaceBundleErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DeleteWorkspaceBundleErrorKind::InvalidParameterValuesException(_inner) => {
                _inner.fmt(f)
            }
            DeleteWorkspaceBundleErrorKind::ResourceAssociatedException(_inner) => _inner.fmt(f),
            DeleteWorkspaceBundleErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteWorkspaceBundleErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteWorkspaceBundleError {
    fn code(&self) -> Option<&str> {
        DeleteWorkspaceBundleError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteWorkspaceBundleError {
    pub fn new(kind: DeleteWorkspaceBundleErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteWorkspaceBundleErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteWorkspaceBundleErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteWorkspaceBundleErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_invalid_parameter_values_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteWorkspaceBundleErrorKind::InvalidParameterValuesException(_)
        )
    }
    pub fn is_resource_associated_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteWorkspaceBundleErrorKind::ResourceAssociatedException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteWorkspaceBundleErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for DeleteWorkspaceBundleError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteWorkspaceBundleErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DeleteWorkspaceBundleErrorKind::InvalidParameterValuesException(_inner) => Some(_inner),
            DeleteWorkspaceBundleErrorKind::ResourceAssociatedException(_inner) => Some(_inner),
            DeleteWorkspaceBundleErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteWorkspaceBundleErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteWorkspaceImageError {
    pub kind: DeleteWorkspaceImageErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteWorkspaceImageErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InvalidResourceStateException(crate::error::InvalidResourceStateException),
    ResourceAssociatedException(crate::error::ResourceAssociatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteWorkspaceImageError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteWorkspaceImageErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DeleteWorkspaceImageErrorKind::InvalidResourceStateException(_inner) => _inner.fmt(f),
            DeleteWorkspaceImageErrorKind::ResourceAssociatedException(_inner) => _inner.fmt(f),
            DeleteWorkspaceImageErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteWorkspaceImageError {
    fn code(&self) -> Option<&str> {
        DeleteWorkspaceImageError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteWorkspaceImageError {
    pub fn new(kind: DeleteWorkspaceImageErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteWorkspaceImageErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteWorkspaceImageErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteWorkspaceImageErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_invalid_resource_state_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteWorkspaceImageErrorKind::InvalidResourceStateException(_)
        )
    }
    pub fn is_resource_associated_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteWorkspaceImageErrorKind::ResourceAssociatedException(_)
        )
    }
}
impl std::error::Error for DeleteWorkspaceImageError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteWorkspaceImageErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DeleteWorkspaceImageErrorKind::InvalidResourceStateException(_inner) => Some(_inner),
            DeleteWorkspaceImageErrorKind::ResourceAssociatedException(_inner) => Some(_inner),
            DeleteWorkspaceImageErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeregisterWorkspaceDirectoryError {
    pub kind: DeregisterWorkspaceDirectoryErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeregisterWorkspaceDirectoryErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InvalidParameterValuesException(crate::error::InvalidParameterValuesException),
    InvalidResourceStateException(crate::error::InvalidResourceStateException),
    OperationNotSupportedException(crate::error::OperationNotSupportedException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeregisterWorkspaceDirectoryError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeregisterWorkspaceDirectoryErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DeregisterWorkspaceDirectoryErrorKind::InvalidParameterValuesException(_inner) => {
                _inner.fmt(f)
            }
            DeregisterWorkspaceDirectoryErrorKind::InvalidResourceStateException(_inner) => {
                _inner.fmt(f)
            }
            DeregisterWorkspaceDirectoryErrorKind::OperationNotSupportedException(_inner) => {
                _inner.fmt(f)
            }
            DeregisterWorkspaceDirectoryErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            DeregisterWorkspaceDirectoryErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeregisterWorkspaceDirectoryError {
    fn code(&self) -> Option<&str> {
        DeregisterWorkspaceDirectoryError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeregisterWorkspaceDirectoryError {
    pub fn new(kind: DeregisterWorkspaceDirectoryErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeregisterWorkspaceDirectoryErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeregisterWorkspaceDirectoryErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeregisterWorkspaceDirectoryErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_invalid_parameter_values_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeregisterWorkspaceDirectoryErrorKind::InvalidParameterValuesException(_)
        )
    }
    pub fn is_invalid_resource_state_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeregisterWorkspaceDirectoryErrorKind::InvalidResourceStateException(_)
        )
    }
    pub fn is_operation_not_supported_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeregisterWorkspaceDirectoryErrorKind::OperationNotSupportedException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeregisterWorkspaceDirectoryErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for DeregisterWorkspaceDirectoryError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeregisterWorkspaceDirectoryErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DeregisterWorkspaceDirectoryErrorKind::InvalidParameterValuesException(_inner) => {
                Some(_inner)
            }
            DeregisterWorkspaceDirectoryErrorKind::InvalidResourceStateException(_inner) => {
                Some(_inner)
            }
            DeregisterWorkspaceDirectoryErrorKind::OperationNotSupportedException(_inner) => {
                Some(_inner)
            }
            DeregisterWorkspaceDirectoryErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            DeregisterWorkspaceDirectoryErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeAccountError {
    pub kind: DescribeAccountErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeAccountErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeAccountError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeAccountErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DescribeAccountErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeAccountError {
    fn code(&self) -> Option<&str> {
        DescribeAccountError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeAccountError {
    pub fn new(kind: DescribeAccountErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeAccountErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeAccountErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAccountErrorKind::AccessDeniedException(_)
        )
    }
}
impl std::error::Error for DescribeAccountError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeAccountErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DescribeAccountErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeAccountModificationsError {
    pub kind: DescribeAccountModificationsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeAccountModificationsErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeAccountModificationsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeAccountModificationsErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DescribeAccountModificationsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeAccountModificationsError {
    fn code(&self) -> Option<&str> {
        DescribeAccountModificationsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeAccountModificationsError {
    pub fn new(kind: DescribeAccountModificationsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeAccountModificationsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeAccountModificationsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAccountModificationsErrorKind::AccessDeniedException(_)
        )
    }
}
impl std::error::Error for DescribeAccountModificationsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeAccountModificationsErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DescribeAccountModificationsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeClientPropertiesError {
    pub kind: DescribeClientPropertiesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeClientPropertiesErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InvalidParameterValuesException(crate::error::InvalidParameterValuesException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeClientPropertiesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeClientPropertiesErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DescribeClientPropertiesErrorKind::InvalidParameterValuesException(_inner) => {
                _inner.fmt(f)
            }
            DescribeClientPropertiesErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeClientPropertiesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeClientPropertiesError {
    fn code(&self) -> Option<&str> {
        DescribeClientPropertiesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeClientPropertiesError {
    pub fn new(kind: DescribeClientPropertiesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeClientPropertiesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeClientPropertiesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeClientPropertiesErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_invalid_parameter_values_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeClientPropertiesErrorKind::InvalidParameterValuesException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeClientPropertiesErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for DescribeClientPropertiesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeClientPropertiesErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DescribeClientPropertiesErrorKind::InvalidParameterValuesException(_inner) => {
                Some(_inner)
            }
            DescribeClientPropertiesErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeClientPropertiesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeConnectionAliasesError {
    pub kind: DescribeConnectionAliasesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeConnectionAliasesErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InvalidParameterValuesException(crate::error::InvalidParameterValuesException),
    OperationNotSupportedException(crate::error::OperationNotSupportedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeConnectionAliasesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeConnectionAliasesErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DescribeConnectionAliasesErrorKind::InvalidParameterValuesException(_inner) => {
                _inner.fmt(f)
            }
            DescribeConnectionAliasesErrorKind::OperationNotSupportedException(_inner) => {
                _inner.fmt(f)
            }
            DescribeConnectionAliasesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeConnectionAliasesError {
    fn code(&self) -> Option<&str> {
        DescribeConnectionAliasesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeConnectionAliasesError {
    pub fn new(kind: DescribeConnectionAliasesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeConnectionAliasesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeConnectionAliasesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeConnectionAliasesErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_invalid_parameter_values_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeConnectionAliasesErrorKind::InvalidParameterValuesException(_)
        )
    }
    pub fn is_operation_not_supported_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeConnectionAliasesErrorKind::OperationNotSupportedException(_)
        )
    }
}
impl std::error::Error for DescribeConnectionAliasesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeConnectionAliasesErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DescribeConnectionAliasesErrorKind::InvalidParameterValuesException(_inner) => {
                Some(_inner)
            }
            DescribeConnectionAliasesErrorKind::OperationNotSupportedException(_inner) => {
                Some(_inner)
            }
            DescribeConnectionAliasesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeConnectionAliasPermissionsError {
    pub kind: DescribeConnectionAliasPermissionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeConnectionAliasPermissionsErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InvalidParameterValuesException(crate::error::InvalidParameterValuesException),
    OperationNotSupportedException(crate::error::OperationNotSupportedException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeConnectionAliasPermissionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeConnectionAliasPermissionsErrorKind::AccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            DescribeConnectionAliasPermissionsErrorKind::InvalidParameterValuesException(
                _inner,
            ) => _inner.fmt(f),
            DescribeConnectionAliasPermissionsErrorKind::OperationNotSupportedException(_inner) => {
                _inner.fmt(f)
            }
            DescribeConnectionAliasPermissionsErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            DescribeConnectionAliasPermissionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeConnectionAliasPermissionsError {
    fn code(&self) -> Option<&str> {
        DescribeConnectionAliasPermissionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeConnectionAliasPermissionsError {
    pub fn new(
        kind: DescribeConnectionAliasPermissionsErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeConnectionAliasPermissionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeConnectionAliasPermissionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeConnectionAliasPermissionsErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_invalid_parameter_values_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeConnectionAliasPermissionsErrorKind::InvalidParameterValuesException(_)
        )
    }
    pub fn is_operation_not_supported_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeConnectionAliasPermissionsErrorKind::OperationNotSupportedException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeConnectionAliasPermissionsErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for DescribeConnectionAliasPermissionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeConnectionAliasPermissionsErrorKind::AccessDeniedException(_inner) => {
                Some(_inner)
            }
            DescribeConnectionAliasPermissionsErrorKind::InvalidParameterValuesException(
                _inner,
            ) => Some(_inner),
            DescribeConnectionAliasPermissionsErrorKind::OperationNotSupportedException(_inner) => {
                Some(_inner)
            }
            DescribeConnectionAliasPermissionsErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            DescribeConnectionAliasPermissionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeIpGroupsError {
    pub kind: DescribeIpGroupsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeIpGroupsErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InvalidParameterValuesException(crate::error::InvalidParameterValuesException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeIpGroupsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeIpGroupsErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DescribeIpGroupsErrorKind::InvalidParameterValuesException(_inner) => _inner.fmt(f),
            DescribeIpGroupsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeIpGroupsError {
    fn code(&self) -> Option<&str> {
        DescribeIpGroupsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeIpGroupsError {
    pub fn new(kind: DescribeIpGroupsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeIpGroupsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeIpGroupsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeIpGroupsErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_invalid_parameter_values_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeIpGroupsErrorKind::InvalidParameterValuesException(_)
        )
    }
}
impl std::error::Error for DescribeIpGroupsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeIpGroupsErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DescribeIpGroupsErrorKind::InvalidParameterValuesException(_inner) => Some(_inner),
            DescribeIpGroupsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeTagsError {
    pub kind: DescribeTagsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeTagsErrorKind {
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeTagsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeTagsErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeTagsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeTagsError {
    fn code(&self) -> Option<&str> {
        DescribeTagsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeTagsError {
    pub fn new(kind: DescribeTagsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeTagsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeTagsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeTagsErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for DescribeTagsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeTagsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeTagsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeWorkspaceBundlesError {
    pub kind: DescribeWorkspaceBundlesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeWorkspaceBundlesErrorKind {
    InvalidParameterValuesException(crate::error::InvalidParameterValuesException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeWorkspaceBundlesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeWorkspaceBundlesErrorKind::InvalidParameterValuesException(_inner) => {
                _inner.fmt(f)
            }
            DescribeWorkspaceBundlesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeWorkspaceBundlesError {
    fn code(&self) -> Option<&str> {
        DescribeWorkspaceBundlesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeWorkspaceBundlesError {
    pub fn new(kind: DescribeWorkspaceBundlesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeWorkspaceBundlesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeWorkspaceBundlesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_values_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeWorkspaceBundlesErrorKind::InvalidParameterValuesException(_)
        )
    }
}
impl std::error::Error for DescribeWorkspaceBundlesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeWorkspaceBundlesErrorKind::InvalidParameterValuesException(_inner) => {
                Some(_inner)
            }
            DescribeWorkspaceBundlesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeWorkspaceDirectoriesError {
    pub kind: DescribeWorkspaceDirectoriesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeWorkspaceDirectoriesErrorKind {
    InvalidParameterValuesException(crate::error::InvalidParameterValuesException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeWorkspaceDirectoriesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeWorkspaceDirectoriesErrorKind::InvalidParameterValuesException(_inner) => {
                _inner.fmt(f)
            }
            DescribeWorkspaceDirectoriesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeWorkspaceDirectoriesError {
    fn code(&self) -> Option<&str> {
        DescribeWorkspaceDirectoriesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeWorkspaceDirectoriesError {
    pub fn new(kind: DescribeWorkspaceDirectoriesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeWorkspaceDirectoriesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeWorkspaceDirectoriesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_values_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeWorkspaceDirectoriesErrorKind::InvalidParameterValuesException(_)
        )
    }
}
impl std::error::Error for DescribeWorkspaceDirectoriesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeWorkspaceDirectoriesErrorKind::InvalidParameterValuesException(_inner) => {
                Some(_inner)
            }
            DescribeWorkspaceDirectoriesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeWorkspaceImagePermissionsError {
    pub kind: DescribeWorkspaceImagePermissionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeWorkspaceImagePermissionsErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InvalidParameterValuesException(crate::error::InvalidParameterValuesException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeWorkspaceImagePermissionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeWorkspaceImagePermissionsErrorKind::AccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            DescribeWorkspaceImagePermissionsErrorKind::InvalidParameterValuesException(_inner) => {
                _inner.fmt(f)
            }
            DescribeWorkspaceImagePermissionsErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            DescribeWorkspaceImagePermissionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeWorkspaceImagePermissionsError {
    fn code(&self) -> Option<&str> {
        DescribeWorkspaceImagePermissionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeWorkspaceImagePermissionsError {
    pub fn new(
        kind: DescribeWorkspaceImagePermissionsErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeWorkspaceImagePermissionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeWorkspaceImagePermissionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeWorkspaceImagePermissionsErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_invalid_parameter_values_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeWorkspaceImagePermissionsErrorKind::InvalidParameterValuesException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeWorkspaceImagePermissionsErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for DescribeWorkspaceImagePermissionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeWorkspaceImagePermissionsErrorKind::AccessDeniedException(_inner) => {
                Some(_inner)
            }
            DescribeWorkspaceImagePermissionsErrorKind::InvalidParameterValuesException(_inner) => {
                Some(_inner)
            }
            DescribeWorkspaceImagePermissionsErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            DescribeWorkspaceImagePermissionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeWorkspaceImagesError {
    pub kind: DescribeWorkspaceImagesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeWorkspaceImagesErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeWorkspaceImagesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeWorkspaceImagesErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DescribeWorkspaceImagesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeWorkspaceImagesError {
    fn code(&self) -> Option<&str> {
        DescribeWorkspaceImagesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeWorkspaceImagesError {
    pub fn new(kind: DescribeWorkspaceImagesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeWorkspaceImagesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeWorkspaceImagesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeWorkspaceImagesErrorKind::AccessDeniedException(_)
        )
    }
}
impl std::error::Error for DescribeWorkspaceImagesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeWorkspaceImagesErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DescribeWorkspaceImagesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeWorkspacesError {
    pub kind: DescribeWorkspacesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeWorkspacesErrorKind {
    InvalidParameterValuesException(crate::error::InvalidParameterValuesException),
    ResourceUnavailableException(crate::error::ResourceUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeWorkspacesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeWorkspacesErrorKind::InvalidParameterValuesException(_inner) => _inner.fmt(f),
            DescribeWorkspacesErrorKind::ResourceUnavailableException(_inner) => _inner.fmt(f),
            DescribeWorkspacesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeWorkspacesError {
    fn code(&self) -> Option<&str> {
        DescribeWorkspacesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeWorkspacesError {
    pub fn new(kind: DescribeWorkspacesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeWorkspacesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeWorkspacesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_values_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeWorkspacesErrorKind::InvalidParameterValuesException(_)
        )
    }
    pub fn is_resource_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeWorkspacesErrorKind::ResourceUnavailableException(_)
        )
    }
}
impl std::error::Error for DescribeWorkspacesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeWorkspacesErrorKind::InvalidParameterValuesException(_inner) => Some(_inner),
            DescribeWorkspacesErrorKind::ResourceUnavailableException(_inner) => Some(_inner),
            DescribeWorkspacesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeWorkspacesConnectionStatusError {
    pub kind: DescribeWorkspacesConnectionStatusErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeWorkspacesConnectionStatusErrorKind {
    InvalidParameterValuesException(crate::error::InvalidParameterValuesException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeWorkspacesConnectionStatusError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeWorkspacesConnectionStatusErrorKind::InvalidParameterValuesException(
                _inner,
            ) => _inner.fmt(f),
            DescribeWorkspacesConnectionStatusErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeWorkspacesConnectionStatusError {
    fn code(&self) -> Option<&str> {
        DescribeWorkspacesConnectionStatusError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeWorkspacesConnectionStatusError {
    pub fn new(
        kind: DescribeWorkspacesConnectionStatusErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeWorkspacesConnectionStatusErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeWorkspacesConnectionStatusErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_values_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeWorkspacesConnectionStatusErrorKind::InvalidParameterValuesException(_)
        )
    }
}
impl std::error::Error for DescribeWorkspacesConnectionStatusError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeWorkspacesConnectionStatusErrorKind::InvalidParameterValuesException(
                _inner,
            ) => Some(_inner),
            DescribeWorkspacesConnectionStatusErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeWorkspaceSnapshotsError {
    pub kind: DescribeWorkspaceSnapshotsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeWorkspaceSnapshotsErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InvalidParameterValuesException(crate::error::InvalidParameterValuesException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeWorkspaceSnapshotsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeWorkspaceSnapshotsErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DescribeWorkspaceSnapshotsErrorKind::InvalidParameterValuesException(_inner) => {
                _inner.fmt(f)
            }
            DescribeWorkspaceSnapshotsErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeWorkspaceSnapshotsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeWorkspaceSnapshotsError {
    fn code(&self) -> Option<&str> {
        DescribeWorkspaceSnapshotsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeWorkspaceSnapshotsError {
    pub fn new(kind: DescribeWorkspaceSnapshotsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeWorkspaceSnapshotsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeWorkspaceSnapshotsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeWorkspaceSnapshotsErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_invalid_parameter_values_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeWorkspaceSnapshotsErrorKind::InvalidParameterValuesException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeWorkspaceSnapshotsErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for DescribeWorkspaceSnapshotsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeWorkspaceSnapshotsErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DescribeWorkspaceSnapshotsErrorKind::InvalidParameterValuesException(_inner) => {
                Some(_inner)
            }
            DescribeWorkspaceSnapshotsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeWorkspaceSnapshotsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DisassociateConnectionAliasError {
    pub kind: DisassociateConnectionAliasErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DisassociateConnectionAliasErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InvalidParameterValuesException(crate::error::InvalidParameterValuesException),
    InvalidResourceStateException(crate::error::InvalidResourceStateException),
    OperationNotSupportedException(crate::error::OperationNotSupportedException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DisassociateConnectionAliasError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DisassociateConnectionAliasErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DisassociateConnectionAliasErrorKind::InvalidParameterValuesException(_inner) => {
                _inner.fmt(f)
            }
            DisassociateConnectionAliasErrorKind::InvalidResourceStateException(_inner) => {
                _inner.fmt(f)
            }
            DisassociateConnectionAliasErrorKind::OperationNotSupportedException(_inner) => {
                _inner.fmt(f)
            }
            DisassociateConnectionAliasErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            DisassociateConnectionAliasErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DisassociateConnectionAliasError {
    fn code(&self) -> Option<&str> {
        DisassociateConnectionAliasError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DisassociateConnectionAliasError {
    pub fn new(kind: DisassociateConnectionAliasErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DisassociateConnectionAliasErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DisassociateConnectionAliasErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateConnectionAliasErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_invalid_parameter_values_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateConnectionAliasErrorKind::InvalidParameterValuesException(_)
        )
    }
    pub fn is_invalid_resource_state_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateConnectionAliasErrorKind::InvalidResourceStateException(_)
        )
    }
    pub fn is_operation_not_supported_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateConnectionAliasErrorKind::OperationNotSupportedException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateConnectionAliasErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for DisassociateConnectionAliasError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DisassociateConnectionAliasErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DisassociateConnectionAliasErrorKind::InvalidParameterValuesException(_inner) => {
                Some(_inner)
            }
            DisassociateConnectionAliasErrorKind::InvalidResourceStateException(_inner) => {
                Some(_inner)
            }
            DisassociateConnectionAliasErrorKind::OperationNotSupportedException(_inner) => {
                Some(_inner)
            }
            DisassociateConnectionAliasErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DisassociateConnectionAliasErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DisassociateIpGroupsError {
    pub kind: DisassociateIpGroupsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DisassociateIpGroupsErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InvalidParameterValuesException(crate::error::InvalidParameterValuesException),
    InvalidResourceStateException(crate::error::InvalidResourceStateException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DisassociateIpGroupsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DisassociateIpGroupsErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DisassociateIpGroupsErrorKind::InvalidParameterValuesException(_inner) => _inner.fmt(f),
            DisassociateIpGroupsErrorKind::InvalidResourceStateException(_inner) => _inner.fmt(f),
            DisassociateIpGroupsErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DisassociateIpGroupsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DisassociateIpGroupsError {
    fn code(&self) -> Option<&str> {
        DisassociateIpGroupsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DisassociateIpGroupsError {
    pub fn new(kind: DisassociateIpGroupsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DisassociateIpGroupsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DisassociateIpGroupsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateIpGroupsErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_invalid_parameter_values_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateIpGroupsErrorKind::InvalidParameterValuesException(_)
        )
    }
    pub fn is_invalid_resource_state_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateIpGroupsErrorKind::InvalidResourceStateException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateIpGroupsErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for DisassociateIpGroupsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DisassociateIpGroupsErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DisassociateIpGroupsErrorKind::InvalidParameterValuesException(_inner) => Some(_inner),
            DisassociateIpGroupsErrorKind::InvalidResourceStateException(_inner) => Some(_inner),
            DisassociateIpGroupsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DisassociateIpGroupsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ImportWorkspaceImageError {
    pub kind: ImportWorkspaceImageErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ImportWorkspaceImageErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InvalidParameterValuesException(crate::error::InvalidParameterValuesException),
    OperationNotSupportedException(crate::error::OperationNotSupportedException),
    ResourceAlreadyExistsException(crate::error::ResourceAlreadyExistsException),
    ResourceLimitExceededException(crate::error::ResourceLimitExceededException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ImportWorkspaceImageError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ImportWorkspaceImageErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            ImportWorkspaceImageErrorKind::InvalidParameterValuesException(_inner) => _inner.fmt(f),
            ImportWorkspaceImageErrorKind::OperationNotSupportedException(_inner) => _inner.fmt(f),
            ImportWorkspaceImageErrorKind::ResourceAlreadyExistsException(_inner) => _inner.fmt(f),
            ImportWorkspaceImageErrorKind::ResourceLimitExceededException(_inner) => _inner.fmt(f),
            ImportWorkspaceImageErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ImportWorkspaceImageErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ImportWorkspaceImageError {
    fn code(&self) -> Option<&str> {
        ImportWorkspaceImageError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ImportWorkspaceImageError {
    pub fn new(kind: ImportWorkspaceImageErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ImportWorkspaceImageErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ImportWorkspaceImageErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            ImportWorkspaceImageErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_invalid_parameter_values_exception(&self) -> bool {
        matches!(
            &self.kind,
            ImportWorkspaceImageErrorKind::InvalidParameterValuesException(_)
        )
    }
    pub fn is_operation_not_supported_exception(&self) -> bool {
        matches!(
            &self.kind,
            ImportWorkspaceImageErrorKind::OperationNotSupportedException(_)
        )
    }
    pub fn is_resource_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            ImportWorkspaceImageErrorKind::ResourceAlreadyExistsException(_)
        )
    }
    pub fn is_resource_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            ImportWorkspaceImageErrorKind::ResourceLimitExceededException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ImportWorkspaceImageErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for ImportWorkspaceImageError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ImportWorkspaceImageErrorKind::AccessDeniedException(_inner) => Some(_inner),
            ImportWorkspaceImageErrorKind::InvalidParameterValuesException(_inner) => Some(_inner),
            ImportWorkspaceImageErrorKind::OperationNotSupportedException(_inner) => Some(_inner),
            ImportWorkspaceImageErrorKind::ResourceAlreadyExistsException(_inner) => Some(_inner),
            ImportWorkspaceImageErrorKind::ResourceLimitExceededException(_inner) => Some(_inner),
            ImportWorkspaceImageErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ImportWorkspaceImageErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListAvailableManagementCidrRangesError {
    pub kind: ListAvailableManagementCidrRangesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListAvailableManagementCidrRangesErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InvalidParameterValuesException(crate::error::InvalidParameterValuesException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListAvailableManagementCidrRangesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListAvailableManagementCidrRangesErrorKind::AccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            ListAvailableManagementCidrRangesErrorKind::InvalidParameterValuesException(_inner) => {
                _inner.fmt(f)
            }
            ListAvailableManagementCidrRangesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListAvailableManagementCidrRangesError {
    fn code(&self) -> Option<&str> {
        ListAvailableManagementCidrRangesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListAvailableManagementCidrRangesError {
    pub fn new(
        kind: ListAvailableManagementCidrRangesErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListAvailableManagementCidrRangesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListAvailableManagementCidrRangesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAvailableManagementCidrRangesErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_invalid_parameter_values_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAvailableManagementCidrRangesErrorKind::InvalidParameterValuesException(_)
        )
    }
}
impl std::error::Error for ListAvailableManagementCidrRangesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListAvailableManagementCidrRangesErrorKind::AccessDeniedException(_inner) => {
                Some(_inner)
            }
            ListAvailableManagementCidrRangesErrorKind::InvalidParameterValuesException(_inner) => {
                Some(_inner)
            }
            ListAvailableManagementCidrRangesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct MigrateWorkspaceError {
    pub kind: MigrateWorkspaceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum MigrateWorkspaceErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InvalidParameterValuesException(crate::error::InvalidParameterValuesException),
    OperationInProgressException(crate::error::OperationInProgressException),
    OperationNotSupportedException(crate::error::OperationNotSupportedException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ResourceUnavailableException(crate::error::ResourceUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for MigrateWorkspaceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            MigrateWorkspaceErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            MigrateWorkspaceErrorKind::InvalidParameterValuesException(_inner) => _inner.fmt(f),
            MigrateWorkspaceErrorKind::OperationInProgressException(_inner) => _inner.fmt(f),
            MigrateWorkspaceErrorKind::OperationNotSupportedException(_inner) => _inner.fmt(f),
            MigrateWorkspaceErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            MigrateWorkspaceErrorKind::ResourceUnavailableException(_inner) => _inner.fmt(f),
            MigrateWorkspaceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for MigrateWorkspaceError {
    fn code(&self) -> Option<&str> {
        MigrateWorkspaceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl MigrateWorkspaceError {
    pub fn new(kind: MigrateWorkspaceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: MigrateWorkspaceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: MigrateWorkspaceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            MigrateWorkspaceErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_invalid_parameter_values_exception(&self) -> bool {
        matches!(
            &self.kind,
            MigrateWorkspaceErrorKind::InvalidParameterValuesException(_)
        )
    }
    pub fn is_operation_in_progress_exception(&self) -> bool {
        matches!(
            &self.kind,
            MigrateWorkspaceErrorKind::OperationInProgressException(_)
        )
    }
    pub fn is_operation_not_supported_exception(&self) -> bool {
        matches!(
            &self.kind,
            MigrateWorkspaceErrorKind::OperationNotSupportedException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            MigrateWorkspaceErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_resource_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            MigrateWorkspaceErrorKind::ResourceUnavailableException(_)
        )
    }
}
impl std::error::Error for MigrateWorkspaceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            MigrateWorkspaceErrorKind::AccessDeniedException(_inner) => Some(_inner),
            MigrateWorkspaceErrorKind::InvalidParameterValuesException(_inner) => Some(_inner),
            MigrateWorkspaceErrorKind::OperationInProgressException(_inner) => Some(_inner),
            MigrateWorkspaceErrorKind::OperationNotSupportedException(_inner) => Some(_inner),
            MigrateWorkspaceErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            MigrateWorkspaceErrorKind::ResourceUnavailableException(_inner) => Some(_inner),
            MigrateWorkspaceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ModifyAccountError {
    pub kind: ModifyAccountErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ModifyAccountErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InvalidParameterValuesException(crate::error::InvalidParameterValuesException),
    InvalidResourceStateException(crate::error::InvalidResourceStateException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ResourceUnavailableException(crate::error::ResourceUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ModifyAccountError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ModifyAccountErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            ModifyAccountErrorKind::InvalidParameterValuesException(_inner) => _inner.fmt(f),
            ModifyAccountErrorKind::InvalidResourceStateException(_inner) => _inner.fmt(f),
            ModifyAccountErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ModifyAccountErrorKind::ResourceUnavailableException(_inner) => _inner.fmt(f),
            ModifyAccountErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ModifyAccountError {
    fn code(&self) -> Option<&str> {
        ModifyAccountError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ModifyAccountError {
    pub fn new(kind: ModifyAccountErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ModifyAccountErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ModifyAccountErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, ModifyAccountErrorKind::AccessDeniedException(_))
    }
    pub fn is_invalid_parameter_values_exception(&self) -> bool {
        matches!(
            &self.kind,
            ModifyAccountErrorKind::InvalidParameterValuesException(_)
        )
    }
    pub fn is_invalid_resource_state_exception(&self) -> bool {
        matches!(
            &self.kind,
            ModifyAccountErrorKind::InvalidResourceStateException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ModifyAccountErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_resource_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ModifyAccountErrorKind::ResourceUnavailableException(_)
        )
    }
}
impl std::error::Error for ModifyAccountError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ModifyAccountErrorKind::AccessDeniedException(_inner) => Some(_inner),
            ModifyAccountErrorKind::InvalidParameterValuesException(_inner) => Some(_inner),
            ModifyAccountErrorKind::InvalidResourceStateException(_inner) => Some(_inner),
            ModifyAccountErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ModifyAccountErrorKind::ResourceUnavailableException(_inner) => Some(_inner),
            ModifyAccountErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ModifyClientPropertiesError {
    pub kind: ModifyClientPropertiesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ModifyClientPropertiesErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InvalidParameterValuesException(crate::error::InvalidParameterValuesException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ModifyClientPropertiesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ModifyClientPropertiesErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            ModifyClientPropertiesErrorKind::InvalidParameterValuesException(_inner) => {
                _inner.fmt(f)
            }
            ModifyClientPropertiesErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ModifyClientPropertiesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ModifyClientPropertiesError {
    fn code(&self) -> Option<&str> {
        ModifyClientPropertiesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ModifyClientPropertiesError {
    pub fn new(kind: ModifyClientPropertiesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ModifyClientPropertiesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ModifyClientPropertiesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            ModifyClientPropertiesErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_invalid_parameter_values_exception(&self) -> bool {
        matches!(
            &self.kind,
            ModifyClientPropertiesErrorKind::InvalidParameterValuesException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ModifyClientPropertiesErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for ModifyClientPropertiesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ModifyClientPropertiesErrorKind::AccessDeniedException(_inner) => Some(_inner),
            ModifyClientPropertiesErrorKind::InvalidParameterValuesException(_inner) => {
                Some(_inner)
            }
            ModifyClientPropertiesErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ModifyClientPropertiesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ModifySelfservicePermissionsError {
    pub kind: ModifySelfservicePermissionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ModifySelfservicePermissionsErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InvalidParameterValuesException(crate::error::InvalidParameterValuesException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ModifySelfservicePermissionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ModifySelfservicePermissionsErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            ModifySelfservicePermissionsErrorKind::InvalidParameterValuesException(_inner) => {
                _inner.fmt(f)
            }
            ModifySelfservicePermissionsErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            ModifySelfservicePermissionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ModifySelfservicePermissionsError {
    fn code(&self) -> Option<&str> {
        ModifySelfservicePermissionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ModifySelfservicePermissionsError {
    pub fn new(kind: ModifySelfservicePermissionsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ModifySelfservicePermissionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ModifySelfservicePermissionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            ModifySelfservicePermissionsErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_invalid_parameter_values_exception(&self) -> bool {
        matches!(
            &self.kind,
            ModifySelfservicePermissionsErrorKind::InvalidParameterValuesException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ModifySelfservicePermissionsErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for ModifySelfservicePermissionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ModifySelfservicePermissionsErrorKind::AccessDeniedException(_inner) => Some(_inner),
            ModifySelfservicePermissionsErrorKind::InvalidParameterValuesException(_inner) => {
                Some(_inner)
            }
            ModifySelfservicePermissionsErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            ModifySelfservicePermissionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ModifyWorkspaceAccessPropertiesError {
    pub kind: ModifyWorkspaceAccessPropertiesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ModifyWorkspaceAccessPropertiesErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ModifyWorkspaceAccessPropertiesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ModifyWorkspaceAccessPropertiesErrorKind::AccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            ModifyWorkspaceAccessPropertiesErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            ModifyWorkspaceAccessPropertiesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ModifyWorkspaceAccessPropertiesError {
    fn code(&self) -> Option<&str> {
        ModifyWorkspaceAccessPropertiesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ModifyWorkspaceAccessPropertiesError {
    pub fn new(kind: ModifyWorkspaceAccessPropertiesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ModifyWorkspaceAccessPropertiesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ModifyWorkspaceAccessPropertiesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            ModifyWorkspaceAccessPropertiesErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ModifyWorkspaceAccessPropertiesErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for ModifyWorkspaceAccessPropertiesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ModifyWorkspaceAccessPropertiesErrorKind::AccessDeniedException(_inner) => Some(_inner),
            ModifyWorkspaceAccessPropertiesErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            ModifyWorkspaceAccessPropertiesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ModifyWorkspaceCreationPropertiesError {
    pub kind: ModifyWorkspaceCreationPropertiesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ModifyWorkspaceCreationPropertiesErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InvalidParameterValuesException(crate::error::InvalidParameterValuesException),
    OperationNotSupportedException(crate::error::OperationNotSupportedException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ModifyWorkspaceCreationPropertiesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ModifyWorkspaceCreationPropertiesErrorKind::AccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            ModifyWorkspaceCreationPropertiesErrorKind::InvalidParameterValuesException(_inner) => {
                _inner.fmt(f)
            }
            ModifyWorkspaceCreationPropertiesErrorKind::OperationNotSupportedException(_inner) => {
                _inner.fmt(f)
            }
            ModifyWorkspaceCreationPropertiesErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            ModifyWorkspaceCreationPropertiesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ModifyWorkspaceCreationPropertiesError {
    fn code(&self) -> Option<&str> {
        ModifyWorkspaceCreationPropertiesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ModifyWorkspaceCreationPropertiesError {
    pub fn new(
        kind: ModifyWorkspaceCreationPropertiesErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ModifyWorkspaceCreationPropertiesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ModifyWorkspaceCreationPropertiesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            ModifyWorkspaceCreationPropertiesErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_invalid_parameter_values_exception(&self) -> bool {
        matches!(
            &self.kind,
            ModifyWorkspaceCreationPropertiesErrorKind::InvalidParameterValuesException(_)
        )
    }
    pub fn is_operation_not_supported_exception(&self) -> bool {
        matches!(
            &self.kind,
            ModifyWorkspaceCreationPropertiesErrorKind::OperationNotSupportedException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ModifyWorkspaceCreationPropertiesErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for ModifyWorkspaceCreationPropertiesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ModifyWorkspaceCreationPropertiesErrorKind::AccessDeniedException(_inner) => {
                Some(_inner)
            }
            ModifyWorkspaceCreationPropertiesErrorKind::InvalidParameterValuesException(_inner) => {
                Some(_inner)
            }
            ModifyWorkspaceCreationPropertiesErrorKind::OperationNotSupportedException(_inner) => {
                Some(_inner)
            }
            ModifyWorkspaceCreationPropertiesErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            ModifyWorkspaceCreationPropertiesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ModifyWorkspacePropertiesError {
    pub kind: ModifyWorkspacePropertiesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ModifyWorkspacePropertiesErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InvalidParameterValuesException(crate::error::InvalidParameterValuesException),
    InvalidResourceStateException(crate::error::InvalidResourceStateException),
    OperationInProgressException(crate::error::OperationInProgressException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ResourceUnavailableException(crate::error::ResourceUnavailableException),
    UnsupportedWorkspaceConfigurationException(
        crate::error::UnsupportedWorkspaceConfigurationException,
    ),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ModifyWorkspacePropertiesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ModifyWorkspacePropertiesErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            ModifyWorkspacePropertiesErrorKind::InvalidParameterValuesException(_inner) => {
                _inner.fmt(f)
            }
            ModifyWorkspacePropertiesErrorKind::InvalidResourceStateException(_inner) => {
                _inner.fmt(f)
            }
            ModifyWorkspacePropertiesErrorKind::OperationInProgressException(_inner) => {
                _inner.fmt(f)
            }
            ModifyWorkspacePropertiesErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ModifyWorkspacePropertiesErrorKind::ResourceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            ModifyWorkspacePropertiesErrorKind::UnsupportedWorkspaceConfigurationException(
                _inner,
            ) => _inner.fmt(f),
            ModifyWorkspacePropertiesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ModifyWorkspacePropertiesError {
    fn code(&self) -> Option<&str> {
        ModifyWorkspacePropertiesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ModifyWorkspacePropertiesError {
    pub fn new(kind: ModifyWorkspacePropertiesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ModifyWorkspacePropertiesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ModifyWorkspacePropertiesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            ModifyWorkspacePropertiesErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_invalid_parameter_values_exception(&self) -> bool {
        matches!(
            &self.kind,
            ModifyWorkspacePropertiesErrorKind::InvalidParameterValuesException(_)
        )
    }
    pub fn is_invalid_resource_state_exception(&self) -> bool {
        matches!(
            &self.kind,
            ModifyWorkspacePropertiesErrorKind::InvalidResourceStateException(_)
        )
    }
    pub fn is_operation_in_progress_exception(&self) -> bool {
        matches!(
            &self.kind,
            ModifyWorkspacePropertiesErrorKind::OperationInProgressException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ModifyWorkspacePropertiesErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_resource_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ModifyWorkspacePropertiesErrorKind::ResourceUnavailableException(_)
        )
    }
    pub fn is_unsupported_workspace_configuration_exception(&self) -> bool {
        matches!(
            &self.kind,
            ModifyWorkspacePropertiesErrorKind::UnsupportedWorkspaceConfigurationException(_)
        )
    }
}
impl std::error::Error for ModifyWorkspacePropertiesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ModifyWorkspacePropertiesErrorKind::AccessDeniedException(_inner) => Some(_inner),
            ModifyWorkspacePropertiesErrorKind::InvalidParameterValuesException(_inner) => {
                Some(_inner)
            }
            ModifyWorkspacePropertiesErrorKind::InvalidResourceStateException(_inner) => {
                Some(_inner)
            }
            ModifyWorkspacePropertiesErrorKind::OperationInProgressException(_inner) => {
                Some(_inner)
            }
            ModifyWorkspacePropertiesErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ModifyWorkspacePropertiesErrorKind::ResourceUnavailableException(_inner) => {
                Some(_inner)
            }
            ModifyWorkspacePropertiesErrorKind::UnsupportedWorkspaceConfigurationException(
                _inner,
            ) => Some(_inner),
            ModifyWorkspacePropertiesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ModifyWorkspaceStateError {
    pub kind: ModifyWorkspaceStateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ModifyWorkspaceStateErrorKind {
    InvalidParameterValuesException(crate::error::InvalidParameterValuesException),
    InvalidResourceStateException(crate::error::InvalidResourceStateException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ModifyWorkspaceStateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ModifyWorkspaceStateErrorKind::InvalidParameterValuesException(_inner) => _inner.fmt(f),
            ModifyWorkspaceStateErrorKind::InvalidResourceStateException(_inner) => _inner.fmt(f),
            ModifyWorkspaceStateErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ModifyWorkspaceStateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ModifyWorkspaceStateError {
    fn code(&self) -> Option<&str> {
        ModifyWorkspaceStateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ModifyWorkspaceStateError {
    pub fn new(kind: ModifyWorkspaceStateErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ModifyWorkspaceStateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ModifyWorkspaceStateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_values_exception(&self) -> bool {
        matches!(
            &self.kind,
            ModifyWorkspaceStateErrorKind::InvalidParameterValuesException(_)
        )
    }
    pub fn is_invalid_resource_state_exception(&self) -> bool {
        matches!(
            &self.kind,
            ModifyWorkspaceStateErrorKind::InvalidResourceStateException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ModifyWorkspaceStateErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for ModifyWorkspaceStateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ModifyWorkspaceStateErrorKind::InvalidParameterValuesException(_inner) => Some(_inner),
            ModifyWorkspaceStateErrorKind::InvalidResourceStateException(_inner) => Some(_inner),
            ModifyWorkspaceStateErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ModifyWorkspaceStateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RebootWorkspacesError {
    pub kind: RebootWorkspacesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RebootWorkspacesErrorKind {
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RebootWorkspacesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RebootWorkspacesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RebootWorkspacesError {
    fn code(&self) -> Option<&str> {
        RebootWorkspacesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RebootWorkspacesError {
    pub fn new(kind: RebootWorkspacesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RebootWorkspacesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RebootWorkspacesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for RebootWorkspacesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RebootWorkspacesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RebuildWorkspacesError {
    pub kind: RebuildWorkspacesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RebuildWorkspacesErrorKind {
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RebuildWorkspacesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RebuildWorkspacesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RebuildWorkspacesError {
    fn code(&self) -> Option<&str> {
        RebuildWorkspacesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RebuildWorkspacesError {
    pub fn new(kind: RebuildWorkspacesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RebuildWorkspacesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RebuildWorkspacesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for RebuildWorkspacesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RebuildWorkspacesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RegisterWorkspaceDirectoryError {
    pub kind: RegisterWorkspaceDirectoryErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RegisterWorkspaceDirectoryErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InvalidParameterValuesException(crate::error::InvalidParameterValuesException),
    InvalidResourceStateException(crate::error::InvalidResourceStateException),
    OperationNotSupportedException(crate::error::OperationNotSupportedException),
    ResourceLimitExceededException(crate::error::ResourceLimitExceededException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    UnsupportedNetworkConfigurationException(
        crate::error::UnsupportedNetworkConfigurationException,
    ),
    WorkspacesDefaultRoleNotFoundException(crate::error::WorkspacesDefaultRoleNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RegisterWorkspaceDirectoryError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RegisterWorkspaceDirectoryErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            RegisterWorkspaceDirectoryErrorKind::InvalidParameterValuesException(_inner) => {
                _inner.fmt(f)
            }
            RegisterWorkspaceDirectoryErrorKind::InvalidResourceStateException(_inner) => {
                _inner.fmt(f)
            }
            RegisterWorkspaceDirectoryErrorKind::OperationNotSupportedException(_inner) => {
                _inner.fmt(f)
            }
            RegisterWorkspaceDirectoryErrorKind::ResourceLimitExceededException(_inner) => {
                _inner.fmt(f)
            }
            RegisterWorkspaceDirectoryErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            RegisterWorkspaceDirectoryErrorKind::UnsupportedNetworkConfigurationException(
                _inner,
            ) => _inner.fmt(f),
            RegisterWorkspaceDirectoryErrorKind::WorkspacesDefaultRoleNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            RegisterWorkspaceDirectoryErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RegisterWorkspaceDirectoryError {
    fn code(&self) -> Option<&str> {
        RegisterWorkspaceDirectoryError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RegisterWorkspaceDirectoryError {
    pub fn new(kind: RegisterWorkspaceDirectoryErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RegisterWorkspaceDirectoryErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RegisterWorkspaceDirectoryErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            RegisterWorkspaceDirectoryErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_invalid_parameter_values_exception(&self) -> bool {
        matches!(
            &self.kind,
            RegisterWorkspaceDirectoryErrorKind::InvalidParameterValuesException(_)
        )
    }
    pub fn is_invalid_resource_state_exception(&self) -> bool {
        matches!(
            &self.kind,
            RegisterWorkspaceDirectoryErrorKind::InvalidResourceStateException(_)
        )
    }
    pub fn is_operation_not_supported_exception(&self) -> bool {
        matches!(
            &self.kind,
            RegisterWorkspaceDirectoryErrorKind::OperationNotSupportedException(_)
        )
    }
    pub fn is_resource_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            RegisterWorkspaceDirectoryErrorKind::ResourceLimitExceededException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            RegisterWorkspaceDirectoryErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_unsupported_network_configuration_exception(&self) -> bool {
        matches!(
            &self.kind,
            RegisterWorkspaceDirectoryErrorKind::UnsupportedNetworkConfigurationException(_)
        )
    }
    pub fn is_workspaces_default_role_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            RegisterWorkspaceDirectoryErrorKind::WorkspacesDefaultRoleNotFoundException(_)
        )
    }
}
impl std::error::Error for RegisterWorkspaceDirectoryError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RegisterWorkspaceDirectoryErrorKind::AccessDeniedException(_inner) => Some(_inner),
            RegisterWorkspaceDirectoryErrorKind::InvalidParameterValuesException(_inner) => {
                Some(_inner)
            }
            RegisterWorkspaceDirectoryErrorKind::InvalidResourceStateException(_inner) => {
                Some(_inner)
            }
            RegisterWorkspaceDirectoryErrorKind::OperationNotSupportedException(_inner) => {
                Some(_inner)
            }
            RegisterWorkspaceDirectoryErrorKind::ResourceLimitExceededException(_inner) => {
                Some(_inner)
            }
            RegisterWorkspaceDirectoryErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            RegisterWorkspaceDirectoryErrorKind::UnsupportedNetworkConfigurationException(
                _inner,
            ) => Some(_inner),
            RegisterWorkspaceDirectoryErrorKind::WorkspacesDefaultRoleNotFoundException(_inner) => {
                Some(_inner)
            }
            RegisterWorkspaceDirectoryErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RestoreWorkspaceError {
    pub kind: RestoreWorkspaceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RestoreWorkspaceErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InvalidParameterValuesException(crate::error::InvalidParameterValuesException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RestoreWorkspaceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RestoreWorkspaceErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            RestoreWorkspaceErrorKind::InvalidParameterValuesException(_inner) => _inner.fmt(f),
            RestoreWorkspaceErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            RestoreWorkspaceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RestoreWorkspaceError {
    fn code(&self) -> Option<&str> {
        RestoreWorkspaceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RestoreWorkspaceError {
    pub fn new(kind: RestoreWorkspaceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RestoreWorkspaceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RestoreWorkspaceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            RestoreWorkspaceErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_invalid_parameter_values_exception(&self) -> bool {
        matches!(
            &self.kind,
            RestoreWorkspaceErrorKind::InvalidParameterValuesException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            RestoreWorkspaceErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for RestoreWorkspaceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RestoreWorkspaceErrorKind::AccessDeniedException(_inner) => Some(_inner),
            RestoreWorkspaceErrorKind::InvalidParameterValuesException(_inner) => Some(_inner),
            RestoreWorkspaceErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            RestoreWorkspaceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RevokeIpRulesError {
    pub kind: RevokeIpRulesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RevokeIpRulesErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InvalidParameterValuesException(crate::error::InvalidParameterValuesException),
    InvalidResourceStateException(crate::error::InvalidResourceStateException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RevokeIpRulesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RevokeIpRulesErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            RevokeIpRulesErrorKind::InvalidParameterValuesException(_inner) => _inner.fmt(f),
            RevokeIpRulesErrorKind::InvalidResourceStateException(_inner) => _inner.fmt(f),
            RevokeIpRulesErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            RevokeIpRulesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RevokeIpRulesError {
    fn code(&self) -> Option<&str> {
        RevokeIpRulesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RevokeIpRulesError {
    pub fn new(kind: RevokeIpRulesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RevokeIpRulesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RevokeIpRulesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, RevokeIpRulesErrorKind::AccessDeniedException(_))
    }
    pub fn is_invalid_parameter_values_exception(&self) -> bool {
        matches!(
            &self.kind,
            RevokeIpRulesErrorKind::InvalidParameterValuesException(_)
        )
    }
    pub fn is_invalid_resource_state_exception(&self) -> bool {
        matches!(
            &self.kind,
            RevokeIpRulesErrorKind::InvalidResourceStateException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            RevokeIpRulesErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for RevokeIpRulesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RevokeIpRulesErrorKind::AccessDeniedException(_inner) => Some(_inner),
            RevokeIpRulesErrorKind::InvalidParameterValuesException(_inner) => Some(_inner),
            RevokeIpRulesErrorKind::InvalidResourceStateException(_inner) => Some(_inner),
            RevokeIpRulesErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            RevokeIpRulesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StartWorkspacesError {
    pub kind: StartWorkspacesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StartWorkspacesErrorKind {
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StartWorkspacesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StartWorkspacesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for StartWorkspacesError {
    fn code(&self) -> Option<&str> {
        StartWorkspacesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl StartWorkspacesError {
    pub fn new(kind: StartWorkspacesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StartWorkspacesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StartWorkspacesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for StartWorkspacesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StartWorkspacesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StopWorkspacesError {
    pub kind: StopWorkspacesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StopWorkspacesErrorKind {
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StopWorkspacesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StopWorkspacesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for StopWorkspacesError {
    fn code(&self) -> Option<&str> {
        StopWorkspacesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl StopWorkspacesError {
    pub fn new(kind: StopWorkspacesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StopWorkspacesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StopWorkspacesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for StopWorkspacesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StopWorkspacesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct TerminateWorkspacesError {
    pub kind: TerminateWorkspacesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum TerminateWorkspacesErrorKind {
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for TerminateWorkspacesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            TerminateWorkspacesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for TerminateWorkspacesError {
    fn code(&self) -> Option<&str> {
        TerminateWorkspacesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl TerminateWorkspacesError {
    pub fn new(kind: TerminateWorkspacesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: TerminateWorkspacesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: TerminateWorkspacesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for TerminateWorkspacesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            TerminateWorkspacesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateConnectionAliasPermissionError {
    pub kind: UpdateConnectionAliasPermissionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateConnectionAliasPermissionErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InvalidParameterValuesException(crate::error::InvalidParameterValuesException),
    InvalidResourceStateException(crate::error::InvalidResourceStateException),
    OperationNotSupportedException(crate::error::OperationNotSupportedException),
    ResourceAssociatedException(crate::error::ResourceAssociatedException),
    ResourceLimitExceededException(crate::error::ResourceLimitExceededException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateConnectionAliasPermissionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateConnectionAliasPermissionErrorKind::AccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            UpdateConnectionAliasPermissionErrorKind::InvalidParameterValuesException(_inner) => {
                _inner.fmt(f)
            }
            UpdateConnectionAliasPermissionErrorKind::InvalidResourceStateException(_inner) => {
                _inner.fmt(f)
            }
            UpdateConnectionAliasPermissionErrorKind::OperationNotSupportedException(_inner) => {
                _inner.fmt(f)
            }
            UpdateConnectionAliasPermissionErrorKind::ResourceAssociatedException(_inner) => {
                _inner.fmt(f)
            }
            UpdateConnectionAliasPermissionErrorKind::ResourceLimitExceededException(_inner) => {
                _inner.fmt(f)
            }
            UpdateConnectionAliasPermissionErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            UpdateConnectionAliasPermissionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateConnectionAliasPermissionError {
    fn code(&self) -> Option<&str> {
        UpdateConnectionAliasPermissionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateConnectionAliasPermissionError {
    pub fn new(kind: UpdateConnectionAliasPermissionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateConnectionAliasPermissionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateConnectionAliasPermissionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateConnectionAliasPermissionErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_invalid_parameter_values_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateConnectionAliasPermissionErrorKind::InvalidParameterValuesException(_)
        )
    }
    pub fn is_invalid_resource_state_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateConnectionAliasPermissionErrorKind::InvalidResourceStateException(_)
        )
    }
    pub fn is_operation_not_supported_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateConnectionAliasPermissionErrorKind::OperationNotSupportedException(_)
        )
    }
    pub fn is_resource_associated_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateConnectionAliasPermissionErrorKind::ResourceAssociatedException(_)
        )
    }
    pub fn is_resource_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateConnectionAliasPermissionErrorKind::ResourceLimitExceededException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateConnectionAliasPermissionErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for UpdateConnectionAliasPermissionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateConnectionAliasPermissionErrorKind::AccessDeniedException(_inner) => Some(_inner),
            UpdateConnectionAliasPermissionErrorKind::InvalidParameterValuesException(_inner) => {
                Some(_inner)
            }
            UpdateConnectionAliasPermissionErrorKind::InvalidResourceStateException(_inner) => {
                Some(_inner)
            }
            UpdateConnectionAliasPermissionErrorKind::OperationNotSupportedException(_inner) => {
                Some(_inner)
            }
            UpdateConnectionAliasPermissionErrorKind::ResourceAssociatedException(_inner) => {
                Some(_inner)
            }
            UpdateConnectionAliasPermissionErrorKind::ResourceLimitExceededException(_inner) => {
                Some(_inner)
            }
            UpdateConnectionAliasPermissionErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            UpdateConnectionAliasPermissionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateRulesOfIpGroupError {
    pub kind: UpdateRulesOfIpGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateRulesOfIpGroupErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InvalidParameterValuesException(crate::error::InvalidParameterValuesException),
    InvalidResourceStateException(crate::error::InvalidResourceStateException),
    ResourceLimitExceededException(crate::error::ResourceLimitExceededException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateRulesOfIpGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateRulesOfIpGroupErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            UpdateRulesOfIpGroupErrorKind::InvalidParameterValuesException(_inner) => _inner.fmt(f),
            UpdateRulesOfIpGroupErrorKind::InvalidResourceStateException(_inner) => _inner.fmt(f),
            UpdateRulesOfIpGroupErrorKind::ResourceLimitExceededException(_inner) => _inner.fmt(f),
            UpdateRulesOfIpGroupErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateRulesOfIpGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateRulesOfIpGroupError {
    fn code(&self) -> Option<&str> {
        UpdateRulesOfIpGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateRulesOfIpGroupError {
    pub fn new(kind: UpdateRulesOfIpGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateRulesOfIpGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateRulesOfIpGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRulesOfIpGroupErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_invalid_parameter_values_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRulesOfIpGroupErrorKind::InvalidParameterValuesException(_)
        )
    }
    pub fn is_invalid_resource_state_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRulesOfIpGroupErrorKind::InvalidResourceStateException(_)
        )
    }
    pub fn is_resource_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRulesOfIpGroupErrorKind::ResourceLimitExceededException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRulesOfIpGroupErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for UpdateRulesOfIpGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateRulesOfIpGroupErrorKind::AccessDeniedException(_inner) => Some(_inner),
            UpdateRulesOfIpGroupErrorKind::InvalidParameterValuesException(_inner) => Some(_inner),
            UpdateRulesOfIpGroupErrorKind::InvalidResourceStateException(_inner) => Some(_inner),
            UpdateRulesOfIpGroupErrorKind::ResourceLimitExceededException(_inner) => Some(_inner),
            UpdateRulesOfIpGroupErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateRulesOfIpGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateWorkspaceBundleError {
    pub kind: UpdateWorkspaceBundleErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateWorkspaceBundleErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InvalidParameterValuesException(crate::error::InvalidParameterValuesException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ResourceUnavailableException(crate::error::ResourceUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateWorkspaceBundleError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateWorkspaceBundleErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            UpdateWorkspaceBundleErrorKind::InvalidParameterValuesException(_inner) => {
                _inner.fmt(f)
            }
            UpdateWorkspaceBundleErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateWorkspaceBundleErrorKind::ResourceUnavailableException(_inner) => _inner.fmt(f),
            UpdateWorkspaceBundleErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateWorkspaceBundleError {
    fn code(&self) -> Option<&str> {
        UpdateWorkspaceBundleError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateWorkspaceBundleError {
    pub fn new(kind: UpdateWorkspaceBundleErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateWorkspaceBundleErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateWorkspaceBundleErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateWorkspaceBundleErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_invalid_parameter_values_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateWorkspaceBundleErrorKind::InvalidParameterValuesException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateWorkspaceBundleErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_resource_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateWorkspaceBundleErrorKind::ResourceUnavailableException(_)
        )
    }
}
impl std::error::Error for UpdateWorkspaceBundleError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateWorkspaceBundleErrorKind::AccessDeniedException(_inner) => Some(_inner),
            UpdateWorkspaceBundleErrorKind::InvalidParameterValuesException(_inner) => Some(_inner),
            UpdateWorkspaceBundleErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateWorkspaceBundleErrorKind::ResourceUnavailableException(_inner) => Some(_inner),
            UpdateWorkspaceBundleErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateWorkspaceImagePermissionError {
    pub kind: UpdateWorkspaceImagePermissionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateWorkspaceImagePermissionErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InvalidParameterValuesException(crate::error::InvalidParameterValuesException),
    OperationNotSupportedException(crate::error::OperationNotSupportedException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ResourceUnavailableException(crate::error::ResourceUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateWorkspaceImagePermissionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateWorkspaceImagePermissionErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            UpdateWorkspaceImagePermissionErrorKind::InvalidParameterValuesException(_inner) => {
                _inner.fmt(f)
            }
            UpdateWorkspaceImagePermissionErrorKind::OperationNotSupportedException(_inner) => {
                _inner.fmt(f)
            }
            UpdateWorkspaceImagePermissionErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            UpdateWorkspaceImagePermissionErrorKind::ResourceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            UpdateWorkspaceImagePermissionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateWorkspaceImagePermissionError {
    fn code(&self) -> Option<&str> {
        UpdateWorkspaceImagePermissionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateWorkspaceImagePermissionError {
    pub fn new(kind: UpdateWorkspaceImagePermissionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateWorkspaceImagePermissionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateWorkspaceImagePermissionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateWorkspaceImagePermissionErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_invalid_parameter_values_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateWorkspaceImagePermissionErrorKind::InvalidParameterValuesException(_)
        )
    }
    pub fn is_operation_not_supported_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateWorkspaceImagePermissionErrorKind::OperationNotSupportedException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateWorkspaceImagePermissionErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_resource_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateWorkspaceImagePermissionErrorKind::ResourceUnavailableException(_)
        )
    }
}
impl std::error::Error for UpdateWorkspaceImagePermissionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateWorkspaceImagePermissionErrorKind::AccessDeniedException(_inner) => Some(_inner),
            UpdateWorkspaceImagePermissionErrorKind::InvalidParameterValuesException(_inner) => {
                Some(_inner)
            }
            UpdateWorkspaceImagePermissionErrorKind::OperationNotSupportedException(_inner) => {
                Some(_inner)
            }
            UpdateWorkspaceImagePermissionErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            UpdateWorkspaceImagePermissionErrorKind::ResourceUnavailableException(_inner) => {
                Some(_inner)
            }
            UpdateWorkspaceImagePermissionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// <p>The specified resource is not available.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceUnavailableException {
    /// <p>The exception error message.</p>
    pub message: std::option::Option<std::string::String>,
    /// <p>The identifier of the resource that is not available.</p>
    pub resource_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ResourceUnavailableException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceUnavailableException");
        formatter.field("message", &self.message);
        formatter.field("resource_id", &self.resource_id);
        formatter.finish()
    }
}
impl ResourceUnavailableException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ResourceUnavailableException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResourceUnavailableException")?;
        if let Some(inner_1) = &self.message {
            write!(f, ": {}", inner_1)?;
        }
        Ok(())
    }
}
impl std::error::Error for ResourceUnavailableException {}
/// See [`ResourceUnavailableException`](crate::error::ResourceUnavailableException)
pub mod resource_unavailable_exception {
    /// A builder for [`ResourceUnavailableException`](crate::error::ResourceUnavailableException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) resource_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The exception error message.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>The identifier of the resource that is not available.</p>
        pub fn resource_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_id = Some(input.into());
            self
        }
        pub fn set_resource_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_id = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceUnavailableException`](crate::error::ResourceUnavailableException)
        pub fn build(self) -> crate::error::ResourceUnavailableException {
            crate::error::ResourceUnavailableException {
                message: self.message,
                resource_id: self.resource_id,
            }
        }
    }
}
impl ResourceUnavailableException {
    /// Creates a new builder-style object to manufacture [`ResourceUnavailableException`](crate::error::ResourceUnavailableException)
    pub fn builder() -> crate::error::resource_unavailable_exception::Builder {
        crate::error::resource_unavailable_exception::Builder::default()
    }
}

/// <p>The resource could not be found.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceNotFoundException {
    /// <p>The resource could not be found.</p>
    pub message: std::option::Option<std::string::String>,
    /// <p>The ID of the resource that could not be found.</p>
    pub resource_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ResourceNotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceNotFoundException");
        formatter.field("message", &self.message);
        formatter.field("resource_id", &self.resource_id);
        formatter.finish()
    }
}
impl ResourceNotFoundException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ResourceNotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResourceNotFoundException")?;
        if let Some(inner_2) = &self.message {
            write!(f, ": {}", inner_2)?;
        }
        Ok(())
    }
}
impl std::error::Error for ResourceNotFoundException {}
/// See [`ResourceNotFoundException`](crate::error::ResourceNotFoundException)
pub mod resource_not_found_exception {
    /// A builder for [`ResourceNotFoundException`](crate::error::ResourceNotFoundException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) resource_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The resource could not be found.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>The ID of the resource that could not be found.</p>
        pub fn resource_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_id = Some(input.into());
            self
        }
        pub fn set_resource_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_id = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceNotFoundException`](crate::error::ResourceNotFoundException)
        pub fn build(self) -> crate::error::ResourceNotFoundException {
            crate::error::ResourceNotFoundException {
                message: self.message,
                resource_id: self.resource_id,
            }
        }
    }
}
impl ResourceNotFoundException {
    /// Creates a new builder-style object to manufacture [`ResourceNotFoundException`](crate::error::ResourceNotFoundException)
    pub fn builder() -> crate::error::resource_not_found_exception::Builder {
        crate::error::resource_not_found_exception::Builder::default()
    }
}

/// <p>This operation is not supported.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct OperationNotSupportedException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for OperationNotSupportedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("OperationNotSupportedException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl OperationNotSupportedException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for OperationNotSupportedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "OperationNotSupportedException")?;
        if let Some(inner_3) = &self.message {
            write!(f, ": {}", inner_3)?;
        }
        Ok(())
    }
}
impl std::error::Error for OperationNotSupportedException {}
/// See [`OperationNotSupportedException`](crate::error::OperationNotSupportedException)
pub mod operation_not_supported_exception {
    /// A builder for [`OperationNotSupportedException`](crate::error::OperationNotSupportedException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`OperationNotSupportedException`](crate::error::OperationNotSupportedException)
        pub fn build(self) -> crate::error::OperationNotSupportedException {
            crate::error::OperationNotSupportedException {
                message: self.message,
            }
        }
    }
}
impl OperationNotSupportedException {
    /// Creates a new builder-style object to manufacture [`OperationNotSupportedException`](crate::error::OperationNotSupportedException)
    pub fn builder() -> crate::error::operation_not_supported_exception::Builder {
        crate::error::operation_not_supported_exception::Builder::default()
    }
}

/// <p>One or more parameter values are not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidParameterValuesException {
    /// <p>The exception error message.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidParameterValuesException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidParameterValuesException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidParameterValuesException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidParameterValuesException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidParameterValuesException")?;
        if let Some(inner_4) = &self.message {
            write!(f, ": {}", inner_4)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidParameterValuesException {}
/// See [`InvalidParameterValuesException`](crate::error::InvalidParameterValuesException)
pub mod invalid_parameter_values_exception {
    /// A builder for [`InvalidParameterValuesException`](crate::error::InvalidParameterValuesException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The exception error message.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidParameterValuesException`](crate::error::InvalidParameterValuesException)
        pub fn build(self) -> crate::error::InvalidParameterValuesException {
            crate::error::InvalidParameterValuesException {
                message: self.message,
            }
        }
    }
}
impl InvalidParameterValuesException {
    /// Creates a new builder-style object to manufacture [`InvalidParameterValuesException`](crate::error::InvalidParameterValuesException)
    pub fn builder() -> crate::error::invalid_parameter_values_exception::Builder {
        crate::error::invalid_parameter_values_exception::Builder::default()
    }
}

/// <p>The user is not authorized to access a resource.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AccessDeniedException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AccessDeniedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AccessDeniedException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl AccessDeniedException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for AccessDeniedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "AccessDeniedException")?;
        if let Some(inner_5) = &self.message {
            write!(f, ": {}", inner_5)?;
        }
        Ok(())
    }
}
impl std::error::Error for AccessDeniedException {}
/// See [`AccessDeniedException`](crate::error::AccessDeniedException)
pub mod access_denied_exception {
    /// A builder for [`AccessDeniedException`](crate::error::AccessDeniedException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`AccessDeniedException`](crate::error::AccessDeniedException)
        pub fn build(self) -> crate::error::AccessDeniedException {
            crate::error::AccessDeniedException {
                message: self.message,
            }
        }
    }
}
impl AccessDeniedException {
    /// Creates a new builder-style object to manufacture [`AccessDeniedException`](crate::error::AccessDeniedException)
    pub fn builder() -> crate::error::access_denied_exception::Builder {
        crate::error::access_denied_exception::Builder::default()
    }
}

/// <p>Your resource limits have been exceeded.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceLimitExceededException {
    /// <p>The exception error message.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ResourceLimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceLimitExceededException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ResourceLimitExceededException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ResourceLimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResourceLimitExceededException")?;
        if let Some(inner_6) = &self.message {
            write!(f, ": {}", inner_6)?;
        }
        Ok(())
    }
}
impl std::error::Error for ResourceLimitExceededException {}
/// See [`ResourceLimitExceededException`](crate::error::ResourceLimitExceededException)
pub mod resource_limit_exceeded_exception {
    /// A builder for [`ResourceLimitExceededException`](crate::error::ResourceLimitExceededException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The exception error message.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceLimitExceededException`](crate::error::ResourceLimitExceededException)
        pub fn build(self) -> crate::error::ResourceLimitExceededException {
            crate::error::ResourceLimitExceededException {
                message: self.message,
            }
        }
    }
}
impl ResourceLimitExceededException {
    /// Creates a new builder-style object to manufacture [`ResourceLimitExceededException`](crate::error::ResourceLimitExceededException)
    pub fn builder() -> crate::error::resource_limit_exceeded_exception::Builder {
        crate::error::resource_limit_exceeded_exception::Builder::default()
    }
}

/// <p>The state of the resource is not valid for this operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidResourceStateException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidResourceStateException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidResourceStateException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidResourceStateException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidResourceStateException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidResourceStateException")?;
        if let Some(inner_7) = &self.message {
            write!(f, ": {}", inner_7)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidResourceStateException {}
/// See [`InvalidResourceStateException`](crate::error::InvalidResourceStateException)
pub mod invalid_resource_state_exception {
    /// A builder for [`InvalidResourceStateException`](crate::error::InvalidResourceStateException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidResourceStateException`](crate::error::InvalidResourceStateException)
        pub fn build(self) -> crate::error::InvalidResourceStateException {
            crate::error::InvalidResourceStateException {
                message: self.message,
            }
        }
    }
}
impl InvalidResourceStateException {
    /// Creates a new builder-style object to manufacture [`InvalidResourceStateException`](crate::error::InvalidResourceStateException)
    pub fn builder() -> crate::error::invalid_resource_state_exception::Builder {
        crate::error::invalid_resource_state_exception::Builder::default()
    }
}

/// <p>The resource is associated with a directory.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceAssociatedException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ResourceAssociatedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceAssociatedException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ResourceAssociatedException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ResourceAssociatedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResourceAssociatedException")?;
        if let Some(inner_8) = &self.message {
            write!(f, ": {}", inner_8)?;
        }
        Ok(())
    }
}
impl std::error::Error for ResourceAssociatedException {}
/// See [`ResourceAssociatedException`](crate::error::ResourceAssociatedException)
pub mod resource_associated_exception {
    /// A builder for [`ResourceAssociatedException`](crate::error::ResourceAssociatedException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceAssociatedException`](crate::error::ResourceAssociatedException)
        pub fn build(self) -> crate::error::ResourceAssociatedException {
            crate::error::ResourceAssociatedException {
                message: self.message,
            }
        }
    }
}
impl ResourceAssociatedException {
    /// Creates a new builder-style object to manufacture [`ResourceAssociatedException`](crate::error::ResourceAssociatedException)
    pub fn builder() -> crate::error::resource_associated_exception::Builder {
        crate::error::resource_associated_exception::Builder::default()
    }
}

/// <p>The workspaces_DefaultRole role could not be found. If this is the first time you are registering a directory, you
/// will need to create the workspaces_DefaultRole role before you can register a directory. For more information, see <a href="https://docs.aws.amazon.com/workspaces/latest/adminguide/workspaces-access-control.html#create-default-role">Creating the workspaces_DefaultRole Role</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct WorkspacesDefaultRoleNotFoundException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for WorkspacesDefaultRoleNotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("WorkspacesDefaultRoleNotFoundException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl WorkspacesDefaultRoleNotFoundException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for WorkspacesDefaultRoleNotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "WorkspacesDefaultRoleNotFoundException")?;
        if let Some(inner_9) = &self.message {
            write!(f, ": {}", inner_9)?;
        }
        Ok(())
    }
}
impl std::error::Error for WorkspacesDefaultRoleNotFoundException {}
/// See [`WorkspacesDefaultRoleNotFoundException`](crate::error::WorkspacesDefaultRoleNotFoundException)
pub mod workspaces_default_role_not_found_exception {
    /// A builder for [`WorkspacesDefaultRoleNotFoundException`](crate::error::WorkspacesDefaultRoleNotFoundException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`WorkspacesDefaultRoleNotFoundException`](crate::error::WorkspacesDefaultRoleNotFoundException)
        pub fn build(self) -> crate::error::WorkspacesDefaultRoleNotFoundException {
            crate::error::WorkspacesDefaultRoleNotFoundException {
                message: self.message,
            }
        }
    }
}
impl WorkspacesDefaultRoleNotFoundException {
    /// Creates a new builder-style object to manufacture [`WorkspacesDefaultRoleNotFoundException`](crate::error::WorkspacesDefaultRoleNotFoundException)
    pub fn builder() -> crate::error::workspaces_default_role_not_found_exception::Builder {
        crate::error::workspaces_default_role_not_found_exception::Builder::default()
    }
}

/// <p>The configuration of this network is not supported for this operation, or your network configuration
/// conflicts with the Amazon WorkSpaces management network IP range. For more information, see
/// <a href="https://docs.aws.amazon.com/workspaces/latest/adminguide/amazon-workspaces-vpc.html">
/// Configure a VPC for Amazon WorkSpaces</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UnsupportedNetworkConfigurationException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UnsupportedNetworkConfigurationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UnsupportedNetworkConfigurationException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl UnsupportedNetworkConfigurationException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for UnsupportedNetworkConfigurationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "UnsupportedNetworkConfigurationException")?;
        if let Some(inner_10) = &self.message {
            write!(f, ": {}", inner_10)?;
        }
        Ok(())
    }
}
impl std::error::Error for UnsupportedNetworkConfigurationException {}
/// See [`UnsupportedNetworkConfigurationException`](crate::error::UnsupportedNetworkConfigurationException)
pub mod unsupported_network_configuration_exception {
    /// A builder for [`UnsupportedNetworkConfigurationException`](crate::error::UnsupportedNetworkConfigurationException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`UnsupportedNetworkConfigurationException`](crate::error::UnsupportedNetworkConfigurationException)
        pub fn build(self) -> crate::error::UnsupportedNetworkConfigurationException {
            crate::error::UnsupportedNetworkConfigurationException {
                message: self.message,
            }
        }
    }
}
impl UnsupportedNetworkConfigurationException {
    /// Creates a new builder-style object to manufacture [`UnsupportedNetworkConfigurationException`](crate::error::UnsupportedNetworkConfigurationException)
    pub fn builder() -> crate::error::unsupported_network_configuration_exception::Builder {
        crate::error::unsupported_network_configuration_exception::Builder::default()
    }
}

/// <p>The configuration of this WorkSpace is not supported for this operation. For more information, see  
/// <a href="https://docs.aws.amazon.com/workspaces/latest/adminguide/required-service-components.html">Required
/// Configuration and Service Components for WorkSpaces </a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UnsupportedWorkspaceConfigurationException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UnsupportedWorkspaceConfigurationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UnsupportedWorkspaceConfigurationException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl UnsupportedWorkspaceConfigurationException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for UnsupportedWorkspaceConfigurationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "UnsupportedWorkspaceConfigurationException")?;
        if let Some(inner_11) = &self.message {
            write!(f, ": {}", inner_11)?;
        }
        Ok(())
    }
}
impl std::error::Error for UnsupportedWorkspaceConfigurationException {}
/// See [`UnsupportedWorkspaceConfigurationException`](crate::error::UnsupportedWorkspaceConfigurationException)
pub mod unsupported_workspace_configuration_exception {
    /// A builder for [`UnsupportedWorkspaceConfigurationException`](crate::error::UnsupportedWorkspaceConfigurationException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`UnsupportedWorkspaceConfigurationException`](crate::error::UnsupportedWorkspaceConfigurationException)
        pub fn build(self) -> crate::error::UnsupportedWorkspaceConfigurationException {
            crate::error::UnsupportedWorkspaceConfigurationException {
                message: self.message,
            }
        }
    }
}
impl UnsupportedWorkspaceConfigurationException {
    /// Creates a new builder-style object to manufacture [`UnsupportedWorkspaceConfigurationException`](crate::error::UnsupportedWorkspaceConfigurationException)
    pub fn builder() -> crate::error::unsupported_workspace_configuration_exception::Builder {
        crate::error::unsupported_workspace_configuration_exception::Builder::default()
    }
}

/// <p>The properties of this WorkSpace are currently being modified. Try again in a moment.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct OperationInProgressException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for OperationInProgressException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("OperationInProgressException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl OperationInProgressException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for OperationInProgressException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "OperationInProgressException")?;
        if let Some(inner_12) = &self.message {
            write!(f, ": {}", inner_12)?;
        }
        Ok(())
    }
}
impl std::error::Error for OperationInProgressException {}
/// See [`OperationInProgressException`](crate::error::OperationInProgressException)
pub mod operation_in_progress_exception {
    /// A builder for [`OperationInProgressException`](crate::error::OperationInProgressException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`OperationInProgressException`](crate::error::OperationInProgressException)
        pub fn build(self) -> crate::error::OperationInProgressException {
            crate::error::OperationInProgressException {
                message: self.message,
            }
        }
    }
}
impl OperationInProgressException {
    /// Creates a new builder-style object to manufacture [`OperationInProgressException`](crate::error::OperationInProgressException)
    pub fn builder() -> crate::error::operation_in_progress_exception::Builder {
        crate::error::operation_in_progress_exception::Builder::default()
    }
}

/// <p>The specified resource already exists.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceAlreadyExistsException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ResourceAlreadyExistsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceAlreadyExistsException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ResourceAlreadyExistsException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ResourceAlreadyExistsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResourceAlreadyExistsException")?;
        if let Some(inner_13) = &self.message {
            write!(f, ": {}", inner_13)?;
        }
        Ok(())
    }
}
impl std::error::Error for ResourceAlreadyExistsException {}
/// See [`ResourceAlreadyExistsException`](crate::error::ResourceAlreadyExistsException)
pub mod resource_already_exists_exception {
    /// A builder for [`ResourceAlreadyExistsException`](crate::error::ResourceAlreadyExistsException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceAlreadyExistsException`](crate::error::ResourceAlreadyExistsException)
        pub fn build(self) -> crate::error::ResourceAlreadyExistsException {
            crate::error::ResourceAlreadyExistsException {
                message: self.message,
            }
        }
    }
}
impl ResourceAlreadyExistsException {
    /// Creates a new builder-style object to manufacture [`ResourceAlreadyExistsException`](crate::error::ResourceAlreadyExistsException)
    pub fn builder() -> crate::error::resource_already_exists_exception::Builder {
        crate::error::resource_already_exists_exception::Builder::default()
    }
}

/// <p>The resource could not be created.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceCreationFailedException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ResourceCreationFailedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceCreationFailedException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ResourceCreationFailedException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ResourceCreationFailedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResourceCreationFailedException")?;
        if let Some(inner_14) = &self.message {
            write!(f, ": {}", inner_14)?;
        }
        Ok(())
    }
}
impl std::error::Error for ResourceCreationFailedException {}
/// See [`ResourceCreationFailedException`](crate::error::ResourceCreationFailedException)
pub mod resource_creation_failed_exception {
    /// A builder for [`ResourceCreationFailedException`](crate::error::ResourceCreationFailedException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceCreationFailedException`](crate::error::ResourceCreationFailedException)
        pub fn build(self) -> crate::error::ResourceCreationFailedException {
            crate::error::ResourceCreationFailedException {
                message: self.message,
            }
        }
    }
}
impl ResourceCreationFailedException {
    /// Creates a new builder-style object to manufacture [`ResourceCreationFailedException`](crate::error::ResourceCreationFailedException)
    pub fn builder() -> crate::error::resource_creation_failed_exception::Builder {
        crate::error::resource_creation_failed_exception::Builder::default()
    }
}
